1	public void populateDisplayData ( DisplayData . Builder builder ) { Set < PipelineOptionSpec > optionSpecs = PipelineOptionsReflector . getOptionSpecs ( knownInterfaces ) ; Multimap < String , PipelineOptionSpec > optionsMap = buildOptionNameToSpecMap ( optionSpecs ) ; for ( Map . Entry < String , BoundValue > option : options . entrySet ( ) ) { BoundValue boundValue = option . getValue ( ) ; if ( boundValue . isDefault ( ) ) { continue ; } DisplayDataValue resolved = DisplayDataValue . resolve ( boundValue . getValue ( ) ) ; HashSet < PipelineOptionSpec > specs = new HashSet < > ( optionsMap . get ( option . getKey ( ) ) ) ; for ( PipelineOptionSpec optionSpec : specs ) { if ( ! optionSpec . shouldSerialize ( ) ) { excluded from display data . These options are generally not useful for display . continue ; } builder . add ( DisplayData . item ( option . getKey ( ) , resolved . getType ( ) , resolved . getValue ( ) ) . withNamespace ( optionSpec . getDefiningInterface ( ) ) ) ; } } for ( Map . Entry < String , JsonNode > jsonOption : jsonOptions . entrySet ( ) ) { if ( options . containsKey ( jsonOption . getKey ( ) ) ) { Option overwritten since deserialization ; don ' t re - write continue ; } HashSet < PipelineOptionSpec > specs = new HashSet < > ( optionsMap . get ( jsonOption . getKey ( ) ) ) ; if ( specs . isEmpty ( ) ) { No PipelineOptions interface for this key not currently loaded builder . add ( DisplayData . item ( jsonOption . getKey ( ) , jsonOption . getValue ( ) . toString ( ) ) . withNamespace ( UnknownPipelineOptions . class ) ) ; continue ; } for ( PipelineOptionSpec spec : specs ) { if ( ! spec . shouldSerialize ( ) ) { continue ; } Object value = getValueFromJson ( jsonOption . getKey ( ) , spec . getGetterMethod ( ) ) ; DisplayDataValue resolved = DisplayDataValue . resolve ( value ) ; builder . add ( DisplayData . item ( jsonOption . getKey ( ) , resolved . getType ( ) , resolved . getValue ( ) ) . withNamespace ( spec . getDefiningInterface ( ) ) ) ; } } } 
2	public void insertTextAsOnly _NUM ( ) throws IOException { final Data data = context . data ( ) ; final int nextid = data . meta . lastid ; insertText ( _NUM , _NUM , T _ JUNIT , Data . TEXT ) ; assertEquals ( size + _NUM , data . meta . size ) ; assertEquals ( _NUM , data . parent ( _NUM , Data . TEXT ) ) ; assertEquals ( Data . ATTR , data . kind ( _NUM ) ) ; assertEquals ( Data . ELEM , data . kind ( _NUM ) ) ; assertEquals ( _NUM , data . parent ( _NUM , Data . ELEM ) ) ; assertEquals ( _NUM , data . parent ( _NUM , Data . ELEM ) ) ; assertEquals ( nextid + _NUM , data . meta . lastid ) ; assertArraysEquals ( T _ JUNIT , data . atom ( _NUM ) ) ; reload ( ) ; assertEquals ( size + _NUM , data . meta . size ) ; assertEquals ( _NUM , data . parent ( _NUM , Data . TEXT ) ) ; assertEquals ( Data . ATTR , data . kind ( _NUM ) ) ; assertEquals ( Data . ELEM , data . kind ( _NUM ) ) ; assertEquals ( _NUM , data . parent ( _NUM , Data . ELEM ) ) ; assertEquals ( _NUM , data . parent ( _NUM , Data . ELEM ) ) ; assertEquals ( nextid + _NUM , data . meta . lastid ) ; assertArraysEquals ( T _ JUNIT , data . atom ( _NUM ) ) ; } 
3	private String checkDependencies ( ITestNGMethod testMethod , ITestNGMethod [ ] allTestMethods ) { If this method is marked alwaysRun , no need to check for its dependencies if ( testMethod . isAlwaysRun ( ) ) { return null ; } Any missing group ? if ( testMethod . getMissingGroup ( ) ! = null & & ! testMethod . ignoreMissingDependencies ( ) ) { return _STR ; } } return null ; } 
4	private long recoverLastPersistedJournalEntry ( ) throws IOException { UfsJournalSnapshot snapshot = UfsJournalSnapshot . getSnapshot ( mJournal ) ; long lastPersistSeq = - _NUM ; UfsJournalFile currentLog = snapshot . getCurrentLog ( mJournal ) ; if ( currentLog ! = null ) { long startSeq = currentLog . getStart ( ) ; LOG . info ( _STR , lastPersistSeq , journal . getLocation ( ) . toString ( ) ) ; } } return lastPersistSeq ; } 
5	public void close ( ) { throwIfCurrentPageNotFinished ( ) ; dispose ( ) ; } 
6	public void testReduceCase ( ) throws Exception { HepProgram program = new HepProgramBuilder ( ) . addRuleInstance ( ReduceExpressionsRule . PROJECT _ INSTANCE ) . build ( ) ; final String sql = _STR ; sql ( sql ) . with ( program ) . withProperty ( Hook . REL _ BUILDER _ SIMPLIFY , false ) . check ( ) ; } 
7	public static org . apache . xmlbeans . xml . stream . XMLInputStream newValidatingXMLInputStream ( org . apache . xmlbeans . xml . stream . XMLInputStream xis , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , org . apache . xmlbeans . xml . stream . XMLStreamException { return XmlBeans . getContextTypeLoader ( ) . newValidatingXMLInputStream ( xis , type , options ) ; } 
8	private String [ ] extractHeader ( ) throws SchemaChangeException , IOException , ExecutionSetupException { assert ( settings . isHeaderExtractionEnabled ( ) ) ; assert ( oContext ! = null ) ; don ' t skip header in case skipFirstLine is set true settings . setSkipFirstLine ( false ) ; HeaderBuilder hOutput = new HeaderBuilder ( ) ; setup Input using InputStream we should read file header irrespective of split given given to this reader InputStream hStream = dfs . openPossiblyCompressedStream ( split . getPath ( ) ) ; TextInput hInput = new TextInput ( settings , hStream , oContext . getManagedBuffer ( READ _ BUFFER ) , _NUM , split . getLength ( ) ) ; setup Reader using Input and Output this . reader = new TextReader ( settings , hInput , hOutput , oContext . getManagedBuffer ( WHITE _ SPACE _ BUFFER ) ) ; reader . start ( ) ; extract first row only reader . parseNext ( ) ; grab the field names from output String [ ] fieldNames = hOutput . getHeaders ( ) ; cleanup and set to skip the first line next time we read input reader . close ( ) ; settings . setSkipFirstLine ( true ) ; return fieldNames ; } 
9	private String formatSaltForScrypt ( byte [ ] salt ) { if ( salt = = null | | salt . length = = _NUM ) { throw new IllegalArgumentException ( _STR ) ; } return Scrypt . formatSalt ( salt , n , r , p ) ; } } 
10	public synchronized void clear ( ) { remove all objects from the linked list from the tail to the head : I _ CmsLruCacheObject currentObject = m _ listTail ; while ( currentObject ! = null ) { currentObject = currentObject . getNextLruObject ( ) ; removeTail ( ) ; } reset the data structure m _ objectCosts = _NUM ; m _ objectCount = _NUM ; m _ listHead = null ; m _ listTail = null ; } 
11	public void add ( String name , long value ) { MutableMetric m = metricsMap . get ( name ) ; if ( m ! = null ) { if ( m instanceof MutableStat ) { ( ( MutableStat ) m ) . add ( value ) ; } else { throw new MetricsException ( _STR + name ) ; } } else { default is a rate metric metricsMap . put ( name , newRate ( name ) ) ; add ( name , value ) ; } } 
12	public void setPreferencesFromResource ( @ XmlRes int preferencesResId , @ Nullable String key ) { requirePreferenceManager ( ) ; final PreferenceScreen xmlRoot = mPreferenceManager . inflateFromResource ( mStyledContext , preferencesResId , null ) ; final Preference root ; if ( key ! = null ) { root = xmlRoot . findPreference ( key ) ; if ( ! ( root instanceof PreferenceScreen ) ) { throw new IllegalArgumentException ( _STR ) ; } } else { root = xmlRoot ; } setPreferenceScreen ( ( PreferenceScreen ) root ) ; } 
13	public Builder setCredentials ( org . apache . drill . exec . proto . UserBitShared . UserCredentials . Builder builderForValue ) { if ( credentialsBuilder _ = = null ) { credentials _ = builderForValue . build ( ) ; onChanged ( ) ; } else { credentialsBuilder _ . setMessage ( builderForValue . build ( ) ) ; } bitField _NUM _ | = _NUM x _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM ; return this ; } 
14	 @ GET @ Path ( _STR , BackgroundJobController . getInstance ( context ) . state ( backgroundJobId ) . toString ( ) ) ; return Response . ok ( object ) . build ( ) ; } catch ( WebApplicationException ex ) { throw ex ; } catch ( ItemNotFound itemNotFound ) { throw new NotFoundFormattedException ( itemNotFound . getMessage ( ) , itemNotFound ) ; } catch ( Exception ex ) { throw new ServiceFormattedException ( ex . getMessage ( ) , ex ) ; } } 
15	private void doPartitionErrors ( PartitionOption option ) throws Exception { Context context = prepareDefaultContext ( false ) ; context . put ( PARTITION _ HEADER _ NAME , KafkaPartitionTestUtil . PARTITION _ HEADER ) ; String tempTopic = findUnusedTopic ( ) ; createTopic ( tempTopic , _NUM ) ; final KafkaChannel channel = createChannel ( context ) ; channel . start ( ) ; Transaction tx = channel . getTransaction ( ) ; tx . begin ( ) ; Map < String , String > headers = new HashMap < > ( ) ; switch ( option ) { case VALIDBUTOUTOFRANGE : headers . put ( KafkaPartitionTestUtil . PARTITION _ HEADER , String . valueOf ( DEFAULT _ TOPIC _ PARTITIONS + _NUM ) ) ; break ; case NOTSET : headers . put ( _STR ) ; break ; default : break ; } Event event = EventBuilder . withBody ( String . valueOf ( _NUM ) . getBytes ( ) , headers ) ; channel . put ( event ) ; tx . commit ( ) ; deleteTopic ( tempTopic ) ; } 
16	public Mode [ ] getSupportedModes ( ) { synchronized ( this ) { updateDisplayInfoLocked ( ) ; final Display . Mode [ ] modes = mDisplayInfo . supportedModes ; return Arrays . copyOf ( modes , modes . length ) ; } } 
17	public void protectSheet ( String password ) { if ( password ! = null ) { CTSheetProtection sheetProtection = safeGetProtectionField ( ) ; defaults to xor password setSheetPassword ( password , null ) ; sheetProtection . setSheet ( true ) ; sheetProtection . setScenarios ( true ) ; sheetProtection . setObjects ( true ) ; } else { worksheet . unsetSheetProtection ( ) ; } } 
18	public void invalidateAll ( byte [ ] physicalName ) { for ( GuidePostsKey key : getCache ( ) . asMap ( ) . keySet ( ) ) { if ( Bytes . compareTo ( key . getPhysicalName ( ) , physicalName ) = = _NUM ) { invalidate ( key ) ; } } } 
19	public void analyze ( StringBuilder text ) { if ( ngrams ! = null ) { ngrams . clear ( ) ; sorted = null ; ngramcounts = null ; } word . clear ( ) . append ( SEPARATOR ) ; for ( int i = _NUM ; i < text . length ( ) ; i + + ) { char c = Character . toLowerCase ( text . charAt ( i ) ) ; if ( Character . isLetter ( c ) ) { add ( word . append ( c ) ) ; } else { found word boundary if ( word . length ( ) > _NUM ) { we have a word ! add ( word . append ( SEPARATOR ) ) ; word . clear ( ) . append ( SEPARATOR ) ; } } } if ( word . length ( ) > _NUM ) { we have a word ! add ( word . append ( SEPARATOR ) ) ; } normalize ( ) ; } 
20	public boolean isInstalled ( ) { checkAccessThread ( ) ; return comboBox ! = null ; } 
21	public Reader getReader ( ) throws IOException { String charset = getCharsetFromContentType ( contentType ) ; return charset = = null ? new StringReader ( str ) : new InputStreamReader ( getStream ( ) , charset ) ; } 
22	protected void doFilterInternal ( ServletRequest servletRequest , ServletResponse servletResponse , final FilterChain chain ) throws ServletException , IOException { Throwable t = null ; try { final ServletRequest request = prepareServletRequest ( servletRequest , servletResponse , chain ) ; final ServletResponse response = prepareServletResponse ( request , servletResponse , chain ) ; final Subject subject = createSubject ( request , response ) ; noinspection unchecked subject . execute ( new Callable ( ) { public Object call ( ) throws Exception { updateSessionLastAccessTime ( request , response ) ; executeChain ( request , response , chain ) ; return null ; } } ) ; } catch ( ExecutionException ex ) { t = ex . getCause ( ) ; } catch ( Throwable throwable ) { t = throwable ; } if ( t ! = null ) { if ( t instanceof ServletException ) { throw ( ServletException ) t ; } if ( t instanceof IOException ) { throw ( IOException ) t ; } otherwise it ' s not one of the two exceptions expected by the filter method signature - wrap it in one : String msg = _STR ; throw new ServletException ( msg , t ) ; } } 
23	private short applyUserCellStyle ( HSSFCellStyle style ) { if ( style . getUserStyleName ( ) = = null ) { throw new IllegalArgumentException ( _STR ) ; } InternalWorkbook iwb = _ book . getWorkbook ( ) ; short userXf = - _NUM ; int numfmt = iwb . getNumExFormats ( ) ; for ( short i = _NUM ; i < numfmt ; i + + ) { ExtendedFormatRecord xf = iwb . getExFormatAt ( i ) ; if ( xf . getXFType ( ) = = ExtendedFormatRecord . XF _ CELL & & xf . getParentIndex ( ) = = style . getIndex ( ) ) { userXf = i ; break ; } } short styleIndex ; if ( userXf = = - _NUM ) { ExtendedFormatRecord xfr = iwb . createCellXF ( ) ; xfr . cloneStyleFrom ( iwb . getExFormatAt ( style . getIndex ( ) ) ) ; xfr . setIndentionOptions ( ( short ) _NUM ) ; xfr . setXFType ( ExtendedFormatRecord . XF _ CELL ) ; xfr . setParentIndex ( style . getIndex ( ) ) ; styleIndex = ( short ) numfmt ; } else { styleIndex = userXf ; } return styleIndex ; } 
24	protected void startJvmMonitorProcess ( ) { if ( Configuration . getBoolean ( PropertyKey . MASTER _ JVM _ MONITOR _ ENABLED ) ) { mJvmPauseMonitor = new JvmPauseMonitor ( ) ; mJvmPauseMonitor . start ( ) ; } } 
25	public void removeWindow ( View view ) { mWindowsLock . writeLock ( ) . lock ( ) ; try { mWindows . remove ( view . getRootView ( ) ) ; } finally { mWindowsLock . writeLock ( ) . unlock ( ) ; } fireWindowsChangedEvent ( ) ; } 
26	public DocListAndSet getDocListAndSet ( Query query , List < Query > filterList , Sort lsort , int offset , int len , int flags ) throws IOException { QueryCommand qc = new QueryCommand ( ) ; qc . setQuery ( query ) . setFilterList ( filterList ) . setSort ( lsort ) . setOffset ( offset ) . setLen ( len ) . setFlags ( flags ) . setNeedDocSet ( true ) ; QueryResult qr = new QueryResult ( ) ; search ( qr , qc ) ; return qr . getDocListAndSet ( ) ; } 
27	public void testTxnLogOnly ( ) throws Exception { long peerZxid ; CommmitedLog is empty , we will use txnlog up to lastProcessZxid db . lastProcessedZxid = _NUM ; db . txnLog . add ( createProposal ( _NUM ) ) ; db . txnLog . add ( createProposal ( _NUM ) ) ; db . txnLog . add ( createProposal ( _NUM ) ) ; db . txnLog . add ( createProposal ( _NUM ) ) ; db . txnLog . add ( createProposal ( _NUM ) ) ; db . txnLog . add ( createProposal ( _NUM ) ) ; Peer has zxid that we have never seen peerZxid = _NUM ; assertFalse ( learnerHandler . syncFollower ( peerZxid , db , leader ) ) ; We send TRUNC to _NUM and forward any packet starting at lastProcessedZxid assertOpType ( Leader . TRUNC , _NUM , db . lastProcessedZxid ) ; DIFF + _NUM proposals + _NUM commit assertEquals ( _NUM , learnerHandler . getQueuedPackets ( ) . size ( ) ) ; queuedPacketMatches ( new long [ ] { _NUM , _NUM , _NUM } ) ; reset ( ) ; Peer has zxid in txnlog range peerZxid = _NUM ; assertFalse ( learnerHandler . syncFollower ( peerZxid , db , leader ) ) ; We send DIFF and forward any packet starting at lastProcessedZxid assertOpType ( Leader . DIFF , db . lastProcessedZxid , db . lastProcessedZxid ) ; DIFF + _NUM proposals + _NUM commit assertEquals ( _NUM , learnerHandler . getQueuedPackets ( ) . size ( ) ) ; queuedPacketMatches ( new long [ ] { _NUM , _NUM , _NUM , _NUM } ) ; reset ( ) ; Peer miss the txnlog peerZxid = _NUM ; assertTrue ( learnerHandler . syncFollower ( peerZxid , db , leader ) ) ; We send snap assertEquals ( _NUM , learnerHandler . getQueuedPackets ( ) . size ( ) ) ; reset ( ) ; } 
28	public static IComplexNDArray createComplex ( double [ ] data , int rows , int columns , int [ ] stride , long offset , char ordering ) { int [ ] shape = getEnsuredShape ( rows , columns ) ; checkShapeValues ( shape ) ; IComplexNDArray ret = INSTANCE . createComplex ( data , shape , stride , offset , ordering ) ; logCreationIfNecessary ( ret ) ; return ret ; } 
29	public static XmlNonPositiveInteger parse ( java . io . File f , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( XmlNonPositiveInteger ) XmlBeans . getContextTypeLoader ( ) . parse ( f , type , options ) ; } 
30	public void setActionBar ( @ Nullable Toolbar toolbar ) { final ActionBar ab = getActionBar ( ) ; if ( ab instanceof WindowDecorActionBar ) { throw new IllegalStateException ( _STR ) ; } If we reach here then we ' re setting a new action bar First clear out the MenuInflater to make sure that it is valid for the new Action Bar mMenuInflater = null ; If we have an action bar currently , destroy it if ( ab ! = null ) { ab . onDestroy ( ) ; } if ( toolbar ! = null ) { final ToolbarActionBar tbab = new ToolbarActionBar ( toolbar , getTitle ( ) , this ) ; mActionBar = tbab ; mWindow . setCallback ( tbab . getWrappedWindowCallback ( ) ) ; } else { mActionBar = null ; Re - set the original window callback since we may have already set a Toolbar wrapper mWindow . setCallback ( this ) ; } invalidateOptionsMenu ( ) ; } 
31	public Integer remove ( Object key ) { char k ; if ( key ! = null ) { if ( key instanceof Character ) { k = unwrapKey ( key ) ; } else { return null ; } } else { k = _ map . getNoEntryKey ( ) ; } int v = _ map . remove ( k ) ; check here . if ( v = = _ map . getNoEntryValue ( ) ) { return null ; } else { return wrapValue ( v ) ; } } 
32	private FileStatus toFileStatus ( HarStatus h , Map < String , FileStatus > cache ) throws IOException { FileStatus underlying = null ; if ( cache ! = null ) { underlying = cache . get ( h . partName ) ; } if ( underlying = = null ) { final Path p = h . isDir ? archivePath : new Path ( archivePath , h . partName ) ; underlying = fs . getFileStatus ( p ) ; if ( cache ! = null ) { cache . put ( h . partName , underlying ) ; } } long modTime = _NUM ; int version = metadata . getVersion ( ) ; if ( version < _NUM ) { modTime = underlying . getModificationTime ( ) ; } else if ( version = = _NUM ) { modTime = h . getModificationTime ( ) ; } return new FileStatus ( h . isDir ( ) ? _NUM L : h . getLength ( ) , h . isDir ( ) , underlying . getReplication ( ) , underlying . getBlockSize ( ) , modTime , underlying . getAccessTime ( ) , underlying . getPermission ( ) , underlying . getOwner ( ) , underlying . getGroup ( ) , makeRelative ( this . uri . getPath ( ) , new Path ( h . name ) ) ) ; } 
33	protected void onSizeChanged ( int w , int h , int oldw , int oldh ) { super . onSizeChanged ( w , h , oldw , oldh ) ; mGraphWidth = w ; mGraphHeight = h ; onGraphSizeChanged ( w , h , oldw , oldh ) ; } 
34	private void createEntry ( Document doc , String prevDest , String destination ) { String xpath = getFileXpath ( destination ) ; String type = getType ( destination ) ; if ( ! type . equals ( _STR ) ; } 
35	public final void synpred _NUM _NUM _NUM _ JPA _NUM _ fragment ( ) throws RecognitionException { JPA _NUM . g : _NUM _NUM _NUM : _NUM : ( in _ expression ) JPA _NUM . g : _NUM _NUM _NUM : _NUM : in _ expression { pushFollow ( FOLLOW _ in _ expression _ in _ synpred _NUM _NUM _NUM _ JPA _NUM _NUM _NUM _NUM _NUM ) ; in _ expression ( ) ; state . _ fsp - - ; if ( state . failed ) return ; } } 
36	private static void createImportDirectory ( ) { File importDir = getDataFolder ( IMPORT _ DIR ) ; if ( importDir ! = null ) { if ( importDir . exists ( ) ) { Log . d ( TAG , _STR ) ; } } 
37	public final void doFilter ( ServletRequest request , ServletResponse response , FilterChain filterChain ) throws ServletException , IOException { String alreadyFilteredAttributeName = getAlreadyFilteredAttributeName ( ) ; if ( request . getAttribute ( alreadyFilteredAttributeName ) ! = null ) { log . trace ( _STR , getName ( ) ) ; request . setAttribute ( alreadyFilteredAttributeName , Boolean . TRUE ) ; try { doFilterInternal ( request , response , filterChain ) ; } finally { Once the request has finished , we ' re done and we don ' t need to mark as ' already filtered ' any more . request . removeAttribute ( alreadyFilteredAttributeName ) ; } } } 
38	public void setGradientCenter ( float x , float y ) { mGradientState . setGradientCenter ( x , y ) ; mGradientIsDirty = true ; invalidateSelf ( ) ; } 
39	private static Restriction newSingleIN ( TableMetadata tableMetadata , int index , ByteBuffer . . . values ) { ColumnMetadata columnDef = getClusteringColumnDefinition ( tableMetadata , index ) ; return new SingleColumnRestriction . InRestrictionWithValues ( columnDef , toTerms ( values ) ) ; } 
40	public static synchronized ConfigMethod getInstance ( Class < ? > configInterface , Method method ) { ConfigMethod configMethod = ( ConfigMethod ) configMethods . get ( configInterface , method ) ; if ( configMethod = = null ) { configMethod = newInstance ( configInterface , method ) ; configMethods . put ( configInterface , method , configMethod ) ; } return configMethod ; } 
41	public void notifyDataRefreshed ( String [ ] feeds ) { Process downloaded data parseJSON ( feeds ) ; Enable user interaction mIsInteractionEnabled = true ; allowUserClicks ( ) ; } 
42	public < T _NUM , T _NUM , T _NUM , T _NUM , T _NUM , T _NUM , T _NUM > Tuple _NUM < T _NUM , T _NUM , T _NUM , T _NUM , T _NUM , T _NUM , T _NUM > getTuple ( String outputName _NUM , String outputName _NUM , String outputName _NUM , String outputName _NUM , String outputName _NUM , String outputName _NUM , String outputName _NUM ) { return new Tuple _NUM < > ( ( T _NUM ) outputValue ( outputName _NUM ) , ( T _NUM ) outputValue ( outputName _NUM ) , ( T _NUM ) outputValue ( outputName _NUM ) , ( T _NUM ) outputValue ( outputName _NUM ) , ( T _NUM ) outputValue ( outputName _NUM ) , ( T _NUM ) outputValue ( outputName _NUM ) , ( T _NUM ) outputValue ( outputName _NUM ) ) ; } 
43	public boolean isSet ( _ Fields field ) { if ( field = = null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case SUCCESS : return isSetSuccess ( ) ; case IO : return isSetIo ( ) ; } throw new IllegalStateException ( ) ; } 
44	public DescribeReservedInstancesOfferingsRequest withFilters ( Filter . . . filters ) { if ( getFilters ( ) = = null ) setFilters ( new java . util . ArrayList < Filter > ( filters . length ) ) ; for ( Filter value : filters ) { getFilters ( ) . add ( value ) ; } return this ; } 
45	public ECFieldElement getX ( ) { return normalize ( ) . getXCoord ( ) ; } 
46	public void testSelectivityAggCached ( ) { RelNode rel = convertSql ( _STR ) ; rel . getCluster ( ) . setMetadataProvider ( new CachingRelMetadataProvider ( rel . getCluster ( ) . getMetadataProvider ( ) , rel . getCluster ( ) . getPlanner ( ) ) ) ; final RelMetadataQuery mq = RelMetadataQuery . instance ( ) ; Double result = mq . getSelectivity ( rel , null ) ; assertThat ( result , within ( DEFAULT _ COMP _ SELECTIVITY * DEFAULT _ EQUAL _ SELECTIVITY , EPSILON ) ) ; } 
47	public void test _NUM _ _NUM AuxiliaryOnMediaPlayerFailure ( ) throws Exception { boolean result = false ; String msg = _STR + e ) ; } assertTrue ( msg , result ) ; } 
48	protected Map < String , Table > parseSelectFromClause ( Marker start ) { Map < String , Table > tablesByAlias = new HashMap < > ( ) ; if ( tokens . canConsume ( _STR ) ) { try { parseAliasedTableInFrom ( start , tablesByAlias ) ; while ( tokens . canConsume ( ' , ' ) | | canConsumeJoin ( start ) ) { parseAliasedTableInFrom ( start , tablesByAlias ) ; canConsumeJoinCondition ( start ) ; } } catch ( ParsingException e ) { do nothing . . . } } return tablesByAlias ; } 
49	public static XmlTime parse ( javax . xml . stream . XMLStreamReader xsr , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException { return ( XmlTime ) XmlBeans . getContextTypeLoader ( ) . parse ( xsr , type , options ) ; } 
50	private void prepareText ( final byte [ ] value , final FTPos ftp ) throws IOException { prepare ( ) ; text ( value , ftp ) ; } 
51	public void dispatchEventToBackground ( Task task ) { mDispatcherHandler . postMessageProcessTask ( task ) ; } 
52	public static InetSocketAddress getAuthority ( ) { Server server = getJettyServer ( ) ; try { InetAddress add = InetAddress . getByName ( server . getConnectors ( ) [ _NUM ] . getHost ( ) ) ; int port = server . getConnectors ( ) [ _NUM ] . getPort ( ) ; return new InetSocketAddress ( add , port ) ; } catch ( UnknownHostException ex ) { throw new RuntimeException ( ex ) ; } } 
53	public Long get ( Object key ) { double k ; if ( key ! = null ) { if ( key instanceof Double ) { k = unwrapKey ( key ) ; } else { return null ; } } else { k = _ map . getNoEntryKey ( ) ; } long v = _ map . get ( k ) ; check here . if ( v = = _ map . getNoEntryValue ( ) ) { return null ; } else { return wrapValue ( v ) ; } } 
54	public void startCall ( String method , int length ) throws IOException { os . write ( ' c ' ) ; os . write ( _ version ) ; os . write ( _NUM ) ; os . write ( ' m ' ) ; int len = method . length ( ) ; os . write ( len > > _NUM ) ; os . write ( len ) ; printString ( method , _NUM , len ) ; } 
55	public static String generateXPath ( XmlCursor node , XmlCursor context , NamespaceContext nsctx ) throws XPathGenerationException { if ( node = = null ) throw new IllegalArgumentException ( _STR + tt . toString ( ) ) ; } } 
56	public static Permission loadPermission ( String name , Map < ? , ? > data , PermissionDefault def , List < Permission > output ) { Validate . notNull ( name , _STR ) . toString ( ) ; } return new Permission ( name , desc , def , children ) ; } 
57	public IntegerPolynomial invertF _NUM ( ) { int N = coeffs . length ; int k = _NUM ; IntegerPolynomial b = new IntegerPolynomial ( N + _NUM ) ; b . coeffs [ _NUM ] = _NUM ; IntegerPolynomial c = new IntegerPolynomial ( N + _NUM ) ; IntegerPolynomial f = new IntegerPolynomial ( N + _NUM ) ; f . coeffs = Arrays . copyOf ( coeffs , N + _NUM ) ; f . modPositive ( _NUM ) ; set g ( x ) = x ^ N âˆ’ _NUM IntegerPolynomial g = new IntegerPolynomial ( N + _NUM ) ; g . coeffs [ _NUM ] = - _NUM ; g . coeffs [ N ] = _NUM ; while ( true ) { while ( f . coeffs [ _NUM ] = = _NUM ) { for ( int i = _NUM ; i < = N ; i + + ) { f ( x ) = f ( x ) / x f . coeffs [ i - _NUM ] = f . coeffs [ i ] ; c ( x ) = c ( x ) * x c . coeffs [ N + _NUM - i ] = c . coeffs [ N - i ] ; } f . coeffs [ N ] = _NUM ; c . coeffs [ _NUM ] = _NUM ; k + + ; if ( f . equalsZero ( ) ) { not invertible return null ; } } if ( f . equalsAbsOne ( ) ) { break ; } if ( f . degree ( ) < g . degree ( ) ) { exchange f and g IntegerPolynomial temp = f ; f = g ; g = temp ; exchange b and c temp = b ; b = c ; c = temp ; } if ( f . coeffs [ _NUM ] = = g . coeffs [ _NUM ] ) { f . sub ( g , _NUM ) ; b . sub ( c , _NUM ) ; } else { f . add ( g , _NUM ) ; b . add ( c , _NUM ) ; } } if ( b . coeffs [ N ] ! = _NUM ) { return null ; } Fp ( x ) = [ + - ] x ^ ( N - k ) * b ( x ) IntegerPolynomial Fp = new IntegerPolynomial ( N ) ; int j = _NUM ; k % = N ; for ( int i = N - _NUM ; i > = _NUM ; i - - ) { j = i - k ; if ( j < _NUM ) { j + = N ; } Fp . coeffs [ j ] = f . coeffs [ _NUM ] * b . coeffs [ i ] ; } Fp . ensurePositive ( _NUM ) ; return Fp ; } 
58	public static boolean test ( FlatDataCollection flatDataCollection , double aLevel ) { Note ! This test works only for _NUM valued internalData . If you have other types of internalData you must transform them into _NUM valued internalData . int U = _NUM ; Map < Object , Integer > Ni = new HashMap < > ( ) ; Object previousValue = null ; Estimate the number of Runs for ( Object x : flatDataCollection ) { if ( previousValue ! = null & & ! previousValue . equals ( x ) ) { if the next value changes count it as different run + + U ; } previousValue = x ; if ( Ni . containsKey ( x ) = = false ) { Ni . put ( x , _NUM ) ; } else { keep track of the occurences in each category Ni . put ( x , Ni . get ( x ) + _NUM ) ; } } the internalData must be two valued in this test if ( Ni . size ( ) ! = _NUM ) { throw new IllegalArgumentException ( _STR ) ; } Object [ ] keys = Ni . keySet ( ) . toArray ( ) ; int n _NUM = Ni . get ( keys [ _NUM ] ) ; int n _NUM = Ni . get ( keys [ _NUM ] ) ; keys = null ; Ni = null ; boolean rejectH _NUM = checkCriticalValue ( ( double ) U , n _NUM , n _NUM , aLevel ) ; return rejectH _NUM ; } 
59	public static float [ ] combine ( List < float [ ] > nums ) { int length = _NUM ; for ( int i = _NUM ; i < nums . size ( ) ; i + + ) length + = nums . get ( i ) . length ; float [ ] ret = new float [ length ] ; int count = _NUM ; for ( float [ ] i : nums ) { for ( int j = _NUM ; j < i . length ; j + + ) { ret [ count + + ] = i [ j ] ; } } return ret ; } 
60	public void setGravity ( int gravity ) { if ( mGravity ! = gravity ) { if ( ( gravity & Gravity . RELATIVE _ HORIZONTAL _ GRAVITY _ MASK ) = = _NUM ) { gravity | = Gravity . START ; } if ( ( gravity & Gravity . VERTICAL _ GRAVITY _ MASK ) = = _NUM ) { gravity | = Gravity . TOP ; } mGravity = gravity ; requestLayout ( ) ; } } 
61	public void appendSQL ( String _ msg ) throws Exception { if ( ! ready ) if ( ! ready ( ) ) throw new Exception ( _STR ) ; if ( msg _ wildcard _ pos > _NUM ) { new _ sql = new _ sql _ part _NUM + _ msg + new _ sql _ part _NUM ; } else new _ sql = sql ; try { stmt . executeUpdate ( new _ sql ) ; } catch ( Exception e ) { errormsg = new _ sql ; throw e ; } } 
62	void setupSetterAndGetter ( Object target ) { if ( mProperty ! = null ) { check to make sure that mProperty is on the class of target try { Object testValue = null ; List < Keyframe > keyframes = mKeyframes . getKeyframes ( ) ; int keyframeCount = keyframes = = null ? _NUM : keyframes . size ( ) ; for ( int i = _NUM ; i < keyframeCount ; i + + ) { Keyframe kf = keyframes . get ( i ) ; if ( ! kf . hasValue ( ) | | kf . valueWasSetOnStart ( ) ) { if ( testValue = = null ) { testValue = convertBack ( mProperty . get ( target ) ) ; } kf . setValue ( testValue ) ; kf . setValueWasSetOnStart ( true ) ; } } return ; } catch ( ClassCastException e ) { Log . w ( _STR , e . toString ( ) ) ; } } } } } 
63	public final void synpred _NUM _NUM _ JPA _NUM _ fragment ( ) throws RecognitionException { JPA _NUM . g : _NUM _NUM _NUM : _NUM : ( scalar _ expression ) JPA _NUM . g : _NUM _NUM _NUM : _NUM : scalar _ expression { pushFollow ( FOLLOW _ scalar _ expression _ in _ synpred _NUM _NUM _ JPA _NUM _NUM _NUM _NUM _NUM ) ; scalar _ expression ( ) ; state . _ fsp - - ; if ( state . failed ) return ; } } 
64	public void destroy ( ) { if ( ! isValid ( ) ) { Already destroyed return ; } mRenderer . onLayerDestroyed ( this ) ; mRenderer = null ; mFinalizer . release ( ) ; mFinalizer = null ; } 
65	protected void dispatchGetDisplayList ( ) { final int count = mChildrenCount ; final View [ ] children = mChildren ; for ( int i = _NUM ; i < count ; i + + ) { final View child = children [ i ] ; if ( ( ( child . mViewFlags & VISIBILITY _ MASK ) = = VISIBLE | | child . getAnimation ( ) ! = null ) ) { recreateChildDisplayList ( child ) ; } } if ( mOverlay ! = null ) { View overlayView = mOverlay . getOverlayView ( ) ; recreateChildDisplayList ( overlayView ) ; } if ( mDisappearingChildren ! = null ) { final ArrayList < View > disappearingChildren = mDisappearingChildren ; final int disappearingCount = disappearingChildren . size ( ) ; for ( int i = _NUM ; i < disappearingCount ; + + i ) { final View child = disappearingChildren . get ( i ) ; recreateChildDisplayList ( child ) ; } } } 
66	public static void showMessage ( String msg , char icon , int timeout , ActionListener listener ) { ToastBar . Status s = ToastBar . getInstance ( ) . createStatus ( ) ; Style stl = UIManager . getInstance ( ) . getComponentStyle ( s . getMessageUIID ( ) ) ; s . setIcon ( FontImage . createMaterial ( icon , stl , _NUM ) ) ; s . setMessage ( msg ) ; if ( listener ! = null ) { s . setListener ( listener ) ; } s . setExpires ( timeout ) ; s . show ( ) ; } 
67	public static < T extends Writable > T deepCopy ( T value , Class < T > writableClass ) { ByteArrayOutputStream byteOutStream = new ByteArrayOutputStream ( ) ; DataOutputStream dataOut = new DataOutputStream ( byteOutStream ) ; T copiedValue = null ; try { value . write ( dataOut ) ; dataOut . flush ( ) ; ByteArrayInputStream byteInStream = new ByteArrayInputStream ( byteOutStream . toByteArray ( ) ) ; DataInput dataInput = new DataInputStream ( byteInStream ) ; copiedValue = writableClass . newInstance ( ) ; copiedValue . readFields ( dataInput ) ; } catch ( Exception e ) { throw new CrunchRuntimeException ( _STR + value , e ) ; } return copiedValue ; } 
68	private static boolean isMultichannelConfigSupported ( int channelConfig ) { check for unsupported channels if ( ( channelConfig & SUPPORTED _ OUT _ CHANNELS ) ! = channelConfig ) { loge ( _STR ) ; return false ; } return true ; } 
69	private void configureProperties ( Map < String , Object > params ) { for ( Map . Entry < String , Object > entry : params . entrySet ( ) ) { Object value = entry . getValue ( ) ; if ( value = = null | | value . equals ( _STR ) ; } } 
70	public static Iterator < Character > stringIterator ( final String string ) { Ensure the error is found as soon as possible . if ( string = = null ) throw new NullPointerException ( ) ; return new Iterator < Character > ( ) { private int index = _NUM ; public boolean hasNext ( ) { return index < string . length ( ) ; } public Character next ( ) { not IndexOutOfBoundsException . if ( ! hasNext ( ) ) throw new NoSuchElementException ( ) ; return string . charAt ( index + + ) ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } 
71	protected WOTSPlusPrivateKeyParameters getPrivateKey ( ) { byte [ ] [ ] privateKey = new byte [ params . getLen ( ) ] [ ] ; for ( int i = _NUM ; i < privateKey . length ; i + + ) { privateKey [ i ] = expandSecretKeySeed ( i ) ; } return new WOTSPlusPrivateKeyParameters ( params , privateKey ) ; } 
72	public boolean hasProperty ( final Property p , final String o , final String l ) throws ReadDeniedException , AuthenticationRequiredException { checkRead ( ) ; final Literal ll = holder . getBaseItem ( ) . getModel ( ) . createLiteral ( o , l ) ; final ExtendedIterator < Statement > iter = holder . getBaseItem ( ) . getModel ( ) . listStatements ( this , p , ll ) . filterKeep ( new PermStatementFilter ( Action . Read , this ) ) ; try { return iter . hasNext ( ) ; } finally { iter . close ( ) ; } } 
73	public void connect ( KeyStore keyStore , final AWSIotMqttClientStatusCallback statusCallback ) { if ( Build . VERSION . SDK _ INT < ANDROID _ API _ LEVEL _ _NUM _NUM ) { throw new UnsupportedOperationException ( _STR , e ) ; } } 
74	public TBigDecimal plus ( TMathContext mc ) { return round ( mc ) ; } 
75	public ViewHolder findViewHolderForLayoutPosition ( int position ) { return findViewHolderForPosition ( position , false ) ; } 
76	public void getEntitiesAt ( Array < Entity > result , Point _NUM D position ) { for ( int i = _NUM ; i < entities . size ( ) ; i + + ) { Entity e = entities . get ( i ) ; if ( e . getPosition ( ) . equals ( position ) ) { result . add ( e ) ; } } } 
77	 @ SuppressWarnings ( _STR ) ; if ( ( suspendProp = = null | | PropertyUtils . isFalse ( suspendProp ) ) & & iterator . hasPrevious ( ) ) { iterator . previous ( ) ; } pause ( ) ; throw ex ; } catch ( RuntimeException ex ) { if ( ! faultOccurred ) { faultOccurred = true ; wrapExceptionAsFault ( message , ex ) ; } state = State . ABORTED ; } } if ( state = = State . EXECUTING ) { state = State . COMPLETE ; } return state = = State . COMPLETE ; } finally { CURRENT _ MESSAGE . set ( oldMessage ) ; } } 
78	public void testVariance ( ) { logger . info ( _STR ) ; FlatDataCollection flatDataCollection = generateFlatDataCollection ( ) ; boolean isSample = true ; double expResult = _NUM _NUM _NUM . _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM ; double result = Descriptives . variance ( flatDataCollection , isSample ) ; assertEquals ( expResult , result , Constants . DOUBLE _ ACCURACY _ HIGH ) ; } 
79	See if we have an action of a given type in progress . @ ServiceThreadOnly < T extends HdmiCecFeatureAction > boolean hasAction ( final Class < T > clazz ) { assertRunOnServiceThread ( ) ; for ( HdmiCecFeatureAction action : mActions ) { if ( action . getClass ( ) . equals ( clazz ) ) { return true ; } } return false ; } 
80	public static boolean isWord ( KeyEvent event ) { KeyCode keyCode = event . getCode ( ) ; return keyCode . isLetterKey ( ) | | keyCode . isDigitKey ( ) | | FILE _ LEGALS . match ( event ) | | keyCode = = KeyCode . UNDEFINED ; } 
81	public void writeAccessControlEntry ( CmsRequestContext context , CmsResource resource , CmsAccessControlEntry ace ) throws CmsException , CmsSecurityException { CmsDbContext dbc = m _ dbContextFactory . getDbContext ( context ) ; try { checkOfflineProject ( dbc ) ; checkPermissions ( dbc , resource , CmsPermissionSet . ACCESS _ CONTROL , true , CmsResourceFilter . ALL ) ; if ( ace . getPrincipal ( ) . equals ( CmsAccessControlEntry . PRINCIPAL _ OVERWRITE _ ALL _ ID ) ) { only vfs managers can set the overwrite all ACE checkRoleForResource ( dbc , CmsRole . VFS _ MANAGER , resource ) ; } m _ driverManager . writeAccessControlEntry ( dbc , resource , ace ) ; } catch ( Exception e ) { dbc . report ( null , Messages . get ( ) . container ( Messages . ERR _ WRITE _ ACL _ ENTRY _ _NUM , context . getSitePath ( resource ) ) , e ) ; } finally { dbc . clear ( ) ; } } 
82	int getDSTOffset ( Calendar source ) { TimeZone localTimezone = Calendar . getInstance ( ) . getTimeZone ( ) ; int rawOffset = localTimezone . getRawOffset ( ) / MILLIS _ TO _ MINUTES ; return getOffsetInMinutes ( source , localTimezone ) - rawOffset ; } 
83	private void fastRelayout ( ) { boolean invalidateAfter = false ; final int childCount = getChildCount ( ) ; int position = mGrid . getFirstVisibleIndex ( ) ; int index = _NUM ; for ( ; index < childCount ; index + + , position + + ) { View view = getChildAt ( index ) ; and call getViewForPosition ( ) again to rebind . if ( position ! = getAdapterPositionByView ( view ) ) { invalidateAfter = true ; break ; } Grid . Location location = mGrid . getLocation ( position ) ; if ( location = = null ) { invalidateAfter = true ; break ; } int startSecondary = getRowStartSecondary ( location . row ) + mWindowAlignment . secondAxis ( ) . getPaddingMin ( ) - mScrollOffsetSecondary ; int primarySize , end ; int start = getViewMin ( view ) ; int oldPrimarySize = getViewPrimarySize ( view ) ; LayoutParams lp = ( LayoutParams ) view . getLayoutParams ( ) ; if ( lp . viewNeedsUpdate ( ) ) { detachAndScrapView ( view , mRecycler ) ; view = getViewForPosition ( position ) ; addView ( view , index ) ; } measureChild ( view ) ; if ( mOrientation = = HORIZONTAL ) { primarySize = getDecoratedMeasuredWidthWithMargin ( view ) ; end = start + primarySize ; } else { primarySize = getDecoratedMeasuredHeightWithMargin ( view ) ; end = start + primarySize ; } layoutChild ( location . row , view , start , end , startSecondary ) ; if ( oldPrimarySize ! = primarySize ) { size changed invalidate remaining Locations if ( DEBUG ) Log . d ( getTag ( ) , _STR + position ) ; invalidateAfter = true ; break ; } } if ( invalidateAfter ) { final int savedLastPos = mGrid . getLastVisibleIndex ( ) ; for ( int i = childCount - _NUM ; i > = index ; i - - ) { View v = getChildAt ( i ) ; detachAndScrapView ( v , mRecycler ) ; } mGrid . invalidateItemsAfter ( position ) ; if ( mPruneChild ) { in regular prune child mode , we just append items up to edge limit appendVisibleItems ( ) ; if ( mFocusPosition > = _NUM & & mFocusPosition < = savedLastPos ) { when there is delta in onLayoutChildren ( ) . while ( mGrid . getLastVisibleIndex ( ) < mFocusPosition ) { mGrid . appendOneColumnVisibleItems ( ) ; } } } else { prune disabled ( e . g . in RowsFragment transition ) : append all removed items while ( mGrid . appendOneColumnVisibleItems ( ) & & mGrid . getLastVisibleIndex ( ) < savedLastPos ) ; } } updateScrollLimits ( ) ; updateSecondaryScrollLimits ( ) ; } 
84	public void setDomainAxisLocation ( int index , AxisLocation location , boolean notify ) { if ( index = = _NUM & & location = = null ) { throw new IllegalArgumentException ( _STR ) ; } this . domainAxisLocations . set ( index , location ) ; if ( notify ) { fireChangeEvent ( ) ; } } 
85	public float [ ] readTemperatureAndPressure ( ) throws IOException , IllegalStateException { if ( mTemperatureOversampling = = OVERSAMPLING _ SKIPPED ) { throw new IllegalStateException ( _STR ) ; } The pressure compensation formula requires the fine temperature reading , so we always read temperature first . int rawTemp = readSample ( BMX _NUM _NUM _NUM _ REG _ TEMP ) ; float [ ] temperatures = compensateTemperature ( rawTemp , mTempCalibrationData ) ; int rawPressure = readSample ( BMX _NUM _NUM _NUM _ REG _ PRESS ) ; float pressure = compensatePressure ( rawPressure , temperatures [ _NUM ] , mPressureCalibrationData ) ; return new float [ ] { temperatures [ _NUM ] , pressure } ; } 
86	public ArraySet < String > getUsedBitmapFiles ( ) { final ArraySet < String > usedFiles = new ArraySet < > ( mShortcuts . size ( ) ) ; for ( int i = mShortcuts . size ( ) - _NUM ; i > = _NUM ; i - - ) { final ShortcutInfo si = mShortcuts . valueAt ( i ) ; if ( si . getBitmapPath ( ) ! = null ) { usedFiles . add ( getFileName ( si . getBitmapPath ( ) ) ) ; } } return usedFiles ; } 
87	public String getVariable ( String name ) { name = variableName ( name ) ; String value = session . get ( name ) ; if ( value = = null ) { value = global . get ( name ) ; } return value ; } 
88	private Map < String , Object > getServiceDescriptor ( String stackName , String stackVersion , String serviceName ) throws NoSuchParentResourceException , IOException { AmbariManagementController controller = getManagementController ( ) ; ServiceInfo serviceInfo ; try { serviceInfo = controller . getAmbariMetaInfo ( ) . getService ( stackName , stackVersion , serviceName ) ; } catch ( StackAccessException e ) { throw new NoSuchParentResourceException ( String . format ( _STR , stackName , stackVersion , serviceName ) ) ; } File kerberosFile = serviceInfo . getKerberosDescriptorFile ( ) ; if ( kerberosFile ! = null ) { KerberosServiceDescriptor serviceDescriptor = kerberosServiceDescriptorFactory . createInstance ( kerberosFile , serviceName ) ; if ( serviceDescriptor ! = null ) { return serviceDescriptor . toMap ( ) ; } } return null ; } 
89	public void completeRow ( ) { while ( ! rowCompleted ) { addCell ( defaultCell ) ; } } 
90	public static WriterDatasetRIOT createDatasetWriter ( Lang lang ) { RDFFormat serialization = langToFormatOrException ( lang ) ; return createDatasetWriter $ ( serialization ) ; } 
91	public static boolean keyIsValid ( String encryptionKeyHex ) { return isHexString ( encryptionKeyHex ) & & ( isUnlimitedStrengthCryptoAvailable ( ) ? UNLIMITED _ KEY _ LENGTHS . contains ( encryptionKeyHex . length ( ) ) : encryptionKeyHex . length ( ) = = _NUM _NUM ) ; } 
92	public boolean add ( final Object key , final Object val ) { final List v = ( List ) this . table . get ( key ) ; if ( v = = null ) { put ( key , val ) ; return true ; } else { return v . add ( val ) ; } } 
93	public org . bitcoin . paymentchannel . Protos . Error . Builder getErrorBuilder ( ) { bitField _NUM _ | = _NUM x _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM ; onChanged ( ) ; return getErrorFieldBuilder ( ) . getBuilder ( ) ; } 
94	private float [ ] rinterpol ( int [ ] coord , int step ) { float [ ] resultSample = new float [ numberOfOutputValues ] ; if ( step = = in . length - _NUM ) { leaf if ( inPrev [ step ] = = inNext [ step ] ) { coord [ step ] = inPrev [ step ] ; int [ ] tmpSample = getSamples ( ) [ calcSampleIndex ( coord ) ] ; for ( int i = _NUM ; i < numberOfOutputValues ; + + i ) { resultSample [ i ] = tmpSample [ i ] ; } return resultSample ; } coord [ step ] = inPrev [ step ] ; int [ ] sample _NUM = getSamples ( ) [ calcSampleIndex ( coord ) ] ; coord [ step ] = inNext [ step ] ; int [ ] sample _NUM = getSamples ( ) [ calcSampleIndex ( coord ) ] ; for ( int i = _NUM ; i < numberOfOutputValues ; + + i ) { resultSample [ i ] = interpolate ( in [ step ] , inPrev [ step ] , inNext [ step ] , sample _NUM [ i ] , sample _NUM [ i ] ) ; } return resultSample ; } else { branch if ( inPrev [ step ] = = inNext [ step ] ) { coord [ step ] = inPrev [ step ] ; return rinterpol ( coord , step + _NUM ) ; } coord [ step ] = inPrev [ step ] ; float [ ] sample _NUM = rinterpol ( coord , step + _NUM ) ; coord [ step ] = inNext [ step ] ; float [ ] sample _NUM = rinterpol ( coord , step + _NUM ) ; for ( int i = _NUM ; i < numberOfOutputValues ; + + i ) { resultSample [ i ] = interpolate ( in [ step ] , inPrev [ step ] , inNext [ step ] , sample _NUM [ i ] , sample _NUM [ i ] ) ; } return resultSample ; } } 
95	protected void updateKerberosConfigurations ( ) throws AmbariException { AmbariManagementController ambariManagementController = injector . getInstance ( AmbariManagementController . class ) ; Clusters clusters = ambariManagementController . getClusters ( ) ; if ( clusters ! = null ) { Map < String , Cluster > clusterMap = clusters . getClusters ( ) ; if ( ! MapUtils . isEmpty ( clusterMap ) ) { for ( Cluster cluster : clusterMap . values ( ) ) { Config config = cluster . getDesiredConfigByType ( _STR , e ) ; } } } } } } 
96	public void setFontAndSize ( BaseFont bf , float size ) { checkWriter ( ) ; if ( size < _NUM . _NUM _NUM _NUM _NUM f & & size > - _NUM . _NUM _NUM _NUM _NUM f ) throw new IllegalArgumentException ( MessageLocalization . getComposedMessage ( _STR ) . append _ i ( separator ) ; } 
97	protected void setTabTitle ( JComponent component ) { int index ; if ( ! ( component instanceof ArffPanel ) ) return ; index = tabbedPane . indexOfComponent ( component ) ; if ( index = = - _NUM ) return ; tabbedPane . setTitleAt ( index , ( ( ArffPanel ) component ) . getTitle ( ) ) ; updateFrameTitle ( ) ; } 
98	protected String add _ escapes ( String str ) { StringBuilder retval = new StringBuilder ( ) ; char ch ; for ( int i = _NUM ; i < str . length ( ) ; i + + ) { switch ( str . charAt ( i ) ) { case _NUM : continue ; case ' \ b ' : retval . append ( _STR ) . append ( s . substring ( s . length ( ) - _NUM , s . length ( ) ) ) ; } else { retval . append ( ch ) ; } } } return retval . toString ( ) ; } 
99	public V compute ( K key , BiFunction < ? super K , ? super V , ? extends V > remappingFunction ) { Objects . requireNonNull ( remappingFunction ) ; V oldValue = get ( key ) ; V newValue = remappingFunction . apply ( key , oldValue ) ; if ( newValue = = null ) { delete mapping if ( oldValue ! = null | | containsKey ( key ) ) { something to remove remove ( key ) ; return null ; } else { nothing to do . Leave things as they were . return null ; } } else { add or replace old mapping put ( key , newValue ) ; return newValue ; } } 
100	protected void setNextBlock ( final int offset , final int nextBlock ) { BATBlockAndIndex bai = getBATBlockAndIndex ( offset ) ; bai . getBlock ( ) . setValueAt ( bai . getIndex ( ) , nextBlock ) ; } 
101	public static boolean isAnyBlank ( final CharSequence . . . css ) { if ( ArrayUtils . isEmpty ( css ) ) { return false ; } for ( final CharSequence cs : css ) { if ( isBlank ( cs ) ) { return true ; } } return false ; } 
102	protected Entity importEntity ( Entity srcEntity , @ Nullable Entity dstEntity , EntityImportView importView , View regularView , CommitContext commitContext , Collection < ReferenceInfo > referenceInfoList ) { MetaClass metaClass = srcEntity . getMetaClass ( ) ; boolean createOp = false ; if ( dstEntity = = null ) { dstEntity = metadata . create ( metaClass ) ; dstEntity . setValue ( _STR . equals ( metaProperty . getName ( ) ) ) | | metaProperty . getRange ( ) . isEnum ( ) ) { dstEntity . setValue ( propertyName , srcEntity . getValue ( propertyName ) ) ; } else if ( metaProperty . getRange ( ) . isClass ( ) ) { View regularPropertyView = regularView . getProperty ( propertyName ) ! = null ? regularView . getProperty ( propertyName ) . getView ( ) : null ; if ( metadata . getTools ( ) . isEmbedded ( metaProperty ) ) { if ( importViewProperty . getView ( ) ! = null ) { Entity embeddedEntity = importEmbeddedAttribute ( srcEntity , dstEntity , createOp , importViewProperty , regularPropertyView , commitContext , referenceInfoList ) ; dstEntity . setValue ( propertyName , embeddedEntity ) ; } } else { switch ( metaProperty . getRange ( ) . getCardinality ( ) ) { case MANY _ TO _ MANY : importManyToManyCollectionAttribute ( srcEntity , dstEntity , srcSecurityState , importViewProperty , regularPropertyView , commitContext , referenceInfoList ) ; break ; case ONE _ TO _ MANY : importOneToManyCollectionAttribute ( srcEntity , dstEntity , srcSecurityState , importViewProperty , regularPropertyView , commitContext , referenceInfoList ) ; break ; default : importReference ( srcEntity , dstEntity , importViewProperty , regularPropertyView , commitContext , referenceInfoList ) ; } } } } if ( entityHasDynamicAttributes ( srcEntity ) ) { if ( PersistenceHelper . isNew ( dstEntity ) & & ( ( BaseGenericIdEntity ) dstEntity ) . getDynamicAttributes ( ) = = null ) { ( ( BaseGenericIdEntity ) dstEntity ) . setDynamicAttributes ( new HashMap < > ( ) ) ; } Map < String , CategoryAttributeValue > srcDynamicAttributes = ( ( BaseGenericIdEntity ) srcEntity ) . getDynamicAttributes ( ) ; for ( Map . Entry < String , CategoryAttributeValue > entry : srcDynamicAttributes . entrySet ( ) ) { String dynamicAttributeCode = entry . getKey ( ) ; CategoryAttributeValue srcDynamicAttribute = entry . getValue ( ) ; dstEntity . setValue ( DynamicAttributesUtils . encodeAttributeCode ( dynamicAttributeCode ) , srcDynamicAttribute . getValue ( ) ) ; } } return dstEntity ; } 
103	public Job createSubmittableJob ( String [ ] args ) throws IOException { if ( ! doCommandLine ( args ) ) { return null ; } Job job = Job . getInstance ( getConf ( ) , getConf ( ) . get ( JOB _ NAME _ CONF _ KEY , NAME + _STR + this . bulkloadDir ) ; HFileOutputFormat _NUM . setOutputPath ( job , bulkloadDir ) ; try ( Connection conn = ConnectionFactory . createConnection ( getConf ( ) ) ; Admin admin = conn . getAdmin ( ) ) { HFileOutputFormat _NUM . configureIncrementalLoadMap ( job , admin . getDescriptor ( ( TableName . valueOf ( dstTableName ) ) ) ) ; } } else { TableMapReduceUtil . initTableMapperJob ( tableName , scan , Import . Importer . class , null , null , job ) ; TableMapReduceUtil . initTableReducerJob ( dstTableName , null , job , null , peerAddress , null , null ) ; } return job ; } 
104	public void offsetLeftAndRight ( int offset ) { if ( offset ! = _NUM ) { final boolean matrixIsIdentity = hasIdentityMatrix ( ) ; if ( matrixIsIdentity ) { if ( isHardwareAccelerated ( ) ) { invalidateViewProperty ( false , false ) ; } else { final ViewParent p = mParent ; if ( p ! = null & & mAttachInfo ! = null ) { final Rect r = mAttachInfo . mTmpInvalRect ; int minLeft ; int maxRight ; if ( offset < _NUM ) { minLeft = mLeft + offset ; maxRight = mRight ; } else { minLeft = mLeft ; maxRight = mRight + offset ; } r . set ( _NUM , _NUM , maxRight - minLeft , mBottom - mTop ) ; p . invalidateChild ( this , r ) ; } } } else { invalidateViewProperty ( false , false ) ; } mLeft + = offset ; mRight + = offset ; mRenderNode . offsetLeftAndRight ( offset ) ; if ( isHardwareAccelerated ( ) ) { invalidateViewProperty ( false , false ) ; invalidateParentIfNeededAndWasQuickRejected ( ) ; } else { if ( ! matrixIsIdentity ) { invalidateViewProperty ( false , true ) ; } invalidateParentIfNeeded ( ) ; } notifySubtreeAccessibilityStateChangedIfNeeded ( ) ; } } 
105	public Builder clearPaymentAck ( ) { if ( paymentAckBuilder _ = = null ) { paymentAck _ = org . bitcoin . paymentchannel . Protos . PaymentAck . getDefaultInstance ( ) ; onChanged ( ) ; } else { paymentAckBuilder _ . clear ( ) ; } bitField _NUM _ = ( bitField _NUM _ & ~ _NUM x _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM ) ; return this ; } 
106	private static Url parseUrl ( final String spec ) { final Url url = new Url ( ) ; int startIndex = _NUM ; int endIndex = spec . length ( ) ; Section _NUM . _NUM . _NUM : Parsing the Fragment Identifier If the parse string contains a crosshatch _STR character is the network location / login ( < net _ loc > ) of the URL . locationEndIndex = semicolonIndex ; startIndex = semicolonIndex ; } url . parameters _ = spec . substring ( semicolonIndex + _NUM , endIndex ) ; endIndex = semicolonIndex ; } done by simply storing the preceding slash along with the path . if ( ( locationStartIndex > = _NUM ) & & ( locationEndIndex < _NUM ) ) { The entire remaining parse string is assigned to the network location / login ( < net _ loc > ) of the URL . locationEndIndex = endIndex ; } else if ( startIndex < endIndex ) { url . path _ = spec . substring ( startIndex , endIndex ) ; } Set the network location / login ( < net _ loc > ) of the URL . if ( ( locationStartIndex > = _NUM ) & & ( locationEndIndex > = _NUM ) ) { url . location _ = spec . substring ( locationStartIndex , locationEndIndex ) ; } return url ; } 
107	public static SyncInfo getCurrentSync ( ) { try { final List < SyncInfo > syncs = getContentService ( ) . getCurrentSyncs ( ) ; if ( syncs . isEmpty ( ) ) { return null ; } return syncs . get ( _NUM ) ; } catch ( RemoteException e ) { throw new RuntimeException ( _STR , e ) ; } } 
108	private void applyStyle ( HTMLElement element , CSSElement selector , HTMLComponent htmlC ) { if ( ( element . getUi ( ) ! = null ) & & ( element . getUi ( ) . size ( ) > _NUM ) ) { if ( ! HTMLComponent . PROCESS _ HTML _ MP _NUM _ ONLY ) { String reset = selector . getAttributeById ( CSSElement . CSS _ COUNTER _ RESET ) ; if ( reset ! = null ) { htmlC . incCounter ( reset , true ) ; } String inc = selector . getAttributeById ( CSSElement . CSS _ COUNTER _ INCREMENT ) ; if ( inc ! = null ) { htmlC . incCounter ( inc , false ) ; } if ( ( selector . getSelectorPseudoClass ( ) & ( CSSElement . PC _ BEFORE | CSSElement . PC _ AFTER ) ) ! = _NUM ) { handleContentProperty ( element , selector , htmlC ) ; return ; } } for ( int iter = _NUM ; iter < element . getUi ( ) . size ( ) ; iter + + ) { Object o = element . getUi ( ) . elementAt ( iter ) ; if ( o ! = null & & o instanceof Component ) { final Component cmp = ( Component ) o ; applyStyleToUIElement ( cmp , selector , element , htmlC ) ; } } } } 
109	public final POIXMLDocumentPart getRelationById ( String id ) { RelationPart rp = getRelationPartById ( id ) ; return ( rp = = null ) ? null : rp . getDocumentPart ( ) ; } 
110	public void finishPage ( Page page ) { throwIfClosed ( ) ; if ( page = = null ) { throw new IllegalArgumentException ( _STR ) ; } mPages . add ( page . getInfo ( ) ) ; mCurrentPage = null ; nativeFinishPage ( mNativeDocument ) ; page . finish ( ) ; } 
111	protected void onDraw ( Canvas canvas ) { super . onDraw ( canvas ) ; float mViewWidth = this . getWidth ( ) ; clear old data , boxes stores an array of _STR ) ) { if ( yOffset > pageHeight ) { if ( yOffset < obstacles . get ( obstacles . size ( ) - _NUM ) . topLefty - getLineHeight ( ) ) { child . setVisibility ( View . GONE ) ; } else { child . setVisibility ( View . VISIBLE ) ; } } else { child . setVisibility ( View . GONE ) ; } } mDesiredHeight = Math . max ( lowestYCoord , ( int ) yOffset ) ; if ( needsMeasure ) { needsMeasure = false ; requestLayout ( ) ; } } 
112	protected String getCallSignature ( SqlValidator validator , SqlValidatorScope scope ) { List < String > signatureList = new ArrayList < > ( ) ; for ( final SqlNode operand : getOperandList ( ) ) { final RelDataType argType = validator . deriveType ( scope , operand ) ; if ( null = = argType ) { continue ; } signatureList . add ( argType . toString ( ) ) ; } return SqlUtil . getOperatorSignature ( getOperator ( ) , signatureList ) ; } 
113	public void addApp ( Class < ? > appClass ) { JMenuItem item = addDemoToMenu ( appsMenu , appClass ) ; item . addActionListener ( new AppStarter ( appClass ) ) ; } 
114	private boolean isTableDisabled ( TableName tableName ) { return tableStates . containsKey ( tableName ) & & tableStates . get ( tableName ) . inStates ( TableState . State . DISABLED , TableState . State . DISABLING ) ; } 
115	public void createOrUpdateFromConnection ( Connection connection , String schemaFiltersString , String buffer , int cursor ) { try ( Connection c = connection ) { if ( schemaFiltersString = = null ) { schemaFiltersString = StringUtils . EMPTY ; } List < String > schemaFilters = Arrays . asList ( schemaFiltersString . split ( _STR , e ) ; } } 
116	public void zoomInRange ( double x , double y ) { Plot plot = this . chart . getPlot ( ) ; if ( plot instanceof Zoomable ) { here we tweak the notify flag on the plot so that only one notification happens even though we update multiple axes . . . boolean savedNotify = plot . isNotify ( ) ; plot . setNotify ( false ) ; Zoomable z = ( Zoomable ) plot ; z . zoomRangeAxes ( this . zoomInFactor , this . info . getPlotInfo ( ) , translateScreenToJava _NUM D ( new Point ( ( int ) x , ( int ) y ) ) , this . zoomAroundAnchor ) ; plot . setNotify ( savedNotify ) ; } } 
117	private float getFloatParameter ( final String param ) { final Float p = ( Float ) getParameter ( param ) ; if ( p = = null ) { return _NUM ; } return p . floatValue ( ) ; } 
118	public Vector < String > getWithPrefix ( String prefix ) { Vector < String > result ; TrieNode node ; TrieIterator iter ; result = new Vector < String > ( ) ; if ( containsPrefix ( prefix ) ) { node = m _ Root . find ( prefix ) ; iter = new TrieIterator ( node ) ; while ( iter . hasNext ( ) ) result . add ( iter . next ( ) ) ; } return result ; } 
119	public static void loadPropsBySuffix ( final File jobPath , final Props props , final String . . . suffixes ) { try { if ( jobPath . isDirectory ( ) ) { final File [ ] files = jobPath . listFiles ( ) ; if ( files ! = null ) { for ( final File file : files ) { loadPropsBySuffix ( file , props , suffixes ) ; } } } else if ( endsWith ( jobPath , suffixes ) ) { props . putAll ( new Props ( null , jobPath . getAbsolutePath ( ) ) ) ; } } catch ( final IOException e ) { throw new RuntimeException ( _STR , e ) ; } } 
120	public static Set < RegionInfo > filterNonFNApplicableRegions ( Collection < RegionInfo > regions ) { Set < RegionInfo > fnRegions = Sets . newHashSet ( ) ; for ( RegionInfo regionInfo : regions ) { if ( ! isFavoredNodeApplicable ( regionInfo ) ) { fnRegions . add ( regionInfo ) ; } } return fnRegions ; } 
121	public boolean isClientSide ( ) { return isConsumerSide ( ) ; } 
122	public Iterator getKeysWithSignaturesBy ( long keyID ) { List keysWithSigs = new ArrayList ( ) ; for ( Iterator keyIt = getPublicKeys ( ) ; keyIt . hasNext ( ) ; ) { PGPPublicKey k = ( PGPPublicKey ) keyIt . next ( ) ; Iterator sigIt = k . getSignaturesForKeyID ( keyID ) ; if ( sigIt . hasNext ( ) ) { keysWithSigs . add ( k ) ; } } return keysWithSigs . iterator ( ) ; } 
123	public void serialize ( RecordOutput rout , String tag ) throws IOException { write out any header , version info , here rout . startRecord ( this , tag ) ; rout . writeString ( name , tag ) ; sTid . writeRest ( rout , tag ) ; rout . endRecord ( this , tag ) ; } 
124	protected long getNumKeys ( long keysPerServer ) throws IOException { int numRegionServers = cluster . getClusterMetrics ( ) . getLiveServerMetrics ( ) . size ( ) ; return keysPerServer * numRegionServers ; } 
125	public boolean isMultipleAdvertisementSupported ( ) { if ( getState ( ) ! = STATE _ ON ) { return false ; } try { mServiceLock . readLock ( ) . lock ( ) ; if ( mService ! = null ) { return mService . isMultiAdvertisementSupported ( ) ; } } catch ( RemoteException e ) { Log . e ( TAG , _STR , e ) ; } finally { mServiceLock . readLock ( ) . unlock ( ) ; } return false ; } 
126	public void testTruncateWithDataNodesRestartImmediately ( ) throws Exception { int startingFileSize = _NUM * BLOCK _ SIZE ; byte [ ] contents = AppendTestUtil . initBuffer ( startingFileSize ) ; final Path p = new Path ( parent , _STR ) ) ; Validate the file FileStatus fileStatus = fs . getFileStatus ( p ) ; assertThat ( fileStatus . getLen ( ) , is ( ( long ) newLength ) ) ; checkFullFile ( p , newLength , contents ) ; fs . delete ( parent , true ) ; } 
127	public boolean canManageSubscription ( SubscriptionInfo info , String packageName ) { if ( ! info . isEmbedded ( ) ) { throw new IllegalArgumentException ( _STR + packageName , e ) ; } for ( UiccAccessRule rule : info . getAccessRules ( ) ) { if ( rule . getCarrierPrivilegeStatus ( packageInfo ) = = TelephonyManager . CARRIER _ PRIVILEGE _ STATUS _ HAS _ ACCESS ) { return true ; } } return false ; } 
128	private static void sigKill ( String pid , boolean isProcessGroup , long sleeptimeBeforeSigkill , boolean inBackground ) { if ( inBackground ) { use a separate thread for killing SigKillThread sigKillThread = new SigKillThread ( pid , isProcessGroup , sleeptimeBeforeSigkill ) ; sigKillThread . setDaemon ( true ) ; sigKillThread . start ( ) ; } else { sigKillInCurrentThread ( pid , isProcessGroup , sleeptimeBeforeSigkill ) ; } } 
129	public void delayHide ( long delayMillis ) { Ensure that any currently queued hide calls are removed removeQueuedRunnables ( ) ; mHandler . postDelayed ( mHideRunnable , delayMillis ) ; } 
130	public static void main ( String [ ] args ) { Parse the input args . if ( ! parseInputArgs ( args ) ) { System . exit ( EXIT _ FAILED ) ; } System . out . println ( _STR , e ) ; } CliUtils . printPassInfo ( checkSuccess ) ; ret & = checkSuccess ; } stopCluster ( ) ; System . exit ( ret ? EXIT _ SUCCESS : EXIT _ FAILED ) ; } 
131	public void startLocalOnlyHotspot ( LocalOnlyHotspotCallback callback , @ Nullable Handler handler ) { synchronized ( mLock ) { Looper looper = ( handler = = null ) ? mContext . getMainLooper ( ) : handler . getLooper ( ) ; LocalOnlyHotspotCallbackProxy proxy = new LocalOnlyHotspotCallbackProxy ( this , looper , callback ) ; try { String packageName = mContext . getOpPackageName ( ) ; int returnCode = mService . startLocalOnlyHotspot ( proxy . getMessenger ( ) , new Binder ( ) , packageName ) ; if ( returnCode ! = LocalOnlyHotspotCallback . REQUEST _ REGISTERED ) { Send message to the proxy to make sure we call back on the correct thread proxy . notifyFailed ( returnCode ) ; return ; } mLOHSCallbackProxy = proxy ; } catch ( RemoteException e ) { throw e . rethrowFromSystemServer ( ) ; } } } 
132	public void read ( TrueTypeFont ttf , TTFDataStream data ) throws IOException { int version = data . readUnsignedShort ( ) ; if ( version ! = _NUM ) { version = ( version < < _NUM _NUM ) | data . readUnsignedShort ( ) ; } int numSubtables = _NUM ; if ( version = = _NUM ) { numSubtables = data . readUnsignedShort ( ) ; } else if ( version = = _NUM ) { numSubtables = ( int ) data . readUnsignedInt ( ) ; } else { LOG . debug ( _STR + version ) ; } if ( numSubtables > _NUM ) { subtables = new KerningSubtable [ numSubtables ] ; for ( int i = _NUM ; i < numSubtables ; + + i ) { KerningSubtable subtable = new KerningSubtable ( ) ; subtable . read ( data , version ) ; subtables [ i ] = subtable ; } } initialized = true ; } 
133	 @ RequestProcessing ( value = _STR , e ) ; } fireFreeMarkerActionEvent ( templateName , dataModel ) ; } 
134	protected void populateFulfillmentOptionsAndEstimationOnModel ( Map < String , Object > localVars ) { List < FulfillmentOption > fulfillmentOptions = fulfillmentOptionService . readAllFulfillmentOptions ( ) ; Order cart = CartState . getCart ( ) ; if ( ! ( cart instanceof NullOrderImpl ) & & cart . getFulfillmentGroups ( ) . size ( ) > _NUM & & hasPopulatedShippingAddress ( cart ) ) { Set < FulfillmentOption > options = new HashSet < > ( ) ; options . addAll ( fulfillmentOptions ) ; FulfillmentEstimationResponse estimateResponse = null ; try { estimateResponse = fulfillmentPricingService . estimateCostForFulfillmentGroup ( fulfillmentGroupService . getFirstShippableFulfillmentGroup ( cart ) , options ) ; } catch ( FulfillmentPriceException e ) { } localVars . put ( _STR , fulfillmentOptions ) ; } 
135	public void should _ create _ new _ connections _ when _ connection _ lost _ and _ under _ core _ connections ( ) throws Exception { int readTimeout = _NUM _NUM _NUM _NUM ; int reconnectInterval = _NUM _NUM _NUM _NUM ; Cluster cluster = this . createClusterBuilder ( ) . withSocketOptions ( new SocketOptions ( ) . setConnectTimeoutMillis ( readTimeout ) . setReadTimeoutMillis ( reconnectInterval ) ) . withReconnectionPolicy ( new ConstantReconnectionPolicy ( _NUM _NUM _NUM _NUM ) ) . build ( ) ; List < MockRequest > allRequests = newArrayList ( ) ; try { cluster . init ( ) ; Connection . Factory factory = spy ( cluster . manager . connectionFactory ) ; cluster . manager . connectionFactory = factory ; TestExecutorService blockingExecutor = new TestExecutorService ( cluster . manager . blockingExecutor ) ; cluster . manager . blockingExecutor = blockingExecutor ; HostConnectionPool pool = createPool ( cluster , _NUM , _NUM ) ; Connection core _NUM = pool . connections . get ( _NUM ) ; Connection core _NUM = pool . connections . get ( _NUM ) ; Connection core _NUM = pool . connections . get ( _NUM ) ; Drop two core connections . Disable new connections initially and we ' ll eventually reenable it . currentClient . disableListener ( ) ; currentClient . closeConnection ( CLOSE , ( ( InetSocketAddress ) core _NUM . channel . localAddress ( ) ) ) ; currentClient . closeConnection ( CLOSE , ( ( InetSocketAddress ) core _NUM . channel . localAddress ( ) ) ) ; Uninterruptibles . sleepUninterruptibly ( _NUM _NUM _NUM , TimeUnit . MILLISECONDS ) ; Since we have a connection left the host should remain up . assertThat ( cluster ) . host ( _NUM ) . hasState ( Host . State . UP ) ; assertThat ( pool . connections ) . hasSize ( _NUM ) ; The borrowed connection should be the open one . MockRequest request = MockRequest . send ( pool ) ; allRequests . add ( request ) ; assertThat ( request . getConnection ( ) ) . isEqualTo ( core _NUM ) ; Should not have tried to create a new core connection since reconnection time had not elapsed . verify ( factory , never ( ) ) . open ( any ( HostConnectionPool . class ) ) ; Sleep to elapse the Reconnection Policy . Uninterruptibles . sleepUninterruptibly ( reconnectInterval , TimeUnit . MILLISECONDS ) ; Attempt to borrow connection , this should trigger ensureCoreConnections thus spawning a new connection . blockingExecutor . reset ( ) ; request = MockRequest . send ( pool ) ; allRequests . add ( request ) ; assertThat ( request . getConnection ( ) ) . isEqualTo ( core _NUM ) ; Should have tried to open up to core connections as result of borrowing a connection past reconnect time and not being at core . blockingExecutor . blockUntilNextTaskCompleted ( ) ; verify ( factory ) . open ( any ( HostConnectionPool . class ) ) ; reset ( factory ) ; Sleep for reconnect interval to allow reconnection time to elapse . Uninterruptibles . sleepUninterruptibly ( ( readTimeout + reconnectInterval ) * _NUM , TimeUnit . MILLISECONDS ) ; Enable listening so new connections succeed . currentClient . enableListener ( ) ; Sleep to elapse the Reconnection Policy . Uninterruptibles . sleepUninterruptibly ( reconnectInterval , TimeUnit . MILLISECONDS ) ; Try to borrow a connection , the pool should grow . blockingExecutor . reset ( ) ; allRequests . add ( MockRequest . send ( pool ) ) ; blockingExecutor . blockUntilNextTaskCompleted ( ) ; verify ( factory ) . open ( any ( HostConnectionPool . class ) ) ; reset ( factory ) ; Another core connection should be opened as result of another request to get us up to core connections . blockingExecutor . reset ( ) ; allRequests . add ( MockRequest . send ( pool ) ) ; blockingExecutor . blockUntilNextTaskCompleted ( ) ; verify ( factory ) . open ( any ( HostConnectionPool . class ) ) ; reset ( factory ) ; Sending another request should not grow the pool any more , since we are now at core connections . allRequests . add ( MockRequest . send ( pool ) ) ; verify ( factory , after ( ( reconnectInterval + readTimeout ) * _NUM ) . never ( ) ) . open ( any ( HostConnectionPool . class ) ) ; } finally { MockRequest . completeAll ( allRequests ) ; cluster . close ( ) ; } } 
136	public void testResolve _ SingleSignOnInfo ( ) throws Exception { SingleSignOnInfo singleSignOnInfoChild = new SingleSignOnInfo ( false , null ) ; SingleSignOnInfo singleSignOnInfoParent = new SingleSignOnInfo ( true , _STR ) ; ServiceInfo childInfo = new ServiceInfo ( ) ; ServiceInfo parentInfo = new ServiceInfo ( ) ; ServiceModule serviceModule ; ServiceInfo serviceInfo ; specified in child only , child wins childInfo . setSingleSignOnInfo ( singleSignOnInfoChild ) ; parentInfo . setSingleSignOnInfo ( null ) ; serviceModule = resolveService ( childInfo , parentInfo ) ; serviceInfo = serviceModule . getModuleInfo ( ) ; assertEquals ( singleSignOnInfoChild . isSupported ( ) , serviceInfo . isSingleSignOnSupported ( ) ) ; assertEquals ( singleSignOnInfoChild . isSupported ( ) , serviceInfo . getSingleSignOnInfo ( ) . isSupported ( ) ) ; assertEquals ( singleSignOnInfoChild . getSupported ( ) , serviceInfo . getSingleSignOnInfo ( ) . getSupported ( ) ) ; assertEquals ( singleSignOnInfoChild . getEnabledConfiguration ( ) , serviceInfo . getSingleSignOnInfo ( ) . getEnabledConfiguration ( ) ) ; specified in parent only , parent wins childInfo . setSingleSignOnInfo ( null ) ; parentInfo . setSingleSignOnInfo ( singleSignOnInfoParent ) ; serviceModule = resolveService ( childInfo , parentInfo ) ; serviceInfo = serviceModule . getModuleInfo ( ) ; assertEquals ( singleSignOnInfoParent . isSupported ( ) , serviceInfo . isSingleSignOnSupported ( ) ) ; assertEquals ( singleSignOnInfoParent . isSupported ( ) , serviceInfo . getSingleSignOnInfo ( ) . isSupported ( ) ) ; assertEquals ( singleSignOnInfoParent . getSupported ( ) , serviceInfo . getSingleSignOnInfo ( ) . getSupported ( ) ) ; assertEquals ( singleSignOnInfoParent . getEnabledConfiguration ( ) , serviceInfo . getSingleSignOnInfo ( ) . getEnabledConfiguration ( ) ) ; specified in both , child wins childInfo . setSingleSignOnInfo ( singleSignOnInfoChild ) ; parentInfo . setSingleSignOnInfo ( singleSignOnInfoParent ) ; serviceModule = resolveService ( childInfo , parentInfo ) ; serviceInfo = serviceModule . getModuleInfo ( ) ; assertEquals ( singleSignOnInfoChild . isSupported ( ) , serviceInfo . isSingleSignOnSupported ( ) ) ; assertEquals ( singleSignOnInfoChild . isSupported ( ) , serviceInfo . getSingleSignOnInfo ( ) . isSupported ( ) ) ; assertEquals ( singleSignOnInfoChild . getSupported ( ) , serviceInfo . getSingleSignOnInfo ( ) . getSupported ( ) ) ; assertEquals ( singleSignOnInfoChild . getEnabledConfiguration ( ) , serviceInfo . getSingleSignOnInfo ( ) . getEnabledConfiguration ( ) ) ; } 
137	public void startDC ( Cluster cluster , int dc ) { logger . debug ( _STR , datacenter ( dc ) ) ; for ( int i = _NUM ; i < = nodes ( dc ) . size ( ) ; i + + ) { int id = ipSuffix ( dc , i ) ; start ( cluster , id ) ; } } 
138	public List < Instance > getInstancesForGroup ( String groupName , String status ) { final AmazonEC _NUM amazonEC _NUM = getEc _NUM Client ( ) ; final DescribeInstancesResult instancesResult = amazonEC _NUM . describeInstances ( new DescribeInstancesRequest ( ) . withFilters ( new Filter ( ) . withName ( _STR + status ) ; } } } return instances ; } 
139	public Hashtable getServerExtensions ( ) throws IOException { if ( this . encryptThenMACOffered & & allowEncryptThenMAC ( ) ) { if ( TlsUtils . isBlockCipherSuite ( this . selectedCipherSuite ) ) { TlsExtensionsUtils . addEncryptThenMACExtension ( checkServerExtensions ( ) ) ; } } if ( this . maxFragmentLengthOffered > = _NUM & & MaxFragmentLength . isValid ( maxFragmentLengthOffered ) ) { TlsExtensionsUtils . addMaxFragmentLengthExtension ( checkServerExtensions ( ) , this . maxFragmentLengthOffered ) ; } if ( this . truncatedHMacOffered & & allowTruncatedHMac ( ) ) { TlsExtensionsUtils . addTruncatedHMacExtension ( checkServerExtensions ( ) ) ; } if ( this . clientECPointFormats ! = null & & TlsECCUtils . isECCipherSuite ( this . selectedCipherSuite ) ) { this . serverECPointFormats = new short [ ] { ECPointFormat . uncompressed , ECPointFormat . ansiX _NUM _NUM _NUM _ compressed _ prime , ECPointFormat . ansiX _NUM _NUM _NUM _ compressed _ char _NUM } ; TlsECCUtils . addSupportedPointFormatsExtension ( checkServerExtensions ( ) , serverECPointFormats ) ; } if ( this . certificateStatusRequest ! = null ) { checkServerExtensions ( ) . put ( TlsExtensionsUtils . EXT _ status _ request , TlsExtensionsUtils . createEmptyExtensionData ( ) ) ; } return serverExtensions ; } 
140	private Iterator < Record > moveOnCurrent ( ) { Iterator < BPTreePage > iter = null ; while ( ! stack . isEmpty ( ) ) { iter = stack . peek ( ) ; if ( iter . hasNext ( ) ) break ; stack . pop ( ) ; } if ( iter = = null | | ! iter . hasNext ( ) ) return null ; BPTreePage p = iter . next ( ) ; BPTreeRecords r = null ; if ( p instanceof BPTreeNode ) { r = loadStack ( ( BPTreeNode ) p ) ; } else { r = ( BPTreeRecords ) p ; } return getRecordsIterator ( r , minRecord , maxRecord ) ; } 
141	private List getRetainedPagesWithTemplate ( List xmlPages ) { list of resources belongs to the selected template List resourcesWithTemplate = new ArrayList ( ) ; TreeMap templates = null ; try { templates = CmsNewResourceXmlPage . getTemplates ( getCms ( ) , null ) ; } catch ( CmsException e ) { if ( LOG . isErrorEnabled ( ) ) { LOG . error ( e . getLocalizedMessage ( ) , e ) ; } } check if the users selected template is valid . if ( ( templates ! = null ) & & templates . containsValue ( getParamTemplate ( ) ) ) { iterate the xmlPages list and add all resources with the specified template to the resourcesWithTemplate list Iterator i = xmlPages . iterator ( ) ; while ( i . hasNext ( ) ) { CmsResource currentPage = ( CmsResource ) i . next ( ) ; read the template property CmsProperty templateProperty ; try { templateProperty = getCms ( ) . readPropertyObject ( getCms ( ) . getSitePath ( currentPage ) , CmsPropertyDefinition . PROPERTY _ TEMPLATE , false ) ; } catch ( CmsException e _NUM ) { if ( LOG . isErrorEnabled ( ) ) { LOG . error ( e _NUM ) ; } continue ; } add currentResource if the template property value is the same as the given template if ( getParamTemplate ( ) . equals ( templateProperty . getValue ( ) ) ) { resourcesWithTemplate . add ( currentPage ) ; } } retain the list of pages against the list with template xmlPages . retainAll ( resourcesWithTemplate ) ; } return xmlPages ; } 
142	public static boolean isNotBlank ( CharSequence cs ) { return ! StringUtils . isBlank ( cs ) ; } 
143	 @ NullableSerializable getSerializable ( @ Nullable String key ) { unparcel ( ) ; Object o = mMap . get ( key ) ; if ( o = = null ) { return null ; } try { return ( Serializable ) o ; } catch ( ClassCastException e ) { typeWarning ( key , o , _STR , e ) ; return null ; } } 
144	public final E _ StrEncodeForURI encode ( Object expr ) { return new E _ StrEncodeForURI ( asExpr ( expr ) ) ; } 
145	public void show ( ) { if ( mShowing ) { if ( mDecor ! = null ) { if ( mWindow . hasFeature ( Window . FEATURE _ ACTION _ BAR ) ) { mWindow . invalidatePanelMenu ( Window . FEATURE _ ACTION _ BAR ) ; } if ( mDecor . getVisibility ( ) ! = View . VISIBLE ) { mDecor . setVisibility ( View . VISIBLE ) ; sendShowMessage ( ) ; } } return ; } mCanceled = false ; if ( ! mCreated ) { dispatchOnCreate ( null ) ; } else { Fill the DecorView in on any configuration changes that may have occured while it was removed from the WindowManager . final Configuration config = mContext . getResources ( ) . getConfiguration ( ) ; mWindow . getDecorView ( ) . dispatchConfigurationChanged ( config ) ; } onStart ( ) ; mDecor = mWindow . getDecorView ( ) ; if ( mActionBar = = null & & mWindow . hasFeature ( Window . FEATURE _ ACTION _ BAR ) ) { final ApplicationInfo info = mContext . getApplicationInfo ( ) ; mWindow . setDefaultIcon ( info . icon ) ; mWindow . setDefaultLogo ( info . logo ) ; mActionBar = new WindowDecorActionBar ( this ) ; } WindowManager . LayoutParams l = mWindow . getAttributes ( ) ; if ( ( l . softInputMode & WindowManager . LayoutParams . SOFT _ INPUT _ IS _ FORWARD _ NAVIGATION ) = = _NUM ) { WindowManager . LayoutParams nl = new WindowManager . LayoutParams ( ) ; nl . copyFrom ( l ) ; nl . softInputMode | = WindowManager . LayoutParams . SOFT _ INPUT _ IS _ FORWARD _ NAVIGATION ; l = nl ; } mWindowManager . addView ( mDecor , l ) ; mShowing = true ; sendShowMessage ( ) ; } 
146	private boolean updateRestrictionsIfNeededLR ( int userId , @ Nullable Bundle restrictions , SparseArray < Bundle > restrictionsArray ) { final boolean changed = ! UserRestrictionsUtils . areEqual ( restrictionsArray . get ( userId ) , restrictions ) ; if ( changed ) { if ( ! UserRestrictionsUtils . isEmpty ( restrictions ) ) { restrictionsArray . put ( userId , restrictions ) ; } else { restrictionsArray . delete ( userId ) ; } } return changed ; } 
147	void initWeights ( final int [ ] textLen , final int nchildren , final Data data , final int w ) { weight = new double [ size ] ; only children if ( w = = _NUM ) { for ( int i = _NUM ; i < size ; + + i ) { weight [ i ] = ( double ) ViewData . size ( data , list [ i ] ) / nchildren ; } return ; } summarize sizes final double sizeP = w / _NUM _NUM _NUM . _NUM d ; long sum = _NUM ; for ( int i = _NUM ; i < size ; + + i ) sum + = weight ( textLen , data , i ) ; use # children and size for weight if ( sizeP < _NUM ) { for ( int i = _NUM ; i < size ; + + i ) { weight [ i ] = sizeP * weight ( textLen , data , i ) / sum + ( _NUM - sizeP ) * ViewData . size ( data , list [ i ] ) / nchildren ; } only sizes } else { for ( int i = _NUM ; i < size ; + + i ) { weight [ i ] = weight ( textLen , data , i ) / sum ; } } } 
148	public GF _NUM Polynomial gcd ( GF _NUM Polynomial g ) throws RuntimeException { if ( isZero ( ) & & g . isZero ( ) ) { throw new ArithmeticException ( _STR ) ; } if ( isZero ( ) ) { return new GF _NUM Polynomial ( g ) ; } if ( g . isZero ( ) ) { return new GF _NUM Polynomial ( this ) ; } GF _NUM Polynomial a = new GF _NUM Polynomial ( this ) ; GF _NUM Polynomial b = new GF _NUM Polynomial ( g ) ; GF _NUM Polynomial c ; while ( ! b . isZero ( ) ) { c = a . remainder ( b ) ; a = b ; b = c ; } return a ; } 
149	public void addNode ( @ Nonnull Layout currentLayout , @ Nonnull String endpoint , boolean isLayoutServer , boolean isSequencerServer , boolean isLogUnitServer , boolean isUnresponsiveServer , int logUnitStripeIndex ) throws OutrankedException { Layout newLayout ; if ( ! currentLayout . getAllServers ( ) . contains ( endpoint ) ) { sealEpoch ( currentLayout ) ; LayoutBuilder layoutBuilder = new LayoutBuilder ( currentLayout ) ; if ( isLayoutServer ) { layoutBuilder . addLayoutServer ( endpoint ) ; } if ( isSequencerServer ) { layoutBuilder . addSequencerServer ( endpoint ) ; } if ( isLogUnitServer ) { Layout . LayoutSegment latestSegment = currentLayout . getSegments ( ) . get ( currentLayout . getSegments ( ) . size ( ) - _NUM ) ; layoutBuilder . addLogunitServer ( logUnitStripeIndex , getMaxGlobalTail ( currentLayout , latestSegment ) , endpoint ) ; } if ( isUnresponsiveServer ) { layoutBuilder . addUnresponsiveServers ( Collections . singleton ( endpoint ) ) ; } newLayout = layoutBuilder . build ( ) ; attemptConsensus ( newLayout ) ; } else { log . info ( _STR , endpoint ) ; newLayout = currentLayout ; } Add node is successful even if reconfigure sequencer fails . TODO : Optimize this by retrying or submitting a workflow to retry . reconfigureSequencerServers ( currentLayout , newLayout , false ) ; } 
150	private void writeNewLine ( ) throws SAXException { try { write new line m _ writer . write ( _STR ) ; write indentation for ( int i = _NUM ; i < m _ indentLevel ; i + + ) { m _ writer . write ( INDENT _ STR ) ; } flush the stream m _ writer . flush ( ) ; } catch ( IOException e ) { throw new SAXException ( Messages . get ( ) . getBundle ( ) . key ( Messages . ERR _ IOERROR _ _NUM ) , e ) ; } } 
151	protected WOTSPlusSignature sign ( byte [ ] messageDigest , OTSHashAddress otsHashAddress ) { if ( messageDigest = = null ) { throw new NullPointerException ( _STR ) ; } List < Integer > baseWMessage = convertToBaseW ( messageDigest , params . getWinternitzParameter ( ) , params . getLen _NUM ( ) ) ; int checksum = _NUM ; for ( int i = _NUM ; i < params . getLen _NUM ( ) ; i + + ) { checksum + = params . getWinternitzParameter ( ) - _NUM - baseWMessage . get ( i ) ; } checksum < < = ( _NUM - ( ( params . getLen _NUM ( ) * XMSSUtil . log _NUM ( params . getWinternitzParameter ( ) ) ) % _NUM ) ) ; int len _NUM Bytes = ( int ) Math . ceil ( ( double ) ( params . getLen _NUM ( ) * XMSSUtil . log _NUM ( params . getWinternitzParameter ( ) ) ) / _NUM ) ; List < Integer > baseWChecksum = convertToBaseW ( XMSSUtil . toBytesBigEndian ( checksum , len _NUM Bytes ) , params . getWinternitzParameter ( ) , params . getLen _NUM ( ) ) ; baseWMessage . addAll ( baseWChecksum ) ; byte [ ] [ ] signature = new byte [ params . getLen ( ) ] [ ] ; for ( int i = _NUM ; i < params . getLen ( ) ; i + + ) { otsHashAddress = ( OTSHashAddress ) new OTSHashAddress . Builder ( ) . withLayerAddress ( otsHashAddress . getLayerAddress ( ) ) . withTreeAddress ( otsHashAddress . getTreeAddress ( ) ) . withOTSAddress ( otsHashAddress . getOTSAddress ( ) ) . withChainAddress ( i ) . withHashAddress ( otsHashAddress . getHashAddress ( ) ) . withKeyAndMask ( otsHashAddress . getKeyAndMask ( ) ) . build ( ) ; signature [ i ] = chain ( expandSecretKeySeed ( i ) , _NUM , baseWMessage . get ( i ) , otsHashAddress ) ; } return new WOTSPlusSignature ( params , signature ) ; } 
152	private void reportGeofencePauseStatus ( int geofenceId , int status ) { if ( mGeofenceHardwareImpl = = null ) { mGeofenceHardwareImpl = GeofenceHardwareImpl . getInstance ( mContext ) ; } mGeofenceHardwareImpl . reportGeofencePauseStatus ( geofenceId , getGeofenceStatus ( status ) ) ; } 
153	public static boolean isInvoiceType ( GenericValue invoice , String inputTypeId ) throws GenericEntityException { if ( invoice = = null ) { return false ; } GenericValue invoiceType = invoice . getRelatedOne ( _STR ) ; if ( inputTypeId . equals ( invoiceTypeId ) ) { return true ; } recurse up tree return isInvoiceTypeRecurse ( invoiceType , inputTypeId ) ; } 
154	public void testXAttrs ( ) throws Exception { final String name _NUM = _STR ) ; xAttrs = getXAttrs ( statusJson ) ; Assert . assertEquals ( _NUM , xAttrs . size ( ) ) ; } 
155	public void visit ( Visitor v ) throws JasperException { Iterator iter = list . iterator ( ) ; while ( iter . hasNext ( ) ) { Node n = ( Node ) iter . next ( ) ; n . accept ( v ) ; } } 
156	public final CharGroup posCharGroup ( ) throws ParseException { final RegExpList cg = new RegExpList ( ) ; RegExp sub = null ; label _ _NUM : while ( true ) { if ( jj _ _NUM _ _NUM ( _NUM ) ) { sub = charRange ( ) ; cg . add ( sub ) ; } else { switch ( ( jj _ ntk = = - _NUM ) ? jj _ ntk ( ) : jj _ ntk ) { case SINGLE _ ESC : case MULTI _ ESC : case CAT _ ESC : switch ( ( jj _ ntk = = - _NUM ) ? jj _ ntk ( ) : jj _ ntk ) { case SINGLE _ ESC : jj _ consume _ token ( SINGLE _ ESC ) ; break ; case MULTI _ ESC : jj _ consume _ token ( MULTI _ ESC ) ; break ; case CAT _ ESC : jj _ consume _ token ( CAT _ ESC ) ; break ; default : jj _ la _NUM [ _NUM _NUM ] = jj _ gen ; jj _ consume _ token ( - _NUM ) ; throw new ParseException ( ) ; } for ( final RegExp re : Escape . inGroup ( token . image ) ) cg . add ( re ) ; break ; default : jj _ la _NUM [ _NUM _NUM ] = jj _ gen ; jj _ consume _ token ( - _NUM ) ; throw new ParseException ( ) ; } } if ( jj _ _NUM _ _NUM ( _NUM ) ) { ; } else { break label _ _NUM ; } } { if ( true ) return new CharGroup ( cg . finish ( ) ) ; } throw new Error ( _STR ) ; } 
157	private boolean pruneInstantApps ( long neededSpace , long maxInstalledCacheDuration , long maxUninstalledCacheDuration ) throws IOException { final StorageManager storage = mService . mContext . getSystemService ( StorageManager . class ) ; final File file = storage . findPathForUuid ( StorageManager . UUID _ PRIVATE _ INTERNAL ) ; if ( file . getUsableSpace ( ) > = neededSpace ) { return true ; } List < String > packagesToDelete = null ; final int [ ] allUsers ; final long now = System . currentTimeMillis ( ) ; Prune first installed instant apps synchronized ( mService . mPackages ) { allUsers = PackageManagerService . sUserManager . getUserIds ( ) ; final int packageCount = mService . mPackages . size ( ) ; for ( int i = _NUM ; i < packageCount ; i + + ) { final PackageParser . Package pkg = mService . mPackages . valueAt ( i ) ; if ( now - pkg . getLatestPackageUseTimeInMills ( ) < maxInstalledCacheDuration ) { continue ; } if ( ! ( pkg . mExtras instanceof PackageSetting ) ) { continue ; } final PackageSetting ps = ( PackageSetting ) pkg . mExtras ; boolean installedOnlyAsInstantApp = false ; for ( int userId : allUsers ) { if ( ps . getInstalled ( userId ) ) { if ( ps . getInstantApp ( userId ) ) { installedOnlyAsInstantApp = true ; } else { installedOnlyAsInstantApp = false ; break ; } } } if ( installedOnlyAsInstantApp ) { if ( packagesToDelete = = null ) { packagesToDelete = new ArrayList < > ( ) ; } packagesToDelete . add ( pkg . packageName ) ; } } if ( packagesToDelete ! = null ) { packagesToDelete . sort ( ( String lhs , String rhs ) - > { final PackageParser . Package lhsPkg = mService . mPackages . get ( lhs ) ; final PackageParser . Package rhsPkg = mService . mPackages . get ( rhs ) ; if ( lhsPkg = = null & & rhsPkg = = null ) { return _NUM ; } else if ( lhsPkg = = null ) { return - _NUM ; } else if ( rhsPkg = = null ) { return _NUM ; } else { if ( lhsPkg . getLatestPackageUseTimeInMills ( ) > rhsPkg . getLatestPackageUseTimeInMills ( ) ) { return _NUM ; } else if ( lhsPkg . getLatestPackageUseTimeInMills ( ) < rhsPkg . getLatestPackageUseTimeInMills ( ) ) { return - _NUM ; } else { if ( lhsPkg . mExtras instanceof PackageSetting & & rhsPkg . mExtras instanceof PackageSetting ) { final PackageSetting lhsPs = ( PackageSetting ) lhsPkg . mExtras ; final PackageSetting rhsPs = ( PackageSetting ) rhsPkg . mExtras ; if ( lhsPs . firstInstallTime > rhsPs . firstInstallTime ) { return _NUM ; } else { return - _NUM ; } } else { return _NUM ; } } } } ) ; } } if ( packagesToDelete ! = null ) { final int packageCount = packagesToDelete . size ( ) ; for ( int i = _NUM ; i < packageCount ; i + + ) { final String packageToDelete = packagesToDelete . get ( i ) ; if ( mService . deletePackageX ( packageToDelete , PackageManager . VERSION _ CODE _ HIGHEST , UserHandle . USER _ SYSTEM , PackageManager . DELETE _ ALL _ USERS ) = = PackageManager . DELETE _ SUCCEEDED ) { if ( file . getUsableSpace ( ) > = neededSpace ) { return true ; } } } } Prune uninstalled instant apps synchronized ( mService . mPackages ) { TODO : Track last used time for uninstalled instant apps for better pruning for ( int userId : UserManagerService . getInstance ( ) . getUserIds ( ) ) { Prune in - memory state removeUninstalledInstantAppStateLPw ( ( UninstalledInstantAppState state ) - > { final long elapsedCachingMillis = System . currentTimeMillis ( ) - state . mTimestamp ; return ( elapsedCachingMillis > maxUninstalledCacheDuration ) ; } , userId ) ; Prune on - disk state File instantAppsDir = getInstantApplicationsDir ( userId ) ; if ( ! instantAppsDir . exists ( ) ) { continue ; } File [ ] files = instantAppsDir . listFiles ( ) ; if ( files = = null ) { continue ; } for ( File instantDir : files ) { if ( ! instantDir . isDirectory ( ) ) { continue ; } File metadataFile = new File ( instantDir , INSTANT _ APP _ METADATA _ FILE ) ; if ( ! metadataFile . exists ( ) ) { continue ; } final long elapsedCachingMillis = System . currentTimeMillis ( ) - metadataFile . lastModified ( ) ; if ( elapsedCachingMillis > maxUninstalledCacheDuration ) { deleteDir ( instantDir ) ; if ( file . getUsableSpace ( ) > = neededSpace ) { return true ; } } } } } return false ; } 
158	public void trim ( ) { if ( transientData = = null ) { We don ' t have any updates to this object . Return quickly . return ; } Beware this array is longer than the number of elements we interested in long [ ] transientValues = transientData . sortedValues ( ) ; int pCompressed = _NUM ; int pTransient = _NUM ; LongsDiffReader reader = new LongsDiffReader ( compressedData , useUnsafeSerialization ) ; LongsDiffWriter writer = new LongsDiffWriter ( useUnsafeSerialization ) ; long curValue = size > _NUM ? reader . readNext ( ) : Long . MAX _ VALUE ; them , we move to pointers and store result in the new array while ( pTransient < transientData . numberOfAddedElements ( ) | | pCompressed < size ) { if ( pTransient < transientData . numberOfAddedElements ( ) & & curValue > = transientValues [ pTransient ] ) { writer . writeNext ( transientValues [ pTransient ] ) ; pTransient + + ; } else { if ( ! transientData . isRemoved ( pCompressed ) ) { writer . writeNext ( curValue ) ; } pCompressed + + ; if ( pCompressed < size ) { curValue = reader . readNext ( ) ; } else { curValue = Long . MAX _ VALUE ; } } } compressedData = writer . toByteArray ( ) ; size + = transientData . size ( ) ; transientData = null ; } 
159	public static final int maskZero ( int start , int finish ) { check ( start , finish ) ; return maskZero $ ( start , finish ) ; } 
160	public static < T > Set < T > getInstancesOf ( Injector injector , Matcher < Class > matcher ) { Set < T > answer = Sets . newHashSet ( ) ; Set < Entry < Key < ? > , Binding < ? > > > entries = injector . getBindings ( ) . entrySet ( ) ; for ( Entry < Key < ? > , Binding < ? > > entry : entries ) { Key < ? > key = entry . getKey ( ) ; Class < ? > keyType = getKeyType ( key ) ; if ( keyType ! = null & & matcher . matches ( keyType ) ) { Binding < ? > binding = entry . getValue ( ) ; Object value = binding . getProvider ( ) . get ( ) ; answer . add ( ( T ) value ) ; } } return answer ; } 
161	public void removePageComment ( final String commentId ) throws ServiceException { final Transaction transaction = commentRepository . beginTransaction ( ) ; try { final JSONObject comment = commentRepository . get ( commentId ) ; final String pageId = comment . getString ( Comment . COMMENT _ ON _ ID ) ; Step _NUM : Remove comment commentRepository . remove ( commentId ) ; Step _NUM : Update page comment count decPageCommentCount ( pageId ) ; Step _NUM : Update blog statistic comment count statisticMgmtService . decBlogCommentCount ( ) ; statisticMgmtService . decPublishedBlogCommentCount ( ) ; transaction . commit ( ) ; } catch ( final Exception e ) { if ( transaction . isActive ( ) ) { transaction . rollback ( ) ; } LOGGER . log ( Level . ERROR , _STR , e ) ; throw new ServiceException ( e ) ; } } 
162	List < InputSplit > getSplits ( final JobContext context , final String startKey , final String endKey ) throws IOException , InterruptedException { Configuration conf = context . getConfiguration ( ) ; boolean ignoreMissing = conf . getBoolean ( WALPlayer . IGNORE _ MISSING _ FILES , false ) ; Path [ ] inputPaths = getInputPaths ( conf ) ; long startTime = conf . getLong ( startKey , Long . MIN _ VALUE ) ; long endTime = conf . getLong ( endKey , Long . MAX _ VALUE ) ; List < FileStatus > allFiles = new ArrayList < FileStatus > ( ) ; for ( Path inputPath : inputPaths ) { FileSystem fs = inputPath . getFileSystem ( conf ) ; try { List < FileStatus > files = getFiles ( fs , inputPath , startTime , endTime ) ; allFiles . addAll ( files ) ; } catch ( FileNotFoundException e ) { if ( ignoreMissing ) { LOG . warn ( _STR ) ; continue ; } throw e ; } } List < InputSplit > splits = new ArrayList < InputSplit > ( allFiles . size ( ) ) ; for ( FileStatus file : allFiles ) { splits . add ( new WALSplit ( file . getPath ( ) . toString ( ) , file . getLen ( ) , startTime , endTime ) ) ; } return splits ; } 
163	public static byte [ ] decodeFromFile ( String filename ) throws java . io . IOException { byte [ ] decodedData = null ; InputStream bis = null ; try { Set up some useful variables java . io . File file = new java . io . File ( filename ) ; byte [ ] buffer = null ; int length = _NUM ; int numBytes = _NUM ; Check for size of file if ( file . length ( ) > Integer . MAX _ VALUE ) { throw new java . io . IOException ( _STR ) ; } end if : file too big for int index buffer = new byte [ ( int ) file . length ( ) ] ; Open a stream bis = new InputStream ( new java . io . BufferedInputStream ( new java . io . FileInputStream ( file ) ) , Base _NUM _NUM . DECODE ) ; Read until done while ( ( numBytes = bis . read ( buffer , length , _NUM _NUM _NUM _NUM ) ) > = _NUM ) { length + = numBytes ; } end while Save in a variable to return decodedData = new byte [ length ] ; System . arraycopy ( buffer , _NUM , decodedData , _NUM , length ) ; } end try catch ( java . io . IOException e ) { Catch and release to execute finally { } throw e ; } finally end catch : java . io . IOException { try { bis . close ( ) ; } catch ( Exception e ) { } } return decodedData ; } 
164	public void removeSpectator ( final User user ) { logger . info ( String . format ( _STR , user . toString ( ) , id ) ) ; synchronized ( spectators ) { if ( ! spectators . remove ( user ) ) { return ; } not actually spectating user . leaveGame ( this ) ; } do this down here so the person that left doesn ' t get the notice too final HashMap < ReturnableData , Object > data = getEventMap ( ) ; data . put ( LongPollResponse . EVENT , LongPollEvent . GAME _ SPECTATOR _ LEAVE . toString ( ) ) ; data . put ( LongPollResponse . NICKNAME , user . getNickname ( ) ) ; broadcastToPlayers ( MessageType . GAME _ PLAYER _ EVENT , data ) ; Don ' t do this anymore , it was driving up a crazy amount of traffic . gameManager . broadcastGameListRefresh ( ) ; } 
165	public static void enableDeathOnNetwork ( ) { int oldPolicy = getThreadPolicyMask ( ) ; int newPolicy = oldPolicy | DETECT _ NETWORK | PENALTY _ DEATH _ ON _ NETWORK ; setThreadPolicyMask ( newPolicy ) ; } 
166	private long recoverLastTxId ( EditLogLedgerMetadata l , boolean fence ) throws IOException , SegmentEmptyException { LedgerHandle lh = null ; try { if ( fence ) { lh = bkc . openLedger ( l . getLedgerId ( ) , BookKeeper . DigestType . MAC , digestpw . getBytes ( Charsets . UTF _ _NUM ) ) ; } else { lh = bkc . openLedgerNoRecovery ( l . getLedgerId ( ) , BookKeeper . DigestType . MAC , digestpw . getBytes ( Charsets . UTF _ _NUM ) ) ; } } catch ( BKException bke ) { throw new IOException ( _STR + l , ie ) ; } BookKeeperEditLogInputStream in = null ; try { long lastAddConfirmed = lh . getLastAddConfirmed ( ) ; if ( lastAddConfirmed = = - _NUM ) { throw new SegmentEmptyException ( ) ; } in = new BookKeeperEditLogInputStream ( lh , l , lastAddConfirmed ) ; long endTxId = HdfsServerConstants . INVALID _ TXID ; FSEditLogOp op = in . readOp ( ) ; while ( op ! = null ) { if ( endTxId = = HdfsServerConstants . INVALID _ TXID | | op . getTransactionId ( ) = = endTxId + _NUM ) { endTxId = op . getTransactionId ( ) ; } op = in . readOp ( ) ; } return endTxId ; } finally { if ( in ! = null ) { in . close ( ) ; } } } 
167	public static String toHex ( final byte [ ] value ) { StringBuilder retVal = new StringBuilder ( ) ; retVal . append ( ' [ ' ) ; if ( value ! = null & & value . length > _NUM ) { for ( int x = _NUM ; x < value . length ; x + + ) { if ( x > _NUM ) { retVal . append ( _STR ) ; } retVal . append ( toHex ( value [ x ] ) ) ; } } retVal . append ( ' ] ' ) ; return retVal . toString ( ) ; } 
168	public static double daleChallGrade ( String strText ) { http : double score = daleChallScore ( strText ) ; if ( score < _NUM . _NUM ) { return _NUM . _NUM ; } else if ( score < _NUM . _NUM ) { return _NUM . _NUM ; } else if ( score < _NUM . _NUM ) { return _NUM . _NUM ; } else if ( score < _NUM . _NUM ) { return _NUM . _NUM ; } else if ( score < _NUM . _NUM ) { return _NUM _NUM . _NUM ; } else if ( score < _NUM _NUM . _NUM ) { return _NUM _NUM . _NUM ; } else { return _NUM _NUM . _NUM ; } } 
169	public static boolean isFloat ( String s , boolean allowNegative , boolean allowPositive , int minDecimal , int maxDecimal ) { if ( isEmpty ( s ) ) return defaultEmptyOK ; try { float temp = Float . parseFloat ( s ) ; if ( ! allowNegative & & temp < _NUM ) return false ; if ( ! allowPositive & & temp > _NUM ) return false ; int decimalPoint = s . indexOf ( _STR ) ; if ( decimalPoint = = - _NUM ) { if ( minDecimal > _NUM ) return false ; return true ; } _NUM . _NUM _NUM _NUM _NUM ; length = _NUM ; point = _NUM ; num = _NUM int numDecimals = s . length ( ) - decimalPoint - _NUM ; if ( minDecimal > = _NUM & & numDecimals < minDecimal ) return false ; if ( maxDecimal > = _NUM & & numDecimals > maxDecimal ) return false ; return true ; } catch ( Exception e ) { return false ; } } 
170	public List < Article > query ( String title , Logger logger ) { for ( String titleForm : cookedTitles ( title ) ) { List < Article > fuzzyLookupEntities ; List < Article > crossWikiEntities ; while ( true ) { try { fuzzyLookupEntities = queryFuzzyLookup ( titleForm , logger ) ; crossWikiEntities = queryCrossWikiLookup ( titleForm , logger ) ; Success ! break ; } catch ( IOException e ) { e . printStackTrace ( ) ; System . err . println ( _STR ) ; try { TimeUnit . SECONDS . sleep ( _NUM _NUM ) ; } catch ( InterruptedException e _NUM ) { oof . . . e _NUM . printStackTrace ( ) ; } } } List < Article > entities = mergeResults ( fuzzyLookupEntities , crossWikiEntities , logger ) ; List < Article > results = new ArrayList < > ( ) ; for ( Article a : entities ) { results . addAll ( queryArticle ( a , logger ) ) ; } results = deduplicateResults ( results ) ; if ( ! results . isEmpty ( ) ) return results ; } return new ArrayList < Article > ( ) ; } 
171	public void createEntry ( Configuration conf , String name , char [ ] credential ) throws Exception { if ( ! isHadoopCredentialProviderAvailable ( ) ) { return ; } List < Object > providers = getCredentialProviders ( conf ) ; if ( null = = providers ) { throw new IOException ( _STR ) ; } Object provider = providers . get ( _NUM ) ; createEntryInProvider ( provider , name , credential ) ; } 
172	public void progressiveStart ( int index ) { resetProgressiveStart ( index ) ; start ( ) ; } 
173	public void setTheme ( int themeResId ) { if ( themeResId ! = - _NUM ) { TypedArray a = getContext ( ) . obtainStyledAttributes ( themeResId , R . styleable . BetterPickersDialogFragment ) ; mTitleColor = a . getColorStateList ( R . styleable . BetterPickersDialogFragment _ bpTitleColor ) ; } restyleViews ( ) ; } 
174	public void run ( ) { the official OBB file path and the mount - request file path should be the same , but let ' s distinguish the two as they may make for some interesting tests later mOfficialObbFilePath = mountObb ( mObbFilePath ) ; assertEquals ( _STR + e . toString ( ) ) ; } } 
175	protected void cancel ( ) { reset ( ) ; } 
176	public InstallRequest build ( ) { validate ( ) ; return new InstallRequest ( term , leader , index , timestamp , offset , data , complete ) ; } 
177	public void refreshNodes ( final Configuration conf ) throws IOException { refreshHostsReader ( conf ) ; namesystem . writeLock ( ) ; try { refreshDatanodes ( ) ; countSoftwareVersions ( ) ; } finally { namesystem . writeUnlock ( ) ; } } 
178	public void animateIn ( ) { mLayoutManager . slideIn ( ) ; } 
179	private void addCustomViewsWithGravity ( List < View > views , int gravity ) { final boolean isRtl = ViewCompat . getLayoutDirection ( this ) = = ViewCompat . LAYOUT _ DIRECTION _ RTL ; final int childCount = getChildCount ( ) ; final int absGrav = GravityCompat . getAbsoluteGravity ( gravity , ViewCompat . getLayoutDirection ( this ) ) ; views . clear ( ) ; if ( isRtl ) { for ( int i = childCount - _NUM ; i > = _NUM ; i - - ) { final View child = getChildAt ( i ) ; final LayoutParams lp = ( LayoutParams ) child . getLayoutParams ( ) ; if ( lp . mViewType = = LayoutParams . CUSTOM & & shouldLayout ( child ) & & getChildHorizontalGravity ( lp . gravity ) = = absGrav ) { views . add ( child ) ; } } } else { for ( int i = _NUM ; i < childCount ; i + + ) { final View child = getChildAt ( i ) ; final LayoutParams lp = ( LayoutParams ) child . getLayoutParams ( ) ; if ( lp . mViewType = = LayoutParams . CUSTOM & & shouldLayout ( child ) & & getChildHorizontalGravity ( lp . gravity ) = = absGrav ) { views . add ( child ) ; } } } } 
180	public static char [ ] toCharArray ( InputStream is , String encoding ) throws IOException { CharArrayWriter output = new CharArrayWriter ( ) ; copy ( is , output , encoding ) ; return output . toCharArray ( ) ; } 
181	public X _NUM _NUM _NUM Certificate generate ( PrivateKey key , String provider , SecureRandom random ) throws CertificateEncodingException , IllegalStateException , NoSuchProviderException , NoSuchAlgorithmException , SignatureException , InvalidKeyException { TBSCertificate tbsCert = tbsGen . generateTBSCertificate ( ) ; byte [ ] signature ; try { signature = X _NUM _NUM _NUM Util . calculateSignature ( sigOID , signatureAlgorithm , provider , key , random , tbsCert ) ; } catch ( IOException e ) { throw new ExtCertificateEncodingException ( _STR , e ) ; } return generateJcaObject ( tbsCert , signature ) ; } 
182	public org . bitcoinj . wallet . Protos . PeerAddress . Builder getBroadcastByBuilder ( int index ) { return getBroadcastByFieldBuilder ( ) . getBuilder ( index ) ; } 
183	public < V extends Comparable < ? super V > > S sortedBy ( Function < ? super T , ? extends V > keyExtractor ) { return sorted ( Comparator . comparing ( keyExtractor ) ) ; } 
184	 - - - - - - - - - - - - - - - - - - - controller services - - - - - - - - - - - - - - - - - - - @ POST @ Consumes ( MediaType . APPLICATION _ JSON ) @ Produces ( MediaType . APPLICATION _ JSON ) @ Path ( _STR ) ; } if ( isReplicateRequest ( ) ) { return replicate ( HttpMethod . POST , requestControllerServiceEntity ) ; } return withWriteLock ( serviceFacade , requestControllerServiceEntity , lookup - > { authorizeController ( RequestAction . WRITE ) ; ComponentAuthorizable authorizable = null ; try { authorizable = lookup . getConfigurableComponent ( requestControllerService . getType ( ) , requestControllerService . getBundle ( ) ) ; if ( authorizable . isRestricted ( ) ) { authorizeRestrictions ( authorizer , authorizable ) ; } if ( requestControllerService . getProperties ( ) ! = null ) { AuthorizeControllerServiceReference . authorizeControllerServiceReferences ( requestControllerService . getProperties ( ) , authorizable , authorizer , lookup ) ; } } finally { if ( authorizable ! = null ) { authorizable . cleanUpResources ( ) ; } } } , ( ) - > serviceFacade . verifyCreateControllerService ( requestControllerService ) , ( controllerServiceEntity ) - > { final ControllerServiceDTO controllerService = controllerServiceEntity . getComponent ( ) ; set the processor id as appropriate controllerService . setId ( generateUuid ( ) ) ; create the controller service and generate the json final Revision revision = getRevision ( controllerServiceEntity , controllerService . getId ( ) ) ; final ControllerServiceEntity entity = serviceFacade . createControllerService ( revision , null , controllerService ) ; controllerServiceResource . populateRemainingControllerServiceEntityContent ( entity ) ; build the response return generateCreatedResponse ( URI . create ( entity . getUri ( ) ) , entity ) . build ( ) ; } ) ; } 
185	SharedPreferences . Editor getEditor ( ) { if ( mPreferenceDataStore ! = null ) { return null ; } if ( mNoCommit ) { if ( mEditor = = null ) { mEditor = getSharedPreferences ( ) . edit ( ) ; } return mEditor ; } else { return getSharedPreferences ( ) . edit ( ) ; } } 
186	private void addItems ( zemberek . morphology . lexicon . proto . LexiconProto . DictionaryItem . Builder builderForValue ) { ensureItemsIsMutable ( ) ; items _ . add ( builderForValue . build ( ) ) ; } 
187	private DB openStorage ( StorageType storageType ) { DB storage = storageRegistry . get ( storageType ) ; if ( ! isOpenStorage ( storage ) ) { DBMaker m ; if ( storageType = = StorageType . PRIMARY _ STORAGE | | storageType = = StorageType . SECONDARY _ STORAGE ) { main storage Path rootPath = getRootPath ( storageName ) ; try { createDirectoryIfNotExists ( rootPath ) ; } catch ( IOException ex ) { throw new UncheckedIOException ( ex ) ; } m = DBMaker . newFileDB ( new File ( rootPath . toFile ( ) , storageType . toString ( ) ) ) ; } else if ( storageType = = StorageType . TEMP _ PRIMARY _ STORAGE | | storageType = = StorageType . TEMP _ SECONDARY _ STORAGE ) { temporary storage m = DBMaker . newTempFileDB ( ) . deleteFilesAfterClose ( ) ; } else { throw new IllegalArgumentException ( _STR ) ; } if ( storageConfiguration . isCompressed ( ) ) { m = m . compressionEnable ( ) ; } boolean permitCaching = storageType = = StorageType . PRIMARY _ STORAGE | | storageType = = StorageType . TEMP _ PRIMARY _ STORAGE ; if ( permitCaching & & storageConfiguration . getCacheSize ( ) > _NUM ) { m = m . cacheLRUEnable ( ) . cacheSize ( storageConfiguration . getCacheSize ( ) ) ; } else { m = m . cacheDisable ( ) ; } if ( storageConfiguration . isAsynchronous ( ) ) { m = m . asyncWriteEnable ( ) ; } m = m . transactionDisable ( ) ; m = m . closeOnJvmShutdown ( ) ; storage = m . make ( ) ; storageRegistry . put ( storageType , storage ) ; } return storage ; } 
188	public static HostAndPort fromParts ( String host , int port ) { checkArgument ( isValidPort ( port ) , _STR , host ) ; return new HostAndPort ( parsedHost . host , port , parsedHost . hasBracketlessColons ) ; } 
189	protected void testWeightedScaleWithR ( SIZE sz , RANGE rng , SPARSITY sp , RUNTIME _ PLATFORM rt ) { RUNTIME _ PLATFORM oldrt = rtplatform ; rtplatform = rt ; try { TestConfiguration config = getTestConfiguration ( _STR ) ; } } finally { reset runtime platform rtplatform = oldrt ; } } 
190	void cacheFlairsByFile ( final String sub , final String filename , final Context context ) { final ArrayList < String > flairsToGet = new ArrayList < > ( ) ; LogUtil . v ( _STR + offset . width ) ; } else { backScaling = new Dimensions ( ) ; offset = new Dimensions ( ) ; } if ( ( ! backScaling . missing & & ! backScaling . scale ) | | ( ! offset . missing & & ! offset . scale ) ) { Bitmap loaded = getFlairImageLoader ( context ) . loadImageSync ( filename , new ImageSize ( backScaling . width , backScaling . height ) ) ; if ( loaded ! = null ) { Bitmap b ; if ( backScaling . missing | | backScaling . width < offset . width ) { b = Bitmap . createScaledBitmap ( loaded , offset . width , offset . height , false ) ; } else { b = Bitmap . createScaledBitmap ( loaded , backScaling . width , backScaling . height , false ) ; } loadingComplete ( b , sub , context , filename , flairsToGet ) ; loaded . recycle ( ) ; } } else { Bitmap loadedB = getFlairImageLoader ( context ) . loadImageSync ( filename ) ; if ( loadedB ! = null ) { if ( backScaling . scale ) { int width = backScaling . width ; int height = loadedB . getHeight ( ) ; int scaledHeight = ( height * width ) / loadedB . getWidth ( ) ; loadingComplete ( Bitmap . createScaledBitmap ( loadedB , width , scaledHeight , false ) , sub , context , filename , flairsToGet ) ; loadedB . recycle ( ) ; } else { loadingComplete ( loadedB , sub , context , filename , flairsToGet ) ; } } } } 
191	private void setupEdgeCaseOneJnHasSegmentWithAcceptedRecovery ( ) throws Exception { Log segment with txns _NUM - _NUM _NUM _NUM succeeds writeSegment ( cluster , qjm , _NUM , _NUM _NUM _NUM , true ) ; startLogSegment only makes it to one of the three nodes failLoggerAtTxn ( spies . get ( _NUM ) , _NUM _NUM _NUM ) ; failLoggerAtTxn ( spies . get ( _NUM ) , _NUM _NUM _NUM ) ; try { writeSegment ( cluster , qjm , _NUM _NUM _NUM , _NUM , true ) ; fail ( _STR ) ; } 
192	private void setISO ( int newMode , boolean rebuildGUI ) { if ( newMode ! = - _NUM ) { if ( mSceneMode ! = CameraParameters . SCENE _ MODE _ AUTO & & CameraController . isSceneModeSupported ( ) ) setSceneMode ( CameraParameters . SCENE _ MODE _ AUTO , false ) ; CameraController . setCameraISO ( newMode ) ; mISO = newMode ; setButtonSelected ( isoButtons , mISO ) ; preferences . edit ( ) . putInt ( ApplicationScreen . sISOPref , newMode ) . commit ( ) ; ApplicationScreen . getPluginManager ( ) . sendMessage ( ApplicationInterface . MSG _ BROADCAST , ApplicationInterface . MSG _ ISO _ CHANGED ) ; } RotateImageView but = ( RotateImageView ) topMenuButtons . get ( MODE _ ISO ) ; int icon _ id = ICONS _ ISO . get ( mISO ) ; but . setImageDrawable ( ApplicationScreen . getAppResources ( ) . getDrawable ( icon _ id ) ) ; if ( rebuildGUI ) { initSettingsMenu ( false ) ; hideSecondaryMenus ( ) ; unselectPrimaryTopMenuButtons ( - _NUM ) ; } } 
193	public void addOptions ( List < Field > fields , IParamLabelRenderer paramLabelRenderer ) { for ( Field field : fields ) { Option option = field . getAnnotation ( Option . class ) ; if ( ! option . hidden ( ) ) { addOption ( field , paramLabelRenderer ) ; } } } 
194	public boolean isFixedOrientation ( ) { return isFixedOrientationLandscape ( ) | | isFixedOrientationPortrait ( ) | | screenOrientation = = SCREEN _ ORIENTATION _ LOCKED ; } 
195	public synchronized void insertElementAt ( E object , int location ) { if ( _NUM < = location & & location < = elementCount ) { if ( elementCount = = elementData . length ) { growByOne ( ) ; } int count = elementCount - location ; if ( count > _NUM ) { System . arraycopy ( elementData , location , elementData , location + _NUM , count ) ; } elementData [ location ] = object ; elementCount + + ; modCount + + ; } else { throw new ArrayIndexOutOfBoundsException ( location ) ; } } 
196	public boolean hasExplicitField ( String fieldName ) { if ( fields . containsKey ( fieldName ) ) { return true ; } for ( DynamicField df : dynamicFields ) { if ( df . matches ( fieldName ) ) return true ; } if ( ! fieldName . endsWith ( _STR ) ; } return false ; } 
197	public static MatrixBlock randOperations ( RandomMatrixGenerator rgen , long seed , int k ) { MatrixBlock out = new MatrixBlock ( ) ; Well _NUM _NUM _NUM _NUM a bigrand = null ; setup seeds and nnz per block if ( ! LibMatrixDatagen . isShortcutRandOperation ( rgen . _ min , rgen . _ max , rgen . _ sparsity , rgen . _ pdf ) ) bigrand = LibMatrixDatagen . setupSeedsForRand ( seed ) ; generate rand data if ( k > _NUM ) out . randOperationsInPlace ( rgen , bigrand , - _NUM , k ) ; else out . randOperationsInPlace ( rgen , bigrand , - _NUM ) ; return out ; } 
198	private void restore ( HashMap < TableName , BackupManifest > backupManifestMap , TableName [ ] sTableArray , TableName [ ] tTableArray , boolean isOverwrite ) throws IOException { TreeSet < BackupImage > restoreImageSet = new TreeSet < > ( ) ; for ( int i = _NUM ; i < sTableArray . length ; i + + ) { TableName table = sTableArray [ i ] ; BackupManifest manifest = backupManifestMap . get ( table ) ; Get the image list of this backup for restore in time order from old to new . List < BackupImage > list = new ArrayList < > ( ) ; list . add ( manifest . getBackupImage ( ) ) ; TreeSet < BackupImage > set = new TreeSet < > ( list ) ; List < BackupImage > depList = manifest . getDependentListByTable ( table ) ; set . addAll ( depList ) ; BackupImage [ ] arr = new BackupImage [ set . size ( ) ] ; set . toArray ( arr ) ; restoreImages ( arr , table , tTableArray [ i ] , isOverwrite ) ; restoreImageSet . addAll ( list ) ; if ( restoreImageSet ! = null & & ! restoreImageSet . isEmpty ( ) ) { LOG . info ( _STR ) ; } 
199	public X _NUM _NUM _NUM CRL generate ( PrivateKey key , String provider , SecureRandom random ) throws CRLException , IllegalStateException , NoSuchProviderException , NoSuchAlgorithmException , SignatureException , InvalidKeyException { TBSCertList tbsCrl = generateCertList ( ) ; byte [ ] signature ; try { signature = X _NUM _NUM _NUM Util . calculateSignature ( sigOID , signatureAlgorithm , provider , key , random , tbsCrl ) ; } catch ( IOException e ) { throw new ExtCRLException ( _STR , e ) ; } return generateJcaObject ( tbsCrl , signature ) ; } 
200	public Long put ( Character key , Long value ) { char k ; long v ; if ( key = = null ) { k = _ map . getNoEntryKey ( ) ; } else { k = unwrapKey ( key ) ; } if ( value = = null ) { v = _ map . getNoEntryValue ( ) ; } else { v = unwrapValue ( value ) ; } long retval = _ map . put ( k , v ) ; if ( retval = = _ map . getNoEntryValue ( ) ) { return null ; } return wrapValue ( retval ) ; } 
201	private void handleFrameEnd ( ) { if ( ! mFrameFlag ) { We never saw the whole message , discard resetBuffer ( ) ; return ; } Gather the bytes into a single array mMessageBuffer . flip ( ) ; byte [ ] raw = new byte [ mMessageBuffer . limit ( ) ] ; mMessageBuffer . get ( raw ) ; mParser . processMessageFrame ( raw ) ; Reset the buffer state resetBuffer ( ) ; } 
202	public void fixType ( ) { mIsGsm = getCdmaRelatedSignalStrength ( ) = = SIGNAL _ STRENGTH _ NONE _ OR _ UNKNOWN ; } 
203	public void testInitializeTempExecutor ( ) { final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl ( ) ; assertTrue ( _STR , init . getActiveExecutor ( ) . isShutdown ( ) ) ; } 
204	public boolean hasNext ( ) { return it . hasNext ( ) ; } @ Override public R next ( ) { final Val v = it . next ( ) ; if ( v . pos = = Val . Pos . left ) { lastLeft = ( T _NUM ) v . val ; return zipper . apply ( lastLeft , lastRight ) ; } else lastRight = ( T _NUM ) v . val ; return ( R ) Optional . empty ( ) ; } } return ReactiveSeq . fromIterator ( new Zip ( ) ) . filter ( next - > ! ( next instanceof Optional ) ) ; } 
205	public JSONObject getShootMode ( ) throws IOException { String service = _STR + responseJson ) ; return new JSONObject ( responseJson ) ; } catch ( JSONException e ) { throw new IOException ( e ) ; } } 
206	public String getSSID ( ) { if ( mWifiSsid ! = null ) { String unicode = mWifiSsid . toString ( ) ; if ( ! TextUtils . isEmpty ( unicode ) ) { return _STR ; } else { String hex = mWifiSsid . getHexString ( ) ; return ( hex ! = null ) ? hex : WifiSsid . NONE ; } } return WifiSsid . NONE ; } 
207	public static < T extends Container < Summation > > double computePi ( final long b , Map < Parameter , T > results ) { if ( results . size ( ) ! = Parameter . values ( ) . length ) throw new IllegalArgumentException ( _STR + results ) ; double pi = _NUM ; for ( Parameter p : Parameter . values ( ) ) { final Summation sigma = results . get ( p ) . getElement ( ) ; final Sum s = new Sum ( b , p , _NUM , null ) ; s . setValue ( sigma ) ; pi = Modular . addMod ( pi , s . getValue ( ) ) ; } return pi ; } 
208	public void getMedian ( RpcController controller , AggregateRequest request , RpcCallback < AggregateResponse > done ) { AggregateResponse response = null ; InternalScanner scanner = null ; try { ColumnInterpreter < T , S , P , Q , R > ci = constructColumnInterpreterFromRequest ( request ) ; S sumVal = null , sumWeights = null , tempVal = null , tempWeight = null ; Scan scan = ProtobufUtil . toScan ( request . getScan ( ) ) ; scanner = env . getRegion ( ) . getScanner ( scan ) ; byte [ ] colFamily = scan . getFamilies ( ) [ _NUM ] ; NavigableSet < byte [ ] > qualifiers = scan . getFamilyMap ( ) . get ( colFamily ) ; byte [ ] valQualifier = null , weightQualifier = null ; if ( qualifiers ! = null & & ! qualifiers . isEmpty ( ) ) { valQualifier = qualifiers . pollFirst ( ) ; if weighted median is requested , get qualifier for the weight column weightQualifier = qualifiers . pollLast ( ) ; } List < Cell > results = new ArrayList < > ( ) ; boolean hasMoreRows = false ; do { tempVal = null ; tempWeight = null ; hasMoreRows = scanner . next ( results ) ; int listSize = results . size ( ) ; for ( int i = _NUM ; i < listSize ; i + + ) { Cell kv = results . get ( i ) ; tempVal = ci . add ( tempVal , ci . castToReturnType ( ci . getValue ( colFamily , valQualifier , kv ) ) ) ; if ( weightQualifier ! = null ) { tempWeight = ci . add ( tempWeight , ci . castToReturnType ( ci . getValue ( colFamily , weightQualifier , kv ) ) ) ; } } results . clear ( ) ; sumVal = ci . add ( sumVal , tempVal ) ; sumWeights = ci . add ( sumWeights , tempWeight ) ; } while ( hasMoreRows ) ; ByteString first _ sumVal = ci . getProtoForPromotedType ( sumVal ) . toByteString ( ) ; S s = sumWeights = = null ? ci . castToReturnType ( ci . getMinValue ( ) ) : sumWeights ; ByteString first _ sumWeights = ci . getProtoForPromotedType ( s ) . toByteString ( ) ; AggregateResponse . Builder pair = AggregateResponse . newBuilder ( ) ; pair . addFirstPart ( first _ sumVal ) ; pair . addFirstPart ( first _ sumWeights ) ; response = pair . build ( ) ; } catch ( IOException e ) { CoprocessorRpcUtils . setControllerException ( controller , e ) ; } finally { if ( scanner ! = null ) { try { scanner . close ( ) ; } catch ( IOException ignored ) { } } } done . run ( response ) ; } 
209	private void putInSelected ( int index ) { state = SELECTED ; selectedChar = _NUM ; Point point = getPointForIndex ( index ) ; for column one if ( index % _NUM _NUM = = _NUM ) { scrollRectToVisible ( new Rectangle ( _NUM , HexModel . lineNumber ( index ) * HexView . CHAR _ HEIGHT , _NUM , _NUM ) ) ; } else if ( ! getVisibleRect ( ) . intersects ( point . x , point . y , HexView . CHAR _ WIDTH , HexView . CHAR _ HEIGHT ) ) { scrollRectToVisible ( new Rectangle ( point . x , point . y , HexView . CHAR _ WIDTH , HexView . CHAR _ HEIGHT ) ) ; } selectedIndex = index ; repaint ( ) ; requestFocusInWindow ( ) ; } 
210	default < C extends PersistentCollection < ? super T > > Traversable < C > grouped ( final int size , final Supplier < C > supplier ) { return traversable ( ) . grouped ( size , supplier ) ; } 
211	public Object parse ( URL url , Map params , String charset ) { return parseURL ( url , params , charset ) ; } 
212	public void addAll ( QuerySolution other ) { Iterator < String > iter = other . varNames ( ) ; for ( ; iter . hasNext ( ) ; ) { String vName = iter . next ( ) ; RDFNode rdfNode = other . get ( vName ) ; map . put ( vName , rdfNode ) ; } } 
213	public UpdateBuilder addDelete ( Object g , Triple t ) { Quad q = new Quad ( AbstractQueryBuilder . makeNode ( g , prefixHandler . getPrefixes ( ) ) , t ) ; deletes . add ( new SingleQuadHolder ( q ) ) ; return this ; } 
214	protected int descend ( final CoverTreeNode query , MyHeap upper _ k , amk _NUM _NUM comment : make sure this getsint current _ scale , amk _NUM _NUM comment : make sure this getsint max _ scale , amk _NUM _NUM comment : contains children inStack < Stack < d _ node > > cover _ sets , amk _NUM _NUM comment : zeroset contains the children atStack < d _ node > zero _ set ) throws the lowest level i . e . - infinityException { d _ node parent ; Stack < d _ node > cover _ set _ currentscale = getCoverSet ( current _ scale , cover _ sets ) ; for ( int i = _NUM ; i < cover _ set _ currentscale . length ; i + + ) { parent = cover _ set _ currentscale . element ( i ) ; CoverTreeNode par = parent . n ; double upper _ dist = upper _ k . peek ( ) . distance + query . max _ dist + * upper _ bound + query - > max _ dist + query - > max _ dist ; query . max _ dist ; if ( parent . dist < = upper _ dist + par . max _ dist ) { CoverTreeNode chi ; if ( if our tree consists of par = = m _ Root & & par . num _ children = = _NUM ) only one root ( which is also leaf ) node chi = par ; else chi = par . children . element ( _NUM ) ; if ( parent . dist < = upper _ dist + chi . max _ dist ) { the parent itself ) if ( chi . num _ children > _NUM ) { if ( max _ scale < chi . scale ) { max _ scale = chi . scale ; } d _ node temp = new d _ node ( parent . dist , chi ) ; getCoverSet ( chi . scale , cover _ sets ) . push ( temp ) ; if ( m _ TreeStats ! = null ) m _ TreeStats . incrIntNodeCount ( ) ; } else if ( parent . dist < = upper _ dist ) { d _ node temp = new d _ node ( parent . dist , chi ) ; zero _ set . push ( temp ) ; if ( m _ TreeStats ! = null ) m _ TreeStats . incrLeafCount ( ) ; } } for ( int c = _NUM ; c < par . num _ children ; c + + ) { chi = par . children . element ( c ) ; double upper _ chi = upper _ k . peek ( ) . distance + chi . max _ dist + query . max _ dist + * upper _ bound + chi . max _ dist query . max _ dist ; query . max _ dist ; if ( shell ( parent . dist , chi . parent _ dist , upper _ chi ) ) { amk _NUM _NUM comment : parent _ query _ dist - child _ parent _ dist < = upper _ chi - if child can be inside the shrunk query ball NOT the same as above parent - > dist < = upper _ dist + chi - > max _ dist double d = Math . sqrt ( m _ DistanceFunction . distance ( query . p ( ) , chi . p ( ) , upper _ chi * upper _ chi , m _ TreeStats ) ) ; if ( m _ TreeStats ! = null ) m _ TreeStats . incrPointCount ( ) ; if ( d < = upper _ chi ) { if child is inside the shrunk query ball if ( * upper _ bound ) d < upper _ k . peek ( ) . distance ) update ( upper _ k , d ) ; if ( chi . num _ children > _NUM ) { if ( max _ scale < chi . scale ) { max _ scale = chi . scale ; } d _ node temp = new d _ node ( d , chi ) ; getCoverSet ( chi . scale , cover _ sets ) . push ( temp ) ; if ( m _ TreeStats ! = null ) m _ TreeStats . incrIntNodeCount ( ) ; } else if ( d < = upper _ chi - chi . max _ dist ) { d _ node temp = new d _ node ( d , chi ) ; zero _ set . push ( temp ) ; if ( m _ TreeStats ! = null ) m _ TreeStats . incrLeafCount ( ) ; } } end if ( d < = upper _ chi ) } end if ( shell ( parent . dist , . . . } end for ( child _ _NUM to n ) } end if ( parent . dist < = upper _ dist . . } end for ( covers _ sets [ current _ scale ] [ i ] ) return max _ scale ; } 
215	public void mark ( long n ) { tickIfNecessary ( ) ; count . add ( n ) ; m _NUM Rate . update ( n ) ; } 
216	public String getDialogInitMethod ( CmsObject cms , I _ CmsWidgetDialog widgetDialog ) { return getEditorWidget ( cms , widgetDialog ) . getDialogInitMethod ( cms , widgetDialog ) ; } 
217	private static String getTableHtml ( String csvData , String delimiter ) throws IOException { String lineSeparator = System . getProperty ( _STR ) . toString ( ) ; } 
218	private IntegerPolynomial MGF ( byte [ ] seed , int N , int minCallsR , boolean hashSeed ) { Digest hashAlg = params . hashAlg ; int hashLen = hashAlg . getDigestSize ( ) ; byte [ ] buf = new byte [ minCallsR * hashLen ] ; byte [ ] Z = hashSeed ? calcHash ( hashAlg , seed ) : seed ; int counter = _NUM ; while ( counter < minCallsR ) { hashAlg . update ( Z , _NUM , Z . length ) ; putInt ( hashAlg , counter ) ; byte [ ] hash = calcHash ( hashAlg ) ; System . arraycopy ( hash , _NUM , buf , counter * hashLen , hashLen ) ; counter + + ; } IntegerPolynomial i = new IntegerPolynomial ( N ) ; while ( true ) { int cur = _NUM ; for ( int index = _NUM ; index ! = buf . length ; index + + ) { int O = ( int ) buf [ index ] & _NUM xFF ; if ( _NUM _NUM _NUM = _NUM ^ _NUM O > = _NUM _NUM _NUM ) { continue ; } for ( int terIdx = _NUM ; terIdx < _NUM ; terIdx + + ) { int rem _NUM = O % _NUM ; i . coeffs [ cur ] = rem _NUM - _NUM ; cur + + ; if ( cur = = N ) { return i ; } O = ( O - rem _NUM ) / _NUM ; } i . coeffs [ cur ] = O - _NUM ; cur + + ; if ( cur = = N ) { return i ; } } if ( cur > = N ) { return i ; } hashAlg . update ( Z , _NUM , Z . length ) ; putInt ( hashAlg , counter ) ; byte [ ] hash = calcHash ( hashAlg ) ; buf = hash ; counter + + ; } } 
219	private void waitForRequestsToFinish ( ) { if ( LOG . isInfoEnabled ( ) ) { LOG . info ( _STR + MemoryUtils . getRuntimeMemoryStats ( ) ) ; } GiraphTimerContext timerContext = waitRequestsTimer . time ( ) ; workerClient . waitAllRequests ( ) ; timerContext . stop ( ) ; } 
220	private void checkUpdating ( ) throws QueryException { derive updating flag from function body updating = expr . has ( Flag . UPD ) ; final boolean updAnn = anns . contains ( Annotation . UPDATING ) ; if ( updating ! = updAnn ) { if ( ! updAnn ) anns . add ( new Ann ( info , Annotation . UPDATING ) ) ; else if ( ! expr . isVacuous ( ) ) throw UPEXPECTF . get ( info ) ; } } 
221	public TransferObserver getTransferById ( int id ) { Cursor c = null ; try { c = dbUtil . queryTransferById ( id ) ; if ( c . moveToNext ( ) ) { final TransferObserver to = new TransferObserver ( id , dbUtil ) ; to . updateFromDB ( c ) ; return to ; } } finally { if ( c ! = null ) { c . close ( ) ; } } return null ; } 
222	public void update ( RegularTimePeriod period , Number value ) { TimeSeriesDataItem temp = new TimeSeriesDataItem ( period , value ) ; int index = Collections . binarySearch ( this . data , temp ) ; if ( index > = _NUM ) { TimeSeriesDataItem pair = ( TimeSeriesDataItem ) this . data . get ( index ) ; pair . setValue ( value ) ; fireSeriesChanged ( ) ; } else { throw new SeriesException ( _STR ) ; } } 
223	protected UnsupportedOperationException noMethod ( Method method ) { StringBuilder buf = new StringBuilder ( ) ; final Class [ ] parameterTypes = method . getParameterTypes ( ) ; for ( int i = _NUM ; i < parameterTypes . length ; i + + ) { if ( i > _NUM ) { buf . append ( _STR ; return new UnsupportedOperationException ( signature ) ; } 
224	public void setLineCompound ( LineCompound style ) { AbstractEscherOptRecord opt = getEscherOptRecord ( ) ; setEscherProperty ( opt , EscherProperties . LINESTYLE _ _ LINESTYLE , style = = LineCompound . SINGLE ? - _NUM : style . nativeId ) ; } 
225	public void offsetChildrenTopAndBottom ( int offset ) { final int count = mChildrenCount ; final View [ ] children = mChildren ; boolean invalidate = false ; for ( int i = _NUM ; i < count ; i + + ) { final View v = children [ i ] ; v . mTop + = offset ; v . mBottom + = offset ; if ( v . mRenderNode ! = null ) { invalidate = true ; v . mRenderNode . offsetTopAndBottom ( offset ) ; } } if ( invalidate ) { invalidateViewProperty ( false , false ) ; } notifySubtreeAccessibilityStateChangedIfNeeded ( ) ; } 
226	protected static HttpPrincipal extractBasicAuthSubject ( HttpRequest request ) { String auth = request . headers ( ) . get ( _STR , principal ) ; return principal ; } finally { buf . release ( ) ; out . release ( ) ; } } } } return null ; } 
227	public static File rewriteAfterRename ( File beforeDir , File afterDir , File file ) { if ( file = = null | | beforeDir = = null | | afterDir = = null ) return null ; if ( contains ( beforeDir , file ) ) { final String splice = file . getAbsolutePath ( ) . substring ( beforeDir . getAbsolutePath ( ) . length ( ) ) ; return new File ( afterDir , splice ) ; } return null ; } 
228	public void doUpdates ( MetricsContext context ) { doMemoryUpdates ( ) ; doGarbageCollectionUpdates ( ) ; doThreadUpdates ( ) ; doEventCountUpdates ( ) ; metrics . update ( ) ; } 
229	private void writeObject ( ObjectOutputStream out ) throws IOException { out . defaultWriteObject ( ) ; doWriteObject ( out ) ; } 
230	public int getButtonCount ( ) { return buttons . size ( ) ; } 
231	public void testCheckpointWhenNoNewTransactionsHappened ( ) throws Exception { Checkpoint as fast as we can , in a tight loop . cluster . getConfiguration ( _NUM ) . setInt ( DFSConfigKeys . DFS _ NAMENODE _ CHECKPOINT _ PERIOD _ KEY , _NUM ) ; cluster . restartNameNode ( _NUM ) ; nn _NUM = cluster . getNameNode ( _NUM ) ; FSImage spyImage _NUM = NameNodeAdapter . spyOnFsImage ( nn _NUM ) ; We shouldn ' t save any checkpoints at txid = _NUM Thread . sleep ( _NUM _NUM _NUM _NUM ) ; Mockito . verify ( spyImage _NUM , Mockito . never ( ) ) . saveNamespace ( ( FSNamesystem ) Mockito . anyObject ( ) ) ; Roll the primary and wait for the standby to catch up HATestUtil . waitForStandbyToCatchUp ( nn _NUM , nn _NUM ) ; Thread . sleep ( _NUM _NUM _NUM _NUM ) ; We should make exactly one checkpoint at this new txid . Mockito . verify ( spyImage _NUM , Mockito . times ( _NUM ) ) . saveNamespace ( ( FSNamesystem ) Mockito . anyObject ( ) , Mockito . eq ( NameNodeFile . IMAGE ) , ( Canceler ) Mockito . anyObject ( ) ) ; } 
232	 @ Test @ FixFor ( _STR ) . build ( ) ; MySqlConnector connector = new MySqlConnector ( ) ; Config result = connector . validate ( config . asMap ( ) ) ; assertConfigurationErrors ( result , MySqlConnectorConfig . SNAPSHOT _ LOCKING _ MODE ) ; } 
233	public static String uppercaseFirstChar ( String in ) { if ( in = = null | | in . length ( ) = = _NUM ) { return in ; } int length = in . length ( ) ; StringBuilder sb = new StringBuilder ( length ) ; sb . append ( Character . toUpperCase ( in . charAt ( _NUM ) ) ) ; if ( length > _NUM ) { String remaining = in . substring ( _NUM ) ; sb . append ( remaining ) ; } return sb . toString ( ) ; } 
234	protected SAML _NUM StringNameIDEncoder prepareNameIdEncoder ( final RequestAbstractType authnRequest , final String nameFormat , final IdPAttribute attribute , final SamlRegisteredService service , final SamlRegisteredServiceServiceProviderMetadataFacade adaptor ) { final SAML _NUM StringNameIDEncoder encoder = new SAML _NUM StringNameIDEncoder ( ) ; encoder . setNameFormat ( nameFormat ) ; if ( getNameIDPolicy ( authnRequest ) ! = null ) { final String qualifier = getNameIDPolicy ( authnRequest ) . getSPNameQualifier ( ) ; LOGGER . debug ( _STR , qualifier ) ; encoder . setNameQualifier ( qualifier ) ; } return encoder ; } 
235	protected AxisState drawTickMarksAndLabels ( Graphics _NUM D g _NUM , double cursor , Rectangle _NUM D plotArea , Rectangle _NUM D dataArea , RectangleEdge edge ) { AxisState state = new AxisState ( cursor ) ; if ( isAxisLineVisible ( ) ) { drawAxisLine ( g _NUM , cursor , dataArea , edge ) ; } List ticks = refreshTicks ( g _NUM , state , dataArea , edge ) ; state . setTicks ( ticks ) ; g _NUM . setFont ( getTickLabelFont ( ) ) ; Iterator iterator = ticks . iterator ( ) ; while ( iterator . hasNext ( ) ) { ValueTick tick = ( ValueTick ) iterator . next ( ) ; if ( isTickLabelsVisible ( ) ) { g _NUM . setPaint ( getTickLabelPaint ( ) ) ; float [ ] anchorPoint = calculateAnchorPoint ( tick , cursor , dataArea , edge ) ; TextUtilities . drawRotatedString ( tick . getText ( ) , g _NUM , anchorPoint [ _NUM ] , anchorPoint [ _NUM ] , tick . getTextAnchor ( ) , tick . getAngle ( ) , tick . getRotationAnchor ( ) ) ; } if ( ( isTickMarksVisible ( ) & & tick . getTickType ( ) . equals ( TickType . MAJOR ) ) | | ( isMinorTickMarksVisible ( ) & & tick . getTickType ( ) . equals ( TickType . MINOR ) ) ) { double ol = ( tick . getTickType ( ) . equals ( TickType . MINOR ) ) ? getMinorTickMarkOutsideLength ( ) : getTickMarkOutsideLength ( ) ; double il = ( tick . getTickType ( ) . equals ( TickType . MINOR ) ) ? getMinorTickMarkInsideLength ( ) : getTickMarkInsideLength ( ) ; float xx = ( float ) valueToJava _NUM D ( tick . getValue ( ) , dataArea , edge ) ; Line _NUM D mark = null ; g _NUM . setStroke ( getTickMarkStroke ( ) ) ; g _NUM . setPaint ( getTickMarkPaint ( ) ) ; if ( edge = = RectangleEdge . LEFT ) { mark = new Line _NUM D . Double ( cursor - ol , xx , cursor + il , xx ) ; } else if ( edge = = RectangleEdge . RIGHT ) { mark = new Line _NUM D . Double ( cursor + ol , xx , cursor - il , xx ) ; } else if ( edge = = RectangleEdge . TOP ) { mark = new Line _NUM D . Double ( xx , cursor - ol , xx , cursor + il ) ; } else if ( edge = = RectangleEdge . BOTTOM ) { mark = new Line _NUM D . Double ( xx , cursor + ol , xx , cursor - il ) ; } g _NUM . draw ( mark ) ; } } need to work out the space used by the tick labels . . . so we can update the cursor . . . double used = _NUM . _NUM ; if ( isTickLabelsVisible ( ) ) { if ( edge = = RectangleEdge . LEFT ) { used + = findMaximumTickLabelWidth ( ticks , g _NUM , plotArea , isVerticalTickLabels ( ) ) ; state . cursorLeft ( used ) ; } else if ( edge = = RectangleEdge . RIGHT ) { used = findMaximumTickLabelWidth ( ticks , g _NUM , plotArea , isVerticalTickLabels ( ) ) ; state . cursorRight ( used ) ; } else if ( edge = = RectangleEdge . TOP ) { used = findMaximumTickLabelHeight ( ticks , g _NUM , plotArea , isVerticalTickLabels ( ) ) ; state . cursorUp ( used ) ; } else if ( edge = = RectangleEdge . BOTTOM ) { used = findMaximumTickLabelHeight ( ticks , g _NUM , plotArea , isVerticalTickLabels ( ) ) ; state . cursorDown ( used ) ; } } return state ; } 
236	public void close ( ) throws IOException { ensureOpen ( ) ; mClosed = true ; } 
237	public void mepComplete ( Message message ) { if ( LOG . isLoggable ( Level . FINE ) ) { LOG . log ( Level . FINE , _STR + invokedHandlers . size ( ) ) ; } if ( isClosed ( ) ) { return ; } invokeReversedClose ( ) ; } 
238	public void consume ( ) { disabled = true ; while ( currentRow ! = null ) _ next ( ) ; } 
239	protected void installPackage ( String packageArchivePath , String packageName , PrintStream . . . progress ) throws Exception { if ( ! establishPackageHome ( ) ) { throw new Exception ( _STR + zipEntry . getName ( ) ) ; } input = new BufferedInputStream ( zipFile . getInputStream ( zipEntry ) ) ; File destFile = new File ( destDir , zipEntry . getName ( ) ) ; FileOutputStream fos = new FileOutputStream ( destFile ) ; output = new BufferedOutputStream ( fos ) ; copyStreams ( input , output ) ; input . close ( ) ; output . flush ( ) ; output . close ( ) ; } } 
240	 @ ServiceThreadOnlyboolean setArcStatus ( boolean enabled ) { assertRunOnServiceThread ( ) ; HdmiLogger . debug ( _STR , mArcEstablished , enabled ) ; boolean oldStatus = mArcEstablished ; _NUM . Enable / disable ARC circuit . enableAudioReturnChannel ( enabled ) ; _NUM . Notify arc status to audio service . notifyArcStatusToAudioService ( enabled ) ; _NUM . Update arc status ; mArcEstablished = enabled ; return oldStatus ; } 
241	public XSLFPictureData getPictureData ( ) { if ( _ data = = null ) { String blipId = getBlipId ( ) ; if ( blipId = = null ) return null ; PackagePart p = getSheet ( ) . getPackagePart ( ) ; PackageRelationship rel = p . getRelationship ( blipId ) ; if ( rel ! = null ) { try { PackagePart imgPart = p . getRelatedPart ( rel ) ; _ data = new XSLFPictureData ( imgPart ) ; } catch ( Exception e ) { throw new POIXMLException ( e ) ; } } } return _ data ; } 
242	public static String removeExtension ( final String fileName ) { if ( fileName = = null ) { return null ; } failIfNullBytePresent ( fileName ) ; final int index = indexOfExtension ( fileName ) ; if ( index = = NOT _ FOUND ) { return fileName ; } return fileName . substring ( _NUM , index ) ; } 
243	public Map < K , V > snapshot ( boolean ascending , int limit , Function < V , V > transformer ) { requireArgument ( limit > = _NUM ) ; Map < K , V > map = new LinkedHashMap < > ( Math . min ( limit , cache . size ( ) ) ) ; int startLevel = ascending ? _NUM : wheel . length - _NUM ; for ( int i = _NUM ; i < wheel . length ; i + + ) { int indexOffset = ascending ? i : - i ; int index = startLevel + indexOffset ; int ticks = ( int ) ( nanos > > SHIFT [ index ] ) ; int bucketMask = ( wheel [ index ] . length - _NUM ) ; int startBucket = ( ticks & bucketMask ) + ( ascending ? _NUM : _NUM ) ; for ( int j = _NUM ; j < wheel [ index ] . length ; j + + ) { int bucketOffset = ascending ? j : - j ; Node < K , V > sentinel = wheel [ index ] [ ( startBucket + bucketOffset ) & bucketMask ] ; for ( Node < K , V > node = traverse ( ascending , sentinel ) ; node ! = sentinel ; node = traverse ( ascending , node ) ) { if ( map . size ( ) > = limit ) { break ; } K key = node . getKey ( ) ; V value = transformer . apply ( node . getValue ( ) ) ; if ( ( key ! = null ) & & ( value ! = null ) & & node . isAlive ( ) ) { map . put ( key , value ) ; } } } } return Collections . unmodifiableMap ( map ) ; } 
244	public Animator . AnimatorListener decrementOnAnimationEnd ( ) { return new AnimatorListenerAdapter ( ) { @ Override public void onAnimationEnd ( Animator animation ) { decrement ( ) ; } } ; } 
245	public boolean isSet ( _ Fields field ) { if ( field = = null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case SUCCESS : return isSetSuccess ( ) ; case IO : return isSetIo ( ) ; } throw new IllegalStateException ( ) ; } 
246	protected void updateStatsForClassifier ( double [ ] predictedDistribution , Instance instance ) throws Exception { int actualClass = ( int ) instance . classValue ( ) ; if ( ! instance . classIsMissing ( ) ) { updateMargins ( predictedDistribution , actualClass , instance . weight ( ) ) ; Determine the predicted class ( doesn ' t detect multiple classifications ) int predictedClass = - _NUM ; double bestProb = _NUM . _NUM ; for ( int i = _NUM ; i < m _ NumClasses ; i + + ) { if ( predictedDistribution [ i ] > bestProb ) { predictedClass = i ; bestProb = predictedDistribution [ i ] ; } } m _ WithClass + = instance . weight ( ) ; Determine misclassification cost if ( m _ CostMatrix ! = null ) { if ( predictedClass < _NUM ) { For missing predictions , we assume the worst possible cost . This is pretty harsh . Perhaps we could take the negative of the cost of a correct prediction ( - m _ CostMatrix . getElement ( actualClass , actualClass ) ) , although often this will be zero m _ TotalCost + = instance . weight ( ) * m _ CostMatrix . getMaxCost ( actualClass , instance ) ; } else { m _ TotalCost + = instance . weight ( ) * m _ CostMatrix . getElement ( actualClass , predictedClass , instance ) ; } } Update counts when no class was predicted if ( predictedClass < _NUM ) { m _ Unclassified + = instance . weight ( ) ; return ; } double predictedProb = Math . max ( MIN _ SF _ PROB , predictedDistribution [ actualClass ] ) ; double priorProb = Math . max ( MIN _ SF _ PROB , m _ ClassPriors [ actualClass ] / m _ ClassPriorsSum ) ; if ( predictedProb > = priorProb ) { m _ SumKBInfo + = ( Utils . log _NUM ( predictedProb ) - Utils . log _NUM ( priorProb ) ) * instance . weight ( ) ; } else { m _ SumKBInfo - = ( Utils . log _NUM ( _NUM . _NUM - predictedProb ) - Utils . log _NUM ( _NUM . _NUM - priorProb ) ) * instance . weight ( ) ; } m _ SumSchemeEntropy - = Utils . log _NUM ( predictedProb ) * instance . weight ( ) ; m _ SumPriorEntropy - = Utils . log _NUM ( priorProb ) * instance . weight ( ) ; updateNumericScores ( predictedDistribution , makeDistribution ( instance . classValue ( ) ) , instance . weight ( ) ) ; Update coverage stats int [ ] indices = Utils . sort ( predictedDistribution ) ; double sum = _NUM , sizeOfRegions = _NUM ; for ( int i = predictedDistribution . length - _NUM ; i > = _NUM ; i - - ) { if ( sum > = m _ ConfLevel ) { break ; } sum + = predictedDistribution [ indices [ i ] ] ; sizeOfRegions + + ; if ( actualClass = = indices [ i ] ) { m _ TotalCoverage + = instance . weight ( ) ; } } m _ TotalSizeOfRegions + = sizeOfRegions / ( m _ MaxTarget - m _ MinTarget ) ; Update other stats m _ ConfusionMatrix [ actualClass ] [ predictedClass ] + = instance . weight ( ) ; if ( predictedClass ! = actualClass ) { m _ Incorrect + = instance . weight ( ) ; } else { m _ Correct + = instance . weight ( ) ; } } else { m _ MissingClass + = instance . weight ( ) ; } } 
247	public static String getLocalNodeName ( ) { switch ( CommonUtils . PROCESS _ TYPE . get ( ) ) { case CLIENT : if ( Configuration . containsKey ( PropertyKey . USER _ HOSTNAME ) ) { return Configuration . get ( PropertyKey . USER _ HOSTNAME ) ; } break ; case MASTER : if ( Configuration . containsKey ( PropertyKey . MASTER _ HOSTNAME ) ) { return Configuration . get ( PropertyKey . MASTER _ HOSTNAME ) ; } break ; case WORKER : if ( Configuration . containsKey ( PropertyKey . WORKER _ HOSTNAME ) ) { return Configuration . get ( PropertyKey . WORKER _ HOSTNAME ) ; } break ; default : break ; } return getLocalHostName ( ) ; } 
248	public static XmlDecimal parse ( java . io . File f , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( XmlDecimal ) XmlBeans . getContextTypeLoader ( ) . parse ( f , type , options ) ; } 
249	public NewTableConfiguration attachIterator ( IteratorSetting setting , EnumSet < IteratorScope > scopes ) { Objects . requireNonNull ( setting , _STR ) ; } return this ; } 
250	protected void doStart ( ) throws Exception { if ( writeConcern ! = null & & writeConcernRef ! = null ) { String msg = _STR , connectionBean , mongoConnection ) ; setWriteReadOptionsOnConnection ( ) ; super . doStart ( ) ; } 
251	public void cacheLocation ( final TableName tableName , final RegionLocations locations ) { byte [ ] startKey = locations . getRegionLocation ( ) . getRegion ( ) . getStartKey ( ) ; ConcurrentMap < byte [ ] , RegionLocations > tableLocations = getTableLocations ( tableName ) ; RegionLocations oldLocation = tableLocations . putIfAbsent ( startKey , locations ) ; boolean isNewCacheEntry = ( oldLocation = = null ) ; if ( isNewCacheEntry ) { if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( _STR + mergedLocation ) ; } addToCachedServers ( locations ) ; } 
252	protected void setOutput ( String lang ) { m _ outputFormat = getCheckedLanguage ( lang ) ; } 
253	private void updatePortsLocked ( IndentingPrintWriter pw , ArrayList < RawPortInfo > newPortInfo ) { for ( int i = mPorts . size ( ) ; i - - > _NUM ; ) { mPorts . valueAt ( i ) . mDisposition = PortInfo . DISPOSITION _ REMOVED ; } Enumerate all extant ports . if ( ! mSimulatedPorts . isEmpty ( ) ) { final int count = mSimulatedPorts . size ( ) ; for ( int i = _NUM ; i < count ; i + + ) { final RawPortInfo portInfo = mSimulatedPorts . valueAt ( i ) ; addOrUpdatePortLocked ( portInfo . portId , portInfo . supportedModes , portInfo . currentMode , portInfo . canChangeMode , portInfo . currentPowerRole , portInfo . canChangePowerRole , portInfo . currentDataRole , portInfo . canChangeDataRole , pw ) ; } } else { for ( RawPortInfo currentPortInfo : newPortInfo ) { addOrUpdatePortLocked ( currentPortInfo . portId , currentPortInfo . supportedModes , currentPortInfo . currentMode , currentPortInfo . canChangeMode , currentPortInfo . currentPowerRole , currentPortInfo . canChangePowerRole , currentPortInfo . currentDataRole , currentPortInfo . canChangeDataRole , pw ) ; } } Once finished , the list of ports will only contain ports in DISPOSITION _ READY . for ( int i = mPorts . size ( ) ; i - - > _NUM ; ) { final PortInfo portInfo = mPorts . valueAt ( i ) ; switch ( portInfo . mDisposition ) { case PortInfo . DISPOSITION _ ADDED : handlePortAddedLocked ( portInfo , pw ) ; portInfo . mDisposition = PortInfo . DISPOSITION _ READY ; break ; case PortInfo . DISPOSITION _ CHANGED : handlePortChangedLocked ( portInfo , pw ) ; portInfo . mDisposition = PortInfo . DISPOSITION _ READY ; break ; case PortInfo . DISPOSITION _ REMOVED : mPorts . removeAt ( i ) ; must do this early portInfo . mUsbPortStatus = null ; handlePortRemovedLocked ( portInfo , pw ) ; break ; } } } 
254	private Class loadTagFile ( Compiler compiler , String tagFilePath , TagInfo tagInfo , PageInfo parentPageInfo ) throws JasperException { URL tagFileJarUrl = null ; if ( tagFilePath . startsWith ( _STR ; } else { tagFileJarPath = tagFileJarUrl . toString ( ) ; } JspCompilationContext ctxt = compiler . getCompilationContext ( ) ; JspRuntimeContext rctxt = ctxt . getRuntimeContext ( ) ; JspServletWrapper wrapper = rctxt . getWrapper ( tagFileJarPath + tagFilePath ) ; synchronized ( rctxt ) { if ( wrapper = = null ) { wrapper = new JspServletWrapper ( ctxt . getServletContext ( ) , ctxt . getOptions ( ) , tagFilePath , tagInfo , ctxt . getRuntimeContext ( ) , tagFileJarUrl ) ; rctxt . addWrapper ( tagFileJarPath + tagFilePath , wrapper ) ; Use same classloader and classpath for compiling tag files wrapper . getJspEngineContext ( ) . setClassLoader ( ( URLClassLoader ) ctxt . getClassLoader ( ) ) ; wrapper . getJspEngineContext ( ) . setClassPath ( ctxt . getClassPath ( ) ) ; } else { Make sure that JspCompilationContext gets the latest TagInfo for the tag file . TagInfo instance was created the last time the tag file was scanned for directives , and the tag file may have been modified since then . wrapper . getJspEngineContext ( ) . setTagInfo ( tagInfo ) ; } Class tagClazz ; int tripCount = wrapper . incTripCount ( ) ; try { if ( tripCount > _NUM ) { When tripCount is greater than zero , a circular dependency exists . The circularily dependant tag file is compiled in prototype mode , to avoid infinite recursion . JspServletWrapper tempWrapper = new JspServletWrapper ( ctxt . getServletContext ( ) , ctxt . getOptions ( ) , tagFilePath , tagInfo , ctxt . getRuntimeContext ( ) , ctxt . getTagFileJarUrl ( tagFilePath ) ) ; tagClazz = tempWrapper . loadTagFilePrototype ( ) ; tempVector . add ( tempWrapper . getJspEngineContext ( ) . getCompiler ( ) ) ; } else { tagClazz = wrapper . loadTagFile ( ) ; } } finally { wrapper . decTripCount ( ) ; } can only be obtained from the tag instance . try { Object tagIns = tagClazz . newInstance ( ) ; if ( tagIns instanceof JspSourceDependent ) { Iterator iter = ( ( List ) ( ( JspSourceDependent ) tagIns ) . getDependants ( ) ) . iterator ( ) ; while ( iter . hasNext ( ) ) { parentPageInfo . addDependant ( ( String ) iter . next ( ) ) ; } } } catch ( Exception e ) { ignore errors } return tagClazz ; } } 
255	public final T createObject ( Configuration conf ) { final String codeSnippet = createFullCodeSnippet ( codeSnippetConfOption . get ( conf ) ) ; if ( codeSnippet = = null | | codeSnippet . isEmpty ( ) ) { return null ; } else { return RuntimeObjectFactoryGenerator . < T > createFactory ( codeSnippet , interfaceType ) . create ( ) ; } } 
256	public static void scheduleUpdateOnBoot ( Context context , File packageFile ) throws IOException { String filename = packageFile . getCanonicalPath ( ) ; boolean securityUpdate = filename . endsWith ( _STR ) ; } } 
257	public String getStringCellValue ( ) { CellType cellType = getCellType ( ) ; switch ( cellType ) { case BLANK : return _STR ; case FORMULA : { FormulaValue fv = ( FormulaValue ) _ value ; if ( fv . getFormulaType ( ) ! = CellType . STRING ) throw typeMismatch ( CellType . STRING , CellType . FORMULA , false ) ; return ( ( StringFormulaValue ) _ value ) . getPreEvaluatedValue ( ) ; } case STRING : { if ( ( ( StringValue ) _ value ) . isRichText ( ) ) return ( ( RichTextValue ) _ value ) . getValue ( ) . getString ( ) ; else return ( ( PlainStringValue ) _ value ) . getValue ( ) ; } default : throw typeMismatch ( CellType . STRING , cellType , false ) ; } } 
258	public IComplexNDArray eps ( INDArray other ) { return dup ( ) . epsi ( other ) ; } 
259	public boolean input ( Instance instance ) throws Exception { if ( getInputFormat ( ) = = null ) { throw new IllegalStateException ( _STR ) ; } if ( m _ NewBatch ) { resetQueue ( ) ; m _ NewBatch = false ; } if ( m _ attStats = = null ) { bufferInput ( instance ) ; return false ; } else { convertInstance ( instance ) ; return true ; } } 
260	public PGPSecretKeyRing getSecretKeyRing ( long keyID ) throws PGPException { Long id = new Long ( keyID ) ; if ( secretRings . containsKey ( id ) ) { return ( PGPSecretKeyRing ) secretRings . get ( id ) ; } Iterator it = this . getKeyRings ( ) ; while ( it . hasNext ( ) ) { PGPSecretKeyRing secretRing = ( PGPSecretKeyRing ) it . next ( ) ; PGPSecretKey secret = secretRing . getSecretKey ( keyID ) ; if ( secret ! = null ) { return secretRing ; } } return null ; } 
261	public void putAll ( Map < ? extends Double , ? extends Short > map ) { Iterator < ? extends Entry < ? extends Double , ? extends Short > > it = map . entrySet ( ) . iterator ( ) ; for ( int i = map . size ( ) ; i - - > _NUM ; ) { Entry < ? extends Double , ? extends Short > e = it . next ( ) ; this . put ( e . getKey ( ) , e . getValue ( ) ) ; } } 
262	public static void validate _ ids ( StormTopology topology ) throws InvalidTopologyException { List < String > list = new ArrayList < String > ( ) ; for ( StormTopology . _ Fields field : Thrift . STORM _ TOPOLOGY _ FIELDS ) { Object value = topology . getFieldValue ( field ) ; if ( value ! = null ) { Map < String , Object > obj _ map = ( Map < String , Object > ) value ; Set < String > commids = obj _ map . keySet ( ) ; list . addAll ( commids ) ; for ( String id : commids ) { if ( system _ id ( id ) ) { throw new InvalidTopologyException ( id + _STR + offending ) ; } } 
263	public boolean hasTransposedNavigationBar ( ) { Rect insets = new Rect ( ) ; getStableInsets ( insets ) ; return insets . right > _NUM ; } 
264	public void setGap ( double gap ) { this . gap = gap ; fireChangeEvent ( ) ; } 
265	public boolean isSet ( _ Fields field ) { if ( field = = null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case HOST : return isSetHost ( ) ; case PORT : return isSetPort ( ) ; } throw new IllegalStateException ( ) ; } 
266	public PrintStream append ( char c ) { print ( c ) ; return this ; } 
267	public void testWatermarkEmission ( ) throws Exception { final int numElements = _NUM _NUM _NUM ; final Object checkpointLock = new Object ( ) ; PipelineOptions options = PipelineOptionsFactory . create ( ) ; this source will emit exactly NUM _ ELEMENTS across all parallel readers , afterwards it will stall . We check whether we also receive NUM _ ELEMENTS elements later . TestCountingSource source = new TestCountingSource ( numElements ) ; UnboundedSourceWrapper < KV < Integer , Integer > , TestCountingSource . CounterMark > flinkWrapper = new UnboundedSourceWrapper < > ( _STR ) . join ( caughtExceptions ) ) ; } if ( seenWatermark . get ( ) ) { break ; } Thread . sleep ( _NUM _NUM ) ; need to advance this so that the watermark timers in the source wrapper fire testHarness . setProcessingTime ( Instant . now ( ) . getMillis ( ) ) ; } sourceOperator . cancel ( ) ; sourceThread . join ( ) ; } 
268	public void setParentTextSize ( int size ) { if ( initialised ) { return ; } int pos = _NUM ; int textHandled = _NUM ; paragraphStyles . clear ( ) ; charStyles . clear ( ) ; While we have text in need of paragraph stylings , go ahead and grok the contents as paragraph formatting data int prsize = size ; while ( pos < rawContents . length & & textHandled < prsize ) { First up , fetch the number of characters this applies to int textLen = LittleEndian . getInt ( rawContents , pos ) ; textLen = checkTextLength ( textLen , textHandled , size ) ; textHandled + = textLen ; pos + = _NUM ; short indent = LittleEndian . getShort ( rawContents , pos ) ; pos + = _NUM ; Grab the _NUM byte value that tells us what properties follow int paraFlags = LittleEndian . getInt ( rawContents , pos ) ; pos + = _NUM ; Now make sense of those properties TextPropCollection thisCollection = new TextPropCollection ( textLen , TextPropType . paragraph ) ; thisCollection . setIndentLevel ( indent ) ; int plSize = thisCollection . buildTextPropList ( paraFlags , rawContents , pos ) ; pos + = plSize ; Save this properties set paragraphStyles . add ( thisCollection ) ; Handle extra _NUM paragraph styles at the end if ( pos < rawContents . length & & textHandled = = size ) { prsize + + ; } } if ( rawContents . length > _NUM & & textHandled ! = ( size + _NUM ) ) { logger . log ( POILogger . WARN , _STR + ( size + _NUM ) ) ; } Handle anything left over if ( pos < rawContents . length ) { reserved = IOUtils . safelyAllocate ( rawContents . length - pos , rawContents . length ) ; System . arraycopy ( rawContents , pos , reserved , _NUM , reserved . length ) ; } initialised = true ; } 
269	public OptionalLong executeIfPresent ( LongConsumer consumer ) { ifPresent ( consumer ) ; return this ; } 
270	private static void waitForServer ( ) throws Exception { int count = _NUM ; while ( ! isServerUp ( ) ) { Give a few seconds for the ambari server to start up serverThread . join ( count * _NUM _NUM _NUM _NUM _NUM ) ; count + = _NUM ; progressive back off count * = _NUM ; exponential back off } } 
271	public String csvHeader ( ) { StringBuffer csv = new StringBuffer ( _NUM _NUM _NUM _NUM ) ; Iterator < CmsListColumnDefinition > itCols = m _ columns . elementList ( ) . iterator ( ) ; while ( itCols . hasNext ( ) ) { CmsListColumnDefinition col = itCols . next ( ) ; if ( ! col . isVisible ( ) ) { continue ; } csv . append ( col . csvHeader ( ) ) ; csv . append ( _STR ) ; return csv . toString ( ) ; } 
272	private void twoWayMergeInternalStandard ( final ReservoirItemsSketch < T > source ) { assert ( source . getN ( ) < = source . getK ( ) ) ; final int numInputSamples = source . getNumSamples ( ) ; for ( int i = _NUM ; i < numInputSamples ; + + i ) { gadget _ . update ( source . getValueAtPosition ( i ) ) ; } } 
273	public void setEditorValue ( CmsObject cms , Map < String , String [ ] > formParameters , I _ CmsWidgetDialog widgetDialog , I _ CmsWidgetParameter param ) { String [ ] values = formParameters . get ( param . getId ( ) ) ; if ( ( values ! = null ) & & ( values . length > _NUM ) ) { initialize bundle initConfiguration ( cms , param ) ; String value = m _ messages . key ( m _ bundleKey ) ; if ( value . equals ( values [ _NUM ] . trim ( ) ) ) { value is equal to localized value , do not save value = _STR with OpenCms macros Matcher matcher = PATTERN _ MESSAGEARGUMENT . matcher ( value ) ; while ( matcher . matches ( ) ) { int startIndex = matcher . start ( _NUM ) ; int endIndex = matcher . end ( _NUM ) ; String number = CmsMacroResolver . formatMacro ( matcher . group ( _NUM ) ) ; replace arguments with macros value = value . substring ( _NUM , startIndex ) + number + value . substring ( endIndex ) ; matcher = PATTERN _ MESSAGEARGUMENT . matcher ( value ) ; } } param . setStringValue ( cms , value ) ; } } 
274	public static XmlString parse ( org . w _NUM c . dom . Node node ) throws org . apache . xmlbeans . XmlException { return ( XmlString ) XmlBeans . getContextTypeLoader ( ) . parse ( node , type , null ) ; } 
275	private static String callMethodAndLine ( ) { String result = _STR ; return result ; } 
276	public void checkAndSetZNodeAcls ( ) { if ( ! ZKUtil . isSecureZooKeeper ( getConfiguration ( ) ) ) { LOG . info ( _STR , e ) ; } } 
277	private boolean addIndexesFromParentTable ( MetaDataMutationResult result , Long resolvedTimestamp ) throws SQLException { PTable view = result . getTable ( ) ; If not a view or if a view directly over an HBase table , there ' s nothing to do if ( view . getType ( ) ! = PTableType . VIEW | | view . getViewType ( ) = = ViewType . MAPPED ) { return false ; } a view on a table will not have a parent name but will have a physical table name ( which is the parent ) String parentName = view . getParentName ( ) . getString ( ) ; String schemaName = SchemaUtil . getSchemaNameFromFullName ( parentName ) ; String tableName = SchemaUtil . getTableNameFromFullName ( parentName ) ; MetaDataMutationResult parentResult = updateCache ( connection . getTenantId ( ) , schemaName , tableName , false , resolvedTimestamp ) ; PTable parentTable = parentResult . getTable ( ) ; if ( parentTable = = null ) { throw new TableNotFoundException ( schemaName , tableName ) ; } if ( ! result . wasUpdated ( ) & & ! parentResult . wasUpdated ( ) ) { return false ; } List < PTable > parentTableIndexes = parentTable . getIndexes ( ) ; if ( parentTableIndexes . isEmpty ( ) ) { return false ; } Filter out indexes if column doesn ' t exist in view List < PTable > indexesToAdd = Lists . newArrayListWithExpectedSize ( parentTableIndexes . size ( ) + view . getIndexes ( ) . size ( ) ) ; if ( result . wasUpdated ( ) ) { Table from server never contains inherited indexes indexesToAdd . addAll ( view . getIndexes ( ) ) ; } else { Only add original ones , as inherited ones may have changed for ( PTable index : view . getIndexes ( ) ) { Original indexes will not have a view statement while inherited ones will if ( index . getViewStatement ( ) = = null ) { indexesToAdd . add ( index ) ; } } } for ( PTable index : parentTableIndexes ) { boolean containsAllReqdCols = true ; Ensure that all columns required to create index exist in the view too , since view columns may be removed . IndexMaintainer indexMaintainer = index . getIndexMaintainer ( parentTable , connection ) ; Check that the columns required for the index pk are present in the view Set < Pair < String , String > > indexedColInfos = indexMaintainer . getIndexedColumnInfo ( ) ; for ( Pair < String , String > colInfo : indexedColInfos ) { try { String colFamily = colInfo . getFirst ( ) ; String colName = colInfo . getSecond ( ) ; if ( colFamily = = null ) { view . getColumnForColumnName ( colName ) ; } else { view . getColumnFamily ( colFamily ) . getPColumnForColumnName ( colName ) ; } } catch ( ColumnNotFoundException e ) { containsAllReqdCols = false ; break ; } } all exist in the index on the parent table . for ( PColumn col : view . getColumns ( ) ) { if ( col . getViewConstant ( ) ! = null ) { try { It ' d be possible to use a local index that doesn ' t have all view constants , but the WHERE clause for the view statement ( which is added to the index below ) would fail to compile . String indexColumnName = IndexUtil . getIndexColumnName ( col ) ; index . getColumnForColumnName ( indexColumnName ) ; } catch ( ColumnNotFoundException e _NUM ) { PColumn indexCol = null ; try { String cf = col . getFamilyName ( ) ! = null ? col . getFamilyName ( ) . getString ( ) : null ; String colName = col . getName ( ) . getString ( ) ; if ( cf ! = null ) { indexCol = parentTable . getColumnFamily ( cf ) . getPColumnForColumnName ( colName ) ; } else { indexCol = parentTable . getColumnForColumnName ( colName ) ; } } catch ( ColumnNotFoundException e _NUM ) { Ignore this index and continue with others containsAllReqdCols = false ; break ; } if ( indexCol . getViewConstant ( ) = = null | | Bytes . compareTo ( indexCol . getViewConstant ( ) , col . getViewConstant ( ) ) ! = _NUM ) { containsAllReqdCols = false ; break ; } } } } if ( containsAllReqdCols ) { Tack on view statement to index to get proper filtering for view String viewStatement = IndexUtil . rewriteViewStatement ( connection , index , parentTable , view . getViewStatement ( ) ) ; PName modifiedIndexName = PNameFactory . newName ( view . getName ( ) . getString ( ) + QueryConstants . CHILD _ VIEW _ INDEX _ NAME _ SEPARATOR + index . getName ( ) . getString ( ) ) ; add the index table with a new name so that it does not conflict with the existing index table and set update cache frequency to that of the view indexesToAdd . add ( PTableImpl . makePTable ( index , modifiedIndexName , viewStatement , view . getUpdateCacheFrequency ( ) , view . getTenantId ( ) ) ) ; } } PTable allIndexesTable = PTableImpl . makePTable ( view , view . getTimeStamp ( ) , indexesToAdd ) ; result . setTable ( allIndexesTable ) ; return true ; } 
278	public static RequestAsyncTask executeRestRequestAsync ( Session session , String restMethod , Bundle parameters , HttpMethod httpMethod ) { return newRestRequest ( session , restMethod , parameters , httpMethod ) . executeAsync ( ) ; } 
279	public static List < FeedItem > getRecentlyPublishedEpisodes ( int limit ) { Log . d ( TAG , _STR ) ; PodDBAdapter adapter = PodDBAdapter . getInstance ( ) ; adapter . open ( ) ; Cursor cursor = null ; try { cursor = adapter . getRecentlyPublishedItemsCursor ( limit ) ; List < FeedItem > items = extractItemlistFromCursor ( adapter , cursor ) ; loadAdditionalFeedItemListData ( items ) ; return items ; } finally { if ( cursor ! = null ) { cursor . close ( ) ; } adapter . close ( ) ; } } 
280	public Set < Dataset > findDistinctDatasets ( ) throws IOException { Set < Dataset > datasets = Sets . newHashSet ( ) ; for ( FileStatus datasetsFileStatus : this . fs . globStatus ( new Path ( inputDir , subDirPattern ) ) ) { log . info ( _STR , jobInputPath , e ) ; continue ; } if ( folderWithinAllowedPeriod ( jobInputPath , folderTime ) ) { Path jobInputLatePath = appendFolderTime ( inputLatePath , folderTime ) ; Path jobOutputPath = appendFolderTime ( outputPath , folderTime ) ; Path jobOutputLatePath = appendFolderTime ( outputLatePath , folderTime ) ; Path jobOutputTmpPath = appendFolderTime ( outputTmpPath , folderTime ) ; Dataset timeBasedDataset = new Dataset . Builder ( ) . withPriority ( priority ) . withDatasetName ( datasetName ) . addInputPath ( this . recompactDatasets ? jobOutputPath : jobInputPath ) . addInputLatePath ( this . recompactDatasets ? jobOutputLatePath : jobInputLatePath ) . withOutputPath ( jobOutputPath ) . withOutputLatePath ( jobOutputLatePath ) . withOutputTmpPath ( jobOutputTmpPath ) . build ( ) ; Stores the extra information for timeBasedDataset timeBasedDataset . setJobProp ( MRCompactor . COMPACTION _ JOB _ DEST _ PARTITION , folderTime . toString ( this . timeFormatter ) ) ; timeBasedDataset . setJobProp ( MRCompactor . COMPACTION _ INPUT _ PATH _ TIME , folderTime . getMillis ( ) ) ; datasets . add ( timeBasedDataset ) ; } } } } } return datasets ; } 
281	public boolean setFontVariationSettings ( String fontVariationSettings ) { final String settings = TextUtils . nullIfEmpty ( fontVariationSettings ) ; if ( settings = = mFontVariationSettings | | ( settings ! = null & & settings . equals ( mFontVariationSettings ) ) ) { return true ; } if ( settings = = null | | settings . length ( ) = = _NUM ) { mFontVariationSettings = null ; setTypeface ( Typeface . createFromTypefaceWithVariation ( mTypeface , Collections . emptyList ( ) ) ) ; return true ; } The null typeface is valid and it is equivalent to Typeface . DEFAULT . To call isSupportedAxes method , use Typeface . DEFAULT instance . Typeface targetTypeface = mTypeface = = null ? Typeface . DEFAULT : mTypeface ; FontVariationAxis [ ] axes = FontVariationAxis . fromFontVariationSettings ( settings ) ; final ArrayList < FontVariationAxis > filteredAxes = new ArrayList < FontVariationAxis > ( ) ; for ( final FontVariationAxis axis : axes ) { if ( targetTypeface . isSupportedAxes ( axis . getOpenTypeTagValue ( ) ) ) { filteredAxes . add ( axis ) ; } } if ( filteredAxes . isEmpty ( ) ) { return false ; } mFontVariationSettings = settings ; setTypeface ( Typeface . createFromTypefaceWithVariation ( targetTypeface , filteredAxes ) ) ; return true ; } 
282	private float getScrollFactor ( ) { if ( mScrollFactor = = Float . MIN _ VALUE ) { TypedValue outValue = new TypedValue ( ) ; if ( getContext ( ) . getTheme ( ) . resolveAttribute ( android . R . attr . listPreferredItemHeight , outValue , true ) ) { mScrollFactor = outValue . getDimension ( getContext ( ) . getResources ( ) . getDisplayMetrics ( ) ) ; } else { listPreferredItemHeight is not defined , no generic scrolling return _NUM ; } } return mScrollFactor ; } 
283	public final void setIncomingMessage ( Class < ? extends Writable > incomingMessageClass ) { superstepClasses . setIncomingMessageClass ( incomingMessageClass ) ; } 
284	public static ComponentName getCallingActivity ( Activity calledActivity ) { ComponentName result = calledActivity . getCallingActivity ( ) ; if ( result = = null ) { result = calledActivity . getIntent ( ) . getParcelableExtra ( EXTRA _ CALLING _ ACTIVITY ) ; } return result ; } 
285	public ParameterConfiguration getPropertyConfiguration ( String name ) { return getPropertyConfigurationMap ( ) . get ( name ) ; } 
286	public TechnicalInformation getTechnicalInformation ( ) { TechnicalInformation result ; result = new TechnicalInformation ( Type . MISC ) ; result . setValue ( Field . AUTHOR , _STR http : return result ; } 
287	public static XmlNonNegativeInteger newInstance ( org . apache . xmlbeans . XmlOptions options ) { return ( XmlNonNegativeInteger ) XmlBeans . getContextTypeLoader ( ) . newInstance ( type , options ) ; } 
288	public void resetDetailLevels ( ) { detailManager . resetDetailLevels ( ) ; refresh ( ) ; } 
289	public void fillRectRadialGradient ( int startColor , int endColor , int x , int y , int width , int height , float relativeX , float relativeY , float relativeSize ) { people do that a lot sadly . . . if ( startColor = = endColor ) { setColor ( startColor ) ; fillRect ( x , y , width , height , ( byte ) _NUM xff ) ; return ; } impl . fillRectRadialGradient ( nativeGraphics , startColor , endColor , x + xTranslate , y + yTranslate , width , height , relativeX , relativeY , relativeSize ) ; } 
290	private void updateThumbPath ( ) { mThumbCurvature = mThumbMaxWidth - mThumbWidth ; mThumbPath . reset ( ) ; tr mThumbPath . moveTo ( mThumbOffset . x + mThumbWidth , mThumbOffset . y ) ; br mThumbPath . lineTo ( mThumbOffset . x + mThumbWidth , mThumbOffset . y + mThumbHeight ) ; bl mThumbPath . lineTo ( mThumbOffset . x , mThumbOffset . y + mThumbHeight ) ; mThumbPath . cubicTo ( mThumbOffset . x , mThumbOffset . y + mThumbHeight , mThumbOffset . x - mThumbCurvature , mThumbOffset . y + mThumbHeight / _NUM , mThumbOffset . x , bl _NUM tl mThumbOffset . y ) ; mThumbPath . close ( ) ; } 
291	public LayeredLayout setReferenceComponentLeft ( Component cmp , Component referenceComponent ) { getOrCreateConstraint ( cmp ) . left ( ) . referenceComponent ( referenceComponent ) ; return this ; } 
292	public void setLineCapStyle ( int lineCapStyle ) throws IOException { if ( inTextMode ) { throw new IllegalStateException ( _STR ) ; } } 
293	public void quantilesCheckViaMemory ( ) { int k = _NUM _NUM _NUM ; int n = _NUM _NUM _NUM _NUM _NUM _NUM _NUM ; DoublesSketch qs = buildAndLoadQS ( k , n ) ; double [ ] ranks = { _NUM . _NUM , _NUM . _NUM , _NUM . _NUM , _NUM . _NUM , _NUM . _NUM , _NUM . _NUM , _NUM . _NUM , _NUM . _NUM , _NUM . _NUM , _NUM . _NUM , _NUM . _NUM } ; String s = getRanksTable ( qs , ranks ) ; println ( s ) ; println ( _STR ) ; Memory srcMem = Memory . wrap ( qs . toByteArray ( ) ) ; HeapUpdateDoublesSketch qs _NUM = HeapUpdateDoublesSketch . heapifyInstance ( srcMem ) ; println ( getRanksTable ( qs _NUM , ranks ) ) ; } 
294	public void testSuccess ( ) throws Exception { Configuration conf = new Configuration ( ) ; conf . setBoolean ( YarnConfiguration . SHARED _ CACHE _ ENABLED , true ) ; LocalResource resource = mock ( LocalResource . class ) ; Path localPath = mock ( Path . class ) ; when ( localPath . getName ( ) ) . thenReturn ( _STR ) . when ( spied ) . computeChecksum ( isA ( Path . class ) ) ; stub uploadFile ( ) to return true doReturn ( true ) . when ( spied ) . uploadFile ( isA ( Path . class ) , isA ( Path . class ) ) ; stub notifySharedCacheManager to return true doReturn ( true ) . when ( spied ) . notifySharedCacheManager ( isA ( String . class ) , isA ( String . class ) ) ; assertTrue ( spied . call ( ) ) ; } 
295	public void testSearchRestriction ( ) throws Exception { CmsObject cms = getCmsObject ( ) ; echo ( _STR ) ; TestCmsSearch . printResults ( searchResult , cms ) ; assertEquals ( expect , searchResult . size ( ) ) ; } } 
296	private void executeOpsTogether ( ArrayList < BackStackRecord > records , ArrayList < Boolean > isRecordPop , int startIndex , int endIndex ) { final boolean allowReordering = records . get ( startIndex ) . mReorderingAllowed ; boolean addToBackStack = false ; if ( mTmpAddedFragments = = null ) { mTmpAddedFragments = new ArrayList < > ( ) ; } else { mTmpAddedFragments . clear ( ) ; } mTmpAddedFragments . addAll ( mAdded ) ; Fragment oldPrimaryNav = getPrimaryNavigationFragment ( ) ; for ( int recordNum = startIndex ; recordNum < endIndex ; recordNum + + ) { final BackStackRecord record = records . get ( recordNum ) ; final boolean isPop = isRecordPop . get ( recordNum ) ; if ( ! isPop ) { oldPrimaryNav = record . expandOps ( mTmpAddedFragments , oldPrimaryNav ) ; } else { oldPrimaryNav = record . trackAddedFragmentsInPop ( mTmpAddedFragments , oldPrimaryNav ) ; } addToBackStack = addToBackStack | | record . mAddToBackStack ; } mTmpAddedFragments . clear ( ) ; if ( ! allowReordering ) { FragmentTransition . startTransitions ( this , records , isRecordPop , startIndex , endIndex , false ) ; } executeOps ( records , isRecordPop , startIndex , endIndex ) ; int postponeIndex = endIndex ; if ( allowReordering ) { ArraySet < Fragment > addedFragments = new ArraySet < > ( ) ; addAddedFragments ( addedFragments ) ; postponeIndex = postponePostponableTransactions ( records , isRecordPop , startIndex , endIndex , addedFragments ) ; makeRemovedFragmentsInvisible ( addedFragments ) ; } if ( postponeIndex ! = startIndex & & allowReordering ) { need to run something now FragmentTransition . startTransitions ( this , records , isRecordPop , startIndex , postponeIndex , true ) ; moveToState ( mCurState , true ) ; } for ( int recordNum = startIndex ; recordNum < endIndex ; recordNum + + ) { final BackStackRecord record = records . get ( recordNum ) ; final boolean isPop = isRecordPop . get ( recordNum ) ; if ( isPop & & record . mIndex > = _NUM ) { freeBackStackIndex ( record . mIndex ) ; record . mIndex = - _NUM ; } record . runOnCommitRunnables ( ) ; } if ( addToBackStack ) { reportBackStackChanged ( ) ; } } 
297	public synchronized V put ( K key , V value ) { if ( key ! = null & & value ! = null ) { int hash = key . hashCode ( ) ; int index = ( hash & _NUM x _NUM FFFFFFF ) % elementData . length ; Entry < K , V > entry = elementData [ index ] ; while ( entry ! = null & & ! entry . equalsKey ( key , hash ) ) { entry = entry . next ; } if ( entry = = null ) { modCount + + ; if ( + + elementCount > threshold ) { rehash ( ) ; index = ( hash & _NUM x _NUM FFFFFFF ) % elementData . length ; } if ( index < firstSlot ) { firstSlot = index ; } if ( index > lastSlot ) { lastSlot = index ; } entry = newEntry ( key , value , hash ) ; entry . next = elementData [ index ] ; elementData [ index ] = entry ; return null ; } V result = entry . value ; entry . value = value ; return result ; } throw new NullPointerException ( ) ; } 
298	public ListenableFuture execute ( Supplier < ListenableFuture < List < RepairSessionResult > > > sessionSubmitter , AtomicBoolean hasFailure ) { logger . info ( _STR , sessionID , formatDuration ( sessionStart , System . currentTimeMillis ( ) ) ) ; } hasFailure . set ( true ) ; fail ( ) ; } } ) ; return proposeFuture ; } 
299	public final V get ( K key ) { if ( key = = null ) { throw new NullPointerException ( _STR ) ; } V mapValue ; synchronized ( this ) { mapValue = map . get ( key ) ; if ( mapValue ! = null ) { hitCount + + ; return mapValue ; } missCount + + ; } V createdValue = create ( key ) ; if ( createdValue = = null ) { return null ; } synchronized ( this ) { createCount + + ; mapValue = map . put ( key , createdValue ) ; if ( mapValue ! = null ) { There was a conflict so undo that last put map . put ( key , mapValue ) ; } else { size + = safeSizeOf ( key , createdValue ) ; } } if ( mapValue ! = null ) { entryRemoved ( false , key , createdValue , mapValue ) ; return mapValue ; } else { trimToSize ( maxSize ) ; return createdValue ; } } 
300	public String getAudience ( ) { List < String > audiences = getAudiences ( ) ; if ( ! StringUtils . isEmpty ( audiences ) ) { return audiences . get ( _NUM ) ; } return null ; } 
301	public static Node buildTreeClone ( List < Node > nodes ) { if ( nodes . size ( ) = = _NUM ) { return new NodeTree ( nodes . get ( _NUM ) ) . cloneSubtree ( ) ; } Node n = nodes . get ( _NUM ) ; Node clone = n . cloneNode ( false ) ; OrderedNodeMatcher matcher = new OrderedNodeMatcher ( nodes ) ; while ( ! matcher . isFinished ( ) ) { if ( matcher . match ( n ) ) { if ( matcher . isFinished ( ) ) break ; } else { n = n . getFirstChild ( ) ; while ( ! JavaScript . contains ( n , matcher . peek ( ) ) ) { n = n . getNextSibling ( ) ; } clone = cloneChild ( clone , n ) ; continue ; } while ( true ) { Node s = n . getNextSibling ( ) ; while ( s ! = null & & ! JavaScript . contains ( s , matcher . peek ( ) ) ) { s = s . getNextSibling ( ) ; } if ( s ! = null ) { clone = cloneParent ( clone , n . getParentNode ( ) ) ; clone = cloneChild ( clone , s ) ; n = s ; break ; } n = n . getParentNode ( ) ; clone = cloneParent ( clone , n ) ; } } while ( clone . getParentNode ( ) ! = null ) { clone = clone . getParentNode ( ) ; } return clone ; } 
302	public static void addInputPath ( JobConf conf , Path path ) { path = new Path ( conf . getWorkingDirectory ( ) , path ) ; String dirStr = StringUtils . escapeString ( path . toString ( ) ) ; String dirs = conf . get ( org . apache . hadoop . mapreduce . lib . input . FileInputFormat . INPUT _ DIR ) ; conf . set ( org . apache . hadoop . mapreduce . lib . input . FileInputFormat . INPUT _ DIR , dirs = = null ? dirStr : dirs + StringUtils . COMMA _ STR + dirStr ) ; } 
303	private static String trim ( String s , String suffix ) { String trimmed = trimOrNull ( s , suffix ) ; return trimmed ! = null ? trimmed : s ; } 
304	public void draw ( PdfContentByte canvas , float llx , float lly , float urx , float ury , float y ) { canvas . saveState ( ) ; drawLine ( canvas , llx , urx , y ) ; canvas . restoreState ( ) ; } 
305	protected Path getCommittedTaskPath ( int appAttemptId , TaskAttemptContext context ) { return new Path ( getJobAttemptPath ( appAttemptId ) , String . valueOf ( context . getTaskAttemptID ( ) . getTaskID ( ) ) ) ; } 
306	public ManagedObjectReference getMoRefProp ( ManagedObjectReference objMor , String propName ) throws Exception { Object props = getDynamicProperty ( objMor , propName ) ; ManagedObjectReference propmor = null ; if ( ! props . getClass ( ) . isArray ( ) ) { propmor = ( ManagedObjectReference ) props ; } return propmor ; } 
307	public static QualityOfProtection getQop ( String stringQop ) { for ( QualityOfProtection qop : QualityOfProtection . values ( ) ) { if ( qop . matches ( stringQop ) ) { return qop ; } } throw new IllegalArgumentException ( _STR ) ; } 
308	public Set < K > keySet ( ) { if ( keySet = = null ) { keySet = new AbstractSet < K > ( ) { @ Override public boolean contains ( Object object ) { return containsKey ( object ) ; } @ Override public int size ( ) { return HashMap . this . size ( ) ; } @ Override public void clear ( ) { HashMap . this . clear ( ) ; } @ Override public boolean remove ( Object key ) { Entry < K , V > entry = HashMap . this . removeEntry ( key ) ; return entry ! = null ; } @ Override public Iterator < K > iterator ( ) { return new KeyIterator < K , V > ( HashMap . this ) ; } } ; } return keySet ; } 
309	public PdfAppearance getAppearance ( ) throws IOException , DocumentException { PdfAppearance app = getBorderAppearance ( ) ; Rectangle box = new Rectangle ( app . getBoundingBox ( ) ) ; if ( ( text = = null | | text . length ( ) = = _NUM ) & & ( layout = = LAYOUT _ LABEL _ ONLY | | ( image = = null & & template = = null & & iconReference = = null ) ) ) { return app ; } if ( layout = = LAYOUT _ ICON _ ONLY & & image = = null & & template = = null & & iconReference = = null ) return app ; BaseFont ufont = getRealFont ( ) ; boolean borderExtra = borderStyle = = PdfBorderDictionary . STYLE _ BEVELED | | borderStyle = = PdfBorderDictionary . STYLE _ INSET ; float h = box . getHeight ( ) - borderWidth * _NUM ; float bw _NUM = borderWidth ; if ( borderExtra ) { h - = borderWidth * _NUM ; bw _NUM * = _NUM ; } float offsetX = ( borderExtra ? _NUM * borderWidth : borderWidth ) ; offsetX = Math . max ( offsetX , _NUM ) ; float offX = Math . min ( bw _NUM , offsetX ) ; tp = null ; float textX = Float . NaN ; float textY = _NUM ; float fsize = fontSize ; float wt = box . getWidth ( ) - _NUM * offX - _NUM ; float ht = box . getHeight ( ) - _NUM * offX ; float adj = ( iconFitToBounds ? _NUM : offX + _NUM ) ; int nlayout = layout ; if ( image = = null & & template = = null & & iconReference = = null ) nlayout = LAYOUT _ LABEL _ ONLY ; Rectangle iconBox = null ; while ( true ) { switch ( nlayout ) { case LAYOUT _ LABEL _ ONLY : case LAYOUT _ LABEL _ OVER _ ICON : if ( text ! = null & & text . length ( ) > _NUM & & wt > _NUM & & ht > _NUM ) { fsize = calculateFontSize ( wt , ht ) ; textX = ( box . getWidth ( ) - ufont . getWidthPoint ( text , fsize ) ) / _NUM ; textY = ( box . getHeight ( ) - ufont . getFontDescriptor ( BaseFont . ASCENT , fsize ) ) / _NUM ; } case LAYOUT _ ICON _ ONLY : if ( nlayout = = LAYOUT _ LABEL _ OVER _ ICON | | nlayout = = LAYOUT _ ICON _ ONLY ) iconBox = new Rectangle ( box . getLeft ( ) + adj , box . getBottom ( ) + adj , box . getRight ( ) - adj , box . getTop ( ) - adj ) ; break ; case LAYOUT _ ICON _ TOP _ LABEL _ BOTTOM : if ( text = = null | | text . length ( ) = = _NUM | | wt < = _NUM | | ht < = _NUM ) { nlayout = LAYOUT _ ICON _ ONLY ; continue ; } float nht = box . getHeight ( ) * _NUM . _NUM _NUM f - offX ; if ( nht > _NUM ) fsize = calculateFontSize ( wt , nht ) ; else fsize = _NUM ; textX = ( box . getWidth ( ) - ufont . getWidthPoint ( text , fsize ) ) / _NUM ; textY = offX - ufont . getFontDescriptor ( BaseFont . DESCENT , fsize ) ; iconBox = new Rectangle ( box . getLeft ( ) + adj , textY + fsize , box . getRight ( ) - adj , box . getTop ( ) - adj ) ; break ; case LAYOUT _ LABEL _ TOP _ ICON _ BOTTOM : if ( text = = null | | text . length ( ) = = _NUM | | wt < = _NUM | | ht < = _NUM ) { nlayout = LAYOUT _ ICON _ ONLY ; continue ; } nht = box . getHeight ( ) * _NUM . _NUM _NUM f - offX ; if ( nht > _NUM ) fsize = calculateFontSize ( wt , nht ) ; else fsize = _NUM ; textX = ( box . getWidth ( ) - ufont . getWidthPoint ( text , fsize ) ) / _NUM ; textY = box . getHeight ( ) - offX - fsize ; if ( textY < offX ) textY = offX ; iconBox = new Rectangle ( box . getLeft ( ) + adj , box . getBottom ( ) + adj , box . getRight ( ) - adj , textY + ufont . getFontDescriptor ( BaseFont . DESCENT , fsize ) ) ; break ; case LAYOUT _ LABEL _ LEFT _ ICON _ RIGHT : if ( text = = null | | text . length ( ) = = _NUM | | wt < = _NUM | | ht < = _NUM ) { nlayout = LAYOUT _ ICON _ ONLY ; continue ; } float nw = box . getWidth ( ) * _NUM . _NUM _NUM f - offX ; if ( nw > _NUM ) fsize = calculateFontSize ( wt , nw ) ; else fsize = _NUM ; if ( ufont . getWidthPoint ( text , fsize ) > = wt ) { nlayout = LAYOUT _ LABEL _ ONLY ; fsize = fontSize ; continue ; } textX = offX + _NUM ; textY = ( box . getHeight ( ) - ufont . getFontDescriptor ( BaseFont . ASCENT , fsize ) ) / _NUM ; iconBox = new Rectangle ( textX + ufont . getWidthPoint ( text , fsize ) , box . getBottom ( ) + adj , box . getRight ( ) - adj , box . getTop ( ) - adj ) ; break ; case LAYOUT _ ICON _ LEFT _ LABEL _ RIGHT : if ( text = = null | | text . length ( ) = = _NUM | | wt < = _NUM | | ht < = _NUM ) { nlayout = LAYOUT _ ICON _ ONLY ; continue ; } nw = box . getWidth ( ) * _NUM . _NUM _NUM f - offX ; if ( nw > _NUM ) fsize = calculateFontSize ( wt , nw ) ; else fsize = _NUM ; if ( ufont . getWidthPoint ( text , fsize ) > = wt ) { nlayout = LAYOUT _ LABEL _ ONLY ; fsize = fontSize ; continue ; } textX = box . getWidth ( ) - ufont . getWidthPoint ( text , fsize ) - offX - _NUM ; textY = ( box . getHeight ( ) - ufont . getFontDescriptor ( BaseFont . ASCENT , fsize ) ) / _NUM ; iconBox = new Rectangle ( box . getLeft ( ) + adj , box . getBottom ( ) + adj , textX - _NUM , box . getTop ( ) - adj ) ; break ; } break ; } if ( textY < box . getBottom ( ) + offX ) textY = box . getBottom ( ) + offX ; if ( iconBox ! = null & & ( iconBox . getWidth ( ) < = _NUM | | iconBox . getHeight ( ) < = _NUM ) ) iconBox = null ; boolean haveIcon = false ; float boundingBoxWidth = _NUM ; float boundingBoxHeight = _NUM ; PdfArray matrix = null ; if ( iconBox ! = null ) { if ( image ! = null ) { tp = new PdfTemplate ( writer ) ; tp . setBoundingBox ( new Rectangle ( image ) ) ; writer . addDirectTemplateSimple ( tp , PdfName . FRM ) ; tp . addImage ( image , image . getWidth ( ) , _NUM , _NUM , image . getHeight ( ) , _NUM , _NUM ) ; haveIcon = true ; boundingBoxWidth = tp . getBoundingBox ( ) . getWidth ( ) ; boundingBoxHeight = tp . getBoundingBox ( ) . getHeight ( ) ; } else if ( template ! = null ) { tp = new PdfTemplate ( writer ) ; tp . setBoundingBox ( new Rectangle ( template . getWidth ( ) , template . getHeight ( ) ) ) ; writer . addDirectTemplateSimple ( tp , PdfName . FRM ) ; tp . addTemplate ( template , template . getBoundingBox ( ) . getLeft ( ) , template . getBoundingBox ( ) . getBottom ( ) ) ; haveIcon = true ; boundingBoxWidth = tp . getBoundingBox ( ) . getWidth ( ) ; boundingBoxHeight = tp . getBoundingBox ( ) . getHeight ( ) ; } else if ( iconReference ! = null ) { PdfDictionary dic = ( PdfDictionary ) PdfReader . getPdfObject ( iconReference ) ; if ( dic ! = null ) { Rectangle r _NUM = PdfReader . getNormalizedRectangle ( dic . getAsArray ( PdfName . BBOX ) ) ; matrix = dic . getAsArray ( PdfName . MATRIX ) ; haveIcon = true ; boundingBoxWidth = r _NUM . getWidth ( ) ; boundingBoxHeight = r _NUM . getHeight ( ) ; } } } if ( haveIcon ) { float icx = iconBox . getWidth ( ) / boundingBoxWidth ; float icy = iconBox . getHeight ( ) / boundingBoxHeight ; if ( proportionalIcon ) { switch ( scaleIcon ) { case SCALE _ ICON _ IS _ TOO _ BIG : icx = Math . min ( icx , icy ) ; icx = Math . min ( icx , _NUM ) ; break ; case SCALE _ ICON _ IS _ TOO _ SMALL : icx = Math . min ( icx , icy ) ; icx = Math . max ( icx , _NUM ) ; break ; case SCALE _ ICON _ NEVER : icx = _NUM ; break ; default : icx = Math . min ( icx , icy ) ; break ; } icy = icx ; } else { switch ( scaleIcon ) { case SCALE _ ICON _ IS _ TOO _ BIG : icx = Math . min ( icx , _NUM ) ; icy = Math . min ( icy , _NUM ) ; break ; case SCALE _ ICON _ IS _ TOO _ SMALL : icx = Math . max ( icx , _NUM ) ; icy = Math . max ( icy , _NUM ) ; break ; case SCALE _ ICON _ NEVER : icx = icy = _NUM ; break ; default : break ; } } float xpos = iconBox . getLeft ( ) + ( iconBox . getWidth ( ) - ( boundingBoxWidth * icx ) ) * iconHorizontalAdjustment ; float ypos = iconBox . getBottom ( ) + ( iconBox . getHeight ( ) - ( boundingBoxHeight * icy ) ) * iconVerticalAdjustment ; app . saveState ( ) ; app . rectangle ( iconBox . getLeft ( ) , iconBox . getBottom ( ) , iconBox . getWidth ( ) , iconBox . getHeight ( ) ) ; app . clip ( ) ; app . newPath ( ) ; if ( tp ! = null ) app . addTemplate ( tp , icx , _NUM , _NUM , icy , xpos , ypos ) ; else { float cox = _NUM ; float coy = _NUM ; if ( matrix ! = null & & matrix . size ( ) = = _NUM ) { PdfNumber nm = matrix . getAsNumber ( _NUM ) ; if ( nm ! = null ) cox = nm . floatValue ( ) ; nm = matrix . getAsNumber ( _NUM ) ; if ( nm ! = null ) coy = nm . floatValue ( ) ; } app . addTemplateReference ( iconReference , PdfName . FRM , icx , _NUM , _NUM , icy , xpos - cox * icx , ypos - coy * icy ) ; } app . restoreState ( ) ; } if ( ! Float . isNaN ( textX ) ) { app . saveState ( ) ; app . rectangle ( offX , offX , box . getWidth ( ) - _NUM * offX , box . getHeight ( ) - _NUM * offX ) ; app . clip ( ) ; app . newPath ( ) ; if ( textColor = = null ) app . resetGrayFill ( ) ; else app . setColorFill ( textColor ) ; app . beginText ( ) ; app . setFontAndSize ( ufont , fsize ) ; app . setTextMatrix ( textX , textY ) ; app . showText ( text ) ; app . endText ( ) ; app . restoreState ( ) ; } return app ; } 
310	private static void initHotspotMBean ( ) throws IOException { if ( hotspotMBean = = null ) { synchronized ( HeapDump . class ) { if ( hotspotMBean = = null ) { hotspotMBean = getHotspotMBean ( ) ; } } } } 
311	public void setWrappedAlgorithm ( Object algorithm ) { if ( ! ( algorithm instanceof weka . associations . Associator ) ) { throw new IllegalArgumentException ( algorithm . getClass ( ) + _STR ) ; } setAssociator ( ( weka . associations . Associator ) algorithm ) ; } 
312	public void replaceAll ( BiFunction < ? super K , ? super V , ? extends V > function ) { Objects . requireNonNull ( function ) ; for ( Map . Entry < K , V > entry : entrySet ( ) ) { K k ; V v ; try { k = entry . getKey ( ) ; v = entry . getValue ( ) ; } catch ( IllegalStateException ise ) { this usually means the entry is no longer in the map . throw new ConcurrentModificationException ( ise ) ; } ise thrown from function is not a cme . v = function . apply ( k , v ) ; try { blindPut ( k , v ) ; } catch ( IllegalStateException ise ) { this usually means the entry is no longer in the map . throw new ConcurrentModificationException ( ise ) ; } } } 
313	protected void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { int widthMode = MeasureSpec . getMode ( widthMeasureSpec ) ; int widthSize ; int heightSize ; final int mPaddingLeft = getPaddingLeft ( ) ; final int mPaddingTop = getPaddingTop ( ) ; final int mPaddingRight = getPaddingRight ( ) ; final int mPaddingBottom = getPaddingBottom ( ) ; mSpinnerPadding . left = mPaddingLeft > mSelectionLeftPadding ? mPaddingLeft : mSelectionLeftPadding ; mSpinnerPadding . top = mPaddingTop > mSelectionTopPadding ? mPaddingTop : mSelectionTopPadding ; mSpinnerPadding . right = mPaddingRight > mSelectionRightPadding ? mPaddingRight : mSelectionRightPadding ; mSpinnerPadding . bottom = mPaddingBottom > mSelectionBottomPadding ? mPaddingBottom : mSelectionBottomPadding ; if ( mDataChanged ) { handleDataChanged ( ) ; } int preferredHeight = _NUM ; int preferredWidth = _NUM ; boolean needsMeasuring = true ; int selectedPosition = getSelectedItemPosition ( ) ; if ( selectedPosition > = _NUM & & mAdapter ! = null & & selectedPosition < mAdapter . getCount ( ) ) { Try looking in the recycler . ( Maybe we were measured once already ) View view = mRecycler . get ( selectedPosition ) ; if ( view = = null ) { Make a new one view = mAdapter . getView ( selectedPosition , null , this ) ; } if ( view ! = null ) { Put in recycler for re - measuring and / or layout mRecycler . put ( selectedPosition , view ) ; } if ( view ! = null ) { if ( view . getLayoutParams ( ) = = null ) { mBlockLayoutRequests = true ; view . setLayoutParams ( generateDefaultLayoutParams ( ) ) ; mBlockLayoutRequests = false ; } measureChild ( view , widthMeasureSpec , heightMeasureSpec ) ; preferredHeight = getChildHeight ( view ) + mSpinnerPadding . top + mSpinnerPadding . bottom ; preferredWidth = getChildWidth ( view ) + mSpinnerPadding . left + mSpinnerPadding . right ; needsMeasuring = false ; } } if ( needsMeasuring ) { No views - - just use padding preferredHeight = mSpinnerPadding . top + mSpinnerPadding . bottom ; if ( widthMode = = MeasureSpec . UNSPECIFIED ) { preferredWidth = mSpinnerPadding . left + mSpinnerPadding . right ; } } preferredHeight = Math . max ( preferredHeight , getSuggestedMinimumHeight ( ) ) ; preferredWidth = Math . max ( preferredWidth , getSuggestedMinimumWidth ( ) ) ; if ( IS _ HONEYCOMB ) { heightSize = resolveSizeAndState ( preferredHeight , heightMeasureSpec , _NUM ) ; widthSize = resolveSizeAndState ( preferredWidth , widthMeasureSpec , _NUM ) ; } else { heightSize = resolveSize ( preferredHeight , heightMeasureSpec ) ; widthSize = resolveSize ( preferredWidth , widthMeasureSpec ) ; } setMeasuredDimension ( widthSize , heightSize ) ; mHeightMeasureSpec = heightMeasureSpec ; mWidthMeasureSpec = widthMeasureSpec ; } 
314	protected void finalize ( ) throws Throwable { finish ( ) ; super . finalize ( ) ; } 
315	public I _ CmsXmlContentValue addValue ( CmsObject cms , String path , Locale locale , int index ) throws CmsIllegalArgumentException , CmsRuntimeException { get the schema type of the requested path I _ CmsXmlSchemaType type = m _ contentDefinition . getSchemaType ( path ) ; if ( type = = null ) { throw new CmsIllegalArgumentException ( Messages . get ( ) . container ( Messages . ERR _ XMLCONTENT _ UNKNOWN _ ELEM _ PATH _ SCHEMA _ _NUM , path ) ) ; } Element parentElement ; String elementName ; CmsXmlContentDefinition contentDefinition ; if ( CmsXmlUtils . isDeepXpath ( path ) ) { this is a nested content definition , so the parent element must be in the bookmarks String parentPath = CmsXmlUtils . createXpath ( CmsXmlUtils . removeLastXpathElement ( path ) , _NUM ) ; Object o = getBookmark ( parentPath , locale ) ; if ( o = = null ) { throw new CmsIllegalArgumentException ( Messages . get ( ) . container ( Messages . ERR _ XMLCONTENT _ UNKNOWN _ ELEM _ PATH _ _NUM , path ) ) ; } CmsXmlNestedContentDefinition parentValue = ( CmsXmlNestedContentDefinition ) o ; parentElement = parentValue . getElement ( ) ; elementName = CmsXmlUtils . getLastXpathElement ( path ) ; contentDefinition = parentValue . getNestedContentDefinition ( ) ; } else { the parent element is the locale element parentElement = getLocaleNode ( locale ) ; elementName = CmsXmlUtils . removeXpathIndex ( path ) ; contentDefinition = m _ contentDefinition ; } read the XML siblings from the parent node List < Element > siblings = CmsXmlGenericWrapper . elements ( parentElement , elementName ) ; int insertIndex ; if ( contentDefinition . getChoiceMaxOccurs ( ) > _NUM ) { for a choice sequence we do not check the index position , we rather do a full XML validation afterwards insertIndex = index ; } else if ( siblings . size ( ) > _NUM ) { if ( siblings . size ( ) > = type . getMaxOccurs ( ) ) { must not allow adding an element if max occurs would be violated throw new CmsRuntimeException ( Messages . get ( ) . container ( Messages . ERR _ XMLCONTENT _ ELEM _ MAXOCCURS _ _NUM , elementName , new Integer ( type . getMaxOccurs ( ) ) ) ) ; } if ( index > siblings . size ( ) ) { index position behind last element of the list throw new CmsRuntimeException ( Messages . get ( ) . container ( Messages . ERR _ XMLCONTENT _ ADD _ ELEM _ INVALID _ IDX _ _NUM , new Integer ( index ) , new Integer ( siblings . size ( ) ) ) ) ; } check for offset required to append beyond last position int offset = ( index = = siblings . size ( ) ) ? _NUM : _NUM ; get the element from the parent at the selected position Element sibling = siblings . get ( index - offset ) ; check position of the node in the parent node content insertIndex = sibling . getParent ( ) . content ( ) . indexOf ( sibling ) + offset ; } else { if ( index > _NUM ) { since the element does not occur , index must be _NUM throw new CmsRuntimeException ( Messages . get ( ) . container ( Messages . ERR _ XMLCONTENT _ ADD _ ELEM _ INVALID _ IDX _ _NUM , new Integer ( index ) , elementName ) ) ; } check where in the type sequence the type should appear int typeIndex = contentDefinition . getTypeSequence ( ) . indexOf ( type ) ; if ( typeIndex = = _NUM ) { this is the first type , so we just add at the very first position insertIndex = _NUM ; } else { create a list of all element names that should occur before the selected type List < String > previousTypeNames = new ArrayList < String > ( ) ; for ( int i = _NUM ; i < typeIndex ; i + + ) { I _ CmsXmlSchemaType t = contentDefinition . getTypeSequence ( ) . get ( i ) ; previousTypeNames . add ( t . getName ( ) ) ; } iterate all elements of the parent node Iterator < Node > i = CmsXmlGenericWrapper . content ( parentElement ) . iterator ( ) ; int pos = _NUM ; while ( i . hasNext ( ) ) { Node node = i . next ( ) ; if ( node instanceof Element ) { if ( ! previousTypeNames . contains ( node . getName ( ) ) ) { so it must be an element that occurs AFTER the type break ; } } pos + + ; } insertIndex = pos ; } } I _ CmsXmlContentValue newValue ; if ( contentDefinition . getChoiceMaxOccurs ( ) > _NUM ) { for a choice we do a full XML validation try { append the new element at the calculated position newValue = addValue ( cms , parentElement , type , locale , insertIndex ) ; validate the XML structure to see if the index position was valid CmsXmlUtils . validateXmlStructure ( m _ document , m _ encoding , new CmsXmlEntityResolver ( cms ) ) ; } catch ( Exception e ) { throw new CmsRuntimeException ( Messages . get ( ) . container ( Messages . ERR _ XMLCONTENT _ ADD _ ELEM _ INVALID _ IDX _ CHOICE _ _NUM , new Integer ( insertIndex ) , elementName , parentElement . getUniquePath ( ) ) ) ; } } else { just append the new element at the calculated position newValue = addValue ( cms , parentElement , type , locale , insertIndex ) ; } re - initialize this XML content initDocument ( m _ document , m _ encoding , m _ contentDefinition ) ; just returning _STR isn ' t enough since this instance is NOT stored in the bookmarks return getBookmark ( getBookmarkName ( newValue . getPath ( ) , locale ) ) ; } 
316	private void setUpSimpleLayout ( ) { activityRule . launchActivity ( new Intent ( ) . putExtra ( LayoutTestActivity . EXTRA _ LAYOUT _ RESOURCE _ ID , R . layout . swipe _ dismiss _ layout _ testcase _ _NUM ) ) ; setDismissCallback ( ) ; } 
317	void notifyPinnedStackAnimationStarted ( ) { mHandler . removeMessages ( NOTIFY _ PINNED _ STACK _ ANIMATION _ STARTED _ LISTENERS _ MSG ) ; final Message msg = mHandler . obtainMessage ( NOTIFY _ PINNED _ STACK _ ANIMATION _ STARTED _ LISTENERS _ MSG ) ; forAllLocalListeners ( mNotifyPinnedStackAnimationStarted , msg ) ; msg . sendToTarget ( ) ; } 
318	public IComplexNDArray subiRowVector ( INDArray rowVector ) { for ( int i = _NUM ; i < rows ( ) ; i + + ) { getRow ( i ) . subi ( rowVector . getScalar ( i ) ) ; } return this ; } 
319	public void drawItem ( Graphics _NUM D g _NUM , XYItemRendererState state , Rectangle _NUM D dataArea , PlotRenderingInfo info , XYPlot plot , ValueAxis domainAxis , ValueAxis rangeAxis , XYDataset dataset , int series , int item , CrosshairState crosshairState , int pass ) { if ( pass = = _NUM ) { drawItemPass _NUM ( g _NUM , dataArea , info , plot , domainAxis , rangeAxis , dataset , series , item , crosshairState ) ; } else if ( pass = = _NUM ) { drawItemPass _NUM ( g _NUM , dataArea , info , plot , domainAxis , rangeAxis , dataset , series , item , crosshairState ) ; } } 
320	public Builder clearTransactionInput ( ) { if ( transactionInputBuilder _ = = null ) { transactionInput _ = java . util . Collections . emptyList ( ) ; bitField _NUM _ = ( bitField _NUM _ & ~ _NUM x _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM ) ; onChanged ( ) ; } else { transactionInputBuilder _ . clear ( ) ; } return this ; } 
321	public XSLFNotes getNotesSlide ( XSLFSlide slide ) { XSLFNotes notesSlide = slide . getNotes ( ) ; if ( notesSlide = = null ) { notesSlide = createNotesSlide ( slide ) ; } return notesSlide ; } 
322	public static void checkDir ( File dir ) throws DiskErrorException { if ( ! mkdirsWithExistsCheck ( dir ) ) { throw new DiskErrorException ( _STR + dir . toString ( ) ) ; } checkDirAccess ( dir ) ; } 
323	private void processLoadQueueItem ( SystemServicesProxy ssp ) { Load the next item from the queue final Task t = mLoadQueue . nextTask ( ) ; if ( t ! = null ) { Drawable cachedIcon = mIconCache . get ( t . key ) ; Load the icon if it is stale or we haven ' t cached one yet if ( cachedIcon = = null ) { cachedIcon = ssp . getBadgedTaskDescriptionIcon ( t . taskDescription , t . key . userId , mContext . getResources ( ) ) ; if ( cachedIcon = = null ) { ActivityInfo info = ssp . getActivityInfo ( t . key . getComponent ( ) , t . key . userId ) ; if ( info ! = null ) { if ( DEBUG ) Log . d ( TAG , _STR + t . key ) ; final ThumbnailData thumbnailData = ssp . getTaskThumbnail ( t . key . id , true ) ; if ( ! mCancelled ) { Notify that the task data has changed final Drawable finalIcon = cachedIcon ; mMainThreadHandler . post ( ( ) - > t . notifyTaskDataLoaded ( thumbnailData , finalIcon ) ) ; } } } 
324	public static String replace ( final Object source , final Properties valueProperties ) { if ( valueProperties = = null ) { return source . toString ( ) ; } final Map < String , String > valueMap = new HashMap < > ( ) ; final Enumeration < ? > propNames = valueProperties . propertyNames ( ) ; while ( propNames . hasMoreElements ( ) ) { final String propName = ( String ) propNames . nextElement ( ) ; final String propValue = valueProperties . getProperty ( propName ) ; valueMap . put ( propName , propValue ) ; } return StrSubstitutor . replace ( source , valueMap ) ; } 
325	public void setInverse ( boolean inverse ) { this . inverse = inverse ; initialize ( ) ; if ( inverse ) { invertPalette ( ) ; } return ; } 
326	public void setData ( final String path , byte [ ] data , int version , StatCallback cb , Object ctx ) { final String clientPath = path ; PathUtils . validatePath ( clientPath ) ; final String serverPath = prependChroot ( clientPath ) ; RequestHeader h = new RequestHeader ( ) ; h . setType ( ZooDefs . OpCode . setData ) ; SetDataRequest request = new SetDataRequest ( ) ; request . setPath ( serverPath ) ; request . setData ( data ) ; request . setVersion ( version ) ; SetDataResponse response = new SetDataResponse ( ) ; cnxn . queuePacket ( h , new ReplyHeader ( ) , request , response , cb , clientPath , serverPath , ctx , null ) ; } 
327	public void finishLine ( ) throws IOException { last token already finished line ; reset silently if ( mLineFinished ) { mLineFinished = false ; return ; } int i = _NUM ; do { scan forward for line boundary and consume for ( ; i < mTail ; i + + ) { if ( mBuffer [ i ] = = ' \ n ' ) { consumeBuf ( i + _NUM ) ; return ; } } } while ( fillBuf ( ) > _NUM ) ; throw new ProtocolException ( _STR ) ; } 
328	public void clearActive ( ) { mActiveIndexes . clear ( ) ; insertPending ( ) ; } 
329	public void putAll ( Map < ? extends Byte , ? extends Byte > map ) { Iterator < ? extends Entry < ? extends Byte , ? extends Byte > > it = map . entrySet ( ) . iterator ( ) ; for ( int i = map . size ( ) ; i - - > _NUM ; ) { Entry < ? extends Byte , ? extends Byte > e = it . next ( ) ; this . put ( e . getKey ( ) , e . getValue ( ) ) ; } } 
330	public static String addCarets ( String sql , int line , int col , int endLine , int endCol ) { String sqlWithCarets ; int cut = lineColToIndex ( sql , line , col ) ; sqlWithCarets = sql . substring ( _NUM , cut ) + _STR ; } } return sqlWithCarets ; } 
331	private boolean onTouchSelectMode ( MotionEvent event ) { ListIterator < CDrawable > li = mDrawableList . listIterator ( mDrawableList . size ( ) ) ; switch ( event . getAction ( ) ) { case MotionEvent . ACTION _ DOWN : hovering = null ; pressStartTime = SystemClock . uptimeMillis ( ) ; pressedX = event . getX ( ) ; pressedY = event . getY ( ) ; while ( li . hasPrevious ( ) ) { CDrawable d = li . previous ( ) ; if ( d instanceof CTransform ) { continue ; } Rect rect = d . computeBounds ( ) ; if ( rect . contains ( ( int ) pressedX , ( int ) pressedY ) ) { hovering = d ; break ; } } if ( hovering ! = null ) { getParent ( ) . requestDisallowInterceptTouchEvent ( true ) ; } return true ; case MotionEvent . ACTION _ MOVE : if ( hovering = = null ) { Nothing is being dragged . break ; } updateHoveringPosition ( event ) ; invalidate ( ) ; return true ; case MotionEvent . ACTION _ UP : if ( hovering ! = null ) { getParent ( ) . requestDisallowInterceptTouchEvent ( false ) ; } long pressDuration = SystemClock . uptimeMillis ( ) - pressStartTime ; double distance = Math . sqrt ( Math . pow ( ( event . getX ( ) - pressedX ) , _NUM ) + Math . pow ( ( event . getY ( ) - pressedY ) , _NUM ) ) ; if ( pressDuration < MAX _ CLICK _ DURATION & & distance < MAX _ CLICK _ DISTANCE ) { It was a click not a drag . if ( hovering = = null & & deleteIconPosition . contains ( event . getX ( ) , event . getY ( ) ) ) { deleteSelection ( ) ; return true ; } selected = hovering ; if ( hovering ! = null ) { hovering . removeTransform ( hoveringTranslation ) ; mDrawableList . remove ( hoveringTranslation ) ; } } else if ( distance > MAX _ CLICK _ DISTANCE ) { It was a drag . Move the object there . if ( hovering ! = null ) { updateHoveringPosition ( event ) ; } } invalidate ( ) ; hovering = null ; hoveringTranslation = null ; return true ; case MotionEvent . ACTION _ CANCEL : if ( hovering ! = null ) { getParent ( ) . requestDisallowInterceptTouchEvent ( false ) ; hovering . removeTransform ( hoveringTranslation ) ; mDrawableList . remove ( hoveringTranslation ) ; hovering = null ; hoveringTranslation = null ; } return true ; } return false ; } 
332	protected Object doEvaluate ( Exchange exchange , boolean closeStream ) { InputStream in = null ; try { in = exchange . getIn ( ) . getMandatoryBody ( InputStream . class ) ; we may read from a file , and want to support custom charset defined on the exchange String charset = IOHelper . getCharsetName ( exchange ) ; return createIterator ( exchange , in , charset ) ; } catch ( InvalidPayloadException e ) { exchange . setException ( e ) ; must close input stream IOHelper . close ( in ) ; return null ; } finally { if ( closeStream ) { IOHelper . close ( in ) ; } } } 
333	public void endDocument ( ) throws SAXException { lazyEndHead ( useFrameset ) ; if ( useFrameset ) { super . endElement ( XHTML , _STR ) ; super . endDocument ( ) ; } 
334	synchronized QueueBufferFuture < R , Result > addIfAllowed ( R request , QueueBufferCallback < R , Result > callback ) { if ( isOkToAdd ( request ) ) { requests . add ( request ) ; QueueBufferFuture < R , Result > theFuture = new QueueBufferFuture < R , Result > ( callback ) ; futures . add ( theFuture ) ; onRequestAdded ( request ) ; return theFuture ; } else return null ; } 
335	protected AegisType getElementType ( QName name , BeanTypeInfo beanTypeInfo , MessageReader reader , Context context ) { nested elements use unqualified names name = qualifyName ( name ) ; AegisType type = super . getElementType ( name , beanTypeInfo , reader , context ) ; if ( type ! = null ) { type = new SoapRefType ( type ) ; } return type ; } 
336	public void print ( Object x ) { printHeader ( ) ; for ( int i = _NUM ; i < size ( ) ; i + + ) ( ( PrintStream ) m _ Streams . get ( i ) ) . print ( x ) ; flush ( ) ; } 
337	boolean tryCaptureViewForDrag ( View toCapture , int pointerId ) { if ( toCapture = = mCapturedView & & mActivePointerId = = pointerId ) { Already done ! return true ; } if ( toCapture ! = null & & mCallback . tryCaptureView ( toCapture , pointerId ) ) { mActivePointerId = pointerId ; captureChildView ( toCapture , pointerId ) ; return true ; } return false ; } 
338	public CreateTableRequest generateCreateTableRequest ( Class < ? > clazz ) { final ItemConverter converter = getConverter ( config ) ; return schemaParser . parseTablePojoToCreateTableRequest ( clazz , config , reflector , converter ) ; } 
339	protected void configureFormat ( F format ) { if ( lineSeparator ! = null ) { format . setLineSeparator ( lineSeparator ) ; } if ( normalizedLineSeparator ! = null ) { format . setNormalizedNewline ( normalizedLineSeparator ) ; } if ( comment ! = null ) { format . setComment ( comment ) ; } } 
340	public MemStoreSize prepare ( ) { passing the current sequence number of the wal - to allow bookkeeping in the memstore this . snapshot = memstore . snapshot ( ) ; this . cacheFlushCount = snapshot . getCellsCount ( ) ; this . cacheFlushSize = snapshot . getDataSize ( ) ; committedFiles = new ArrayList < > ( _NUM ) ; return new MemStoreSize ( snapshot . getMemStoreSize ( ) ) ; } 
341	public static String xorHashPassword ( String password ) { int hashedPassword = createXorVerifier _NUM ( password ) ; return String . format ( Locale . ROOT , _STR , hashedPassword ) ; } 
342	public JSONObject put ( String key , Object value ) throws JSONException { if ( key = = null ) { throw new JSONException ( _STR ) ; } if ( value ! = null ) { testValidity ( value ) ; this . m _ map . put ( key , value ) ; } else { remove ( key ) ; } return this ; } 
343	public String toUnicodeString ( ) { if ( encoding ! = null & & encoding . length ( ) ! = _NUM ) return value ; getBytes ( ) ; if ( bytes . length > = _NUM & & bytes [ _NUM ] = = ( byte ) _NUM _NUM _NUM & & bytes [ _NUM ] = = ( byte ) _NUM _NUM _NUM ) return PdfEncodings . convertToString ( bytes , PdfObject . TEXT _ UNICODE ) ; else return PdfEncodings . convertToString ( bytes , PdfObject . TEXT _ PDFDOCENCODING ) ; } 
344	public static Map generateMap ( InputStream inputStream ) throws IOException { logger . trace ( _STR , map ) ; return map ; } 
345	public boolean beginFakeDrag ( ) { if ( mIsBeingDragged ) { return false ; } mFakeDragging = true ; setScrollState ( SCROLL _ STATE _ DRAGGING ) ; mInitialMotionX = mLastMotionX = _NUM ; if ( mVelocityTracker = = null ) { mVelocityTracker = VelocityTracker . obtain ( ) ; } else { mVelocityTracker . clear ( ) ; } final long time = SystemClock . uptimeMillis ( ) ; final MotionEvent ev = MotionEvent . obtain ( time , time , MotionEvent . ACTION _ DOWN , _NUM , _NUM , _NUM ) ; mVelocityTracker . addMovement ( ev ) ; ev . recycle ( ) ; mFakeDragBeginTime = time ; return true ; } 
346	public static String getSqlQueryBadCoveredColVal ( Connection conn , SourceTargetColumnNames columnNames , long scrutinyTimeMillis ) throws SQLException { String paramQuery = getHasTargetRowQuery ( conn , columnNames , scrutinyTimeMillis ) ; return paramQuery . replaceFirst ( _STR ) ; } 
347	public InitializeBuilder initialize ( final Context context , final AWSStartupHandler awsStartupHandler ) { this . awsConfiguration = new AWSConfiguration ( context . getApplicationContext ( ) ) ; this . signInProviderConfig = null ; this . startupAuthResultHandler = new StartupAuthResultHandler ( ) { @ Override public void onComplete ( final StartupAuthResult startupAuthResult ) { Log . i ( LOG _ TAG , _STR ) ; } awsStartupHandler . onComplete ( new AWSStartupResult ( IdentityManager . getDefaultIdentityManager ( ) ) ) ; } } ; this . awsStartupHandler = awsStartupHandler ; return new InitializeBuilder ( context ) ; } 
348	public void setBookmarkIcon ( Icon icon ) { removeBookmarkTrackingIcons ( ) ; bookmarkIcon = icon ; repaint ( ) ; } 
349	public String consumeAnyOf ( int . . . typeOptions ) throws IllegalStateException { if ( completed ) { throw new ParsingException ( tokens . get ( tokens . size ( ) - _NUM ) . position ( ) , _STR + fragment ; throw new ParsingException ( pos , msg ) ; } 
350	public static Array create ( Element arrayE ) throws Exception { if ( ! isArray ( arrayE ) ) { throw new Exception ( _STR ) ; } if ( isSparseArray ( arrayE ) ) { return new SparseArray ( arrayE ) ; } return new Array ( arrayE ) ; } 
351	public static int getMultiFormRowCount ( Map < String , ? > requestMap ) { The number of multi form rows is computed selecting the maximum index int rowCount = _NUM ; String maxRowIndex = _STR + maxRowIndex , module ) ; } } return rowCount ; } 
352	protected static synchronized void resetAllCounters ( ) { for ( AtomicInteger counter : nodeCounters . values ( ) ) { counter . set ( _NUM ) ; } } 
353	public void assertContains ( Description description , List < ? > actual , Object value , Index index ) { assertNotNull ( description , actual ) ; checkNotEmpty ( description , actual ) ; checkIndexValueIsValid ( index , actual . size ( ) - _NUM ) ; Object actualElement = actual . get ( index . value ) ; if ( ! areEqual ( actualElement , value ) ) { throw failures . failure ( description , shouldContainAtIndex ( actual , value , index , actual . get ( index . value ) ) ) ; } } 
354	public boolean containsValue ( double val ) { for ( NSObject o : dict . values ( ) ) { if ( o . getClass ( ) . equals ( NSNumber . class ) ) { NSNumber num = ( NSNumber ) o ; if ( num . isReal ( ) & & num . doubleValue ( ) = = val ) return true ; } } return false ; } 
355	public ViewPropertyAnimator scaleYBy ( float value ) { animatePropertyBy ( SCALE _ Y , value ) ; return this ; } 
356	public void maybeLogPayload ( long duration , Object . . . objects ) { if ( duration > timerLogThreshold | | logger . isInfoEnabled ( ) ) { String message ; if ( objects . length > _NUM ) { message = formatMessage ( duration , MapUtils . map ( objects ) ) ; } else { message = formatMessage ( duration , objects ) ; } logger . info ( message ) ; } } 
357	public static PropertyValuesHolder ofObject ( String propertyName , TypeEvaluator evaluator , Object . . . values ) { PropertyValuesHolder pvh = new PropertyValuesHolder ( propertyName ) ; pvh . setObjectValues ( values ) ; pvh . setEvaluator ( evaluator ) ; return pvh ; } 
358	public static Object evaluate ( String language , String script , Class < ? > scriptClass , Map < String , Object > context ) throws Exception { Assert . notNull ( _STR + e . toString ( ) ; Debug . logWarning ( e , errMsg , module ) ; throw new IllegalArgumentException ( errMsg ) ; } } 
359	public static POITextExtractor createExtractor ( DirectoryNode poifsDir ) throws IOException { out from for ( String workbookName : WORKBOOK _ DIR _ ENTRY _ NAMES ) { if ( poifsDir . hasEntry ( workbookName ) ) { if ( getPreferEventExtractor ( ) ) { return new EventBasedExcelExtractor ( poifsDir ) ; } return new ExcelExtractor ( poifsDir ) ; } } if ( poifsDir . hasEntry ( OLD _ WORKBOOK _ DIR _ ENTRY _ NAME ) ) { throw new OldExcelFormatException ( _STR ) ; } 
360	public void testVersionOfDynamicFilename ( ) throws Exception { final int SERVER _ COUNT = _NUM ; final int oldServerCount = _NUM ; final int lagOffServerId = _NUM ; final int [ ] clientPorts = new int [ SERVER _ COUNT ] ; StringBuilder sb = new StringBuilder ( ) ; String server ; StringBuilder oldSb = new StringBuilder ( ) ; ArrayList < String > allServers = new ArrayList < String > ( ) ; for ( int i = _NUM ; i < SERVER _ COUNT ; i + + ) { clientPorts [ i ] = PortAssignment . unique ( ) ; server = _STR ) ) ; for ( int i = _NUM ; i < SERVER _ COUNT ; i + + ) { mt [ i ] . shutdown ( ) ; } } 
361	public void setJustificationMode ( @ Layout . JustificationMode int justificationMode ) { mJustificationMode = justificationMode ; if ( mLayout ! = null ) { nullLayouts ( ) ; requestLayout ( ) ; invalidate ( ) ; } } 
362	private void sendRequestLineWithPath ( Socket server , String requestType , URI absoluteUri , String httpVersion ) throws IOException { String absolutePath = getAbsolutePathFromAbsoluteURI ( absoluteUri ) ; String outgoingRequestLine = String . format ( _STR , requestType , absolutePath , httpVersion ) ; sendLine ( server , outgoingRequestLine ) ; } 
363	public BluetoothLeAdvertiser getBluetoothLeAdvertiser ( ) { if ( ! getLeAccess ( ) ) { return null ; } if ( ! isMultipleAdvertisementSupported ( ) ) { Log . e ( TAG , _STR ) ; return null ; } synchronized ( mLock ) { if ( sBluetoothLeAdvertiser = = null ) { sBluetoothLeAdvertiser = new BluetoothLeAdvertiser ( mManagerService ) ; } } return sBluetoothLeAdvertiser ; } 
364	public void testAuthorizedLogUserAllowWhitelistedTopologyUser ( ) { Map < String , Object > stormConf = Utils . readStormConfig ( ) ; Map < String , Object > conf = new HashMap < > ( stormConf ) ; ResourceAuthorizer authorizer = spy ( new ResourceAuthorizer ( conf ) ) ; doReturn ( new ResourceAuthorizer . LogUserGroupWhitelist ( Collections . singleton ( _STR ) ) ; verifyStubMethodsAreCalledProperly ( authorizer ) ; } 
365	public void testLockupAroundBadAssignSync ( ) throws IOException { final AtomicLong rolls = new AtomicLong ( _NUM ) ; Dodgy WAL . Will throw exceptions when flags set . class DodgyFSLog extends FSHLog { volatile boolean throwSyncException = false ; volatile boolean throwAppendException = false ; public DodgyFSLog ( FileSystem fs , Path root , String logDir , Configuration conf ) throws IOException { super ( fs , root , logDir , conf ) ; } @ Override public byte [ ] [ ] rollWriter ( boolean force ) throws FailedLogCloseException , IOException { byte [ ] [ ] regions = super . rollWriter ( force ) ; rolls . getAndIncrement ( ) ; return regions ; } @ Override protected Writer createWriterInstance ( Path path ) throws IOException { final Writer w = super . createWriterInstance ( path ) ; return new Writer ( ) { @ Override public void close ( ) throws IOException { w . close ( ) ; } @ Override public void sync ( boolean forceSync ) throws IOException { if ( throwSyncException ) { throw new IOException ( _STR , threwOnSync ) ; } } 
366	public int write ( ByteBuffer src ) throws IOException { return writeToShard ( ALL _ SHARDS , src ) ; } 
367	public void setDigestMethod ( List < COSName > digestMethod ) { integrity check for ( COSName cosName : digestMethod ) { if ( ! ( cosName . equals ( COSName . DIGEST _ SHA _NUM ) | | cosName . equals ( COSName . DIGEST _ SHA _NUM _NUM _NUM ) | | cosName . equals ( COSName . DIGEST _ SHA _NUM _NUM _NUM ) | | cosName . equals ( COSName . DIGEST _ SHA _NUM _NUM _NUM ) | | cosName . equals ( COSName . DIGEST _ RIPEMD _NUM _NUM _NUM ) ) ) { throw new IllegalArgumentException ( _STR ) ; } } dictionary . setItem ( COSName . DIGEST _ METHOD , COSArrayList . converterToCOSArray ( digestMethod ) ) ; } 
368	public void setText ( String text ) { clearText ( ) ; addNewTextParagraph ( ) . addNewTextRun ( ) . setText ( text ) ; } 
369	public void setMaxNumberOfDataFormats ( int num ) { if ( num < getNumDataFormats ( ) ) { if ( num < _NUM ) { throw new IllegalArgumentException ( _STR ) ; } } MAXIMUM _ NUMBER _ OF _ DATA _ FORMATS = num ; } 
370	public static XmlShort parse ( java . io . InputStream is ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( XmlShort ) XmlBeans . getContextTypeLoader ( ) . parse ( is , type , null ) ; } 
371	public void add ( LruCachedBlock cb ) { if ( heapSize < maxSize ) { queue . add ( cb ) ; heapSize + = cb . heapSize ( ) ; } else { LruCachedBlock head = queue . peek ( ) ; if ( cb . compareTo ( head ) > _NUM ) { heapSize + = cb . heapSize ( ) ; heapSize - = head . heapSize ( ) ; if ( heapSize > maxSize ) { queue . poll ( ) ; } else { heapSize + = head . heapSize ( ) ; } queue . add ( cb ) ; } } } 
372	public void setLegendLabelToolTipGenerator ( PieSectionLabelGenerator generator ) { this . legendLabelToolTipGenerator = generator ; fireChangeEvent ( ) ; } 
373	public boolean contains ( char val ) { return index ( val ) > = _NUM ; } 
374	void timeoutCallbacks ( ) { Store the current time . long currentTime = System . currentTimeMillis ( ) ; Iterate through future callbacks and time out callbacks that have been alive longer than the current timeout according to the message type . Iterator < Map . Entry < Long , Callback > > iterator = futures . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Callback callback = iterator . next ( ) . getValue ( ) ; try { RequestMonitor requestMonitor = requestMonitors . get ( callback . type , RequestMonitor : : new ) ; long elapsedTime = currentTime - callback . time ; if ( elapsedTime > MAX _ TIMEOUT _ MILLIS | | ( elapsedTime > MIN _ TIMEOUT _ MILLIS & & requestMonitor . isTimedOut ( elapsedTime ) ) ) { iterator . remove ( ) ; requestMonitor . addReplyTime ( elapsedTime ) ; callback . completeExceptionally ( new TimeoutException ( _STR ) ) ; } } catch ( ExecutionException e ) { throw new AssertionError ( ) ; } } } 
375	public void updateLocked ( List < DisplayDevice > devices ) { Nothing to update if already invalid . if ( mPrimaryDisplayDevice = = null ) { return ; } Check whether logical display has become invalid . if ( ! devices . contains ( mPrimaryDisplayDevice ) ) { mPrimaryDisplayDevice = null ; return ; } Bootstrap the logical display using its associated primary physical display . We might use more elaborate configurations later . It ' s possible that the configuration of several physical displays might be used to determine the logical display that they are sharing . ( eg . Adjust size for pixel - perfect mirroring over HDMI . ) DisplayDeviceInfo deviceInfo = mPrimaryDisplayDevice . getDisplayDeviceInfoLocked ( ) ; if ( ! Objects . equal ( mPrimaryDisplayDeviceInfo , deviceInfo ) ) { mBaseDisplayInfo . layerStack = mLayerStack ; mBaseDisplayInfo . flags = _NUM ; if ( ( deviceInfo . flags & DisplayDeviceInfo . FLAG _ SUPPORTS _ PROTECTED _ BUFFERS ) ! = _NUM ) { mBaseDisplayInfo . flags | = Display . FLAG _ SUPPORTS _ PROTECTED _ BUFFERS ; } if ( ( deviceInfo . flags & DisplayDeviceInfo . FLAG _ SECURE ) ! = _NUM ) { mBaseDisplayInfo . flags | = Display . FLAG _ SECURE ; } if ( ( deviceInfo . flags & DisplayDeviceInfo . FLAG _ PRIVATE ) ! = _NUM ) { mBaseDisplayInfo . flags | = Display . FLAG _ PRIVATE ; For private displays by default content is destroyed on removal . mBaseDisplayInfo . removeMode = Display . REMOVE _ MODE _ DESTROY _ CONTENT ; } if ( ( deviceInfo . flags & DisplayDeviceInfo . FLAG _ DESTROY _ CONTENT _ ON _ REMOVAL ) ! = _NUM ) { mBaseDisplayInfo . removeMode = Display . REMOVE _ MODE _ DESTROY _ CONTENT ; } if ( ( deviceInfo . flags & DisplayDeviceInfo . FLAG _ PRESENTATION ) ! = _NUM ) { mBaseDisplayInfo . flags | = Display . FLAG _ PRESENTATION ; } if ( ( deviceInfo . flags & DisplayDeviceInfo . FLAG _ ROUND ) ! = _NUM ) { mBaseDisplayInfo . flags | = Display . FLAG _ ROUND ; } if ( ( deviceInfo . flags & DisplayDeviceInfo . FLAG _ CAN _ SHOW _ WITH _ INSECURE _ KEYGUARD ) ! = _NUM ) { mBaseDisplayInfo . flags | = Display . FLAG _ CAN _ SHOW _ WITH _ INSECURE _ KEYGUARD ; } mBaseDisplayInfo . type = deviceInfo . type ; mBaseDisplayInfo . address = deviceInfo . address ; mBaseDisplayInfo . name = deviceInfo . name ; mBaseDisplayInfo . uniqueId = deviceInfo . uniqueId ; mBaseDisplayInfo . appWidth = deviceInfo . width ; mBaseDisplayInfo . appHeight = deviceInfo . height ; mBaseDisplayInfo . logicalWidth = deviceInfo . width ; mBaseDisplayInfo . logicalHeight = deviceInfo . height ; mBaseDisplayInfo . rotation = Surface . ROTATION _ _NUM ; mBaseDisplayInfo . modeId = deviceInfo . modeId ; mBaseDisplayInfo . defaultModeId = deviceInfo . defaultModeId ; mBaseDisplayInfo . supportedModes = Arrays . copyOf ( deviceInfo . supportedModes , deviceInfo . supportedModes . length ) ; mBaseDisplayInfo . colorMode = deviceInfo . colorMode ; mBaseDisplayInfo . supportedColorModes = Arrays . copyOf ( deviceInfo . supportedColorModes , deviceInfo . supportedColorModes . length ) ; mBaseDisplayInfo . hdrCapabilities = deviceInfo . hdrCapabilities ; mBaseDisplayInfo . logicalDensityDpi = deviceInfo . densityDpi ; mBaseDisplayInfo . physicalXDpi = deviceInfo . xDpi ; mBaseDisplayInfo . physicalYDpi = deviceInfo . yDpi ; mBaseDisplayInfo . appVsyncOffsetNanos = deviceInfo . appVsyncOffsetNanos ; mBaseDisplayInfo . presentationDeadlineNanos = deviceInfo . presentationDeadlineNanos ; mBaseDisplayInfo . state = deviceInfo . state ; mBaseDisplayInfo . smallestNominalAppWidth = deviceInfo . width ; mBaseDisplayInfo . smallestNominalAppHeight = deviceInfo . height ; mBaseDisplayInfo . largestNominalAppWidth = deviceInfo . width ; mBaseDisplayInfo . largestNominalAppHeight = deviceInfo . height ; mBaseDisplayInfo . ownerUid = deviceInfo . ownerUid ; mBaseDisplayInfo . ownerPackageName = deviceInfo . ownerPackageName ; mPrimaryDisplayDeviceInfo = deviceInfo ; mInfo = null ; } } 
376	public INDArray generateRandomGivenZ ( INDArray latentSpaceValues ) { INDArray pxzDistributionPreOut = decodeGivenLatentSpaceValues ( latentSpaceValues ) ; return reconstructionDistribution . generateRandom ( pxzDistributionPreOut ) ; } 
377	synchronized void addTransferRanges ( String keyspace , Collection < Range < Token > > ranges , Collection < String > columnFamilies , boolean flushTables ) { failIfFinished ( ) ; Collection < ColumnFamilyStore > stores = getColumnFamilyStores ( keyspace , columnFamilies ) ; if ( flushTables ) flushSSTables ( stores ) ; List < Range < Token > > normalizedRanges = Range . normalize ( ranges ) ; List < OutgoingStream > streams = getOutgoingStreamsForRanges ( normalizedRanges , stores , pendingRepair , previewKind ) ; addTransferStreams ( streams ) ; Set < Range < Token > > toBeUpdated = transferredRangesPerKeyspace . get ( keyspace ) ; if ( toBeUpdated = = null ) { toBeUpdated = new HashSet < > ( ) ; } toBeUpdated . addAll ( ranges ) ; transferredRangesPerKeyspace . put ( keyspace , toBeUpdated ) ; } 
378	public synchronized void password ( final String password ) { EnumMap < Code , String > codes = passwords . get ( Algorithm . DIGEST ) ; codes . put ( Code . HASH , digest ( name , password ) ) ; codes = passwords . get ( Algorithm . SALTED _ SHA _NUM _NUM _NUM ) ; final String salt = Long . toString ( System . nanoTime ( ) ) ; codes . put ( Code . SALT , salt ) ; codes . put ( Code . HASH , sha _NUM _NUM _NUM ( salt + password ) ) ; } 
379	public void actionUndelete ( ) throws JspException { save initialized instance of this class in request attribute for included sub - elements getJsp ( ) . getRequest ( ) . setAttribute ( SESSION _ WORKPLACE _ CLASS , this ) ; try { if ( performDialogOperation ( ) ) { if no exception is caused and _STR screen getJsp ( ) . include ( FILE _ DIALOG _ SCREEN _ WAIT ) ; } } catch ( Throwable e ) { error during deletion , show error dialog includeErrorpage ( this , e ) ; } } 
380	public void setImsRegistrationState ( boolean registered ) { try { ITelephony telephony = getITelephony ( ) ; if ( telephony ! = null ) telephony . setImsRegistrationState ( registered ) ; } catch ( RemoteException e ) { } } 
381	void add ( BigIntPolynomial b , BigInteger modulus ) { add ( b ) ; mod ( modulus ) ; } 
382	public void moveColumnToAnotherTable ( String sourceTableName , DBColumnInfo sourceColumn , String sourceIDFieldName , String targetTableName , DBColumnInfo targetColumn , String targetIDFieldName , Object initialValue ) throws SQLException { if ( tableHasColumn ( sourceTableName , sourceIDFieldName ) & & tableHasColumn ( sourceTableName , sourceColumn . getName ( ) ) & & tableHasColumn ( targetTableName , targetIDFieldName ) ) { final String moveSQL = dbmsHelper . getCopyColumnToAnotherTableStatement ( sourceTableName , sourceColumn . getName ( ) , sourceIDFieldName , targetTableName , targetColumn . getName ( ) , targetIDFieldName ) ; final boolean isTargetColumnNullable = targetColumn . isNullable ( ) ; setting column nullable by default to move rows with null targetColumn . setNullable ( true ) ; addColumn ( targetTableName , targetColumn ) ; executeUpdate ( moveSQL , false ) ; if ( initialValue ! = null ) { String updateSQL = dbmsHelper . getColumnUpdateStatementWhereColumnIsNull ( convertObjectName ( targetTableName ) , convertObjectName ( targetColumn . getName ( ) ) , convertObjectName ( targetColumn . getName ( ) ) ) ; executePreparedUpdate ( updateSQL , initialValue ) ; } if ( ! isTargetColumnNullable ) { setColumnNullable ( targetTableName , targetColumn . getName ( ) , false ) ; } dropColumn ( sourceTableName , sourceColumn . getName ( ) ) ; } } 
383	private List < String > getDistinctCalls ( Implementor implementor ) { final String relAlias = implementor . getPigRelationAlias ( this ) ; final List < String > result = new ArrayList < > ( ) ; for ( AggregateCall aggCall : aggCalls ) { if ( aggCall . isDistinct ( ) ) { for ( int fieldIndex : aggCall . getArgList ( ) ) { String fieldName = getInputFieldName ( fieldIndex ) ; result . add ( _STR ) ; } } } return result ; } 
384	public boolean execute ( CommandSender sender , String commandLabel , String [ ] args ) { boolean success = false ; if ( ! owningPlugin . isEnabled ( ) ) { return false ; } if ( ! testPermission ( sender ) ) { return true ; } try { success = executor . onCommand ( sender , this , commandLabel , args ) ; } catch ( Throwable ex ) { throw new CommandException ( _STR ) ) { sender . sendMessage ( line ) ; } } return success ; } 
385	private static void checkXAttrSize ( FSDirectory fsd , XAttr xAttr ) { if ( fsd . getXattrMaxSize ( ) = = _NUM ) { return ; } int size = xAttr . getName ( ) . getBytes ( Charsets . UTF _ _NUM ) . length ; if ( xAttr . getValue ( ) ! = null ) { size + = xAttr . getValue ( ) . length ; } if ( size > fsd . getXattrMaxSize ( ) ) { throw new HadoopIllegalArgumentException ( _STR + size ) ; } } 
386	private static PCollection . IsBounded inferBoundedness ( TypeDescriptor < ? extends DoFn > fnT , DoFnSignature . ProcessElementMethod processElement , ErrorReporter errors ) { PCollection . IsBounded isBounded = null ; for ( TypeDescriptor < ? > supertype : fnT . getTypes ( ) ) { if ( supertype . getRawType ( ) . isAnnotationPresent ( DoFn . BoundedPerElement . class ) | | supertype . getRawType ( ) . isAnnotationPresent ( DoFn . UnboundedPerElement . class ) ) { errors . checkArgument ( isBounded = = null , _STR ) ; isBounded = PCollection . IsBounded . BOUNDED ; } return isBounded ; } 
387	public void quit ( ) { Handler handler = mGLHandlerThread . getHandler ( ) ; handler . sendMessageAtFrontOfQueue ( handler . obtainMessage ( MSG _ CLEANUP ) ) ; mGLHandlerThread . quitSafely ( ) ; try { mGLHandlerThread . join ( ) ; } catch ( InterruptedException e ) { Log . e ( TAG , String . format ( _STR , mGLHandlerThread . getName ( ) , mGLHandlerThread . getId ( ) ) ) ; } } 
388	public CancelReservedInstancesListingResult withReservedInstancesListings ( ReservedInstancesListing . . . reservedInstancesListings ) { if ( getReservedInstancesListings ( ) = = null ) setReservedInstancesListings ( new java . util . ArrayList < ReservedInstancesListing > ( reservedInstancesListings . length ) ) ; for ( ReservedInstancesListing value : reservedInstancesListings ) { getReservedInstancesListings ( ) . add ( value ) ; } return this ; } 
389	public static YamlConfiguration loadConfiguration ( File file ) { Validate . notNull ( file , _STR + file , ex ) ; } return config ; } 
390	public void setPinned ( LockedInodePath inodePath , boolean pinned , long opTimeMs ) throws FileDoesNotExistException { Inode < ? > inode = inodePath . getInode ( ) ; inode . setPinned ( pinned ) ; inode . setLastModificationTimeMs ( opTimeMs ) ; if ( inode . isFile ( ) ) { InodeFile inodeFile = ( InodeFile ) inode ; if ( inodeFile . isPinned ( ) ) { mPinnedInodeFileIds . add ( inodeFile . getId ( ) ) ; } else { mPinnedInodeFileIds . remove ( inodeFile . getId ( ) ) ; } } else { assert inode instanceof InodeDirectory ; inode is a directory . Set the pinned state for all children . TempInodePathForDescendant tempInodePath = new TempInodePathForDescendant ( inodePath ) ; for ( Inode < ? > child : ( ( InodeDirectory ) inode ) . getChildren ( ) ) { try { child . lockWriteAndCheckParent ( inode ) ; } catch ( InvalidPathException e ) { Inode is no longer a child of the directory , continue . continue ; } try { tempInodePath . setDescendant ( child , getPath ( child ) ) ; setPinned ( tempInodePath , pinned , opTimeMs ) ; } finally { child . unlockWrite ( ) ; } } } } 
391	public String getDialogInitCall ( CmsObject cms , I _ CmsWidgetDialog widgetDialog ) { return getEditorWidget ( cms , widgetDialog ) . getDialogInitCall ( cms , widgetDialog ) ; } 
392	public void put ( TimelineDomain domain ) throws IOException { WriteBatch domainWriteBatch = null ; WriteBatch ownerWriteBatch = null ; try { domainWriteBatch = domaindb . createWriteBatch ( ) ; ownerWriteBatch = ownerdb . createWriteBatch ( ) ; if ( domain . getId ( ) = = null | | domain . getId ( ) . length ( ) = = _NUM ) { throw new IllegalArgumentException ( _STR ) ; } Write description byte [ ] domainEntryKey = createDomainEntryKey ( domain . getId ( ) , DESCRIPTION _ COLUMN ) ; byte [ ] ownerLookupEntryKey = createOwnerLookupKey ( domain . getOwner ( ) , domain . getId ( ) , DESCRIPTION _ COLUMN ) ; if ( domain . getDescription ( ) ! = null ) { domainWriteBatch . put ( domainEntryKey , domain . getDescription ( ) . getBytes ( UTF _ _NUM ) ) ; ownerWriteBatch . put ( ownerLookupEntryKey , domain . getDescription ( ) . getBytes ( UTF _ _NUM ) ) ; } else { domainWriteBatch . put ( domainEntryKey , EMPTY _ BYTES ) ; ownerWriteBatch . put ( ownerLookupEntryKey , EMPTY _ BYTES ) ; } Write owner domainEntryKey = createDomainEntryKey ( domain . getId ( ) , OWNER _ COLUMN ) ; ownerLookupEntryKey = createOwnerLookupKey ( domain . getOwner ( ) , domain . getId ( ) , OWNER _ COLUMN ) ; Null check for owner is done before domainWriteBatch . put ( domainEntryKey , domain . getOwner ( ) . getBytes ( UTF _ _NUM ) ) ; ownerWriteBatch . put ( ownerLookupEntryKey , domain . getOwner ( ) . getBytes ( UTF _ _NUM ) ) ; Write readers domainEntryKey = createDomainEntryKey ( domain . getId ( ) , READER _ COLUMN ) ; ownerLookupEntryKey = createOwnerLookupKey ( domain . getOwner ( ) , domain . getId ( ) , READER _ COLUMN ) ; if ( domain . getReaders ( ) ! = null & & domain . getReaders ( ) . length ( ) > _NUM ) { domainWriteBatch . put ( domainEntryKey , domain . getReaders ( ) . getBytes ( UTF _ _NUM ) ) ; ownerWriteBatch . put ( ownerLookupEntryKey , domain . getReaders ( ) . getBytes ( UTF _ _NUM ) ) ; } else { domainWriteBatch . put ( domainEntryKey , EMPTY _ BYTES ) ; ownerWriteBatch . put ( ownerLookupEntryKey , EMPTY _ BYTES ) ; } Write writers domainEntryKey = createDomainEntryKey ( domain . getId ( ) , WRITER _ COLUMN ) ; ownerLookupEntryKey = createOwnerLookupKey ( domain . getOwner ( ) , domain . getId ( ) , WRITER _ COLUMN ) ; if ( domain . getWriters ( ) ! = null & & domain . getWriters ( ) . length ( ) > _NUM ) { domainWriteBatch . put ( domainEntryKey , domain . getWriters ( ) . getBytes ( UTF _ _NUM ) ) ; ownerWriteBatch . put ( ownerLookupEntryKey , domain . getWriters ( ) . getBytes ( UTF _ _NUM ) ) ; } else { domainWriteBatch . put ( domainEntryKey , EMPTY _ BYTES ) ; ownerWriteBatch . put ( ownerLookupEntryKey , EMPTY _ BYTES ) ; } Write creation time and modification time We put both timestamps together because they are always retrieved together , and store them in the same way as we did for the entity ' s start time and insert time . domainEntryKey = createDomainEntryKey ( domain . getId ( ) , TIMESTAMP _ COLUMN ) ; ownerLookupEntryKey = createOwnerLookupKey ( domain . getOwner ( ) , domain . getId ( ) , TIMESTAMP _ COLUMN ) ; long currentTimestamp = System . currentTimeMillis ( ) ; byte [ ] timestamps = domaindb . get ( domainEntryKey ) ; if ( timestamps = = null ) { timestamps = new byte [ _NUM _NUM ] ; writeReverseOrderedLong ( currentTimestamp , timestamps , _NUM ) ; writeReverseOrderedLong ( currentTimestamp , timestamps , _NUM ) ; } else { writeReverseOrderedLong ( currentTimestamp , timestamps , _NUM ) ; } domainWriteBatch . put ( domainEntryKey , timestamps ) ; ownerWriteBatch . put ( ownerLookupEntryKey , timestamps ) ; domaindb . write ( domainWriteBatch ) ; ownerdb . write ( ownerWriteBatch ) ; } finally { IOUtils . cleanup ( LOG , domainWriteBatch ) ; IOUtils . cleanup ( LOG , ownerWriteBatch ) ; } } 
393	public double [ ] getQuantiles ( final int evenlySpaced ) { if ( isEmpty ( ) ) { return null ; } return getQuantiles ( getEvenlySpaced ( evenlySpaced ) ) ; } 
394	public void queryTypes ( ) { final Object [ ] [ ] types = XdmInfoTest . TYPES ; for ( final Object [ ] type : types ) { if ( type = = null | | type . length < _NUM ) continue ; query ( SerializerOptions . BINARY . arg ( _STR ' ) , type [ _NUM ] ) ; } } 
395	public void setUrl ( String url ) { checkEnv ( ) ; m _ URL = url ; String uCopy = m _ URL ; try { uCopy = m _ env . substitute ( uCopy ) ; } catch ( Exception ex ) { } m _ DataBaseConnection . setDatabaseURL ( uCopy ) ; } 
396	public static INDArray create ( int rows , int columns , int [ ] stride , char ordering ) { int [ ] shape = getEnsuredShape ( rows , columns ) ; checkShapeValues ( shape ) ; INDArray ret = INSTANCE . create ( shape , stride , _NUM , ordering ) ; logCreationIfNecessary ( ret ) ; return ret ; } 
397	public void testH _NUM _NUM _NUM VideoPlaybackMemoryUsage ( ) throws Exception { boolean memoryResult = false ; mStartPid = getMediaserverPid ( ) ; for ( int i = _NUM ; i < NUM _ STRESS _ LOOP ; i + + ) { mediaStressPlayback ( MediaNames . VIDEO _ HIGHRES _ H _NUM _NUM _NUM ) ; getMemoryWriteToLog ( i ) ; writeProcmemInfo ( ) ; } memoryResult = validateMemoryResult ( mStartPid , mStartMemory , DECODER _ LIMIT ) ; assertTrue ( _STR , memoryResult ) ; } 
398	public X _NUM _NUM _NUM Certificate generate ( PrivateKey key , SecureRandom random ) throws CertificateEncodingException , IllegalStateException , NoSuchAlgorithmException , SignatureException , InvalidKeyException { TBSCertificate tbsCert = generateTbsCert ( ) ; byte [ ] signature ; try { signature = X _NUM _NUM _NUM Util . calculateSignature ( sigOID , signatureAlgorithm , key , random , tbsCert ) ; } catch ( IOException e ) { throw new ExtCertificateEncodingException ( _STR , e ) ; } } 
399	public ListAutoNumber getBulletAutoNumberScheme ( ) { ParagraphPropertyFetcher < ListAutoNumber > fetcher = new ParagraphPropertyFetcher < ListAutoNumber > ( getLevel ( ) ) { public boolean fetch ( CTTextParagraphProperties props ) { if ( props . isSetBuAutoNum ( ) ) { setValue ( ListAutoNumber . values ( ) [ props . getBuAutoNum ( ) . getType ( ) . intValue ( ) - _NUM ] ) ; return true ; } return false ; } } ; fetchParagraphProperty ( fetcher ) ; Note : documentation does not define a default , return ListAutoNumber . ARABIC _ PLAIN ( _NUM , _NUM , _NUM . . . ) return fetcher . getValue ( ) = = null ? ListAutoNumber . ARABIC _ PLAIN : fetcher . getValue ( ) ; } 
400	protected final void checkSize ( ) { if ( size < next . length ) return ; final int s = size < < _NUM ; final int [ ] tmp = new int [ s ] ; for ( final int b : buckets ) { int id = b ; while ( id ! = _NUM ) { final int p = hash ( id ) & s - _NUM ; final int nx = next [ id ] ; next [ id ] = tmp [ p ] ; tmp [ p ] = id ; id = nx ; } } buckets = tmp ; next = Arrays . copyOf ( next , s ) ; rehash ( s ) ; } 
401	void restoreMenu ( ) { menuBar . installMenuBar ( ) ; } 
402	public void blockReport _ _NUM _NUM ( ) throws Exception { final String METHOD _ NAME = GenericTestUtils . getMethodName ( ) ; Path filePath = new Path ( _STR , _NUM , cluster . getNamesystem ( ) . getUnderReplicatedBlocks ( ) ) ; } 
403	private static String doNormalize ( final String fileName , final char separator , final boolean keepSeparator ) { if ( fileName = = null ) { return null ; } failIfNullBytePresent ( fileName ) ; int size = fileName . length ( ) ; if ( size = = _NUM ) { return fileName ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < _NUM ) { return null ; } + _NUM for possible extra slash , + _NUM for arraycopy final char [ ] array = new char [ size + _NUM ] ; fileName . getChars ( _NUM , fileName . length ( ) , array , _NUM ) ; fix separators throughout final char otherSeparator = separator = = SYSTEM _ SEPARATOR ? OTHER _ SEPARATOR : SYSTEM _ SEPARATOR ; for ( int i = _NUM ; i < array . length ; i + + ) { if ( array [ i ] = = otherSeparator ) { array [ i ] = separator ; } } add extra separator on the end to simplify code below boolean lastIsDirectory = true ; if ( array [ size - _NUM ] ! = separator ) { array [ size + + ] = separator ; lastIsDirectory = false ; } adjoining slashes for ( int i = prefix + _NUM ; i < size ; i + + ) { if ( array [ i ] = = separator & & array [ i - _NUM ] = = separator ) { System . arraycopy ( array , i , array , i - _NUM , size - i ) ; size - - ; i - - ; } } dot slash for ( int i = prefix + _NUM ; i < size ; i + + ) { if ( array [ i ] = = separator & & array [ i - _NUM ] = = ' . ' & & ( i = = prefix + _NUM | | array [ i - _NUM ] = = separator ) ) { if ( i = = size - _NUM ) { lastIsDirectory = true ; } System . arraycopy ( array , i + _NUM , array , i - _NUM , size - i ) ; size - = _NUM ; i - - ; } } double dot slash outer : for ( int i = prefix + _NUM ; i < size ; i + + ) { if ( array [ i ] = = separator & & array [ i - _NUM ] = = ' . ' & & array [ i - _NUM ] = = ' . ' & & ( i = = prefix + _NUM | | array [ i - _NUM ] = = separator ) ) { if ( i = = prefix + _NUM ) { return null ; } if ( i = = size - _NUM ) { lastIsDirectory = true ; } int j ; for ( j = i - _NUM ; j > = prefix ; j - - ) { if ( array [ j ] = = separator ) { remove b / . . / from a / b / . . / c System . arraycopy ( array , i + _NUM , array , j + _NUM , size - i ) ; size - = i - j ; i = j + _NUM ; continue outer ; } } remove a / . . / from a / . . / c System . arraycopy ( array , i + _NUM , array , prefix , size - i ) ; size - = i + _NUM - prefix ; i = prefix + _NUM ; } } if ( size < = _NUM ) { should never be less than _NUM return EMPTY _ STRING ; } if ( size < = prefix ) { should never be less than prefix return new String ( array , _NUM , size ) ; } if ( lastIsDirectory & & keepSeparator ) { keep trailing separator return new String ( array , _NUM , size ) ; } lose trailing separator return new String ( array , _NUM , size - _NUM ) ; } 
404	public boolean isSet ( _ Fields field ) { if ( field = = null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case SUCCESS : return isSetSuccess ( ) ; case IO : return isSetIo ( ) ; } throw new IllegalStateException ( ) ; } 
405	public static byte [ ] packInt ( int val ) { byte [ ] valBytes = new byte [ Integer . SIZE / Byte . SIZE ] ; setInt ( val , valBytes , _NUM ) ; return valBytes ; } 
406	final void notifyItemChanged ( ) { if ( mListeners ! = null ) { for ( int i = _NUM ; i < mListeners . size ( ) ; ) { Listener l = mListeners . get ( i ) . get ( ) ; if ( l = = null ) { mListeners . remove ( i ) ; } else { l . onItemChanged ( this ) ; i + + ; } } } } 
407	 @ SuppressWarnings ( _STR , jarName , e ) ; } } } long latestRegistryVersion = jars . size ( ) ! = missingJars . size ( ) ? localRegistryVersion : remoteVersion . getVersion ( ) ; localFunctionRegistry . register ( jars , latestRegistryVersion ) ; return true ; } } } return version ! = localFunctionRegistry . getVersion ( ) ; } 
408	void include ( int min , int max , boolean include ) { if ( include ) { merge ( min , max ) ; } else { remove ( min , max ) ; } } 
409	public synchronized void closeUdpEncapsulationSocket ( int resourceId ) throws RemoteException { UserRecord userRecord = mUserResourceTracker . getUserRecord ( Binder . getCallingUid ( ) ) ; releaseResource ( userRecord . mEncapSocketRecords , resourceId ) ; } 
410	public static XmlGYearMonth newInstance ( ) { return ( XmlGYearMonth ) XmlBeans . getContextTypeLoader ( ) . newInstance ( type , null ) ; } 
411	public void visitMapWay ( MapWay way ) { DefaultEntityViewInfo pInfo = ( DefaultEntityViewInfo ) way . getViewInfo ( ) ; List < MapNode > nodes = getWayNodes ( way ) ; if ( ! nodes . isEmpty ( ) & & pInfo . wayColor ! = null ) { if ( pInfo . wayFillColor ! = null & & nodes . get ( _NUM ) = = nodes . get ( nodes . size ( ) - _NUM ) & & ( way . isArea ( ) | | ! pInfo . fillAreasOnly ) ) alternative solution : & & ( way . isArea ( ) | | ( nodes . get ( _NUM ) = = nodes . get ( nodes . size ( ) - _NUM ) & & ! pInfo . fillAreasOnly ) ) ) areaBuffer . add ( way ) ; else wayBuffer . add ( way ) ; } if ( pInfo . isWayIcon & & pInfo . icon ! = null ) nodeBuffer . add ( way ) ; } 
412	public static Optional < Number > max ( List < Object > args ) { if ( args = = null | | args . size ( ) = = _NUM ) { return Optional . empty ( ) ; } Integer maxInt = Integer . MIN _ VALUE ; Double maxDouble = - ( Double . MAX _ VALUE ) ; Long maxLong = Long . MIN _ VALUE ; boolean found = false ; for ( Object arg : args ) { if ( arg instanceof Integer ) { maxInt = java . lang . Math . max ( maxInt , ( Integer ) arg ) ; found = true ; } else if ( arg instanceof Double ) { maxDouble = java . lang . Math . max ( maxDouble , ( Double ) arg ) ; found = true ; } else if ( arg instanceof Long ) { maxLong = java . lang . Math . max ( maxLong , ( Long ) arg ) ; found = true ; } else if ( arg instanceof String ) { Optional < ? > optional = Objects . toNumber ( arg ) ; if ( optional . isPresent ( ) ) { arg = optional . get ( ) ; if ( arg instanceof Integer ) { maxInt = java . lang . Math . max ( maxInt , ( Integer ) arg ) ; found = true ; } else if ( arg instanceof Double ) { maxDouble = java . lang . Math . max ( maxDouble , ( Double ) arg ) ; found = true ; } else if ( arg instanceof Long ) { maxLong = java . lang . Math . max ( maxLong , ( Long ) arg ) ; found = true ; } } } } if ( ! found ) { return Optional . empty ( ) ; } check MathTest # testAutoBoxingIssue for example if ( maxInt . longValue ( ) > = maxDouble . longValue ( ) & & maxInt . longValue ( ) > = maxLong ) { return Optional . < Number > of ( maxInt ) ; } else if ( maxLong > = maxDouble . longValue ( ) ) { return Optional . < Number > of ( maxLong ) ; } else { return Optional . < Number > of ( maxDouble ) ; } } 
413	private void drawAutofilledHighlight ( @ NonNull Canvas canvas ) { if ( isAutofilled ( ) ) { Drawable autofilledHighlight = getAutofilledDrawable ( ) ; if ( autofilledHighlight ! = null ) { autofilledHighlight . setBounds ( _NUM , _NUM , getWidth ( ) , getHeight ( ) ) ; autofilledHighlight . draw ( canvas ) ; } } } 
414	public static boolean isNonpositiveInteger ( String s ) { if ( isEmpty ( s ) ) return defaultEmptyOK ; try { int temp = Integer . parseInt ( s ) ; if ( temp < = _NUM ) return true ; return false ; } catch ( Exception e ) { return false ; } } 
415	public String getTextLine _NUM ( ) { return thirdRow . getText ( ) ; } 
416	private String getUsersBlogs ( ) throws Exception { final StringBuilder stringBuilder = new StringBuilder ( _STR ) ; return stringBuilder . toString ( ) ; } 
417	public double logDensityForInstance ( Instance instance ) throws Exception { double [ ] a = logJointDensitiesForInstance ( instance ) ; double max = a [ Utils . maxIndex ( a ) ] ; double sum = _NUM . _NUM ; for ( int i = _NUM ; i < a . length ; i + + ) { sum + = Math . exp ( a [ i ] - max ) ; } return max + Math . log ( sum ) ; } 
418	public void start ( ) { Preconditions . checkState ( state . compareAndSet ( State . LATENT , State . STARTED ) , _STR ) ; client . getConnectionStateListenable ( ) . addListener ( connectionStateListener ) ; createNode ( ) ; } 
419	public void testHFileMultiSlaveReplication ( ) throws Exception { LOG . info ( _STR , _NUM , new int [ ] { _NUM , _NUM } , row , famName , htables , hfileRanges , numOfRows , newExpectedCounts , true ) ; } finally { close ( htables ) ; shutDownMiniClusters ( ) ; } } 
420	protected String getBlobName ( Exchange exchange ) { String blobName = ( ( JcloudsBlobStoreEndpoint ) getEndpoint ( ) ) . getBlobName ( ) ; if ( ObjectHelper . isNotEmpty ( exchange . getIn ( ) . getHeader ( JcloudsConstants . BLOB _ NAME ) ) ) { blobName = exchange . getIn ( ) . getHeader ( JcloudsConstants . BLOB _ NAME , String . class ) ; } return blobName ; } 
421	public Character get ( Object key ) { int k ; if ( key ! = null ) { if ( key instanceof Integer ) { k = unwrapKey ( key ) ; } else { return null ; } } else { k = _ map . getNoEntryKey ( ) ; } char v = _ map . get ( k ) ; check here . if ( v = = _ map . getNoEntryValue ( ) ) { return null ; } else { return wrapValue ( v ) ; } } 
422	public static void main ( String [ ] args ) throws Exception { Options options = new Options ( ) ; options . addOption ( Option . builder ( _STR , e ) ; } finally { System . exit ( exitStatus ) ; } } 
423	public JSONObject getCameraMethodTypes ( ) throws IOException { String service = _STR + responseJson ) ; return new JSONObject ( responseJson ) ; } catch ( JSONException e ) { throw new IOException ( e ) ; } } 
424	public void testDFSAdminRollingUpgradeCommands ( ) throws Exception { start a cluster final Configuration conf = new HdfsConfiguration ( ) ; MiniDFSCluster cluster = null ; try { cluster = new MiniDFSCluster . Builder ( conf ) . numDataNodes ( _NUM ) . build ( ) ; cluster . waitActive ( ) ; final Path foo = new Path ( _STR ) ; All directories created before upgrade , when upgrade in progress and after upgrade finalize exists Assert . assertTrue ( dfs . exists ( foo ) ) ; Assert . assertTrue ( dfs . exists ( bar ) ) ; Assert . assertTrue ( dfs . exists ( baz ) ) ; dfs . setSafeMode ( SafeModeAction . SAFEMODE _ ENTER ) ; dfs . saveNamespace ( ) ; dfs . setSafeMode ( SafeModeAction . SAFEMODE _ LEAVE ) ; } Ensure directories exist after restart cluster . restartNameNode ( ) ; { final DistributedFileSystem dfs = cluster . getFileSystem ( ) ; Assert . assertTrue ( dfs . exists ( foo ) ) ; Assert . assertTrue ( dfs . exists ( bar ) ) ; Assert . assertTrue ( dfs . exists ( baz ) ) ; } } finally { if ( cluster ! = null ) cluster . shutdown ( ) ; } } 
425	private Iterator < Resource > listSubjects ( ) { Iterator < Resource > currentFile = new SingletonIterator < > ( model . createResource ( this . localName ) ) ; The pleasing types Iterator < Resource > pleasing = pleasingTypeIterator ( ) ; Iterator < Resource > fakeStopPleasing = new NullIterator < Resource > ( ) { @ Override public boolean hasNext ( ) { pleasingTypeSet = new HashSet < > ( ) ; return false ; } } ; Subjects that are not objects of anything . Iterator < Resource > nonObjects = new FilterIterator < Resource > ( new Filter < Resource > ( ) { @ Override public boolean test ( Resource o ) { return ( ! objectTable . containsKey ( o ) ) & & ( ! wantReification ( o ) ) ; } } , modelListSubjects ( ) ) ; Iterator < Resource > nonObjects = modelListSubjects ( ) . filterKeep ( o - > ! objectTable . containsKey ( o ) & & ! wantReification ( o ) ) ; At these stage we evaluate a dependency graph of the remaining resources . This is stuck in the master iterator so that it ' s hasNext is called at an appropriate time ( after the earlier stages , before the later stages ) . We use this to trigger the dependency graph evalaution . Iterator < Resource > fakeLazyEvaluator = new NullIterator < Resource > ( ) { @ Override public boolean hasNext ( ) { Evalaute dependency graph . findInfiniteCycles ( ) ; return false ; } } ; non - anonymous resources that are the object of more than one triple that are in infinite cycles . Iterator < Resource > firstChoiceCyclic = allInfiniteLeft ( ) . filterKeep ( r - > { codeCoverage [ _NUM ] + + ; if ( r . isAnon ( ) ) return false ; Integer cnt = objectTable . get ( r ) ; if ( cnt = = null | | cnt . intValue ( ) < = _NUM ) return false ; return true ; } ) ; any non genuinely anonymous resources that are in infinite cycles Iterator < Resource > nonAnonInfinite = allInfiniteLeft ( ) . filterKeep ( r - > { codeCoverage [ _NUM ] + + ; return ! isGenuineAnon ( r ) ; } ) ; any other resource in an infinite cyle Iterator < Resource > inf = allInfiniteLeft ( ) ; Iterator < Resource > anotherFake = new NullIterator < Resource > ( ) { @ Override public boolean hasNext ( ) { avoidExplicitReification = false ; return false ; } } ; Iterator < Resource > reifications = allInfiniteLeft ( ) . filterKeep ( r - > { codeCoverage [ _NUM ] + + ; return res _NUM statement . containsKey ( r ) ; } ) ; any other resource . Iterator < Resource > backStop = modelListSubjects ( ) ; @ SuppressWarnings ( _STR ) Iterator < Resource > [ ] all = new Iterator [ ] { currentFile , pleasing , fakeStopPleasing , nonObjects , fakeLazyEvaluator , firstChoiceCyclic , nonAnonInfinite , inf , anotherFake , reifications , new NullIterator < Resource > ( ) { @ Override public boolean hasNext ( ) { if ( modelListSubjects ( ) . hasNext ( ) ) codeCoverage [ _NUM ] + + ; return false ; } } , backStop } ; ExtendedIterator < Resource > allAsOne = WrappedIterator . createIteratorIterator ( Arrays . asList ( all ) . iterator ( ) ) ; Filter for those that still have something to list . return allAsOne . filterKeep ( this : : hasProperties ) ; } 
426	public static XmlDouble parse ( javax . xml . stream . XMLStreamReader xsr , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException { return ( XmlDouble ) XmlBeans . getContextTypeLoader ( ) . parse ( xsr , type , options ) ; } 
427	protected static int getPendingInflightExchanges ( RouteStartupOrder order ) { int inflight = _NUM ; inflight exchanges ( such as the aggregator ) for ( Service service : order . getServices ( ) ) { Set < Service > children = ServiceHelper . getChildServices ( service ) ; for ( Service child : children ) { if ( child instanceof ShutdownAware ) { inflight + = ( ( ShutdownAware ) child ) . getPendingExchangesSize ( ) ; } } } return inflight ; } 
428	public static AttributeInfo forLocalItem ( XmlSchemaObject sequenceObject , XmlSchema currentSchema , SchemaCollection schemaCollection , NamespacePrefixAccumulator prefixAccumulator , QName contextName ) { XmlSchemaAnnotated annotated = JavascriptUtils . getObjectAnnotated ( sequenceObject , contextName ) ; AttributeInfo attributeInfo = new AttributeInfo ( ) ; XmlSchemaAnnotated realAnnotated = annotated ; if ( annotated instanceof XmlSchemaAttribute ) { XmlSchemaAttribute attribute = ( XmlSchemaAttribute ) annotated ; attributeInfo . use = attribute . getUse ( ) ; if ( attribute . getRef ( ) . getTarget ( ) ! = null ) { realAnnotated = attribute . getRef ( ) . getTarget ( ) ; attributeInfo . global = true ; } } else if ( annotated instanceof XmlSchemaAnyAttribute ) { attributeInfo . any = true ; unknown until runtime . attributeInfo . xmlName = null ; attributeInfo . javascriptName = _STR , annotated , contextName ) ; } factoryCommon ( realAnnotated , currentSchema , schemaCollection , prefixAccumulator , attributeInfo ) ; attributeInfo . annotated = realAnnotated ; return attributeInfo ; } 
429	public static Comparator thisUniversalComparator ( final boolean ascending , final boolean nullsFirst ) { return new Comparator ( ) { @ Override public int compare ( Object o _NUM , Object o _NUM ) { Object value _NUM ; Object value _NUM ; if ( ascending ) { value _NUM = ( o _NUM ) ; value _NUM = ( o _NUM ) ; } else { value _NUM = ( o _NUM ) ; value _NUM = ( o _NUM ) ; } return Sorting . compare ( value _NUM , value _NUM , nullsFirst ) ; } } ; } 
430	public float [ ] evalFunction ( float [ ] input ) throws IOException { PDFunction [ ] functions = getFunctionsArray ( ) ; int numberOfFunctions = functions . length ; float [ ] returnValues ; if ( numberOfFunctions = = _NUM ) { returnValues = functions [ _NUM ] . eval ( input ) ; } else { returnValues = new float [ numberOfFunctions ] ; for ( int i = _NUM ; i < numberOfFunctions ; i + + ) { float [ ] newValue = functions [ i ] . eval ( input ) ; returnValues [ i ] = newValue [ _NUM ] ; } } is out of range , it shall be adjusted to the nearest valid value . " for ( int i = _NUM ; i < returnValues . length ; + + i ) { if ( returnValues [ i ] < _NUM ) { returnValues [ i ] = _NUM ; } else if ( returnValues [ i ] > _NUM ) { returnValues [ i ] = _NUM ; } } return returnValues ; } 
431	protected boolean scrollBottom ( TextView widget , Spannable buffer ) { final Layout layout = widget . getLayout ( ) ; final int lineCount = layout . getLineCount ( ) ; if ( getBottomLine ( widget ) < = lineCount - _NUM ) { Touch . scrollTo ( widget , layout , widget . getScrollX ( ) , layout . getLineTop ( lineCount ) - getInnerHeight ( widget ) ) ; return true ; } return false ; } 
432	private boolean removeAll ( Array < ? extends T > array , boolean identity ) { int size = this . size ; int startSize = size ; T [ ] items = this . items ; if ( identity ) { for ( int i = _NUM , n = array . size ; i < n ; i + + ) { T item = array . get ( i ) ; for ( int ii = _NUM ; ii < size ; ii + + ) { if ( item = = items [ ii ] ) { removeIndex ( ii ) ; size - - ; break ; } } } } else { for ( int i = _NUM , n = array . size ; i < n ; i + + ) { T item = array . get ( i ) ; for ( int ii = _NUM ; ii < size ; ii + + ) { if ( item . equals ( items [ ii ] ) ) { removeIndex ( ii ) ; size - - ; break ; } } } } return size ! = startSize ; } 
433	public static Map < String , Object > updatePassword ( DispatchContext ctx , Map < String , ? > context ) { Delegator delegator = ctx . getDelegator ( ) ; Security security = ctx . getSecurity ( ) ; GenericValue loggedInUserLogin = ( GenericValue ) context . get ( _STR , userLoginToUpdate ) ; return result ; } 
434	public static void validateCoderIsCompatible ( IsmRecordCoder < ? > coder ) { for ( Coder < ? > keyComponentCoder : coder . getKeyComponentCoders ( ) ) { try { keyComponentCoder . verifyDeterministic ( ) ; } catch ( NonDeterministicException e ) { throw new IllegalArgumentException ( String . format ( _STR , keyComponentCoder ) , e ) ; } } } 
435	public final void setSpannableFactory ( Spannable . Factory factory ) { mSpannableFactory = factory ; setText ( mText ) ; } 
436	public static XmlLong parse ( java . lang . String s ) throws org . apache . xmlbeans . XmlException { return ( XmlLong ) XmlBeans . getContextTypeLoader ( ) . parse ( s , type , null ) ; } 
437	public Form getCurrent ( ) { Form current = impl . getCurrentForm ( ) ; if ( current ! = null & & current instanceof Dialog ) { if ( ( ( Dialog ) current ) . isMenu ( ) | | ( ( Dialog ) current ) . isDisposed ( ) ) { Form p = current . getPreviousForm ( ) ; if ( p ! = null ) { return p ; } we are in the middle of a transition so we should extract the next form if ( animationQueue ! = null ) { int size = animationQueue . size ( ) ; for ( int iter = _NUM ; iter < size ; iter + + ) { Animation o = animationQueue . get ( iter ) ; if ( o instanceof Transition ) { return ( Form ) ( ( Transition ) o ) . getDestination ( ) ; } } } } } return current ; } 
438	public void addBRules ( List < Rule > rules ) { for ( Rule rule : rules ) { logger . debug ( _STR + rule ) ; bEngine . addRule ( rule ) ; } bEngine . reset ( ) ; } 
439	public static MediaPlayer create ( Context context , int resid , AudioAttributes audioAttributes , int audioSessionId ) { try { AssetFileDescriptor afd = context . getResources ( ) . openRawResourceFd ( resid ) ; if ( afd = = null ) return null ; MediaPlayer mp = new MediaPlayer ( ) ; final AudioAttributes aa = audioAttributes ! = null ? audioAttributes : new AudioAttributes . Builder ( ) . build ( ) ; mp . setAudioAttributes ( aa ) ; mp . setAudioSessionId ( audioSessionId ) ; mp . setDataSource ( afd . getFileDescriptor ( ) , afd . getStartOffset ( ) , afd . getLength ( ) ) ; afd . close ( ) ; mp . prepare ( ) ; return mp ; } catch ( IOException ex ) { Log . d ( TAG , _STR , ex ) ; fall through } return null ; } 
440	protected void persistIndexedSiteMap ( ) { String now = FormatUtil . formatDateUsingW _NUM C ( new Date ( ) ) ; Save the leftover URL set persistIndexedURLSetWrapper ( currentURLSetWrapper ) ; Build the siteMapIndex SiteMapIndexWrapper siteMapIndexWrapper = new SiteMapIndexWrapper ( ) ; for ( String fileName : indexedFileNames ) { SiteMapWrapper siteMapWrapper = new SiteMapWrapper ( ) ; String fileLoc = null ; if ( gzipSiteMapFiles ) { fileLoc = BroadleafFileUtils . appendUnixPaths ( baseUrl , fileName + _STR ) ; } indexedFileNames . add ( siteMapConfig . getIndexedSiteMapFileName ( ) ) ; persistXMLDocument ( siteMapConfig . getIndexedSiteMapFileName ( ) , siteMapIndexWrapper ) ; } 
441	public static String escapeHtmlTags ( final String input ) { if ( Strings . isEmpty ( input ) | | ( input . indexOf ( ' _STR ) ; } else { buf . append ( ch ) ; } } return buf . toString ( ) ; } 
442	public final void populateViewportLocked ( DisplayViewport viewport ) { viewport . orientation = mCurrentOrientation ; if ( mCurrentLayerStackRect ! = null ) { viewport . logicalFrame . set ( mCurrentLayerStackRect ) ; } else { viewport . logicalFrame . setEmpty ( ) ; } if ( mCurrentDisplayRect ! = null ) { viewport . physicalFrame . set ( mCurrentDisplayRect ) ; } else { viewport . physicalFrame . setEmpty ( ) ; } boolean isRotated = ( mCurrentOrientation = = Surface . ROTATION _ _NUM _NUM | | mCurrentOrientation = = Surface . ROTATION _ _NUM _NUM _NUM ) ; DisplayDeviceInfo info = getDisplayDeviceInfoLocked ( ) ; viewport . deviceWidth = isRotated ? info . height : info . width ; viewport . deviceHeight = isRotated ? info . width : info . height ; } 
443	public long getInstanceLength ( ) { See Content - Range in http : final String contentRange = ( String ) metadata . get ( Headers . CONTENT _ RANGE ) ; if ( contentRange ! = null ) { final int pos = contentRange . lastIndexOf ( _STR ) ; if ( pos > = _NUM ) { return Long . parseLong ( contentRange . substring ( pos + _NUM ) ) ; } } return getContentLength ( ) ; } 
444	public void testCastInAggregateReduceFunctions ( ) { final HepProgram program = HepProgram . builder ( ) . addRuleInstance ( AggregateReduceFunctionsRule . INSTANCE ) . build ( ) ; final String sql = _STR ; sql ( sql ) . with ( program ) . check ( ) ; } 
445	static Instance createInstance ( int sequenceType , int orientationType , Gesture gesture , String label ) { float [ ] pts ; Instance instance ; if ( sequenceType = = GestureStore . SEQUENCE _ SENSITIVE ) { pts = temporalSampler ( orientationType , gesture ) ; instance = new Instance ( gesture . getID ( ) , pts , label ) ; instance . normalize ( ) ; } else { pts = spatialSampler ( gesture ) ; instance = new Instance ( gesture . getID ( ) , pts , label ) ; } return instance ; } 
446	public void commitBlockNotOwnedBySessionId ( ) throws Exception { mThrown . expect ( InvalidWorkerStateException . class ) ; mThrown . expectMessage ( ExceptionMessage . BLOCK _ ID _ FOR _ DIFFERENT _ SESSION . getMessage ( TEMP _ BLOCK _ ID , SESSION _ ID _NUM , SESSION _ ID _NUM ) ) ; TieredBlockStoreTestUtils . createTempBlock ( SESSION _ ID _NUM , TEMP _ BLOCK _ ID , BLOCK _ SIZE , mTestDir _NUM ) ; mBlockStore . commitBlock ( SESSION _ ID _NUM , TEMP _ BLOCK _ ID ) ; } 
447	public static Intent getParentActivityIntent ( Context context , Class < ? > sourceActivityClass ) throws NameNotFoundException { String parentActivity = getParentActivityName ( context , new ComponentName ( context , sourceActivityClass ) ) ; if ( parentActivity = = null ) return null ; If the parent itself has no parent , generate a main activity intent . final ComponentName target = new ComponentName ( context , parentActivity ) ; final String grandparent = getParentActivityName ( context , target ) ; final Intent parentIntent = grandparent = = null ? IntentCompat . makeMainActivity ( target ) : new Intent ( ) . setComponent ( target ) ; return parentIntent ; } 
448	public static void decodeFileToFile ( String infile , String outfile ) { byte [ ] decoded = Base _NUM _NUM . decodeFromFile ( infile ) ; java . io . OutputStream out = null ; try { out = new java . io . BufferedOutputStream ( new java . io . FileOutputStream ( outfile ) ) ; out . write ( decoded ) ; } end try catch ( java . io . IOException ex ) { ex . printStackTrace ( ) ; } finally end catch { try { out . close ( ) ; } catch ( Exception ex ) { } } end finally } 
449	public ReportRegionStateTransitionResponse reportRegionStateTransition ( final ReportRegionStateTransitionRequest req ) throws PleaseHoldException { final ReportRegionStateTransitionResponse . Builder builder = ReportRegionStateTransitionResponse . newBuilder ( ) ; final ServerName serverName = ProtobufUtil . toServerName ( req . getServer ( ) ) ; try { for ( RegionStateTransition transition : req . getTransitionList ( ) ) { switch ( transition . getTransitionCode ( ) ) { case OPENED : case FAILED _ OPEN : case CLOSED : assert transition . getRegionInfoCount ( ) = = _NUM : transition ; final RegionInfo hri = ProtobufUtil . toRegionInfo ( transition . getRegionInfo ( _NUM ) ) ; updateRegionTransition ( serverName , transition . getTransitionCode ( ) , hri , transition . hasOpenSeqNum ( ) ? transition . getOpenSeqNum ( ) : HConstants . NO _ SEQNUM ) ; break ; case READY _ TO _ SPLIT : case SPLIT : case SPLIT _ REVERTED : assert transition . getRegionInfoCount ( ) = = _NUM : transition ; final RegionInfo parent = ProtobufUtil . toRegionInfo ( transition . getRegionInfo ( _NUM ) ) ; final RegionInfo splitA = ProtobufUtil . toRegionInfo ( transition . getRegionInfo ( _NUM ) ) ; final RegionInfo splitB = ProtobufUtil . toRegionInfo ( transition . getRegionInfo ( _NUM ) ) ; updateRegionSplitTransition ( serverName , transition . getTransitionCode ( ) , parent , splitA , splitB ) ; break ; case READY _ TO _ MERGE : case MERGED : case MERGE _ REVERTED : assert transition . getRegionInfoCount ( ) = = _NUM : transition ; final RegionInfo merged = ProtobufUtil . toRegionInfo ( transition . getRegionInfo ( _NUM ) ) ; final RegionInfo mergeA = ProtobufUtil . toRegionInfo ( transition . getRegionInfo ( _NUM ) ) ; final RegionInfo mergeB = ProtobufUtil . toRegionInfo ( transition . getRegionInfo ( _NUM ) ) ; updateRegionMergeTransition ( serverName , transition . getTransitionCode ( ) , merged , mergeA , mergeB ) ; break ; } } } catch ( PleaseHoldException e ) { if ( LOG . isTraceEnabled ( ) ) LOG . trace ( _STR + e . getMessage ( ) ) ; } return builder . build ( ) ; } 
450	final Entry < K , V > removeEntryForKey ( Object key ) { int hash = ( key = = null ) ? _NUM : hash ( key . hashCode ( ) ) ; int i = indexFor ( hash , table . length ) ; Entry < K , V > prev = table [ i ] ; Entry < K , V > e = prev ; while ( e ! = null ) { Entry < K , V > next = e . next ; Object k ; if ( e . hash = = hash & & ( ( k = e . key ) = = key | | ( key ! = null & & key . equals ( k ) ) ) ) { modCount + + ; size - - ; if ( prev = = e ) table [ i ] = next ; else prev . next = next ; e . recordRemoval ( this ) ; return e ; } prev = e ; e = next ; } return e ; } 
451	private void checkIOErrorIsTolerated ( ) { long now = EnvironmentEdgeManager . currentTime ( ) ; if ( this . ioErrorStartTime > _NUM ) { if ( cacheEnabled & & ( now - ioErrorStartTime ) > this . ioErrorsTolerationDuration ) { LOG . error ( _STR ) ; disableCache ( ) ; } } else { this . ioErrorStartTime = now ; } } 
452	public int pauseAllWithType ( TransferType type ) { final ContentValues values = new ContentValues ( ) ; values . put ( TransferTable . COLUMN _ STATE , TransferState . PENDING _ PAUSE . toString ( ) ) ; String selection = null ; String [ ] selectionArgs = null ; if ( type = = TransferType . ANY ) { selection = TransferTable . COLUMN _ STATE + _STR ; selectionArgs = new String [ ] { TransferState . IN _ PROGRESS . toString ( ) , TransferState . RESUMED _ WAITING . toString ( ) , TransferState . WAITING . toString ( ) , type . toString ( ) } ; } return transferDBBase . update ( transferDBBase . getContentUri ( ) , values , selection , selectionArgs ) ; } 
453	private void correctExternalNetworkDevicesSetup ( Connection conn ) { PreparedStatement pNetworkStmt = null , f _NUM DevicesStmt = null , srxDevicesStmt = null ; ResultSet pNetworksResults = null , f _NUM DevicesResult = null , srxDevicesResult = null ; try ( PreparedStatement zoneSearchStmt = conn . prepareStatement ( _STR , e ) ; } } 
454	public static void datasetToStream ( DatasetGraph datasetGraph , StreamRDF stream ) { stream . start ( ) ; sendDatasetToStream ( datasetGraph , stream ) ; stream . finish ( ) ; } 
455	public SqlCall permutedCall ( ) { final List < SqlNode > operandList = operands ( ) ; if ( operandList . equals ( call . getOperandList ( ) ) ) { return call ; } return call . getOperator ( ) . createCall ( call . pos , operandList ) ; } 
456	public boolean removeAll ( ArraySet < ? extends E > array ) { TODO : If array is sufficiently large , a marking approach might be beneficial . In a first pass , use the property that the sets are sorted by hash to make this linear passes ( except for hash collisions , which means worst case still n * m ) , then do one collection pass into a new array . This avoids binary searches and excessive memcpy . final int N = array . mSize ; Note : ArraySet does not make thread - safety guarantees . So instead of OR - ing together all the single results , compare size before and after . final int originalSize = mSize ; for ( int i = _NUM ; i < N ; i + + ) { remove ( array . valueAt ( i ) ) ; } return originalSize ! = mSize ; } 
457	protected void setCancelButton ( boolean flag ) { if ( m _ cancelBut ! = null ) m _ cancelBut . setEnabled ( flag ) ; } 
458	 @ Override @ SuppressWarnings ( _STR ) ; sendGlobalBarrierComplete ( ) ; completedLatch . countDown ( ) ; tell the timer we are done , if we get here successfully timeoutInjector . complete ( ) ; return null ; } } 
459	private void setValues ( Object o ) { String msg ; String title ; String value ; String valueNew ; int i ; ArffSortedTableModel model ; value = _STR ) ) { valueNew = null ; } model . setValueAt ( valueNew , i , m _ CurrentCol ) ; } } model . setUndoEnabled ( true ) ; model . setNotificationEnabled ( true ) ; model . notifyListener ( new TableModelEvent ( model , _NUM , model . getRowCount ( ) , m _ CurrentCol , TableModelEvent . UPDATE ) ) ; refresh m _ TableArff . repaint ( ) ; } 
460	public static void main ( String [ ] argv ) throws Exception { FsShell shell = newShellInstance ( ) ; Configuration conf = new Configuration ( ) ; conf . setQuietMode ( false ) ; shell . setConf ( conf ) ; int res ; try { res = ToolRunner . run ( shell , argv ) ; } finally { shell . close ( ) ; } System . exit ( res ) ; } 
461	public double squaredDistance ( INDArray other ) { double sd = _NUM . _NUM ; if ( other instanceof IComplexNDArray ) { IComplexNDArray n = ( IComplexNDArray ) other ; IComplexNDArray nLinear = n . linearView ( ) ; for ( int i = _NUM ; i < length ( ) ; i + + ) { IComplexNumber diff = linearView ( ) . getComplex ( i ) . sub ( nLinear . getComplex ( i ) ) ; double d = diff . absoluteValue ( ) . doubleValue ( ) ; sd + = d * d ; } return sd ; } for ( int i = _NUM ; i < length ( ) ; i + + ) { INDArray linear = other . linearView ( ) ; IComplexNumber diff = linearView ( ) . getComplex ( i ) . sub ( linear . getDouble ( i ) ) ; double d = diff . absoluteValue ( ) . doubleValue ( ) ; sd + = d * d ; } return sd ; } 
462	protected void internalDeleteUserInfo ( CmsDbContext dbc , CmsUUID userId , String key ) throws CmsDataAccessException { try { Query q = m _ sqlManager . createQuery ( dbc , C _ USERDATA _ DELETE _ _NUM ) ; write data to database q . setParameter ( _NUM , userId . toString ( ) ) ; q . setParameter ( _NUM , key ) ; q . executeUpdate ( ) ; } catch ( PersistenceException e ) { throw new CmsDataAccessException ( Messages . get ( ) . container ( Messages . ERR _ JPA _ PERSITENCE , e ) , e ) ; } } 
463	private NetworkRequestInfo findExistingNetworkRequestInfo ( PendingIntent pendingIntent ) { Intent intent = pendingIntent . getIntent ( ) ; for ( Map . Entry < NetworkRequest , NetworkRequestInfo > entry : mNetworkRequests . entrySet ( ) ) { PendingIntent existingPendingIntent = entry . getValue ( ) . mPendingIntent ; if ( existingPendingIntent ! = null & & existingPendingIntent . getIntent ( ) . filterEquals ( intent ) ) { return entry . getValue ( ) ; } } return null ; } 
464	public boolean supportsProperty ( Property property ) { if ( factory = = null ) return false ; Model caps = factory . getCapabilities ( ) ; Resource root = caps . getResource ( factory . getURI ( ) ) ; return caps . contains ( root , ReasonerVocabulary . supportsP , property ) ; } 
465	protected void internalUpdateUserInfo ( CmsDbContext dbc , CmsUUID userId , String key , Object value ) throws CmsDataAccessException { PreparedStatement stmt = null ; Connection conn = null ; try { get connection conn = m _ sqlManager . getConnection ( dbc ) ; write data to database stmt = m _ sqlManager . getPreparedStatement ( conn , _STR ) ; stmt . setString ( _NUM , value . getClass ( ) . getName ( ) ) ; stmt . setString ( _NUM , userId . toString ( ) ) ; stmt . setString ( _NUM , key ) ; stmt . executeUpdate ( ) ; } catch ( SQLException e ) { throw new CmsDbSqlException ( org . opencms . db . generic . Messages . get ( ) . container ( org . opencms . db . generic . Messages . ERR _ GENERIC _ SQL _ _NUM , CmsDbSqlException . getErrorQuery ( stmt ) ) , e ) ; } finally { m _ sqlManager . closeAll ( dbc , conn , stmt , null ) ; } internalUpdateUserInfoData ( dbc , userId , key , value ) ; } 
466	public void testStop ( ) { BluetoothAdapter adapter = BluetoothAdapter . getDefaultAdapter ( ) ; assertTrue ( adapter . isEnabled ( ) ) ; mTestUtils . disable ( adapter ) ; } 
467	private static void testUserLoggerSetError ( ) { Properties props = new Properties ( ) ; ByteArrayOutputStream out _NUM = new ByteArrayOutputStream ( ) ; ByteArrayOutputStream err _NUM = new ByteArrayOutputStream ( ) ; PrintStream out _NUM = new PrintStream ( out _NUM ) ; PrintStream err _NUM = new PrintStream ( err _NUM ) ; props . put ( _STR ) ; } } 
468	public static void resume ( @ NonNull AppCompatActivity activity ) { if ( instance = = null ) { return ; } instance . context = activity ; instance . isResumed = true ; if ( instance . subs ! = null ) { instance . subs . clear ( ) ; } instance . subs = new CompositeDisposable ( ) ; subscribeBackgroundListeners ( ) ; instance . subs . add ( instance . colorPrimary ( ) . compose ( Rx . < Integer > distinctToMainThread ( ) ) . subscribe ( new Consumer < Integer > ( ) { @ Override public void accept ( @ io . reactivex . annotations . NonNull Integer color ) { Util . setTaskDescriptionColor ( instance . context , color ) ; } } , onErrorLogAndRethrow ( ) ) ) ; instance . subs . add ( instance . activityTheme ( ) . compose ( Rx . < Integer > distinctToMainThread ( ) ) . subscribe ( new Consumer < Integer > ( ) { @ Override public void accept ( @ io . reactivex . annotations . NonNull Integer themeId ) { if ( getLastActivityTheme ( instance . context ) = = themeId ) { return ; } instance . lastActivityThemes . put ( instance . context . getClass ( ) . getName ( ) , themeId ) ; instance . context . recreate ( ) ; } } , onErrorLogAndRethrow ( ) ) ) ; instance . subs . add ( Observable . combineLatest ( instance . colorStatusBar ( ) , instance . lightStatusBarMode ( ) , new BiFunction < Integer , Integer , Pair < Integer , Integer > > ( ) { @ Override public Pair < Integer , Integer > apply ( Integer integer , Integer integer _NUM ) { return Pair . create ( integer , integer _NUM ) ; } } ) . compose ( Rx . < Pair < Integer , Integer > > distinctToMainThread ( ) ) . subscribe ( new Consumer < Pair < Integer , Integer > > ( ) { @ Override public void accept ( @ io . reactivex . annotations . NonNull Pair < Integer , Integer > result ) { instance . invalidateStatusBar ( ) ; } } , onErrorLogAndRethrow ( ) ) ) ; instance . subs . add ( instance . colorNavigationBar ( ) . compose ( Rx . < Integer > distinctToMainThread ( ) ) . subscribe ( new Consumer < Integer > ( ) { @ Override public void accept ( @ io . reactivex . annotations . NonNull Integer color ) { setNavBarColorCompat ( instance . context , color ) ; } } , onErrorLogAndRethrow ( ) ) ) ; instance . subs . add ( instance . colorWindowBackground ( ) . compose ( Rx . < Integer > distinctToMainThread ( ) ) . subscribe ( new Consumer < Integer > ( ) { @ Override public void accept ( @ io . reactivex . annotations . NonNull Integer color ) { instance . context . getWindow ( ) . setBackgroundDrawable ( new ColorDrawable ( color ) ) ; } } , onErrorLogAndRethrow ( ) ) ) ; if ( MaterialDialogsUtil . shouldSupport ( ) ) { instance . subs . add ( MaterialDialogsUtil . observe ( instance ) ) ; } } 
469	public synchronized Instant getEarliestTimerTimestamp ( ) { Instant earliest = THE _ END _ OF _ TIME . get ( ) ; for ( NavigableSet < TimerData > timers : processingTimers . values ( ) ) { if ( ! timers . isEmpty ( ) ) { earliest = INSTANT _ ORDERING . min ( timers . first ( ) . getTimestamp ( ) , earliest ) ; } } for ( NavigableSet < TimerData > timers : synchronizedProcessingTimers . values ( ) ) { if ( ! timers . isEmpty ( ) ) { earliest = INSTANT _ ORDERING . min ( timers . first ( ) . getTimestamp ( ) , earliest ) ; } } if ( ! pendingTimers . isEmpty ( ) ) { earliest = INSTANT _ ORDERING . min ( pendingTimers . first ( ) . getTimestamp ( ) , earliest ) ; } return earliest ; } 
470	protected void setupRequestProcessors ( ) { We might consider changing the processor behaviour of Observers to , for example , remove the disk sync requirements . Currently , they behave almost exactly the same as followers . RequestProcessor finalProcessor = new FinalRequestProcessor ( this ) ; commitProcessor = new CommitProcessor ( finalProcessor , Long . toString ( getServerId ( ) ) , true , getZooKeeperServerListener ( ) ) ; commitProcessor . start ( ) ; firstProcessor = new ObserverRequestProcessor ( this , commitProcessor ) ; ( ( ObserverRequestProcessor ) firstProcessor ) . start ( ) ; if ( syncRequestProcessorEnabled ) { syncProcessor = new SyncRequestProcessor ( this , null ) ; syncProcessor . start ( ) ; } } 
471	protected String mapRequestToDataset ( String uri ) { return mapRequestToDatasetLongest $ ( uri ) ; } 
472	boolean update ( WifiNetworkScoreCache scoreCache , boolean scoringUiEnabled , long maxScoreCacheAgeMillis ) { boolean scoreChanged = false ; if ( scoringUiEnabled ) { scoreChanged = updateScores ( scoreCache , maxScoreCacheAgeMillis ) ; } return updateMetered ( scoreCache ) | | scoreChanged ; } 
473	public static void testIndependence ( Iterable < ? extends AbstractPiece > referenceImpl , Iterable < ? extends AbstractPiece > testImpl ) { int length = testSequential ( referenceImpl , testImpl ) ; testRandom ( length , referenceImpl , testImpl ) ; } 
474	public void wakeRegions ( final Procedure procedure , final TableName table , final RegionInfo . . . regionInfo ) { Arrays . sort ( regionInfo , RegionInfo . COMPARATOR ) ; schedLock ( ) ; try { int numProcs = _NUM ; final Procedure [ ] nextProcs = new Procedure [ regionInfo . length ] ; for ( int i = _NUM ; i < regionInfo . length ; + + i ) { assert regionInfo [ i ] . getTable ( ) . equals ( table ) ; assert i = = _NUM | | regionInfo [ i ] ! = regionInfo [ i - _NUM ] : _STR + regionInfo [ i ] ; LockAndQueue regionLock = locking . getRegionLock ( regionInfo [ i ] . getEncodedName ( ) ) ; if ( regionLock . releaseExclusiveLock ( procedure ) ) { if ( ! regionLock . isEmpty ( ) ) { release one procedure at the time since regions has an xlock nextProcs [ numProcs + + ] = regionLock . removeFirst ( ) ; } else { locking . removeRegionLock ( regionInfo [ i ] . getEncodedName ( ) ) ; } } } awake procedures if any for ( int i = numProcs - _NUM ; i > = _NUM ; - - i ) { wakeProcedure ( nextProcs [ i ] ) ; } wakePollIfNeeded ( numProcs ) ; if ( ! procedure . hasParent ( ) ) { release the table shared - lock . ( if we have a parent , it is holding an xlock so we didn ' t take the shared - lock ) wakeTableSharedLock ( procedure , table ) ; } } finally { schedUnlock ( ) ; } } 
475	public void testPopupShow ( ) throws Throwable { AutoCompleteTextViewSimple theActivity = getActivity ( ) ; final AutoCompleteTextView textView = theActivity . getTextView ( ) ; final Instrumentation instrumentation = getInstrumentation ( ) ; Drop - down should not be showing when no text has been entered assertFalse ( _STR , textView , true ) ; TODO : FlakyTest repeat runs will not currently call setUp , clear state clearText ( textView ) ; } 
476	public static Properties readProperties ( String resourceName ) throws Exception { Properties defaultProps = new Properties ( ) ; try { Apparently hardcoded slashes are OK here jdk _NUM . _NUM / docs / guide / misc / resources . html Utils utils = new Utils ( ) ; Enumeration < URL > urls = utils . getClass ( ) . getClassLoader ( ) . getResources ( resourceName ) ; boolean first = true ; while ( urls . hasMoreElements ( ) ) { URL url = urls . nextElement ( ) ; if ( first ) { defaultProps . load ( url . openStream ( ) ) ; first = false ; } else { Properties props = new Properties ( defaultProps ) ; props . load ( url . openStream ( ) ) ; defaultProps = props ; } } } catch ( Exception ex ) { System . err . println ( _STR + propFile ) ; } } return localProps ; } 
477	public String getNodeGroup ( String loc ) { netlock . readLock ( ) . lock ( ) ; try { loc = InnerNode . normalize ( loc ) ; Node locNode = getNode ( loc ) ; if ( locNode instanceof InnerNodeWithNodeGroup ) { InnerNodeWithNodeGroup node = ( InnerNodeWithNodeGroup ) locNode ; if ( node . isNodeGroup ( ) ) { return loc ; } else if ( node . isRack ( ) ) { not sure the node group for a rack return null ; } else { may be a leaf node return getNodeGroup ( node . getNetworkLocation ( ) ) ; } } else { not in cluster map , don ' t handle it return loc ; } } finally { netlock . readLock ( ) . unlock ( ) ; } } 
478	public String addNewLogger ( ) { if ( this . model . getNewLogger ( ) ! = null & & this . model . getNewLogger ( ) . getLoggerName ( ) ! = null & & this . model . getNewLogger ( ) . getNewLogLevel ( ) ! = null ) { final Logger newLogger = LoggingUtil . getLogger ( this . model . getNewLogger ( ) . getLoggerName ( ) ) ; newLogger . setLevel ( Level . toLevel ( this . model . getNewLogger ( ) . getNewLogLevel ( ) . getLogLevel ( ) ) ) ; Need to refresh the loggers loadLoggers ( ) ; } return _STR ; } 
479	public void addProperty ( String name , boolean value ) { CTProperty p = add ( name ) ; p . setBool ( value ) ; } 
480	public String getFileName ( final URL url ) { final String file = getPath ( url ) ; final int last = file . lastIndexOf ( _STR ) ; if ( last < _NUM ) { return file ; } return file . substring ( last + _NUM ) ; } 
481	private List search ( String [ ] attributeNames , String attributeValue , String [ ] attrs ) throws StoreException { String filter = null ; if ( attributeNames = = null ) { filter = null ; } else { filter = _STR ; if ( filter = = null ) { filter _NUM = filter _NUM ; } List list ; list = getFromCache ( filter _NUM ) ; if ( list ! = null ) { return list ; } DirContext ctx = null ; list = new ArrayList ( ) ; try { ctx = connectLDAP ( ) ; SearchControls constraints = new SearchControls ( ) ; constraints . setSearchScope ( SearchControls . SUBTREE _ SCOPE ) ; constraints . setCountLimit ( _NUM ) ; constraints . setReturningAttributes ( attrs ) ; NamingEnumeration results = ctx . search ( params . getBaseDN ( ) , filter _NUM , constraints ) ; while ( results . hasMoreElements ( ) ) { SearchResult sr = ( SearchResult ) results . next ( ) ; NamingEnumeration enumeration = ( ( Attribute ) ( sr . getAttributes ( ) . getAll ( ) . next ( ) ) ) . getAll ( ) ; while ( enumeration . hasMore ( ) ) { list . add ( enumeration . next ( ) ) ; } } addToCache ( filter _NUM , list ) ; } catch ( NamingException e ) { skip exception , unfortunately if an attribute type is not supported an exception is thrown } finally { try { if ( null ! = ctx ) { ctx . close ( ) ; } } catch ( Exception e ) { } } return list ; } 
482	public void setInstances ( Instances instances ) { Capabilities cap = getCapabilities ( ) ; if ( ! cap . test ( instances ) ) throw new IllegalArgumentException ( cap . getFailReason ( ) ) ; if ( m _ retrieval = = INCREMENTAL ) { if ( setStructure ( instances ) = = CANCEL ) cancel ( ) ; } else m _ instances = instances ; } 
483	public void testCorruptCheckpointCompleteMarkerMostSignificant _NUM Bytes ( ) throws Exception { Map < String , String > overrides = Maps . newHashMap ( ) ; channel = createFileChannel ( overrides ) ; channel . start ( ) ; Assert . assertTrue ( channel . isOpen ( ) ) ; Set < String > in = putEvents ( channel , _STR ) ; writer . seek ( EventQueueBackingStoreFile . INDEX _ CHECKPOINT _ MARKER * Serialization . SIZE _ OF _ LONG ) ; writer . write ( new byte [ ] { ( byte ) _NUM , ( byte ) _NUM } ) ; writer . getFD ( ) . sync ( ) ; writer . close ( ) ; channel = createFileChannel ( overrides ) ; channel . start ( ) ; Assert . assertTrue ( channel . isOpen ( ) ) ; Set < String > out = consumeChannel ( channel ) ; Assert . assertTrue ( channel . didFullReplayDueToBadCheckpointException ( ) ) ; compareInputAndOut ( in , out ) ; } 
484	public boolean equals ( Object other ) { if ( ! ( other instanceof TObjectDoubleMap ) ) { return false ; } TObjectDoubleMap that = ( TObjectDoubleMap ) other ; if ( that . size ( ) ! = this . size ( ) ) { return false ; } try { TObjectDoubleIterator iter = this . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; Object key = iter . key ( ) ; double value = iter . value ( ) ; if ( value = = no _ entry _ value ) { if ( ! ( that . get ( key ) = = that . getNoEntryValue ( ) & & that . containsKey ( key ) ) ) { return false ; } } else { if ( value ! = that . get ( key ) ) { return false ; } } } } catch ( ClassCastException ex ) { unused . } return true ; } 
485	public void testValidEmailWithNoRecipients ( ) throws Exception { final TestRunner runner = TestRunners . newTestRunner ( new ExtractEmailHeaders ( ) ) ; runner . setProperty ( ExtractEmailHeaders . CAPTURED _ HEADERS , _STR ) ; } 
486	public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( _STR ) ; return sb . toString ( ) ; } 
487	public static XmlENTITIES parse ( java . net . URL u , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( XmlENTITIES ) XmlBeans . getContextTypeLoader ( ) . parse ( u , type , options ) ; } 
488	public static Expression bean ( Object bean , String method ) { BeanLanguage language = new BeanLanguage ( ) ; return language . createExpression ( bean , method ) ; } 
489	private void removeAt ( int i ) { The order of the edges is irrelevant , so we can simply replace the deleted edge with the rightmost element , thus achieving constant time . I tmpValue = neighbors . getElementTypeOps ( ) . create ( ) ; neighbors . popIntoW ( tmpValue ) ; if ( i ! = neighbors . size ( ) ) { neighbors . setW ( i , tmpValue ) ; } If needed after the removal , trim the array . trim ( ) ; } 
490	public < S > Observable < TupleN < Object > > getTupleN ( ) { return get ( Tuples . tupleN ( Object . class ) ) ; } 
491	public int putNumberFormat ( String fmt ) { Check if number format already exists if ( numberFormats . containsValue ( fmt ) ) { try { return getNumberFormatId ( fmt ) ; } catch ( final IllegalStateException e ) { throw new IllegalStateException ( _STR ) ; } formatIndex = ( short ) Math . max ( nextKey , FIRST _ USER _ DEFINED _ NUMBER _ FORMAT _ ID ) ; } numberFormats . put ( formatIndex , fmt ) ; return formatIndex ; } 
492	public V removeAt ( int index ) { final Object old = mArray [ ( index < < _NUM ) + _NUM ] ; if ( mSize < = _NUM ) { Now empty . if ( DEBUG ) Log . d ( TAG , _STR + index ) ; System . arraycopy ( mHashes , index + _NUM , mHashes , index , mSize - index ) ; System . arraycopy ( mArray , ( index + _NUM ) < < _NUM , mArray , index < < _NUM , ( mSize - index ) < < _NUM ) ; } mArray [ mSize < < _NUM ] = null ; mArray [ ( mSize < < _NUM ) + _NUM ] = null ; } } return ( V ) old ; } 
493	public void show ( ) { if ( mAnchorViewRef . get ( ) ! = null ) { mPopupContent = new PopupContentView ( mContext ) ; TextView body = ( TextView ) mPopupContent . findViewById ( R . id . com _ facebook _ tooltip _ bubble _ view _ text _ body ) ; body . setText ( mText ) ; if ( mStyle = = Style . BLUE ) { mPopupContent . bodyFrame . setBackgroundResource ( R . drawable . com _ facebook _ tooltip _ blue _ background ) ; mPopupContent . bottomArrow . setImageResource ( R . drawable . com _ facebook _ tooltip _ blue _ bottomnub ) ; mPopupContent . topArrow . setImageResource ( R . drawable . com _ facebook _ tooltip _ blue _ topnub ) ; mPopupContent . xOut . setImageResource ( R . drawable . com _ facebook _ tooltip _ blue _ xout ) ; } else { mPopupContent . bodyFrame . setBackgroundResource ( R . drawable . com _ facebook _ tooltip _ black _ background ) ; mPopupContent . bottomArrow . setImageResource ( R . drawable . com _ facebook _ tooltip _ black _ bottomnub ) ; mPopupContent . topArrow . setImageResource ( R . drawable . com _ facebook _ tooltip _ black _ topnub ) ; mPopupContent . xOut . setImageResource ( R . drawable . com _ facebook _ tooltip _ black _ xout ) ; } final Window window = ( ( Activity ) mContext ) . getWindow ( ) ; final View decorView = window . getDecorView ( ) ; final int decorWidth = decorView . getWidth ( ) ; final int decorHeight = decorView . getHeight ( ) ; registerObserver ( ) ; mPopupContent . onMeasure ( View . MeasureSpec . makeMeasureSpec ( decorWidth , View . MeasureSpec . AT _ MOST ) , View . MeasureSpec . makeMeasureSpec ( decorHeight , View . MeasureSpec . AT _ MOST ) ) ; mPopupWindow = new PopupWindow ( mPopupContent , mPopupContent . getMeasuredWidth ( ) , mPopupContent . getMeasuredHeight ( ) ) ; mPopupWindow . showAsDropDown ( mAnchorViewRef . get ( ) ) ; updateArrows ( ) ; if ( mNuxDisplayTime > _NUM ) { mPopupContent . postDelayed ( new Runnable ( ) { @ Override public void run ( ) { dismiss ( ) ; } } , mNuxDisplayTime ) ; } mPopupWindow . setTouchable ( true ) ; mPopupContent . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { dismiss ( ) ; } } ) ; } } 
494	private void stopDrag ( MotionEvent ev ) { mTouchMode = TOUCH _ MODE _ IDLE ; Commit the change if the event is up and not canceled and the switch has not been disabled during the drag . final boolean commitChange = ev . getAction ( ) = = MotionEvent . ACTION _ UP & & isEnabled ( ) ; final boolean oldState = isChecked ( ) ; final boolean newState ; if ( commitChange ) { mVelocityTracker . computeCurrentVelocity ( _NUM _NUM _NUM _NUM ) ; final float xvel = mVelocityTracker . getXVelocity ( ) ; if ( Math . abs ( xvel ) > mMinFlingVelocity ) { newState = isLayoutRtl ( ) ? ( xvel < _NUM ) : ( xvel > _NUM ) ; } else { newState = getTargetCheckedState ( ) ; } } else { newState = oldState ; } if ( newState ! = oldState ) { playSoundEffect ( SoundEffectConstants . CLICK ) ; } Always call setChecked so that the thumb is moved back to the correct edge setChecked ( newState ) ; cancelSuperTouch ( ev ) ; } 
495	public boolean next ( List < Cell > result , ScannerContext scannerContext ) throws IOException { if ( this . current = = null ) { return scannerContext . setScannerState ( NextState . NO _ MORE _ VALUES ) . hasMoreValues ( ) ; } InternalScanner currentAsInternal = ( InternalScanner ) this . current ; boolean moreCells = currentAsInternal . next ( result , scannerContext ) ; Cell pee = this . current . peek ( ) ; if ( pee = = null | | ! moreCells ) { add the scanner that is to be closed this . scannersForDelayedClose . add ( this . current ) ; } else { this . heap . add ( this . current ) ; } this . current = null ; this . current = pollRealKV ( ) ; if ( this . current = = null ) { moreCells = scannerContext . setScannerState ( NextState . NO _ MORE _ VALUES ) . hasMoreValues ( ) ; } return moreCells ; } 
496	public void testIsNullUUID ( ) { this test will test isNullUUID using the five main ways you could create a null UUID and test a case where it should NOT be true test using default constructor UUID uuid = nullUUID ; assertIsNullUUID ( uuid ) ; test by string creation using null uuid represented in string form uuid = UUIDUtil . uuid ( NULL _ UUID _ STRING ) ; assertIsNullUUID ( uuid ) ; test by byte [ ] creation using null uuid represented in byte [ ] form uuid = UUIDUtil . uuid ( NULL _ UUID _ BYTE _ ARRAY ) ; assertIsNullUUID ( uuid ) ; test by byte [ ] creation using null uuid represented in byte [ ] form starting at an offset byte [ ] null _ uuid _ array = new byte [ _NUM _NUM ] ; Arrays . fill ( null _ uuid _ array , _NUM , _NUM , ( byte ) ' x ' ) ; uuid = UUIDUtil . uuid ( null _ uuid _ array , _NUM ) ; assertIsNullUUID ( uuid ) ; test a not null case uuid = UUIDUtil . uuid ( VALID _ UUID _ BYTE _ ARRAY ) ; assertFalse ( _NUM L = = uuid . getMostSignificantBits ( ) ) ; assertFalse ( _NUM L = = uuid . getLeastSignificantBits ( ) ) ; } 
497	private void initializeLookAheadBuffer ( ) { for ( int i = _NUM ; i < lookAheadBufferSize ; i + + ) { Mark th entire buffer as being end of input . lookAheadBuffer [ i ] = END _ OF _ INPUT ; } for ( int i = _NUM ; i < lookAheadBufferSize ; i + + ) { Now fill the buffer ( if possible ) from the input . lookAheadBuffer [ i ] = readInput ( ) ; if ( isEndOfInput ( lookAheadBuffer [ i ] ) ) { The input is smaller than the buffer size break ; } } } 
498	private Format getFormat ( final String desc ) { if ( registry ! = null ) { String name = desc ; String args = null ; final int i = desc . indexOf ( START _ FMT ) ; if ( i > _NUM ) { name = desc . substring ( _NUM , i ) . trim ( ) ; args = desc . substring ( i + _NUM ) . trim ( ) ; } final FormatFactory factory = registry . get ( name ) ; if ( factory ! = null ) { return factory . getFormat ( name , args , getLocale ( ) ) ; } } return null ; } 
499	public endpoints where the only difference is the query parameter . Response initiateOrCompleteMultipartUpload ( @ PathParam ( _STR ) ; if ( uploads ! = null ) { return initiateMultipartUpload ( bucket , object ) ; } else { return completeMultipartUpload ( bucket , object , uploadId ) ; } } 
500	private UnfilteredRowIterator getThroughCache ( ColumnFamilyStore cfs , ReadExecutionController executionController ) { CASSANDRA - _NUM _NUM _NUM _NUM assert ! cfs . isIndex ( ) ; assert cfs . isRowCacheEnabled ( ) : String . format ( _STR ) ; return queryMemtableAndDisk ( cfs , executionController ) ; } 
501	public void store ( final SmtpResponse response , final String params ) { if ( params ! = null ) { if ( SmtpState . DATA _ HDR . equals ( response . getNextState ( ) ) ) { final int headerNameEnd = params . indexOf ( ' : ' ) ; if ( headerNameEnd > = _NUM ) { final String name = params . substring ( _NUM , headerNameEnd ) . trim ( ) ; final String value = params . substring ( headerNameEnd + _NUM ) . trim ( ) ; addHeader ( name , value ) ; } } else if ( SmtpState . DATA _ BODY = = response . getNextState ( ) ) { body . append ( params ) ; } } } 
502	public void removeData ( byte [ ] buf , int off , int len , int skip ) { read ( buf , off , len , skip ) ; removeData ( skip + len ) ; } 
503	public void testIterator _ Remove ( ) { Graph graph = graphWith ( producer . newInstance ( ) , _STR , graph , toRemove ) ; } catch ( UnsupportedOperationException e ) { No Iterator . remove } } 
504	protected Layout parseLayout ( Element layout _ element ) { String className = subst ( layout _ element . getAttribute ( CLASS _ ATTR ) ) ; LogLog . debug ( _STR , oops ) ; return null ; } } 
505	private static String generateEvent ( Long currTime , int delayInMillis ) { TeamInfo team = randomTeam ( liveTeams ) ; String teamName = team . getTeamName ( ) ; String user ; final int parseErrorRate = _NUM _NUM _NUM _NUM _NUM _NUM ; String robot = team . getRobot ( ) ; If the team has an associated robot team member . . . if ( robot ! = null ) { members , so that if there is a robot on the team , it has a higher click rate . if ( random . nextInt ( team . numMembers ( ) / _NUM ) = = _NUM ) { user = robot ; } else { user = team . getRandomUser ( ) ; } } else { No robot . user = team . getRandomUser ( ) ; } String event = user + _STR ; } return addTimeInfoToEvent ( event , currTime , delayInMillis ) ; } 
506	private void genPreambleStaticInitializers ( ) throws JasperException { out . printil ( _STR ) ; out . println ( ) ; } } 
507	private void mergeServiceWithStackServiceParent ( ServiceModule service , String parent , Map < String , StackModule > allStacks , Map < String , ServiceModule > commonServices , Map < String , ExtensionModule > extensions ) throws AmbariException { ServiceInfo serviceInfo = service . getModuleInfo ( ) ; String [ ] parentToks = parent . split ( StackManager . PATH _ DELIMITER ) ; if ( parentToks . length ! = _NUM | | parentToks [ _NUM ] . equalsIgnoreCase ( StackManager . EXTENSIONS ) | | parentToks [ _NUM ] . equalsIgnoreCase ( StackManager . COMMON _ SERVICES ) ) { throw new AmbariException ( _STR ) ; } service . resolveExplicit ( baseService , allStacks , commonServices , extensions ) ; } 
508	public boolean resume ( ) { if ( isPaused ( ) ) { startAnimateMove ( mEventCurrent ) ; return true ; } return false ; } 
509	private void buildCIDSet ( Map < Integer , Integer > cidToGid ) throws IOException { int cidMax = Collections . max ( cidToGid . keySet ( ) ) ; byte [ ] bytes = new byte [ cidMax / _NUM + _NUM ] ; for ( int cid = _NUM ; cid < = cidMax ; cid + + ) { int mask = _NUM < < _NUM - cid % _NUM ; bytes [ cid / _NUM ] | = mask ; } InputStream input = new ByteArrayInputStream ( bytes ) ; PDStream stream = new PDStream ( document , input , COSName . FLATE _ DECODE ) ; fontDescriptor . setCIDSet ( stream ) ; } 
510	public void testRoundSemiMonth ( ) throws Exception { final int calendarField = DateUtils . SEMI _ MONTH ; Date roundedUpDate , roundedDownDate , lastRoundedDownDate ; Date minDate , maxDate ; month with _NUM _NUM days ( _NUM ) roundedUpDate = dateTimeParser . parse ( _STR ) ; roundToJanuaryFirst ( minDate , maxDate , calendarField ) ; } 
511	private void animatePreLayout ( final float durationUnit , final Animator . AnimatorListener listener ) { final AnimatorSet animatorSet = new AnimatorSet ( ) ; final int firstVisiblePosition = getFirstVisiblePosition ( ) ; final int childCount = getChildCount ( ) ; for ( final Iterator < Entry < Long , Float > > iter = yMap . entrySet ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { final Entry < Long , Float > entry = iter . next ( ) ; final long id = entry . getKey ( ) ; final int oldPos = positionMap . get ( id ) ; final View child = getChildAt ( oldPos - firstVisiblePosition ) ; final int newPos = getPositionForId ( id ) ; fade out items that disappear if ( newPos = = - _NUM ) { final ObjectAnimator anim = animateAlpha ( child , false ) ; animatorSet . play ( anim ) ; iter . remove ( ) ; positionMap . remove ( id ) ; continue ; } translate items that move out of bounds if ( newPos < firstVisiblePosition | | newPos > firstVisiblePosition + childCount ) { final float offset ; if ( newPos < firstVisiblePosition ) { offset = - getHeight ( ) ; } else { offset = getHeight ( ) ; } final AnimatorProxy proxy = AnimatorProxy . wrap ( child ) ; final ObjectAnimator anim = ObjectAnimator . ofFloat ( proxy , _STR , _NUM f , offset ) ; final int finalDuration = getDuration ( _NUM , getHeight ( ) / _NUM , durationUnit ) ; anim . setInterpolator ( new AccelerateInterpolator ( ) ) ; anim . setDuration ( ( long ) ( finalDuration * animationDurationFactor ) ) ; animatorSet . addListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationEnd ( final Animator animation ) { child . post ( new Runnable ( ) { @ Override public void run ( ) { proxy . setTranslationY ( _NUM f ) ; } } ) ; } } ) ; animatorSet . play ( anim ) ; iter . remove ( ) ; positionMap . remove ( id ) ; continue ; } } if ( ! animatorSet . getChildAnimations ( ) . isEmpty ( ) ) { animatorSet . addListener ( listener ) ; animatorSet . start ( ) ; } else { listener . onAnimationEnd ( animatorSet ) ; } } 
512	public INDArray mmul ( INDArray other ) { FIXME : for _NUM D case , we probably want vector output here ? int [ ] shape = { rows ( ) , other . rank ( ) = = _NUM ? _NUM : other . columns ( ) } ; INDArray result = createUninitialized ( shape , ' f ' ) ; if ( result . isScalar ( ) ) return Nd _NUM j . scalar ( Nd _NUM j . getBlasWrapper ( ) . dot ( this , other ) ) ; return mmuli ( other , result ) ; } 
513	public boolean isSet ( _ Fields field ) { if ( field = = null ) { throw new java . lang . IllegalArgumentException ( ) ; } switch ( field ) { case LOGIN : return isSetLogin ( ) ; case TABLE _ NAME : return isSetTableName ( ) ; case START _ ROW : return isSetStartRow ( ) ; case END _ ROW : return isSetEndRow ( ) ; case WAIT : return isSetWait ( ) ; } throw new java . lang . IllegalStateException ( ) ; } 
514	public void adbBackup ( ParcelFileDescriptor fd , boolean includeApks , boolean includeObbs , boolean includeShared , boolean doWidgets , boolean doAllApps , boolean includeSystem , boolean compress , boolean doKeyValue , String [ ] pkgList ) { mContext . enforceCallingPermission ( android . Manifest . permission . BACKUP , _STR ) ; } } 
515	public Action getActionForKeyCode ( ObjectAdapter adapter , int keyCode ) { if ( adapter ! = mPrimaryActionsAdapter & & adapter ! = mSecondaryActionsAdapter ) { throw new IllegalArgumentException ( _STR ) ; } for ( int i = _NUM ; i < adapter . size ( ) ; i + + ) { Action action = ( Action ) adapter . get ( i ) ; if ( action . respondsToKeyCode ( keyCode ) ) { return action ; } } return null ; } 
516	public double getStartYValue ( int series , int item ) { if ( ! this . transposed ) { return getItemStartValue ( series , item ) ; } else { return getSeriesStartValue ( series ) ; } } 
517	public static boolean isStateCode ( String s ) { if ( isEmpty ( s ) ) return defaultEmptyOK ; return ( ( USStateCodes . indexOf ( s ) ! = - _NUM ) & & ( s . indexOf ( USStateCodeDelimiter ) = = - _NUM ) ) ; } 
518	public static void main ( String [ ] args ) throws IOException { suppress the Dock icon on OS X System . setProperty ( _STR ) ; ExportXFDF exporter = new ExportXFDF ( ) ; exporter . exportXFDF ( args ) ; } 
519	private boolean run ( ) throws YarnException , IOException { boolean success = false ; try { getAllTokens ( ) ; registerRMCallBackHandler ( ) ; registerNMCallbackHandler ( ) ; registerAMToRM ( ) ; madeAllContainerRequestToRM ( ) ; LOG . info ( _STR + done ) ; force kill , especially if got here by throw executor . shutdownNow ( ) ; } success = finish ( ) ; } return success ; } 
520	public RowPresenter . ViewHolder findRowViewHolderByPosition ( int position ) { if ( mVerticalGridView = = null ) { return null ; } return getRowViewHolder ( ( ItemBridgeAdapter . ViewHolder ) mVerticalGridView . findViewHolderForAdapterPosition ( position ) ) ; } 
521	public Multimap < String , String > assembleAllWatchKeys ( String appId , String clusterName , Set < String > namespaces , String dataCenter ) { Multimap < String , String > watchedKeysMap = assembleWatchKeys ( appId , clusterName , namespaces , dataCenter ) ; Every app has an ' application ' namespace if ( ! ( namespaces . size ( ) = = _NUM & & namespaces . contains ( ConfigConsts . NAMESPACE _ APPLICATION ) ) ) { Set < String > namespacesBelongToAppId = namespacesBelongToAppId ( appId , namespaces ) ; Set < String > publicNamespaces = Sets . difference ( namespaces , namespacesBelongToAppId ) ; Listen on more namespaces if it ' s a public namespace if ( ! publicNamespaces . isEmpty ( ) ) { watchedKeysMap . putAll ( findPublicConfigWatchKeys ( appId , clusterName , publicNamespaces , dataCenter ) ) ; } } return watchedKeysMap ; } 
522	protected int readAtOffset ( FSDataInputStream istream , byte [ ] dest , int destOffset , int size , boolean peekIntoNextBlock , long fileOffset , boolean pread ) throws IOException { if ( peekIntoNextBlock & & destOffset + size + hdrSize > dest . length ) { not enough room in the array . throw new IOException ( _STR ) ; } if ( ! peekIntoNextBlock ) { IOUtils . readFully ( istream , dest , destOffset , size ) ; return - _NUM ; } Try to read the next block header . if ( ! readWithExtra ( istream , dest , destOffset , size , hdrSize ) ) { return - _NUM ; } } else { Positional read . Better for random reads ; or when the streamLock is already locked . int extraSize = peekIntoNextBlock ? hdrSize : _NUM ; if ( ! positionalReadWithExtra ( istream , fileOffset , dest , destOffset , size , extraSize ) ) { return - _NUM ; } } assert peekIntoNextBlock ; return Bytes . toInt ( dest , destOffset + size + BlockType . MAGIC _ LENGTH ) + hdrSize ; } 
523	public RangeIterator < Long , Token > search ( Expression exp ) { assert mode . supports ( exp . getOp ( ) ) ; if ( exp . getOp ( ) = = Expression . Op . PREFIX & & mode = = OnDiskIndexBuilder . Mode . CONTAINS & & ! hasMarkedPartials ) throw new UnsupportedOperationException ( _STR ) RangeIterator < Long , Token > range = searchRange ( e ) ; if ( range ! = null ) builder . add ( range ) ; } return builder . build ( ) ; } 
524	public boolean containsDomainValue ( long millisecond ) { Segment segment = getSegment ( millisecond ) ; return segment . inIncludeSegments ( ) ; } 
525	public Intent execute ( Context context ) { double [ ] minValues = new double [ ] { - _NUM _NUM , - _NUM _NUM , - _NUM _NUM , - _NUM , _NUM , _NUM _NUM , _NUM _NUM , _NUM _NUM , _NUM , _NUM , - _NUM _NUM , - _NUM _NUM } ; double [ ] maxValues = new double [ ] { _NUM , _NUM _NUM , _NUM _NUM , _NUM _NUM , _NUM _NUM , _NUM _NUM , _NUM _NUM , _NUM _NUM , _NUM _NUM , _NUM _NUM , _NUM _NUM , _NUM } ; XYMultipleSeriesDataset dataset = new XYMultipleSeriesDataset ( ) ; RangeCategorySeries series = new RangeCategorySeries ( _STR ) ; } 
526	public static Object [ ] readAll ( InputStream stream ) throws Exception { ObjectInputStream ois ; Vector < Object > result ; if ( ! ( stream instanceof BufferedInputStream ) ) stream = new BufferedInputStream ( stream ) ; ois = new ObjectInputStream ( stream ) ; result = new Vector < Object > ( ) ; try { while ( true ) { result . add ( ois . readObject ( ) ) ; } } catch ( Exception e ) { ignored } ois . close ( ) ; return result . toArray ( new Object [ result . size ( ) ] ) ; } 
527	public boolean equals ( Object other ) { if ( ! ( other instanceof TObjectIntMap ) ) { return false ; } TObjectIntMap that = ( TObjectIntMap ) other ; if ( that . size ( ) ! = this . size ( ) ) { return false ; } try { TObjectIntIterator iter = this . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; Object key = iter . key ( ) ; int value = iter . value ( ) ; if ( value = = no _ entry _ value ) { if ( ! ( that . get ( key ) = = that . getNoEntryValue ( ) & & that . containsKey ( key ) ) ) { return false ; } } else { if ( value ! = that . get ( key ) ) { return false ; } } } } catch ( ClassCastException ex ) { unused . } return true ; } 
528	public void scheduleAfterOutputWouldBeProduced ( PCollection < ? > value , BoundedWindow window , WindowingStrategy < ? , ? > windowingStrategy , Runnable runnable ) { AppliedPTransform < ? , ? , ? > producing = graph . getProducer ( value ) ; callbackExecutor . callOnGuaranteedFiring ( producing , window , windowingStrategy , runnable ) ; fireAvailableCallbacks ( producing ) ; } 
529	public void onFinishedExpansionChange ( ) { mGroupExpansionChanging = false ; updateBackgroundForGroupState ( ) ; } 
530	public int uriIdForPrefix ( final byte [ ] prefix , final int pre , final Data data ) { return uriId ( prefix , cursor . find ( pre , data ) ) ; } 
531	public String sizeString ( String prefix ) { if ( getSize ( ) = = null ) return prefix ; if ( getSizeUnit ( ) = = Style . UNIT _ TYPE _ DIPS ) { return prefix + getSize ( ) + unitString ( ) ; } else if ( getSizeUnit ( ) = = StyleParser . UNIT _ INHERIT ) { return prefix ; } else { return prefix + getSize ( ) . intValue ( ) + unitString ( ) ; } } 
532	public void testReadingSourceTwice ( ) throws Exception { final String table = tmpTable . getName ( ) ; final int numRows = _NUM _NUM ; Set up test table data and sample row keys for size estimation and splitting . createTable ( table ) ; writeData ( table , numRows ) ; HBaseIO . Read read = HBaseIO . read ( ) . withConfiguration ( conf ) . withTableId ( table ) ; HBaseSource source = new HBaseSource ( read , null ) ; assertThat ( SourceTestUtils . readFromSource ( source , null ) , hasSize ( numRows ) ) ; second read . assertThat ( SourceTestUtils . readFromSource ( source , null ) , hasSize ( numRows ) ) ; } 
533	public static boolean equalIgnoreCase ( Object a , Object b ) { return equal ( a , b , true ) ; } 
534	public Object getAdapter ( Class adapter ) { we need to handle common GEF elements we created if ( adapter = = GraphicalViewer . class | | adapter = = EditPartViewer . class ) { return getGraphicalViewer ( ) ; } else if ( adapter = = CommandStack . class ) { return getCommandStack ( ) ; } else if ( adapter = = EditDomain . class ) { return getEditDomain ( ) ; } else if ( adapter = = ActionRegistry . class ) { return getActionRegistry ( ) ; } else if ( adapter = = IPropertySheetPage . class ) { return getPropertySheetPage ( ) ; } else if ( adapter = = IContentOutlinePage . class ) { return getOverviewOutlinePage ( ) ; } else if ( adapter = = ZoomManager . class ) { return getGraphicalViewer ( ) . getProperty ( ZoomManager . class . toString ( ) ) ; } else if ( IWorkbenchAdapter . class . equals ( adapter ) ) { return new WorkbenchAdapter ( ) { @ Override public String getLabel ( Object o ) { return _STR ; } } ; } the super implementation handles the rest return super . getAdapter ( adapter ) ; } 
535	public static XmlNMTOKEN parse ( java . io . File f , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( XmlNMTOKEN ) XmlBeans . getContextTypeLoader ( ) . parse ( f , type , options ) ; } 
536	public Map < String , Connection > getConnections ( AuthenticatedUser user , LDAPConnection ldapConnection ) throws GuacamoleException { Do not return any connections if base DN is not specified String configurationBaseDN = confService . getConfigurationBaseDN ( ) ; if ( configurationBaseDN = = null ) return Collections . < String , Connection > emptyMap ( ) ; try { Pull the current user DN from the LDAP connection String userDN = ldapConnection . getAuthenticationDN ( ) ; possibly be null assert ( userDN ! = null ) ; Get the search filter for finding connections accessible by the current user String connectionSearchFilter = getConnectionSearchFilter ( userDN , ldapConnection ) ; Find all Guacamole connections for the given user by looking for direct membership in the guacConfigGroup and possibly any groups the user is a member of that are referred to in the seeAlso attribute of the guacConfigGroup . LDAPSearchResults results = ldapConnection . search ( configurationBaseDN , LDAPConnection . SCOPE _ SUB , connectionSearchFilter , null , false , confService . getLDAPSearchConstraints ( ) ) ; Build token filter containing credential tokens TokenFilter tokenFilter = new TokenFilter ( ) ; StandardTokens . addStandardTokens ( tokenFilter , user ) ; Produce connections for each readable configuration Map < String , Connection > connections = new HashMap < String , Connection > ( ) ; while ( results . hasMore ( ) ) { try { LDAPEntry entry = results . next ( ) ; Get common name ( CN ) LDAPAttribute cn = entry . getAttribute ( _STR , e ) ; } } 
537	void startDataNode ( Configuration conf , List < StorageLocation > dataDirs , SecureResources resources ) throws IOException { settings global for all BPs in the Data Node this . secureResources = resources ; synchronized ( this ) { this . dataDirs = dataDirs ; } this . conf = conf ; this . dnConf = new DNConf ( conf ) ; checkSecureConfig ( dnConf , conf , resources ) ; this . spanReceiverHost = SpanReceiverHost . get ( conf , DFSConfigKeys . DFS _ SERVER _ HTRACE _ PREFIX ) ; if ( dnConf . maxLockedMemory > _NUM ) { if ( ! NativeIO . POSIX . getCacheManipulator ( ) . verifyCanMlock ( ) ) { throw new RuntimeException ( String . format ( _STR + supergroup ) ; initIpcServer ( conf ) ; metrics = DataNodeMetrics . create ( conf , getDisplayName ( ) ) ; metrics . getJvmMetrics ( ) . setPauseMonitor ( pauseMonitor ) ; blockPoolManager = new BlockPoolManager ( this ) ; blockPoolManager . refreshNamenodes ( conf ) ; Create the ReadaheadPool from the DataNode context so we can exit without having to explicitly shutdown its thread pool . readaheadPool = ReadaheadPool . getInstance ( ) ; saslClient = new SaslDataTransferClient ( dnConf . conf , dnConf . saslPropsResolver , dnConf . trustedChannelResolver ) ; saslServer = new SaslDataTransferServer ( dnConf , blockPoolTokenSecretManager ) ; } 
538	public void testIsAtLeastOneActive ( ) throws Exception { MiniDFSCluster cluster = new MiniDFSCluster . Builder ( new HdfsConfiguration ( ) ) . nnTopology ( MiniDFSNNTopology . simpleHATopology ( ) ) . numDataNodes ( _NUM ) . build ( ) ; try { Configuration conf = new HdfsConfiguration ( ) ; HATestUtil . setFailoverConfigurations ( cluster , conf ) ; List < ClientProtocol > namenodes = HAUtil . getProxiesForAllNameNodesInNameservice ( conf , HATestUtil . getLogicalHostname ( cluster ) ) ; assertEquals ( _NUM , namenodes . size ( ) ) ; assertFalse ( HAUtil . isAtLeastOneActive ( namenodes ) ) ; cluster . transitionToActive ( _NUM ) ; assertTrue ( HAUtil . isAtLeastOneActive ( namenodes ) ) ; cluster . transitionToStandby ( _NUM ) ; assertFalse ( HAUtil . isAtLeastOneActive ( namenodes ) ) ; cluster . transitionToActive ( _NUM ) ; assertTrue ( HAUtil . isAtLeastOneActive ( namenodes ) ) ; cluster . transitionToStandby ( _NUM ) ; assertFalse ( HAUtil . isAtLeastOneActive ( namenodes ) ) ; } finally { if ( cluster ! = null ) { cluster . shutdown ( ) ; } } } 
539	private < CResult > AsyncRequestFuture submit ( AsyncProcessTask < CResult > task , boolean atLeastOne ) throws InterruptedIOException { TableName tableName = task . getTableName ( ) ; RowAccess < ? extends Row > rows = task . getRowAccess ( ) ; Map < ServerName , MultiAction > actionsByServer = new HashMap < > ( ) ; List < Action > retainedActions = new ArrayList < > ( rows . size ( ) ) ; NonceGenerator ng = this . connection . getNonceGenerator ( ) ; Currently , nonce group is per entire client . long nonceGroup = ng . getNonceGroup ( ) ; Location errors that happen before we decide what requests to take . List < Exception > locationErrors = null ; List < Integer > locationErrorRows = null ; RequestController . Checker checker = requestController . newChecker ( ) ; boolean firstIter = true ; do { Wait until there is at least one slot for a new task . requestController . waitForFreeSlot ( id , periodToLog , getLogger ( tableName , - _NUM ) ) ; int posInList = - _NUM ; if ( ! firstIter ) { checker . reset ( ) ; } Iterator < ? extends Row > it = rows . iterator ( ) ; while ( it . hasNext ( ) ) { Row r = it . next ( ) ; HRegionLocation loc ; try { if ( r = = null ) { throw new IllegalArgumentException ( _STR , ex ) ; This action failed before creating ars . Retain it , but do not add to submit list . We will then add it to ars in an already - failed state . int priority = HConstants . NORMAL _ QOS ; if ( r instanceof Mutation ) { priority = ( ( Mutation ) r ) . getPriority ( ) ; } retainedActions . add ( new Action ( r , + + posInList , priority ) ) ; locationErrors . add ( ex ) ; locationErrorRows . add ( posInList ) ; it . remove ( ) ; Backward compat : we stop considering actions on location error . break ; } ReturnCode code = checker . canTakeRow ( loc , r ) ; if ( code = = ReturnCode . END ) { break ; } if ( code = = ReturnCode . INCLUDE ) { int priority = HConstants . NORMAL _ QOS ; if ( r instanceof Mutation ) { priority = ( ( Mutation ) r ) . getPriority ( ) ; } Action action = new Action ( r , + + posInList , priority ) ; setNonce ( ng , r , action ) ; retainedActions . add ( action ) ; TODO : replica - get is not supported on this path byte [ ] regionName = loc . getRegionInfo ( ) . getRegionName ( ) ; addAction ( loc . getServerName ( ) , regionName , action , actionsByServer , nonceGroup ) ; it . remove ( ) ; } } firstIter = false ; } while ( retainedActions . isEmpty ( ) & & atLeastOne & & ( locationErrors = = null ) ) ; if ( retainedActions . isEmpty ( ) ) return NO _ REQS _ RESULT ; return submitMultiActions ( task , retainedActions , nonceGroup , locationErrors , locationErrorRows , actionsByServer ) ; } 
540	protected void saveHistory ( ) { BufferedOutputStream str ; try { str = new BufferedOutputStream ( new FileOutputStream ( getHistoryFilename ( ) ) ) ; m _ History . store ( str , _STR ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } 
541	 @ SuppressWarnings ( _STR ; final NoSqlDatabaseManager < ? > manager = NoSqlDatabaseManager . getNoSqlDatabaseManager ( managerName , bufferSizeInt , provider ) ; if ( manager = = null ) { return null ; } return new NoSqlAppender ( name , filter , null , ignoreExceptions , manager ) ; } 
542	public CipherParameters generateDerivedMacParameters ( int keySize ) { return generateDerivedParameters ( keySize ) ; } 
543	public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( ! ( o instanceof ConstantScorePrefixQuery ) ) return false ; ConstantScorePrefixQuery other = ( ConstantScorePrefixQuery ) o ; return this . prefix . equals ( other . prefix ) & & this . getBoost ( ) = = other . getBoost ( ) ; } 
544	protected void adjustHeight ( ) { if ( ( m _ scrollPanel ! = null ) & & ( m _ resourceItem ! = null ) ) { m _ scrollPanel . getElement ( ) . getStyle ( ) . setPropertyPx ( _STR , getAvailableHeight ( m _ resourceItem . getOffsetHeight ( ) ) ) ; } center ( ) ; } 
545	public Schedule getSchedule ( final int scheduleId ) throws ScheduleManagerException { updateLocal ( ) ; return this . scheduleIDMap . get ( scheduleId ) ; } 
546	public void awaitResponses ( ) throws ReadTimeoutException { try { handler . awaitResults ( ) ; } catch ( ReadTimeoutException e ) { try { onReadTimeout ( ) ; } finally { throw e ; } } return immediately , or begin a read repair if ( digestResolver . responsesMatch ( ) ) { setResult ( digestResolver . getData ( ) ) ; } else { Tracing . trace ( _STR , getKey ( ) ) ; readRepair . startForegroundRepair ( digestResolver , handler . endpoints , getContactedReplicas ( ) , this : : setResult ) ; } } 
547	public void verifyAnnotationTransformerMethod ( ) { TestNG tng = create ( AnnotationTransformerSampleTest . class ) ; tng . setPreserveOrder ( true ) ; MyTransformer transformer = new MyTransformer ( ) ; tng . addListener ( transformer ) ; TestListenerAdapter tla = new TestListenerAdapter ( ) ; tng . addListener ( ( ITestNGListener ) tla ) ; tng . run ( ) ; assertThat ( transformer . getMethodNames ( ) ) . contains ( _STR ) ; assertThat ( tla . getFailedTests ( ) ) . isEmpty ( ) ; } 
548	protected static ElementPair fromEncodedJson ( String encoded ) { ObjectMapper mapper = SequenceElement . mapper ( ) ; try { String decoded = new String ( Base _NUM _NUM . decodeBase _NUM _NUM ( encoded ) , _STR ) ; return mapper . readValue ( decoded , ElementPair . class ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } 
549	public void createSubEntry ( final CmsClientSitemapEntry parent , final CmsUUID structureId ) { final CmsClientSitemapEntry newEntry = new CmsClientSitemapEntry ( ) ; CmsSitemapTreeItem item = CmsSitemapTreeItem . getItemById ( parent . getId ( ) ) ; AsyncCallback < CmsClientSitemapEntry > callback = new AsyncCallback < CmsClientSitemapEntry > ( ) { public void onFailure ( Throwable caught ) { nothing to do } public void onSuccess ( CmsClientSitemapEntry result ) { String urlName = ensureUniqueName ( parent , NEW _ ENTRY _ NAME ) ; newEntry . setTitle ( urlName ) ; newEntry . setName ( urlName ) ; String sitePath = parent . getSitePath ( ) + urlName + _STR ) ; newEntry . getOwnProperties ( ) . put ( CmsClientProperty . PROPERTY _ TITLE , new CmsClientProperty ( CmsClientProperty . PROPERTY _ TITLE , NEW _ ENTRY _ NAME , NEW _ ENTRY _ NAME ) ) ; create ( newEntry , parent . getId ( ) , structureId ) ; } } ; if ( item . getLoadState ( ) . equals ( LoadState . UNLOADED ) ) { getChildren ( parent . getId ( ) , true , callback ) ; } else { callback . onSuccess ( parent ) ; } } 
550	private boolean inlineLets ( final CompileContext cc ) throws QueryException { boolean changed = false , changing ; do { changing = false ; final ListIterator < Clause > iter = clauses . listIterator ( ) ; while ( iter . hasNext ( ) ) { final Clause clause = iter . next ( ) ; final int next = iter . nextIndex ( ) ; if ( clause instanceof Let ) { final Let lt = ( Let ) clause ; final Expr expr = lt . expr ; if ( expr . has ( Flag . NDT ) ) continue ; if ( inline simple values expr instanceof Value | | inline variable references without type checks expr instanceof VarRef & & ! lt . var . checksType ( ) | | - construct nodes ( e . g . let $ x : = < X / > return < X xmlns = ' xx ' > { $ x / self : : X } < / X > ) count ( lt . var , next ) = = VarUsage . ONCE & & ! expr . has ( Flag . CTX , Flag . CNS ) | | inline only cheap axis paths expr instanceof AxisPath & & ( ( AxisPath ) expr ) . cheap ( ) ) { cc . info ( QueryText . OPTINLINE _ X , lt . var ) ; inline ( cc , lt . var , lt . inlineExpr ( cc ) , iter ) ; clauses . remove ( lt ) ; changing = changed = true ; continue from the beginning as clauses below could have been deleted break ; } } } } while ( changing ) ; return changed ; } 
551	private void tryComputeMaxWidth ( ) { if ( ! mComputeMaxWidth ) { return ; } int maxTextWidth = _NUM ; if ( mDisplayedValues = = null ) { float maxDigitWidth = _NUM ; for ( int i = _NUM ; i < = _NUM ; i + + ) { final float digitWidth = mSelectorWheelPaint . measureText ( formatNumberWithLocale ( i ) ) ; if ( digitWidth > maxDigitWidth ) { maxDigitWidth = digitWidth ; } } int numberOfDigits = _NUM ; int current = mMaxValue ; while ( current > _NUM ) { numberOfDigits + + ; current = current / _NUM _NUM ; } maxTextWidth = ( int ) ( numberOfDigits * maxDigitWidth ) ; } else { final int valueCount = mDisplayedValues . length ; for ( int i = _NUM ; i < valueCount ; i + + ) { final float textWidth = mSelectorWheelPaint . measureText ( mDisplayedValues [ i ] ) ; if ( textWidth > maxTextWidth ) { maxTextWidth = ( int ) textWidth ; } } } maxTextWidth + = mInputText . getPaddingLeft ( ) + mInputText . getPaddingRight ( ) ; if ( mMaxWidth ! = maxTextWidth ) { if ( maxTextWidth > mMinWidth ) { mMaxWidth = maxTextWidth ; } else { mMaxWidth = mMinWidth ; } invalidate ( ) ; } } 
552	public static void createAndVerifyFile ( FileSystem fs , Path parent , final long fileSize ) throws IOException { int testBufferSize = fs . getConf ( ) . getInt ( IO _ CHUNK _ BUFFER _ SIZE , DEFAULT _ IO _ CHUNK _ BUFFER _ SIZE ) ; int modulus = fs . getConf ( ) . getInt ( IO _ CHUNK _ MODULUS _ SIZE , DEFAULT _ IO _ CHUNK _ MODULUS _ SIZE ) ; final String objectName = UUID . randomUUID ( ) . toString ( ) ; final Path objectPath = new Path ( parent , objectName ) ; Write test file in a specific pattern assertEquals ( fileSize , generateTestFile ( fs , objectPath , fileSize , testBufferSize , modulus ) ) ; assertPathExists ( fs , _STR , objectPath ) ; Now read the same file back and verify its content try { verifyReceivedData ( fs , objectPath , fileSize , testBufferSize , modulus ) ; } finally { Delete test file fs . delete ( objectPath , false ) ; } } 
553	public static StringBuilder box ( final double value ) { return getSB ( ) . append ( value ) ; } 
554	public boolean input ( Instance instance ) { if ( getInputFormat ( ) = = null ) { throw new IllegalStateException ( _STR ) ; } if ( m _ NewBatch ) { resetQueue ( ) ; m _ NewBatch = false ; } if ( isFirstBatchDone ( ) ) { push ( instance ) ; return true ; } else { bufferInput ( instance ) ; copyValues ( instance , false ) ; processInstance ( instance ) ; return false ; } } 
555	private void removeKerberosArtifact ( Cluster cluster ) throws AmbariException { PredicateBuilder pb = new PredicateBuilder ( ) ; Predicate predicate = pb . begin ( ) . property ( _STR , e ) ; } } 
556	private void handleSetOccluded ( boolean isOccluded , boolean animate ) { Trace . beginSection ( _STR ) ; synchronized ( KeyguardViewMediator . this ) { if ( mHiding & & isOccluded ) { We ' re in the process of going away but WindowManager wants to show a SHOW _ WHEN _ LOCKED activity instead . startKeyguardExitAnimation ( _NUM , _NUM ) ; } if ( mOccluded ! = isOccluded ) { mOccluded = isOccluded ; mUpdateMonitor . setKeyguardOccluded ( isOccluded ) ; mStatusBarKeyguardViewManager . setOccluded ( isOccluded , animate & & mDeviceInteractive ) ; adjustStatusBarLocked ( ) ; } } Trace . endSection ( ) ; } 
557	public void setSheetName ( ) throws IOException { Workbook wb _NUM = newSetSheetNameTestingWorkbook ( ) ; Sheet sh _NUM = wb _NUM . getSheetAt ( _NUM ) ; Name sale _ _NUM = wb _NUM . getNameAt ( _NUM ) ; Name sale _ _NUM = wb _NUM . getNameAt ( _NUM ) ; Name sale _ _NUM = wb _NUM . getNameAt ( _NUM ) ; assertEquals ( _STR , cell _NUM . getCellFormula ( ) ) ; evaluator = wb _NUM . getCreationHelper ( ) . createFormulaEvaluator ( ) ; assertEquals ( _NUM . _NUM , evaluator . evaluate ( cell _NUM ) . getNumberValue ( ) , _NUM ) ; assertEquals ( _NUM _NUM . _NUM , evaluator . evaluate ( cell _NUM ) . getNumberValue ( ) , _NUM ) ; assertEquals ( _NUM . _NUM , evaluator . evaluate ( cell _NUM ) . getNumberValue ( ) , _NUM ) ; wb _NUM . close ( ) ; } 
558	public static Formatter formatDateRange ( Context context , Formatter formatter , long startMillis , long endMillis , int flags , String timeZone ) { but we want to fall back to the user ' s preference . if ( ( flags & ( FORMAT _ SHOW _ TIME | FORMAT _ _NUM _NUM HOUR | FORMAT _ _NUM _NUM HOUR ) ) = = FORMAT _ SHOW _ TIME ) { flags | = DateFormat . is _NUM _NUM HourFormat ( context ) ? FORMAT _ _NUM _NUM HOUR : FORMAT _ _NUM _NUM HOUR ; } String range = DateIntervalFormat . formatDateRange ( startMillis , endMillis , flags , timeZone ) ; try { formatter . out ( ) . append ( range ) ; } catch ( IOException impossible ) { throw new AssertionError ( impossible ) ; } return formatter ; } 
559	private static QuotaCounts computeQuotaDeltaForUCBlock ( FSNamesystem fsn , INodeFile file ) { final QuotaCounts delta = new QuotaCounts . Builder ( ) . build ( ) ; final BlockInfo lastBlock = file . getLastBlock ( ) ; if ( lastBlock ! = null ) { final long diff = file . getPreferredBlockSize ( ) - lastBlock . getNumBytes ( ) ; final short repl = file . getPreferredBlockReplication ( ) ; delta . addStorageSpace ( diff * repl ) ; final BlockStoragePolicy policy = fsn . getFSDirectory ( ) . getBlockStoragePolicySuite ( ) . getPolicy ( file . getStoragePolicyID ( ) ) ; List < StorageType > types = policy . chooseStorageTypes ( repl ) ; for ( StorageType t : types ) { if ( t . supportTypeQuota ( ) ) { delta . addTypeSpace ( t , diff ) ; } } } return delta ; } 
560	public void testMultiThreadedOperation ( ) throws Exception { for ( int iter = _NUM ; iter < _NUM _NUM ; iter + + ) { final int numThreads = _NUM _NUM ; Thread [ ] threads = new Thread [ numThreads ] ; final ConcurrentLinkedQueue < Throwable > exceptionsEncountered = new ConcurrentLinkedQueue < Throwable > ( ) ; for ( int i = _NUM ; i < numThreads ; i + + ) { final Path threadLocalFile = new Path ( _STR , selectToString ( exceptionsEncountered ) ) , exceptionsEncountered . isEmpty ( ) ) ; tearDown ( ) ; setUp ( ) ; } } 
561	protected void onSetCurrentPositionLabel ( long currentTimeMs ) { if ( mCurrentTime ! = null ) { formatTime ( currentTimeMs , mTempBuilder ) ; mCurrentTime . setText ( mTempBuilder . toString ( ) ) ; } } 
562	public void setProgressCallback ( ProgressCallback callback , @ Nullable Executor executor ) { boolean shouldInvoke ; int num ; boolean mined ; synchronized ( this ) { this . callback = callback ; this . progressCallbackExecutor = executor ; num = this . numSeemPeers ; mined = this . mined ; shouldInvoke = numWaitingFor > _NUM ; } if ( shouldInvoke ) invokeProgressCallback ( num , mined ) ; } 
563	public Map < String , Object > toMap ( int maxCols ) { start with the fingerpring map and build on top of it Map < String , Object > map = getFingerprint ( ) ; map from families to column list replaces fingerprint ' s list of families Map < String , List < String > > familyColumns = new HashMap < > ( ) ; map . put ( _STR , getId ( ) ) ; } return map ; } 
564	public FlexibleAdapter < T > setDisplayHeadersAtStartUp ( boolean displayHeaders ) { if ( ! headersShown & & displayHeaders ) { showAllHeaders ( true ) ; } return this ; } 
565	public int numSections ( ) { initSections ( ) ; return _ sectionEnd - _ sectionStart ; } 
566	 $ ANTLR start _STR , retval ! = null ? retval . tree : null ) ; root _ _NUM = ( Object ) adaptor . nil ( ) ; _NUM _NUM _NUM : _NUM : - > ^ ( T _ ORDER _ BY _ FIELD [ ] path _ expression ' DESC ' ) { JPA . g : _NUM _NUM _NUM : _NUM : ^ ( T _ ORDER _ BY _ FIELD [ ] path _ expression ' DESC ' ) { Object root _ _NUM = ( Object ) adaptor . nil ( ) ; root _ _NUM = ( Object ) adaptor . becomeRoot ( new OrderByFieldNode ( T _ ORDER _ BY _ FIELD ) , root _ _NUM ) ; adaptor . addChild ( root _ _NUM , stream _ path _ expression . nextTree ( ) ) ; adaptor . addChild ( root _ _NUM , stream _ DESC . nextNode ( ) ) ; adaptor . addChild ( root _ _NUM , root _ _NUM ) ; } } retval . tree = root _ _NUM ; } } break ; } retval . stop = input . LT ( - _NUM ) ; if ( state . backtracking = = _NUM ) { retval . tree = ( Object ) adaptor . rulePostProcessing ( root _ _NUM ) ; adaptor . setTokenBoundaries ( retval . tree , retval . start , retval . stop ) ; } } catch ( RecognitionException re ) { reportError ( re ) ; recover ( input , re ) ; retval . tree = ( Object ) adaptor . errorNode ( input , retval . start , input . LT ( - _NUM ) , re ) ; } finally { } return retval ; } 
567	public void hmacSHA _NUM _NUM _NUM hex ( ) { query ( _STR ) ; } 
568	public void increaseCount ( int recursionLevel , int incr ) { if ( recursionLevel = = m _ counts . size ( ) ) { new element m _ counts . add ( incr ) ; } else if ( recursionLevel = = m _ counts . size ( ) - _NUM ) { otherwise increment the top int n = m _ counts . get ( recursionLevel ) . intValue ( ) ; m _ counts . set ( recursionLevel , ( n + incr ) ) ; } } 
569	public void animateRemovePendingItem ( ) { removePreviousContextualUndoIfPresent ( ) ; } 
570	public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( _STR ) ; return sb . toString ( ) ; } 
571	private void readPayload ( ) throws IOException , InterruptedException { if ( incomingBuffer . remaining ( ) ! = _NUM ) { have we read length bytes ? sock is non - blocking , so ok int rc = sock . read ( incomingBuffer ) ; if ( rc < _NUM ) { throw new EndOfStreamException ( _STR ) ; } } if ( incomingBuffer . remaining ( ) = = _NUM ) { have we read length bytes ? packetReceived ( ) ; incomingBuffer . flip ( ) ; if ( ! initialized ) { readConnectRequest ( ) ; } else { readRequest ( ) ; } lenBuffer . clear ( ) ; incomingBuffer = lenBuffer ; } } 
572	protected boolean _ hasTablePermission ( String user , Table . ID table , TablePermission permission , boolean useCached ) throws ThriftSecurityException { targetUserExists ( user ) ; if ( ( table . equals ( MetadataTable . ID ) | | table . equals ( RootTable . ID ) | | table . equals ( ReplicationTable . ID ) ) & & permission . equals ( TablePermission . READ ) ) return true ; try { if ( useCached ) return permHandle . hasCachedTablePermission ( user , table . canonicalID ( ) , permission ) ; return permHandle . hasTablePermission ( user , table . canonicalID ( ) , permission ) ; } catch ( AccumuloSecurityException e ) { throw e . asThriftException ( ) ; } catch ( TableNotFoundException e ) { throw new ThriftSecurityException ( user , SecurityErrorCode . TABLE _ DOESNT _ EXIST ) ; } } 
573	protected List < Job > poll ( int limit ) { assertIsRunning ( ) ; The rest of this method logs exceptions and does not throw them . The idea is to keep the JobPoller working even when a database connection is not available ( possible on a saturated server ) . DispatchContext dctx = getDispatcher ( ) . getDispatchContext ( ) ; if ( dctx = = null ) { Debug . logWarning ( _STR , module ) ; } Debug . logWarning ( t , errMsg , module ) ; return Collections . emptyList ( ) ; } finally { if ( jobsIterator ! = null ) { try { jobsIterator . close ( ) ; } catch ( GenericEntityException e ) { Debug . logWarning ( e , module ) ; } } } } return poll ; } 
574	public void setTotalWidth ( float [ ] columnWidth ) throws DocumentException { if ( columnWidth . length ! = getNumberOfColumns ( ) ) throw new DocumentException ( MessageLocalization . getComposedMessage ( _STR ) ) ; totalWidth = _NUM ; for ( int k = _NUM ; k < columnWidth . length ; + + k ) totalWidth + = columnWidth [ k ] ; setWidths ( columnWidth ) ; } 
575	public Answer createVolume ( CreateObjectCommand cmd ) { LOGGER . debug ( _STR + e . toString ( ) , e ) ; return new CreateObjectAnswer ( e . toString ( ) ) ; } } 
576	public void clearGrantedUriPermissions ( String packageName ) { try { getService ( ) . clearGrantedUriPermissions ( packageName , UserHandle . myUserId ( ) ) ; } catch ( RemoteException e ) { throw e . rethrowFromSystemServer ( ) ; } } 
577	public void testFileUpdate ( ) throws Exception { checkAndNotify ( ) ; checkCollectionsEmpty ( _STR , listener . getChangedFiles ( ) . contains ( testDirAFile _NUM ) ) ; } 
578	public Endpoint getInternalEndpoint ( String api ) { return findByAPI ( internal , api ) ; } 
579	protected boolean hasNextBinding ( ) { Needs to be idempotent . ? if ( isFinished ( ) ) return false ; if ( nextBinding ! = null ) return true ; Null iterator . if ( getInput ( ) = = null ) throw new ARQInternalErrorException ( Lib . className ( this ) + _STR ) ; while ( getInput ( ) . hasNext ( ) ) { Skip forward until a binding to return is found . Binding input = getInput ( ) . nextBinding ( ) ; Binding output = accept ( input ) ; if ( output ! = null ) { nextBinding = output ; return true ; } } nextBinding = null ; return false ; } 
580	public ArrayList < PackagePart > getPartsByContentType ( String contentType ) { ArrayList < PackagePart > retArr = new ArrayList < > ( ) ; for ( PackagePart part : partList . sortedValues ( ) ) { if ( part . getContentType ( ) . equals ( contentType ) ) { retArr . add ( part ) ; } } return retArr ; } 
581	public void onConfigurationChanged ( Configuration newConfig ) { super . onConfigurationChanged ( newConfig ) ; mFragments . dispatchConfigurationChanged ( newConfig ) ; } 
582	private void handleCellSwitch ( ) { final int deltaY = mLastEventY - mDownY ; int deltaYTotal = mHoverCellOriginalBounds . top + mTotalOffset + deltaY ; View belowView = getViewForId ( mBelowItemId ) ; View mobileView = getViewForId ( mMobileItemId ) ; View aboveView = getViewForId ( mAboveItemId ) ; boolean isBelow = ( belowView ! = null ) & & ( deltaYTotal > belowView . getTop ( ) ) ; boolean isAbove = ( aboveView ! = null ) & & ( deltaYTotal < aboveView . getTop ( ) ) ; if ( isBelow | | isAbove ) { final long switchItemId = isBelow ? mBelowItemId : mAboveItemId ; View switchView = isBelow ? belowView : aboveView ; final int originalItem = getPositionForView ( mobileView ) ; if ( switchView = = null ) { updateNeighborViewsForId ( mMobileItemId ) ; return ; } if ( getPositionForView ( switchView ) < getHeaderViewsCount ( ) ) { return ; } swapElements ( originalItem , getPositionForView ( switchView ) ) ; BaseAdapter adapter ; if ( getAdapter ( ) instanceof HeaderViewListAdapter ) { adapter = ( BaseAdapter ) ( ( HeaderViewListAdapter ) getAdapter ( ) ) . getWrappedAdapter ( ) ; } else { adapter = ( BaseAdapter ) getAdapter ( ) ; } adapter . notifyDataSetChanged ( ) ; mDownY = mLastEventY ; mDownX = mLastEventX ; final int switchViewStartTop = switchView . getTop ( ) ; mobileView . setVisibility ( View . VISIBLE ) ; switchView . setVisibility ( View . INVISIBLE ) ; updateNeighborViewsForId ( mMobileItemId ) ; final ViewTreeObserver observer = getViewTreeObserver ( ) ; observer . addOnPreDrawListener ( new ViewTreeObserver . OnPreDrawListener ( ) { public boolean onPreDraw ( ) { observer . removeOnPreDrawListener ( this ) ; View switchView = getViewForId ( switchItemId ) ; mTotalOffset + = deltaY ; int switchViewNewTop = switchView . getTop ( ) ; int delta = switchViewStartTop - switchViewNewTop ; ViewHelper . setTranslationY ( switchView , delta ) ; ObjectAnimator animator = ObjectAnimator . ofFloat ( switchView , _STR , _NUM ) ; animator . setDuration ( MOVE _ DURATION ) ; animator . start ( ) ; return true ; } } ) ; } } 
583	public static List < Integer > getOriginalIndexes ( int samplingLevel ) { List < Integer > originalIndexes = originalIndexCache . get ( samplingLevel ) ; if ( originalIndexes ! = null ) return originalIndexes ; List < Integer > pattern = getSamplingPattern ( BASE _ SAMPLING _ LEVEL ) . subList ( _NUM , BASE _ SAMPLING _ LEVEL - samplingLevel ) ; originalIndexes = new ArrayList < > ( samplingLevel ) ; for ( int j = _NUM ; j < BASE _ SAMPLING _ LEVEL ; j + + ) { if ( ! pattern . contains ( j ) ) originalIndexes . add ( j ) ; } originalIndexCache . put ( samplingLevel , originalIndexes ) ; return originalIndexes ; } 
584	private void applyStyleAttribute ( HTMLElement element , HTMLComponent htmlC ) { String styleStr = element . getAttributeById ( HTMLElement . ATTR _ STYLE ) ; if ( styleStr ! = null ) { CSSElement style = null ; So it will be parsed correctly styleStr = _STR ; try { style = CSSParser . getInstance ( ) . parseCSS ( new InputStreamReader ( new ByteArrayInputStream ( styleStr . getBytes ( ) ) ) , htmlC ) ; applyStyle ( element , style , htmlC ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } } 
585	void goToAnchor ( String anchorName ) { Label anchorCmp = ( Label ) anchors . get ( anchorName ) ; if ( anchorCmp ! = null ) { int cx = anchorCmp . getX ( ) ; int cy = anchorCmp . getY ( ) ; int h = getHeight ( ) ; if ( anchorCmp . getAbsoluteY ( ) - getY ( ) + h > getPreferredH ( ) ) { h = getPreferredH ( ) - ( anchorCmp . getAbsoluteY ( ) - getY ( ) ) ; } scrollRectToVisible ( cx , cy , getWidth ( ) , h , anchorCmp ) ; } } 
586	public static IComplexNDArray createComplex ( INDArray arr ) { if ( arr instanceof IComplexNDArray ) return ( IComplexNDArray ) arr ; IComplexNDArray ret = INSTANCE . createComplex ( arr ) ; logCreationIfNecessary ( ret ) ; return ret ; } 
587	protected List < ProviderGroup > subscribeFromDirectUrl ( String directUrl ) { List < ProviderGroup > result = new ArrayList < ProviderGroup > ( ) ; List < ProviderInfo > tmpProviderInfoList = new ArrayList < ProviderInfo > ( ) ; String [ ] providerStrs = StringUtils . splitWithCommaOrSemicolon ( directUrl ) ; for ( String providerStr : providerStrs ) { ProviderInfo providerInfo = convertToProviderInfo ( providerStr ) ; if ( providerInfo . getStaticAttr ( ProviderInfoAttrs . ATTR _ SOURCE ) = = null ) { providerInfo . setStaticAttr ( ProviderInfoAttrs . ATTR _ SOURCE , _STR ) ; } tmpProviderInfoList . add ( providerInfo ) ; } result . add ( new ProviderGroup ( RpcConstants . ADDRESS _ DIRECT _ GROUP , tmpProviderInfoList ) ) ; return result ; } 
588	public void initialize ( final int whichUser ) { TODO : http : if ( whichUser = = UserHandle . USER _ SYSTEM ) { Does this product support backup / restore at all ? if ( mGlobalDisable ) { Slog . i ( TAG , _STR + whichUser ) ; } } } } 
589	public INDArray divi ( INDArray other , INDArray result ) { if ( other . isScalar ( ) ) { return divi ( other . getDouble ( _NUM ) , result ) ; } if ( isScalar ( ) ) { return other . rdivi ( getDouble ( _NUM ) , result ) ; } if ( ! Shape . shapeEquals ( this . shape ( ) , other . shape ( ) ) ) { int [ ] broadcastDimensions = Shape . getBroadcastDimensions ( this . shape ( ) , other . shape ( ) ) ; Nd _NUM j . getExecutioner ( ) . exec ( new BroadcastDivOp ( this , other , result , broadcastDimensions ) , broadcastDimensions ) ; return result ; } LinAlgExceptions . assertSameShape ( other , result ) ; Nd _NUM j . getExecutioner ( ) . exec ( new OldDivOp ( this , other , result , length ( ) ) ) ; if ( Nd _NUM j . ENFORCE _ NUMERICAL _ STABILITY ) Nd _NUM j . clearNans ( result ) ; return result ; } 
590	public void setErrorHandlerLoggingLevel ( LoggingLevel errorHandlerLoggingLevel ) { getConfiguration ( ) . setErrorHandlerLoggingLevel ( errorHandlerLoggingLevel ) ; } 
591	private void postSuperstepCallbacks ( ) { GiraphTimerContext timerContext = wcPostSuperstepTimer . time ( ) ; getWorkerContext ( ) . postSuperstep ( ) ; timerContext . stop ( ) ; getContext ( ) . progress ( ) ; for ( WorkerObserver obs : getWorkerObservers ( ) ) { obs . postSuperstep ( getSuperstep ( ) ) ; getContext ( ) . progress ( ) ; } } 
592	public void setWorkbookPassword ( String password , HashAlgorithm hashAlgo ) { if ( password = = null & & ! workbookProtectionPresent ( ) ) { return ; } setPassword ( safeGetWorkbookProtection ( ) , password , hashAlgo , _STR ) ; } 
593	public static < T > Maybe < T > accumulateJust ( final Monoid < T > reducer , final Iterable < Maybe < T > > maybes ) { return sequenceJust ( maybes ) . map ( s - > s . reduce ( reducer ) ) ; } 
594	public static void setMaterialIcon ( MultiButton l , char icon , float size ) { if ( Font . isTrueTypeFileSupported ( ) ) { Style s = new Style ( l . getUnselectedStyle ( ) ) ; s . setFont ( getMaterialDesignFont ( ) . derive ( rightSize ( s , size ) , Font . STYLE _ PLAIN ) ) ; l . setIcon ( FontImage . create ( _STR + icon , s ) ) ; } } 
595	public SpeechletResponseEnvelope dispatchSpeechletCall ( SpeechletRequestEnvelope < ? > requestEnvelope , Session session ) throws IOException , SpeechletRequestHandlerException , SpeechletException { SpeechletRequest speechletRequest = requestEnvelope . getRequest ( ) ; Prepare a response envelope final SpeechletResponseEnvelope responseEnvelope = new SpeechletResponseEnvelope ( ) ; responseEnvelope . setVersion ( Sdk . VERSION ) ; responseEnvelope . setUserAgent ( USER _ AGENT ) ; If this is a new session , invoke the speechlet ' s onSessionStarted life - cycle method . if ( ( session ! = null ) & & session . isNew ( ) ) { final String requestId = ( speechletRequest ! = null ) ? speechletRequest . getRequestId ( ) : null ; final Locale locale = ( speechletRequest ! = null ) ? speechletRequest . getLocale ( ) : null ; SessionStartedRequest sessionStartedRequest = SessionStartedRequest . builder ( ) . withRequestId ( requestId ) . withLocale ( locale ) . build ( ) ; SpeechletRequestEnvelope < SessionStartedRequest > sessionStartedRequestEnvelope = SpeechletRequestEnvelope . < SessionStartedRequest > builder ( ) . withContext ( requestEnvelope . getContext ( ) ) . withRequest ( sessionStartedRequest ) . withSession ( session ) . withVersion ( requestEnvelope . getVersion ( ) ) . build ( ) ; try { speechlet . onSessionStarted ( sessionStartedRequestEnvelope ) ; } catch ( RuntimeException e ) { SpeechletV _NUM is used if ( e . getCause ( ) instanceof SpeechletException ) { throw ( SpeechletException ) e . getCause ( ) ; } throw e ; } } Object speechletWithInterfaces = speechlet instanceof SpeechletToSpeechletV _NUM Adapter ? ( ( SpeechletToSpeechletV _NUM Adapter ) speechlet ) . getSpeechlet ( ) : speechlet ; boolean saveSessionAttributes = false ; SpeechletResponse speechletResponse = null ; if ( speechletRequest instanceof AlexaSkillEventRequest ) { if ( speechletRequest instanceof SkillEnabledEventRequest ) { if ( speechletWithInterfaces instanceof SkillEventListener ) { @ SuppressWarnings ( _STR , requestType , requestEnvelope . getVersion ( ) , Sdk . VERSION ) ; throw new SpeechletRequestHandlerException ( message ) ; } responseEnvelope . setResponse ( speechletResponse ) ; if ( saveSessionAttributes & & session ! = null ) { responseEnvelope . setSessionAttributes ( session . getAttributes ( ) ) ; } return responseEnvelope ; } 
596	public String zookeeperConnect ( ) { return zookeeper . connectString ( ) ; } 
597	public void requestFocus ( ) { Form rootForm = getComponentForm ( ) ; if ( rootForm ! = null ) { Component . setDisableSmoothScrolling ( true ) ; rootForm . requestFocus ( this ) ; Component . setDisableSmoothScrolling ( false ) ; } } 
598	private void initColorConversionCache ( ) throws IOException { there ' s nothing to cache for non - attribute spaces if ( attributes = = null ) { return ; } colorant names List < String > colorantNames = getColorantNames ( ) ; numColorants = colorantNames . size ( ) ; process components colorantToComponent = new int [ numColorants ] ; for ( int c = _NUM ; c < numColorants ; c + + ) { colorantToComponent [ c ] = - _NUM ; } if ( attributes . getProcess ( ) ! = null ) { List < String > components = attributes . getProcess ( ) . getComponents ( ) ; map each colorant to the corresponding process component ( if any ) for ( int c = _NUM ; c < numColorants ; c + + ) { colorantToComponent [ c ] = components . indexOf ( colorantNames . get ( c ) ) ; } process color space processColorSpace = attributes . getProcess ( ) . getColorSpace ( ) ; } spot colorants spotColorSpaces = new PDSeparation [ numColorants ] ; spot color spaces Map < String , PDSeparation > spotColorants = attributes . getColorants ( ) ; map each colorant to the corresponding spot color space for ( int c = _NUM ; c < numColorants ; c + + ) { String name = colorantNames . get ( c ) ; PDSeparation spot = spotColorants . get ( name ) ; if ( spot ! = null ) { spot colorant spotColorSpaces [ c ] = spot ; providing that the subtype is not NChannel . if ( ! isNChannel ( ) ) { colorantToComponent [ c ] = - _NUM ; } } else { process colorant spotColorSpaces [ c ] = null ; } } } 
599	protected void statusUpdate ( TaskAttemptStatus reportedStatus , long timestamp ) { String stateString = reportedStatus . taskState . toString ( ) ; TaskAttemptId attemptID = reportedStatus . id ; TaskId taskID = attemptID . getTaskId ( ) ; Job job = context . getJob ( taskID . getJobId ( ) ) ; if ( job = = null ) { return ; } Task task = job . getTask ( taskID ) ; if ( task = = null ) { return ; } estimator . updateAttempt ( reportedStatus , timestamp ) ; if ( stateString . equals ( TaskAttemptState . RUNNING . name ( ) ) ) { runningTasks . putIfAbsent ( taskID , Boolean . TRUE ) ; } else { runningTasks . remove ( taskID , Boolean . TRUE ) ; if ( ! stateString . equals ( TaskAttemptState . STARTING . name ( ) ) ) { runningTaskAttemptStatistics . remove ( attemptID ) ; } } } 
600	public void setNavigationOnClickListener ( OnClickListener listener ) { ensureNavButtonView ( ) ; mNavButtonView . setOnClickListener ( listener ) ; } 
601	public void testMRAsyncDiskService ( ) throws Throwable { FileSystem localFileSystem = FileSystem . getLocal ( new Configuration ( ) ) ; String [ ] vols = new String [ ] { TEST _ ROOT _ DIR + _STR , ee ) ; asyncDiskService is able to automatically find the file in one of the volumes . assertTrue ( service . moveAndDeleteAbsolutePath ( vols [ _NUM ] + Path . SEPARATOR _ CHAR + d ) ) ; Make sure everything is cleaned up makeSureCleanedUp ( vols , service ) ; } 
602	public void testQueryWithAggregateGroupingSets ( ) throws Exception { Connection connection = DriverManager . getConnection ( _STR ) ) ; assertThat ( resultSetMetaData . getTableName ( _NUM ) , nullValue ( ) ) ; assertThat ( resultSetMetaData . getSchemaName ( _NUM ) , nullValue ( ) ) ; resultSet . close ( ) ; statement . close ( ) ; connection . close ( ) ; } 
603	public boolean onTouchEvent ( MotionEvent event ) { if ( ! this . isEnabled ( ) ) return false ; if ( event . getAction ( ) = = MotionEvent . ACTION _ DOWN ) { mDownTouchPosition = getDownTouchPosition ( event ) ; } if ( mIsHorizontalScroll ) { mGestureDetector . onTouchEvent ( event ) ; } restoreGestureDetectorState ( event ) ; invalidateChildren ( ) ; if ( getSelectedItemPosition ( ) = = mDownTouchPosition ) { if ( sendDispatchTouchEventToChild ( event ) ) { mIsSingleTapUp = false ; return true ; } else if ( mIsSingleTapUp ) { onCarouselItemClick ( ) ; } } return true ; } 
604	public NdefMessage getNdefMessage ( ) throws IOException , FormatException { checkConnected ( ) ; try { INfcTag tagService = mTag . getTagService ( ) ; if ( tagService = = null ) { throw new IOException ( _STR , e ) ; return null ; } } 
605	public static void notEmpty ( Map map , String message ) { if ( isEmpty ( map ) ) { throw new IllegalArgumentException ( message ) ; } } 
606	private void addDecommissionAction ( final ActionExecutionContext actionExecutionContext , final RequestResourceFilter resourceFilter , Stage stage , ExecuteCommandJson executeCommandJson ) throws AmbariException { String clusterName = actionExecutionContext . getClusterName ( ) ; final Cluster cluster = clusters . getCluster ( clusterName ) ; final String serviceName = resourceFilter . getServiceName ( ) ; String masterCompType = resourceFilter . getComponentName ( ) ; List < String > hosts = resourceFilter . getHostNames ( ) ; if ( hosts ! = null & & ! hosts . isEmpty ( ) ) { throw new AmbariException ( _STR ) ; addCustomCommandAction ( commandContext , commandFilter , stage , commandParams , commandDetail . toString ( ) , null ) ; } } } 
607	public int getWidth ( String text ) { int total = _NUM ; if ( fastWinansi ) { int len = text . length ( ) ; for ( int k = _NUM ; k < len ; + + k ) { char char _NUM = text . charAt ( k ) ; if ( char _NUM < _NUM _NUM _NUM | | ( char _NUM > = _NUM _NUM _NUM & & char _NUM < = _NUM _NUM _NUM ) ) total + = widths [ char _NUM ] ; else total + = widths [ PdfEncodings . winansi . get ( char _NUM ) ] ; } return total ; } else { byte [ ] mbytes = convertToBytes ( text ) ; for ( int k = _NUM ; k < mbytes . length ; + + k ) total + = widths [ _NUM xff & mbytes [ k ] ] ; } return total ; } 
608	public void setEnableScheduledScanJobs ( boolean enabled ) { if ( isAnyConsumerBound ( ) ) { LogManager . e ( TAG , _STR ) ; return ; } mScheduledScanJobsEnabled = enabled ; } 
609	public org . apache . drill . exec . proto . UserBitShared . QueryId . Builder getParentQueryIdBuilder ( ) { bitField _NUM _ | = _NUM x _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM ; onChanged ( ) ; return getParentQueryIdFieldBuilder ( ) . getBuilder ( ) ; } 
610	static boolean canHandleEntryData ( ZipEntry entry ) { return supportsEncryptionOf ( entry ) & & supportsMethodOf ( entry ) ; } 
611	private byte [ ] calcFinalKey ( long objectNumber , long genNumber ) { byte [ ] newKey = new byte [ encryptionKey . length + _NUM ] ; System . arraycopy ( encryptionKey , _NUM , newKey , _NUM , encryptionKey . length ) ; PDF _NUM . _NUM reference pg _NUM _NUM step _NUM we have the reference step _NUM newKey [ newKey . length - _NUM ] = ( byte ) ( objectNumber & _NUM xff ) ; newKey [ newKey . length - _NUM ] = ( byte ) ( objectNumber > > _NUM & _NUM xff ) ; newKey [ newKey . length - _NUM ] = ( byte ) ( objectNumber > > _NUM _NUM & _NUM xff ) ; newKey [ newKey . length - _NUM ] = ( byte ) ( genNumber & _NUM xff ) ; newKey [ newKey . length - _NUM ] = ( byte ) ( genNumber > > _NUM & _NUM xff ) ; step _NUM MessageDigest md = MessageDigests . getMD _NUM ( ) ; md . update ( newKey ) ; if ( useAES ) { md . update ( AES _ SALT ) ; } byte [ ] digestedKey = md . digest ( ) ; step _NUM int length = Math . min ( newKey . length , _NUM _NUM ) ; byte [ ] finalKey = new byte [ length ] ; System . arraycopy ( digestedKey , _NUM , finalKey , _NUM , length ) ; return finalKey ; } 
612	public VolumeStatusItem withEvents ( VolumeStatusEvent . . . events ) { if ( getEvents ( ) = = null ) setEvents ( new java . util . ArrayList < VolumeStatusEvent > ( events . length ) ) ; for ( VolumeStatusEvent value : events ) { getEvents ( ) . add ( value ) ; } return this ; } 
613	public void setImageClass ( String imageClass ) { setUpFace ( m _ text , imageClass ) ; } 
614	public Builder clearFragments ( ) { if ( fragmentsBuilder _ = = null ) { fragments _ = java . util . Collections . emptyList ( ) ; bitField _NUM _ = ( bitField _NUM _ & ~ _NUM x _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM ) ; onChanged ( ) ; } else { fragmentsBuilder _ . clear ( ) ; } return this ; } 
615	public Response getVersion ( ) { return RestUtils . call ( new RestUtils . RestCallable < String > ( ) { @ Override public String call ( ) throws Exception { return RuntimeConstants . VERSION ; } } ) ; } 
616	public static List < Locale > countriesByLanguage ( final String languageCode ) { if ( languageCode = = null ) { return Collections . emptyList ( ) ; } List < Locale > countries = cCountriesByLanguage . get ( languageCode ) ; if ( countries = = null ) { countries = new ArrayList < > ( ) ; final List < Locale > locales = availableLocaleList ( ) ; for ( final Locale locale : locales ) { if ( languageCode . equals ( locale . getLanguage ( ) ) & & locale . getCountry ( ) . length ( ) ! = _NUM & & locale . getVariant ( ) . isEmpty ( ) ) { countries . add ( locale ) ; } } countries = Collections . unmodifiableList ( countries ) ; cCountriesByLanguage . putIfAbsent ( languageCode , countries ) ; countries = cCountriesByLanguage . get ( languageCode ) ; } return countries ; } 
617	public String buildSelectExplorerButtonStyle ( String htmlAttributes ) { int selectedIndex = Integer . parseInt ( getParamTabExButtonStyle ( ) ) ; return buildSelectButtonStyle ( htmlAttributes , selectedIndex ) ; } 
618	public void setBrandColor ( @ ColorInt int color ) { mBrandColor = color ; mBrandColorSet = true ; if ( mHeadersSupportFragment ! = null ) { mHeadersSupportFragment . setBackgroundColor ( mBrandColor ) ; } } 
619	String printout ( ) { printstatus = idle ; anyprinted = false ; PrintStream _ sysout = System . out ; _ sysout . flush ( ) ; String ret ; try { ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; System . setOut ( new PrintStream ( bout ) ) ; for ( printoldline = printnewline = _NUM ; ; ) { if ( printoldline > oldinfo . maxLine ) { newconsume ( ) ; break ; } if ( printnewline > newinfo . maxLine ) { oldconsume ( ) ; break ; } if ( newinfo . other [ printnewline ] < _NUM ) { if ( oldinfo . other [ printoldline ] < _NUM ) showchange ( ) ; else showinsert ( ) ; } else if ( oldinfo . other [ printoldline ] < _NUM ) showdelete ( ) ; else if ( blocklen [ printoldline ] < _NUM ) skipold ( ) ; else if ( oldinfo . other [ printoldline ] = = printnewline ) showsame ( ) ; else showmove ( ) ; } if ( anyprinted ) ret = bout . toString ( ) ; else ret = null ; } finally { System . setOut ( _ sysout ) ; } return ret ; } 
620	public void addBlock ( ) throws Exception { AlluxioURI uri = new AlluxioURI ( _STR ) ; CreateFileOptions options = CreateFileOptions . defaults ( ) . setBlockSizeBytes ( _NUM _NUM ) ; FileOutStream os = mFileSystem . createFile ( uri , options ) ; for ( int k = _NUM ; k < _NUM _NUM _NUM _NUM ; k + + ) { os . write ( k ) ; } os . close ( ) ; URIStatus status = mFileSystem . getStatus ( uri ) ; mLocalAlluxioCluster . stopFS ( ) ; addBlockTestUtil ( status ) ; } 
621	public void valueOf ( final Type type ) { if ( type . getSort ( ) = = Type . OBJECT | | type . getSort ( ) = = Type . ARRAY ) { return ; } if ( type = = Type . VOID _ TYPE ) { push ( ( String ) null ) ; } else { Type boxed = getBoxedType ( type ) ; invokeStatic ( boxed , new Method ( _STR , boxed , new Type [ ] { type } ) ) ; } } 
622	public TypedInputStream open ( String filenameIRI ) { String fn = toFileName ( filenameIRI ) ; if ( fn = = null ) return null ; try { if ( ! exists $ ( fn ) ) { if ( StreamManager . logAllLookups & & log . isTraceEnabled ( ) ) log . trace ( _STR + ioEx . getMessage ( ) ) ; return null ; } } 
623	public static CharsetDecoder allocDecoder ( ) { CharsetDecoder dec = Chars . getDecoder ( ) ; Plain Pool ( sync wrapped ) - might - allocate an extra one . if ( dec = = null ) dec = Chars . createDecoder ( ) ; dec . onMalformedInput ( CodingErrorAction . REPLACE ) . onUnmappableCharacter ( CodingErrorAction . REPLACE ) . reset ( ) ; return dec ; } 
624	private Expr postfix ( ) throws QueryException { Expr ex = primary ( ) , old ; if ( ex ! = null ) { do { old = ex ; if ( wsConsume ( SQUARE _NUM ) ) { parses the _STR rule ex = new Lookup ( info ( ) , keySpecifier ( ) , ex ) ; } } while ( ex ! = old ) ; } return ex ; } 
625	public void onStartedGoingToSleep ( int why ) { if ( DEBUG ) Log . d ( TAG , _STR , e ) ; } mExitSecureCallback = null ; if ( ! mExternallyEnabled ) { hideLocked ( ) ; } } else if ( mShowing ) { mPendingReset = true ; } else if ( ( why = = WindowManagerPolicy . OFF _ BECAUSE _ OF _ TIMEOUT & & timeout > _NUM ) | | ( why = = WindowManagerPolicy . OFF _ BECAUSE _ OF _ USER & & ! lockImmediately ) ) { doKeyguardLaterLocked ( timeout ) ; mLockLater = true ; } else if ( ! mLockPatternUtils . isLockScreenDisabled ( currentUser ) ) { mPendingLock = true ; } if ( mPendingLock ) { playSounds ( true ) ; } } KeyguardUpdateMonitor . getInstance ( mContext ) . dispatchStartedGoingToSleep ( why ) ; notifyStartedGoingToSleep ( ) ; } 
626	public void binderDied ( ) { Log . w ( TAG , _STR ) ; if ( mRemoteDevice = = null ) { Camera already closed return ; } mInError = true ; Runnable r = new Runnable ( ) { @ Override public void run ( ) { if ( ! isClosed ( ) ) { mDeviceCallback . onError ( CameraDeviceImpl . this , StateCallback . ERROR _ CAMERA _ SERVICE ) ; } } } ; CameraDeviceImpl . this . mDeviceHandler . post ( r ) ; } 
627	 @ GET @ Path ( _STR ) String jobId ) { try { final JobController jobController = getResourceManager ( ) . readController ( jobId ) ; ProgressRetriever . Progress progress = new ProgressRetriever ( jobController . getJob ( ) , getSharedObjectsFactory ( ) ) . getProgress ( ) ; return Response . ok ( progress ) . build ( ) ; } catch ( WebApplicationException ex ) { throw ex ; } catch ( ItemNotFound itemNotFound ) { throw new NotFoundFormattedException ( itemNotFound . getMessage ( ) , itemNotFound ) ; } catch ( Exception ex ) { throw new ServiceFormattedException ( ex . getMessage ( ) , ex ) ; } } 
628	public void setRetainViewMode ( @ NonNull RetainViewMode retainViewMode ) { this . retainViewMode = retainViewMode ! = null ? retainViewMode : RetainViewMode . RELEASE _ DETACH ; if ( this . retainViewMode = = RetainViewMode . RELEASE _ DETACH & & ! attached ) { removeViewReference ( ) ; } } 
629	public void scheduleAndCancelMessage ( ) { final long when = _NUM _NUM _NUM _NUM ; scheduleAndVerifyAlarm ( when ) ; mMessage . cancel ( ) ; mListenerCaptor . getValue ( ) . onAlarm ( ) ; verify ( mHandler , never ( ) ) . handleMessage ( any ( Message . class ) ) ; } 
630	public void testNotInUncorrelatedSubQueryInSelectNotNull ( ) { final String sql = _STR ; sql ( sql ) . ok ( ) ; } 
631	protected void copy ( I _ CmsRepositoryItem item , PrintWriter writer , Iterator < CmsWebdavRange > ranges , String contentType ) throws IOException { IOException exception = null ; while ( ( exception = = null ) & & ( ranges . hasNext ( ) ) ) { InputStream resourceInputStream = new ByteArrayInputStream ( item . getContent ( ) ) ; Reader reader = new InputStreamReader ( resourceInputStream ) ; CmsWebdavRange currentRange = ranges . next ( ) ; Writing MIME header . writer . println ( ) ; writer . println ( _STR ) ; Rethrow any exception that has occurred if ( exception ! = null ) { throw exception ; } } 
632	public void elementsWithText ( ) { run ( _STR ) ; } 
633	public void testAnonymous ( ) throws Exception { final AWSCredentials credentials = new AnonymousAWSCredentials ( ) ; final Request < ? > request = generateBasicRequest ( ) ; final Calendar c = new GregorianCalendar ( ) ; c . set ( _NUM _NUM _NUM _NUM , _NUM , _NUM _NUM , _NUM , _NUM _NUM , _NUM ) ; c . setTimeZone ( TimeZone . getTimeZone ( _STR ) ) ; } 
634	File recoverTempUnlinkedBlock ( File unlinkedTmp ) throws IOException { File blockFile = FsDatasetUtil . getOrigFile ( unlinkedTmp ) ; if ( blockFile . exists ( ) ) { If the original block file still exists , then no recovery is needed . if ( ! unlinkedTmp . delete ( ) ) { throw new IOException ( _STR + unlinkedTmp ) ; } return blockFile ; } } 
635	public synchronized boolean hasAccess ( String queueName , QueueACL qACL , UserGroupInformation ugi ) { Queue q = leafQueues . get ( queueName ) ; if ( q = = null ) { LOG . info ( _STR + ugi . getShortUserName ( ) ) ; } AccessControlList acl = q . getAcls ( ) . get ( toFullPropertyName ( queueName , qACL . getAclName ( ) ) ) ; if ( acl = = null ) { return false ; } Check if user is part of the ACL return acl . isUserAllowed ( ugi ) ; } 
636	private void handleStateRemoving ( InetAddressAndPort endpoint , String [ ] pieces ) { assert ( pieces . length > _NUM ) ; if ( endpoint . equals ( FBUtilities . getBroadcastAddressAndPort ( ) ) ) { logger . info ( _STR , removeTokens , endpoint ) ; Note that the endpoint is being removed tokenMetadata . addLeavingEndpoint ( endpoint ) ; PendingRangeCalculatorService . instance . update ( ) ; find the endpoint coordinating this removal that we need to notify when we ' re done String [ ] coordinator = splitValue ( Gossiper . instance . getEndpointStateForEndpoint ( endpoint ) . getApplicationState ( ApplicationState . REMOVAL _ COORDINATOR ) ) ; UUID hostId = UUID . fromString ( coordinator [ _NUM ] ) ; grab any data we are now responsible for and notify responsible node restoreReplicaCount ( endpoint , tokenMetadata . getEndpointForHostId ( hostId ) ) ; } } else now that the gossiper has told us about this nonexistent member , notify the gossiper to remove it { if ( VersionedValue . REMOVED _ TOKEN . equals ( pieces [ _NUM ] ) ) addExpireTimeIfFound ( endpoint , extractExpireTime ( pieces ) ) ; removeEndpoint ( endpoint ) ; } } 
637	public Size getPreferredPreviewSizeForVideo ( ) { String pair = get ( KEY _ PREFERRED _ PREVIEW _ SIZE _ FOR _ VIDEO ) ; return strToSize ( pair ) ; } 
638	public synchronized int available ( ) throws IOException { if ( disableBuffering ) { return available ( ) ; } return superAvailable ( ) + ( count - pos ) ; } 
639	private StringBuilder format ( final MapFormat format , final StringBuilder sb ) { if ( format = = null ) { appendMap ( sb ) ; } else { switch ( format ) { case XML : { asXml ( sb ) ; break ; } case JSON : { asJson ( sb ) ; break ; } case JAVA : { asJava ( sb ) ; break ; } default : { appendMap ( sb ) ; } } } return sb ; } 
640	public void setNamespaceUserPermissions ( String username , String namespace , List < TablePermission > perms ) { PermissionCache < TablePermission > tablePerms = getNamespacePermissions ( namespace ) ; tablePerms . replaceUser ( username , perms ) ; writeNamespaceToZooKeeper ( namespace , tablePerms ) ; } 
641	private List < WordWithTextPositions > normalize ( List < LineItem > line ) { List < WordWithTextPositions > normalized = new LinkedList < > ( ) ; StringBuilder lineBuilder = new StringBuilder ( ) ; List < TextPosition > wordPositions = new ArrayList < > ( ) ; for ( LineItem item : line ) { lineBuilder = normalizeAdd ( normalized , lineBuilder , wordPositions , item ) ; } if ( lineBuilder . length ( ) > _NUM ) { normalized . add ( createWord ( lineBuilder . toString ( ) , wordPositions ) ) ; } return normalized ; } 
642	public synchronized boolean load ( ) { Either < Void , T > oldData = data ; String oldKey = versionedKey ; try { if ( isOutOfDate ( ) ) { String newVersionedKey = ( String ) connection . get ( key ) . get ( ) ; data = Either . right ( ( T ) nonAtomicload ( newVersionedKey ) ) ; versionedKey = newVersionedKey ; } else { return false ; } } catch ( Throwable e ) { data = oldData ; versionedKey = oldKey ; logger . debug ( e . getMessage ( ) , e ) ; throw ExceptionSoftener . throwSoftenedException ( e ) ; } return true ; } 
643	public static String encodePartiallyEncoded ( String encoded , boolean query ) { if ( encoded . length ( ) = = _NUM ) { return encoded ; } Matcher m = ENCODE _ PATTERN . matcher ( encoded ) ; StringBuilder sb = new StringBuilder ( ) ; int i = _NUM ; while ( m . find ( ) ) { String before = encoded . substring ( i , m . start ( ) ) ; sb . append ( query ? HttpUtils . queryEncode ( before ) : HttpUtils . pathEncode ( before ) ) ; sb . append ( m . group ( ) ) ; i = m . end ( ) ; } String tail = encoded . substring ( i , encoded . length ( ) ) ; sb . append ( query ? HttpUtils . queryEncode ( tail ) : HttpUtils . pathEncode ( tail ) ) ; return sb . toString ( ) ; } 
644	public static void writeOrNull ( WLongArrayList list , DataOutput out ) throws IOException { if ( list = = null ) { Varint . writeUnsignedVarInt ( _NUM , out ) ; } else { list . write ( out ) ; } } 
645	public void testFullRestoreMultipleEmpty ( ) throws Exception { LOG . info ( _STR ) ; List < TableName > tables = toList ( table _NUM . getNameAsString ( ) , table _NUM . getNameAsString ( ) ) ; String backupId = fullTableBackup ( tables ) ; TableName [ ] restore _ tableset = new TableName [ ] { table _NUM , table _NUM } ; TableName [ ] tablemap = new TableName [ ] { table _NUM _ restore , table _NUM _ restore } ; getBackupAdmin ( ) . restore ( BackupUtils . createRestoreRequest ( BACKUP _ ROOT _ DIR , backupId , false , restore _ tableset , tablemap , false ) ) ; HBaseAdmin hba = TEST _ UTIL . getHBaseAdmin ( ) ; assertTrue ( hba . tableExists ( table _NUM _ restore ) ) ; assertTrue ( hba . tableExists ( table _NUM _ restore ) ) ; TEST _ UTIL . deleteTable ( table _NUM _ restore ) ; TEST _ UTIL . deleteTable ( table _NUM _ restore ) ; hba . close ( ) ; } 
646	protected void drawPie ( Graphics _NUM D g _NUM , Rectangle _NUM D plotArea , PlotRenderingInfo info ) { PiePlotState state = initialise ( g _NUM , plotArea , this , null , info ) ; adjust the plot area for interior spacing and labels . . . double labelReserve = _NUM . _NUM ; if ( this . labelGenerator ! = null & & ! this . simpleLabels ) { labelReserve = this . labelGap + this . maximumLabelWidth ; } double gapHorizontal = plotArea . getWidth ( ) * ( this . interiorGap + labelReserve ) * _NUM . _NUM ; double gapVertical = plotArea . getHeight ( ) * this . interiorGap * _NUM . _NUM ; if ( DEBUG _ DRAW _ INTERIOR ) { double hGap = plotArea . getWidth ( ) * this . interiorGap ; double vGap = plotArea . getHeight ( ) * this . interiorGap ; double igx _NUM = plotArea . getX ( ) + hGap ; double igx _NUM = plotArea . getMaxX ( ) - hGap ; double igy _NUM = plotArea . getY ( ) + vGap ; double igy _NUM = plotArea . getMaxY ( ) - vGap ; g _NUM . setPaint ( Color . gray ) ; g _NUM . draw ( new Rectangle _NUM D . Double ( igx _NUM , igy _NUM , igx _NUM - igx _NUM , igy _NUM - igy _NUM ) ) ; } double linkX = plotArea . getX ( ) + gapHorizontal / _NUM ; double linkY = plotArea . getY ( ) + gapVertical / _NUM ; double linkW = plotArea . getWidth ( ) - gapHorizontal ; double linkH = plotArea . getHeight ( ) - gapVertical ; make the link area a square if the pie chart is to be circular . . . if ( this . circular ) { double min = Math . min ( linkW , linkH ) / _NUM ; linkX = ( linkX + linkX + linkW ) / _NUM - min ; linkY = ( linkY + linkY + linkH ) / _NUM - min ; linkW = _NUM * min ; linkH = _NUM * min ; } the link area defines the dog leg points for the linking lines to the labels Rectangle _NUM D linkArea = new Rectangle _NUM D . Double ( linkX , linkY , linkW , linkH ) ; state . setLinkArea ( linkArea ) ; if ( DEBUG _ DRAW _ LINK _ AREA ) { g _NUM . setPaint ( Color . blue ) ; g _NUM . draw ( linkArea ) ; g _NUM . setPaint ( Color . yellow ) ; g _NUM . draw ( new Ellipse _NUM D . Double ( linkArea . getX ( ) , linkArea . getY ( ) , linkArea . getWidth ( ) , linkArea . getHeight ( ) ) ) ; } the explode area defines the max circle / ellipse for the exploded pie sections . it is defined by shrinking the linkArea by the linkMargin factor . double lm = _NUM . _NUM ; if ( ! this . simpleLabels ) { lm = this . labelLinkMargin ; } double hh = linkArea . getWidth ( ) * lm * _NUM . _NUM ; double vv = linkArea . getHeight ( ) * lm * _NUM . _NUM ; Rectangle _NUM D explodeArea = new Rectangle _NUM D . Double ( linkX + hh / _NUM . _NUM , linkY + vv / _NUM . _NUM , linkW - hh , linkH - vv ) ; state . setExplodedPieArea ( explodeArea ) ; the pie area defines the circle / ellipse for regular pie sections . it is defined by shrinking the explodeArea by the explodeMargin factor . double maximumExplodePercent = getMaximumExplodePercent ( ) ; double percent = maximumExplodePercent / ( _NUM . _NUM + maximumExplodePercent ) ; double h _NUM = explodeArea . getWidth ( ) * percent ; double v _NUM = explodeArea . getHeight ( ) * percent ; Rectangle _NUM D pieArea = new Rectangle _NUM D . Double ( explodeArea . getX ( ) + h _NUM / _NUM . _NUM , explodeArea . getY ( ) + v _NUM / _NUM . _NUM , explodeArea . getWidth ( ) - h _NUM , explodeArea . getHeight ( ) - v _NUM ) ; if ( DEBUG _ DRAW _ PIE _ AREA ) { g _NUM . setPaint ( Color . green ) ; g _NUM . draw ( pieArea ) ; } state . setPieArea ( pieArea ) ; state . setPieCenterX ( pieArea . getCenterX ( ) ) ; state . setPieCenterY ( pieArea . getCenterY ( ) ) ; state . setPieWRadius ( pieArea . getWidth ( ) / _NUM . _NUM ) ; state . setPieHRadius ( pieArea . getHeight ( ) / _NUM . _NUM ) ; plot the data ( unless the dataset is null ) . . . if ( ( this . dataset ! = null ) & & ( this . dataset . getKeys ( ) . size ( ) > _NUM ) ) { List keys = this . dataset . getKeys ( ) ; double totalValue = DatasetUtilities . calculatePieDatasetTotal ( this . dataset ) ; int passesRequired = state . getPassesRequired ( ) ; for ( int pass = _NUM ; pass < passesRequired ; pass + + ) { double runningTotal = _NUM . _NUM ; for ( int section = _NUM ; section < keys . size ( ) ; section + + ) { Number n = this . dataset . getValue ( section ) ; if ( n ! = null ) { double value = n . doubleValue ( ) ; if ( value > _NUM . _NUM ) { runningTotal + = value ; drawItem ( g _NUM , section , explodeArea , state , pass ) ; } } } } if ( this . simpleLabels ) { drawSimpleLabels ( g _NUM , keys , totalValue , plotArea , linkArea , state ) ; } else { drawLabels ( g _NUM , keys , totalValue , plotArea , linkArea , state ) ; } } else { drawNoDataMessage ( g _NUM , plotArea ) ; } } 
647	public void copyFrom ( PackageSettingBase orig ) { super . copyFrom ( orig ) ; doCopy ( orig ) ; } 
648	private static String fromMaven ( String name ) { Matcher m = mvnPattern . matcher ( name ) ; if ( ! m . matches ( ) ) { return name ; } StringBuilder b = new StringBuilder ( ) ; b . append ( m . group ( _NUM ) ) ; for ( int i = _NUM ; i < b . length ( ) ; i + + ) { if ( b . charAt ( i ) = = ' . ' ) { b . setCharAt ( i , ' / ' ) ; } } groupId b . append ( _STR ) ; } return b . toString ( ) ; } 
649	public synchronized RemoteEditLogManifest getEditLogManifest ( long fromTxId ) { Collect RemoteEditLogs available from each FileJournalManager List < RemoteEditLog > allLogs = Lists . newArrayList ( ) ; for ( JournalAndStream j : journals ) { if ( j . getManager ( ) instanceof FileJournalManager ) { FileJournalManager fjm = ( FileJournalManager ) j . getManager ( ) ; try { allLogs . addAll ( fjm . getRemoteEditLogs ( fromTxId , false ) ) ; } catch ( Throwable t ) { LOG . warn ( _STR + ret ) ; } return ret ; } 
650	public void testLevel _NUM Configuration ( ) throws Exception { CmsObject offlineCms = getCmsObject ( ) ; CmsObject onlineCms = onlineCms ( ) ; OpenCms . getADEManager ( ) . refresh ( ) ; checkResourceTypes ( offlineCms , _STR ) ; } 
651	public IComplexNDArray complexValueOf ( int [ ] shape , IComplexNumber value ) { IComplexNDArray ones = complexOnes ( shape ) ; ones . assign ( Nd _NUM j . scalar ( value ) ) ; return ones ; } 
652	public void setOptions ( String [ ] options ) throws Exception { m _ bUseADTree = ! ( Utils . getFlag ( ' D ' , options ) ) ; String sBIFFile = Utils . getOption ( ' B ' , options ) ; if ( sBIFFile ! = null & & ! sBIFFile . equals ( _STR ) ) { setBIFFile ( sBIFFile ) ; } String searchAlgorithmName = Utils . getOption ( ' Q ' , options ) ; if ( searchAlgorithmName . length ( ) ! = _NUM ) { setSearchAlgorithm ( ( SearchAlgorithm ) Utils . forName ( SearchAlgorithm . class , searchAlgorithmName , partitionOptions ( options ) ) ) ; } else { setSearchAlgorithm ( new K _NUM ( ) ) ; } String estimatorName = Utils . getOption ( ' E ' , options ) ; if ( estimatorName . length ( ) ! = _NUM ) { setEstimator ( ( BayesNetEstimator ) Utils . forName ( BayesNetEstimator . class , estimatorName , Utils . partitionOptions ( options ) ) ) ; } else { setEstimator ( new SimpleEstimator ( ) ) ; } Utils . checkForRemainingOptions ( options ) ; } 
653	public int createLocalAndTransfer ( final DirectSorter adder ) { final int first = addLocals ( adder , _NUM ) ; transferToLocal ( adder , first ) ; return first ; } 
654	public void collapsePanels ( ) { try { final IStatusBarService svc = getService ( ) ; if ( svc ! = null ) { svc . collapsePanels ( ) ; } } catch ( RemoteException ex ) { throw ex . rethrowFromSystemServer ( ) ; } } 
655	public static TupleMap create ( String label , String input , String output ) { return new TupleMap ( label , compileMapping ( input , output ) ) ; } 
656	 < T > T callInContext ( ContextualCallable < T > callable ) { Object [ ] reference = localContext . get ( ) ; if ( reference [ _NUM ] = = null ) { reference [ _NUM ] = new InternalContext ( this ) ; try { return callable . call ( ( InternalContext ) reference [ _NUM ] ) ; } finally { Only remove the context if this call created it . reference [ _NUM ] = null ; WW - _NUM _NUM _NUM _NUM : ThreadLocal was not removed localContext . remove ( ) ; } } else { Someone else will clean up this context . return callable . call ( ( InternalContext ) reference [ _NUM ] ) ; } } 
657	public boolean checkDefaultOptions ( ) { boolean result ; String [ ] options ; print ( _STR ) ; result = false ; if ( getDebug ( ) ) println ( e ) ; } return result ; } 
658	public UaaContext authenticate ( TokenRequest request ) { if ( request = = null ) { throw new NullPointerException ( TokenRequest . class . getName ( ) + _STR + request . getGrantType ( ) ) ; } } 
659	public boolean performFinish ( ) { DataSourceDescriptor dsCopy = new DataSourceDescriptor ( originalDataSource ) ; DataSourceDescriptor dsChanged = new DataSourceDescriptor ( dataSource ) ; saveSettings ( dsChanged ) ; if ( dsCopy . equalSettings ( dsChanged ) ) { No changes return true ; } Check locked datasources if ( ! CommonUtils . isEmpty ( dataSource . getLockPasswordHash ( ) ) ) { if ( DBeaverCore . getInstance ( ) . getSecureStorage ( ) . useSecurePreferences ( ) & & ! isOnlyUserCredentialChanged ( dsCopy , dsChanged ) ) { if ( ! checkLockPassword ( ) ) { return false ; } } } Save saveSettings ( originalDataSource ) ; originalDataSource . getRegistry ( ) . updateDataSource ( originalDataSource ) ; if ( originalDataSource . isConnected ( ) ) { if ( UIUtils . confirmAction ( getShell ( ) , CoreMessages . dialog _ connection _ edit _ wizard _ conn _ change _ title , NLS . bind ( CoreMessages . dialog _ connection _ edit _ wizard _ conn _ change _ question , originalDataSource . getName ( ) ) ) ) { DataSourceHandler . reconnectDataSource ( null , originalDataSource ) ; } } return true ; } 
660	public ExecutionEntityImpl getParent ( ) { ensureParentInitialized ( ) ; return parent ; } 
661	private static Hop removeUnnecessaryReorgOperation ( Hop parent , Hop hi , int pos ) { ReOrgOp [ ] lookup = new ReOrgOp [ ] { ReOrgOp . TRANS , ReOrgOp . REV } ; if ( first reorg hi instanceof ReorgOp & & HopRewriteUtils . isValidOp ( ( ( ReorgOp ) hi ) . getOp ( ) , lookup ) ) { ReOrgOp firstOp = ( ( ReorgOp ) hi ) . getOp ( ) ; Hop hi _NUM = hi . getInput ( ) . get ( _NUM ) ; if ( second reorg w / same type hi _NUM instanceof ReorgOp & & ( ( ReorgOp ) hi _NUM ) . getOp ( ) = = firstOp ) { Hop hi _NUM = hi _NUM . getInput ( ) . get ( _NUM ) ; remove unnecessary chain of t ( t ( ) ) HopRewriteUtils . replaceChildReference ( parent , hi , hi _NUM , pos ) ; HopRewriteUtils . cleanupUnreferenced ( hi , hi _NUM ) ; hi = hi _NUM ; LOG . debug ( _STR ) ; } } return hi ; } 
662	public void scroll ( int distance , int time ) { scroller . forceFinished ( true ) ; lastScrollY = _NUM ; scroller . startScroll ( _NUM , _NUM , _NUM , distance , time ! = _NUM ? time : SCROLLING _ DURATION ) ; setNextMessage ( MESSAGE _ SCROLL ) ; startScrolling ( ) ; } 
663	public void showAnnotation ( PDAnnotation annotation ) throws IOException { PDAppearanceStream appearanceStream = getAppearance ( annotation ) ; if ( appearanceStream ! = null ) { processAnnotation ( annotation , appearanceStream ) ; } } 
664	public String toString ( String name , String defaultValue ) { try { return parseString ( name ) ; } catch ( Exception e ) { return defaultValue ; } } 
665	markWritten ( ) MUST be called once we are done with the segment or the CL will never flushbut must not be called more than oncevoid markWritten ( ) { appendOp . close ( ) ; } 
666	public boolean containsElement ( CmsUUID elementId ) { return getElementIds ( ) . contains ( elementId ) ; } 
667	public void add ( ShortcutInfo item , boolean animate ) { contents . add ( item ) ; for ( int i = _NUM ; i < listeners . size ( ) ; i + + ) { listeners . get ( i ) . onAdd ( item ) ; } itemsChanged ( animate ) ; } 
668	public boolean hasNext ( ) { if ( currentIndex = = endIndex ) { return false ; } element to make sure it exists . if ( nextElement = = null ) { nextElement = getNextElement ( ) ; if ( nextElement = = null ) { return false ; } } return true ; } 
669	public static < T extends TServiceClient > T getClientNoTimeout ( TServiceClientFactory < T > factory , HostAndPort address , ClientContext context ) throws TTransportException { return getClient ( factory , address , context , _NUM ) ; } 
670	private void createTextPanel ( ) { GridLayout gridLayout = new GridLayout ( ) ; gridLayout . numColumns = _NUM ; textComposite = new Composite ( dialogShell , SWT . NONE ) ; textComposite . setLayout ( gridLayout ) ; createRadixPanel ( ) ; text = new Text ( textComposite , SWT . BORDER | SWT . SINGLE ) ; text . setTextLimit ( _NUM _NUM ) ; int columns = _NUM _NUM ; GC gc = new GC ( text ) ; FontMetrics fm = gc . getFontMetrics ( ) ; int width = columns * fm . getAverageCharWidth ( ) ; gc . dispose ( ) ; text . setLayoutData ( new GridData ( width , SWT . DEFAULT ) ) ; text . addModifyListener ( new ModifyListener ( ) { @ Override public void modifyText ( ModifyEvent e ) { String newText = text . getText ( ) ; int radix = _NUM _NUM ; Matcher numberMatcher ; if ( hexRadioButton . getSelection ( ) ) { numberMatcher = patternHexDigits . matcher ( newText ) ; radix = _NUM _NUM ; } else { numberMatcher = patternDecDigits . matcher ( newText ) ; } tempResult = - _NUM ; if ( numberMatcher . matches ( ) ) tempResult = Long . parseLong ( newText , radix ) ; if ( tempResult > = _NUM L & & tempResult < = limit ) { showButton . setEnabled ( true ) ; gotoButton . setEnabled ( true ) ; $ NON - NLS - _NUM $ label _NUM . setText ( _STR ) ; else if ( tempResult < _NUM ) label _NUM . setText ( CoreMessages . dialog _ go _ to _ label _ not _ number ) ; else label _NUM . setText ( CoreMessages . dialog _ go _ to _ label _ out _ of _ range ) ; } } } ) ; FormData formData = new FormData ( ) ; formData . top = new FormAttachment ( label ) ; textComposite . setLayoutData ( formData ) ; } 
671	public boolean isEnabled ( int position ) { T item = getItem ( position ) ; return item ! = null & & item . isEnabled ( ) ; } 
672	public String getModuleName ( ) { final HaskellQconid qconid = getModuleElement ( ) ; return qconid = = null ? null : qconid . getText ( ) ; } 
673	private void readCentralDirectoryEntry ( Map < ZipEntry , NameAndComment > noUTF _NUM Flag ) throws IOException { archive . readFully ( CFH _ BUF ) ; int off = _NUM ; OffsetEntry offset = new OffsetEntry ( ) ; Entry ze = new Entry ( offset ) ; int versionMadeBy = ZipShort . getValue ( CFH _ BUF , off ) ; off + = SHORT ; ze . setPlatform ( ( versionMadeBy > > BYTE _ SHIFT ) & NIBLET _ MASK ) ; skip version info off + = SHORT ; final GeneralPurposeBit gpFlag = GeneralPurposeBit . parse ( CFH _ BUF , off ) ; final boolean hasUTF _NUM Flag = gpFlag . usesUTF _NUM ForNames ( ) ; final ZipEncoding entryEncoding = hasUTF _NUM Flag ? ZipEncodingHelper . UTF _NUM _ ZIP _ ENCODING : zipEncoding ; ze . setGeneralPurposeBit ( gpFlag ) ; off + = SHORT ; ze . setMethod ( ZipShort . getValue ( CFH _ BUF , off ) ) ; off + = SHORT ; long time = ZipUtil . dosToJavaTime ( ZipLong . getValue ( CFH _ BUF , off ) ) ; ze . setTime ( time ) ; off + = WORD ; ze . setCrc ( ZipLong . getValue ( CFH _ BUF , off ) ) ; off + = WORD ; ze . setCompressedSize ( ZipLong . getValue ( CFH _ BUF , off ) ) ; off + = WORD ; ze . setSize ( ZipLong . getValue ( CFH _ BUF , off ) ) ; off + = WORD ; int fileNameLen = ZipShort . getValue ( CFH _ BUF , off ) ; off + = SHORT ; int extraLen = ZipShort . getValue ( CFH _ BUF , off ) ; off + = SHORT ; int commentLen = ZipShort . getValue ( CFH _ BUF , off ) ; off + = SHORT ; int diskStart = ZipShort . getValue ( CFH _ BUF , off ) ; off + = SHORT ; ze . setInternalAttributes ( ZipShort . getValue ( CFH _ BUF , off ) ) ; off + = SHORT ; ze . setExternalAttributes ( ZipLong . getValue ( CFH _ BUF , off ) ) ; off + = WORD ; byte [ ] fileName = new byte [ fileNameLen ] ; archive . readFully ( fileName ) ; ze . setName ( entryEncoding . decode ( fileName ) , fileName ) ; LFH offset , offset . headerOffset = ZipLong . getValue ( CFH _ BUF , off ) ; data offset will be filled later entries . add ( ze ) ; byte [ ] cdExtraData = new byte [ extraLen ] ; archive . readFully ( cdExtraData ) ; ze . setCentralDirectoryExtra ( cdExtraData ) ; setSizesAndOffsetFromZip _NUM _NUM Extra ( ze , offset , diskStart ) ; byte [ ] comment = new byte [ commentLen ] ; archive . readFully ( comment ) ; ze . setComment ( entryEncoding . decode ( comment ) ) ; if ( ! hasUTF _NUM Flag & & useUnicodeExtraFields ) { noUTF _NUM Flag . put ( ze , new NameAndComment ( fileName , comment ) ) ; } } 
674	private boolean isFullyInMemory ( InodeFile inode ) throws UnavailableException { return getInMemoryPercentage ( inode ) = = _NUM _NUM _NUM ; } 
675	public static void skip ( DataInput in ) throws IOException { int length = WritableUtils . readVInt ( in ) ; WritableUtils . skipFully ( in , length ) ; } 
676	public void terminate ( ) { if ( ! terminating . compareAndSet ( false , true ) ) { return ; } kill ( new Runnable ( ) { @ Override public void run ( ) { new Terminator ( ) . nextInvocation ( singleNodeHandler ) . nextInvocation ( multiNodeHandler ) . nextInvocation ( commitHandler ) . nextInvocation ( rollbackHandler ) . nextInvocation ( new Terminatable ( ) { @ Override public void terminate ( Runnable runnable ) { clearConnections ( false ) ; } } ) . nextInvocation ( new Terminatable ( ) { @ Override public void terminate ( Runnable runnable ) { terminating . set ( false ) ; } } ) . invoke ( ) ; } } ) ; } 
677	public byte [ ] encode ( String ionText ) { Keep here for breakpoint IonDatagram dg = loader ( ) . load ( ionText ) ; return dg . getBytes ( ) ; } 
678	private void forwardPublishWill ( WillMessage will , String clientID ) { LOG . info ( _STR , clientID , will . getTopic ( ) ) ; it has just to publish the message downstream to the subscribers NB it ' s a will publish , it needs a PacketIdentifier for this conn , default to _NUM IMessagesStore . StoredMessage tobeStored = asStoredMessage ( will ) ; tobeStored . setClientID ( clientID ) ; Topic topic = new Topic ( tobeStored . getTopic ( ) ) ; this . messagesPublisher . publish _NUM Subscribers ( tobeStored , topic ) ; Stores retained message to the topic if ( will . isRetained ( ) ) { m _ messagesStore . storeRetained ( topic , tobeStored ) ; } } 
679	private void executePostponedTransaction ( ArrayList < BackStackRecord > records , ArrayList < Boolean > isRecordPop ) { int numPostponed = mPostponedTransactions = = null ? _NUM : mPostponedTransactions . size ( ) ; for ( int i = _NUM ; i < numPostponed ; i + + ) { StartEnterTransitionListener listener = mPostponedTransactions . get ( i ) ; if ( records ! = null & & ! listener . mIsBack ) { int index = records . indexOf ( listener . mRecord ) ; if ( index ! = - _NUM & & isRecordPop . get ( index ) ) { listener . cancelTransaction ( ) ; continue ; } } if ( listener . isReady ( ) | | ( records ! = null & & listener . mRecord . interactsWith ( records , _NUM , records . size ( ) ) ) ) { mPostponedTransactions . remove ( i ) ; i - - ; numPostponed - - ; int index ; if ( records ! = null & & ! listener . mIsBack & & ( index = records . indexOf ( listener . mRecord ) ) ! = - _NUM & & isRecordPop . get ( index ) ) { This is popping a postponed transaction listener . cancelTransaction ( ) ; } else { listener . completeTransaction ( ) ; } } } } 
680	protected static Pointer getDensePointer ( GPUContext gCtx , MatrixObject input , String instName ) { if ( isInSparseFormat ( gCtx , input ) ) { input . getGPUObject ( gCtx ) . sparseToDense ( instName ) ; } return input . getGPUObject ( gCtx ) . getJcudaDenseMatrixPtr ( ) ; } 
681	private String readTitle ( XmlPullParser parser ) throws IOException , XmlPullParserException { parser . require ( XmlPullParser . START _ TAG , ns , _STR ) ; return title ; } 
682	private void showGlobalContextActionBar ( ) { ActionBar actionBar = getActionBar ( ) ; actionBar . setDisplayShowTitleEnabled ( true ) ; actionBar . setNavigationMode ( ActionBar . NAVIGATION _ MODE _ STANDARD ) ; actionBar . setTitle ( R . string . app _ name ) ; } 
683	public void setup ( final Map < String , Object > config ) { final String KEYTAB _ KEY = _STR ) ; } 
684	public void testDFSClientRetriesOnBusyBlocks ( ) throws IOException { System . out . println ( _STR ) ; } 
685	public int getBottomIndex ( ) { if ( bottomIndex ! = - _NUM ) return bottomIndex ; if ( getItemCount ( ) = = _NUM ) { bottomIndex = _NUM ; } else if ( getVisibleGridHeight ( ) < _NUM ) { bottomIndex = getTopIndex ( ) ; } else { RowRange range = getRowRange ( getTopIndex ( ) , getVisibleGridHeight ( ) , false , false ) ; bottomIndex = range . endIndex ; bottomIndexShownCompletely = range . height < = getVisibleGridHeight ( ) ; } return bottomIndex ; } 
686	int getUnfilteredChildCount ( ) { return mCallback . getChildCount ( ) ; } 
687	public int getSearchAffordanceColor ( ) { return getSearchAffordanceColors ( ) . color ; } 
688	protected boolean shouldSelect ( Transaction tx ) { if ( tx ! = null ) { return isSelectable ( tx ) ; } return true ; } 
689	private void reportGeofenceOperationStatus ( int operation , int geofenceId , int operationStatus ) { acquireWakeLock ( ) ; Message message = mGeofenceHandler . obtainMessage ( operation ) ; message . arg _NUM = geofenceId ; message . arg _NUM = operationStatus ; message . sendToTarget ( ) ; } 
690	public void write ( byte [ ] buffer , int offset , int length ) throws IOException { while ( ( mByteToSkip > _NUM | | mByteToCopy > _NUM | | mState ! = STATE _ JPEG _ DATA ) & & length > _NUM ) { if ( mByteToSkip > _NUM ) { int byteToProcess = length > mByteToSkip ? mByteToSkip : length ; length - = byteToProcess ; mByteToSkip - = byteToProcess ; offset + = byteToProcess ; } if ( mByteToCopy > _NUM ) { int byteToProcess = length > mByteToCopy ? mByteToCopy : length ; out . write ( buffer , offset , byteToProcess ) ; length - = byteToProcess ; mByteToCopy - = byteToProcess ; offset + = byteToProcess ; } if ( length = = _NUM ) { return ; } switch ( mState ) { case STATE _ SOI : int byteRead = requestByteToBuffer ( _NUM , buffer , offset , length ) ; offset + = byteRead ; length - = byteRead ; if ( mBuffer . position ( ) < _NUM ) { return ; } mBuffer . rewind ( ) ; if ( mBuffer . getShort ( ) ! = JpegHeader . SOI ) { throw new IOException ( _STR ) ; } out . write ( mBuffer . array ( ) , _NUM , _NUM ) ; mState = STATE _ FRAME _ HEADER ; mBuffer . rewind ( ) ; writeExifData ( ) ; break ; case STATE _ FRAME _ HEADER : We ignore the APP _NUM segment and copy all other segments until SOF tag . byteRead = requestByteToBuffer ( _NUM , buffer , offset , length ) ; offset + = byteRead ; length - = byteRead ; Check if this image data doesn ' t contain SOF . if ( mBuffer . position ( ) = = _NUM ) { short tag = mBuffer . getShort ( ) ; if ( tag = = JpegHeader . EOI ) { out . write ( mBuffer . array ( ) , _NUM , _NUM ) ; mBuffer . rewind ( ) ; } } if ( mBuffer . position ( ) < _NUM ) { return ; } mBuffer . rewind ( ) ; short marker = mBuffer . getShort ( ) ; if ( marker = = JpegHeader . APP _NUM ) { mByteToSkip = ( mBuffer . getShort ( ) & _NUM x _NUM _NUM _NUM _NUM ffff ) - _NUM ; mState = STATE _ JPEG _ DATA ; } else if ( ! JpegHeader . isSofMarker ( marker ) ) { out . write ( mBuffer . array ( ) , _NUM , _NUM ) ; mByteToCopy = ( mBuffer . getShort ( ) & _NUM x _NUM _NUM _NUM _NUM ffff ) - _NUM ; } else { out . write ( mBuffer . array ( ) , _NUM , _NUM ) ; mState = STATE _ JPEG _ DATA ; } mBuffer . rewind ( ) ; } } if ( length > _NUM ) { out . write ( buffer , offset , length ) ; } } 
691	private char nextCharSkipSpaces ( ) { char c = nextChar ( ) ; while ( c = = ' ' | | c = = ' \ t ' | | c = = ' \ n ' ) c = nextChar ( ) ; return c ; } 
692	static DoublesUnionImpl directInstance ( final int maxK , final WritableMemory dstMem ) { final DirectUpdateDoublesSketch sketch = DirectUpdateDoublesSketch . newInstance ( maxK , dstMem ) ; final DoublesUnionImpl union = new DoublesUnionImpl ( maxK ) ; union . maxK _ = maxK ; union . gadget _ = sketch ; return union ; } 
693	public void assertContains ( Description description , Collection < ? > actual , Object [ ] values ) { checkIsNotNullAndNotEmpty ( values ) ; assertNotNull ( description , actual ) ; Set < Object > notFound = new LinkedHashSet < Object > ( ) ; for ( Object value : values ) { if ( ! actual . contains ( value ) ) { notFound . add ( value ) ; } } if ( notFound . isEmpty ( ) ) { return ; } throw failures . failure ( description , shouldContain ( actual , values , notFound ) ) ; } 
694	public void setRGBColorFillF ( float red , float green , float blue ) { checkNoColor ( ) ; super . setRGBColorFillF ( red , green , blue ) ; } 
695	public static String removeAdditionalParty ( HttpServletRequest request , HttpServletResponse response ) { ShoppingCart cart = getCartObject ( request ) ; String partyId = request . getParameter ( _STR ; } 
696	public X _NUM _NUM _NUM CRL generate ( PrivateKey key , String provider , SecureRandom random ) throws CRLException , IllegalStateException , NoSuchProviderException , NoSuchAlgorithmException , SignatureException , InvalidKeyException { TBSCertList tbsCrl = generateCertList ( ) ; byte [ ] signature ; try { signature = X _NUM _NUM _NUM Util . calculateSignature ( sigOID , signatureAlgorithm , provider , key , random , tbsCrl ) ; } catch ( IOException e ) { throw new ExtCRLException ( _STR , e ) ; } return generateJcaObject ( tbsCrl , signature ) ; } 
697	public String buildLockRequest ( int hiddenTimeout , boolean includeRelated ) { StringBuffer html = new StringBuffer ( _NUM _NUM _NUM ) ; html . append ( _STR ) ; return html . toString ( ) ; } 
698	public IndexCosts costs ( final Data data , final IndexToken token ) { return enforce ( ) ? IndexCosts . ENFORCE : data . costs ( token ) ; } 
699	public static NSObject parse ( InputStream is ) throws IOException , PropertyListFormatException { byte [ ] buf = PropertyListParser . readAll ( is ) ; return parse ( buf ) ; } 
700	public void test ( ) throws Exception { int timeoutMins = _NUM ; RetryUpgradeActionService service = injector . getInstance ( RetryUpgradeActionService . class ) ; service . startUp ( ) ; Case _NUM : No cluster service . runOneIteration ( ) ; Case _NUM : Cluster and valid timeout , but no active upgrade createCluster ( ) ; service . setMaxTimeout ( timeoutMins ) ; service . runOneIteration ( ) ; Case _NUM : Cluster with an active upgrade , but no HOLDING _ FAILED | HOLDING _ TIMEDOUT commands . prepareUpgrade ( ) ; Run the service service . runOneIteration ( ) ; Assert all commands in PENDING List < HostRoleCommandEntity > commands = hostRoleCommandDAO . findAll ( ) ; Assert . assertTrue ( ! commands . isEmpty ( ) ) ; for ( HostRoleCommandEntity hrc : commands ) { if ( hrc . getStatus ( ) = = HostRoleStatus . PENDING ) { Assert . fail ( _STR ) ; hostRoleCommandDAO . merge ( hrc _NUM ) ; Run the service service . runOneIteration ( ) ; Assert . assertEquals ( HostRoleStatus . HOLDING _ FAILED , hostRoleCommandDAO . findByPK ( hrc _NUM . getTaskId ( ) ) . getStatus ( ) ) ; } 
701	public void invalidate ( String bpid , Block [ ] invalidBlks ) throws IOException { final List < String > errors = new ArrayList < String > ( ) ; for ( int i = _NUM ; i < invalidBlks . length ; i + + ) { final File f ; final FsVolumeImpl v ; synchronized ( this ) { final ReplicaInfo info = volumeMap . get ( bpid , invalidBlks [ i ] ) ; if ( info = = null ) { It is okay if the block is not found - - it may be deleted earlier . LOG . info ( _STR ) . append ( errors . get ( i ) ) ; } throw new IOException ( b . toString ( ) ) ; } } 
702	private int lineToY ( int line ) { int h = textArea . getVisibleRect ( ) . height ; float lineCount = textArea . getLineCount ( ) ; return ( int ) ( ( ( line - _NUM ) / ( lineCount - _NUM ) ) * ( h - _NUM ) ) ; } 
703	public boolean onStop ( ) { cleanUpPlayer ( ) ; setState ( STATE _ STOPPED ) ; return true ; } 
704	public boolean initSettings ( CmsWorkplaceSettings settings , HttpServletRequest request ) { check if the user requested a project change String project = request . getParameter ( PARAM _ WP _ PROJECT ) ; boolean reloadRequired = false ; if ( project ! = null ) { reloadRequired = true ; try { getCms ( ) . readProject ( new CmsUUID ( project ) ) ; } catch ( Exception e ) { project not found , set online project project = String . valueOf ( CmsProject . ONLINE _ PROJECT _ ID ) ; } try { m _ cms . getRequestContext ( ) . setCurrentProject ( getCms ( ) . readProject ( new CmsUUID ( project ) ) ) ; } catch ( Exception e ) { if ( LOG . isInfoEnabled ( ) ) { LOG . info ( e ) ; } } settings . setProject ( new CmsUUID ( project ) ) ; } check if the user requested a site change String site = request . getParameter ( PARAM _ WP _ SITE ) ; if ( site ! = null ) { reloadRequired = true ; m _ cms . getRequestContext ( ) . setSiteRoot ( site ) ; settings . setSite ( site ) ; } check which resource was requested String explorerResource = request . getParameter ( PARAM _ WP _ EXPLORER _ RESOURCE ) ; if ( explorerResource ! = null ) { reloadRequired = true ; settings . setExplorerResource ( explorerResource , getCms ( ) ) ; } return reloadRequired ; } 
705	public void testGroupBy ( ) { hr ( ) . query ( _STR ) ; } 
706	public void resizeRange ( double percent , double anchorValue ) { if ( percent > _NUM . _NUM ) { double halfLength = getDisplayLength ( ) * percent / _NUM ; setDisplayRange ( anchorValue - halfLength , anchorValue + halfLength ) ; } else { setAutoRange ( true ) ; } } 
707	private void handleMajorStateChange ( InetAddressAndPort ep , EndpointState epState ) { EndpointState localEpState = endpointStateMap . get ( ep ) ; if ( ! isDeadState ( epState ) ) { if ( localEpState ! = null ) logger . info ( _STR , ep ) ; markDead ( ep , epState ) ; } for ( IEndpointStateChangeSubscriber subscriber : subscribers ) subscriber . onJoin ( ep , epState ) ; check this at the end so nodes will learn about the endpoint if ( isShutdown ( ep ) ) markAsShutdown ( ep ) ; } 
708	public void testFallbackFromShortCircuitToUnixDomainTraffic ( ) throws Exception { DFSInputStream . tcpReadsDisabledForTesting = true ; TemporarySocketDirectory sockDir = new TemporarySocketDirectory ( ) ; The server is NOT configured with short - circuit local reads ; the client is . Both support UNIX domain reads . Configuration clientConf = createShortCircuitConf ( _STR ; final int TEST _ FILE _ LEN = _NUM _NUM _NUM _NUM ; final int SEED = _NUM xFADED ; DFSTestUtil . createFile ( dfs , new Path ( TEST _ FILE ) , TEST _ FILE _ LEN , ( short ) _NUM , SEED ) ; byte [ ] contents = DFSTestUtil . readFileBuffer ( dfs , new Path ( TEST _ FILE ) ) ; byte [ ] expected = DFSTestUtil . calculateFileContentsFromSeed ( SEED , TEST _ FILE _ LEN ) ; Assert . assertTrue ( Arrays . equals ( contents , expected ) ) ; cluster . shutdown ( ) ; sockDir . close ( ) ; } 
709	public Animator onAppear ( ViewGroup sceneRoot , TransitionValues startValues , int startVisibility , TransitionValues endValues , int endVisibility ) { if ( ( mMode & MODE _ IN ) ! = MODE _ IN | | endValues = = null ) { return null ; } if ( startValues = = null ) { VisibilityInfo parentVisibilityInfo = null ; View endParent = ( View ) endValues . view . getParent ( ) ; TransitionValues startParentValues = getMatchedTransitionValues ( endParent , false ) ; TransitionValues endParentValues = getTransitionValues ( endParent , false ) ; parentVisibilityInfo = getVisibilityChangeInfo ( startParentValues , endParentValues ) ; if ( parentVisibilityInfo . visibilityChange ) { return null ; } } final boolean isForcedVisibility = mForcedStartVisibility ! = - _NUM | | mForcedEndVisibility ! = - _NUM ; if ( isForcedVisibility ) { Make sure that we reverse the effect of onDisappear ' s setTransitionAlpha ( _NUM ) Object savedAlpha = endValues . view . getTag ( R . id . transitionAlpha ) ; if ( savedAlpha instanceof Float ) { endValues . view . setAlpha ( ( Float ) savedAlpha ) ; endValues . view . setTag ( R . id . transitionAlpha , null ) ; } } return onAppear ( sceneRoot , endValues . view , startValues , endValues ) ; } 
710	public static void getDelegationTokens ( Configuration job , Credentials credentials ) throws IOException { URI [ ] tarchives = DistributedCache . getCacheArchives ( job ) ; URI [ ] tfiles = DistributedCache . getCacheFiles ( job ) ; int size = ( tarchives ! = null ? tarchives . length : _NUM ) + ( tfiles ! = null ? tfiles . length : _NUM ) ; Path [ ] ps = new Path [ size ] ; int i = _NUM ; if ( tarchives ! = null ) { for ( i = _NUM ; i < tarchives . length ; i + + ) { ps [ i ] = new Path ( tarchives [ i ] . toString ( ) ) ; } } if ( tfiles ! = null ) { for ( int j = _NUM ; j < tfiles . length ; j + + ) { ps [ i + j ] = new Path ( tfiles [ j ] . toString ( ) ) ; } } TokenCache . obtainTokensForNamenodes ( credentials , ps , job ) ; } 
711	public void flush ( ) throws IOException { flushBuffer ( ) ; if ( out ! = null ) { out . flush ( ) ; } } 
712	public boolean releaseInstance ( ) { try { return ActivityManager . getService ( ) . releaseActivityInstance ( mToken ) ; } catch ( RemoteException e ) { Empty } return false ; } 
713	public static TimeBasedGenerator timeBasedGenerator ( EthernetAddress ethernetAddress , UUIDTimer timer ) { if ( timer = = null ) { timer = sharedTimer ( ) ; } return new TimeBasedGenerator ( ethernetAddress , timer ) ; } 
714	protected boolean startObjectDefinition ( final String className , final String register , final boolean ignore ) throws ObjectDescriptionException { if ( ignore ) { return false ; } this . target = loadClass ( className ) ; if ( this . target = = null ) { Log . warn ( new Log . SimpleMessage ( _STR , className ) ) ; return false ; } this . registerName = register ; this . propertyDefinition = new ArrayList ( ) ; this . attributeDefinition = new ArrayList ( ) ; this . constructorDefinition = new ArrayList ( ) ; this . lookupDefinitions = new ArrayList ( ) ; this . orderedNames = new ArrayList ( ) ; return true ; } 
715	public static Dataset createLucene ( Dataset base , Directory directory , EntityDefinition entMap ) { SpatialIndex index = createLuceneIndex ( directory , entMap ) ; return create ( base , index ) ; } 
716	 @ Test ( timeout = _NUM _NUM _NUM _NUM _NUM _NUM ) @ SuppressWarnings ( _STR ) ) ; Returns null when there are no further events Assert . assertTrue ( eis . poll ( ) = = null ) ; make sure the estimate hasn ' t changed since the above assertion tells us that we are fully caught up to the current namesystem state and we should not have been behind at all when eventsBehind was set either , since there were few enough events that they should have all been read to the client during the first poll ( ) call Assert . assertTrue ( eis . getTxidsBehindEstimate ( ) = = eventsBehind ) ; } finally { cluster . shutdown ( ) ; } } 
717	public static XmlNegativeInteger parse ( java . io . Reader r ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( XmlNegativeInteger ) XmlBeans . getContextTypeLoader ( ) . parse ( r , type , null ) ; } 
718	public DecimalBuilder setArgumentsFromDouble ( double number , int minimumFractionDigits , int maximumFractionDigits ) { Format double . NumberFormat formatter = NumberFormat . getInstance ( Locale . US ) ; formatter . setMinimumFractionDigits ( maximumFractionDigits ) ; formatter . setMaximumFractionDigits ( maximumFractionDigits ) ; formatter . setGroupingUsed ( false ) ; String str = formatter . format ( number ) ; Split at decimal point . int i = str . indexOf ( ' . ' ) ; if ( i > = _NUM ) { setIntegerPart ( str . substring ( _NUM , i ) ) ; setFractionalPart ( str . substring ( i + _NUM ) ) ; } else { setIntegerPart ( str ) ; } return this ; } 
719	 @ GET @ Consumes ( MediaType . WILDCARD ) @ Produces ( MediaType . APPLICATION _ JSON ) @ Path ( _STR ) ; } if ( isReplicateRequest ( ) ) { return replicate ( HttpMethod . GET ) ; } authorize access serviceFacade . authorizeAccess ( lookup - > { final Authorizable processor = lookup . getProcessor ( id ) . getAuthorizable ( ) ; processor . authorize ( authorizer , RequestAction . READ , NiFiUserUtils . getNiFiUser ( ) ) ; } ) ; get the property descriptor final PropertyDescriptorDTO descriptor = serviceFacade . getProcessorPropertyDescriptor ( id , propertyName ) ; generate the response entity final PropertyDescriptorEntity entity = new PropertyDescriptorEntity ( ) ; entity . setPropertyDescriptor ( descriptor ) ; generate the response return generateOkResponse ( entity ) . build ( ) ; } 
720	protected void replaceText ( CharSequence text ) { clearComposingText ( ) ; setText ( text ) ; make sure we keep the caret at the end of the text view Editable spannable = getText ( ) ; Selection . setSelection ( spannable , spannable . length ( ) ) ; } 
721	public static String formatMode ( short mode , boolean directory ) { StringBuilder str = new StringBuilder ( ) ; if ( directory ) { str . append ( _STR ) ; } str . append ( new Mode ( mode ) . toString ( ) ) ; return str . toString ( ) ; } 
722	private void updateCommands ( ) { int commandBehavior = getCommandBehavior ( ) ; if ( commandBehavior = = Display . COMMAND _ BEHAVIOR _ NATIVE ) { Display . getInstance ( ) . getImplementation ( ) . setNativeCommands ( commands ) ; return ; } if ( commandBehavior > = Display . COMMAND _ BEHAVIOR _ BUTTON _ BAR ) { return ; } if ( soft . length > _NUM ) { soft [ _NUM ] . setText ( _STR ) ; if ( commandSize > _NUM ) { if ( commandSize > _NUM ) { softCommand [ _NUM ] = menuCommand ; } else { softCommand [ _NUM ] = getCommand ( getCommandCount ( ) - _NUM ) ; } soft [ _NUM ] . setText ( softCommand [ _NUM ] . getCommandName ( ) ) ; soft [ _NUM ] . setIcon ( softCommand [ _NUM ] . getIcon ( ) ) ; } else { softCommand [ _NUM ] = null ; } } if ( commandSize > _NUM ) { softCommand [ _NUM ] = getCommand ( getCommandCount ( ) - _NUM ) ; soft [ _NUM ] . setText ( softCommand [ _NUM ] . getCommandName ( ) ) ; soft [ _NUM ] . setIcon ( softCommand [ _NUM ] . getIcon ( ) ) ; if ( commandSize > _NUM ) { if ( soft . length = = _NUM & & commandSize > _NUM ) { softCommand [ _NUM ] = menuCommand ; } else { softCommand [ _NUM ] = getCommand ( getCommandCount ( ) - _NUM ) ; } soft [ _NUM ] . setText ( softCommand [ _NUM ] . getCommandName ( ) ) ; soft [ _NUM ] . setIcon ( softCommand [ _NUM ] . getIcon ( ) ) ; } else { softCommand [ _NUM ] = null ; } } else { softCommand [ _NUM ] = null ; softCommand [ _NUM ] = null ; } we need to add the menu bar to an already visible form if ( commandSize = = _NUM ) { if ( parent . isVisible ( ) ) { parent . revalidate ( ) ; } } repaint ( ) ; } } 
723	public void storeJSON ( String name ) { try { OutputStream os = Storage . getInstance ( ) . createOutputStream ( name ) ; os . write ( toJSON ( ) . getBytes ( _STR ) ) ; os . close ( ) ; } catch ( IOException err ) { Log . e ( err ) ; throw new RuntimeException ( err . toString ( ) ) ; } } 
724	private Properties createServiceContextProperties ( ) { final Properties contextProperties = new Properties ( ) ; contextProperties . setProperty ( CloudifyConstants . CONTEXT _ PROPERTY _ APPLICATION _ NAME , deploymentConfig . getApplicationName ( ) ) ; contextProperties . setProperty ( CloudifyConstants . CONTEXT _ PROPERTY _ AUTH _ GROUPS , deploymentConfig . getAuthGroups ( ) ) ; contextProperties . setProperty ( CloudifyConstants . CONTEXT _ PROPERTY _ DEPLOYMENT _ ID , deploymentConfig . getDeploymentId ( ) ) ; if ( deploymentConfig . getTemplateName ( ) ! = null ) { contextProperties . setProperty ( CloudifyConstants . CONTEXT _ PROPERTY _ TEMPLATE , deploymentConfig . getTemplateName ( ) ) ; } final Service service = deploymentConfig . getService ( ) ; final List < String > dependsOn = service . getDependsOn ( ) ; if ( dependsOn . isEmpty ( ) ) { contextProperties . setProperty ( CloudifyConstants . CONTEXT _ PROPERTY _ DEPENDS _ ON , _STR ) ; } else { final List < String > absoluteServiceNames = new ArrayList < String > ( ) ; for ( final String name : dependsOn ) { absoluteServiceNames . add ( ServiceUtils . getAbsolutePUName ( deploymentConfig . getApplicationName ( ) , name . trim ( ) ) ) ; } contextProperties . setProperty ( CloudifyConstants . CONTEXT _ PROPERTY _ DEPENDS _ ON , Arrays . toString ( absoluteServiceNames . toArray ( ) ) ) ; } if ( service . getType ( ) ! = null ) { contextProperties . setProperty ( CloudifyConstants . CONTEXT _ PROPERTY _ SERVICE _ TYPE , service . getType ( ) ) ; } if ( service . getIcon ( ) ! = null ) { contextProperties . setProperty ( CloudifyConstants . CONTEXT _ PROPERTY _ SERVICE _ ICON , CloudifyConstants . SERVICE _ EXTERNAL _ FOLDER + service . getIcon ( ) ) ; } if ( service . getNetwork ( ) ! = null ) { if ( service . getNetwork ( ) . getProtocolDescription ( ) ! = null ) { contextProperties . setProperty ( CloudifyConstants . CONTEXT _ PROPERTY _ NETWORK _ PROTOCOL _ DESCRIPTION , service . getNetwork ( ) . getProtocolDescription ( ) ) ; } } final String cloudName = getCloudName ( ) ; contextProperties . setProperty ( CloudifyConstants . CONTEXT _ PROPERTY _ CLOUD _ NAME , cloudName ) ; contextProperties . setProperty ( CloudifyConstants . CONTEXT _ PROPERTY _ ELASTIC , Boolean . toString ( service . isElastic ( ) ) ) ; final InstallServiceRequest installRequest = deploymentConfig . getInstallRequest ( ) ; if ( installRequest . isDebugAll ( ) ) { contextProperties . setProperty ( CloudifyConstants . CONTEXT _ PROPERTY _ DEBUG _ ALL , Boolean . TRUE . toString ( ) ) ; contextProperties . setProperty ( CloudifyConstants . CONTEXT _ PROPERTY _ DEBUG _ MODE , installRequest . getDebugMode ( ) ) ; } else if ( installRequest . getDebugEvents ( ) ! = null ) { contextProperties . setProperty ( CloudifyConstants . CONTEXT _ PROPERTY _ DEBUG _ EVENTS , installRequest . getDebugEvents ( ) ) ; contextProperties . setProperty ( CloudifyConstants . CONTEXT _ PROPERTY _ DEBUG _ MODE , installRequest . getDebugMode ( ) ) ; } return contextProperties ; } 
725	private void mergeConfigUpgradePack ( ConfigUpgradePack pack , File upgradesFolder ) throws AmbariException { File stackFolder = new File ( upgradesFolder , stackInfo . getName ( ) ) ; File versionFolder = new File ( stackFolder , stackInfo . getVersion ( ) ) ; File serviceConfig = new File ( versionFolder , StackDefinitionDirectory . CONFIG _ UPGRADE _ XML _ FILENAME _ PREFIX ) ; if ( ! serviceConfig . exists ( ) ) { return ; } try { ConfigUpgradePack serviceConfigPack = unmarshaller . unmarshal ( ConfigUpgradePack . class , serviceConfig ) ; pack . services . addAll ( serviceConfigPack . services ) ; } catch ( Exception e ) { throw new AmbariException ( _STR + serviceConfig . getAbsolutePath ( ) , e ) ; } } 
726	public final void createErr ( ) throws IOException { session . create ( NAME , new ArrayInput ( _STR ) ) ; } 
727	public int [ ] scanLeft ( int seed , IntBinaryOperator accumulator ) { return prepend ( seed ) . scanLeft ( accumulator ) ; } 
728	public void testImportExportFolder ( ) throws Exception { CmsObject cms = getCmsObject ( ) ; echo ( _STR , true ) ) ; } finally { try { if ( zipExportFilename ! = null ) { File file = new File ( zipExportFilename ) ; if ( file . exists ( ) ) { file . delete ( ) ; } } } catch ( Throwable t ) { intentionally left blank } } assertResources ( cms , filename , startResources ) ; } 
729	public final int parent ( final int pre , final int kind ) { return pre - dist ( pre , kind ) ; } 
730	protected boolean compareQualifier ( final CompareOp compareOp , final ByteArrayComparable comparator , final Cell cell ) { We do not call through to the non - deprecated method for perf reasons . if ( compareOp = = CompareOp . NO _ OP ) { return true ; } int compareResult = PrivateCellUtil . compareQualifier ( cell , comparator ) ; return compare ( compareOp , compareResult ) ; } 
731	private List < CmsSitemapTreeItem > getItemsOnPath ( String path ) { List < CmsSitemapTreeItem > result = new ArrayList < CmsSitemapTreeItem > ( ) ; CmsSitemapData data = m _ controller . getData ( ) ; CmsClientSitemapEntry root = data . getRoot ( ) ; String rootSitePath = root . getSitePath ( ) ; String remainingPath = path . substring ( rootSitePath . length ( ) ) ; CmsSitemapTreeItem currentItem = getRootItem ( ) ; result . add ( currentItem ) ; String [ ] names = CmsStringUtil . splitAsArray ( remainingPath , _STR ) ; for ( String name : names ) { if ( currentItem = = null ) { break ; } if ( CmsStringUtil . isEmptyOrWhitespaceOnly ( name ) ) { continue ; } currentItem = ( CmsSitemapTreeItem ) currentItem . getChild ( name ) ; if ( currentItem ! = null ) { result . add ( currentItem ) ; } } return result ; } 
732	private static byte [ ] nextDecimalKey ( byte [ ] key ) { BigDecimal decimal = ( BigDecimal ) PDecimal . INSTANCE . toObject ( key ) ; BigDecimal next = decimal . add ( getSmallestUnit ( decimal ) ) ; return PDecimal . INSTANCE . toBytes ( next ) ; } 
733	private static CharacterStyle getColor ( String color , boolean foreground ) { int c = _NUM xff _NUM _NUM _NUM _NUM _NUM _NUM ; if ( ! TextUtils . isEmpty ( color ) ) { if ( color . startsWith ( _STR ) ; if ( colorRes ! = _NUM ) { ColorStateList colors = res . getColorStateList ( colorRes , null ) ; if ( foreground ) { return new TextAppearanceSpan ( null , _NUM , _NUM , colors , null ) ; } else { c = colors . getDefaultColor ( ) ; } } } else { try { c = Color . parseColor ( color ) ; } catch ( IllegalArgumentException e ) { c = Color . BLACK ; } } } if ( foreground ) { return new ForegroundColorSpan ( c ) ; } else { return new BackgroundColorSpan ( c ) ; } } 
734	public static < T , K , D , A , M extends Map < K , D > > Collector < T , ? , M > groupingBy ( Function < ? super T , ? extends K > classifier , Set < K > domain , Supplier < M > mapFactory , Collector < ? super T , A , D > downstream ) { Supplier < A > downstreamSupplier = downstream . supplier ( ) ; Collector < T , ? , M > groupingBy ; Function < K , A > supplier = k - > { if ( ! domain . contains ( k ) ) throw new IllegalStateException ( _STR ) ; return downstreamSupplier . get ( ) ; } ; BiConsumer < A , ? super T > downstreamAccumulator = downstream . accumulator ( ) ; BiConsumer < Map < K , A > , T > accumulator = ( m , t ) - > { K key = Objects . requireNonNull ( classifier . apply ( t ) ) ; A container = m . computeIfAbsent ( key , supplier ) ; downstreamAccumulator . accept ( container , t ) ; } ; PartialCollector < Map < K , A > , M > partial = PartialCollector . grouping ( mapFactory , downstream ) ; Predicate < A > downstreamFinished = finished ( downstream ) ; if ( downstreamFinished ! = null ) { int size = domain . size ( ) ; groupingBy = partial . asCancellable ( accumulator , map - > { if ( map . size ( ) < size ) return false ; for ( A container : map . values ( ) ) { if ( ! downstreamFinished . test ( container ) ) return false ; } return true ; } ) ; } else { groupingBy = partial . asRef ( accumulator ) ; } return collectingAndThen ( groupingBy , map - > { Function < A , D > finisher = downstream . finisher ( ) ; domain . forEach ( key - > map . computeIfAbsent ( key , k - > finisher . apply ( downstreamSupplier . get ( ) ) ) ) ; return map ; } ) ; } 
735	public void testScheduleNextBlockReport _NUM ( ) { for ( final long now : getTimestamps ( ) ) { Scheduler scheduler = makeMockScheduler ( now ) ; scheduler . resetBlockReportTime = false ; Make it look like the block report was scheduled to be sent between _NUM - _NUM intervals ago but sent just now . final long blockReportDelay = BLOCK _ REPORT _ INTERVAL _ MS + random . nextInt ( _NUM * ( int ) BLOCK _ REPORT _ INTERVAL _ MS ) ; final long origBlockReportTime = now - blockReportDelay ; scheduler . nextBlockReportTime = origBlockReportTime ; scheduler . scheduleNextBlockReport ( ) ; assertTrue ( scheduler . nextBlockReportTime - now < BLOCK _ REPORT _ INTERVAL _ MS ) ; assertTrue ( ( ( scheduler . nextBlockReportTime - origBlockReportTime ) % BLOCK _ REPORT _ INTERVAL _ MS ) = = _NUM ) ; } } 
736	public synchronized Countly addCrashLog ( String record ) { if ( Countly . sharedInstance ( ) . isLoggingEnabled ( ) ) { Log . d ( Countly . TAG , _STR ) ; } CrashDetails . addLog ( record ) ; return this ; } 
737	public boolean verifyData ( String x _ app _ id , String content _ type , String package _ name , String class _ name , int app _ type , boolean need _ signature , boolean further _ processing ) { WapPushManDBHelper dbh = getDatabase ( this ) ; SQLiteDatabase db = dbh . getReadableDatabase ( ) ; WapPushManDBHelper . queryData lastapp = dbh . queryLastApp ( db , x _ app _ id , content _ type ) ; if ( LOCAL _ LOGV ) Log . v ( LOG _ TAG , _STR + lastapp . furtherProcessing ) ; if ( lastapp . packageName . equals ( package _ name ) & & lastapp . className . equals ( class _ name ) & & lastapp . appType = = app _ type & & lastapp . needSignature = = ( need _ signature ? _NUM : _NUM ) & & lastapp . furtherProcessing = = ( further _ processing ? _NUM : _NUM ) ) { return true ; } else { return false ; } } 
738	private static final boolean setLocationModeForUser ( ContentResolver cr , int mode , int userId ) { synchronized ( mLocationSettingsLock ) { boolean gps = false ; boolean network = false ; switch ( mode ) { case LOCATION _ MODE _ PREVIOUS : Retrieve the actual mode and set to that mode . return restoreLocationModeForUser ( cr , userId ) ; case LOCATION _ MODE _ OFF : saveLocationModeForUser ( cr , userId ) ; break ; case LOCATION _ MODE _ SENSORS _ ONLY : gps = true ; break ; case LOCATION _ MODE _ BATTERY _ SAVING : network = true ; break ; case LOCATION _ MODE _ HIGH _ ACCURACY : gps = true ; network = true ; break ; default : throw new IllegalArgumentException ( _STR + mode ) ; } Note it ' s important that we set the NLP mode first . The Google implementation of NLP clears its NLP consent setting any time it receives a LocationManager . PROVIDERS _ CHANGED _ ACTION broadcast and NLP is disabled . Also , it shows an NLP consent dialog any time it receives the broadcast , NLP is enabled , and the NLP consent is not set . If _NUM ) we were to enable GPS first , _NUM ) a setup wizard has its own NLP consent UI that sets the NLP consent setting , and _NUM ) the receiver happened to complete before we enabled NLP , then the Google NLP would detect the attempt to enable NLP and show a redundant NLP consent dialog . Then the people who wrote the setup wizard would be sad . boolean nlpSuccess = Settings . Secure . setLocationProviderEnabledForUser ( cr , LocationManager . NETWORK _ PROVIDER , network , userId ) ; boolean gpsSuccess = Settings . Secure . setLocationProviderEnabledForUser ( cr , LocationManager . GPS _ PROVIDER , gps , userId ) ; return gpsSuccess & & nlpSuccess ; } } 
739	public boolean contains ( final byte [ ] name ) { return get ( name ) ! = - _NUM ; } 
740	public void testBoundaryEventSubscriptionDeletedOnDeploymentDelete ( ) { String deploymentId = deployBoundaryMessageTestProcess ( ) ; runtimeService . startProcessInstanceByKeyAndTenantId ( _STR , taskService . createTaskQuery ( ) . singleResult ( ) . getName ( ) ) ; assertEquals ( _NUM , getAllEventSubscriptions ( ) . size ( ) ) ; repositoryService . deleteDeployment ( deploymentId _NUM , true ) ; assertEquals ( _NUM , getAllEventSubscriptions ( ) . size ( ) ) ; } 
741	public void testFileIdMismatch ( ) throws IOException { Configuration conf = new HdfsConfiguration ( ) ; MiniDFSCluster cluster = new MiniDFSCluster . Builder ( conf ) . numDataNodes ( _NUM ) . build ( ) ; DistributedFileSystem dfs = null ; try { cluster . waitActive ( ) ; dfs = cluster . getFileSystem ( ) ; DFSClient client = dfs . dfs ; final Path f = new Path ( _STR , e ) ; } } finally { IOUtils . closeStream ( dfs ) ; cluster . shutdown ( ) ; } } 
742	private org . apache . usergrid . persistence . Entity getApplicationInfo ( final UUID appId ) throws Exception { final ApplicationScope managementAppScope = getApplicationScope ( CpNamingUtils . MANAGEMENT _ APPLICATION _ ID ) ; final EntityCollectionManager managementCollectionManager = entityCollectionManagerFactory . createCollectionManager ( managementAppScope ) ; Observable < MarkedEdge > edgesObservable = getApplicationInfoEdges ( appId ) ; get the graph for all app infos Observable < org . apache . usergrid . persistence . model . entity . Entity > entityObs = edgesObservable . flatMap ( edge - > { final Id appInfoId = edge . getTargetNode ( ) ; return managementCollectionManager . load ( appInfoId ) . filter ( entity - > { check for app id return entity ! = null ? entity . getId ( ) . getUuid ( ) . equals ( appId ) : false ; } ) ; } ) ; don ' t expect many applications , so we block org . apache . usergrid . persistence . model . entity . Entity applicationInfo = entityObs . toBlocking ( ) . lastOrDefault ( null ) ; if ( applicationInfo = = null ) { return null ; } Class clazz = Schema . getDefaultSchema ( ) . getEntityClass ( applicationInfo . getId ( ) . getType ( ) ) ; org . apache . usergrid . persistence . Entity entity = EntityFactory . newEntity ( applicationInfo . getId ( ) . getUuid ( ) , applicationInfo . getId ( ) . getType ( ) , clazz ) ; entity . setProperties ( CpEntityMapUtils . toMap ( applicationInfo ) ) ; return entity ; } 
743	public static int getIsSyncableAsUser ( Account account , String authority , @ UserIdInt int userId ) { try { return getContentService ( ) . getIsSyncableAsUser ( account , authority , userId ) ; } catch ( RemoteException e ) { throw new RuntimeException ( _STR , e ) ; } } 
744	public static String getLocalIp ( ) throws UnknownHostException { return chooseAddress ( ) . getHostAddress ( ) ; } 
745	public org . apache . drill . exec . proto . BitControl . PlanFragment . Builder addFragmentBuilder ( ) { return getFragmentFieldBuilder ( ) . addBuilder ( org . apache . drill . exec . proto . BitControl . PlanFragment . getDefaultInstance ( ) ) ; } 
746	public Iterator < Element > iterator ( ) { return new AbstractIterator < Element > ( ) { private final Iterator < Element > i = vector . all ( ) . iterator ( ) ; @ Override protected Vector . Element computeNext ( ) { if ( i . hasNext ( ) ) { final Element x = i . next ( ) ; return new Element ( ) { private final int index = unpivot [ x . index ( ) ] ; @ Override public double get ( ) { return x . get ( ) ; } @ Override public int index ( ) { return index ; } @ Override public void set ( double value ) { x . set ( value ) ; } } ; } else { return endOfData ( ) ; } } } ; } 
747	public void setLayout ( Layout layout ) { if ( layout . isConstraintTracking ( ) ) { for ( int iter = _NUM ; iter < getComponentCount ( ) ; iter + + ) { Component c = getComponentAt ( iter ) ; Object cons = this . layout . getComponentConstraint ( c ) ; if ( cons ! = null ) { layout . addLayoutComponent ( cons , c , this ) ; } } } this . layout = layout ; if ( layout instanceof BorderLayout & & isScrollable ( ) ) { setScrollable ( false ) ; } } 
748	private void displayQueueInfo ( String queue , boolean showJobs ) throws IOException , InterruptedException { JobQueueInfo jobQueueInfo = jc . getQueueInfo ( queue ) ; if ( jobQueueInfo = = null ) { System . out . println ( _STR ) ; return ; } printJobQueueInfo ( jobQueueInfo , new PrintWriter ( new OutputStreamWriter ( System . out , Charsets . UTF _ _NUM ) ) ) ; if ( showJobs & & ( jobQueueInfo . getChildren ( ) = = null | | jobQueueInfo . getChildren ( ) . size ( ) = = _NUM ) ) { JobStatus [ ] jobs = jobQueueInfo . getJobStatuses ( ) ; if ( jobs = = null ) jobs = new JobStatus [ _NUM ] ; jc . displayJobList ( jobs ) ; } } 
749	public void advance ( ) { showNext ( ) ; } 
750	public void write ( int ch ) throws IOException { ch = ch & _NUM xff ; _ os . write ( ch ) ; _ state . next ( ch ) ; } 
751	public static XmlAnySimpleType parse ( java . io . Reader r ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( XmlAnySimpleType ) XmlBeans . getContextTypeLoader ( ) . parse ( r , type , null ) ; } 
752	public String toStringKey ( ) { String result ; int i ; result = _STR ; } return result ; } 
753	public AxisState draw ( Graphics _NUM D g _NUM , double cursor , Rectangle _NUM D plotArea , Rectangle _NUM D dataArea , RectangleEdge edge , PlotRenderingInfo plotState ) { if the axis is not visible , don ' t draw it . . . if ( ! isVisible ( ) ) { AxisState state = new AxisState ( cursor ) ; even though the axis is not visible , we need to refresh ticks in case the grid is being drawn . . . List ticks = refreshTicks ( g _NUM , state , dataArea , edge ) ; state . setTicks ( ticks ) ; return state ; } draw the tick marks and labels . . . AxisState state = drawTickMarksAndLabels ( g _NUM , cursor , plotArea , dataArea , edge ) ; draw the axis label ( note that ' state ' is passed in * and * returned ) . . . state = drawLabel ( getLabel ( ) , g _NUM , plotArea , dataArea , edge , state ) ; createAndAddEntity ( cursor , state , dataArea , edge , plotState ) ; return state ; } 
754	public org . apache . flume . channel . file . proto . ProtosFactory . FlumeEvent . Builder getEventBuilder ( ) { bitField _NUM _ | = _NUM x _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM ; onChanged ( ) ; return getEventFieldBuilder ( ) . getBuilder ( ) ; } 
755	public void addBarList ( List < StackedBarModel > _ List ) { mData = _ List ; onDataChanged ( ) ; } 
756	protected int insertKey ( char val ) { int hash , index ; hash = HashFunctions . hash ( val ) & _NUM x _NUM fffffff ; index = hash % _ states . length ; byte state = _ states [ index ] ; consumeFreeSlot = false ; if ( state = = FREE ) { consumeFreeSlot = true ; insertKeyAt ( index , val ) ; empty , all done return index ; } if ( state = = FULL & & _ set [ index ] = = val ) { already stored return - index - _NUM ; } already FULL or REMOVED , must probe return insertKeyRehash ( val , index , hash , state ) ; } 
757	private void setNewVNCPasswordInRootFS ( String pw ) { If packages haven ' t been updated , the password cannot be changed until expect is installed . installXSupport will use the password set on the Android side after expect has been installed . File xPackagesStatus = new File ( getInstallDir ( ) . getAbsolutePath ( ) + _STR + e ) ; } } 
758	public void setRecyclerView ( final RecyclerView recyclerView ) { this . recyclerView = recyclerView ; if ( onScrollListener ! = null ) this . recyclerView . removeOnScrollListener ( onScrollListener ) ; this . recyclerView . addOnScrollListener ( onScrollListener ) ; this . recyclerView . addOnLayoutChangeListener ( new OnLayoutChangeListener ( ) { @ Override public void onLayoutChange ( View v , int left , int top , int right , int bottom , int oldLeft , int oldTop , int oldRight , int oldBottom ) { layoutManager = FastScroller . this . recyclerView . getLayoutManager ( ) ; } } ) ; if ( recyclerView . getAdapter ( ) instanceof BubbleTextCreator ) setBubbleTextCreator ( ( BubbleTextCreator ) recyclerView . getAdapter ( ) ) ; if ( recyclerView . getAdapter ( ) instanceof OnScrollStateChangeListener ) addOnScrollStateChangeListener ( ( OnScrollStateChangeListener ) recyclerView . getAdapter ( ) ) ; this . recyclerView . getViewTreeObserver ( ) . addOnPreDrawListener ( new ViewTreeObserver . OnPreDrawListener ( ) { @ Override public boolean onPreDraw ( ) { FastScroller . this . recyclerView . getViewTreeObserver ( ) . removeOnPreDrawListener ( this ) ; if ( bubble = = null | | handle . isSelected ( ) ) return true ; int verticalScrollOffset = FastScroller . this . recyclerView . computeVerticalScrollOffset ( ) ; int verticalScrollRange = FastScroller . this . computeVerticalScrollRange ( ) ; float proportion = ( float ) verticalScrollOffset / ( ( float ) verticalScrollRange - height ) ; setBubbleAndHandlePosition ( height * proportion ) ; return true ; } } ) ; } 
759	public String [ ] getOptions ( ) { Vector result ; String [ ] options ; int i ; result = new Vector ( ) ; options = super . getOptions ( ) ; for ( i = _NUM ; i < options . length ; i + + ) result . add ( options [ i ] ) ; result . add ( _STR ) ; result . add ( getIgnoreRange ( ) ) ; } return ( String [ ] ) result . toArray ( new String [ result . size ( ) ] ) ; } 
760	public void replyToMessage ( Message srcMsg , int what , int arg _NUM ) { Message msg = Message . obtain ( ) ; msg . what = what ; msg . arg _NUM = arg _NUM ; replyToMessage ( srcMsg , msg ) ; } 
761	public Object buildBean ( String beanName , Map < String , Object > extraContext , boolean injectInternal ) throws Exception { Object o ; if ( appContext . containsBean ( beanName ) ) { o = appContext . getBean ( beanName ) ; } else { Class beanClazz = getClassInstance ( beanName ) ; o = buildBean ( beanClazz , extraContext ) ; } if ( injectInternal ) { injectInternalBeans ( o ) ; } return o ; } 
762	public static String [ ] infinitiveToSimplePast ( String verb ) { verb = verb . toLowerCase ( ) ; String [ ] sp = IrregularVerbs . getSimplePast ( verb ) ; regular verb if ( sp = = null ) sp = infinitiveToSimplePastReg ( verb ) ; return sp ; } 
763	public boolean draw ( Canvas canvas ) { update ( ) ; final int count = canvas . save ( ) ; final float centerX = mBounds . centerX ( ) ; final float centerY = mBounds . height ( ) - mRadius ; canvas . scale ( _NUM . f , Math . min ( mGlowScaleY , _NUM . f ) * mBaseGlowScale , centerX , _NUM ) ; final float displacement = Math . max ( _NUM , Math . min ( mDisplacement , _NUM . f ) ) - _NUM . _NUM f ; float translateX = mBounds . width ( ) * displacement / _NUM ; canvas . clipRect ( mBounds ) ; canvas . translate ( translateX , _NUM ) ; mPaint . setAlpha ( ( int ) ( _NUM xff * mGlowAlpha ) ) ; canvas . drawCircle ( centerX , centerY , mRadius , mPaint ) ; canvas . restoreToCount ( count ) ; boolean oneLastFrame = false ; if ( mState = = STATE _ RECEDE & & mGlowScaleY = = _NUM ) { mState = STATE _ IDLE ; oneLastFrame = true ; } return mState ! = STATE _ IDLE | | oneLastFrame ; } 
764	private String readValue ( final ReaderHelper reader , String firstLine ) throws IOException { final StringBuffer b = new StringBuffer ( firstLine . trim ( ) ) ; boolean newLine = true ; while ( isNextLineValueLine ( reader ) ) { firstLine = reader . next ( ) ; final String trimedLine = firstLine . trim ( ) ; if ( trimedLine . length ( ) = = _NUM & & ( newLine = = false ) ) { b . append ( _STR ) ; } b . append ( parseValue ( trimedLine ) ) ; newLine = false ; } } return b . toString ( ) ; } 
765	public static void setByKey ( Class en , String iKey , Object value ) throws ConfigurationException { Object enumValue = findByKey ( en , iKey ) ; try { en . getMethod ( _STR , e ) ; } } 
766	 @ SuppressWarnings ( _STR ) ; } } SchemaBundle schemaBundle = loadSchema ( version ) ; RoomDatabase . MigrationContainer container = new RoomDatabase . MigrationContainer ( ) ; DatabaseConfiguration configuration = new DatabaseConfiguration ( mInstrumentation . getTargetContext ( ) , name , mOpenFactory , container , null , true , true ) ; RoomOpenHelper roomOpenHelper = new RoomOpenHelper ( configuration , new CreatingDelegate ( schemaBundle . getDatabase ( ) ) , schemaBundle . getDatabase ( ) . getIdentityHash ( ) ) ; return openDatabase ( name , roomOpenHelper ) ; } 
767	public synchronized V get ( Object key ) { int hash = key . hashCode ( ) ; int index = ( hash & _NUM x _NUM FFFFFFF ) % elementData . length ; Entry < K , V > entry = elementData [ index ] ; while ( entry ! = null ) { if ( entry . equalsKey ( key , hash ) ) { return entry . value ; } entry = entry . next ; } return null ; } 
768	private void setUpField ( ) throws Exception { m _ fieldIndex = - _NUM ; m _ fieldValueIndex = - _NUM ; m _ field = null ; if ( m _ fieldDefs ! = null ) { m _ fieldIndex = getFieldDefIndex ( m _ fieldName ) ; if ( m _ fieldIndex < _NUM ) { throw new Exception ( _STR + m _ field . name ( ) ) ; } } else if ( m _ field . isString ( ) ) { add our value to this attribute ( if it is already there then this will have no effect ) . m _ fieldValueIndex = m _ field . addStringValue ( m _ fieldValue ) ; } } } 
769	protected void service ( HttpServletRequest req , HttpServletResponse resp ) throws ServletException , IOException { String method = req . getMethod ( ) ; if ( LOG . isDebugEnabled ( ) ) { String path = getRelativePath ( req ) ; LOG . debug ( _STR String base _NUM _NUM Token = auth . substring ( _NUM ) ; decode it , using base _NUM _NUM decoder String token = new String ( Base _NUM _NUM . decodeBase _NUM _NUM ( base _NUM _NUM Token . getBytes ( ) ) ) ; String password = null ; int pos = token . indexOf ( SEPARATOR _ CREDENTIALS ) ; if ( pos ! = - _NUM ) { m _ username = token . substring ( _NUM , pos ) ; password = token . substring ( pos + _NUM ) ; } get session try { m _ session = m _ repository . login ( m _ username , password ) ; } catch ( CmsException ex ) { m _ session = null ; } if ( m _ session = = null ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( Messages . get ( ) . getBundle ( ) . key ( Messages . LOG _ LOGIN _ FAILED _ _NUM , m _ username ) ) ; } resp . setStatus ( HttpServletResponse . SC _ FORBIDDEN ) ; return ; } if ( method . equals ( METHOD _ PROPFIND ) ) { doPropfind ( req , resp ) ; } else if ( method . equals ( METHOD _ PROPPATCH ) ) { doProppatch ( req , resp ) ; } else if ( method . equals ( METHOD _ MKCOL ) ) { doMkcol ( req , resp ) ; } else if ( method . equals ( METHOD _ COPY ) ) { doCopy ( req , resp ) ; } else if ( method . equals ( METHOD _ MOVE ) ) { doMove ( req , resp ) ; } else if ( method . equals ( METHOD _ LOCK ) ) { doLock ( req , resp ) ; } else if ( method . equals ( METHOD _ UNLOCK ) ) { doUnlock ( req , resp ) ; } else { DefaultServlet processing super . service ( req , resp ) ; } } 
770	protected void saveRequestAndRedirectToLogin ( ServletRequest request , ServletResponse response ) throws IOException { saveRequest ( request ) ; redirectToLogin ( request , response ) ; } 
771	public void refineType ( final SeqType st , final long size , final CompileContext cc ) throws QueryException { if ( declType ! = null ) { if ( declType . occ . intersect ( st . occ ) = = null ) throw typeError ( st , declType , name , info ) ; if ( st . instanceOf ( declType ) ) { if ( cc ! = null ) cc . info ( QueryText . OPTTYPE _ X , this ) ; declType = null ; } else if ( ! st . promotable ( declType ) ) { return ; } } final SeqType dt = exprType . seqType ( ) ; if ( ! dt . eq ( st ) & & ! dt . instanceOf ( st ) ) { the new type provides new information final SeqType it = dt . intersect ( st ) ; if ( it ! = null ) exprType . assign ( it , size ) ; } } 
772	private static FeedImage getFeedImage ( PodDBAdapter adapter , final long imageId ) { return getFeedImages ( adapter , imageId ) . get ( imageId ) ; } 
773	protected < O > boolean execShutdown ( final ObserverOperation < O > observerOperation ) throws IOException { if ( observerOperation = = null ) return false ; boolean bypass = false ; List < E > envs = coprocEnvironments . get ( ) ; Iterate the coprocessors and execute ObserverOperation ' s call ( ) for ( E env : envs ) { observerOperation . prepare ( env ) ; Thread currentThread = Thread . currentThread ( ) ; ClassLoader cl = currentThread . getContextClassLoader ( ) ; try { currentThread . setContextClassLoader ( env . getClassLoader ( ) ) ; observerOperation . callObserver ( ) ; } catch ( Throwable e ) { handleCoprocessorThrowable ( env , e ) ; } finally { currentThread . setContextClassLoader ( cl ) ; } bypass | = observerOperation . shouldBypass ( ) ; } Iterate the coprocessors and execute ObserverOperation ' s postEnvCall ( ) for ( E env : envs ) { observerOperation . prepare ( env ) ; observerOperation . postEnvCall ( ) ; } return bypass ; } 
774	 @ ResponseBody @ RequestMapping ( _STR , dataMap ) ; return com . alibaba . fastjson . JSONArray . toJSONString ( resultMap ) ; } 
775	private void bootstrapFinished ( ) { markViewsAsBuilt ( ) ; isBootstrapMode = false ; } 
776	public void onAnimationStart ( Animator animation ) { final ValueAnimator va = ( ValueAnimator ) animation ; va . addUpdateListener ( FirstFrameAnimatorHelper . this ) ; onAnimationUpdate ( va ) ; } 
777	public int size ( ) { checkTokenized ( ) ; return tokens . length ; } 
778	public void addCommand ( Command cmd ) { with the select command if ( commands . contains ( cmd ) ) { return ; } if ( getBackCommand ( ) = = cmd & & UIManager . getInstance ( ) . isThemeConstant ( _STR , false ) ) { return ; } special case for default commands which are placed at the end and aren ' t overriden later if ( soft . length > _NUM & & cmd = = parent . getDefaultCommand ( ) ) { commands . addElement ( cmd ) ; } else { commands . insertElementAt ( cmd , _NUM ) ; } if ( ! ( parent instanceof Dialog ) ) { int behavior = getCommandBehavior ( ) ; if ( behavior = = Display . COMMAND _ BEHAVIOR _ BUTTON _ BAR | | behavior = = Display . COMMAND _ BEHAVIOR _ BUTTON _ BAR _ TITLE _ BACK | | behavior = = Display . COMMAND _ BEHAVIOR _ BUTTON _ BAR _ TITLE _ RIGHT | | behavior = = Display . COMMAND _ BEHAVIOR _ ICS ) { if ( behavior = = Display . COMMAND _ BEHAVIOR _ BUTTON _ BAR _ TITLE _ BACK & & ( cmd = = parent . getBackCommand ( ) | | findCommandComponent ( cmd ) ! = null ) ) { return ; } if ( parent . getBackCommand ( ) ! = cmd ) { if ( ( behavior = = Display . COMMAND _ BEHAVIOR _ BUTTON _ BAR _ TITLE _ BACK | | behavior = = Display . COMMAND _ BEHAVIOR _ ICS | | behavior = = Display . COMMAND _ BEHAVIOR _ SIDE _ NAVIGATION ) & & parent . getTitle ( ) ! = null & & parent . getTitle ( ) . length ( ) > _NUM ) { synchronizeCommandsWithButtonsInBackbutton ( ) ; return ; } setLayout ( new GridLayout ( _NUM , getCommandCount ( ) ) ) ; addComponent ( createTouchCommandButton ( cmd ) ) ; } else { commands . removeElement ( cmd ) ; } return ; } } updateCommands ( ) ; } 
779	public String getFormattedMessage ( ) { if ( formattedMessage ! = null ) { return formattedMessage ; } ResourceBundle bundle = this . resourceBundle ; if ( bundle = = null ) { if ( baseName ! = null ) { bundle = getResourceBundle ( baseName , locale , false ) ; } else { bundle = getResourceBundle ( loggerName , locale , true ) ; } } final String myKey = getFormat ( ) ; final String msgPattern = ( bundle = = null | | ! bundle . containsKey ( myKey ) ) ? myKey : bundle . getString ( myKey ) ; final Object [ ] array = argArray = = null ? stringArgs : argArray ; final FormattedMessage msg = new FormattedMessage ( msgPattern , array ) ; formattedMessage = msg . getFormattedMessage ( ) ; throwable = msg . getThrowable ( ) ; return formattedMessage ; } 
780	public static void saveCertificateAndPrivateKey ( String certId , String certPem , PrivateKey privKey , String keystorePath , String keystoreName , String keystorePassword ) { if ( certId = = null ) { throw new IllegalArgumentException ( _STR , e ) ; } } 
781	private void applyDensityScaling ( int sourceDensity , int targetDensity ) { mInsetLeft . scaleFromDensity ( sourceDensity , targetDensity ) ; mInsetTop . scaleFromDensity ( sourceDensity , targetDensity ) ; mInsetRight . scaleFromDensity ( sourceDensity , targetDensity ) ; mInsetBottom . scaleFromDensity ( sourceDensity , targetDensity ) ; } 
782	private Component getScrollableFast ( ) { if ( scrollableXFlag ( ) | | scrollableYFlag ( ) ) { return this ; } Component p = getParent ( ) ; if ( p = = null ) { return null ; } return p . getScrollableFast ( ) ; } 
783	private void initialize ( ) { title = getIntent ( ) . getStringExtra ( _STR ) ; é™ é»˜ ä¸‹ è½½ ç›´ æŽ¥ åœ¨ åŽ å° ä¸‹ è½½ ä¸ æ˜¾ ç¤º ç‰ˆ æœ¬ ä¿¡ æ¯ åª æœ‰ ä¸‹ è½½ å®Œ æˆ ä¹‹ åŽ åœ¨ æ˜¾ ç¤º ç‰ˆ æœ¬ ä¿¡ æ¯ if ( title ! = null & & updateMsg ! = null & & downloadUrl ! = null & & versionParams ! = null ) { showVersionDialog ( ) ; } } 
784	protected Set < String > getClustersNameFromResources ( Set < Resource > resources , String clusterNamePropertyId ) { Set < String > clusNames = new HashSet < > ( ) ; if ( resources ! = null ) { Iterator < Resource > itr = resources . iterator ( ) ; while ( itr . hasNext ( ) ) { Resource res = itr . next ( ) ; if ( res ! = null ) { clusNames . add ( ( String ) res . getPropertyValue ( clusterNamePropertyId ) ) ; } } } return clusNames ; } 
785	public void setAdapter ( ListAdapter adapter ) { if ( null ! = mAdapter ) { mAdapter . unregisterDataSetObserver ( mDataSetObserver ) ; } resetList ( ) ; mRecycler . clear ( ) ; if ( mHeaderViewInfos . size ( ) > _NUM | | mFooterViewInfos . size ( ) > _NUM ) { mAdapter = new PLAHeaderViewListAdapter ( mHeaderViewInfos , mFooterViewInfos , adapter ) ; } else { mAdapter = adapter ; } mOldSelectedPosition = INVALID _ POSITION ; mOldSelectedRowId = INVALID _ ROW _ ID ; if ( mAdapter ! = null ) { mAreAllItemsSelectable = mAdapter . areAllItemsEnabled ( ) ; mOldItemCount = mItemCount ; mItemCount = mAdapter . getCount ( ) ; mDataSetObserver = new AdapterDataSetObserver ( ) ; mAdapter . registerDataSetObserver ( mDataSetObserver ) ; mRecycler . setViewTypeCount ( mAdapter . getViewTypeCount ( ) ) ; } else { mAreAllItemsSelectable = true ; Nothing selected } requestLayout ( ) ; } 
786	public Builder setCertificateNotAfter ( @ NonNull Date date ) { if ( date = = null ) { throw new NullPointerException ( _STR ) ; } mCertificateNotAfter = Utils . cloneIfNotNull ( date ) ; return this ; } 
787	public boolean actionCreateResource ( ) throws JspException { try { calculate the new resource Title property value String title = CmsNewResource . computeNewTitleProperty ( getParamResource ( ) ) ; get the full resource name String fullResourceName = computeFullResourceName ( ) ; create the Title and Navigation properties if configured List properties = CmsNewResource . createResourceProperties ( getCms ( ) , fullResourceName , CmsResourceTypeFolder . getStaticTypeName ( ) , title ) ; create the folder getCms ( ) . createResource ( fullResourceName , OpenCms . getResourceManager ( ) . getResourceType ( CmsResourceTypeFolder . getStaticTypeName ( ) ) . getTypeId ( ) , null , properties ) ; setParamResource ( fullResourceName ) ; return true ; } catch ( Throwable e ) { error creating folder , show error dialog setParamMessage ( Messages . get ( ) . getBundle ( getLocale ( ) ) . key ( Messages . ERR _ CREATE _ FOLDER _ _NUM ) ) ; includeErrorpage ( this , e ) ; } return false ; } 
788	private void filter ( ) { final byte [ ] filterPath = ResourceNode . preparePath ( token ( filterText . getText ( ) ) ) ; if ( eq ( filterPath , SLASH ) ) { refreshFolder ( root ) ; return ; } final Context context = dialog . gui . context ; final Data data = context . data ( ) ; clear tree to append filtered nodes root . removeAllChildren ( ) ; int cmax = ResourceFolder . MAXC ; create a folder if there ' s either a raw or document folder if ( data . resources . isDir ( filterPath ) ) { root . add ( new ResourceFolder ( ResourceFolder . name ( filterPath ) , ResourceFolder . path ( filterPath ) , tree , context ) ) ; cmax - - ; } now add the actual files ( if there are any ) final byte [ ] name = ResourceFolder . name ( filterPath ) ; final byte [ ] sub = ResourceFolder . path ( filterPath ) ; cmax = new ResourceFolder ( ResourceFolder . name ( sub ) , ResourceFolder . path ( sub ) , tree , context ) . addLeaves ( name , cmax , root ) ; add dummy node if maximum number of nodes is exceeded if ( cmax < = _NUM ) root . add ( new ResourceLeaf ( token ( DOTS ) , sub , false , true , tree , context ) ) ; ( ( DefaultTreeModel ) tree . getModel ( ) ) . nodeStructureChanged ( root ) ; } 
789	public static Cancellable fromAssetFileName ( Context context , String fileName , OnCompositionLoadedListener listener ) { InputStream stream ; try { stream = context . getAssets ( ) . open ( fileName ) ; } catch ( IOException e ) { throw new IllegalArgumentException ( _STR + fileName , e ) ; } return fromInputStream ( stream , listener ) ; } 
790	private boolean userHasMagnificationServicesLocked ( UserState userState ) { final List < Service > services = userState . mBoundServices ; for ( int i = _NUM , count = services . size ( ) ; i < count ; i + + ) { final Service service = services . get ( i ) ; if ( mSecurityPolicy . canControlMagnification ( service ) ) { return true ; } } return false ; } 
791	public void headAction ( Node [ ] args , int length , RuleContext context ) { doHide ( args , length , context ) ; } 
792	public static < T > Monoid < T > fromBiFunction ( final T zero , final BiFunction < T , T , T > combiner ) { return new Monoid < T > ( ) { @ Override public T zero ( ) { return zero ; } @ Override public T apply ( final T t , final T u ) { return combiner . apply ( t , u ) ; } } ; } 
793	private void testManyEventsAfterPrimaryShutdown ( Replication replication ) throws Throwable { List < PrimaryBackupServer > servers = createServers ( _NUM ) ; PrimaryBackupClient client = createClient ( ) ; PrimitiveProxy session = createProxy ( client , _NUM , replication ) ; session . addEventListener ( event - > { threadAssertNotNull ( event ) ; resume ( ) ; } ) ; for ( int i = _NUM ; i < _NUM _NUM ; i + + ) { session . invoke ( EVENT , SERIALIZER : : encode , true ) . thenRun ( this : : resume ) ; await ( _NUM _NUM _NUM _NUM , _NUM ) ; } PrimaryBackupServer leader = servers . stream ( ) . filter ( s - > s . getRole ( ) = = Role . PRIMARY ) . findFirst ( ) . get ( ) ; leader . stop ( ) . get ( _NUM _NUM , TimeUnit . SECONDS ) ; for ( int i = _NUM ; i < _NUM _NUM ; i + + ) { session . invoke ( EVENT , SERIALIZER : : encode , true ) . thenRun ( this : : resume ) ; await ( _NUM _NUM _NUM _NUM , _NUM ) ; } } 
794	public synchronized void next ( ) { index + + ; Reached the end ? if ( index > = size ( ) ) { index = isRepeatEnabled ( ) ? _NUM : - _NUM ; } } 
795	public List < Map < String , List < HostRoleCommand > > > getOrderedHostRoleCommands ( Map < String , Map < String , HostRoleCommand > > unorderedCommands ) { build ( unorderedCommands ) ; represents an ordered list of stages List < Map < String , List < HostRoleCommand > > > orderedCommands = new ArrayList < > ( ) ; List < RoleGraphNode > firstStageNodes = new ArrayList < > ( ) ; while ( ! graph . isEmpty ( ) ) { for ( String role : graph . keySet ( ) ) { RoleGraphNode rgn = graph . get ( role ) ; if ( rgn . getInDegree ( ) = = _NUM ) { firstStageNodes . add ( rgn ) ; } } represents a stage Map < String , List < HostRoleCommand > > commandsPerHost = new HashMap < > ( ) ; for ( RoleGraphNode rgn : firstStageNodes ) { for every host for this stage , create the ordered commands for ( String host : rgn . getHosts ( ) ) { List < HostRoleCommand > commands = commandsPerHost . get ( host ) ; if ( null = = commands ) { commands = new ArrayList < > ( ) ; commandsPerHost . put ( host , commands ) ; } HostRoleCommand hrc = hrcFactory . create ( host , rgn . getRole ( ) , null , rgn . getCommand ( ) ) ; commands . add ( hrc ) ; } } add the stage to the list of stages orderedCommands . add ( commandsPerHost ) ; these nodes have an incoming edges . for ( RoleGraphNode rgn : firstStageNodes ) { removeZeroInDegreeNode ( rgn . getRole ( ) . toString ( ) ) ; } firstStageNodes . clear ( ) ; } return orderedCommands ; } 
796	public static String camelCaseLower ( String in ) { return camelCase ( in , false ) ; } 
797	public TarEntry getNextEntry ( ) throws IOException { close entry if ( entry ! = null ) { skip bytes : count number of entry blocks , subtract number of read bytes long skip = ( entry . getSize ( ) + BLOCK - _NUM ) / BLOCK * BLOCK - offset ; offset = _NUM ; entry = null ; while ( skip > _NUM ) skip - = skip ( skip ) ; } read header final byte [ ] header = new byte [ BLOCK ] ; int read = _NUM ; while ( read < BLOCK ) { final int res = read ( header , read , BLOCK - read ) ; if ( res < _NUM ) break ; read + = res ; } if ( eof ( header ) ) return null ; create entry entry = new TarEntry ( header ) ; if ( entry . isLongName ( ) ) { final String name = longName ( ) ; entry = getNextEntry ( ) ; entry . setName ( name ) ; } return entry ; } 
798	public void testPageBlobSeekAndReadAfterWrite ( ) throws IOException { writeRandomData ( PAGE _ SIZE * MAX _ PAGES ) ; int recordSize = _NUM _NUM _NUM ; byte [ ] b = new byte [ recordSize ] ; FSDataInputStream stream = fs . open ( PATH ) ; Seek to a boundary around the middle of the _NUM th page int seekPosition = _NUM * PAGE _ SIZE + _NUM _NUM _NUM ; stream . seek ( seekPosition ) ; Read a record ' s worth of bytes and verify results int bytesRead = stream . read ( b ) ; verifyReadRandomData ( b , bytesRead , seekPosition , recordSize ) ; Seek to another spot and read a record greater than a page seekPosition = _NUM _NUM * PAGE _ SIZE + _NUM _NUM _NUM ; stream . seek ( seekPosition ) ; recordSize = _NUM _NUM _NUM _NUM ; b = new byte [ recordSize ] ; bytesRead = stream . read ( b ) ; verifyReadRandomData ( b , bytesRead , seekPosition , recordSize ) ; Read the last _NUM _NUM _NUM bytes of the file recordSize = _NUM _NUM _NUM ; seekPosition = PAGE _ SIZE * MAX _ PAGES - recordSize ; stream . seek ( seekPosition ) ; b = new byte [ recordSize ] ; bytesRead = stream . read ( b ) ; verifyReadRandomData ( b , bytesRead , seekPosition , recordSize ) ; Read past the end of the file and we should get only partial data . recordSize = _NUM _NUM _NUM ; seekPosition = PAGE _ SIZE * MAX _ PAGES - recordSize + _NUM _NUM ; stream . seek ( seekPosition ) ; b = new byte [ recordSize ] ; bytesRead = stream . read ( b ) ; assertEquals ( _NUM _NUM , bytesRead ) ; compare last _NUM _NUM bytes written with those read byte [ ] tail = Arrays . copyOfRange ( randomData , seekPosition , randomData . length ) ; assertTrue ( comparePrefix ( tail , b , _NUM _NUM ) ) ; } 
799	public Node getGroundVersion ( Node node ) { Node bind = getBinding ( node ) ; if ( bind = = null ) { return node ; } else { return bind ; } } 
800	public boolean hasMoreTokens ( ) { log . info ( _STR ) ; if ( ! tokens . isEmpty ( ) ) return position . get ( ) < tokens . size ( ) ; else return streamHasMoreTokens ( ) ; } 
801	public void testReadOnlyPropertyIsTakenFromTargetStack ( ) throws Exception { RepositoryVersionEntity repoVersion _NUM _NUM _NUM = createNiceMock ( RepositoryVersionEntity . class ) ; RepositoryVersionEntity repoVersion _NUM _NUM _NUM = createNiceMock ( RepositoryVersionEntity . class ) ; StackId stack _NUM _NUM _NUM = new StackId ( _STR , expectedFooType . get ( fooPropertyName ) ) ; } 
802	public void onContactSelected ( Uri contactUri ) { Long contactId = ContactUtils . getContactId ( getContentResolver ( ) , contactUri ) ; Map < String , String > phoneNumbers = ContactUtils . getPhoneNumbers ( getApplicationContext ( ) , contactId ) ; if ( phoneNumbers . isEmpty ( ) ) { Toast toast = Toast . makeText ( this . getApplicationContext ( ) , R . string . phone _ number _ not _ present , Toast . LENGTH _ SHORT ) ; toast . setGravity ( Gravity . CENTER , _NUM , _NUM ) ; toast . show ( ) ; return ; } Intent intent = new Intent ( ) ; intent . putExtra ( CONTACT _ ID , contactId ) ; intent . setData ( contactUri ) ; finishActivity ( intent ) ; } 
803	public final void delete ( final int pre ) { meta . update ( ) ; delete references in document index int kind = kind ( pre ) ; final int size = size ( pre , kind ) ; delete entries in value indexes indexDelete ( pre , id ( pre ) , size ) ; / delete textual values if ( kind ! = DOC & & kind ! = ELEM ) delete ( pre , kind ! = ATTR ) ; reduce size of ancestors int par = pre ; check if we are an attribute ( different size counters ) if ( kind = = ATTR ) { par = parent ( par , ATTR ) ; attSize ( par , ELEM , attSize ( par , ELEM ) - _NUM ) ; size ( par , ELEM , size ( par , ELEM ) - _NUM ) ; kind = kind ( par ) ; } delete namespace nodes and propagate pre value shifts ( before node sizes are touched ! ) nspaces . delete ( pre , size , this ) ; reduce size of ancestors while ( par > _NUM & & kind ! = DOC ) { par = parent ( par , kind ) ; kind = kind ( par ) ; size ( par , kind , size ( par , kind ) - size ) ; } preserve empty root node if ( kind ( pre ) = = DOC ) - - meta . ndocs ; delete node from table structure and reduce document size table . delete ( pre , size ) ; updateDist ( pre , - size ) ; } 
804	public static ApplicationScope getApplicationScope ( UUID applicationId ) { We can always generate a scope , it doesn ' t matter if the application exists yet or not . return new ApplicationScopeImpl ( generateApplicationId ( applicationId ) ) ; } 
805	private static Request newStatusUpdateRequest ( Session session , String message , String placeId , List < String > tagIds , Callback callback ) { Bundle parameters = new Bundle ( ) ; parameters . putString ( _STR , tags ) ; } return new Request ( session , MY _ FEED , parameters , HttpMethod . POST , callback ) ; } 
806	public JSONObject putOnce ( String key , Object value ) throws JSONException { if ( key ! = null & & value ! = null ) { if ( opt ( key ) ! = null ) { throw new JSONException ( _STR ) ; } put ( key , value ) ; } return this ; } 
807	public static int writeString ( DataOutput out , String s ) throws IOException { if ( s . length ( ) > _NUM xffff / _NUM ) { maybe too long LOG . warn ( _STR ) ; out . writeShort ( len ) ; writeChars ( out , s , _NUM , s . length ( ) ) ; return len ; } 
808	protected void addVisit ( CmsDbContext dbc , String poolName , CmsVisitEntry visit ) throws CmsDbSqlException { Connection conn = null ; PreparedStatement stmt = null ; try { if ( CmsStringUtil . isNotEmpty ( poolName ) ) { conn = m _ sqlManager . getConnection ( poolName ) ; } else { conn = m _ sqlManager . getConnection ( dbc ) ; } stmt = m _ sqlManager . getPreparedStatement ( conn , _STR ) ; stmt . setString ( _NUM , visit . getUserId ( ) . toString ( ) ) ; stmt . setLong ( _NUM , visit . getDate ( ) ) ; stmt . setString ( _NUM , visit . getStructureId ( ) = = null ? null : visit . getStructureId ( ) . toString ( ) ) ; try { stmt . executeUpdate ( ) ; } catch ( SQLException e ) { ignore , most likely a duplicate entry LOG . debug ( Messages . get ( ) . container ( Messages . ERR _ GENERIC _ SQL _ _NUM , CmsDbSqlException . getErrorQuery ( stmt ) ) . key ( ) , e ) ; } } catch ( SQLException e ) { throw new CmsDbSqlException ( Messages . get ( ) . container ( Messages . ERR _ GENERIC _ SQL _ _NUM , CmsDbSqlException . getErrorQuery ( stmt ) ) , e ) ; } finally { try { m _ sqlManager . closeAll ( dbc , conn , stmt , null ) ; } catch ( Throwable t ) { this could happen during shutdown LOG . debug ( t . getLocalizedMessage ( ) , t ) ; } } } 
809	private void logRequest ( final HttpServletRequest req , final Session session ) { final StringBuilder buf = new StringBuilder ( ) ; buf . append ( getRealClientIpAddr ( req ) ) . append ( _STR ) ; } } logger . info ( buf . toString ( ) ) ; } 
810	public void setEnabled ( boolean enabled ) { super . setEnabled ( enabled ) ; int count = getComponentCount ( ) ; for ( int i = _NUM ; i < count ; i + + ) { Component c = getComponentAt ( i ) ; c . setEnabled ( enabled ) ; } } 
811	public void send ( Destination destination , javax . jms . Message message ) throws JMSException { JmsBaseMessage jmsMsg = ( JmsBaseMessage ) message ; initJMSHeaders ( jmsMsg , destination ) ; try { if ( context = = null ) { throw new IllegalStateException ( _STR ) ; jmsException . setLinkedException ( e ) ; throw jmsException ; } } 
812	public boolean isHtmlContentAllowed ( ) { return getState ( false ) . captionAsHtml ; } 
813	public JSObject getObject ( String key ) { return ( JSObject ) get ( key ) ; } 
814	public static void encodeToFile ( byte [ ] dataToEncode , String filename ) throws java . io . IOException { if ( dataToEncode = = null ) { throw new NullPointerException ( _STR ) ; } end iff OutputStream bos = null ; try { bos = new OutputStream ( new java . io . FileOutputStream ( filename ) , Base _NUM _NUM . ENCODE ) ; bos . write ( dataToEncode ) ; } end try catch ( java . io . IOException e ) { Catch and throw to execute finally { } block throw e ; } finally end catch : java . io . IOException { try { bos . close ( ) ; } catch ( Exception e ) { } } end finally } 
815	public boolean batchFinished ( ) { if ( getInputFormat ( ) = = null ) { throw new IllegalStateException ( _STR ) ; } process input if ( m _ Values = = null ) { determineValues ( getInputFormat ( ) ) ; setOutputFormat ( ) ; } flushInput ( ) ; m _ NewBatch = true ; m _ FirstBatchDone = true ; return ( numPendingOutput ( ) ! = _NUM ) ; } 
816	public final long getItemId ( int position ) { if ( position < _NUM | | position > = mIdMap . size ( ) ) { return INVALID _ ID ; } Object item = getItem ( position ) ; return mIdMap . get ( item ) ; } 
817	public E last ( ) { return backingMap . lastKey ( ) ; } 
818	private boolean addSubItems ( @ IntRange ( from = _NUM ) int parentPosition , @ IntRange ( from = _NUM ) int subPosition , @ NonNull IExpandable parent , @ NonNull List < T > subItems , boolean expandParent , @ Nullable Object payload ) { boolean added = false ; Expand parent if requested and not already expanded if ( expandParent & & ! parent . isExpanded ( ) ) { expand ( parentPosition ) ; } If parent is collapsed there ' s no need to add sub items . if ( parent . isExpanded ( ) ) { added = addItems ( parentPosition + _NUM + getRecursiveSubItemCount ( parent , subPosition ) , subItems ) ; } Notify the parent about the change if requested and not already done as Header if ( payload ! = null & & ! isHeader ( ( T ) parent ) ) { notifyItemChanged ( parentPosition , payload ) ; } return added ; } 
819	public final synchronized int numRamDocs ( ) { ensureOpen ( ) ; return docWriter . getNumDocs ( ) ; } 
820	public List < String > parse ( String input ) { TurkishLetterSequence sequence = new TurkishLetterSequence ( input , alphabet ) ; List < String > list = new ArrayList < > ( ) ; while ( input . length ( ) > _NUM ) { int index = letterCountForLastSyllable ( sequence ) ; if ( index < _NUM ) { return Collections . emptyList ( ) ; } int basla = sequence . length ( ) - index ; list . add ( sequence . toString ( basla ) ) ; sequence . clip ( basla ) ; } Collections . reverse ( list ) ; return list ; } 
821	public static double standardDeviation ( double [ ] values , final int start , final int length ) { double variance = varianceDouble ( values , start , length ) ; return Math . sqrt ( variance ) ; } 
822	public CmsFolder readParentFolder ( CmsDbContext dbc , CmsUUID projectId , CmsUUID structureId ) throws CmsDataAccessException { CmsFolder parent = null ; ResultSet res = null ; PreparedStatement stmt = null ; Connection conn = null ; try { conn = m _ sqlManager . getConnection ( dbc ) ; stmt = m _ sqlManager . getPreparedStatement ( conn , projectId , _STR ) ; stmt . setString ( _NUM , structureId . toString ( ) ) ; res = stmt . executeQuery ( ) ; if ( res . next ( ) ) { parent = new CmsFolder ( createResource ( res , projectId ) ) ; while ( res . next ( ) ) { do nothing only move through all rows because of mssql odbc driver } } } catch ( SQLException e ) { throw new CmsDbSqlException ( Messages . get ( ) . container ( Messages . ERR _ GENERIC _ SQL _ _NUM , CmsDbSqlException . getErrorQuery ( stmt ) ) , e ) ; } finally { m _ sqlManager . closeAll ( dbc , conn , stmt , res ) ; } return parent ; } 
823	public org . apache . phoenix . coprocessor . generated . ServerCachingProtos . ColumnReference . Builder getDataTableColRefForCoveredColumnsBuilder ( int index ) { return getDataTableColRefForCoveredColumnsFieldBuilder ( ) . getBuilder ( index ) ; } 
824	public void bug _NUM _NUM _NUM _NUM _NUM ( ) throws Exception { HSSFWorkbook wb _NUM = openSample ( _STR ' [ $ http : row . getCell ( _NUM ) . getCellFormula ( ) ) ; assertEquals ( _NUM _NUM _NUM . _NUM , row . getCell ( _NUM ) . getNumericCellValue ( ) , _NUM ) ; wb _NUM . close ( ) ; } 
825	public UnitOfWork createUoW ( Exchange exchange ) throws Exception { from this unit of work if ( route ! = null & & exchange . getFromRouteId ( ) = = null ) { exchange . setFromRouteId ( route . getId ( ) ) ; } UnitOfWork uow = endpoint . getCamelContext ( ) . getUnitOfWorkFactory ( ) . createUnitOfWork ( exchange ) ; exchange . setUnitOfWork ( uow ) ; uow . start ( ) ; return uow ; } 
826	public AboutInfo about ( @ Context HttpServletRequest req , @ Context HttpServletResponse res ) { init ( res ) ; return new AboutInfo ( _STR ) ; } 
827	static String maybeQuote ( String tSpecials , String value ) { if ( needsQuote ( tSpecials , value ) ) { StringBuilder buff = new StringBuilder ( ) ; buff . append ( ' _STR : value ; } 
828	public void addAll ( ValuesHandler handler ) { if ( handler . valuesTable . size ( ) = = _NUM ) { return ; } assume our table is square . int count = _NUM ; if ( valuesTable . size ( ) > _NUM ) { count = valuesTable . values ( ) . iterator ( ) . next ( ) . size ( ) ; } for ( Var var : handler . valuesTable . keySet ( ) ) { List < Node > lst = valuesTable . get ( var ) ; if ( lst = = null ) { lst = new ArrayList < Node > ( ) ; lst . addAll ( Arrays . asList ( new Node [ count ] ) ) ; valuesTable . put ( var , lst ) ; } lst . addAll ( handler . valuesTable . get ( var ) ) ; } keep table square by adding nulls to the vars that are not in the other table . List < Var > lst = new ArrayList < Var > ( valuesTable . keySet ( ) ) ; lst . removeAll ( handler . valuesTable . keySet ( ) ) ; if ( ! lst . isEmpty ( ) ) { count = handler . valuesTable . values ( ) . iterator ( ) . next ( ) . size ( ) ; for ( Var var : lst ) { List < Node > lst _NUM = valuesTable . get ( var ) ; lst _NUM . addAll ( Arrays . asList ( new Node [ count ] ) ) ; } } } 
829	public CmsFile writeFile ( CmsRequestContext context , CmsFile resource ) throws CmsException , CmsSecurityException { CmsDbContext dbc = m _ dbContextFactory . getDbContext ( context ) ; CmsFile result = null ; try { checkOfflineProject ( dbc ) ; checkPermissions ( dbc , resource , CmsPermissionSet . ACCESS _ WRITE , true , CmsResourceFilter . ALL ) ; result = m _ driverManager . writeFile ( dbc , resource ) ; } catch ( Exception e ) { dbc . report ( null , Messages . get ( ) . container ( Messages . ERR _ WRITE _ FILE _ _NUM , context . getSitePath ( resource ) ) , e ) ; } finally { dbc . clear ( ) ; } return result ; } 
830	 @ VisibleForTesting ( otherwise = VisibleForTesting . PRIVATE ) void refreshDashboardTiles ( final String TAG ) { final PreferenceScreen screen = getPreferenceScreen ( ) ; final DashboardCategory category = mDashboardFeatureProvider . getTilesForCategory ( getCategoryKey ( ) ) ; if ( category = = null ) { Log . d ( TAG , _STR + tile ) ; continue ; } if ( ! displayTile ( tile ) ) { continue ; } if ( tintTileIcon ( tile ) ) { tile . icon . setTint ( tintColor ) ; } if ( mDashboardTilePrefKeys . contains ( key ) ) { Have the key already , will rebind . final Preference preference = mProgressiveDisclosureMixin . findPreference ( screen , key ) ; mDashboardFeatureProvider . bindPreferenceToTile ( getActivity ( ) , getMetricsCategory ( ) , preference , tile , key , mPlaceholderPreferenceController . getOrder ( ) ) ; } else { Don ' t have this key , add it . final Preference pref = new Preference ( getPrefContext ( ) ) ; mDashboardFeatureProvider . bindPreferenceToTile ( getActivity ( ) , getMetricsCategory ( ) , pref , tile , key , mPlaceholderPreferenceController . getOrder ( ) ) ; mProgressiveDisclosureMixin . addPreference ( screen , pref ) ; mDashboardTilePrefKeys . add ( key ) ; } remove . remove ( key ) ; } Finally remove tiles that are gone . for ( String key : remove ) { mDashboardTilePrefKeys . remove ( key ) ; mProgressiveDisclosureMixin . removePreference ( screen , key ) ; } mSummaryLoader . setListening ( true ) ; } 
831	public String toErrorString ( ) { return toString ( ) ; } 
832	int getThreadDefaultConnectionFlags ( boolean readOnly ) { int flags = readOnly ? SQLiteConnectionPool . CONNECTION _ FLAG _ READ _ ONLY : SQLiteConnectionPool . CONNECTION _ FLAG _ PRIMARY _ CONNECTION _ AFFINITY ; if ( isMainThread ( ) ) { flags | = SQLiteConnectionPool . CONNECTION _ FLAG _ INTERACTIVE ; } return flags ; } 
833	public void testUserDefinedFunctionInView ( ) throws Exception { Class . forName ( _STR ) ; assertThat ( CalciteAssert . toString ( viewResultSet ) , is ( result ) ) ; statement . close ( ) ; connection . close ( ) ; } 
834	final Vbox splitBox ( ) { if ( ! canSplit ( ) ) { throw new IllegalStateException ( _STR ) ; } find median along the longest dimension final int splitPoint = findSplitPoint ( ) ; Vbox newBox = new Vbox ( splitPoint + _NUM , mUpperIndex ) ; Now change this box ' s upperIndex and recompute the color boundaries mUpperIndex = splitPoint ; fitBox ( ) ; return newBox ; } 
835	public void writeFile ( RawKeyValueIterator records , Writer writer ) throws IOException { while ( records . next ( ) ) { writer . appendRaw ( records . getKey ( ) . getData ( ) , _NUM , records . getKey ( ) . getLength ( ) , records . getValue ( ) ) ; } writer . sync ( ) ; } 
836	public void publish ( Object obj ) throws InterruptedException { currentBatch . add ( obj ) ; if ( currentBatch . size ( ) > = batchSz ) { flush ( ) ; } } 
837	public void encode ( OutputStream output ) throws IOException { Vector derEncodings = new Vector ( this . certificateList . length ) ; int totalLength = _NUM ; for ( int i = _NUM ; i < this . certificateList . length ; + + i ) { byte [ ] derEncoding = certificateList [ i ] . getEncoded ( ASN _NUM Encoding . DER ) ; derEncodings . addElement ( derEncoding ) ; totalLength + = derEncoding . length + _NUM ; } TlsUtils . checkUint _NUM _NUM ( totalLength ) ; TlsUtils . writeUint _NUM _NUM ( totalLength , output ) ; for ( int i = _NUM ; i < derEncodings . size ( ) ; + + i ) { byte [ ] derEncoding = ( byte [ ] ) derEncodings . elementAt ( i ) ; TlsUtils . writeOpaque _NUM _NUM ( derEncoding , output ) ; } } 
838	Shell command infrastructure : immediately timeout currently executing jobsint executeTimeoutCommand ( PrintWriter pw , String pkgName , int userId , boolean hasJobId , int jobId ) { if ( DEBUG ) { Slog . v ( TAG , _STR ) ; } } return _NUM ; } 
839	public Set < ConnectionEntity > populateRemainingConnectionEntitiesContent ( Set < ConnectionEntity > connectionEntities ) { for ( ConnectionEntity connectionEntity : connectionEntities ) { populateRemainingConnectionEntityContent ( connectionEntity ) ; } return connectionEntities ; } 
840	public boolean exists ( String name ) { name = ensureRootPrefix ( name ) ; synchronized ( queues ) { return queues . containsKey ( name ) ; } } 
841	public static String formatResourceName ( String name , int maxLength ) { if ( name = = null ) { return null ; } if ( name . length ( ) < = maxLength ) { return name ; } int total = name . length ( ) ; String [ ] names = CmsStringUtil . splitAsArray ( name , _STR ) ; result . append ( names [ i ] ) ; } } return result . toString ( ) ; } 
842	public char skipTo ( char to ) throws JSONException { char c ; try { int startIndex = this . index ; int startCharacter = this . character ; int startLine = this . line ; reader . mark ( Integer . MAX _ VALUE ) ; do { c = next ( ) ; if ( c = = _NUM ) { reader . reset ( ) ; this . index = startIndex ; this . character = startCharacter ; this . line = startLine ; return c ; } } while ( c ! = to ) ; } catch ( IOException exc ) { throw new JSONException ( exc ) ; } back ( ) ; return c ; } 
843	Codec getCodec ( ) { For NO CODEC , _STR + className , e ) ; } } 
844	public Object getInjectionValue ( Class < ? > type , String endpointUri , String endpointRef , String endpointProperty , String injectionPointName , Object bean , String beanName , boolean binding ) { if ( type . isAssignableFrom ( ProducerTemplate . class ) ) { return createInjectionProducerTemplate ( endpointUri , endpointRef , endpointProperty , injectionPointName , bean ) ; } else if ( type . isAssignableFrom ( FluentProducerTemplate . class ) ) { return createInjectionFluentProducerTemplate ( endpointUri , endpointRef , endpointProperty , injectionPointName , bean ) ; } else if ( type . isAssignableFrom ( ConsumerTemplate . class ) ) { return createInjectionConsumerTemplate ( endpointUri , endpointRef , endpointProperty , injectionPointName ) ; } else { Endpoint endpoint = getEndpointInjection ( bean , endpointUri , endpointRef , endpointProperty , injectionPointName , true ) ; if ( endpoint ! = null ) { if ( type . isInstance ( endpoint ) ) { return endpoint ; } else if ( type . isAssignableFrom ( Producer . class ) ) { return createInjectionProducer ( endpoint , bean , beanName ) ; } else if ( type . isAssignableFrom ( PollingConsumer . class ) ) { return createInjectionPollingConsumer ( endpoint , bean , beanName ) ; } else if ( type . isInterface ( ) ) { lets create a proxy try { return ProxyHelper . createProxy ( endpoint , binding , type ) ; } catch ( Exception e ) { throw createProxyInstantiationRuntimeException ( type , endpoint , e ) ; } } else { throw new IllegalArgumentException ( _STR + endpoint ) ; } } return null ; } } 
845	public static File getContainerLogFile ( ContainerId containerId , String fileName , String remoteUser , Context context ) throws YarnException { Container container = context . getContainers ( ) . get ( containerId ) ; Application application = getApplicationForContainer ( containerId , context ) ; checkAccess ( remoteUser , application , context ) ; if ( container ! = null ) { checkState ( container . getContainerState ( ) ) ; } try { LocalDirsHandlerService dirsHandler = context . getLocalDirsHandler ( ) ; String relativeContainerLogDir = ContainerLaunch . getRelativeContainerLogDir ( application . getAppId ( ) . toString ( ) , containerId . toString ( ) ) ; Path logPath = dirsHandler . getLogPathToRead ( relativeContainerLogDir + Path . SEPARATOR + fileName ) ; URI logPathURI = new File ( logPath . toString ( ) ) . toURI ( ) ; File logFile = new File ( logPathURI . getPath ( ) ) ; return logFile ; } catch ( IOException e ) { LOG . warn ( _STR ) ; } } 
846	private void setVpnForcedLocked ( boolean enforce ) { final List < String > exemptedPackages = isNullOrLegacyVpn ( mPackage ) ? null : Collections . singletonList ( mPackage ) ; final Set < UidRange > removedRanges = new ArraySet < > ( mBlockedUsers ) ; Set < UidRange > addedRanges = Collections . emptySet ( ) ; if ( enforce ) { addedRanges = createUserAndRestrictedProfilesRanges ( mUserHandle , null , exemptedPackages ) ; removedRanges . removeAll ( addedRanges ) ; addedRanges . removeAll ( mBlockedUsers ) ; } setAllowOnlyVpnForUids ( false , removedRanges ) ; setAllowOnlyVpnForUids ( true , addedRanges ) ; } 
847	public static void deleteStream ( AmazonKinesisClient kinesisClient , String streamName ) { if ( streamExists ( kinesisClient , streamName ) ) { DeleteStreamRequest deleteStreamRequest = new DeleteStreamRequest ( ) ; deleteStreamRequest . setStreamName ( streamName ) ; kinesisClient . deleteStream ( deleteStreamRequest ) ; LOG . info ( _STR ) ; } } 
848	public void setLeftAssistIcon ( Drawable drawable ) { mLeftAssistIcon = drawable ; updateLeftAffordanceIcon ( ) ; } 
849	public boolean left ( ) { if ( mColumn = = _NUM ) { mRow - - ; mColumn = _NUM ; } else { mColumn - - ; } if ( isWithinCurrentMonth ( mRow , mColumn ) ) { return false ; } need to flip to last day of previous month previousMonth ( ) ; int lastDay = getNumberOfDaysInMonth ( ) ; mRow = getRowOf ( lastDay ) ; mColumn = getColumnOf ( lastDay ) ; return true ; } 
850	public Configuration getConfiguration ( final LoggerContext loggerContext , final String name , final URI configLocation , final ClassLoader loader ) { if ( ! isActive ( ) ) { return null ; } if ( loader = = null ) { return getConfiguration ( loggerContext , name , configLocation ) ; } if ( isClassLoaderUri ( configLocation ) ) { final String path = extractClassLoaderUriPath ( configLocation ) ; final ConfigurationSource source = ConfigurationSource . fromResource ( path , loader ) ; if ( source ! = null ) { final Configuration configuration = getConfiguration ( loggerContext , source ) ; if ( configuration ! = null ) { return configuration ; } } } return getConfiguration ( loggerContext , name , configLocation ) ; } 
851	public void addHostedFeedData ( ) throws IOException { if ( feedDataHosted ) throw new IllegalStateException ( _STR , null , hostFile ( mediaFile ) , false , null , _NUM , _NUM ) ) ; } feed . setItems ( items ) ; feed . setDownload _ url ( hostFeed ( feed ) ) ; hostedFeeds . add ( feed ) ; } feedDataHosted = true ; } 
852	protected boolean scrollLineEnd ( TextView widget , Spannable buffer ) { final int maxScrollX = getScrollBoundsRight ( widget ) - getInnerWidth ( widget ) ; int scrollX = widget . getScrollX ( ) ; if ( scrollX < maxScrollX ) { widget . scrollTo ( maxScrollX , widget . getScrollY ( ) ) ; return true ; } return false ; } 
853	public static CalculatedStatus statusFromStageSummary ( Map < Long , HostRoleCommandStatusSummaryDTO > stageDto , Set < Long > stageIds ) { leaves the stages and request if ( stageDto . isEmpty ( ) | | stageIds . isEmpty ( ) ) { return COMPLETED ; } Collection < HostRoleStatus > stageStatuses = new HashSet < > ( ) ; Collection < HostRoleStatus > stageDisplayStatuses = new HashSet < > ( ) ; Collection < HostRoleStatus > taskStatuses = new ArrayList < > ( ) ; for ( Long stageId : stageIds ) { if ( ! stageDto . containsKey ( stageId ) ) { continue ; } HostRoleCommandStatusSummaryDTO summary = stageDto . get ( stageId ) ; int total = summary . getTaskTotal ( ) ; boolean skip = summary . isStageSkippable ( ) ; Map < HostRoleStatus , Integer > counts = calculateStatusCounts ( summary . getTaskStatuses ( ) ) ; HostRoleStatus stageStatus = calculateSummaryStatus ( counts , total , skip ) ; HostRoleStatus stageDisplayStatus = calculateSummaryDisplayStatus ( counts , total , skip ) ; stageStatuses . add ( stageStatus ) ; stageDisplayStatuses . add ( stageDisplayStatus ) ; taskStatuses . addAll ( summary . getTaskStatuses ( ) ) ; } calculate the overall status from the stage statuses Map < HostRoleStatus , Integer > counts = calculateStatusCounts ( stageStatuses ) ; Map < HostRoleStatus , Integer > displayCounts = calculateStatusCounts ( stageDisplayStatuses ) ; HostRoleStatus status = calculateSummaryStatusOfUpgrade ( counts , stageStatuses . size ( ) ) ; HostRoleStatus displayStatus = calculateSummaryDisplayStatus ( displayCounts , stageDisplayStatuses . size ( ) , false ) ; double progressPercent = calculateProgressPercent ( calculateStatusCounts ( taskStatuses ) , taskStatuses . size ( ) ) ; return new CalculatedStatus ( status , displayStatus , progressPercent ) ; } 
854	public void show ( WindowManager . LayoutParams params ) { if ( sVerbose ) Slog . v ( TAG , _STR + params , e ) ; mCallback . onDestroy ( ) ; } } 
855	public double parseDouble ( ) throws ParseException { String str = parseArg ( ) ; if ( argWasQuoted ( ) ) throw new ParseException ( _STR + str ) ; double value = Double . parseDouble ( str ) ; return value ; } 
856	public static byte [ ] [ ] distinctTokens ( final byte [ ] token ) { final byte [ ] [ ] tokens = split ( normalize ( token ) , ' ' ) ; int tl = tokens . length ; for ( int i = _NUM ; i < tl - _NUM ; i + + ) { for ( int j = i + _NUM ; j < tl ; j + + ) { if ( eq ( tokens [ i ] , tokens [ j ] ) ) { Array . move ( tokens , j + _NUM , - _NUM , tl - j - _NUM ) ; j - - ; tl - - ; } } } return Array . copyOf ( tokens , tl ) ; } 
857	public static void reverse ( List < ? > list ) { int size = list . size ( ) ; ListIterator < Object > front = ( ListIterator < Object > ) list . listIterator ( ) ; ListIterator < Object > back = ( ListIterator < Object > ) list . listIterator ( size ) ; for ( int i = _NUM ; i < size / _NUM ; i + + ) { Object frontNext = front . next ( ) ; Object backPrev = back . previous ( ) ; front . set ( backPrev ) ; back . set ( frontNext ) ; } } 
858	public String getNormFileName ( int number ) throws IOException { long gen ; if ( normGen = = null ) { gen = CHECK _ DIR ; } else { gen = normGen [ number ] ; } if ( hasSeparateNorms ( number ) ) { case _NUM : separate norm return IndexFileNames . fileNameFromGeneration ( name , _STR + number , WITHOUT _ GEN ) ; } 
859	public Token getNextToken ( ) { Token specialToken = null ; Token matchedToken ; int curPos = _NUM ; EOFLoop : for ( ; ; ) { try { curChar = input _ stream . BeginToken ( ) ; } catch ( java . io . IOException e ) { jjmatchedKind = _NUM ; matchedToken = jjFillToken ( ) ; matchedToken . specialToken = specialToken ; return matchedToken ; } jjmatchedKind = _NUM x _NUM fffffff ; jjmatchedPos = _NUM ; curPos = jjMoveStringLiteralDfa _NUM _ _NUM ( ) ; if ( jjmatchedKind ! = _NUM x _NUM fffffff ) { if ( jjmatchedPos + _NUM < curPos ) input _ stream . backup ( curPos - jjmatchedPos - _NUM ) ; if ( ( jjtoToken [ jjmatchedKind > > _NUM ] & ( _NUM L < < ( jjmatchedKind & _NUM _NUM _NUM ) ) ) ! = _NUM L ) { matchedToken = jjFillToken ( ) ; matchedToken . specialToken = specialToken ; return matchedToken ; } else { if ( ( jjtoSpecial [ jjmatchedKind > > _NUM ] & ( _NUM L < < ( jjmatchedKind & _NUM _NUM _NUM ) ) ) ! = _NUM L ) { matchedToken = jjFillToken ( ) ; if ( specialToken = = null ) specialToken = matchedToken ; else { matchedToken . specialToken = specialToken ; specialToken = ( specialToken . next = matchedToken ) ; } } continue EOFLoop ; } } int error _ line = input _ stream . getEndLine ( ) ; int error _ column = input _ stream . getEndColumn ( ) ; String error _ after = null ; boolean EOFSeen = false ; try { input _ stream . readChar ( ) ; input _ stream . backup ( _NUM ) ; } catch ( java . io . IOException e _NUM ) { EOFSeen = true ; error _ after = curPos < = _NUM ? _STR : input _ stream . GetImage ( ) ; } throw new TokenMgrError ( EOFSeen , curLexState , error _ line , error _ column , error _ after , curChar , TokenMgrError . LEXICAL _ ERROR ) ; } } 
860	public void processServerResponse ( int response , com . google . android . vending . licensing . ResponseData rawData ) { Update retry counter if ( response ! = Policy . RETRY ) { setRetryCount ( _NUM ) ; } else { setRetryCount ( mRetryCount + _NUM ) ; } if ( response = = Policy . LICENSED ) { Update server policy data Map < String , String > extras = decodeExtras ( rawData . extra ) ; mLastResponse = response ; setValidityTimestamp ( Long . toString ( System . currentTimeMillis ( ) + MILLIS _ PER _ MINUTE ) ) ; Set < String > keys = extras . keySet ( ) ; for ( String key : keys ) { if ( key . equals ( _STR . length ( ) ) ) - _NUM ; setExpansionFileSize ( index , Long . parseLong ( extras . get ( key ) ) ) ; } } } else if ( response = = Policy . NOT _ LICENSED ) { Clear out stale policy data setValidityTimestamp ( DEFAULT _ VALIDITY _ TIMESTAMP ) ; setRetryUntil ( DEFAULT _ RETRY _ UNTIL ) ; setMaxRetries ( DEFAULT _ MAX _ RETRIES ) ; } setLastResponse ( response ) ; mPreferences . commit ( ) ; } 
861	public Animator onDisappear ( ViewGroup sceneRoot , TransitionValues startValues , int startVisibility , TransitionValues endValues , int endVisibility ) { if ( ( mMode & MODE _ OUT ) ! = MODE _ OUT ) { return null ; } View startView = ( startValues ! = null ) ? startValues . view : null ; View endView = ( endValues ! = null ) ? endValues . view : null ; View overlayView = null ; View viewToKeep = null ; if ( endView = = null | | endView . getParent ( ) = = null ) { if ( endView ! = null ) { endView was removed from its parent - add it to the overlay overlayView = endView ; } else if ( startView ! = null ) { it being removed from its current parent if ( startView . getParent ( ) = = null ) { no parent - safe to use overlayView = startView ; } else if ( startView . getParent ( ) instanceof View ) { View startParent = ( View ) startView . getParent ( ) ; TransitionValues startParentValues = getTransitionValues ( startParent , true ) ; TransitionValues endParentValues = getMatchedTransitionValues ( startParent , true ) ; VisibilityInfo parentVisibilityInfo = getVisibilityChangeInfo ( startParentValues , endParentValues ) ; if ( ! parentVisibilityInfo . mVisibilityChange ) { overlayView = TransitionUtils . copyViewImage ( sceneRoot , startView , startParent ) ; } else if ( startParent . getParent ( ) = = null ) { int id = startParent . getId ( ) ; if ( id ! = View . NO _ ID & & sceneRoot . findViewById ( id ) ! = null & & mCanRemoveViews ) { no parent , but its parent is unparented but the parent hierarchy has been replaced by a new hierarchy with the same id and it is safe to un - parent startView overlayView = startView ; } } } } } else { visibility change if ( endVisibility = = View . INVISIBLE ) { viewToKeep = endView ; } else { Becoming GONE if ( startView = = endView ) { viewToKeep = endView ; } else { overlayView = startView ; } } } final int finalVisibility = endVisibility ; if ( overlayView ! = null & & startValues ! = null ) { TODO : Need to do this for general case of adding to overlay int [ ] screenLoc = ( int [ ] ) startValues . values . get ( PROPNAME _ SCREEN _ LOCATION ) ; int screenX = screenLoc [ _NUM ] ; int screenY = screenLoc [ _NUM ] ; int [ ] loc = new int [ _NUM ] ; sceneRoot . getLocationOnScreen ( loc ) ; overlayView . offsetLeftAndRight ( ( screenX - loc [ _NUM ] ) - overlayView . getLeft ( ) ) ; overlayView . offsetTopAndBottom ( ( screenY - loc [ _NUM ] ) - overlayView . getTop ( ) ) ; final ViewGroupOverlayImpl overlay = ViewGroupUtils . getOverlay ( sceneRoot ) ; overlay . add ( overlayView ) ; Animator animator = onDisappear ( sceneRoot , overlayView , startValues , endValues ) ; if ( animator = = null ) { overlay . remove ( overlayView ) ; } else { final View finalOverlayView = overlayView ; animator . addListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationEnd ( Animator animation ) { overlay . remove ( finalOverlayView ) ; } } ) ; } return animator ; } if ( viewToKeep ! = null ) { int originalVisibility = viewToKeep . getVisibility ( ) ; ViewUtils . setTransitionVisibility ( viewToKeep , View . VISIBLE ) ; Animator animator = onDisappear ( sceneRoot , viewToKeep , startValues , endValues ) ; if ( animator ! = null ) { DisappearListener disappearListener = new DisappearListener ( viewToKeep , finalVisibility , true ) ; animator . addListener ( disappearListener ) ; AnimatorUtils . addPauseListener ( animator , disappearListener ) ; addListener ( disappearListener ) ; } else { ViewUtils . setTransitionVisibility ( viewToKeep , originalVisibility ) ; } return animator ; } return null ; } 
862	public static List < PackageParser . Package > getPackagesForDexopt ( Collection < PackageParser . Package > packages , PackageManagerService packageManagerService ) { ArrayList < PackageParser . Package > remainingPkgs = new ArrayList < > ( packages ) ; LinkedList < PackageParser . Package > result = new LinkedList < > ( ) ; ArrayList < PackageParser . Package > sortTemp = new ArrayList < > ( remainingPkgs . size ( ) ) ; Give priority to core apps . applyPackageFilter ( ( pkg ) - > pkg . coreApp , result , remainingPkgs , sortTemp , packageManagerService ) ; Give priority to system apps that listen for pre boot complete . Intent intent = new Intent ( Intent . ACTION _ PRE _ BOOT _ COMPLETED ) ; final ArraySet < String > pkgNames = getPackageNamesForIntent ( intent , UserHandle . USER _ SYSTEM ) ; applyPackageFilter ( ( pkg ) - > pkgNames . contains ( pkg . packageName ) , result , remainingPkgs , sortTemp , packageManagerService ) ; Give priority to apps used by other apps . DexManager dexManager = packageManagerService . getDexManager ( ) ; applyPackageFilter ( ( pkg ) - > dexManager . getPackageUseInfoOrDefault ( pkg . packageName ) . isAnyCodePathUsedByOtherApps ( ) , result , remainingPkgs , sortTemp , packageManagerService ) ; Filter out packages that aren ' t recently used , add all remaining apps . TODO : add a property to control this ? Predicate < PackageParser . Package > remainingPredicate ; if ( ! remainingPkgs . isEmpty ( ) & & packageManagerService . isHistoricalPackageUsageAvailable ( ) ) { if ( DEBUG _ DEXOPT ) { Log . i ( TAG , _STR + packagesToString ( remainingPkgs ) ) ; } return result ; } 
863	public static boolean isVisaElectron ( String cc ) { String first _NUM digs = cc . substring ( _NUM , _NUM ) ; String first _NUM digs = cc . substring ( _NUM , _NUM ) ; if ( ( cc . length ( ) = = _NUM _NUM ) & & ( first _NUM digs . equals ( _STR ) ) ) return isCreditCard ( cc ) ; return false ; } 
864	public List < int [ ] > getSplits ( int depth ) { return dancer . split ( depth ) ; } 
865	public String getAdvisorName ( String serviceName ) { if ( getAdvisorFile ( ) = = null | | serviceName = = null ) return null ; File serviceDir = new File ( getAbsolutePath ( ) ) ; File stackVersionDir = serviceDir . getParentFile ( ) . getParentFile ( ) ; File stackDir = stackVersionDir . getParentFile ( ) ; String stackName = stackDir . getName ( ) ; String versionString = stackVersionDir . getName ( ) . replaceAll ( _STR ) ; return advisorClassName ; } 
866	private void addToResultMaps ( final String origName , final ClassifierResult result , final boolean allowDupsWithRename ) { String name = origName ; if ( allowDupsWithRename ) { name = getUniqueName ( origName , result ) ; } if ( ! result . outputMap . containsKey ( name ) ) { result . outputNames . add ( name ) ; result . outputMap . put ( name , name ) ; } else { result . outputNames . add ( EMPTY _ STRING ) ; } } 
867	public void remove ( int key ) { delete ( key ) ; } 
868	public void release ( ) throws Exception { Thread currentThread = Thread . currentThread ( ) ; LockData lockData = threadData . get ( currentThread ) ; if ( lockData = = null ) { throw new IllegalMonitorStateException ( _STR + basePath ) ; } try { internals . releaseLock ( lockData . lockPath ) ; } finally { threadData . remove ( currentThread ) ; } } 
869	private void testLinkReadDuringRename ( FileSystem fs , Path rootDir ) throws IOException { Path originalPath = new Path ( rootDir , _STR ) ; writeSomeData ( fs , originalPath , _NUM _NUM _NUM < < _NUM _NUM , ( byte ) _NUM ) ; List < Path > files = new ArrayList < > ( ) ; files . add ( originalPath ) ; files . add ( archivedPath ) ; FileLink link = new FileLink ( files ) ; FSDataInputStream in = link . open ( fs ) ; try { byte [ ] data = new byte [ _NUM _NUM _NUM _NUM ] ; long size = _NUM ; Read from origin int n = in . read ( data ) ; dataVerify ( data , n , ( byte ) _NUM ) ; size + = n ; if ( FSUtils . WINDOWS ) { in . close ( ) ; } Move origin to archive assertFalse ( fs . exists ( archivedPath ) ) ; fs . rename ( originalPath , archivedPath ) ; assertFalse ( fs . exists ( originalPath ) ) ; assertTrue ( fs . exists ( archivedPath ) ) ; if ( FSUtils . WINDOWS ) { re - read from beginning in = link . open ( fs ) ; in . read ( data ) ; } Try to read to the end while ( ( n = in . read ( data ) ) > _NUM ) { dataVerify ( data , n , ( byte ) _NUM ) ; size + = n ; } assertEquals ( _NUM _NUM _NUM < < _NUM _NUM , size ) ; } finally { in . close ( ) ; if ( fs . exists ( originalPath ) ) fs . delete ( originalPath , true ) ; if ( fs . exists ( archivedPath ) ) fs . delete ( archivedPath , true ) ; } } 
870	public CmsTemplateLoaderFacade getTemplateLoaderFacade ( CmsObject cms , CmsResource resource , String templateProperty ) throws CmsException { String templateProp = cms . readPropertyObject ( resource , templateProperty , true ) . getValue ( ) ; if ( templateProp = = null ) { use default template , if template is not set templateProp = DEFAULT _ TEMPLATE ; if ( ! cms . existsResource ( templateProp , CmsResourceFilter . IGNORE _ EXPIRATION ) ) { no template property defined , this is a must for facade loaders throw new CmsLoaderException ( Messages . get ( ) . container ( Messages . ERR _ NONDEF _ PROP _ _NUM , templateProperty , cms . getSitePath ( resource ) ) ) ; } } else if ( ! cms . existsResource ( templateProp , CmsResourceFilter . IGNORE _ EXPIRATION ) ) { use default template , if template does not exist if ( cms . existsResource ( DEFAULT _ TEMPLATE , CmsResourceFilter . IGNORE _ EXPIRATION ) ) { templateProp = DEFAULT _ TEMPLATE ; } } CmsResource template = cms . readFile ( templateProp , CmsResourceFilter . IGNORE _ EXPIRATION ) ; return new CmsTemplateLoaderFacade ( getLoader ( template ) , resource , template ) ; } 
871	public static MultiLayerNetwork importKerasSequentialModelAndWeights ( String modelJsonFilename , String weightsHdf _NUM Filename , boolean enforceTrainingConfig ) throws IOException , InvalidKerasConfigurationException , UnsupportedKerasConfigurationException { KerasSequentialModel kerasModel = new KerasSequentialModel ( ) . modelBuilder ( ) . modelJsonFilename ( modelJsonFilename ) . weightsHdf _NUM Filename ( weightsHdf _NUM Filename ) . enforceTrainingConfig ( enforceTrainingConfig ) . buildSequential ( ) ; return kerasModel . getMultiLayerNetwork ( ) ; } 
872	public final void dispatchAddFinished ( ViewHolder item ) { onAddFinished ( item ) ; dispatchAnimationFinished ( item ) ; } 
873	private boolean isRenamePendingFile ( Path path ) { return path . toString ( ) . endsWith ( FolderRenamePending . SUFFIX ) ; } 
874	public void addInodeFileFromJournal ( InodeFileEntry entry ) { InodeFile file = InodeFile . fromJournalEntry ( entry ) ; addInodeFromJournalInternal ( file ) ; } 
875	public Set < Map . Entry < Integer , Integer > > entrySet ( ) { return new AbstractSet < Map . Entry < Integer , Integer > > ( ) { public int size ( ) { return _ map . size ( ) ; } public boolean isEmpty ( ) { return TIntIntMapDecorator . this . isEmpty ( ) ; } public boolean contains ( Object o ) { if ( o instanceof Map . Entry ) { Object k = ( ( Map . Entry ) o ) . getKey ( ) ; Object v = ( ( Map . Entry ) o ) . getValue ( ) ; return TIntIntMapDecorator . this . containsKey ( k ) & & TIntIntMapDecorator . this . get ( k ) . equals ( v ) ; } else { return false ; } } public Iterator < Map . Entry < Integer , Integer > > iterator ( ) { return new Iterator < Map . Entry < Integer , Integer > > ( ) { private final TIntIntIterator it = _ map . iterator ( ) ; public Map . Entry < Integer , Integer > next ( ) { it . advance ( ) ; int ik = it . key ( ) ; final Integer key = ( ik = = _ map . getNoEntryKey ( ) ) ? null : wrapKey ( ik ) ; int iv = it . value ( ) ; final Integer v = ( iv = = _ map . getNoEntryValue ( ) ) ? null : wrapValue ( iv ) ; return new Map . Entry < Integer , Integer > ( ) { private Integer val = v ; public boolean equals ( Object o ) { return o instanceof Map . Entry & & ( ( Map . Entry ) o ) . getKey ( ) . equals ( key ) & & ( ( Map . Entry ) o ) . getValue ( ) . equals ( val ) ; } public Integer getKey ( ) { return key ; } public Integer getValue ( ) { return val ; } public int hashCode ( ) { return key . hashCode ( ) + val . hashCode ( ) ; } public Integer setValue ( Integer value ) { val = value ; return put ( key , value ) ; } } ; } public boolean hasNext ( ) { return it . hasNext ( ) ; } public void remove ( ) { it . remove ( ) ; } } ; } public boolean add ( Map . Entry < Integer , Integer > o ) { throw new UnsupportedOperationException ( ) ; } public boolean remove ( Object o ) { boolean modified = false ; if ( contains ( o ) ) { noinspection unchecked Integer key = ( ( Map . Entry < Integer , Integer > ) o ) . getKey ( ) ; _ map . remove ( unwrapKey ( key ) ) ; modified = true ; } return modified ; } public boolean addAll ( Collection < ? extends Map . Entry < Integer , Integer > > c ) { throw new UnsupportedOperationException ( ) ; } public void clear ( ) { TIntIntMapDecorator . this . clear ( ) ; } } ; } 
876	private Integer getInternalLocalOffset ( ) { if ( _ isNullValue ( ) ) { return null ; } return _ timestamp _ value . getLocalOffset ( ) ; } 
877	private I _ CmsFormWidget createTemplateSelector ( ) { if ( m _ handler . useAdeTemplates ( ) ) { CmsSelectBox selectBox = new CmsSelectBox ( new ArrayList < CmsPair < String , String > > ( ) ) ; Map < String , String > values = new LinkedHashMap < String , String > ( ) ; for ( Map . Entry < String , CmsClientTemplateBean > templateEntry : m _ handler . getPossibleTemplates ( ) . entrySet ( ) ) { CmsClientTemplateBean template = templateEntry . getValue ( ) ; String title = template . getTitle ( ) ; if ( ( title = = null ) | | ( title . length ( ) = = _NUM ) ) { title = template . getSitePath ( ) ; } values . put ( template . getSitePath ( ) , title ) ; } selectBox = new CmsSelectBox ( values , true ) ; return selectBox ; } else { CmsTextBox textbox = new CmsTextBox ( ) ; return textbox ; } } 
878	protected void update ( int position , View view , V item ) { setCurrentView ( view ) ; update ( position , item ) ; } 
879	public boolean isMatch ( ComponentInfo componentInfo , int flags ) { final boolean isSystemApp = componentInfo . applicationInfo . isSystemApp ( ) ; final boolean matchUninstalled = ( flags & PackageManager . MATCH _ KNOWN _ PACKAGES ) ! = _NUM ; if ( ! isAvailable ( flags ) & & ! ( isSystemApp & & matchUninstalled ) ) return false ; if ( ! isEnabled ( componentInfo , flags ) ) return false ; if ( ( flags & MATCH _ SYSTEM _ ONLY ) ! = _NUM ) { if ( ! isSystemApp ) { return false ; } } final boolean matchesUnaware = ( ( flags & MATCH _ DIRECT _ BOOT _ UNAWARE ) ! = _NUM ) & & ! componentInfo . directBootAware ; final boolean matchesAware = ( ( flags & MATCH _ DIRECT _ BOOT _ AWARE ) ! = _NUM ) & & componentInfo . directBootAware ; return matchesUnaware | | matchesAware ; } 
880	static < T > Option < T > fromOptional ( final Optional < T > opt ) { if ( opt . isPresent ( ) ) return Option . of ( opt . get ( ) ) ; return none ( ) ; } 
881	public String [ ] getEncryptionPaddings ( ) { return ArrayUtils . cloneIfNotEmpty ( mEncryptionPaddings ) ; } 
882	private boolean putElement ( XMLStringBuffer xsb , String tagName , Properties attributes , boolean hasChildElements ) { if ( hasChildElements ) { xsb . push ( tagName , attributes ) ; } else { xsb . addEmptyElement ( tagName , attributes ) ; } return hasChildElements ; } 
883	protected void updateRowStates ( ) { final int N = mStackScroller . getChildCount ( ) ; int visibleNotifications = _NUM ; boolean onKeyguard = mState = = StatusBarState . KEYGUARD ; int maxNotifications = - _NUM ; if ( onKeyguard ) { maxNotifications = getMaxKeyguardNotifications ( true ) ; } mStackScroller . setMaxDisplayedNotifications ( maxNotifications ) ; Stack < ExpandableNotificationRow > stack = new Stack < > ( ) ; for ( int i = N - _NUM ; i > = _NUM ; i - - ) { View child = mStackScroller . getChildAt ( i ) ; if ( ! ( child instanceof ExpandableNotificationRow ) ) { continue ; } stack . push ( ( ExpandableNotificationRow ) child ) ; } while ( ! stack . isEmpty ( ) ) { ExpandableNotificationRow row = stack . pop ( ) ; NotificationData . Entry entry = row . getEntry ( ) ; boolean isChildNotification = mGroupManager . isChildInGroupWithSummary ( entry . notification ) ; row . setOnKeyguard ( onKeyguard ) ; if ( ! onKeyguard ) { If mAlwaysExpandNonGroupedNotification is false , then only expand the very first notification and if it ' s not a child of grouped notifications . row . setSystemExpanded ( mAlwaysExpandNonGroupedNotification | | ( visibleNotifications = = _NUM & & ! isChildNotification & & ! row . isLowPriority ( ) ) ) ; } entry . row . setShowAmbient ( isDozing ( ) ) ; int userId = entry . notification . getUserId ( ) ; boolean suppressedSummary = mGroupManager . isSummaryOfSuppressedGroup ( entry . notification ) & & ! entry . row . isRemoved ( ) ; boolean showOnKeyguard = shouldShowOnKeyguard ( entry . notification ) ; if ( suppressedSummary | | ( isLockscreenPublicMode ( userId ) & & ! mShowLockscreenNotifications ) | | ( onKeyguard & & ! showOnKeyguard ) ) { entry . row . setVisibility ( View . GONE ) ; } else { boolean wasGone = entry . row . getVisibility ( ) = = View . GONE ; if ( wasGone ) { entry . row . setVisibility ( View . VISIBLE ) ; } if ( ! isChildNotification & & ! entry . row . isRemoved ( ) ) { if ( wasGone ) { notify the scroller of a child addition mStackScroller . generateAddAnimation ( entry . row , ! showOnKeyguard ) ; } visibleNotifications + + ; } } if ( row . isSummaryWithChildren ( ) ) { List < ExpandableNotificationRow > notificationChildren = row . getNotificationChildren ( ) ; int size = notificationChildren . size ( ) ; for ( int i = size - _NUM ; i > = _NUM ; i - - ) { stack . push ( notificationChildren . get ( i ) ) ; } } } mNotificationPanel . setNoVisibleNotifications ( visibleNotifications = = _NUM ) ; The following views will be moved to the end of mStackScroller . This counter represents the offset from the last child . Initialized to _NUM for the very last position . It is post - incremented in the following _STR call is ever added . mStackScroller . changeViewPosition ( mNotificationShelf , mStackScroller . getChildCount ( ) - offsetFromEnd ) ; Scrim opacity varies based on notification count mScrimController . setNotificationCount ( mStackScroller . getNotGoneChildCount ( ) ) ; } 
884	public static byte [ ] generate ( byte [ ] P , byte [ ] S , int N , int r , int p , int dkLen ) { if ( P = = null ) { throw new IllegalArgumentException ( _STR ) ; } return MFcrypt ( P , S , N , r , p , dkLen ) ; } 
885	public XSSFConnector createConnector ( XSSFClientAnchor anchor ) { CTTwoCellAnchor ctAnchor = createTwoCellAnchor ( anchor ) ; CTConnector ctShape = ctAnchor . addNewCxnSp ( ) ; ctShape . set ( XSSFConnector . prototype ( ) ) ; XSSFConnector shape = new XSSFConnector ( this , ctShape ) ; shape . anchor = anchor ; return shape ; } 
886	public String getSelectedFontFamily ( ) { String fontName = ( String ) getFontFamilyList ( ) . getSelectedValue ( ) ; return fontName ; } 
887	public void setDatasetRenderingOrder ( DatasetRenderingOrder order ) { if ( order = = null ) { throw new IllegalArgumentException ( _STR ) ; } this . renderingOrder = order ; fireChangeEvent ( ) ; } 
888	public NormalizedResourceRequest getTotalResources ( ExecutorDetails exec ) { if ( hasExecInTopo ( exec ) ) { return this . resourceList . get ( exec ) ; } return null ; } 
889	public void testParquetFullEngineEventBased ( boolean testValues , boolean generateNew , String plan , String readEntries , String filename , int numberOfTimesRead , ParquetTestProperties props , QueryType queryType ) throws Exception { if ( generateNew ) { TestFileGenerator . generateParquetFile ( filename , props ) ; } final ParquetResultListener resultListener = new ParquetResultListener ( getAllocator ( ) , props , numberOfTimesRead , testValues ) ; final long C = System . nanoTime ( ) ; String planText = Files . toString ( DrillFileUtils . getResourceAsFile ( plan ) , Charsets . UTF _ _NUM ) ; substitute in the string for the read entries , allows reuse of the plan file for several tests if ( readEntries ! = null ) { planText = planText . replaceFirst ( _STR , ( float ) ( D - C ) / _NUM E _NUM ) ) ; } 
890	protected String getSpec ( String clusterName , String report ) throws SystemException { StringBuilder sb = new StringBuilder ( ) ; if ( configuration . isHttpsEnabled ( ) ) { sb . append ( _STR ) ; return sb . toString ( ) ; } 
891	public ModifyImageAttributeRequest withProductCodes ( String . . . productCodes ) { if ( getProductCodes ( ) = = null ) setProductCodes ( new java . util . ArrayList < String > ( productCodes . length ) ) ; for ( String value : productCodes ) { getProductCodes ( ) . add ( value ) ; } return this ; } 
892	public static VoLteServiceState newFromBundle ( Bundle m ) { VoLteServiceState ret ; ret = new VoLteServiceState ( ) ; ret . setFromNotifierBundle ( m ) ; return ret ; } 
893	public void place _ union _ _NUM _NUM ( ) { String in = StrUtils . strjoinNL ( _STR ) ; test ( in , out ) ; } 
894	protected void onResume ( ) { super . onResume ( ) ; mHandler . sendEmptyMessage ( MSG _ RESUME _ PENDING ) ; mResumed = true ; mFragments . execPendingActions ( ) ; } 
895	public List < AppInfo > getAllAppsLatestStats ( String account ) { List < AppInfo > appInfos = new ArrayList < AppInfo > ( ) ; Cursor cursor = null ; try { cursor = context . getContentResolver ( ) . query ( AppInfoTable . CONTENT _ URI , new String [ ] { AppInfoTable . KEY _ ROWID , AppInfoTable . KEY _ APP _ VERSION _ NAME , AppInfoTable . KEY _ APP _ PACKAGENAME , AppInfoTable . KEY _ APP _ LASTUPDATE , AppInfoTable . KEY _ APP _ NAME , AppInfoTable . KEY _ APP _ GHOST , AppInfoTable . KEY _ APP _ SKIP _ NOTIFICATION , AppInfoTable . KEY _ APP _ RATINGS _ EXPANDED , AppInfoTable . KEY _ APP _ ICONURL , AppInfoTable . KEY _ APP _ ADMOB _ ACCOUNT , AppInfoTable . KEY _ APP _ ADMOB _ SITE _ ID , AppInfoTable . KEY _ APP _ ADMOB _ AD _ UNIT _ ID , AppInfoTable . KEY _ APP _ LAST _ COMMENTS _ UPDATE , AppInfoTable . KEY _ APP _ DEVELOPER _ ID , AppInfoTable . KEY _ APP _ DEVELOPER _ NAME } , AppInfoTable . KEY _ APP _ ACCOUNT + _STR ) ; while ( cursor . moveToNext ( ) ) { AppInfo appInfo = new AppInfo ( ) ; appInfo . setId ( cursor . getLong ( cursor . getColumnIndex ( AppInfoTable . KEY _ ROWID ) ) ) ; appInfo . setAccount ( account ) ; appInfo . setLastUpdate ( Utils . parseDbDate ( cursor . getString ( cursor . getColumnIndex ( AppInfoTable . KEY _ APP _ LASTUPDATE ) ) ) ) ; appInfo . setPackageName ( cursor . getString ( cursor . getColumnIndex ( AppInfoTable . KEY _ APP _ PACKAGENAME ) ) ) ; appInfo . setName ( cursor . getString ( cursor . getColumnIndex ( AppInfoTable . KEY _ APP _ NAME ) ) ) ; appInfo . setGhost ( cursor . getInt ( cursor . getColumnIndex ( AppInfoTable . KEY _ APP _ GHOST ) ) = = _NUM ? false : true ) ; appInfo . setSkipNotification ( cursor . getInt ( cursor . getColumnIndex ( AppInfoTable . KEY _ APP _ SKIP _ NOTIFICATION ) ) = = _NUM ? false : true ) ; appInfo . setRatingDetailsExpanded ( cursor . getInt ( cursor . getColumnIndex ( AppInfoTable . KEY _ APP _ RATINGS _ EXPANDED ) ) = = _NUM ? false : true ) ; appInfo . setIconUrl ( cursor . getString ( cursor . getColumnIndex ( AppInfoTable . KEY _ APP _ ICONURL ) ) ) ; appInfo . setVersionName ( cursor . getString ( cursor . getColumnIndex ( AppInfoTable . KEY _ APP _ VERSION _ NAME ) ) ) ; int idx = cursor . getColumnIndex ( AppInfoTable . KEY _ APP _ ADMOB _ ACCOUNT ) ; if ( ! cursor . isNull ( idx ) ) { appInfo . setAdmobAccount ( cursor . getString ( idx ) ) ; } idx = cursor . getColumnIndex ( AppInfoTable . KEY _ APP _ ADMOB _ SITE _ ID ) ; if ( ! cursor . isNull ( idx ) ) { appInfo . setAdmobSiteId ( cursor . getString ( idx ) ) ; } idx = cursor . getColumnIndex ( AppInfoTable . KEY _ APP _ ADMOB _ AD _ UNIT _ ID ) ; if ( ! cursor . isNull ( idx ) ) { appInfo . setAdmobAdUnitId ( cursor . getString ( idx ) ) ; } idx = cursor . getColumnIndex ( AppInfoTable . KEY _ APP _ LAST _ COMMENTS _ UPDATE ) ; if ( ! cursor . isNull ( idx ) ) { appInfo . setLastCommentsUpdate ( new Date ( cursor . getLong ( idx ) ) ) ; } idx = cursor . getColumnIndex ( AppInfoTable . KEY _ APP _ DEVELOPER _ ID ) ; if ( ! cursor . isNull ( idx ) ) { appInfo . setDeveloperId ( cursor . getString ( idx ) ) ; } idx = cursor . getColumnIndex ( AppInfoTable . KEY _ APP _ DEVELOPER _ NAME ) ; if ( ! cursor . isNull ( idx ) ) { appInfo . setDeveloperName ( cursor . getString ( idx ) ) ; } appInfos . add ( appInfo ) ; } } finally { if ( cursor ! = null ) { cursor . close ( ) ; } } for ( AppInfo appInfo : appInfos ) { String packageName = appInfo . getPackageName ( ) ; AppStatsSummary statsForApp = getStatsForApp ( packageName , Timeframe . LAST _ TWO _ DAYS , false ) ; AppStats stats = new AppStats ( ) ; if ( statsForApp . getStats ( ) . size ( ) > _NUM ) { stats = statsForApp . getStats ( ) . get ( _NUM ) ; } else { if ( statsForApp . getStats ( ) . size ( ) > _NUM ) { stats = statsForApp . getStats ( ) . get ( _NUM ) ; } } stats . init ( ) ; appInfo . setLatestStats ( stats ) ; RevenueSummary revenueSummary = getRevenueSummaryForApp ( appInfo ) ; appInfo . setTotalRevenueSummary ( revenueSummary ) ; } return appInfos ; } 
896	public Header getFirstHeader ( ) { return new XSSFFirstHeader ( getSheetTypeHeaderFooter ( ) ) ; } 
897	public final void setEndPointEndingStyle ( String style ) { if ( style = = null ) { style = PDAnnotationLine . LE _ NONE ; } COSArray array = ( COSArray ) annot . getDictionaryObject ( COSName . LE ) ; if ( array = = null ) { array = new COSArray ( ) ; array . add ( COSName . getPDFName ( PDAnnotationLine . LE _ NONE ) ) ; array . add ( COSName . getPDFName ( style ) ) ; annot . setItem ( COSName . LE , array ) ; } else { array . setName ( _NUM , style ) ; } } 
898	public void setQueryHint ( CharSequence hint ) { mQueryHint = hint ; updateQueryHint ( ) ; } 
899	public boolean removeRangeMarker ( int index , Marker marker , Layer layer , boolean notify ) { if ( marker = = null ) { throw new IllegalArgumentException ( _STR ) ; } ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) ; } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } return removed ; } 
900	protected Processor getProcessorWithoutErrorHandler ( Route route ) { EventDrivenConsumerRoute consumerRoute = assertIsInstanceOf ( EventDrivenConsumerRoute . class , route ) ; Processor processor = unwrap ( consumerRoute . getProcessor ( ) ) ; return unwrapErrorHandler ( processor ) ; } 
901	private void fill ( ) { end = _NUM ; index = _NUM ; if ( source . hasNext ( ) ) source . doNextPreCheck ( ) ; int amountRead = _NUM ; as we keep filling , increase the read ahead buffer if ( nextEntries . length < MAX _ READ _ AHEAD _ ENTRIES ) nextEntries = new PreAllocatedArray < > ( Math . min ( nextEntries . length * _NUM , MAX _ READ _ AHEAD _ ENTRIES ) ) ; while ( source . hasNext ( ) & & end < nextEntries . length ) { Entry < Key , Value > ne = source . next ( ) ; nextEntries . set ( end + + , ne ) ; amountRead + = ne . getKey ( ) . getSize ( ) + ne . getValue ( ) . getSize ( ) ; if ( amountRead > READ _ AHEAD _ BYTES ) break ; } } 
902	public void fifthTest ( ) throws Exception { ClusterFixtureBuilder builder = ClusterFixture . builder ( dirTestWatcher ) . maxParallelization ( _NUM ) . configProperty ( ExecConstants . SYS _ STORE _ PROVIDER _ LOCAL _ ENABLE _ WRITE , true ) ; try ( ClusterFixture cluster = builder . build ( ) ; ClientFixture client = cluster . clientFixture ( ) ) { String sql = _STR + summary . queryIdString ( ) ) ; ProfileParser profile = client . parseProfile ( summary . queryIdString ( ) ) ; profile . print ( ) ; } } 
903	public XSSFTextParagraph addNewTextParagraph ( String text ) { XSSFTextParagraph paragraph = addNewTextParagraph ( ) ; paragraph . addNewTextRun ( ) . setText ( text ) ; return paragraph ; } 
904	public static void sendToHintedEndpoints ( final Mutation mutation , Iterable < InetAddressAndPort > targets , AbstractWriteResponseHandler < IMutation > responseHandler , String localDataCenter , Stage stage ) throws OverloadedException { int targetsSize = Iterables . size ( targets ) ; this dc replicas : Collection < InetAddressAndPort > localDc = null ; extra - datacenter replicas , grouped by dc Map < String , Collection < InetAddressAndPort > > dcGroups = null ; only need to create a Message for non - local writes MessageOut < Mutation > message = null ; boolean insertLocal = false ; ArrayList < InetAddressAndPort > endpointsToHint = null ; List < InetAddressAndPort > backPressureHosts = null ; for ( InetAddressAndPort destination : targets ) { checkHintOverload ( destination ) ; if ( FailureDetector . instance . isAlive ( destination ) ) { if ( canDoLocalRequest ( destination ) ) { insertLocal = true ; } else { belongs on a different server if ( message = = null ) message = mutation . createMessage ( ) ; String dc = DatabaseDescriptor . getEndpointSnitch ( ) . getDatacenter ( destination ) ; ( _NUM . _NUM knows how to forward old - style String message IDs ; updated to int in _NUM . _NUM ) if ( localDataCenter . equals ( dc ) ) { if ( localDc = = null ) localDc = new ArrayList < > ( targetsSize ) ; localDc . add ( destination ) ; } else { Collection < InetAddressAndPort > messages = ( dcGroups ! = null ) ? dcGroups . get ( dc ) : null ; if ( messages = = null ) { most DCs will have < = _NUM replicas messages = new ArrayList < > ( _NUM ) ; if ( dcGroups = = null ) dcGroups = new HashMap < > ( ) ; dcGroups . put ( dc , messages ) ; } messages . add ( destination ) ; } if ( backPressureHosts = = null ) backPressureHosts = new ArrayList < > ( targetsSize ) ; backPressureHosts . add ( destination ) ; } } else { Immediately mark the response as expired since the request will not be sent responseHandler . expired ( ) ; if ( shouldHint ( destination ) ) { if ( endpointsToHint = = null ) endpointsToHint = new ArrayList < > ( targetsSize ) ; endpointsToHint . add ( destination ) ; } } } if ( backPressureHosts ! = null ) MessagingService . instance ( ) . applyBackPressure ( backPressureHosts , responseHandler . currentTimeout ( ) ) ; if ( endpointsToHint ! = null ) submitHint ( mutation , endpointsToHint , responseHandler ) ; if ( insertLocal ) performLocally ( stage , Optional . of ( mutation ) , mutation : : apply , responseHandler ) ; if ( localDc ! = null ) { for ( InetAddressAndPort destination : localDc ) MessagingService . instance ( ) . sendRR ( message , destination , responseHandler , true ) ; } if ( dcGroups ! = null ) { for each datacenter , send the message to one node to relay the write to other replicas for ( Collection < InetAddressAndPort > dcTargets : dcGroups . values ( ) ) sendMessagesToNonlocalDC ( message , dcTargets , responseHandler ) ; } } 
905	public static Object convertToRowValues ( List < RelDataTypeField > relDataTypeFields , Object geodeResultObject ) { Object values ; if ( geodeResultObject instanceof Struct ) { values = handleStructEntry ( relDataTypeFields , geodeResultObject ) ; } else if ( geodeResultObject instanceof PdxInstance ) { values = handlePdxInstanceEntry ( relDataTypeFields , geodeResultObject ) ; } else { values = handleJavaObjectEntry ( relDataTypeFields , geodeResultObject ) ; } return values ; } 
906	public CharSequence [ ] getTextArray ( @ ArrayRes int id ) throws NotFoundException { CharSequence [ ] res = mResourcesImpl . getAssets ( ) . getResourceTextArray ( id ) ; if ( res ! = null ) { return res ; } throw new NotFoundException ( _STR + Integer . toHexString ( id ) ) ; } 
907	private void addRequestToAuditlogCache ( Request request ) { if ( ! auditLogger . isEnabled ( ) ) { return ; } if ( auditlogRequestCache . getIfPresent ( request . getRequestId ( ) ) = = null ) { int numberOfTasks = _NUM ; for ( Stage stage : request . getStages ( ) ) { numberOfTasks + = stage . getOrderedHostRoleCommands ( ) . size ( ) ; } RequestDetails requestDetails = new RequestDetails ( ) ; requestDetails . setNumberOfTasks ( numberOfTasks ) ; requestDetails . setUserName ( AuthorizationHelper . getAuthenticatedName ( ) ) ; auditlogRequestCache . put ( request . getRequestId ( ) , requestDetails ) ; } } 
908	Transport has been initialized and the PM metadata submitted successfullyif that was warranted . Now we process the single next thing in the queue . void invokeNextAgent ( ) { mStatus = BackupTransport . TRANSPORT _ OK ; backupManagerService . addBackupTrace ( _STR ) ; } } } 
909	public void dismiss ( ) { if ( DEBUG ) { Slog . d ( TAG , _STR ) ; } if ( mPrepared ) { dismissResources ( ) ; destroySurface ( ) ; mPrepared = false ; } } 
910	public Font getSelectedFont ( ) { Font font = new Font ( getSelectedFontFamily ( ) , getSelectedFontStyle ( ) , getSelectedFontSize ( ) ) ; return font ; } 
911	public void updateNotificationIcons ( NotificationData notificationData ) { updateIconsForLayout ( notificationData , entry - > entry . icon , mNotificationIcons , false ) ; updateIconsForLayout ( notificationData , entry - > entry . expandedIcon , mShelfIcons , NotificationShelf . SHOW _ AMBIENT _ ICONS ) ; applyNotificationIconsTint ( ) ; } 
912	public void removeComponent ( BaseCell component ) { int removePosition = getPositionByItem ( component ) ; if ( mData ! = null & & component ! = null & & removePosition > = _NUM ) { if ( mCards ! = null ) { List < Pair < Range < Integer > , Card > > newCards = new ArrayList < > ( ) ; for ( int i = _NUM , size = mCards . size ( ) ; i < size ; i + + ) { Pair < Range < Integer > , Card > pair = mCards . get ( i ) ; int start = pair . first . getLower ( ) ; int end = pair . first . getUpper ( ) ; if ( end < removePosition ) { do nothing newCards . add ( pair ) ; } else if ( start < = removePosition & & removePosition < end ) { int itemCount = end - start - _NUM ; if ( itemCount > _NUM ) { Pair < Range < Integer > , Card > newPair = new Pair < > ( Range . create ( start , end - _NUM ) , pair . second ) ; newCards . add ( newPair ) ; } } else if ( removePosition < = start ) { Pair < Range < Integer > , Card > newPair = new Pair < > ( Range . create ( start - _NUM , end - _NUM ) , pair . second ) ; newCards . add ( newPair ) ; } } component . removed ( ) ; mCards . clear ( ) ; mCards . addAll ( newCards ) ; mData . remove ( component ) ; notifyItemRemoved ( removePosition ) ; int last = mLayoutManager . findLastVisibleItemPosition ( ) ; notifyItemRangeChanged ( removePosition , last - removePosition ) ; } } } 
913	public void onDarkChanged ( Rect tintArea , float darkIntensity , int iconTint ) { if ( tintArea = = null ) { mTintArea . setEmpty ( ) ; } else { mTintArea . set ( tintArea ) ; } mIconTint = iconTint ; applyNotificationIconsTint ( ) ; } 
914	public void blockIdCK ( String blockId ) { if ( blockId = = null ) { out . println ( _STR , e ) ; } } 
915	int getDSTOffset ( Calendar source ) { TimeZone localTimezone = Calendar . getInstance ( ) . getTimeZone ( ) ; int rawOffset = localTimezone . getRawOffset ( ) / MILLIS _ TO _ MINUTES ; return getOffsetInMinutes ( source , localTimezone ) - rawOffset ; } 
916	private void extract ( ) throws RuntimeException , IOException , InterruptedException , ChildManager . ChildNotStartedException { ArchiveInputStream is = null ; ArchiveEntry entry ; CountingInputStream counter ; OutputStream outputStream = null ; File f , inFile ; File [ ] list ; String name ; String envPath ; final StringBuffer sb = new StringBuffer ( ) ; int mode ; int count ; long total ; boolean isTar , r , w , x , isElf , isScript ; short percentage , old _ percentage ; Child which ; if ( mCurrentTask . path = = null | | mCurrentTask . outputDir = = null ) return ; mBuilder . setContentTitle ( getString ( R . string . extracting ) ) . setContentText ( _STR ) . setProgress ( _NUM _NUM _NUM , _NUM _NUM _NUM , true ) . setChannelId ( getBaseContext ( ) . getString ( R . string . csploitChannelId ) ) ; mNotificationManager . notify ( NOTIFICATION _ ID , mBuilder . build ( ) ) ; } finally { if ( is ! = null ) is . close ( ) ; if ( outputStream ! = null ) outputStream . close ( ) ; } } 
917	public Object [ ] getViewableArray ( ) { Object [ ] results = new Object [ _NUM ] ; results [ _NUM ] = _STR + getSize ( ) ; return results ; } 
918	public static XmlENTITIES parse ( org . w _NUM c . dom . Node node ) throws org . apache . xmlbeans . XmlException { return ( XmlENTITIES ) XmlBeans . getContextTypeLoader ( ) . parse ( node , type , null ) ; } 
919	public static int readSwappedInteger ( final InputStream input ) throws IOException { final int value _NUM = read ( input ) ; final int value _NUM = read ( input ) ; final int value _NUM = read ( input ) ; final int value _NUM = read ( input ) ; return ( ( value _NUM & _NUM xff ) < < _NUM ) + ( ( value _NUM & _NUM xff ) < < _NUM ) + ( ( value _NUM & _NUM xff ) < < _NUM _NUM ) + ( ( value _NUM & _NUM xff ) < < _NUM _NUM ) ; } 
920	private void defaultAppWidget ( final Context context , final int [ ] appWidgetIds ) { final RemoteViews appWidgetView = new RemoteViews ( context . getPackageName ( ) , R . layout . app _ widget _ classic ) ; appWidgetView . setViewVisibility ( R . id . media _ titles , View . INVISIBLE ) ; appWidgetView . setViewVisibility ( R . id . image , View . INVISIBLE ) ; appWidgetView . setImageViewBitmap ( R . id . button _ next , createBitmap ( Util . getTintedVectorDrawable ( context , R . drawable . ic _ skip _ next _ white _ _NUM _NUM dp , MaterialValueHelper . getSecondaryTextColor ( context , false ) ) , _NUM f ) ) ; appWidgetView . setImageViewBitmap ( R . id . button _ prev , createBitmap ( Util . getTintedVectorDrawable ( context , R . drawable . ic _ skip _ previous _ white _ _NUM _NUM dp , MaterialValueHelper . getSecondaryTextColor ( context , false ) ) , _NUM f ) ) ; appWidgetView . setImageViewBitmap ( R . id . button _ toggle _ play _ pause , createBitmap ( Util . getTintedVectorDrawable ( context , R . drawable . ic _ play _ arrow _ white _ _NUM _NUM dp , MaterialValueHelper . getSecondaryTextColor ( context , false ) ) , _NUM f ) ) ; linkButtons ( context , appWidgetView ) ; pushUpdate ( context , appWidgetIds , appWidgetView ) ; } 
921	public void setThisData ( byte [ ] data ) { try { pen . setData ( data ) ; } catch ( Exception e ) { ThreadUtils . checkInterrupted ( e ) ; Throwables . propagate ( e ) ; } } 
922	private void animateText ( boolean nowVisible , final Runnable onFinishedRunnable ) { if ( nowVisible ! = mIsVisible ) { Animate text float endValue = nowVisible ? _NUM . _NUM f : _NUM . _NUM f ; Interpolator interpolator ; if ( nowVisible ) { interpolator = Interpolators . ALPHA _ IN ; } else { interpolator = Interpolators . ALPHA _ OUT ; } mAnimating = true ; mContent . animate ( ) . alpha ( endValue ) . setInterpolator ( interpolator ) . setDuration ( _NUM _NUM _NUM ) . withEndAction ( new Runnable ( ) { @ Override public void run ( ) { mAnimating = false ; if ( onFinishedRunnable ! = null ) { onFinishedRunnable . run ( ) ; } } } ) ; mIsVisible = nowVisible ; } else { if ( onFinishedRunnable ! = null ) { onFinishedRunnable . run ( ) ; } } } 
923	public void dereferenceObjectStreams ( ) throws IOException { for ( COSObject objStream : getObjectsByType ( COSName . OBJ _ STM ) ) { COSStream stream = ( COSStream ) objStream . getObject ( ) ; PDFObjectStreamParser parser = new PDFObjectStreamParser ( stream , this ) ; parser . parse ( ) ; for ( COSObject next : parser . getObjects ( ) ) { COSObjectKey key = new COSObjectKey ( next ) ; if ( objectPool . get ( key ) = = null | | objectPool . get ( key ) . getObject ( ) = = null | | xrefTable stores negated objNr of objStream for objects in objStreams ( xrefTable . containsKey ( key ) & & xrefTable . get ( key ) = = - objStream . getObjectNumber ( ) ) ) { COSObject obj = getObjectFromPool ( key ) ; obj . setObject ( next . getObject ( ) ) ; } } } } 
924	public SignerInformationStore getSignerInfos ( ) { if ( signerInfoStore = = null ) { ASN _NUM Set s = signedData . getSignerInfos ( ) ; List signerInfos = new ArrayList ( ) ; for ( int i = _NUM ; i ! = s . size ( ) ; i + + ) { SignerInfo info = SignerInfo . getInstance ( s . getObjectAt ( i ) ) ; ASN _NUM ObjectIdentifier contentType = signedData . getEncapContentInfo ( ) . getContentType ( ) ; if ( hashes = = null ) { signerInfos . add ( new SignerInformation ( info , contentType , signedContent , null ) ) ; } else { Object obj = hashes . keySet ( ) . iterator ( ) . next ( ) ; byte [ ] hash = ( obj instanceof String ) ? ( byte [ ] ) hashes . get ( info . getDigestAlgorithm ( ) . getAlgorithm ( ) . getId ( ) ) : ( byte [ ] ) hashes . get ( info . getDigestAlgorithm ( ) . getAlgorithm ( ) ) ; signerInfos . add ( new SignerInformation ( info , contentType , null , hash ) ) ; } } signerInfoStore = new SignerInformationStore ( signerInfos ) ; } return signerInfoStore ; } 
925	public boolean offer ( T t ) { if ( once . get ( ) ) { return false ; } if ( t = = null ) { throw new NullPointerException ( _STR ) ; } if ( fusionMode = = QueueSubscription . NONE ) { if ( queue . offer ( t ) ) { drain ( ) ; return true ; } } return false ; } 
926	public static < E extends Exception > void closeWhileHandlingException ( E priorException , Closeable . . . objects ) throws E , IOException { Throwable th = null ; for ( Closeable object : objects ) { try { if ( object ! = null ) { object . close ( ) ; } } catch ( Throwable t ) { addSuppressed ( ( priorException = = null ) ? th : priorException , t ) ; if ( th = = null ) { th = t ; } } } if ( priorException ! = null ) { throw priorException ; } else if ( th ! = null ) { if ( th instanceof IOException ) throw ( IOException ) th ; if ( th instanceof RuntimeException ) throw ( RuntimeException ) th ; if ( th instanceof Error ) throw ( Error ) th ; throw new RuntimeException ( th ) ; } } 
927	public void exportExcelAndSave ( String [ ] header , List < Object > excelList , String sheetTitle , String filePath , String fileName ) { ç”Ÿ æˆ Excel HSSFWorkbook book = exportExcel ( header , excelList , sheetTitle ) ; ä¿ å­˜ ç”Ÿ æˆ çš„ Excel saveExcel ( book , filePath , fileName ) ; } 
928	public synchronized String toPrintFriendlyHl _NUM String ( ) { if ( hasCompleteEnvelope ( ) ) { int startPosition = hasStartOfBlock ( ) ? startOfBlockIndex + _NUM : _NUM ; int endPosition = hasEndOfBlock ( ) ? endOfBlockIndex : availableByteCount - _NUM ; return Hl _NUM Util . convertToPrintFriendlyString ( buffer , startPosition , endPosition ) ; } return _STR ; } 
929	NOTE : this is an internal method used by the OnShellCommand implementation only and shouldbe guarded by permission checking . int getUidState ( int uid ) { synchronized ( this ) { return getUidStateLocked ( uid ) ; } } 
930	public static String execHttpGetString ( String url , String acceptHeader ) { CaptureString handler = new CaptureString ( ) ; try { execHttpGet ( url , acceptHeader , handler ) ; } catch ( HttpException ex ) { if ( ex . getResponseCode ( ) = = HttpSC . NOT _ FOUND _ _NUM _NUM _NUM ) return null ; throw ex ; } return handler . get ( ) ; } 
931	private Test documentTest ( ) throws QueryException { final boolean elem = consume ( ELEMENT ) ; if ( ! elem & & ! consume ( SCHEMA _ ELEMENT ) ) return null ; wsCheck ( PAREN _NUM ) ; skipWs ( ) ; final NodeTest nt = elem ? elementTest ( ) : schemaTest ( ) ; wsCheck ( PAREN _NUM ) ; return new DocTest ( nt ! = null ? nt : KindTest . ELM ) ; } 
932	private LayeredLayoutConstraint installConstraint ( LayeredLayoutConstraint constraint , Component cmp ) { if ( constraint . outer ( ) ! = this | | ( constraint . cmp ! = null & & constraint . cmp ! = cmp ) ) { LayeredLayoutConstraint tmp = createConstraint ( ) ; constraint . copyTo ( tmp ) ; constraint = tmp ; } constraint . cmp = cmp ; cmp . putClientProperty ( _STR , constraint ) ; return constraint ; } 
933	private void saveBundles ( final File dest , final Feature feature , final FeaturesService featuresService ) throws Exception { Save this feature ' s bundles . for ( final BundleInfo info : feature . getBundles ( ) ) { if ( ! onlyDependencies | | ( onlyDependencies & & info . isDependency ( ) ) ) { final File resolvedLocation = resolver . resolve ( info . getLocation ( ) ) ; if ( copyFileToDirectory ( resolvedLocation , dest ) ) { System . out . println ( _STR ) ; } } } 
934	public static void assertEquals ( String message , Object expected , Object actual ) { if ( expected = = null & & actual = = null ) return ; if ( expected ! = null & & expected . equals ( actual ) ) return ; failNotEquals ( message , expected , actual ) ; } 
935	public void bindShortcutsChanged ( final ArrayList < ShortcutInfo > updated , final ArrayList < ShortcutInfo > removed , final UserHandleCompat user ) { Runnable r = new Runnable ( ) { public void run ( ) { bindShortcutsChanged ( updated , removed , user ) ; } } ; if ( waitUntilResume ( r ) ) { return ; } if ( ! updated . isEmpty ( ) ) { mWorkspace . updateShortcuts ( updated ) ; } if ( ! removed . isEmpty ( ) ) { HashSet < ComponentName > removedComponents = new HashSet < > ( ) ; HashSet < ShortcutKey > removedDeepShortcuts = new HashSet < > ( ) ; for ( ShortcutInfo si : removed ) { if ( si . itemType = = Favorites . ITEM _ TYPE _ DEEP _ SHORTCUT ) { removedDeepShortcuts . add ( ShortcutKey . fromShortcutInfo ( si ) ) ; } else { removedComponents . add ( si . getTargetComponent ( ) ) ; } } if ( ! removedComponents . isEmpty ( ) ) { ItemInfoMatcher matcher = ItemInfoMatcher . ofComponents ( removedComponents , user ) ; mWorkspace . removeItemsByMatcher ( matcher ) ; mDragController . onAppsRemoved ( matcher ) ; } if ( ! removedDeepShortcuts . isEmpty ( ) ) { ItemInfoMatcher matcher = ItemInfoMatcher . ofShortcutKeys ( removedDeepShortcuts ) ; mWorkspace . removeItemsByMatcher ( matcher ) ; mDragController . onAppsRemoved ( matcher ) ; } } } 
936	public void teardownLocalCloudOnLocalhostAndWait ( final long timeout , final TimeUnit timeunit ) throws InterruptedException , TimeoutException , CLIException { setDefaultNicAddress ( ) ; setDefaultLocalcloudLookup ( ) ; uninstallApplications ( timeout , timeunit ) ; shutdownAgentOnLocalhostAndWaitInternal ( true , true , timeout , timeunit ) ; } 
937	public String authenticate ( Credentials credentials , String token ) throws GuacamoleException { Pull existing session if token provided GuacamoleSession existingSession ; if ( token ! = null ) existingSession = tokenSessionMap . get ( token ) ; else existingSession = null ; Get up - to - date AuthenticatedUser and associated UserContexts AuthenticatedUser authenticatedUser = getAuthenticatedUser ( existingSession , credentials ) ; List < DecoratedUserContext > userContexts = getUserContexts ( existingSession , authenticatedUser , credentials ) ; Update existing session , if it exists String authToken ; if ( existingSession ! = null ) { authToken = token ; existingSession . setAuthenticatedUser ( authenticatedUser ) ; existingSession . setUserContexts ( userContexts ) ; } else If no existing session , generate a new token / session pair { authToken = authTokenGenerator . getToken ( ) ; tokenSessionMap . put ( authToken , new GuacamoleSession ( environment , authenticatedUser , userContexts ) ) ; logger . debug ( _STR , authenticatedUser . getIdentifier ( ) ) ; } return authToken ; } 
938	public static boolean remove ( MetricType type ) { return type = = null ? false : REGISTRY . removeMetricType ( type ) ; } 
939	public String getDialogWidget ( CmsObject cms , I _ CmsWidgetDialog widgetDialog , I _ CmsWidgetParameter param ) { StringBuffer result = new StringBuffer ( _NUM _NUM ) ; result . append ( _STR ) ; return result . toString ( ) ; } 
940	public JSONArray optJSONArray ( String key ) { Object o = opt ( key ) ; return o instanceof JSONArray ? ( JSONArray ) o : null ; } 
941	public static XmlUnsignedShort parse ( java . net . URL u ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( XmlUnsignedShort ) XmlBeans . getContextTypeLoader ( ) . parse ( u , type , null ) ; } 
942	public void setTextSpacing ( int spacingPixels ) { mScaledTextSpacing = spacingPixels ; requestLayout ( ) ; } 
943	public AudioVisualizationRenderer build ( ) { final GLRenderer renderer = new GLRenderer ( builder . context , new Configuration ( builder ) ) ; final InnerAudioVisualization audioVisualization = new InnerAudioVisualization ( ) { @ Override public void startRendering ( ) { if ( glSurfaceView . getRenderMode ( ) ! = RENDERMODE _ CONTINUOUSLY ) { glSurfaceView . setRenderMode ( RENDERMODE _ CONTINUOUSLY ) ; } } @ Override public void stopRendering ( ) { if ( glSurfaceView . getRenderMode ( ) ! = RENDERMODE _ WHEN _ DIRTY ) { glSurfaceView . setRenderMode ( RENDERMODE _ WHEN _ DIRTY ) ; } } @ Override public void calmDownListener ( @ Nullable CalmDownListener calmDownListener ) { } @ Override public void onDataReceived ( float [ ] dBmArray , float [ ] ampsArray ) { renderer . onDataReceived ( dBmArray , ampsArray ) ; } } ; renderer . calmDownListener ( new CalmDownListener ( ) { @ Override public void onCalmedDown ( ) { audioVisualization . stopRendering ( ) ; } } ) ; handler . setUp ( audioVisualization , builder . layersCount ) ; return renderer ; } 
944	public List < RunningServiceInfo > getRunningServices ( int maxNum ) throws SecurityException { try { return getService ( ) . getServices ( maxNum , _NUM ) ; } catch ( RemoteException e ) { throw e . rethrowFromSystemServer ( ) ; } } 
945	public void queryMore ( ) throws IOException { try ( Query query = session . query ( _STR ) ) { int c = _NUM ; while ( query . more ( ) ) assertEqual ( Integer . toString ( + + c ) , query . next ( ) ) ; } } 
946	boolean submitProcedure ( Procedure proc ) { if the submitted procedure was null , then we don ' t want to run it if ( proc = = null ) { return false ; } String procName = proc . getName ( ) ; make sure we aren ' t already running a procedure of that name Procedure oldProc = procedures . get ( procName ) ; if ( oldProc ! = null ) { procedures are always eventually completed on both successful and failed execution try { if ( ! oldProc . isCompleted ( ) ) { LOG . warn ( _STR , e ) ; Remove the procedure from the list since is not started this . procedures . remove ( procName , proc ) ; the thread pool is full and we can ' t run the procedure proc . receive ( new ForeignException ( procName , e ) ) ; } return false ; } 
947	public void addValues ( Instances data , int attrIndex , int classIndex , int classValue ) throws Exception { can estimator handle the data ? m _ noClass = false ; getCapabilities ( ) . testWithFail ( data ) ; find the minimal and the maximal value double [ ] minMax = new double [ _NUM ] ; try { EstimatorUtils . getMinMax ( data , attrIndex , minMax ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; System . out . println ( ex . getMessage ( ) ) ; } double min = minMax [ _NUM ] ; double max = minMax [ _NUM ] ; extract the instances with the given class value Instances workData = new Instances ( data , _NUM ) ; double factor = getInstancesFromClass ( data , attrIndex , classIndex , ( double ) classValue , workData ) ; if no data return if ( workData . numInstances ( ) = = _NUM ) return ; addValues ( data , attrIndex , min , max , factor ) ; } 
948	private Map < Volume , StoragePool > getPoolListForVolumesForMigration ( VirtualMachineProfile profile , Host targetHost , Map < Long , Long > volumeToPool ) { if ( MapUtils . isEmpty ( volumeToPool ) ) { return getDefaultMappingOfVolumesAndStoragePoolForMigration ( profile , targetHost ) ; } return createMappingVolumeAndStoragePoolEnteredByUser ( profile , targetHost , volumeToPool ) ; } 
949	public static NdefRecord createUri ( Uri uri ) { if ( uri = = null ) throw new NullPointerException ( _STR ) ; byte prefix = _NUM ; for ( int i = _NUM ; i < URI _ PREFIX _ MAP . length ; i + + ) { if ( uriString . startsWith ( URI _ PREFIX _ MAP [ i ] ) ) { prefix = ( byte ) i ; uriString = uriString . substring ( URI _ PREFIX _ MAP [ i ] . length ( ) ) ; break ; } } byte [ ] uriBytes = uriString . getBytes ( StandardCharsets . UTF _ _NUM ) ; byte [ ] recordBytes = new byte [ uriBytes . length + _NUM ] ; recordBytes [ _NUM ] = prefix ; System . arraycopy ( uriBytes , _NUM , recordBytes , _NUM , uriBytes . length ) ; return new NdefRecord ( TNF _ WELL _ KNOWN , RTD _ URI , null , recordBytes ) ; } 
950	public void scrollRectToVisible ( int x , int y , int width , int height , Component coordinateSpace ) { if ( isScrollable ( ) ) { int scrollPosition = getScrollY ( ) ; Style s = getStyle ( ) ; int w = getWidth ( ) - s . getHorizontalPadding ( ) ; int h = getHeight ( ) - s . getVerticalPadding ( ) ; Rectangle view ; int invisibleAreaUnderVKB = getInvisibleAreaUnderVKB ( ) ; if ( isSmoothScrolling ( ) & & destScrollY > - _NUM ) { view = new Rectangle ( getScrollX ( ) , destScrollY , w , h - invisibleAreaUnderVKB ) ; } else { view = new Rectangle ( getScrollX ( ) , getScrollY ( ) , w , h - invisibleAreaUnderVKB ) ; } int relativeX = x ; int relativeY = y ; component needs to be in absolute coordinates . . . Container parent = null ; if ( coordinateSpace ! = null ) { parent = coordinateSpace . getParent ( ) ; } if ( parent = = this ) { if ( view . contains ( x , y , width , height ) ) { return ; } } else { while ( parent ! = this ) { mostly a special case for list if ( parent = = null ) { relativeX = x ; relativeY = y ; break ; } relativeX + = parent . getX ( ) ; relativeY + = parent . getY ( ) ; parent = parent . getParent ( ) ; } if ( view . contains ( relativeX , relativeY , width , height ) ) { return ; } } if ( isScrollableX ( ) ) { if ( getScrollX ( ) > relativeX ) { setScrollX ( relativeX ) ; } int rightX = relativeX + width - s . getHorizontalPadding ( ) ; if ( getScrollX ( ) + w < rightX ) { setScrollX ( getScrollX ( ) + ( rightX - ( getScrollX ( ) + w ) ) ) ; } else { if ( getScrollX ( ) > relativeX ) { setScrollX ( relativeX ) ; } } } if ( isScrollableY ( ) ) { if ( getScrollY ( ) > relativeY ) { scrollPosition = relativeY ; } int bottomY = relativeY + height - s . getVerticalPadding ( ) ; if ( getScrollY ( ) + h < bottomY + invisibleAreaUnderVKB ) { scrollPosition = getScrollY ( ) + ( bottomY - ( getScrollY ( ) + h ) ) + invisibleAreaUnderVKB ; } else { if ( getScrollY ( ) > relativeY ) { scrollPosition = relativeY ; } } if ( isSmoothScrolling ( ) & & isInitialized ( ) ) { initialScrollY = getScrollY ( ) ; destScrollY = scrollPosition ; initScrollMotion ( ) ; } else { setScrollY ( scrollPosition ) ; } } repaint ( ) ; } else { try to move parent scroll if you are not scrollable Container parent = getParent ( ) ; if ( parent ! = null ) { parent . scrollRectToVisible ( getAbsoluteX ( ) - parent . getAbsoluteX ( ) + x , getAbsoluteY ( ) - parent . getAbsoluteY ( ) + y , width , height , parent ) ; } } } 
951	public void setFixedDomainAxisSpace ( AxisSpace space , boolean notify ) { this . fixedDomainAxisSpace = space ; if ( notify ) { fireChangeEvent ( ) ; } } 
952	public boolean draw ( Canvas canvas , RectF bounds ) { if ( super . draw ( canvas , bounds ) ) { return true ; } final float endPos = calcCurrentPosition ( mPositionStart , mPositionEnd , mSeriesItem . getMinValue ( ) , mSeriesItem . getMaxValue ( ) , mPercentComplete ) ; mArcAngleSweep = adjustSweepDirection ( verifyMinSweepAngle ( endPos * mAngleSweep ) ) ; mArcAngleStart = mAngleStart ; if ( mSeriesItem . getDrawAsPoint ( ) ) { mArcAngleStart = adjustDrawPointAngle ( mArcAngleSweep ) ; mArcAngleSweep = adjustSweepDirection ( getMinSweepAngle ( ) ) ; } else if ( mArcAngleSweep = = _NUM ) { return true ; } return false ; } 
953	public static < TNode extends AvlNode > TNode remove ( TNode root , Object key , final AvlKeyComparator < TNode > keyComparator , final AtomicBoolean removed ) { if ( root = = null ) return null ; int cmp = keyComparator . compareKey ( root , key ) ; if ( cmp = = _NUM ) { if ( removed ! = null ) removed . set ( true ) ; TNode q = ( TNode ) root . avlLeft ; TNode r = ( TNode ) root . avlRight ; if ( r = = null ) return q ; TNode min = getFirst ( r ) ; min . avlRight = removeMin ( r ) ; min . avlLeft = q ; return balance ( min ) ; } else if ( cmp > _NUM ) { root . avlLeft = remove ( ( TNode ) root . avlLeft , key , keyComparator ) ; } else { root . avlRight = remove ( ( TNode ) root . avlRight , key , keyComparator ) ; } return balance ( root ) ; } 
954	public Drawable getDrawableForDensity ( @ DrawableRes int id , int density , @ Nullable Theme theme ) { final TypedValue value = obtainTempTypedValue ( ) ; try { final ResourcesImpl impl = mResourcesImpl ; impl . getValueForDensity ( id , density , value , true ) ; return impl . loadDrawable ( this , value , id , density , theme ) ; } finally { releaseTempTypedValue ( value ) ; } } 
955	public void readPreviousVersionProperties ( StorageDirectory sd ) throws IOException { Properties props = readPropertiesFile ( sd . getPreviousVersionFile ( ) ) ; setFieldsFromProperties ( props , sd ) ; } 
956	public String getString ( ) { ByteBuffer bb = getBlob ( ) ; if ( bb = = null ) return null ; int x = bb . position ( ) ; String s = Bytes . fromByteBuffer ( bb ) ; bb . position ( x ) ; return s ; } 
957	public List < User > getUsers ( ) { return getUserService ( ) . getUsers ( ) . getResults ( ) ; } 
958	public final void push ( final int element ) { add ( element ) ; } 
959	public boolean visibleBoundsContains ( int x , int y ) { boolean contains = true ; if ( ! isVisible ( ) | | ! contains ( x , y ) ) { contains = false ; } if ( contains ) { Container parent = getParent ( ) ; while ( parent ! = null ) { if ( ! parent . visibleBoundsContains ( x , y ) ) { contains = false ; } if ( ! contains ) { break ; } parent = parent . getParent ( ) ; } } return contains ; } 
960	public void connect ( LocalSocketAddress endpoint ) throws IOException { synchronized ( this ) { if ( isConnected ) { throw new IOException ( _STR ) ; } implCreateIfNeeded ( ) ; impl . connect ( endpoint , _NUM ) ; isConnected = true ; isBound = true ; } } 
961	public void checkParentPermission ( Mode . Bits bits , LockedInodePath inodePath ) throws AccessControlException , InvalidPathException { if ( ! mPermissionCheckEnabled ) { return ; } root _STR has no parent , so return without checking if ( PathUtils . isRoot ( inodePath . getUri ( ) . getPath ( ) ) ) { return ; } collects existing inodes info on the path . Note that , not all the components of the path have corresponding inodes . List < Inode < ? > > inodeList = inodePath . getInodeList ( ) ; collects user and groups String user = AuthenticatedClientUser . getClientUser ( ) ; List < String > groups = getGroups ( user ) ; remove the last element if all components of the path exist , since we only check the parent . if ( inodePath . fullPathExists ( ) ) { inodeList . remove ( inodeList . size ( ) - _NUM ) ; } checkInodeList ( user , groups , bits , inodePath . getUri ( ) . getPath ( ) , inodeList , false ) ; } 
962	public XWPFFooter createFooter ( Enum type , XWPFParagraph [ ] pars ) { XWPFFooter footer = getFooter ( type ) ; if ( footer = = null ) { FtrDocument ftrDoc = FtrDocument . Factory . newInstance ( ) ; XWPFRelation relation = XWPFRelation . FOOTER ; int i = getRelationIndex ( relation ) ; XWPFFooter wrapper = ( XWPFFooter ) doc . createRelationship ( relation , XWPFFactory . getInstance ( ) , i ) ; wrapper . setXWPFDocument ( doc ) ; CTHdrFtr ftr = buildFtr ( type , wrapper , pars ) ; wrapper . setHeaderFooter ( ftr ) ; ftrDoc . setFtr ( ftr ) ; assignFooter ( wrapper , type ) ; footer = wrapper ; } return footer ; } 
963	public void write ( OutputStream out , boolean preserveNodes ) throws IOException { Get a new FileSystem to write into POIFSFileSystem outFS = new POIFSFileSystem ( ) ; try { Write into the new FileSystem write ( outFS , preserveNodes ) ; Send the POIFSFileSystem object out to the underlying stream outFS . writeFilesystem ( out ) ; } finally { outFS . close ( ) ; } } 
964	public void removeUidsLocked ( int [ ] uids ) { if ( mRotator ! = null ) { try { Rewrite all persisted data to migrate UID stats mRotator . rewriteAll ( new RemoveUidRewriter ( mBucketDuration , uids ) ) ; } catch ( IOException e ) { Log . wtf ( TAG , _STR + Arrays . toString ( uids ) , e ) ; recoverFromWtf ( ) ; } } Remove any pending stats if ( mPending ! = null ) { mPending . removeUids ( uids ) ; } if ( mSinceBoot ! = null ) { mSinceBoot . removeUids ( uids ) ; } Clear UID from current stats snapshot if ( mLastSnapshot ! = null ) { mLastSnapshot = mLastSnapshot . withoutUids ( uids ) ; } final NetworkStatsCollection complete = mComplete ! = null ? mComplete . get ( ) : null ; if ( complete ! = null ) { complete . removeUids ( uids ) ; } } 
965	public void transformMatrixToGlobal ( Matrix m ) { final ViewParent parent = mParent ; if ( parent instanceof View ) { final View vp = ( View ) parent ; vp . transformMatrixToGlobal ( m ) ; m . preTranslate ( - vp . mScrollX , - vp . mScrollY ) ; } else if ( parent instanceof ViewRootImpl ) { final ViewRootImpl vr = ( ViewRootImpl ) parent ; vr . transformMatrixToGlobal ( m ) ; m . preTranslate ( _NUM , - vr . mCurScrollY ) ; } m . preTranslate ( mLeft , mTop ) ; if ( ! hasIdentityMatrix ( ) ) { m . preConcat ( getMatrix ( ) ) ; } } 
966	public void setAnimation ( Image animation ) { this . animation = animation ; cache . clear ( ) ; } 
967	public UiObject getChildByText ( UiSelector childPattern , String text ) throws UiObjectNotFoundException { Tracer . trace ( childPattern , text ) ; if ( text ! = null ) { int count = getChildCount ( childPattern ) ; for ( int x = _NUM ; x < count ; x + + ) { UiObject row = getChildByInstance ( childPattern , x ) ; String nodeText = row . getText ( ) ; if ( text . equals ( nodeText ) ) { return row ; } UiObject item = row . getChild ( new UiSelector ( ) . text ( text ) ) ; if ( item . exists ( ) ) { return row ; } } } throw new UiObjectNotFoundException ( _STR ) ; } 
968	public String getLabel ( ) { return cleanString ( _ label ) ; } 
969	public Messages . Tag . Builder addTagsBuilder ( ) { return getTagsFieldBuilder ( ) . addBuilder ( Messages . Tag . getDefaultInstance ( ) ) ; } 
970	private String getCucumberOptionsString ( final Bundle bundle ) { if ( bundle = = null ) { return _STR , features ) ; return sb . toString ( ) ; } 
971	public static int getVCores ( ResourceCalculatorPlugin plugin , Configuration conf ) { int cores ; boolean hardwareDetectionEnabled = conf . getBoolean ( YarnConfiguration . NM _ ENABLE _ HARDWARE _ CAPABILITY _ DETECTION , YarnConfiguration . DEFAULT _ NM _ ENABLE _ HARDWARE _ CAPABILITY _ DETECTION ) ; String message ; if ( ! hardwareDetectionEnabled | | plugin = = null ) { cores = conf . getInt ( YarnConfiguration . NM _ VCORES , YarnConfiguration . DEFAULT _ NM _ VCORES ) ; if ( cores = = - _NUM ) { cores = YarnConfiguration . DEFAULT _ NM _ VCORES ; } } else { cores = conf . getInt ( YarnConfiguration . NM _ VCORES , - _NUM ) ; if ( cores = = - _NUM ) { float physicalCores = NodeManagerHardwareUtils . getContainersCPUs ( plugin , conf ) ; float multiplier = conf . getFloat ( YarnConfiguration . NM _ PCORES _ VCORES _ MULTIPLIER , YarnConfiguration . DEFAULT _ NM _ PCORES _ VCORES _ MULTIPLIER ) ; if ( multiplier > _NUM ) { float tmp = physicalCores * multiplier ; if ( tmp > _NUM & & tmp < _NUM ) { on a single core machine - tmp can be between _NUM and _NUM cores = _NUM ; } else { cores = ( int ) tmp ; } } else { message = _STR ; throw new IllegalArgumentException ( message ) ; } return cores ; } 
972	public String mapName ( String word ) { return mapString ( word , insertOrder ) ; } 
973	public void setParameter ( Property parameter , Object value ) { throw new IllegalParameterException ( parameter . toString ( ) ) ; } 
974	public static void overwriteRegions ( Connection connection , List < RegionInfo > regionInfos , int regionReplication ) throws IOException { use master time for delete marker and the Put long now = EnvironmentEdgeManager . currentTime ( ) ; deleteRegions ( connection , regionInfos , now ) ; Why sleep ? This is the easiest way to ensure that the previous deletes does not eclipse the following puts , that might happen in the same ts from the server . See HBASE - _NUM _NUM _NUM _NUM , and HBASE - _NUM _NUM _NUM _NUM . Once either HBASE - _NUM _NUM _NUM _NUM , HBASE - _NUM _NUM _NUM _NUM is fixed , or HBASE - _NUM _NUM _NUM _NUM is fixed and meta uses seqIds , we do not need the sleep . HBASE - _NUM _NUM _NUM _NUM _NUM uses master timestamp for the mutations . The _NUM _NUM ms sleep is not needed addRegionsToMeta ( connection , regionInfos , regionReplication , now + _NUM ) ; LOG . info ( _STR , regionInfos ) ; } 
975	public void testSaveNamespace ( ) throws Exception { start a cluster Configuration conf = new HdfsConfiguration ( ) ; MiniDFSCluster cluster = null ; FileSystem fileSys = null ; AtomicReference < Throwable > caughtErr = new AtomicReference < Throwable > ( ) ; try { cluster = new MiniDFSCluster . Builder ( conf ) . numDataNodes ( NUM _ DATA _ NODES ) . build ( ) ; cluster . waitActive ( ) ; fileSys = cluster . getFileSystem ( ) ; final FSNamesystem namesystem = cluster . getNamesystem ( ) ; final NamenodeProtocols nn = cluster . getNameNodeRpc ( ) ; FSImage fsimage = namesystem . getFSImage ( ) ; FSEditLog editLog = fsimage . getEditLog ( ) ; startTransactionWorkers ( nn , caughtErr ) ; for ( int i = _NUM ; i < NUM _ SAVE _ IMAGE & & caughtErr . get ( ) = = null ; i + + ) { try { Thread . sleep ( _NUM _NUM ) ; } catch ( InterruptedException ignored ) { } LOG . info ( _STR ) ; } } finally { stopTransactionWorkers ( ) ; if ( caughtErr . get ( ) ! = null ) { throw new RuntimeException ( caughtErr . get ( ) ) ; } if ( fileSys ! = null ) fileSys . close ( ) ; if ( cluster ! = null ) cluster . shutdown ( ) ; } } 
976	public boolean shouldHideSipper ( BatterySipper sipper ) { final BatterySipper . DrainType drainType = sipper . drainType ; return drainType = = BatterySipper . DrainType . IDLE | | drainType = = BatterySipper . DrainType . CELL | | drainType = = BatterySipper . DrainType . SCREEN | | drainType = = BatterySipper . DrainType . UNACCOUNTED | | drainType = = BatterySipper . DrainType . OVERCOUNTED | | isTypeService ( sipper ) | | isTypeSystem ( sipper ) ; } 
977	public static short translateBucketAcl ( AccessControlList acl , String userId ) { short mode = ( short ) _NUM ; for ( Grant grant : acl . getGrantsAsList ( ) ) { Permission perm = grant . getPermission ( ) ; Grantee grantee = grant . getGrantee ( ) ; if ( perm . equals ( Permission . Read ) ) { if ( isUserIdInGrantee ( grantee , userId ) ) { If the bucket is readable by the user , add r and x to the owner mode . mode | = ( short ) _NUM _NUM _NUM _NUM ; } } else if ( perm . equals ( Permission . Write ) ) { if ( isUserIdInGrantee ( grantee , userId ) ) { If the bucket is writable by the user , + w to the owner mode . mode | = ( short ) _NUM _NUM _NUM _NUM ; } } else if ( perm . equals ( Permission . FullControl ) ) { if ( isUserIdInGrantee ( grantee , userId ) ) { If the user has full control to the bucket , + rwx to the owner mode . mode | = ( short ) _NUM _NUM _NUM _NUM ; } } } return mode ; } 
978	private void dumpThreads ( ) { if ( LOG . isDebugEnabled ( ) ) { StringBuffer b = new StringBuffer ( _NUM _NUM _NUM ) ; Iterator < CmsUUID > i = m _ threads . keySet ( ) . iterator ( ) ; while ( i . hasNext ( ) ) { CmsUUID key = i . next ( ) ; A _ CmsReportThread thread = m _ threads . get ( key ) ; b . append ( thread . getName ( ) ) ; b . append ( _STR ) ; b . append ( thread . getUUID ( ) ) ; b . append ( ' \ n ' ) ; } LOG . debug ( Messages . get ( ) . getBundle ( ) . key ( Messages . LOG _ THREADSTORE _ POOL _ CONTENT _ _NUM , new Integer ( m _ threads . size ( ) ) , b . toString ( ) ) ) ; } } 
979	public static void deleteRecursive ( ZooKeeper zk , final String pathRoot , VoidCallback cb , Object ctx ) throws InterruptedException , KeeperException { PathUtils . validatePath ( pathRoot ) ; List < String > tree = listSubTreeBFS ( zk , pathRoot ) ; LOG . debug ( _STR ) ; for ( int i = tree . size ( ) - _NUM ; i > = _NUM ; - - i ) { Delete the leaves first and eventually get rid of the root Delete all versions of the node with - _NUM . zk . delete ( tree . get ( i ) , - _NUM , cb , ctx ) ; } } 
980	public Pair < Map < SDVariable , DifferentialFunction > , List < DifferentialFunction > > execBackwards ( ) { final SameDiff outer = this ; if ( getFunction ( _STR ) ; if ( grad . isDebugMode ( ) ) { ensure all gradients are present for all variables for ( SDVariable sdVariable : grad . variables ( ) ) { sdVariable . gradient ( ) ; } } return forward ; } 
981	protected < T > T getBody ( int aIndex , Class < T > aType ) { Message in = getMessage ( aIndex ) ; T body = in . getBody ( aType ) ; assertNotNull ( body ) ; return body ; } 
982	public void _ testGroupExpressionEquivalenceCorrelated ( ) { dname comes from dept , so it is constant within the sub - query , and is so is a valid expr in a group - by query check ( _STR ) ; } 
983	public static Timestamp valueOf ( CharSequence ionFormattedTimestamp ) { final CharSequence in = ionFormattedTimestamp ; int pos ; final int length = in . length ( ) ; if ( length = = _NUM ) { throw fail ( in ) ; } check for ' null . timestamp ' if ( in . charAt ( _NUM ) = = ' n ' ) { if ( length > = LEN _ OF _ NULL _ IMAGE & & NULL _ TIMESTAMP _ IMAGE . contentEquals ( in . subSequence ( _NUM , LEN _ OF _ NULL _ IMAGE ) ) ) { if ( length > LEN _ OF _ NULL _ IMAGE ) { if ( ! isValidFollowChar ( in . charAt ( LEN _ OF _ NULL _ IMAGE ) ) ) { throw fail ( in ) ; } } return null ; } throw fail ( in ) ; } int year = _NUM ; int month = _NUM ; int day = _NUM ; int hour = _NUM ; int minute = _NUM ; int seconds = _NUM ; BigDecimal fraction = null ; Precision precision ; fake label to turn goto ' s into a break so Java is happy : ) enjoy do { otherwise we expect yyyy - mm - ddThh : mm : ss . ssss + hh : mm if ( length < END _ OF _ YEAR + _NUM ) { + _NUM for the _STR ) ; } Timestamp ts = new Timestamp ( precision , year , month , day , hour , minute , seconds , fraction , offset , APPLY _ OFFSET _ YES ) ; return ts ; } 
984	private void initRemoteRegistration ( List < String > functions , JarManager jarManager , RemoteFunctionRegistry remoteRegistry ) throws IOException { int retryAttempts = remoteRegistry . getRetryAttempts ( ) ; boolean copyJars = true ; try { while ( retryAttempts > = _NUM ) { DataChangeVersion version = new DataChangeVersion ( ) ; List < Jar > remoteJars = remoteRegistry . getRegistry ( version ) . getJarList ( ) ; validateAgainstRemoteRegistry ( remoteJars , jarManager . getBinaryName ( ) , functions ) ; if ( copyJars ) { jarManager . copyToRegistryArea ( ) ; copyJars = false ; } List < Jar > jars = Lists . newArrayList ( remoteJars ) ; jars . add ( Jar . newBuilder ( ) . setName ( jarManager . getBinaryName ( ) ) . addAllFunctionSignature ( functions ) . build ( ) ) ; Registry updatedRegistry = Registry . newBuilder ( ) . addAllJar ( jars ) . build ( ) ; try { remoteRegistry . updateRegistry ( updatedRegistry , version ) ; return ; } catch ( VersionMismatchException ex ) { logger . debug ( _STR ) ; } catch ( Exception e ) { if ( ! copyJars ) { jarManager . deleteQuietlyFromRegistryArea ( ) ; } throw e ; } } 
985	public ImmutableList < RexNode > fields ( RelCollation collation ) { final ImmutableList . Builder < RexNode > nodes = ImmutableList . builder ( ) ; for ( RelFieldCollation fieldCollation : collation . getFieldCollations ( ) ) { RexNode node = field ( fieldCollation . getFieldIndex ( ) ) ; switch ( fieldCollation . direction ) { case DESCENDING : node = desc ( node ) ; } switch ( fieldCollation . nullDirection ) { case FIRST : node = nullsFirst ( node ) ; break ; case LAST : node = nullsLast ( node ) ; break ; } nodes . add ( node ) ; } return nodes . build ( ) ; } 
986	public static void round ( Calendar c , String unit ) { Integer uu = CALENDAR _ UNITS . get ( unit ) ; if ( null = = uu ) { throw new IllegalArgumentException ( _STR + unit ) ; } } 
987	public static XmlDate parse ( java . net . URL u ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( XmlDate ) XmlBeans . getContextTypeLoader ( ) . parse ( u , type , null ) ; } 
988	public void onDestroy ( ) { super . onDestroy ( ) ; Log . d ( LOG _ TAG , _STR , Toast . LENGTH _ SHORT ) ; } 
989	public Integer getDeviceId ( INDArray array ) { return getAllocationPoint ( array ) . getDeviceId ( ) ; } 
990	boolean isStoppingNoHistoryActivity ( ) { activity has become visible . for ( ActivityRecord record : mStoppingActivities ) { if ( record . isNoHistory ( ) ) { return true ; } } return false ; } 
991	public static QueryExecution sparqlService ( String service , Query query , HttpClient client , HttpContext httpContext ) { checkNotNull ( service , _STR ) ; checkArg ( query ) ; return createServiceRequest ( service , query , client , httpContext ) ; } 
992	public void addBRule ( Rule brule ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( _STR + brule ) ; } bEngine . addRule ( brule ) ; bEngine . reset ( ) ; } 
993	private Instances defineDataset ( Random random ) throws Exception { boolean [ ] attList _ Irr ; int [ ] attList _ Num ; FastVector attributes = new FastVector ( ) ; Attribute attribute ; FastVector nominalValues = new FastVector ( _NUM ) ; nominalValues . addElement ( _STR , classValues ) ; attributes . addElement ( attribute ) ; dataset = new Instances ( getRelationNameToUse ( ) , attributes , getNumExamplesAct ( ) ) ; dataset . setClassIndex ( getNumAttributes ( ) ) ; set dataset format of this class Instances format = new Instances ( dataset , _NUM ) ; setDatasetFormat ( format ) ; return dataset ; } 
994	public boolean setReplication ( Path src , short replication ) throws IOException , UnresolvedLinkException { boolean value = getMyFs ( ) . setReplication ( src , replication ) ; if ( ! value ) { return false ; } Path checkFile = getChecksumFile ( src ) ; if ( exists ( checkFile ) ) { getMyFs ( ) . setReplication ( checkFile , replication ) ; } return true ; } 
995	private CmsCroppingParamBean getInitialCroppingParameter ( String resourcePath ) { CmsImageInfoBean imageInfo = getImageInfo ( resourcePath ) ; CmsImageFormatHandler formatHandler = new CmsImageFormatHandler ( getGalleryMode ( ) , resourcePath , imageInfo . getHeight ( ) , imageInfo . getWidth ( ) ) ; CmsCroppingParamBean param = formatHandler . getCroppingParam ( ) ; if ( formatHandler . isUseFormats ( ) ) { formatHandler . getFormats ( ) . values ( ) . iterator ( ) . next ( ) . adjustCroppingParam ( param ) ; } return param ; } 
996	public static INDArray rand ( int [ ] shape , long seed ) { ; INSTANCE . rand ( shape , seed ) ; INDArray ret = createUninitialized ( shape , Nd _NUM j . order ( ) ) ; logCreationIfNecessary ( ret ) ; return rand ( ret , seed ) ; } 
997	public void testDisableReusingLastProvider ( ) throws Exception { MockCredentialsProvider provider _NUM = new MockCredentialsProvider ( ) ; provider _NUM . throwException = true ; MockCredentialsProvider provider _NUM = new MockCredentialsProvider ( ) ; AWSCredentialsProviderChain chain = new AWSCredentialsProviderChain ( provider _NUM , provider _NUM ) ; chain . setReuseLastProvider ( false ) ; assertEquals ( _NUM , provider _NUM . getCredentialsCallCount ) ; assertEquals ( _NUM , provider _NUM . getCredentialsCallCount ) ; chain . getCredentials ( ) ; assertEquals ( _NUM , provider _NUM . getCredentialsCallCount ) ; assertEquals ( _NUM , provider _NUM . getCredentialsCallCount ) ; chain . getCredentials ( ) ; assertEquals ( _NUM , provider _NUM . getCredentialsCallCount ) ; assertEquals ( _NUM , provider _NUM . getCredentialsCallCount ) ; } 
998	public List < PluginInfo > getPluginInfos ( String type ) { List < PluginInfo > result = pluginStore . get ( type ) ; return result = = null ? ( List < PluginInfo > ) Collections . EMPTY _ LIST : result ; } 
999	protectedRenameTo ( FSDirectory fsd , String src , String dst , final INodesInPath srcIIP , final INodesInPath dstIIP , long timestamp , BlocksMapUpdateInfo collectedBlocks , Options . Rename . . . options ) throws IOException { assert fsd . hasWriteLock ( ) ; boolean overwrite = options ! = null & & Arrays . asList ( options ) . contains ( Options . Rename . OVERWRITE ) ; final String error ; final INode srcInode = srcIIP . getLastINode ( ) ; validateRenameSource ( srcIIP ) ; validate the destination if ( dst . equals ( src ) ) { throw new FileAlreadyExistsException ( _STR ) ; } 
1000	public void setOptimisticStreamUnsafe ( WriteSetSMRStream optimisticStream ) { if ( this . optimisticStream ! = null ) { optimisticRollbackUnsafe ( ) ; } this . optimisticStream = optimisticStream ; } 
1001	public synchronized Collection < Beacon > finalizeBeacons ( ) { Map < Beacon , RangedBeacon > newRangedBeacons = new HashMap < Beacon , RangedBeacon > ( ) ; ArrayList < Beacon > finalizedBeacons = new ArrayList < Beacon > ( ) ; synchronized ( mRangedBeacons ) { for ( Beacon beacon : mRangedBeacons . keySet ( ) ) { RangedBeacon rangedBeacon = mRangedBeacons . get ( beacon ) ; if ( rangedBeacon . isTracked ( ) ) { calculates accuracy rangedBeacon . commitMeasurements ( ) ; if ( ! rangedBeacon . noMeasurementsAvailable ( ) ) { finalizedBeacons . add ( rangedBeacon . getBeacon ( ) ) ; } } tracked anymore so we don ' t pass it on as visible unless it is seen again if ( ! rangedBeacon . noMeasurementsAvailable ( ) = = true ) { measurements for a certain amount of time if ( ! sUseTrackingCache | | rangedBeacon . isExpired ( ) ) rangedBeacon . setTracked ( false ) ; newRangedBeacons . put ( beacon , rangedBeacon ) ; } else { LogManager . d ( TAG , _STR ) ; } } mRangedBeacons = newRangedBeacons ; } return finalizedBeacons ; } 
1002	public void applyToCanvas ( Canvas canvas ) { if ( canvas . isHardwareAccelerated ( ) ) { if ( mMatrix = = null ) mMatrix = new Matrix ( ) ; getMatrix ( mMatrix ) ; canvas . concat ( mMatrix ) ; } else { nativeApplyToCanvas ( canvas . getNativeCanvasWrapper ( ) ) ; } } 
1003	private static Method moduleMethod ( final Object module , final String name , final int arity , final String [ ] types , final QueryContext qc , final InputInfo info ) throws QueryException { find method with identical name and arity Method meth = null ; int methArity = - _NUM ; final Class < ? > clazz = module . getClass ( ) ; for ( final Method m : clazz . getMethods ( ) ) { if ( ! m . getName ( ) . equals ( name ) ) continue ; final Class < ? > [ ] pTypes = m . getParameterTypes ( ) ; methArity = pTypes . length ; if ( methArity ! = arity ) continue ; methArity = - _NUM ; if ( ! typeMatches ( pTypes , types ) ) continue ; if ( meth ! = null ) throw JAVAAMB _ X _ X _ X . get ( info , clazz . getName ( ) , name , arity ) ; meth = m ; } if ( meth = = null ) { if ( methArity ! = - _NUM ) throw JAVAARITY _ X _ X _ X _ X . get ( info , clazz . getName ( ) , name , methArity , arguments ( arity ) ) ; throw WHICHJAVA _ X _ X _ X . get ( info , clazz . getName ( ) , name , arity ) ; } Add module locks to QueryContext . final Lock lock = meth . getAnnotation ( Lock . class ) ; if ( lock ! = null ) { for ( final String read : lock . read ( ) ) qc . readLocks . add ( Locking . MODULE _ PREFIX + read ) ; for ( final String write : lock . write ( ) ) qc . writeLocks . add ( Locking . MODULE _ PREFIX + write ) ; } return meth ; } 
1004	private void createConnectionFactoryInstance ( ConfigurationContext context ) { String connectionFactoryImplName = context . getProperty ( CONNECTION _ FACTORY _ IMPL ) . evaluateAttributeExpressions ( ) . getValue ( ) ; this . connectionFactory = Utils . newDefaultInstance ( connectionFactoryImplName ) ; } 
1005	protected byte [ ] engineGetEncoded ( ) { AlgorithmIdentifier hashAlgorithm = new AlgorithmIdentifier ( DigestFactory . getOID ( currentSpec . getDigestAlgorithm ( ) ) , DERNull . INSTANCE ) ; MGF _NUM ParameterSpec mgfSpec = ( MGF _NUM ParameterSpec ) currentSpec . getMGFParameters ( ) ; AlgorithmIdentifier maskGenAlgorithm = new AlgorithmIdentifier ( PKCSObjectIdentifiers . id _ mgf _NUM , new AlgorithmIdentifier ( DigestFactory . getOID ( mgfSpec . getDigestAlgorithm ( ) ) , DERNull . INSTANCE ) ) ; PSource . PSpecified pSource = ( PSource . PSpecified ) currentSpec . getPSource ( ) ; AlgorithmIdentifier pSourceAlgorithm = new AlgorithmIdentifier ( PKCSObjectIdentifiers . id _ pSpecified , new DEROctetString ( pSource . getValue ( ) ) ) ; RSAESOAEPparams oaepP = new RSAESOAEPparams ( hashAlgorithm , maskGenAlgorithm , pSourceAlgorithm ) ; try { return oaepP . getEncoded ( ASN _NUM Encoding . DER ) ; } catch ( IOException e ) { throw new RuntimeException ( _STR ) ; } } 
1006	 @ Override @ SuppressWarnings ( _STR + methodCall ) ; } methodSendQueue . send ( methodCall ) ; } 
1007	public static boolean isOverrideSet ( String propertyName ) { try { String p = fetchProperty ( propertyName ) ; if ( p ! = null ) { return _STR . equals ( Strings . toLowerCase ( p ) ) ; } return false ; } catch ( AccessControlException e ) { return false ; } } 
1008	private static void prepImportsList ( List < SymbolTable > importsList , IonReader reader , IonCatalog catalog ) { assert IMPORTS . equals ( reader . getFieldName ( ) ) ; reader . stepIn ( ) ; IonType t ; while ( ( t = reader . next ( ) ) ! = null ) { if ( ! reader . isNullValue ( ) & & t = = IonType . STRUCT ) { SymbolTable importedTable = readOneImport ( reader , catalog ) ; if ( importedTable ! = null ) { importsList . add ( importedTable ) ; } } } reader . stepOut ( ) ; } 
1009	public static void moveBottom ( JList list ) { int [ ] indices ; int diff ; if ( canMoveDown ( list ) ) { indices = list . getSelectedIndices ( ) ; diff = list . getModel ( ) . getSize ( ) - _NUM - indices [ indices . length - _NUM ] ; moveItems ( list , diff , MOVE _ DOWN ) ; } } 
1010	protected final synchronized boolean onResult ( @ NonNull final String permission , Permissions result ) { mPermissions . remove ( permission ) ; if ( result = = Permissions . GRANTED ) { if ( mPermissions . isEmpty ( ) ) { new Handler ( mLooper ) . post ( new Runnable ( ) { @ Override public void run ( ) { onGranted ( ) ; } } ) ; return true ; } } else if ( result = = Permissions . DENIED ) { new Handler ( mLooper ) . post ( new Runnable ( ) { @ Override public void run ( ) { onDenied ( permission ) ; } } ) ; return true ; } else if ( result = = Permissions . NOT _ FOUND ) { if ( shouldIgnorePermissionNotFound ( permission ) ) { if ( mPermissions . isEmpty ( ) ) { new Handler ( mLooper ) . post ( new Runnable ( ) { @ Override public void run ( ) { onGranted ( ) ; } } ) ; return true ; } } else { new Handler ( mLooper ) . post ( new Runnable ( ) { @ Override public void run ( ) { onDenied ( permission ) ; } } ) ; return true ; } } return false ; } 
1011	public void expectedMessagesMatches ( Predicate . . . predicates ) { for ( int i = _NUM ; i < predicates . length ; i + + ) { final int messageIndex = i ; final Predicate predicate = predicates [ i ] ; final AssertionClause clause = new AssertionClause ( this ) { public void run ( ) { addPredicate ( predicate ) ; applyAssertionOn ( MockEndpoint . this , messageIndex , assertExchangeReceived ( messageIndex ) ) ; } } ; expects ( clause ) ; } } 
1012	public static String graphNodeToString ( Node g ) { if ( g = = null ) return null ; if ( ! ( g . isURI ( ) | | g . isBlank ( ) ) ) throw new TextIndexException ( _STR + g ) ; return nodeToString ( g ) ; } 
1013	public void mkdir ( String dirName , int posixPermissions ) throws IOException { int req _ id = generateNextRequestID ( ) ; TypesWriter tw = new TypesWriter ( ) ; tw . writeString ( dirName , charsetName ) ; tw . writeUINT _NUM _NUM ( AttribFlags . SSH _ FILEXFER _ ATTR _ PERMISSIONS ) ; tw . writeUINT _NUM _NUM ( posixPermissions ) ; sendMessage ( Packet . SSH _ FXP _ MKDIR , req _ id , tw . getBytes ( ) ) ; expectStatusOKMessage ( req _ id ) ; } 
1014	public boolean hasChild ( int tag , int . . . tags ) throws InvalidAsn _NUM DataException { try { getChild ( tag , tags ) ; } catch ( TagNotFoundException e ) { return false ; } return true ; } 
1015	public void onInitEngine ( int status ) { if ( status = = TextToSpeech . SUCCESS ) { if ( DBG ) Log . d ( TAG , _STR ) ; updateWidgetState ( false ) ; } } 
1016	public static InetSocketAddress getServiceAddress ( Configuration conf , boolean fallback ) { String addr = conf . getTrimmed ( DFS _ NAMENODE _ SERVICE _ RPC _ ADDRESS _ KEY ) ; if ( addr = = null | | addr . isEmpty ( ) ) { return fallback ? getAddress ( conf ) : null ; } return getAddress ( addr ) ; } 
1017	private void addPackageParticipantsLocked ( String [ ] packageNames ) { Look for apps that define the android : backupAgent attribute List < PackageInfo > targetApps = allAgentPackages ( ) ; if ( packageNames ! = null ) { if ( MORE _ DEBUG ) Slog . v ( TAG , _STR ) ; addPackageParticipantsLockedInner ( null , targetApps ) ; } } 
1018	public SegmentTermEnum terms ( ) { return ( SegmentTermEnum ) origEnum . clone ( ) ; } 
1019	public String getInstructions ( String output ) { switch ( method ) { case RAND : return getRandInstructionCPSpark ( output ) ; case SINIT : return getSInitInstructionCPSpark ( output ) ; case SEQ : return getSeqInstructionCPSpark ( output ) ; case SAMPLE : return getSampleInstructionCPSpark ( output ) ; default : throw new LopsException ( _STR + method ) ; } } 
1020	public String getUnqualifiedLanguagePropertyValue ( String name , String expectedLanguage ) { String language = ( expectedLanguage ! = null ) ? expectedLanguage : XmpConstants . X _ DEFAULT ; AbstractField property = getAbstractProperty ( name ) ; if ( property ! = null ) { if ( property instanceof ArrayProperty ) { ArrayProperty arrayProp = ( ArrayProperty ) property ; for ( AbstractField child : arrayProp . getContainer ( ) . getAllProperties ( ) ) { Attribute text = child . getAttribute ( XmpConstants . LANG _ NAME ) ; if ( text ! = null & & text . getValue ( ) . equals ( language ) ) { return ( ( TextType ) child ) . getStringValue ( ) ; } } return null ; } else { throw new IllegalArgumentException ( _STR ) ; } } return null ; } 
1021	public void testInsertNormal ( ) { CmsJspNavElement a = dummyNav ( _STR ) ; printNav ( navs ) ; assertTrue ( checkIncreasing ( navs ) ) ; } 
1022	public IBarLineScatterCandleBubbleDataSet getDataSetByTouchPoint ( float x , float y ) { Highlight h = getHighlightByTouchPoint ( x , y ) ; if ( h ! = null ) { return mData . getDataSetByIndex ( h . getDataSetIndex ( ) ) ; } return null ; } 
1023	public void recalculatePermissibles ( ) { Set < Permissible > perms = getPermissibles ( ) ; Bukkit . getServer ( ) . getPluginManager ( ) . recalculatePermissionDefaults ( this ) ; for ( Permissible p : perms ) { p . recalculatePermissions ( ) ; } } 
1024	public boolean isFastScrollAlwaysVisible ( ) { if ( mFastScroll = = null ) { return mFastScrollEnabled & & mFastScrollAlwaysVisible ; } else { return mFastScroll . isEnabled ( ) & & mFastScroll . isAlwaysShowEnabled ( ) ; } } 
1025	public void mockEndpoints ( ) throws Exception { getContext ( ) . addRegisterEndpointCallback ( new InterceptSendToMockEndpointStrategy ( null ) ) ; } 
1026	public void install ( ) throws ProcessingUnitAlreadyDeployedException , CLIException { try { if ( agentZone = = null ) { throw new IllegalStateException ( _STR ) ; } } 
1027	public static SecuredProperty getInstance ( final SecuredModel securedModel , final Property property ) { if ( securedModel = = null ) { throw new IllegalArgumentException ( _STR ) ; } check that property has a securedModel . Property goodProp = property ; if ( goodProp . getModel ( ) = = null ) { final Node n = property . asNode ( ) ; if ( property . isAnon ( ) ) { goodProp = securedModel . createProperty ( n . getBlankNodeId ( ) . getLabelString ( ) ) ; } else { goodProp = securedModel . createProperty ( property . asNode ( ) . getURI ( ) ) ; } } final ItemHolder < Property , SecuredProperty > holder = new ItemHolder < > ( goodProp ) ; final SecuredPropertyImpl checker = new SecuredPropertyImpl ( securedModel , holder ) ; one . if ( goodProp instanceof SecuredProperty ) { if ( checker . isEquivalent ( ( SecuredProperty ) goodProp ) ) { return ( SecuredProperty ) goodProp ; } } return holder . setSecuredItem ( new SecuredItemInvoker ( property . getClass ( ) , checker ) ) ; } 
1028	public void initFromPage ( int valueCount , ByteBufferInputStream stream ) throws IOException { this . in = stream ; this . config = DeltaBinaryPackingConfig . readConfig ( in ) ; this . totalValueCount = BytesUtils . readUnsignedVarInt ( in ) ; allocateValuesBuffer ( ) ; bitWidths = new int [ config . miniBlockNumInABlock ] ; read first value from header valuesBuffer [ valuesBuffered + + ] = BytesUtils . readZigZagVarLong ( in ) ; while ( valuesBuffered < totalValueCount ) { values Buffered could be more than totalValueCount , since we flush on a mini block basis loadNewBlockToBuffer ( ) ; } } 
1029	public E element ( ) { return getFirst ( ) ; } 
1030	private static void postProcessSeq ( Path input , Path output ) throws IOException { ClusterOutputPostProcessor clusterOutputPostProcessor = new ClusterOutputPostProcessor ( input , output , new Configuration ( ) ) ; clusterOutputPostProcessor . process ( ) ; } 
1031	private int readAndCheckbytes ( Scanner scanner , int start , int n ) throws IOException { String value = _STR , Arrays . equals ( valStr . getBytes ( ) , val ) ) ; assertTrue ( scanner . advance ( ) ) ; } return ( start + n ) ; } 
1032	public String getPath ( String filename , String ext ) { check ( filename , ext ) ; if ( ext = = null ) return pathname + filename ; return pathname + filename + _STR + ext ; } 
1033	public boolean executeUpdate ( Document doc , String xpath , boolean forReal ) { org . dom _NUM j . Node node = doc . selectSingleNode ( xpath ) ; if ( ( node ! = null ) & & Objects . equal ( node . getText ( ) , m _ value ) ) { return false ; } CmsSetupXmlHelper . setValue ( doc , xpath , m _ value ) ; return true ; } 
1034	public void translate ( Vector vector ) { Matrix m = Matrix . getTranslateInstance ( vector . getX ( ) , vector . getY ( ) ) ; concatenate ( m ) ; } 
1035	public void loadResource ( CmsObject cms , CmsResource resource , HttpServletRequest req , HttpServletResponse res ) throws ServletException , IOException , CmsException { res . setContentType ( getMimeType ( resource . getName ( ) , cms . getRequestContext ( ) . getEncoding ( ) ) ) ; I _ CmsResourceLoader loader = getLoader ( resource ) ; loader . load ( cms , resource , req , res ) ; } 
1036	protected CommandReport processIdentity ( ResolvedKerberosPrincipal resolvedPrincipal , KerberosOperationHandler operationHandler , Map < String , String > kerberosConfiguration , Map < String , Object > requestSharedDataContext ) throws AmbariException { CommandReport commandReport = null ; if ( resolvedPrincipal ! = null & & StageUtils . getHostName ( ) . equals ( resolvedPrincipal . getHostName ( ) ) ) { final String hostName = resolvedPrincipal . getHostName ( ) ; final String dataDirectory = getDataDirectoryPath ( ) ; for ( Map . Entry < String , String > serviceMappingEntry : resolvedPrincipal . getServiceMapping ( ) . entries ( ) ) { TODO check if changes needed for multiple principals in one keytab if ( RootService . AMBARI . name ( ) . equals ( serviceMappingEntry . getKey ( ) ) ) { ResolvedKerberosKeytab keytab = resolvedPrincipal . getResolvedKerberosKeytab ( ) ; String destKeytabFilePath = resolvedPrincipal . getResolvedKerberosKeytab ( ) . getFile ( ) ; File hostDirectory = new File ( dataDirectory , hostName ) ; File srcKeytabFile = new File ( hostDirectory , DigestUtils . sha _NUM _NUM _NUM Hex ( destKeytabFilePath ) ) ; if ( srcKeytabFile . exists ( ) ) { String ownerAccess = keytab . getOwnerAccess ( ) ; String groupAccess = keytab . getGroupAccess ( ) ; installAmbariServerIdentity ( resolvedPrincipal , srcKeytabFile . getAbsolutePath ( ) , destKeytabFilePath , keytab . getOwnerName ( ) , ownerAccess , keytab . getGroupName ( ) , groupAccess , actionLog ) ; if ( serviceMappingEntry . getValue ( ) . contains ( _STR ) ) { Create / update the JAASFile . . . configureJAAS ( resolvedPrincipal . getPrincipal ( ) , destKeytabFilePath , actionLog ) ; } } } } } return commandReport ; } 
1037	public boolean canConsumeInteger ( IntConsumer consumer ) throws IllegalStateException { if ( completed ) throwNoMoreContent ( ) ; Get the value from the current token . . . String value = currentToken ( ) . value ( ) ; try { int result = Integer . parseInt ( value ) ; moveToNextToken ( ) ; consumer . accept ( result ) ; return true ; } catch ( NumberFormatException e ) { return false ; } } 
1038	protected Processor createLogger ( ) throws Exception { Processor answer ; setup a new logger here CamelLogger camelLogger ; LoggingLevel loggingLevel = LoggingLevel . INFO ; if ( level ! = null ) { loggingLevel = LoggingLevel . valueOf ( level ) ; } if ( providedLogger = = null ) { camelLogger = new CamelLogger ( loggerName , loggingLevel , getMarker ( ) ) ; } else { camelLogger = new CamelLogger ( providedLogger , loggingLevel , getMarker ( ) ) ; } if ( getGroupSize ( ) ! = null ) { answer = new ThroughputLogger ( camelLogger , getGroupSize ( ) ) ; } else if ( getGroupInterval ( ) ! = null ) { Boolean groupActiveOnly = getGroupActiveOnly ( ) ! = null ? getGroupActiveOnly ( ) : Boolean . TRUE ; Long groupDelay = getGroupDelay ( ) ; answer = new ThroughputLogger ( camelLogger , this . getCamelContext ( ) , getGroupInterval ( ) , groupDelay , groupActiveOnly ) ; } else { answer = new CamelLogProcessor ( camelLogger , localFormatter , getMaskingFormatter ( ) , getCamelContext ( ) . getLogListeners ( ) ) ; } the logger is the processor setProcessor ( answer ) ; return answer ; } 
1039	public static String clearCart ( HttpServletRequest request , HttpServletResponse response ) { ShoppingCart cart = getCartObject ( request ) ; cart . clear ( ) ; if this was an anonymous checkout process , go ahead and clear the session and such now that the order is placed ; we don ' t want this to mess up additional orders and such HttpSession session = request . getSession ( ) ; GenericValue userLogin = ( GenericValue ) session . getAttribute ( _STR ; } 
1040	public Response getConfiguration ( ) { return RestUtils . call ( new RestUtils . RestCallable < Map < String , String > > ( ) { @ Override public Map < String , String > call ( ) throws Exception { return getConfigurationInternal ( true ) ; } } ) ; } 
1041	public void shouldLoseTypesWithGraphSONNoTypesForVertexIds ( ) throws IOException { final GraphWriter writer = getWriter ( noTypesMapperV _NUM d _NUM ) ; final GraphReader reader = getReader ( noTypesMapperV _NUM d _NUM ) ; final TinkerGraph sampleGraph _NUM = TinkerGraph . open ( ) ; TinkerFactory . generateModern ( sampleGraph _NUM ) ; sampleGraph _NUM . addVertex ( T . id , _NUM _NUM _NUM L , _STR ) ; try ( final ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ) { writer . writeGraph ( out , sampleGraph _NUM ) ; final String json = out . toString ( ) ; final TinkerGraph read = TinkerGraph . open ( ) ; reader . readGraph ( new ByteArrayInputStream ( json . getBytes ( ) ) , read ) ; Should fail on deserialized vertex Id . assertFalse ( approximateGraphsCheck ( sampleGraph _NUM , read ) ) ; } } 
1042	public byte [ ] getData ( ) { if ( memoryOutputStream ! = null ) { return memoryOutputStream . toByteArray ( ) ; } return null ; } 
1043	public boolean shouldVibrate ( int vibrateType ) { final IAudioService service = getService ( ) ; try { return service . shouldVibrate ( vibrateType ) ; } catch ( RemoteException e ) { throw e . rethrowFromSystemServer ( ) ; } } 
1044	protected Hashtable createStandardAttributeTable ( Map parameters ) { Hashtable std = copyHashTable ( table ) ; if ( ! std . containsKey ( CMSAttributes . contentType ) ) { ASN _NUM ObjectIdentifier contentType = ASN _NUM ObjectIdentifier . getInstance ( parameters . get ( CMSAttributeTableGenerator . CONTENT _ TYPE ) ) ; contentType will be null if we ' re trying to generate a counter signature . if ( contentType ! = null ) { Attribute attr = new Attribute ( CMSAttributes . contentType , new DERSet ( contentType ) ) ; std . put ( attr . getAttrType ( ) , attr ) ; } } if ( ! std . containsKey ( CMSAttributes . signingTime ) ) { Date signingTime = new Date ( ) ; Attribute attr = new Attribute ( CMSAttributes . signingTime , new DERSet ( new Time ( signingTime ) ) ) ; std . put ( attr . getAttrType ( ) , attr ) ; } if ( ! std . containsKey ( CMSAttributes . messageDigest ) ) { byte [ ] messageDigest = ( byte [ ] ) parameters . get ( CMSAttributeTableGenerator . DIGEST ) ; Attribute attr = new Attribute ( CMSAttributes . messageDigest , new DERSet ( new DEROctetString ( messageDigest ) ) ) ; std . put ( attr . getAttrType ( ) , attr ) ; } if ( ! std . contains ( CMSAttributes . cmsAlgorithmProtect ) ) { Attribute attr = new Attribute ( CMSAttributes . cmsAlgorithmProtect , new DERSet ( new CMSAlgorithmProtection ( ( AlgorithmIdentifier ) parameters . get ( CMSAttributeTableGenerator . DIGEST _ ALGORITHM _ IDENTIFIER ) , CMSAlgorithmProtection . SIGNATURE , ( AlgorithmIdentifier ) parameters . get ( CMSAttributeTableGenerator . SIGNATURE _ ALGORITHM _ IDENTIFIER ) ) ) ) ; std . put ( attr . getAttrType ( ) , attr ) ; } return std ; } 
1045	protected Range findDomainBounds ( XYDataset dataset , boolean includeInterval ) { if ( dataset = = null ) { return null ; } if ( getDataBoundsIncludesVisibleSeriesOnly ( ) ) { List visibleSeriesKeys = new ArrayList ( ) ; int seriesCount = dataset . getSeriesCount ( ) ; for ( int s = _NUM ; s < seriesCount ; s + + ) { if ( isSeriesVisible ( s ) ) { visibleSeriesKeys . add ( dataset . getSeriesKey ( s ) ) ; } } return DatasetUtilities . findDomainBounds ( dataset , visibleSeriesKeys , includeInterval ) ; } else { return DatasetUtilities . findDomainBounds ( dataset , includeInterval ) ; } } 
1046	public void drawItem ( Graphics _NUM D g _NUM , CategoryItemRendererState state , Rectangle _NUM D dataArea , CategoryPlot plot , CategoryAxis domainAxis , ValueAxis rangeAxis , CategoryDataset dataset , int row , int column , int pass ) { nothing is drawn for null values . . . Number dataValue = dataset . getValue ( row , column ) ; if ( dataValue = = null ) { return ; } double value = dataValue . doubleValue ( ) ; Comparable group = this . seriesToGroupMap . getGroup ( dataset . getRowKey ( row ) ) ; PlotOrientation orientation = plot . getOrientation ( ) ; double barW _NUM = calculateBarW _NUM ( plot , orientation , dataArea , domainAxis , state , row , column ) ; double positiveBase = _NUM . _NUM ; double negativeBase = _NUM . _NUM ; for ( int i = _NUM ; i < row ; i + + ) { if ( group . equals ( this . seriesToGroupMap . getGroup ( dataset . getRowKey ( i ) ) ) ) { Number v = dataset . getValue ( i , column ) ; if ( v ! = null ) { double d = v . doubleValue ( ) ; if ( d > _NUM ) { positiveBase = positiveBase + d ; } else { negativeBase = negativeBase + d ; } } } } double translatedBase ; double translatedValue ; boolean positive = ( value > _NUM . _NUM ) ; boolean inverted = rangeAxis . isInverted ( ) ; RectangleEdge barBase ; if ( orientation = = PlotOrientation . HORIZONTAL ) { if ( positive & & inverted | | ! positive & & ! inverted ) { barBase = RectangleEdge . RIGHT ; } else { barBase = RectangleEdge . LEFT ; } } else { if ( positive & & ! inverted | | ! positive & & inverted ) { barBase = RectangleEdge . BOTTOM ; } else { barBase = RectangleEdge . TOP ; } } RectangleEdge location = plot . getRangeAxisEdge ( ) ; if ( value > _NUM . _NUM ) { translatedBase = rangeAxis . valueToJava _NUM D ( positiveBase , dataArea , location ) ; translatedValue = rangeAxis . valueToJava _NUM D ( positiveBase + value , dataArea , location ) ; } else { translatedBase = rangeAxis . valueToJava _NUM D ( negativeBase , dataArea , location ) ; translatedValue = rangeAxis . valueToJava _NUM D ( negativeBase + value , dataArea , location ) ; } double barL _NUM = Math . min ( translatedBase , translatedValue ) ; double barLength = Math . max ( Math . abs ( translatedValue - translatedBase ) , getMinimumBarLength ( ) ) ; Rectangle _NUM D bar = null ; if ( orientation = = PlotOrientation . HORIZONTAL ) { bar = new Rectangle _NUM D . Double ( barL _NUM , barW _NUM , barLength , state . getBarWidth ( ) ) ; } else { bar = new Rectangle _NUM D . Double ( barW _NUM , barL _NUM , state . getBarWidth ( ) , barLength ) ; } getBarPainter ( ) . paintBar ( g _NUM , this , row , column , bar , barBase ) ; CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ; if ( generator ! = null & & isItemLabelVisible ( row , column ) ) { drawItemLabel ( g _NUM , dataset , row , column , plot , generator , bar , ( value < _NUM . _NUM ) ) ; } collect entity and tool tip information . . . if ( state . getInfo ( ) ! = null ) { EntityCollection entities = state . getEntityCollection ( ) ; if ( entities ! = null ) { addItemEntity ( entities , dataset , row , column , bar ) ; } } } 
1047	public static ExceptionWithContext withContext ( Throwable ex , String str ) { ExceptionWithContext ewc ; if ( ex instanceof ExceptionWithContext ) { ewc = ( ExceptionWithContext ) ex ; } else { ewc = new ExceptionWithContext ( ex ) ; } ewc . addContext ( str ) ; return ewc ; } 
1048	public void setSectionProperty ( String sectionName , String propertyName , String propertyValue ) { String name = cleanName ( sectionName ) ; Section section = getSection ( name ) ; if ( section = = null ) { section = addSection ( name ) ; } section . put ( propertyName , propertyValue ) ; } 
1049	protected String resolvePort ( Cluster cluster , String hostname , String componentName , Map < String , String > metricsProperties , String protocol ) throws AmbariException { String portConfigType = null ; String portPropertyNameInMetricsProperties = protocol . equalsIgnoreCase ( HTTPS _ PROTOCOL ) ? HTTPS _ PORT _ PROPERTY _ NAME _ PROPERTY : PORT _ PROPERTY _ NAME _ PROPERTY ; String portPropertyName = null ; if ( metricsProperties . containsKey ( PORT _ CONFIG _ TYPE _ PROPERTY ) & & metricsProperties . containsKey ( portPropertyNameInMetricsProperties ) ) { portConfigType = metricsProperties . get ( PORT _ CONFIG _ TYPE _ PROPERTY ) ; portPropertyName = metricsProperties . get ( portPropertyNameInMetricsProperties ) ; } String portStr = getPropertyValueByNameAndConfigType ( portPropertyName , portConfigType , cluster , hostname ) ; if ( portStr = = null & & metricsProperties . containsKey ( DEFAULT _ PORT _ PROPERTY ) ) { if ( metricsProperties . containsKey ( DEFAULT _ PORT _ PROPERTY ) ) { portStr = metricsProperties . get ( DEFAULT _ PORT _ PROPERTY ) ; } else { String message = String . format ( _STR , componentName , DEFAULT _ PORT _ PROPERTY ) ; throw new AmbariException ( message ) ; } } return portStr ; } 
1050	public BasicKeyChain toEncrypted ( KeyCrypter keyCrypter , KeyParameter aesKey ) { lock . lock ( ) ; try { checkNotNull ( keyCrypter ) ; checkState ( this . keyCrypter = = null , _STR ) ; encrypted . importKeyLocked ( encryptedKey ) ; } return encrypted ; } finally { lock . unlock ( ) ; } } 
1051	public void buildClassifier ( Instances data ) throws Exception { super . buildClassifier ( data ) ; can classifier handle the data ? getCapabilities ( ) . testWithFail ( data ) ; remove instances with missing class Instances newData = new Instances ( data ) ; newData . deleteWithMissingClass ( ) ; double sum = _NUM ; double temp _ sum = _NUM ; Add the model for the mean first m _ zeroR = new ZeroR ( ) ; m _ zeroR . buildClassifier ( newData ) ; only class ? - > use only ZeroR model if ( newData . numAttributes ( ) = = _NUM ) { System . err . println ( _STR + sum ) ; } m _ NumIterationsPerformed + + ; } while ( ( ( temp _ sum - sum ) > Utils . SMALL ) & & ( m _ NumIterationsPerformed < m _ Classifiers . length ) ) ; } 
1052	public static boolean isConnected ( Context context ) { return ! Reddit . appRestart . contains ( _STR ) & & getConnectivityStatus ( context ) ! = Status . NONE ; } 
1053	void run ( ) throws QueryException , IOException { try { parseArgs ( ) ; } catch ( final IOException ex ) { Util . errln ( ex ) ; System . exit ( _NUM ) ; } if ( ! new IOFile ( path ) . isAbsolute ( ) ) path = new IOFile ( _STR + time ) ; context . close ( ) ; sandbox ( ) . delete ( ) ; } 
1054	public void setXindex ( int x ) { m _ xIndex = x ; for ( int i = _NUM ; i < m _ plots . size ( ) ; i + + ) { ( ( PlotData _NUM D ) m _ plots . elementAt ( i ) ) . setXindex ( m _ xIndex ) ; } determineBounds ( ) ; if ( m _ JitterVal ! = _NUM ) { updatePturb ( ) ; } m _ axisChanged = true ; this . repaint ( ) ; } 
1055	Set < BTraceMethodNode > callers ( String name , String desc ) { Set < String > closure = new HashSet < > ( ) ; graph . callers ( name , desc , closure ) ; return fromIdSet ( closure ) ; } 
1056	protected void defineWidgets ( ) { initialize the user object to use for the dialog initGroupObject ( ) ; setKeyPrefix ( KEY _ PREFIX ) ; widgets to display if ( ! isOverview ( ) ) { addWidget ( new CmsWidgetDialogParameter ( this , _STR , PAGES [ _NUM ] , new CmsDisplayWidget ( ) ) ) ; } } 
1057	String listStatus ( String path ) throws IOException { StringBuilder sb = new StringBuilder ( ) ; ObjectMapper mapper = new ObjectMapper ( ) ; List < Map < String , Object > > fileStatusList = getFileStatusList ( path ) ; sb . append ( _STR ) ; return sb . toString ( ) ; } 
1058	public static String searchExportProductList ( HttpServletRequest request , HttpServletResponse response ) { Delegator delegator = ( Delegator ) request . getAttribute ( _STR ; } 
1059	public static void flakyTest ( Runnable test , int rerunsOnFailure , String message ) { AssertionError e = runCatchingAssertionError ( test ) ; if ( e = = null ) success return ; logger . info ( _STR ) ; } 
1060	public void testVerifyListReplicatedTable ( ) throws Exception { LOG . info ( _STR + i , ( match [ i ] = = _NUM ) ) ; } drop tables for ( int i = _NUM ; i < numOfTables ; i + + ) { TableName tableName = TableName . valueOf ( tName + i ) ; hadmin . disableTable ( tableName ) ; hadmin . deleteTable ( tableName ) ; } hadmin . close ( ) ; } 
1061	public void validateSignatureWithDigestAlgorithm ( ) { query ( _STR , true ) ; } 
1062	private void compactIfNecessary ( ) { if ( ! mCompacted ) { if ( mDepth ! = _NUM ) { throw new IllegalArgumentException ( _STR ) ; } The buffer must be compacted . mBuffer . startEditing ( ) ; final int readableSize = mBuffer . getReadableSize ( ) ; Cache the sizes of the objects editEncodedSize ( readableSize ) ; Re - write the buffer with the sizes as proper varints instead of pairs of uint _NUM _NUM s . We know this will always fit in the same buffer because the pair of uint _NUM _NUM s is exactly _NUM bytes long , and the single varint size will be no more than _NUM bytes long . mBuffer . rewindRead ( ) ; compactSizes ( readableSize ) ; If there is any data left over that wasn ' t copied yet , copy it . if ( mCopyBegin < readableSize ) { mBuffer . writeFromThisBuffer ( mCopyBegin , readableSize - mCopyBegin ) ; } Set the new readableSize mBuffer . startEditing ( ) ; It ' s not valid to write to this object anymore . The write pointers are off , and then some of the data would be compacted and some not . mCompacted = true ; } } 
1063	private void verticalScrollToFieldValue ( int field , int fieldValue , int [ ] columnIndices , DatePicker pickerView , int scrollDir ) throws Throwable { int columnIndex = getColumnIndexForDateField ( field , columnIndices ) ; int colDayIndex = columnIndices [ _NUM ] ; int colMonthIndex = columnIndices [ _NUM ] ; int colYearIndex = columnIndices [ _NUM ] ; horizontalScrollToDateField ( field , columnIndices , pickerView ) ; Calendar currentActionCal = Calendar . getInstance ( ) ; currentActionCal . setTimeInMillis ( pickerView . getDate ( ) ) ; Calendar minCal = Calendar . getInstance ( ) ; minCal . setTimeInMillis ( pickerView . getMinDate ( ) ) ; Calendar maxCal = Calendar . getInstance ( ) ; maxCal . setTimeInMillis ( pickerView . getMaxDate ( ) ) ; int prevColumnVal = - _NUM ; int currentColumnVal = pickerView . getColumnAt ( columnIndex ) . getCurrentValue ( ) ; while ( currentColumnVal ! = prevColumnVal & & currentColumnVal ! = fieldValue ) { assertTrue ( mContext . getString ( R . string . datepicker _ test _ wrong _ day _ value ) , pickerView . getColumnAt ( colDayIndex ) . getCurrentValue ( ) = = currentActionCal . get ( Calendar . DAY _ OF _ MONTH ) ) ; assertTrue ( mContext . getString ( R . string . datepicker _ test _ wrong _ month _ value ) , pickerView . getColumnAt ( colMonthIndex ) . getCurrentValue ( ) = = currentActionCal . get ( Calendar . MONTH ) ) ; assertTrue ( mContext . getString ( R . string . datepicker _ test _ wrong _ year _ value ) , pickerView . getColumnAt ( colYearIndex ) . getCurrentValue ( ) = = currentActionCal . get ( Calendar . YEAR ) ) ; int offset = scrollDir = = KeyEvent . KEYCODE _ DPAD _ DOWN ? _NUM : - _NUM ; addDate ( currentActionCal , field , offset , minCal , maxCal ) ; sendKey ( scrollDir ) ; Thread . sleep ( VERTICAL _ SCROLL _ WAIT ) ; prevColumnVal = currentColumnVal ; currentColumnVal = pickerView . getColumnAt ( columnIndex ) . getCurrentValue ( ) ; } } 
1064	public XmlError getError ( ) { if ( _ errors = = null | | _ errors . size ( ) = = _NUM ) return null ; return ( XmlError ) _ errors . get ( _NUM ) ; } 
1065	public int getSubscriptionId ( ) { final int subId = ( mSubId = = DEFAULT _ SUBSCRIPTION _ ID ) ? getDefaultSmsSubscriptionId ( ) : mSubId ; boolean isSmsSimPickActivityNeeded = false ; final Context context = ActivityThread . currentApplication ( ) . getApplicationContext ( ) ; try { ISms iccISms = getISmsService ( ) ; if ( iccISms ! = null ) { isSmsSimPickActivityNeeded = iccISms . isSmsSimPickActivityNeeded ( subId ) ; } } catch ( RemoteException ex ) { Log . e ( TAG , _STR ) ; } } return subId ; } 
1066	public static RowsBuilder of ( final Object . . . args ) { RowType beamSQLRowType = buildBeamSqlRowType ( args ) ; RowsBuilder builder = new RowsBuilder ( ) ; builder . type = beamSQLRowType ; return builder ; } 
1067	public void enableSessionValidation ( ) { if ( log . isDebugEnabled ( ) ) { log . debug ( _STR , e ) ; } } } 
1068	public void testFullRestoreMultipleCommand ( ) throws Exception { LOG . info ( _STR ) } ; Run backup int ret = ToolRunner . run ( conf _NUM , new RestoreDriver ( ) , args ) ; assertTrue ( ret = = _NUM ) ; HBaseAdmin hba = TEST _ UTIL . getHBaseAdmin ( ) ; assertTrue ( hba . tableExists ( table _NUM _ restore ) ) ; assertTrue ( hba . tableExists ( table _NUM _ restore ) ) ; TEST _ UTIL . deleteTable ( table _NUM _ restore ) ; TEST _ UTIL . deleteTable ( table _NUM _ restore ) ; hba . close ( ) ; } 
1069	public void deleteClusterFile ( ) { deleteMinimesosFile ( ) ; } 
1070	public void bulkDeleteCorrectness _NUM ( ) { for ( int k = _NUM ; k < ITER ; + + k ) { setUp ( ) ; int n = baseid + _NUM ; for ( int i = _NUM ; i < opcount ; + + i ) { final int c = RANDOM . nextInt ( BULK ) + _NUM ; insert ( RANDOM . nextInt ( n ) , n , c ) ; check ( ) ; n + = c ; } check ( ) ; while ( n > _NUM ) { final int pre = RANDOM . nextInt ( n ) ; we don ' t want to delete more records than already exist : final int c = - Math . min ( n - pre , RANDOM . nextInt ( BULK ) + _NUM ) ; try { delete ( pre , c ) ; check ( ) ; } catch ( final ArrayIndexOutOfBoundsException ex ) { dump ( ) ; throw ex ; } n + = c ; } } } 
1071	protected PublicKey engineGeneratePublic ( KeySpec keySpec ) throws InvalidKeySpecException { if ( keySpec instanceof X _NUM _NUM _NUM EncodedKeySpec ) { get the DER - encoded Key according to X . _NUM _NUM _NUM from the spec byte [ ] encKey = ( ( X _NUM _NUM _NUM EncodedKeySpec ) keySpec ) . getEncoded ( ) ; decode the SubjectPublicKeyInfo data structure to the pki object SubjectPublicKeyInfo pki ; try { pki = SubjectPublicKeyInfo . getInstance ( ASN _NUM Primitive . fromByteArray ( encKey ) ) ; } catch ( IOException e ) { throw new InvalidKeySpecException ( e . toString ( ) ) ; } try { if ( PQCObjectIdentifiers . mcEliece . equals ( pki . getAlgorithm ( ) . getAlgorithm ( ) ) ) { McEliecePublicKey key = McEliecePublicKey . getInstance ( pki . parsePublicKey ( ) ) ; return new BCMcEliecePublicKey ( new McEliecePublicKeyParameters ( key . getN ( ) , key . getT ( ) , key . getG ( ) ) ) ; } else { throw new InvalidKeySpecException ( _STR ) ; } 
1072	public void onLocationChanged ( Location location ) { synchronized ( mLock ) { if ( mReceivingLocationUpdates ) { mLastLocationUpdate = location ; } case the caller is holding a wakelock . if ( mPendingUpdate ) { mHandler . removeMessages ( MSG _ UPDATE _ FENCES ) ; } else { mPendingUpdate = true ; } } updateFences ( ) ; } 
1073	public void testNewEpochZxidWithTxnlogOnly ( ) throws Exception { long peerZxid ; db . txnLog . add ( createProposal ( getZxid ( _NUM , _NUM ) ) ) ; db . txnLog . add ( createProposal ( getZxid ( _NUM , _NUM ) ) ) ; db . txnLog . add ( createProposal ( getZxid ( _NUM , _NUM ) ) ) ; db . txnLog . add ( createProposal ( getZxid ( _NUM , _NUM ) ) ) ; After leader election , lastProcessedZxid will point to new epoch db . lastProcessedZxid = getZxid ( _NUM , _NUM ) ; Peer has zxid of epoch _NUM peerZxid = getZxid ( _NUM , _NUM ) ; assertFalse ( learnerHandler . syncFollower ( peerZxid , db , leader ) ) ; We send DIFF to ( _NUM , _NUM ) and forward any packet starting at ( _NUM , _NUM ) assertOpType ( Leader . DIFF , getZxid ( _NUM , _NUM ) , getZxid ( _NUM , _NUM ) ) ; DIFF + _NUM proposals + _NUM commit assertEquals ( _NUM , learnerHandler . getQueuedPackets ( ) . size ( ) ) ; queuedPacketMatches ( new long [ ] { getZxid ( _NUM , _NUM ) } ) ; reset ( ) ; Peer has zxid of epoch _NUM peerZxid = getZxid ( _NUM , _NUM ) ; assertFalse ( learnerHandler . syncFollower ( peerZxid , db , leader ) ) ; We send DIFF to ( _NUM , _NUM ) and forward any packet starting at ( _NUM , _NUM ) assertOpType ( Leader . DIFF , getZxid ( _NUM , _NUM ) , getZxid ( _NUM , _NUM ) ) ; DIFF + _NUM proposals + _NUM commit assertEquals ( _NUM , learnerHandler . getQueuedPackets ( ) . size ( ) ) ; queuedPacketMatches ( new long [ ] { getZxid ( _NUM , _NUM ) } ) ; reset ( ) ; Peer has zxid of epoch _NUM peerZxid = getZxid ( _NUM , _NUM ) ; assertFalse ( learnerHandler . syncFollower ( peerZxid , db , leader ) ) ; We send DIFF to ( _NUM , _NUM ) and forward any packet starting at ( _NUM , _NUM ) assertOpType ( Leader . DIFF , getZxid ( _NUM , _NUM ) , getZxid ( _NUM , _NUM ) ) ; DIFF only assertEquals ( _NUM , learnerHandler . getQueuedPackets ( ) . size ( ) ) ; reset ( ) ; Peer has zxid of epoch _NUM peerZxid = getZxid ( _NUM , _NUM ) ; assertFalse ( learnerHandler . syncFollower ( peerZxid , db , leader ) ) ; We send DIFF to ( _NUM , _NUM ) and forward any packet starting at ( _NUM , _NUM ) assertOpType ( Leader . DIFF , getZxid ( _NUM , _NUM ) , getZxid ( _NUM , _NUM ) ) ; DIFF only assertEquals ( _NUM , learnerHandler . getQueuedPackets ( ) . size ( ) ) ; reset ( ) ; } 
1074	public final void update ( final int pre , final int kind , final byte [ ] name , final byte [ ] uri ) { meta . update ( ) ; if ( kind = = PI ) { updateText ( pre , trim ( concat ( name , SPACE , atom ( pre ) ) ) , PI ) ; } else { check if namespace has changed final byte [ ] prefix = prefix ( name ) ; final int oldUriId = nspaces . uriIdForPrefix ( prefix , pre , this ) ; final boolean nsFlag = oldUriId = = _NUM & & uri . length ! = _NUM & & ! eq ( prefix , XML ) ; final int nsPre = kind = = ATTR ? parent ( pre , kind ) : pre ; final int uriId = nsFlag ? nspaces . add ( nsPre , prefix , uri , this ) : oldUriId ! = _NUM & & eq ( nspaces . uri ( oldUriId ) , uri ) ? oldUriId : _NUM ; final int size = size ( pre , kind ) ; write ids of namespace uri and name , and namespace flag if ( kind = = ATTR ) { delete old values from attribute indexes if ( meta . updindex ) { if ( meta . attrindex ) attrIndex . delete ( new ValueCache ( pre , IndexType . ATTRIBUTE , this ) ) ; if ( meta . tokenindex ) tokenIndex . delete ( new ValueCache ( pre , IndexType . TOKEN , this ) ) ; } table . write _NUM ( pre , _NUM _NUM , uriId ) ; table . write _NUM ( pre , _NUM , attrNames . put ( name ) ) ; if ( nsFlag ) table . write _NUM ( nsPre , _NUM , _NUM < < _NUM _NUM | nameId ( nsPre ) ) ; add new values to attribute indexes if ( meta . updindex ) { if ( meta . attrindex ) attrIndex . add ( new ValueCache ( pre , IndexType . ATTRIBUTE , this ) ) ; if ( meta . tokenindex ) tokenIndex . add ( new ValueCache ( pre , IndexType . TOKEN , this ) ) ; } } else { update element name final IntList pres = new IntList ( ) ; update text index if ( meta . updindex & & meta . textindex ) { final int last = pre + size ; for ( int curr = pre + attSize ( pre , kind ) ; curr < last ; curr + = size ( curr , kind ( curr ) ) ) { if ( kind ( curr ) = = TEXT ) pres . add ( curr ) ; } textIndex . delete ( new ValueCache ( pres , IndexType . TEXT , this ) ) ; } table . write _NUM ( pre , _NUM , uriId ) ; final int nameId = elemNames . put ( name ) ; table . write _NUM ( nsPre , _NUM , ( nsFlag | | nsFlag ( nsPre ) ? _NUM < < _NUM _NUM : _NUM ) | nameId ) ; if ( ! pres . isEmpty ( ) ) textIndex . add ( new ValueCache ( pres , IndexType . TEXT , this ) ) ; } } } 
1075	public static void writeHeader ( FileChannel fc , int version , boolean verify ) throws IOException { LogHeader header = LogHeader . newBuilder ( ) . setVersion ( version ) . setVerifyChecksum ( verify ) . build ( ) ; ByteBuffer buf = getByteBufferWithMetaData ( header ) ; safeWrite ( fc , buf ) ; fc . force ( true ) ; } 
1076	public static List < EventLog > getAllEventLogsForSuite ( String suiteName ) { List < EventLog > suiteEventLogs = new ArrayList < > ( ) ; for ( EventLog eventLog : eventLogs ) { if ( belongsToSuite ( suiteName , eventLog ) ) { suiteEventLogs . add ( eventLog ) ; } } return suiteEventLogs ; } 
1077	public boolean isInCall ( ) { try { if ( isServiceConnected ( ) ) { return getTelecomService ( ) . isInCall ( mContext . getOpPackageName ( ) ) ; } } catch ( RemoteException e ) { Log . e ( TAG , _STR , e ) ; } return false ; } 
1078	void measureVertical ( int widthMeasureSpec , int heightMeasureSpec ) { mTotalLength = _NUM ; int maxWidth = _NUM ; int childState = _NUM ; int alternativeMaxWidth = _NUM ; int weightedMaxWidth = _NUM ; boolean allFillParent = true ; float totalWeight = _NUM ; final int count = getVirtualChildCount ( ) ; final int widthMode = MeasureSpec . getMode ( widthMeasureSpec ) ; final int heightMode = MeasureSpec . getMode ( heightMeasureSpec ) ; boolean matchWidth = false ; boolean skippedMeasure = false ; final int baselineChildIndex = mBaselineAlignedChildIndex ; final boolean useLargestChild = mUseLargestChild ; int largestChildHeight = Integer . MIN _ VALUE ; See how tall everyone is . Also remember max width . for ( int i = _NUM ; i < count ; + + i ) { final View child = getVirtualChildAt ( i ) ; if ( child = = null ) { mTotalLength + = measureNullChild ( i ) ; continue ; } if ( child . getVisibility ( ) = = View . GONE ) { i + = getChildrenSkipCount ( child , i ) ; continue ; } if ( hasDividerBeforeChildAt ( i ) ) { mTotalLength + = mDividerHeight ; } LayoutParams lp = ( LayoutParams ) child . getLayoutParams ( ) ; totalWeight + = lp . weight ; if ( heightMode = = MeasureSpec . EXACTLY & & lp . height = = _NUM & & lp . weight > _NUM ) { Optimization : don ' t bother measuring children who are going to use leftover space . These views will get measured again down below if there is any leftover space . final int totalLength = mTotalLength ; mTotalLength = Math . max ( totalLength , totalLength + lp . topMargin + lp . bottomMargin ) ; skippedMeasure = true ; } else { int oldHeight = Integer . MIN _ VALUE ; if ( lp . height = = _NUM & & lp . weight > _NUM ) { heightMode is either UNSPECIFIED or AT _ MOST , and this child wanted to stretch to fill available space . Translate that to WRAP _ CONTENT so that it does not end up with a height of _NUM oldHeight = _NUM ; lp . height = LayoutParams . WRAP _ CONTENT ; } Determine how big this child would like to be . If this or previous children have given a weight , then we allow it to use all available space ( and we will shrink things later if needed ) . measureChildBeforeLayout ( child , i , widthMeasureSpec , _NUM , heightMeasureSpec , totalWeight = = _NUM ? mTotalLength : _NUM ) ; if ( oldHeight ! = Integer . MIN _ VALUE ) { lp . height = oldHeight ; } final int childHeight = child . getMeasuredHeight ( ) ; final int totalLength = mTotalLength ; mTotalLength = Math . max ( totalLength , totalLength + childHeight + lp . topMargin + lp . bottomMargin + getNextLocationOffset ( child ) ) ; if ( useLargestChild ) { largestChildHeight = Math . max ( childHeight , largestChildHeight ) ; } } if ( ( baselineChildIndex > = _NUM ) & & ( baselineChildIndex = = i + _NUM ) ) { mBaselineChildTop = mTotalLength ; } weight . fail fast to aid the developer . if ( i < baselineChildIndex & & lp . weight > _NUM ) { throw new RuntimeException ( _STR ) ; } boolean matchWidthLocally = false ; if ( widthMode ! = MeasureSpec . EXACTLY & & lp . width = = LayoutParams . MATCH _ PARENT ) { The width of the linear layout will scale , and at least one child said it wanted to match our width . Set a flag indicating that we need to remeasure at least that view when we know our width . matchWidth = true ; matchWidthLocally = true ; } final int margin = lp . leftMargin + lp . rightMargin ; final int measuredWidth = child . getMeasuredWidth ( ) + margin ; maxWidth = Math . max ( maxWidth , measuredWidth ) ; childState = combineMeasuredStates ( childState , child . getMeasuredState ( ) ) ; allFillParent = allFillParent & & lp . width = = LayoutParams . MATCH _ PARENT ; if ( lp . weight > _NUM ) { weightedMaxWidth = Math . max ( weightedMaxWidth , matchWidthLocally ? margin : measuredWidth ) ; } else { alternativeMaxWidth = Math . max ( alternativeMaxWidth , matchWidthLocally ? margin : measuredWidth ) ; } i + = getChildrenSkipCount ( child , i ) ; } if ( mTotalLength > _NUM & & hasDividerBeforeChildAt ( count ) ) { mTotalLength + = mDividerHeight ; } if ( useLargestChild & & ( heightMode = = MeasureSpec . AT _ MOST | | heightMode = = MeasureSpec . UNSPECIFIED ) ) { mTotalLength = _NUM ; for ( int i = _NUM ; i < count ; + + i ) { final View child = getVirtualChildAt ( i ) ; if ( child = = null ) { mTotalLength + = measureNullChild ( i ) ; continue ; } if ( child . getVisibility ( ) = = GONE ) { i + = getChildrenSkipCount ( child , i ) ; continue ; } final LayoutParams lp = ( LayoutParams ) child . getLayoutParams ( ) ; Account for negative margins final int totalLength = mTotalLength ; mTotalLength = Math . max ( totalLength , totalLength + largestChildHeight + lp . topMargin + lp . bottomMargin + getNextLocationOffset ( child ) ) ; } } Add in our padding mTotalLength + = mPaddingTop + mPaddingBottom ; int heightSize = mTotalLength ; Check against our minimum height heightSize = Math . max ( heightSize , getSuggestedMinimumHeight ( ) ) ; Reconcile our calculated size with the heightMeasureSpec int heightSizeAndState = resolveSizeAndState ( heightSize , heightMeasureSpec , _NUM ) ; heightSize = heightSizeAndState & MEASURED _ SIZE _ MASK ; Either expand children with weight to take up available space or shrink them if they extend beyond our current bounds . If we skipped measurement on any children , we need to measure them now . int delta = heightSize - mTotalLength ; if ( skippedMeasure | | delta ! = _NUM & & totalWeight > _NUM . _NUM f ) { float weightSum = mWeightSum > _NUM . _NUM f ? mWeightSum : totalWeight ; mTotalLength = _NUM ; for ( int i = _NUM ; i < count ; + + i ) { final View child = getVirtualChildAt ( i ) ; if ( child . getVisibility ( ) = = View . GONE ) { continue ; } LayoutParams lp = ( LayoutParams ) child . getLayoutParams ( ) ; float childExtra = lp . weight ; MatchParentShrinkingLinearLayout custom code starts here . if ( childExtra > _NUM & & delta > _NUM ) { Child said it could absorb extra space - - give him his share int share = ( int ) ( childExtra * delta / weightSum ) ; weightSum - = childExtra ; delta - = share ; final int childWidthMeasureSpec = getChildMeasureSpec ( widthMeasureSpec , mPaddingLeft + mPaddingRight + lp . leftMargin + lp . rightMargin , lp . width ) ; child has been previously measured if ( ( lp . height ! = _NUM ) | | ( heightMode ! = MeasureSpec . EXACTLY ) ) { child was measured once already above . . . base new measurement on stored values int childHeight = child . getMeasuredHeight ( ) + share ; if ( childHeight < _NUM ) { childHeight = _NUM ; } child . measure ( childWidthMeasureSpec , MeasureSpec . makeMeasureSpec ( childHeight , MeasureSpec . EXACTLY ) ) ; } else { child was skipped in the loop above . Measure for this first time here child . measure ( childWidthMeasureSpec , MeasureSpec . makeMeasureSpec ( share > _NUM ? share : _NUM , MeasureSpec . EXACTLY ) ) ; } Child may now not fit in vertical dimension . childState = combineMeasuredStates ( childState , child . getMeasuredState ( ) & ( MEASURED _ STATE _ MASK > > MEASURED _ HEIGHT _ STATE _ SHIFT ) ) ; } else if ( delta < _NUM & & lp . height = = LayoutParams . MATCH _ PARENT ) { final int childWidthMeasureSpec = getChildMeasureSpec ( widthMeasureSpec , mPaddingLeft + mPaddingRight + lp . leftMargin + lp . rightMargin , lp . width ) ; int childHeight = child . getMeasuredHeight ( ) + delta ; if ( childHeight < _NUM ) { childHeight = _NUM ; } delta - = childHeight - child . getMeasuredHeight ( ) ; child . measure ( childWidthMeasureSpec , MeasureSpec . makeMeasureSpec ( childHeight , MeasureSpec . EXACTLY ) ) ; Child may now not fit in vertical dimension . childState = combineMeasuredStates ( childState , child . getMeasuredState ( ) & ( MEASURED _ STATE _ MASK > > MEASURED _ HEIGHT _ STATE _ SHIFT ) ) ; } MatchParentShrinkingLinearLayout custom code ends here . final int margin = lp . leftMargin + lp . rightMargin ; final int measuredWidth = child . getMeasuredWidth ( ) + margin ; maxWidth = Math . max ( maxWidth , measuredWidth ) ; boolean matchWidthLocally = widthMode ! = MeasureSpec . EXACTLY & & lp . width = = LayoutParams . MATCH _ PARENT ; alternativeMaxWidth = Math . max ( alternativeMaxWidth , matchWidthLocally ? margin : measuredWidth ) ; allFillParent = allFillParent & & lp . width = = LayoutParams . MATCH _ PARENT ; final int totalLength = mTotalLength ; mTotalLength = Math . max ( totalLength , totalLength + child . getMeasuredHeight ( ) + lp . topMargin + lp . bottomMargin + getNextLocationOffset ( child ) ) ; } Add in our padding mTotalLength + = mPaddingTop + mPaddingBottom ; TODO : Should we recompute the heightSpec based on the new total length ? } else { alternativeMaxWidth = Math . max ( alternativeMaxWidth , weightedMaxWidth ) ; Children will have already been measured once . if ( useLargestChild & & heightMode ! = MeasureSpec . EXACTLY ) { for ( int i = _NUM ; i < count ; i + + ) { final View child = getVirtualChildAt ( i ) ; if ( child = = null | | child . getVisibility ( ) = = View . GONE ) { continue ; } final LayoutParams lp = ( LayoutParams ) child . getLayoutParams ( ) ; float childExtra = lp . weight ; if ( childExtra > _NUM ) { child . measure ( MeasureSpec . makeMeasureSpec ( child . getMeasuredWidth ( ) , MeasureSpec . EXACTLY ) , MeasureSpec . makeMeasureSpec ( largestChildHeight , MeasureSpec . EXACTLY ) ) ; } } } } if ( ! allFillParent & & widthMode ! = MeasureSpec . EXACTLY ) { maxWidth = alternativeMaxWidth ; } maxWidth + = mPaddingLeft + mPaddingRight ; Check against our minimum width maxWidth = Math . max ( maxWidth , getSuggestedMinimumWidth ( ) ) ; setMeasuredDimension ( resolveSizeAndState ( maxWidth , widthMeasureSpec , childState ) , heightSizeAndState ) ; if ( matchWidth ) { forceUniformWidth ( count , heightMeasureSpec ) ; } } 
1079	public AbstractType < ? > parse ( ) throws SyntaxException , ConfigurationException { skipBlank ( ) ; String name = readNextIdentifier ( ) ; skipBlank ( ) ; if ( ! isEOS ( ) & & str . charAt ( idx ) = = ' ( ' ) return getAbstractType ( name , this ) ; else return getAbstractType ( name ) ; } 
1080	public String getSoundName ( ) { return _ name . getText ( ) ; } 
1081	void onAutoCaptureEnabled ( ) { Session session = currentSession . get ( ) ; if ( session ! = null & & ! foregroundActivities . isEmpty ( ) ) { If there is no session we will wait for one to be created trackSessionIfNeeded ( session ) ; } } 
1082	public void playSoundEffect ( int effectType ) { if ( effectType < _NUM | | effectType > = NUM _ SOUND _ EFFECTS ) { return ; } if ( ! querySoundEffectsEnabled ( Process . myUserHandle ( ) . getIdentifier ( ) ) ) { return ; } final IAudioService service = getService ( ) ; try { service . playSoundEffect ( effectType ) ; } catch ( RemoteException e ) { throw e . rethrowFromSystemServer ( ) ; } } 
1083	public boolean launchFocusedTask ( int logEvent ) { if ( mTaskStackView ! = null ) { Task task = mTaskStackView . getFocusedTask ( ) ; if ( task ! = null ) { TaskView taskView = mTaskStackView . getChildViewForTask ( task ) ; EventBus . getDefault ( ) . send ( new LaunchTaskEvent ( taskView , task , null , INVALID _ STACK _ ID , false ) ) ; if ( logEvent ! = _NUM ) { MetricsLogger . action ( getContext ( ) , logEvent , task . key . getComponent ( ) . toString ( ) ) ; } return true ; } } return false ; } 
1084	public void setSeriesVisibleInLegend ( int series , Boolean visible , boolean notify ) { this . seriesVisibleInLegendList . setBoolean ( series , visible ) ; if ( notify ) { fireChangeEvent ( ) ; } } 
1085	public void setEndPointEndingStyle ( String style ) { if ( style = = null ) { style = PDAnnotationLine . LE _ NONE ; } COSArray array = ( COSArray ) annot . getDictionaryObject ( COSName . LE ) ; if ( array = = null ) { array = new COSArray ( ) ; array . add ( COSName . getPDFName ( PDAnnotationLine . LE _ NONE ) ) ; array . add ( COSName . getPDFName ( style ) ) ; annot . setItem ( COSName . LE , array ) ; } else { array . setName ( _NUM , style ) ; } } 
1086	public int getPositionByTile ( Tile tile ) { final int size = mItems . size ( ) ; for ( int i = _NUM ; i < size ; i + + ) { final Object entity = mItems . get ( i ) . entity ; if ( entity = = tile ) { return i ; } else if ( entity instanceof Tile & & tile . title . equals ( ( ( Tile ) entity ) . title ) ) { return i ; } } return POSITION _ NOT _ FOUND ; } 
1087	public void setTag ( int key , final Object tag ) { or a framework id if ( ( key > > > _NUM _NUM ) < _NUM ) { throw new IllegalArgumentException ( _STR ) ; } setKeyedTag ( key , tag ) ; } 
1088	public void writeToParcel ( Parcel parcel , int flags ) { final boolean oldAllowFds = parcel . pushAllowFds ( ( mFlags & FLAG _ ALLOW _ FDS ) ! = _NUM ) ; try { super . writeToParcelInner ( parcel , flags ) ; } finally { parcel . restoreAllowFds ( oldAllowFds ) ; } } 
1089	public static void info ( final Logger logger , final String pattern , final short argument ) { if ( logger . isInfoEnabled ( ) ) { forcedLog ( logger , Level . INFO , format ( pattern , valueOf ( argument ) ) ) ; } } 
1090	public float mapProgress ( ) throws IOException { ensureState ( JobState . RUNNING ) ; ensureFreshStatus ( ) ; return status . getMapProgress ( ) ; } 
1091	public static Map < String , Properties > partitionOnCommonPrefixes ( final Properties properties ) { final Map < String , Properties > parts = new ConcurrentHashMap < > ( ) ; for ( final String key : properties . stringPropertyNames ( ) ) { final String prefix = key . substring ( _NUM , key . indexOf ( ' . ' ) ) ; if ( ! parts . containsKey ( prefix ) ) { parts . put ( prefix , new Properties ( ) ) ; } parts . get ( prefix ) . setProperty ( key . substring ( key . indexOf ( ' . ' ) + _NUM ) , properties . getProperty ( key ) ) ; } return parts ; } 
1092	public void processPathDirOrderAtime ( ) throws IOException { TestFile testfile _NUM _NUM = new TestFile ( _STR ) ; inOrder . verify ( out ) . println ( testfile _NUM _NUM . formatLineAtime ( lineFormat ) ) ; inOrder . verify ( out ) . println ( testfile _NUM _NUM . formatLineAtime ( lineFormat ) ) ; inOrder . verify ( out ) . println ( testfile _NUM _NUM . formatLineAtime ( lineFormat ) ) ; inOrder . verify ( out ) . println ( testfile _NUM _NUM . formatLineAtime ( lineFormat ) ) ; inOrder . verify ( out ) . println ( testfile _NUM _NUM . formatLineAtime ( lineFormat ) ) ; inOrder . verify ( out ) . println ( testfile _NUM _NUM . formatLineAtime ( lineFormat ) ) ; verifyNoMoreInteractions ( out ) ; } 
1093	public Builder setCatalogNameFilter ( org . apache . drill . exec . proto . UserProtos . LikeFilter . Builder builderForValue ) { if ( catalogNameFilterBuilder _ = = null ) { catalogNameFilter _ = builderForValue . build ( ) ; onChanged ( ) ; } else { catalogNameFilterBuilder _ . setMessage ( builderForValue . build ( ) ) ; } bitField _NUM _ | = _NUM x _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM ; return this ; } 
1094	private static AclFeature createAclFeature ( List < AclEntry > accessEntries , List < AclEntry > defaultEntries ) { Pre - allocate list size for the explicit entries stored in the feature , which is all entries minus the _NUM entries implicitly stored in the permission bits . List < AclEntry > featureEntries = Lists . newArrayListWithCapacity ( ( accessEntries . size ( ) - _NUM ) + defaultEntries . size ( ) ) ; predictable range . if ( ! AclUtil . isMinimalAcl ( accessEntries ) ) { featureEntries . addAll ( accessEntries . subList ( _NUM , accessEntries . size ( ) - _NUM ) ) ; } Add all default entries to the feature . featureEntries . addAll ( defaultEntries ) ; return new AclFeature ( AclEntryStatusFormat . toInt ( featureEntries ) ) ; } 
1095	private void getJpegAttributes ( ByteOrderedDataInputStream in , int jpegOffset , int imageType ) throws IOException { See JPEG File Interchange Format Specification , _STR ) ; } bytesRead + = length ; } Restore original byte order in . setByteOrder ( mExifByteOrder ) ; } 
1096	private void play ( ) { from the app side if ( ! mInitialized ) { PlaybackStateCompat . Builder builder = createPlaybackStateBuilder ( PlaybackStateCompat . STATE _ ERROR ) ; builder . setErrorMessage ( PlaybackStateCompat . ERROR _ CODE _ APP _ ERROR , PLAYER _ NOT _ INITIALIZED ) ; mMediaSession . setPlaybackState ( builder . build ( ) ) ; If the player has is playing , and this function is fired again , it is an error state from the app side } else { Request audio focus only when needed if ( mAudioManager . requestAudioFocus ( mOnAudioFocusChangeListener , AudioManager . STREAM _ MUSIC , AudioManager . AUDIOFOCUS _ GAIN ) ! = AudioManager . AUDIOFOCUS _ REQUEST _ GRANTED ) { return ; } if ( mPlayer . getPlaybackParams ( ) . getSpeed ( ) ! = NORMAL _ SPEED ) { Reset to normal speed and play resetSpeedAndPlay ( ) ; } else { Continue play . mPlayer . start ( ) ; mMediaSession . setPlaybackState ( createPlaybackStateBuilder ( PlaybackStateCompat . STATE _ PLAYING ) . build ( ) ) ; } } } 
1097	private PackedMap < Interval , MutableInt > createLinks ( boolean min ) { Assoc < Interval , MutableInt > result = Assoc . of ( Interval . class , MutableInt . class ) ; Spec [ ] keys = getGroupBounds ( ) . keys ; for ( int i = _NUM , N = keys . length ; i < N ; i + + ) { Interval span = min ? keys [ i ] . span : keys [ i ] . span . inverse ( ) ; result . put ( span , new MutableInt ( ) ) ; } return result . pack ( ) ; } 
1098	public void acceptInput ( String input ) { if ( currentPrompt ! = null ) { Echo the user ' s input if ( localEchoEnabled ) { context . getForWhom ( ) . sendRawMessage ( prefix . getPrefix ( context ) + input ) ; } Test for conversation abandonment based on input for ( ConversationCanceller canceller : cancellers ) { if ( canceller . cancelBasedOnInput ( context , input ) ) { abandon ( new ConversationAbandonedEvent ( this , canceller ) ) ; return ; } } Not abandoned , output the next prompt currentPrompt = currentPrompt . acceptInput ( context , input ) ; outputNextPrompt ( ) ; } } 
1099	public void exec ( INDArrayIndex . . . indexes ) { int [ ] shape = arr . shape ( ) ; if ( arr . isSparse ( ) ) { resolveFixedDimensionsCOO ( indexes ) ; } Check that given point indexes are not out of bounds for ( int i = _NUM ; i < indexes . length ; i + + ) { INDArrayIndex idx = indexes [ i ] ; On vectors , the first dimension can be ignored when indexing them with a single point index if ( idx instanceof PointIndex & & ( arr . isVector ( ) & & indexes . length = = _NUM ? idx . current ( ) > = shape [ i + _NUM ] : idx . current ( ) > = shape [ i ] ) ) { throw new IllegalArgumentException ( _STR ) ; } } indexes = NDArrayIndex . resolve ( arr . shapeInfoDataBuffer ( ) , indexes ) ; if ( tryShortCircuit ( indexes ) ) { return ; } int numIntervals = _NUM ; number of new axes dimensions to prepend to the beginning int newAxesPrepend = _NUM ; whether we have encountered an all so far boolean encounteredAll = false ; int lastPrependIndex = - _NUM ; List < Integer > oneDimensionWithAllEncountered = new ArrayList < > ( ) ; accumulate the results List < Long > accumShape = new ArrayList < > ( ) ; List < Long > accumStrides = new ArrayList < > ( ) ; List < Long > accumOffsets = new ArrayList < > ( ) ; List < Long > intervalStrides = new ArrayList < > ( ) ; collect the indexes of the points that get removed for point purposes this will be used to compute the offset for the new array List < Long > pointStrides = new ArrayList < > ( ) ; List < Long > pointOffsets = new ArrayList < > ( ) ; int numPointIndexes = _NUM ; bump number to read from the shape int shapeIndex = _NUM ; stride index to read strides from the array int strideIndex = _NUM ; list of indexes to prepend to for new axes if all is encountered List < Integer > prependNewAxes = new ArrayList < > ( ) ; for ( int i = _NUM ; i < indexes . length ; i + + ) { INDArrayIndex idx = indexes [ i ] ; if ( idx instanceof NDArrayIndexAll ) { encounteredAll = true ; if ( i < arr . rank ( ) & & arr . size ( i ) = = _NUM ) oneDimensionWithAllEncountered . add ( i ) ; at at the beginning . track when the last new axis is encountered . if ( newAxesPrepend > _NUM & & lastPrependIndex < _NUM ) { lastPrependIndex = i - _NUM ; } } also move the stride counter if ( idx instanceof PointIndex ) { pointOffsets . add ( idx . offset ( ) ) ; pointStrides . add ( ( long ) arr . stride ( strideIndex ) ) ; numPointIndexes + + ; shapeIndex + + ; strideIndex + + ; at at the beginning . track when the last new axis is encountered . if ( newAxesPrepend > _NUM & & lastPrependIndex < _NUM ) { lastPrependIndex = i - _NUM ; } continue ; } else to set the new axis in the middle if ( idx instanceof NewAxis ) { prepend the new axes at different indexes accumShape . add ( _NUM L ) ; accumOffsets . add ( _NUM L ) ; accumStrides . add ( _NUM L ) ; prependNewAxes . add ( i ) ; continue ; } else points and intervals both have a direct desired length if ( idx instanceof IntervalIndex & & ! ( idx instanceof NDArrayIndexAll ) | | idx instanceof SpecifiedIndex ) { if ( idx instanceof IntervalIndex ) { accumStrides . add ( arr . stride ( strideIndex ) * idx . stride ( ) ) ; used in computing an adjusted offset for the augmented strides intervalStrides . add ( idx . stride ( ) ) ; numIntervals + + ; } else accumStrides . add ( ( long ) arr . stride ( strideIndex ) ) ; accumShape . add ( idx . length ( ) ) ; add the offset for the index if ( idx instanceof IntervalIndex ) { accumOffsets . add ( idx . offset ( ) ) ; } else accumOffsets . add ( idx . offset ( ) ) ; shapeIndex + + ; strideIndex + + ; at at the beginning . track when the last new axis is encountered . if ( newAxesPrepend > _NUM & & lastPrependIndex < _NUM ) { lastPrependIndex = i - _NUM ; } continue ; } add the shape and stride based on the original stride / shape accumShape . add ( ( long ) shape [ shapeIndex + + ] ) ; account for erroneous strides from dimensions of size _NUM move the stride index if its one and fill it in at the bottom accumStrides . add ( ( long ) arr . stride ( strideIndex + + ) ) ; default offsets are zero accumOffsets . add ( idx . offset ( ) ) ; } fill in missing strides and shapes while ( shapeIndex < shape . length ) { scalar , should be _NUM x _NUM rather than the number of columns in the vector if ( Shape . isVector ( shape ) ) { accumShape . add ( _NUM L ) ; shapeIndex + + ; } else accumShape . add ( ( long ) shape [ shapeIndex + + ] ) ; } fill in the rest of the offsets with zero int delta = ( shape . length < = _NUM ? shape . length : shape . length - numPointIndexes ) ; boolean needsFilledIn = accumShape . size ( ) ! = accumStrides . size ( ) & & accumOffsets . size ( ) ! = accumShape . size ( ) ; while ( accumOffsets . size ( ) < delta & & needsFilledIn ) accumOffsets . add ( _NUM L ) ; while ( accumShape . size ( ) < _NUM ) { if ( Shape . isRowVectorShape ( arr . shape ( ) ) ) accumShape . add ( _NUM , _NUM L ) ; else accumShape . add ( _NUM L ) ; } while ( strideIndex < accumShape . size ( ) ) { accumStrides . add ( ( long ) arr . stride ( strideIndex + + ) ) ; } prune off extra zeros for trailing and leading ones int trailingZeroRemove = accumOffsets . size ( ) - _NUM ; while ( accumOffsets . size ( ) > accumShape . size ( ) ) { if ( accumOffsets . get ( trailingZeroRemove ) = = _NUM ) accumOffsets . remove ( accumOffsets . size ( ) - _NUM ) ; trailingZeroRemove - - ; } if ( accumStrides . size ( ) < accumOffsets . size ( ) ) accumStrides . addAll ( pointStrides ) ; while ( accumOffsets . size ( ) < accumShape . size ( ) ) { if ( Shape . isRowVectorShape ( arr . shape ( ) ) ) accumOffsets . add ( _NUM , _NUM L ) ; else accumOffsets . add ( _NUM L ) ; } if ( Shape . isMatrix ( shape ) & & indexes [ _NUM ] instanceof PointIndex & & indexes [ _NUM ] instanceof NDArrayIndexAll ) { Collections . reverse ( accumShape ) ; } if ( arr . isMatrix ( ) & & indexes [ _NUM ] instanceof PointIndex & & indexes [ _NUM ] instanceof IntervalIndex ) { this . shapes = new long [ _NUM ] ; shapes [ _NUM ] = _NUM ; IntervalIndex idx = ( IntervalIndex ) indexes [ _NUM ] ; shapes [ _NUM ] = idx . length ( ) ; } else this . shapes = Longs . toArray ( accumShape ) ; boolean isColumnVector = Shape . isColumnVectorShape ( this . shapes ) ; finally fill in teh rest of the strides if any are left over while ( accumStrides . size ( ) < accumOffsets . size ( ) ) { if ( ! isColumnVector ) accumStrides . add ( _NUM , ( long ) arr . elementStride ( ) ) ; else accumStrides . add ( ( long ) arr . elementStride ( ) ) ; } this . strides = Longs . toArray ( accumStrides ) ; this . offsets = Longs . toArray ( accumOffsets ) ; if ( numPointIndexes > _NUM & & ! pointStrides . isEmpty ( ) ) { append to the end for tensors if ( newAxesPrepend > = _NUM ) { while ( pointStrides . size ( ) < accumOffsets . size ( ) ) { pointStrides . add ( _NUM L ) ; } same structure in the point strides for ( int i = _NUM ; i < accumStrides . size ( ) ; i + + ) { if ( accumStrides . get ( i ) = = _NUM & & ! ( indexes [ i ] instanceof NewAxis ) & & lastPrependIndex < = _NUM ) pointStrides . set ( i , _NUM L ) ; } } and index in to a particular offset while ( pointOffsets . size ( ) < pointStrides . size ( ) ) { pointOffsets . add ( _NUM L ) ; } special case where offsets aren ' t caught if ( arr . isRowVector ( ) & & ! intervalStrides . isEmpty ( ) & & pointOffsets . get ( _NUM ) = = _NUM & & ! ( indexes [ _NUM ] instanceof IntervalIndex ) ) this . offset = indexes [ _NUM ] . offset ( ) ; else this . offset = ArrayUtil . dotProductLong _NUM ( pointOffsets , pointStrides ) ; } else { this . offset = _NUM ; } if ( numIntervals > _NUM & & arr . rank ( ) > _NUM ) { if ( encounteredAll & & arr . size ( _NUM ) ! = _NUM | | indexes [ _NUM ] instanceof PointIndex ) FIXME : LONG this . offset + = ArrayUtil . dotProductLong _NUM ( accumOffsets , accumStrides ) ; else FIXME : LONG this . offset + = ArrayUtil . dotProductLong _NUM ( accumOffsets , accumStrides ) ; } else if ( numIntervals > _NUM & & anyHaveStrideOne ( indexes ) ) this . offset + = ArrayUtil . calcOffsetLong _NUM ( accumShape , accumOffsets , accumStrides ) ; else this . offset + = ArrayUtil . calcOffsetLong _NUM ( accumShape , accumOffsets , accumStrides ) / Math . max ( _NUM , numIntervals ) ; collapse singular dimensions with specified index List < Integer > removeShape = new ArrayList < > ( ) ; for ( int i = _NUM ; i < Math . min ( this . shapes . length , indexes . length ) ; i + + ) { if ( this . shapes [ i ] = = _NUM & & indexes [ i ] instanceof SpecifiedIndex ) { removeShape . add ( i ) ; } } if ( ! removeShape . isEmpty ( ) ) { List < Long > newShape = new ArrayList < > ( ) ; List < Long > newStrides = new ArrayList < > ( ) ; for ( int i = _NUM ; i < this . shapes . length ; i + + ) { if ( ! removeShape . contains ( i ) ) { newShape . add ( this . shapes [ i ] ) ; newStrides . add ( this . strides [ i ] ) ; } } this . shapes = Longs . toArray ( newShape ) ; this . strides = Longs . toArray ( newStrides ) ; } } 
1100	public int getAlbumCount ( final List < MusicFolder > musicFolders ) { if ( musicFolders . isEmpty ( ) ) { return _NUM ; } Map < String , Object > args = new HashMap < String , Object > ( ) ; args . put ( _STR , args , Integer . class ) ; } 
1101	public void testProcessMsg _NUM ( ) { byte [ ] originalMessageBody = mMessageBody ; mMessageBody = new byte [ ] { ( byte ) _NUM xee , ( byte ) _NUM xff , ( byte ) _NUM xee , ( byte ) _NUM xff , ( byte ) _NUM xee , ( byte ) _NUM xff , ( byte ) _NUM xee , ( byte ) _NUM xff , ( byte ) _NUM xee , ( byte ) _NUM xff , ( byte ) _NUM xee , ( byte ) _NUM xff } ; byte [ ] pdu = createPDU ( _NUM ) ; int headerLen = pdu . length - ( mGsmHeader . length + mUserDataHeader . length + mMessageBody . length ) ; int pduType = _NUM ; int tranId = _NUM ; String originalPackageName = mPackageName ; String originalClassName = mClassName ; try { IWapPushManager iwapman = getInterface ( ) ; IDataVerify dataverify = getVerifyInterface ( ) ; dataverify . resetData ( ) ; set up data mClassName = _STR ; mMessageBody = new byte [ ] { ( byte ) _NUM xaa , ( byte ) _NUM xbb , ( byte ) _NUM x _NUM _NUM , ( byte ) _NUM x _NUM _NUM , ( byte ) _NUM xaa , ( byte ) _NUM xbb , ( byte ) _NUM x _NUM _NUM , ( byte ) _NUM x _NUM _NUM , ( byte ) _NUM xaa , ( byte ) _NUM xbb , ( byte ) _NUM x _NUM _NUM , ( byte ) _NUM x _NUM _NUM , ( byte ) _NUM xaa , ( byte ) _NUM xbb , ( byte ) _NUM x _NUM _NUM , ( byte ) _NUM x _NUM _NUM , ( byte ) _NUM xaa , ( byte ) _NUM xbb , ( byte ) _NUM x _NUM _NUM , ( byte ) _NUM x _NUM _NUM , ( byte ) _NUM xaa , ( byte ) _NUM xbb , ( byte ) _NUM x _NUM _NUM , ( byte ) _NUM x _NUM _NUM } ; pdu = createPDU ( _NUM ) ; iwapman . addPackage ( Integer . toString ( mAppIdValue ) , Integer . toString ( mContentTypeValue ) , mPackageName , mClassName , WapPushManagerParams . APP _ TYPE _ SERVICE , false , false ) ; iwapman . processMessage ( Integer . toString ( mAppIdValue ) , Integer . toString ( mContentTypeValue ) , createIntent ( pduType , tranId ) ) ; clean up data iwapman . deletePackage ( Integer . toString ( mAppIdValue ) , Integer . toString ( mContentTypeValue ) , mPackageName , mClassName ) ; Log . d ( LOG _ TAG , HexDump . dumpHexString ( mMessageBody ) ) ; assertTrue ( dataverify . verifyData ( mMessageBody ) ) ; } catch ( RemoteException e ) { assertTrue ( false ) ; } mPackageName = originalPackageName ; mClassName = originalClassName ; mMessageBody = originalMessageBody ; } 
1102	public Map . Entry < K , V > ceil ( K k ) { if ( contains ( k ) ) { return mHashMap . get ( k ) . mPrevious ; } return null ; } 
1103	public V remove ( Object key ) { return getPartition ( key ) . remove ( key ) ; } 
1104	public boolean hasScoreCurve ( ScanResult result ) { ScoredNetwork network = getScoredNetwork ( result ) ; return network ! = null & & network . rssiCurve ! = null ; } 
1105	public < T > List < T > queryFrom ( String sql , StatementParameters parameters , DalHints hints , DalRowMapper < T > mapper , int start , int count ) throws SQLException { hints . set ( DalHintEnum . resultSetType , ResultSet . TYPE _ SCROLL _ INSENSITIVE ) ; return queryRange ( sql , parameters , hints , mapper , start , count ) ; } 
1106	public DoubleStream stream ( ) { if ( ! isPresent ( ) ) { return DoubleStream . empty ( ) ; } return DoubleStream . of ( value ) ; } 
1107	public ByteVector putByteArray ( final byte [ ] b , final int off , final int len ) { if ( length + len > data . length ) { enlarge ( len ) ; } if ( b ! = null ) { System . arraycopy ( b , off , data , length , len ) ; } length + = len ; return this ; } 
1108	public void testRWBufferDirBecomesRO ( ) throws Exception { if ( isWindows ) return ; String dir _NUM = buildBufferDir ( ROOT , _NUM ) ; String dir _NUM = buildBufferDir ( ROOT , _NUM ) ; try { conf . set ( CONTEXT , dir _NUM + _STR + dir _NUM ) ; assertTrue ( localFs . mkdirs ( new Path ( dir _NUM ) ) ) ; assertTrue ( localFs . mkdirs ( new Path ( dir _NUM ) ) ) ; Create the first small file createTempFile ( SMALL _ FILE _ SIZE ) ; Determine the round - robin sequence int nextDirIdx = ( dirAllocator . getCurrentDirectoryIndex ( ) = = _NUM ) ? _NUM : _NUM ; validateTempDirCreation ( buildBufferDir ( ROOT , nextDirIdx ) ) ; change buffer directory _NUM to be read only new File ( new Path ( dir _NUM ) . toUri ( ) . getPath ( ) ) . setReadOnly ( ) ; validateTempDirCreation ( dir _NUM ) ; validateTempDirCreation ( dir _NUM ) ; } finally { rmBufferDirs ( ) ; } } 
1109	public void setFont ( Font font ) { Font old = super . getFont ( ) ; Do this first . super . setFont ( font ) ; Usually programmers keep a single font for all token types , but may use bold or italic for styling some . SyntaxScheme scheme = getSyntaxScheme ( ) ; if ( scheme ! = null & & old ! = null ) { scheme . changeBaseFont ( old , font ) ; calculateLineHeight ( ) ; } graphics to be non - null . if ( isDisplayable ( ) ) { refreshFontMetrics ( getGraphics _NUM D ( getGraphics ( ) ) ) ; Updates the margin line . updateMarginLineX ( ) ; Force the current line highlight to be repainted , even though the caret ' s location hasn ' t changed . forceCurrentLineHighlightRepaint ( ) ; Get line number border in text area to repaint again since line heights have updated . firePropertyChange ( _STR , old , font ) ; So parent JScrollPane will have its scrollbars updated . revalidate ( ) ; } } 
1110	public void output ( String filename ) { build ( ) . output ( filename ) ; } 
1111	public boolean isEncryptionKey ( ) { int algorithm = publicPk . getAlgorithm ( ) ; return ( ( algorithm = = RSA _ GENERAL ) | | ( algorithm = = RSA _ ENCRYPT ) | | ( algorithm = = ELGAMAL _ ENCRYPT ) | | ( algorithm = = ELGAMAL _ GENERAL ) | | algorithm = = ECDH ) ; } 
1112	public boolean checkAccess ( UserGroupInformation callerUGI , JobACL jobOperation , String jobOwner , AccessControlList jobACL ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( _STR + callerUGI . getShortUserName ( ) ) ; } String user = callerUGI . getShortUserName ( ) ; if ( ! areACLsEnabled ( ) ) { return true ; } Allow Job - owner for any operation on the job if ( isMRAdmin ( callerUGI ) | | user . equals ( jobOwner ) | | jobACL . isUserAllowed ( callerUGI ) ) { return true ; } return false ; } 
1113	private void fireProcessingResultUpdated ( ) { for ( ISearchResultListener listener : listeners ) listener . beforeProcessingResultUpdated ( ) ; for ( ISearchResultListener listener : listeners ) listener . processingResultUpdated ( result ) ; for ( ISearchResultListener listener : listeners ) listener . afterProcessingResultUpdated ( ) ; } 
1114	public Container addAll ( Component . . . cmps ) { for ( Component c : cmps ) { addComponent ( c ) ; } return this ; } 
1115	public byte [ ] peek ( ) throws KeeperException , InterruptedException { try { return element ( ) ; } catch ( NoSuchElementException e ) { return null ; } } 
1116	private String getPost ( final String postId ) throws Exception { final StringBuilder stringBuilder = new StringBuilder ( _STR ) ; return stringBuilder . toString ( ) ; } 
1117	public static WALEdit createBulkLoadEvent ( RegionInfo hri , WALProtos . BulkLoadDescriptor bulkLoadDescriptor ) { KeyValue kv = new KeyValue ( getRowForRegion ( hri ) , METAFAMILY , BULK _ LOAD , EnvironmentEdgeManager . currentTime ( ) , bulkLoadDescriptor . toByteArray ( ) ) ; return new WALEdit ( ) . add ( kv ) ; } 
1118	public org . fife . ui . rsyntaxtextarea . Token yylex ( ) throws java . io . IOException { int zzInput ; int zzAction ; cached fields : int zzCurrentPosL ; int zzMarkedPosL ; int zzEndReadL = zzEndRead ; char [ ] zzBufferL = zzBuffer ; char [ ] zzCMapL = ZZ _ CMAP ; int [ ] zzTransL = ZZ _ TRANS ; int [ ] zzRowMapL = ZZ _ ROWMAP ; int [ ] zzAttrL = ZZ _ ATTRIBUTE ; while ( true ) { zzMarkedPosL = zzMarkedPos ; zzAction = - _NUM ; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL ; zzState = zzLexicalState ; zzForAction : { while ( true ) { if ( zzCurrentPosL < zzEndReadL ) zzInput = zzBufferL [ zzCurrentPosL + + ] ; else if ( zzAtEOF ) { zzInput = YYEOF ; break zzForAction ; } else { store back cached positions zzCurrentPos = zzCurrentPosL ; zzMarkedPos = zzMarkedPosL ; boolean eof = zzRefill ( ) ; get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos ; zzMarkedPosL = zzMarkedPos ; zzBufferL = zzBuffer ; zzEndReadL = zzEndRead ; if ( eof ) { zzInput = YYEOF ; break zzForAction ; } else { zzInput = zzBufferL [ zzCurrentPosL + + ] ; } } int zzNext = zzTransL [ zzRowMapL [ zzState ] + zzCMapL [ zzInput ] ] ; if ( zzNext = = - _NUM ) break zzForAction ; zzState = zzNext ; int zzAttributes = zzAttrL [ zzState ] ; if ( ( zzAttributes & _NUM ) = = _NUM ) { zzAction = zzState ; zzMarkedPosL = zzCurrentPosL ; if ( ( zzAttributes & _NUM ) = = _NUM ) break zzForAction ; } } } store back cached position zzMarkedPos = zzMarkedPosL ; switch ( zzAction < _NUM ? zzAction : ZZ _ ACTION [ zzAction ] ) { case _NUM : { addNullToken ( ) ; return firstToken ; } case _NUM _NUM : break ; case _NUM _NUM : { addToken ( Token . LITERAL _ CHAR ) ; } case _NUM _NUM : break ; case _NUM _NUM : { start = zzMarkedPos - _NUM ; yybegin ( LONGSTRING ) ; } case _NUM _NUM : break ; case _NUM _NUM : { yybegin ( YYINITIAL ) ; addToken ( start , zzStartRead + _NUM , Token . COMMENT _ MULTILINE ) ; } case _NUM _NUM : break ; case _NUM : { addToken ( Token . WHITESPACE ) ; } case _NUM _NUM : break ; case _NUM : { addToken ( Token . LITERAL _ NUMBER _ FLOAT ) ; } case _NUM _NUM : break ; case _NUM _NUM : { addToken ( Token . RESERVED _ WORD ) ; } case _NUM _NUM : break ; case _NUM _NUM : { start = zzMarkedPos - _NUM ; yybegin ( MLC ) ; } case _NUM _NUM : break ; case _NUM : { addToken ( Token . SEPARATOR ) ; } case _NUM _NUM : break ; case _NUM : { addToken ( Token . IDENTIFIER ) ; } case _NUM _NUM : break ; case _NUM _NUM : { addToken ( Token . FUNCTION ) ; } case _NUM _NUM : break ; case _NUM : { addToken ( Token . ERROR _ CHAR ) ; addNullToken ( ) ; return firstToken ; } case _NUM _NUM : break ; case _NUM : { addToken ( Token . ERROR _ STRING _ DOUBLE ) ; addNullToken ( ) ; return firstToken ; } case _NUM _NUM : break ; case _NUM _NUM : { addToken ( Token . DATA _ TYPE ) ; } case _NUM _NUM : break ; case _NUM _NUM : { addToken ( Token . LITERAL _ BOOLEAN ) ; } case _NUM _NUM : break ; case _NUM _NUM : { yybegin ( YYINITIAL ) ; addToken ( start , zzStartRead + _NUM , Token . LITERAL _ STRING _ DOUBLE _ QUOTE ) ; } case _NUM _NUM : break ; case _NUM _NUM : { addToken ( Token . LITERAL _ STRING _ DOUBLE _ QUOTE ) ; } case _NUM _NUM : break ; case _NUM _NUM : { addToken ( start , zzStartRead - _NUM , Token . LITERAL _ STRING _ DOUBLE _ QUOTE ) ; return firstToken ; } case _NUM _NUM : break ; case _NUM _NUM : { addToken ( start , zzStartRead - _NUM , Token . COMMENT _ EOL ) ; return firstToken ; } case _NUM _NUM : break ; case _NUM : { addToken ( Token . OPERATOR ) ; } case _NUM _NUM : break ; case _NUM _NUM : { start = zzMarkedPos - _NUM ; yybegin ( LINECOMMENT ) ; } case _NUM _NUM : break ; case _NUM : { } case _NUM _NUM : break ; case _NUM _NUM : { addToken ( start , zzStartRead - _NUM , Token . COMMENT _ MULTILINE ) ; return firstToken ; } case _NUM _NUM : break ; default : if ( zzInput = = YYEOF & & zzStartRead = = zzCurrentPos ) { zzAtEOF = true ; switch ( zzLexicalState ) { case YYINITIAL : { addNullToken ( ) ; return firstToken ; } case _NUM _NUM _NUM : break ; case LONGSTRING : { addToken ( start , zzStartRead - _NUM , Token . LITERAL _ STRING _ DOUBLE _ QUOTE ) ; return firstToken ; } case _NUM _NUM _NUM : break ; case LINECOMMENT : { addToken ( start , zzStartRead - _NUM , Token . COMMENT _ EOL ) ; return firstToken ; } case _NUM _NUM _NUM : break ; case MLC : { addToken ( start , zzStartRead - _NUM , Token . COMMENT _ MULTILINE ) ; return firstToken ; } case _NUM _NUM _NUM : break ; default : return null ; } } else { zzScanError ( ZZ _ NO _ MATCH ) ; } } } } 
1119	protected void fireStart ( CmsPublishJobEnqueued publishJob ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( Messages . get ( ) . getBundle ( ) . key ( Messages . LOG _ PUBLISH _ JOB _ START _ _NUM ) ) ; } for ( Iterator < I _ CmsPublishEventListener > it = iterator ( ) ; it . hasNext ( ) ; ) { I _ CmsPublishEventListener listener = it . next ( ) ; try { listener . onStart ( publishJob ) ; } catch ( Throwable t ) { catch every thing including runtime exceptions if ( LOG . isErrorEnabled ( ) ) { LOG . error ( Messages . get ( ) . getBundle ( ) . key ( Messages . ERR _ PUBLISH _ JOB _ START _ ERROR _ _NUM , listener . getClass ( ) . getName ( ) ) , t ) ; } if ( publishJob . m _ publishJob . getPublishReport ( ) ! = null ) { publishJob . m _ publishJob . getPublishReport ( ) . println ( t ) ; } } } popup the start message boolean busyStart = ( ( System . currentTimeMillis ( ) - publishJob . getEnqueueTime ( ) ) > _NUM _NUM _NUM _NUM ) ; boolean bigJob = ( ( publishJob . getPublishList ( ) . size ( ) > _NUM _NUM ) | | ( OpenCms . getStaticExportManager ( ) . getHandler ( ) instanceof CmsAfterPublishStaticExportHandler ) ) ; if ( busyStart | | bigJob ) { String msgText = Messages . get ( ) . getBundle ( publishJob . getLocale ( ) ) . key ( Messages . GUI _ PUBLISH _ JOB _ STARTED _ _NUM , new Long ( publishJob . getEnqueueTime ( ) ) ) ; m _ publishEngine . sendMessage ( publishJob . getUserId ( ) , msgText , false ) ; } } 
1120	public static S _NUM Object decryptObjectUsingMetadata ( S _NUM Object object , EncryptionMaterials materials , Provider cryptoProvider ) { Create an instruction object from the object headers EncryptionInstruction instruction = EncryptionUtils . buildInstructionFromObjectMetadata ( object , materials , cryptoProvider ) ; Decrypt the object file with the instruction return EncryptionUtils . decryptObjectUsingInstruction ( object , instruction ) ; } 
1121	public DVCSRequest build ( CMSSignedData document ) throws DVCSException { try { Data data = new Data ( document . getEncoded ( ) ) ; return createDVCRequest ( data ) ; } catch ( IOException e ) { throw new DVCSException ( _STR , e ) ; } } 
1122	public boolean pan ( int dX , int dY ) { We only pan if the current scaling is able to pan . if ( scaling ! = null & & ! scaling . isAbleToPan ( ) ) return false ; double scale = getScale ( ) ; double sX = ( double ) dX / scale ; double sY = ( double ) dY / scale ; if ( absoluteXPosition + sX < _NUM ) dX = diff to _NUM sX = - absoluteXPosition ; if ( absoluteYPosition + sY < _NUM ) sY = - absoluteYPosition ; Prevent panning right or below desktop image if ( absoluteXPosition + getVisibleWidth ( ) + sX > getImageWidth ( ) ) sX = getImageWidth ( ) - getVisibleWidth ( ) - absoluteXPosition ; if ( absoluteYPosition + getVisibleHeight ( ) + sY > getImageHeight ( ) ) sY = getImageHeight ( ) - getVisibleHeight ( ) - absoluteYPosition ; absoluteXPosition + = sX ; absoluteYPosition + = sY ; if ( sX ! = _NUM . _NUM | | sY ! = _NUM . _NUM ) { scrollBy ( ( int ) sX , ( int ) sY ) ; scrollToAbsolute ( ) ; return true ; } return false ; } 
1123	public DeleteTagsRequest withResources ( String . . . resources ) { if ( getResources ( ) = = null ) setResources ( new java . util . ArrayList < String > ( resources . length ) ) ; for ( String value : resources ) { getResources ( ) . add ( value ) ; } return this ; } 
1124	public DhcpConfiguration withValues ( String . . . values ) { if ( getValues ( ) = = null ) setValues ( new java . util . ArrayList < String > ( values . length ) ) ; for ( String value : values ) { getValues ( ) . add ( value ) ; } return this ; } 
1125	private void copyFromLocal ( AlluxioURI srcPath , AlluxioURI dstPath ) throws AlluxioException , IOException { File srcFile = new File ( srcPath . getPath ( ) ) ; if ( srcFile . isDirectory ( ) ) { copyFromLocalDir ( srcPath , dstPath ) ; } else { copyPath ( srcPath , dstPath ) ; } System . out . println ( _STR + dstPath ) ; } 
1126	protected final IBinder getBinderService ( String name ) { return ServiceManager . getService ( name ) ; } 
1127	public void testAddMap ( ) { PrefixMapping b = getMapping ( ) ; Map < String , String > map = new HashMap < > ( ) ; map . put ( _STR , butterURI ) ; b . setNsPrefixes ( map ) ; checkContainsMapping ( b ) ; } 
1128	public synchronized void add ( double x , double y ) { while ( mXY . get ( x ) ! = null ) { add a very small value to x such as data points sharing the same x will still be added x + = getPadding ( x ) ; } mXY . put ( x , y ) ; updateRange ( x , y ) ; } 
1129	public void writeUserInfo ( CmsDbContext dbc , CmsUUID userId , String key , Object value ) throws CmsDataAccessException { analyse the dbc attribute what to do here String mode = ( String ) dbc . getAttribute ( ATTRIBUTE _ USERADDINFO ) ; delete the user info if ( CmsStringUtil . isNotEmpty ( mode ) & & mode . equals ( ATTRIBUTE _ USERADDINFO _ VALUE _ DELETE ) ) { internalDeleteUserInfo ( dbc , userId , key ) ; } else if ( CmsStringUtil . isNotEmpty ( mode ) & & mode . equals ( ATTRIBUTE _ USERADDINFO _ VALUE _ UPDATE ) ) { internalUpdateUserInfo ( dbc , userId , key , value ) ; } else { default is to insert or update a new value internalWriteUserInfo ( dbc , userId , key , value ) ; } } 
1130	private void putResize ( int key , V value ) { if ( key = = _NUM ) { zeroValue = value ; hasZeroValue = true ; return ; } Check for empty buckets . int index _NUM = key & mask ; int key _NUM = keyTable [ index _NUM ] ; if ( key _NUM = = EMPTY ) { keyTable [ index _NUM ] = key ; valueTable [ index _NUM ] = value ; if ( size + + > = threshold ) resize ( capacity < < _NUM ) ; return ; } int index _NUM = hash _NUM ( key ) ; int key _NUM = keyTable [ index _NUM ] ; if ( key _NUM = = EMPTY ) { keyTable [ index _NUM ] = key ; valueTable [ index _NUM ] = value ; if ( size + + > = threshold ) resize ( capacity < < _NUM ) ; return ; } int index _NUM = hash _NUM ( key ) ; int key _NUM = keyTable [ index _NUM ] ; if ( key _NUM = = EMPTY ) { keyTable [ index _NUM ] = key ; valueTable [ index _NUM ] = value ; if ( size + + > = threshold ) resize ( capacity < < _NUM ) ; return ; } push ( key , value , index _NUM , key _NUM , index _NUM , key _NUM , index _NUM , key _NUM ) ; } 
1131	public void test _NUM ( ) throws Exception { configure ( _STR ) ) ; } 
1132	private static < T > List < T > flatListNotComparable ( T [ ] t ) { switch ( t . length ) { case _NUM : noinspection unchecked return COMPARABLE _ EMPTY _ LIST ; case _NUM : return new Flat _NUM List < > ( t [ _NUM ] ) ; case _NUM : return new Flat _NUM List < > ( t [ _NUM ] , t [ _NUM ] ) ; case _NUM : return new Flat _NUM List < > ( t [ _NUM ] , t [ _NUM ] , t [ _NUM ] ) ; case _NUM : return new Flat _NUM List < > ( t [ _NUM ] , t [ _NUM ] , t [ _NUM ] , t [ _NUM ] ) ; case _NUM : return new Flat _NUM List < > ( t [ _NUM ] , t [ _NUM ] , t [ _NUM ] , t [ _NUM ] , t [ _NUM ] ) ; case _NUM : return new Flat _NUM List < > ( t [ _NUM ] , t [ _NUM ] , t [ _NUM ] , t [ _NUM ] , t [ _NUM ] , t [ _NUM ] ) ; default : return ImmutableNullableList . copyOf ( t ) ; } } 
1133	public void getChild ( ) { large number of small files InodeDirectory inodeDirectory = createInodeDirectory ( ) ; int nFiles = ( int ) _NUM E _NUM ; Inode < ? > [ ] inodes = new Inode [ nFiles ] ; for ( int i = _NUM ; i < nFiles ; i + + ) { inodes [ i ] = createInodeFile ( i + _NUM ) ; inodeDirectory . addChild ( inodes [ i ] ) ; } Runtime runtime = Runtime . getRuntime ( ) ; LOG . info ( String . format ( _STR , nFiles , System . currentTimeMillis ( ) - start ) ) ; } 
1134	public boolean getLastVoiceTagNumber ( BluetoothDevice device ) { if ( DBG ) log ( _STR ) ; return false ; } 
1135	public void testAlertDefinitionChanged ( ) throws Exception { installHdfsService ( ) ; int definitionCount = definitionDao . findAll ( ) . size ( ) ; AlertDefinitionEntity definition = ormHelper . createAlertDefinition ( cluster . getClusterId ( ) ) ; Assert . assertEquals ( definitionCount + _NUM , definitionDao . findAll ( ) . size ( ) ) ; AggregateSource source = new AggregateSource ( ) ; Reporting reporting = new Reporting ( ) ; ReportTemplate okTemplate = new ReportTemplate ( ) ; okTemplate . setValue ( _NUM _NUM . _NUM d ) ; okTemplate . setText ( _STR , aggregate . getSource ( ) . getReporting ( ) . getOk ( ) . getText ( ) ) ; } 
1136	public void testDirectory ( ) throws Exception { checkAndNotify ( ) ; checkCollectionsEmpty ( _STR ) ; } 
1137	private void clearSubTreeLocked ( int windowId , long rootNodeId ) { if ( DEBUG ) { Log . i ( LOG _ TAG , _STR ) ; } LongSparseArray < AccessibilityNodeInfo > nodes = mNodeCache . get ( windowId ) ; if ( nodes ! = null ) { clearSubTreeRecursiveLocked ( nodes , rootNodeId ) ; } } 
1138	public void bug _NUM _NUM _NUM _NUM _NUM _ NamedRangesReferToCorrectSheetWhenSheetOrderIsChanged ( ) throws Exception { Workbook wb = _ testDataProvider . createWorkbook ( ) ; Sheet sheet _NUM = wb . createSheet ( _STR , name . getRefersToFormula ( ) ) ; wb _NUM . close ( ) ; } wb . close ( ) ; } 
1139	public void testUnionWithSameColumnNames ( ) { CalciteAssert . hr ( ) . query ( _STR ) ; } 
1140	public Object instantiateItem ( ViewGroup collection , int position ) { View view ; Resources res = mContext . getResources ( ) ; if ( position = = EXPIRATION _ MONTH _ POSITION ) { Months sMonthKeyboardPosition = position ; view = mInflater . inflate ( R . layout . keyboard _ text , collection , false ) ; View v _NUM = view . findViewById ( R . id . first ) ; View v _NUM = view . findViewById ( R . id . second ) ; View v _NUM = view . findViewById ( R . id . third ) ; View v _NUM = view . findViewById ( R . id . fourth ) ; mMonths [ _NUM ] = ( Button ) v _NUM . findViewById ( R . id . key _ left ) ; mMonths [ _NUM ] = ( Button ) v _NUM . findViewById ( R . id . key _ middle ) ; mMonths [ _NUM ] = ( Button ) v _NUM . findViewById ( R . id . key _ right ) ; mMonths [ _NUM ] = ( Button ) v _NUM . findViewById ( R . id . key _ left ) ; mMonths [ _NUM ] = ( Button ) v _NUM . findViewById ( R . id . key _ middle ) ; mMonths [ _NUM ] = ( Button ) v _NUM . findViewById ( R . id . key _ right ) ; mMonths [ _NUM ] = ( Button ) v _NUM . findViewById ( R . id . key _ left ) ; mMonths [ _NUM ] = ( Button ) v _NUM . findViewById ( R . id . key _ middle ) ; mMonths [ _NUM ] = ( Button ) v _NUM . findViewById ( R . id . key _ right ) ; mMonths [ _NUM ] = ( Button ) v _NUM . findViewById ( R . id . key _ left ) ; mMonths [ _NUM _NUM ] = ( Button ) v _NUM . findViewById ( R . id . key _ middle ) ; mMonths [ _NUM _NUM ] = ( Button ) v _NUM . findViewById ( R . id . key _ right ) ; for ( int i = _NUM ; i < _NUM _NUM ; i + + ) { mMonths [ i ] . setOnClickListener ( ExpirationPicker . this ) ; mMonths [ i ] . setText ( mMonthAbbreviations [ i ] ) ; mMonths [ i ] . setText ( String . format ( _STR , i ) ) ; mYearNumbers [ i ] . setTextColor ( mTextColor ) ; mYearNumbers [ i ] . setBackgroundResource ( mKeyBackgroundResId ) ; mYearNumbers [ i ] . setTag ( R . id . date _ keyboard , KEYBOARD _ YEAR ) ; mYearNumbers [ i ] . setTag ( R . id . numbers _ key , i ) ; } } else { view = new View ( mContext ) ; } setLeftRightEnabled ( ) ; updateExpiration ( ) ; updateKeypad ( ) ; collection . addView ( view , _NUM ) ; return view ; } 
1141	public static void main ( String [ ] args ) { PorterStemmer s = new PorterStemmer ( ) ; for ( int i = _NUM ; i < args . length ; i + + ) { try { InputStream in = new FileInputStream ( args [ i ] ) ; byte [ ] buffer = new byte [ _NUM _NUM _NUM _NUM ] ; int bufferLen , offset , ch ; bufferLen = in . read ( buffer ) ; offset = _NUM ; s . reset ( ) ; while ( true ) { if ( offset < bufferLen ) ch = buffer [ offset + + ] ; else { bufferLen = in . read ( buffer ) ; offset = _NUM ; if ( bufferLen < _NUM ) ch = - _NUM ; else ch = buffer [ offset + + ] ; } if ( Character . isLetter ( ( char ) ch ) ) { s . add ( Character . toLowerCase ( ( char ) ch ) ) ; } else { s . stem ( ) ; System . out . print ( s . toString ( ) ) ; s . reset ( ) ; if ( ch < _NUM ) break ; else { System . out . print ( ( char ) ch ) ; } } } in . close ( ) ; } catch ( IOException e ) { System . out . println ( _STR + args [ i ] ) ; } } } 
1142	public Uri build ( ) { if ( opaquePart ! = null ) { if ( this . scheme = = null ) { throw new UnsupportedOperationException ( _STR ) ; } return new OpaqueUri ( scheme , opaquePart , fragment ) ; } else { Hierarchical URIs should not return null for getPath ( ) . PathPart path = this . path ; if ( path = = null | | path = = PathPart . NULL ) { path = PathPart . EMPTY ; } else { be absolute . Prepend it with a ' / ' if necessary . if ( hasSchemeOrAuthority ( ) ) { path = PathPart . makeAbsolute ( path ) ; } } return new HierarchicalUri ( scheme , authority , path , query , fragment ) ; } } 
1143	protected synchronized void startRouteService ( RouteService routeService , boolean addingRoutes ) throws Exception { we may already be starting routes so remember this , so we can unset accordingly in finally block boolean alreadyStartingRoutes = isStartingRoutes ( ) ; if ( ! alreadyStartingRoutes ) { isStartingRoutes . set ( true ) ; } try { the route service could have been suspended , and if so then resume it instead if ( routeService . getStatus ( ) . isSuspended ( ) ) { resumeRouteService ( routeService ) ; } else { start the route service routeServices . put ( routeService . getId ( ) , routeService ) ; if ( shouldStartRoutes ( ) ) { this method will log the routes being started safelyStartRouteServices ( true , true , true , false , addingRoutes , routeService ) ; start route services if it was configured to auto startup and we are not adding routes boolean autoStartup = routeService . getRouteDefinition ( ) . isAutoStartup ( this ) & & this . isAutoStartup ( ) ; if ( ! addingRoutes | | autoStartup ) { start the route since auto start is enabled or we are starting a route ( not adding new routes ) routeService . start ( ) ; } } } } finally { if ( ! alreadyStartingRoutes ) { isStartingRoutes . remove ( ) ; } } } 
1144	private void createSShell ( ) { sShell = new Shell ( getParent ( ) , SWT . MODELESS | SWT . DIALOG _ TRIM ) ; sShell . setText ( textFindReplace ) ; FormLayout formLayout = new FormLayout ( ) ; formLayout . marginHeight = _NUM ; formLayout . marginWidth = _NUM ; formLayout . spacing = _NUM ; sShell . setLayout ( formLayout ) ; sShell . addShellListener ( new ShellAdapter ( ) { @ Override public void shellActivated ( ShellEvent e ) { enableDisableControls ( ) ; } } ) ; if ( findGroup = = null ) { findGroup = new TextHexInputGroup ( findReplaceFindList ) ; } findGroup . initialise ( ) ; findGroup . group . setText ( textFindLiteral ) ; SelectionAdapter hexTextSelectionAdapter = new SelectionAdapter ( ) { @ Override public void widgetSelected ( SelectionEvent e ) { checkBox . setEnabled ( e . widget = = findGroup . textRadioButton ) ; } } ; findGroup . textRadioButton . addSelectionListener ( hexTextSelectionAdapter ) ; findGroup . hexRadioButton . addSelectionListener ( hexTextSelectionAdapter ) ; if ( replaceGroup = = null ) { replaceGroup = new TextHexInputGroup ( findReplaceReplaceList ) ; } replaceGroup . initialise ( ) ; replaceGroup . group . setText ( textReplaceWith ) ; FormData formData = new FormData ( ) ; formData . top = new FormAttachment ( findGroup . group ) ; replaceGroup . group . setLayoutData ( formData ) ; createDirectionGroup ( ) ; createIgnoreCaseComposite ( ) ; createFindReplaceButtonsComposite ( ) ; Composite feedbackComposite = new Composite ( sShell , SWT . NONE ) ; FormData formData _NUM = new FormData ( ) ; formData _NUM . top = new FormAttachment ( findReplaceButtonsComposite ) ; formData _NUM . left = new FormAttachment ( _NUM ) ; formData _NUM . bottom = new FormAttachment ( _NUM _NUM _NUM ) ; feedbackComposite . setLayoutData ( formData _NUM ) ; FormLayout formLayout _NUM = new FormLayout ( ) ; formLayout _NUM . spacing = _NUM ; feedbackComposite . setLayout ( formLayout _NUM ) ; feedbackLabel = new Label ( feedbackComposite , SWT . CENTER ) ; feedbackLabel . setText ( textNewFind ) ; FormData formData _NUM = new FormData ( ) ; formData _NUM . top = new FormAttachment ( _NUM ) ; formData _NUM . left = new FormAttachment ( _NUM ) ; formData _NUM . right = new FormAttachment ( _NUM _NUM _NUM ) ; feedbackLabel . setLayoutData ( formData _NUM ) ; progressComposite = new Composite ( feedbackComposite , SWT . NONE ) ; FormLayout formLayout _NUM = new FormLayout ( ) ; formLayout _NUM . spacing = _NUM ; progressComposite . setLayout ( formLayout _NUM ) ; FormData formData _NUM = new FormData ( ) ; formData _NUM . top = new FormAttachment ( feedbackLabel ) ; formData _NUM . bottom = new FormAttachment ( _NUM _NUM _NUM ) ; formData _NUM . left = new FormAttachment ( _NUM ) ; formData _NUM . right = new FormAttachment ( _NUM _NUM _NUM ) ; progressComposite . setLayoutData ( formData _NUM ) ; progressComposite . setBackground ( Display . getCurrent ( ) . getSystemColor ( SWT . COLOR _ CYAN ) ) ; progressBar = new ProgressBar ( progressComposite , SWT . NONE ) ; FormData formData _NUM = new FormData ( ) ; formData _NUM . bottom = new FormAttachment ( _NUM _NUM _NUM ) ; formData _NUM . left = new FormAttachment ( _NUM ) ; formData _NUM . height = progressBar . computeSize ( SWT . DEFAULT , SWT . DEFAULT , false ) . y ; progressBar . setLayoutData ( formData _NUM ) ; progressCancelButton = new Button ( progressComposite , SWT . NONE ) ; progressCancelButton . setText ( textCancel ) ; FormData formData _NUM = new FormData ( ) ; formData _NUM . right = new FormAttachment ( _NUM _NUM _NUM ) ; progressCancelButton . setLayoutData ( formData _NUM ) ; formData _NUM . right = new FormAttachment ( progressCancelButton ) ; progressCancelButton . addSelectionListener ( new SelectionAdapter ( ) { @ Override public void widgetSelected ( SelectionEvent e ) { editControl . stopSearching ( ) ; } } ) ; progressComposite . setVisible ( false ) ; closeButton = new Button ( sShell , SWT . NONE ) ; closeButton . setText ( textClose ) ; FormData formData _NUM = new FormData ( ) ; formData _NUM . right = new FormAttachment ( _NUM _NUM _NUM ) ; formData _NUM . bottom = new FormAttachment ( _NUM _NUM _NUM ) ; closeButton . setLayoutData ( formData _NUM ) ; closeButton . addSelectionListener ( new SelectionAdapter ( ) { @ Override public void widgetSelected ( SelectionEvent e ) { sShell . close ( ) ; } } ) ; formData _NUM . right = new FormAttachment ( closeButton ) ; sShell . addListener ( SWT . Close , new Listener ( ) { @ Override public void handleEvent ( Event event ) { editControl . stopSearching ( ) ; } } ) ; } 
1145	public void resetTransition ( ) { mAlpha = _NUM ; mTransitionState = TRANSITION _ NONE ; invalidateSelf ( ) ; } 
1146	private ArrayList < OutputEvent > filterByRelationship ( ArrayList < OutputEvent > events ) { ArrayList < OutputEvent > newEvents = new ArrayList < OutputEvent > ( ) ; init eventsFlag int [ ] eventsFlag = new int [ events . size ( ) ] ; for ( int i = _NUM ; i < eventsFlag . length ; i + + ) { eventsFlag [ i ] = _NUM ; } for ( int i = _NUM ; i < events . size ( ) ; i + + ) { if ( _NUM = = eventsFlag [ i ] ) { continue ; } OutputEvent outputEvent = events . get ( i ) ; ArrayList < OutputEvent > eventFamily = getEventsByRelationship ( events , outputEvent ) ; get the longest family string Collections . sort ( eventFamily , new SortByFamilyString ( ) ) ; newEvents . add ( eventFamily . get ( _NUM ) ) ; mark event which have been handled for ( int j = _NUM ; j < events . size ( ) ; j + + ) { eventsFlag [ j ] = eventFamily . contains ( events . get ( j ) ) ? _NUM : _NUM ; } } return newEvents ; } 
1147	public synchronized Value collection ( final QueryInput qi , final InputInfo info ) throws QueryException { return default collection if ( qi = = null ) { if ( colls . isEmpty ( ) ) throw NODEFCOLL . get ( info ) ; return colls . get ( _NUM ) ; } favor default database Data data = globalData ( ) ; if ( data ! = null & & qc . context . options . get ( MainOptions . DEFAULTDB ) ) { final IntList pres = data . resources . docs ( qi . original ) ; return DBNodeSeq . get ( pres , data , true , qi . original . isEmpty ( ) ) ; } check currently opened collections ( required for tests ) final int cs = colls . size ( ) ; for ( int c = _NUM ; c < cs ; c + + ) { final String name = collNames . get ( c ) , path = qi . io . path ( ) ; if ( Prop . CASE ? name . equals ( path ) : name . equalsIgnoreCase ( path ) ) { return colls . get ( c ) ; } } access open database or create new one data = data ( qi , info , false ) ; final IntList docs = data . resources . docs ( qi . dbPath ) ; return DBNodeSeq . get ( docs , data , true , qi . dbPath . isEmpty ( ) ) ; } 
1148	public void testUpdateId ( ) throws Exception { CmsObject cms = getCmsObject ( ) ; echo ( _STR ) , true ) ; } 
1149	private UnfilteredRowIterator withSSTablesIterated ( List < UnfilteredRowIterator > iterators , TableMetrics metrics , SSTableReadMetricsCollector metricsCollector ) { Closed through the closing of the result of the caller method . @ SuppressWarnings ( _STR , mergedSSTablesIterated ) ; } } ; return Transformation . apply ( merged , new UpdateSstablesIterated ( ) ) ; } 
1150	public void readsSpanningBoundary ( ) { StreamTester st = createStreamTester ( _NUM x _NUM _NUM , _STR , _NUM x _NUM _NUM C _NUM _NUM _NUM _NUM _NUM ) ; st . rollForward ( _NUM x _NUM _NUM _NUM _NUM , _NUM x _NUM _NUM FC ) ; st . confirmLong ( _NUM x _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM E _NUM A _NUM EEFL ) ; st . rollForward ( _NUM x _NUM _NUM _NUM _NUM , _NUM x _NUM _NUM FE ) ; st . confirmInt ( _NUM xD _NUM _NUM E _NUM _NUM CC ) ; st . rollForward ( _NUM x _NUM _NUM _NUM _NUM , _NUM x _NUM BFF ) ; st . confirmShort ( _NUM x _NUM B _NUM _NUM ) ; st . assertNoErrors ( ) ; } 
1151	public static Model loadModel ( String uri ) { Model m = createModel ( ) ; read ( m , uri ) ; return m ; } 
1152	private boolean mmapOperation ( ) { boolean isSuccess = false ; AllocateRequest req = null ; try { req = this . requestQueue . take ( ) ; AllocateRequest expectedRequest = this . requestTable . get ( req . getFilePath ( ) ) ; if ( null = = expectedRequest ) { log . warn ( _STR , e ) ; this . hasException = true ; if ( null ! = req ) { requestQueue . offer ( req ) ; try { Thread . sleep ( _NUM ) ; } catch ( InterruptedException ignored ) { } } } finally { if ( req ! = null & & isSuccess ) req . getCountDownLatch ( ) . countDown ( ) ; } return true ; } 
1153	public LayoutInflater onGetLayoutInflater ( Bundle savedInstanceState ) { if ( mHost = = null ) { throw new IllegalStateException ( _STR ) ; } final LayoutInflater result = mHost . onGetLayoutInflater ( ) ; if ( mHost . onUseFragmentManagerInflaterFactory ( ) ) { Init if needed ; use raw implementation below . getChildFragmentManager ( ) ; result . setPrivateFactory ( mChildFragmentManager . getLayoutInflaterFactory ( ) ) ; } return result ; } 
1154	private Component createInstance ( final ComponentEntry root , final EditableResources res , Container rootCnt , final Container parentContainer , final ArrayList < Runnable > postCreateTasks ) { try { final Component c = createComponentType ( root . getType ( ) ) ; if ( rootCnt = = null ) { rootCnt = ( Container ) c ; } final Container rootContainer = rootCnt ; if ( root . getBaseForm ( ) ! = null ) { c . putClientProperty ( _STR , JOptionPane . ERROR _ MESSAGE ) ; return null ; } } 
1155	static < T > VarOptItemsSketch < T > newInstanceFromUnionResult ( final ArrayList < T > dataList , final ArrayList < Double > weightList , final int k , final long n , final int hCount , final int rCount , final double totalWtR ) { final VarOptItemsSketch < T > sketch = new VarOptItemsSketch < > ( dataList , weightList , k , n , dataList . size ( ) , DEFAULT _ RESIZE _ FACTOR , hCount , rCount , totalWtR ) ; sketch . convertToHeap ( ) ; return sketch ; } 
1156	public TimeSeriesDataItem getDataItem ( RegularTimePeriod period ) { int index = getIndex ( period ) ; if ( index > = _NUM ) { return ( TimeSeriesDataItem ) this . data . get ( index ) ; } else { return null ; } } 
1157	public static byte [ ] encodeName ( String name ) { int length = name . length ( ) ; ByteBuffer buf = new ByteBuffer ( length + _NUM _NUM ) ; buf . append ( ' / ' ) ; char c ; char [ ] chars = name . toCharArray ( ) ; for ( int k = _NUM ; k < length ; k + + ) { c = ( char ) ( chars [ k ] & _NUM xff ) ; Escape special characters switch ( c ) { case ' ' : case ' % ' : case ' ( ' : case ' ) ' : case ' < ' : case ' > ' : case ' [ ' : case ' ] ' : case ' { ' : case ' } ' : case ' / ' : case ' # ' : buf . append ( ' # ' ) ; buf . append ( Integer . toString ( c , _NUM _NUM ) ) ; break ; default : if ( c > = _NUM _NUM & & c < = _NUM _NUM _NUM ) buf . append ( c ) ; else { buf . append ( ' # ' ) ; if ( c < _NUM _NUM ) buf . append ( ' _NUM ' ) ; buf . append ( Integer . toString ( c , _NUM _NUM ) ) ; } break ; } } return buf . toByteArray ( ) ; } 
1158	public void addSession ( MediaSessionRecord record ) { mSessions . add ( record ) ; clearCache ( record . getUserId ( ) ) ; Update the media button session . The added session could be the session from the package with the audio playback . This can happen if an app starts audio playback before creating media session . updateMediaButtonSessionIfNeeded ( ) ; } 
1159	public static boolean hasText ( CharSequence str ) { if ( ! hasLength ( str ) ) { return false ; } int strLen = str . length ( ) ; for ( int i = _NUM ; i < strLen ; i + + ) { if ( ! Character . isWhitespace ( str . charAt ( i ) ) ) { return true ; } } return false ; } 
1160	public static boolean deleteFile ( String path ) { if ( TextUtils . isEmpty ( path ) ) { return true ; } File file = new File ( path ) ; if ( ! file . exists ( ) ) { return true ; } if ( file . isFile ( ) ) { return file . delete ( ) ; } if ( ! file . isDirectory ( ) ) { return false ; } for ( File f : file . listFiles ( ) ) { if ( f . isFile ( ) ) { f . delete ( ) ; } else if ( f . isDirectory ( ) ) { deleteFile ( f . getAbsolutePath ( ) ) ; } } return file . delete ( ) ; } 
1161	public V putIfAbsent ( K key , V value ) { V v = get ( key ) ; if ( v = = null ) { v = put ( key , value ) ; } return v ; } 
1162	 $ ANTLR start _STR , _NUM _NUM _NUM , _NUM , input ) ; throw nvae ; } switch ( alt _NUM _NUM _NUM ) { case _NUM : JPA _NUM . g : _NUM _NUM _NUM : _NUM : path _ expression { root _ _NUM = ( Object ) adaptor . nil ( ) ; pushFollow ( FOLLOW _ path _ expression _ in _ boolean _ expression _NUM _NUM _NUM _NUM ) ; path _ expression _NUM _NUM _NUM = path _ expression ( ) ; state . _ fsp - - ; if ( state . failed ) return retval ; if ( state . backtracking = = _NUM ) adaptor . addChild ( root _ _NUM , path _ expression _NUM _NUM _NUM . getTree ( ) ) ; } break ; case _NUM : JPA _NUM . g : _NUM _NUM _NUM : _NUM : boolean _ literal { root _ _NUM = ( Object ) adaptor . nil ( ) ; pushFollow ( FOLLOW _ boolean _ literal _ in _ boolean _ expression _NUM _NUM _NUM _NUM ) ; boolean _ literal _NUM _NUM _NUM = boolean _ literal ( ) ; state . _ fsp - - ; if ( state . failed ) return retval ; if ( state . backtracking = = _NUM ) adaptor . addChild ( root _ _NUM , boolean _ literal _NUM _NUM _NUM . getTree ( ) ) ; } break ; case _NUM : JPA _NUM . g : _NUM _NUM _NUM : _NUM : input _ parameter { root _ _NUM = ( Object ) adaptor . nil ( ) ; pushFollow ( FOLLOW _ input _ parameter _ in _ boolean _ expression _NUM _NUM _NUM _NUM ) ; input _ parameter _NUM _NUM _NUM = input _ parameter ( ) ; state . _ fsp - - ; if ( state . failed ) return retval ; if ( state . backtracking = = _NUM ) adaptor . addChild ( root _ _NUM , input _ parameter _NUM _NUM _NUM . getTree ( ) ) ; } break ; case _NUM : JPA _NUM . g : _NUM _NUM _NUM : _NUM : case _ expression { root _ _NUM = ( Object ) adaptor . nil ( ) ; pushFollow ( FOLLOW _ case _ expression _ in _ boolean _ expression _NUM _NUM _NUM _NUM ) ; case _ expression _NUM _NUM _NUM = case _ expression ( ) ; state . _ fsp - - ; if ( state . failed ) return retval ; if ( state . backtracking = = _NUM ) adaptor . addChild ( root _ _NUM , case _ expression _NUM _NUM _NUM . getTree ( ) ) ; } break ; case _NUM : JPA _NUM . g : _NUM _NUM _NUM : _NUM : function _ invocation { root _ _NUM = ( Object ) adaptor . nil ( ) ; pushFollow ( FOLLOW _ function _ invocation _ in _ boolean _ expression _NUM _NUM _NUM _NUM ) ; function _ invocation _NUM _NUM _NUM = function _ invocation ( ) ; state . _ fsp - - ; if ( state . failed ) return retval ; if ( state . backtracking = = _NUM ) adaptor . addChild ( root _ _NUM , function _ invocation _NUM _NUM _NUM . getTree ( ) ) ; } break ; case _NUM : JPA _NUM . g : _NUM _NUM _NUM : _NUM : extension _ functions { root _ _NUM = ( Object ) adaptor . nil ( ) ; pushFollow ( FOLLOW _ extension _ functions _ in _ boolean _ expression _NUM _NUM _NUM _NUM ) ; extension _ functions _NUM _NUM _NUM = extension _ functions ( ) ; state . _ fsp - - ; if ( state . failed ) return retval ; if ( state . backtracking = = _NUM ) adaptor . addChild ( root _ _NUM , extension _ functions _NUM _NUM _NUM . getTree ( ) ) ; } break ; case _NUM : JPA _NUM . g : _NUM _NUM _NUM : _NUM : subquery { root _ _NUM = ( Object ) adaptor . nil ( ) ; pushFollow ( FOLLOW _ subquery _ in _ boolean _ expression _NUM _NUM _NUM _NUM ) ; subquery _NUM _NUM _NUM = subquery ( ) ; state . _ fsp - - ; if ( state . failed ) return retval ; if ( state . backtracking = = _NUM ) adaptor . addChild ( root _ _NUM , subquery _NUM _NUM _NUM . getTree ( ) ) ; } break ; } retval . stop = input . LT ( - _NUM ) ; if ( state . backtracking = = _NUM ) { retval . tree = ( Object ) adaptor . rulePostProcessing ( root _ _NUM ) ; adaptor . setTokenBoundaries ( retval . tree , retval . start , retval . stop ) ; } } catch ( RecognitionException re ) { reportError ( re ) ; recover ( input , re ) ; retval . tree = ( Object ) adaptor . errorNode ( input , retval . start , input . LT ( - _NUM ) , re ) ; } finally { do for sure before leaving } return retval ; } 
1163	public void abortBlock ( ) throws Exception { TieredBlockStoreTestUtils . createTempBlock ( SESSION _ ID _NUM , TEMP _ BLOCK _ ID , BLOCK _ SIZE , mTestDir _NUM ) ; mBlockStore . abortBlock ( SESSION _ ID _NUM , TEMP _ BLOCK _ ID ) ; assertFalse ( mTestDir _NUM . hasBlockMeta ( BLOCK _ ID _NUM ) ) ; assertFalse ( mBlockStore . hasBlockMeta ( TEMP _ BLOCK _ ID ) ) ; assertFalse ( FileUtils . exists ( TempBlockMeta . tempPath ( mTestDir _NUM , SESSION _ ID _NUM , TEMP _ BLOCK _ ID ) ) ) ; assertFalse ( FileUtils . exists ( TempBlockMeta . commitPath ( mTestDir _NUM , TEMP _ BLOCK _ ID ) ) ) ; } 
1164	protected void checkDeleteFrontsTriples ( final ExtendedIterator < ? extends FrontsTriple > frontsTriplesIter ) throws DeleteDeniedException , AuthenticationRequiredException { if ( ! canDelete ( Triple . ANY ) ) { try { while ( frontsTriplesIter . hasNext ( ) ) { checkDelete ( frontsTriplesIter . next ( ) ) ; } } finally { frontsTriplesIter . close ( ) ; } } } 
1165	public void actionPerformed ( final ActionEvent event ) { if ( event . getActionCommand ( ) . equals ( _STR ) ) { handleCombo _NUM Change ( ) ; } } 
1166	void cancelExecutingJobLocked ( int reason , String debugReason ) { doCancelLocked ( reason , debugReason ) ; } 
1167	public static boolean isInstrumentationAccessAllowed ( ServletContext servletContext , HttpServletRequest request , HttpServletResponse response ) throws IOException { Configuration conf = ( Configuration ) servletContext . getAttribute ( CONF _ CONTEXT _ ATTRIBUTE ) ; boolean access = true ; boolean adminAccess = conf . getBoolean ( CommonConfigurationKeys . HADOOP _ SECURITY _ INSTRUMENTATION _ REQUIRES _ ADMIN , false ) ; if ( adminAccess ) { access = hasAdministratorAccess ( servletContext , request , response ) ; } return access ; } 
1168	public static < T > TimestampedValues < T > timestamped ( Iterable < T > values , Iterable < Long > timestamps ) { List < TimestampedValue < T > > elems = new ArrayList < > ( ) ; Iterator < T > valueIter = values . iterator ( ) ; Iterator < Long > timestampIter = timestamps . iterator ( ) ; while ( valueIter . hasNext ( ) & & timestampIter . hasNext ( ) ) { elems . add ( TimestampedValue . of ( valueIter . next ( ) , new Instant ( timestampIter . next ( ) ) ) ) ; } checkArgument ( ! valueIter . hasNext ( ) & & ! timestampIter . hasNext ( ) , _STR ) ; return timestamped ( elems ) ; } 
1169	private void openNiDialog ( GpsNiNotification notif ) { Intent intent = getDlgIntent ( notif ) ; if ( DEBUG ) Log . d ( TAG , _STR + notif . text ) ; mContext . startActivity ( intent ) ; } 
1170	public synchronized void setEndpoint ( String endpoint ) { URI uri = toURI ( endpoint ) ; this . endpoint = uri ; if ( isIpOrLocalhost ( uri ) ) { serviceClient . getClientConfiguration ( ) . setSLDEnabled ( true ) ; } this . bucketOperation . setEndpoint ( uri ) ; this . objectOperation . setEndpoint ( uri ) ; this . multipartOperation . setEndpoint ( uri ) ; this . corsOperation . setEndpoint ( uri ) ; this . liveChannelOperation . setEndpoint ( uri ) ; this . udfOperation . setEndpoint ( uri ) ; } 
1171	public void cloneNonPositionParameters ( Rectangle rect ) { throwReadOnlyError ( ) ; } 
1172	public void actionPreview ( ) throws IOException , JspException { try { save content of the editor only to the temporary file setEditorValues ( getElementLocale ( ) ) ; writeContent ( ) ; remove eventual release & expiration date from temporary file to make preview work getCms ( ) . setDateReleased ( getParamTempfile ( ) , CmsResource . DATE _ RELEASED _ DEFAULT , false ) ; getCms ( ) . setDateExpired ( getParamTempfile ( ) , CmsResource . DATE _ EXPIRED _ DEFAULT , false ) ; } catch ( CmsException e ) { show error page showErrorPage ( this , e ) ; } get preview uri from content handler String previewUri = m _ content . getHandler ( ) . getPreview ( getCms ( ) , m _ content , getParamTempfile ( ) ) ; create locale request parameter StringBuffer param = new StringBuffer ( _NUM ) ; if ( previewUri . indexOf ( ' ? ' ) ! = - _NUM ) { param . append ( _STR ) ; param . append ( getParamElementlanguage ( ) ) ; redirect to the temporary file with currently active element language or to the specified preview uri sendCmsRedirect ( previewUri + param ) ; } 
1173	public void postponedAddAnimators ( ) throws Throwable { final FragmentManager fm = mActivityRule . getActivity ( ) . getSupportFragmentManager ( ) ; final AnimatorFragment fragment = new AnimatorFragment ( ) ; fragment . postponeEnterTransition ( ) ; fm . beginTransaction ( ) . setCustomAnimations ( ENTER , EXIT , POP _ ENTER , POP _ EXIT ) . add ( R . id . fragmentContainer , fragment ) . addToBackStack ( null ) . setReorderingAllowed ( true ) . commit ( ) ; FragmentTestUtil . waitForExecution ( mActivityRule ) ; assertPostponed ( fragment , _NUM ) ; fragment . startPostponedEnterTransition ( ) ; FragmentTestUtil . waitForExecution ( mActivityRule ) ; assertEnterPopExit ( fragment ) ; } 
1174	public byte [ ] getThumbnail ( ) { if ( mThumbnailCompression = = DATA _ JPEG | | mThumbnailCompression = = DATA _ JPEG _ COMPRESSED ) { return getThumbnailBytes ( ) ; } return null ; } 
1175	public void release ( ) { try { stop ( ) ; } catch ( IllegalStateException ise ) { don ' t raise an exception , we ' re releasing the resources . } native _ release ( ) ; mState = STATE _ UNINITIALIZED ; } 
1176	public static < V > int distinctList ( List < V > sourceList ) { if ( isEmpty ( sourceList ) ) { return _NUM ; } int sourceCount = sourceList . size ( ) ; int sourceListSize = sourceList . size ( ) ; for ( int i = _NUM ; i < sourceListSize ; i + + ) { for ( int j = ( i + _NUM ) ; j < sourceListSize ; j + + ) { if ( sourceList . get ( i ) . equals ( sourceList . get ( j ) ) ) { sourceList . remove ( j ) ; sourceListSize = sourceList . size ( ) ; j - - ; } } } return sourceCount - sourceList . size ( ) ; } 
1177	public Map < String , Object > toStringMap ( ) { Map < String , Object > stringMap = new HashMap < > ( ) ; stringMap . put ( _STR , tagsString ) ; } return stringMap ; } 
1178	public void testFileCreationError _NUM ( ) throws IOException { long leasePeriod = _NUM _NUM _NUM _NUM ; System . out . println ( _STR ) ; } finally { IOUtils . closeStream ( dfs ) ; cluster . shutdown ( ) ; } } 
1179	public static Expression regexReplaceAll ( final Expression expression , final String regex , final Expression replacementExpression ) { final Pattern pattern = Pattern . compile ( regex ) ; return new ExpressionAdapter ( ) { public Object evaluate ( Exchange exchange ) { String text = expression . evaluate ( exchange , String . class ) ; String replacement = replacementExpression . evaluate ( exchange , String . class ) ; if ( text = = null | | replacement = = null ) { return null ; } return pattern . matcher ( text ) . replaceAll ( replacement ) ; } @ Override public String toString ( ) { return _STR ; } } ; } 
1180	public static String getDontShowDialogResponse ( String dialogName ) throws Exception { if ( ! getDontShowDialog ( dialogName ) ) { This must be the first time - no file recorded yet . return null ; } File wekaHome = WekaPackageManager . WEKA _ HOME ; File dialogSubDir = new File ( wekaHome . toString ( ) + File . separator + _STR + File . separator + dialogName ) ; BufferedReader br = new BufferedReader ( new FileReader ( dialogSubDir ) ) ; String response = br . readLine ( ) ; br . close ( ) ; return response ; } 
1181	public String toClassDetailsString ( String title ) throws Exception { if ( ! m _ ClassIsNominal ) { throw new Exception ( _STR ) ; return text . toString ( ) ; } 
1182	public static File getUserDirectory ( ) { return new File ( getUserDirectoryPath ( ) ) ; } 
1183	private void fadeDimmedBackground ( ) { mBackgroundDimmed . animate ( ) . cancel ( ) ; mBackgroundNormal . animate ( ) . cancel ( ) ; if ( mActivated ) { updateBackground ( ) ; return ; } if ( ! shouldHideBackground ( ) ) { if ( mDimmed ) { mBackgroundDimmed . setVisibility ( View . VISIBLE ) ; } else { mBackgroundNormal . setVisibility ( View . VISIBLE ) ; } } float startAlpha = mDimmed ? _NUM f : _NUM ; float endAlpha = mDimmed ? _NUM : _NUM f ; int duration = BACKGROUND _ ANIMATION _ LENGTH _ MS ; Check whether there is already a background animation running . if ( mBackgroundAnimator ! = null ) { startAlpha = ( Float ) mBackgroundAnimator . getAnimatedValue ( ) ; duration = ( int ) mBackgroundAnimator . getCurrentPlayTime ( ) ; mBackgroundAnimator . removeAllListeners ( ) ; mBackgroundAnimator . cancel ( ) ; if ( duration < = _NUM ) { updateBackground ( ) ; return ; } } mBackgroundNormal . setAlpha ( startAlpha ) ; mBackgroundAnimator = ObjectAnimator . ofFloat ( mBackgroundNormal , View . ALPHA , startAlpha , endAlpha ) ; mBackgroundAnimator . setInterpolator ( Interpolators . FAST _ OUT _ SLOW _ IN ) ; mBackgroundAnimator . setDuration ( duration ) ; mBackgroundAnimator . addListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationEnd ( Animator animation ) { updateBackground ( ) ; mBackgroundAnimator = null ; if ( mFadeInFromDarkAnimator = = null ) { mDimmedBackgroundFadeInAmount = - _NUM ; } } } ) ; mBackgroundAnimator . addUpdateListener ( mBackgroundVisibilityUpdater ) ; mBackgroundAnimator . start ( ) ; } 
1184	public boolean nextRawKey ( ) throws IOException { if ( in = = null ) { int bufferSize = getBufferSize ( conf ) ; Reader reader = new Reader ( conf , Reader . file ( segmentPathName ) , Reader . bufferSize ( bufferSize ) , Reader . start ( segmentOffset ) , Reader . length ( segmentLength ) ) ; sometimes we ignore syncs especially for temp merge files if ( ignoreSync ) reader . ignoreSync ( ) ; if ( reader . getKeyClass ( ) ! = keyClass ) throw new IOException ( _STR + valClass ) ; this . in = reader ; rawKey = new DataOutputBuffer ( ) ; } rawKey . reset ( ) ; int keyLength = in . nextRawKey ( rawKey ) ; return ( keyLength > = _NUM ) ; } 
1185	Map < String , String > createIndexedData ( String . . . additionalPrefixes ) { String prefix = createPrefix ( ) ; take over any potential prefixes we may have been asked for if ( additionalPrefixes . length > _NUM ) { StringBuilder sb = new StringBuilder ( prefix ) ; for ( String additionalPrefix : additionalPrefixes ) { sb . append ( additionalPrefix ) . append ( _STR , key , value ) ; Map < String , String > map = new HashMap < String , String > ( ) ; map . put ( key , value ) ; return map ; } 
1186	public void noOrderIterator ( ) throws Exception { List < AlluxioURI > storeUris = new ArrayList < > ( ) ; List < List < KeyValuePair > > keyValuePairs = new ArrayList < > ( ) ; List < KeyValuePair > pairs = new ArrayList < > ( ) ; storeUris . add ( createStoreOfSize ( _NUM , pairs ) ) ; keyValuePairs . add ( pairs ) ; pairs = new ArrayList < > ( ) ; storeUris . add ( createStoreOfSize ( _NUM , pairs ) ) ; keyValuePairs . add ( pairs ) ; pairs = new ArrayList < > ( ) ; storeUris . add ( createStoreOfMultiplePartitions ( _NUM , pairs ) ) ; keyValuePairs . add ( pairs ) ; int numStoreUri = storeUris . size ( ) ; for ( int i = _NUM ; i < numStoreUri ; i + + ) { List < KeyValuePair > expectedPairs = keyValuePairs . get ( i ) ; List < KeyValuePair > iteratedPairs = new ArrayList < > ( ) ; mReader = sKeyValueSystem . openStore ( storeUris . get ( i ) ) ; KeyValueIterator iterator = mReader . iterator ( ) ; while ( iterator . hasNext ( ) ) { iteratedPairs . add ( iterator . next ( ) ) ; } If size is not the same , no need for the time - consuming list comparison below . Assert . assertEquals ( expectedPairs . size ( ) , iteratedPairs . size ( ) ) ; Sorts and then compares pairs and iteratedPairs . Collections . sort ( expectedPairs ) ; Collections . sort ( iteratedPairs ) ; Assert . assertEquals ( expectedPairs , iteratedPairs ) ; } } 
1187	protected String getOpenPreviewCall ( I _ CmsWidgetDialog widgetDialog , String id ) { StringBuffer sb = new StringBuffer ( _NUM _NUM ) ; sb . append ( _STR ) ; return sb . toString ( ) ; } 
1188	public static INDArray create ( float [ ] data , char order ) { INDArray ret = INSTANCE . create ( data , order ) ; logCreationIfNecessary ( ret ) ; return ret ; } 
1189	public void testLoadAIF ( ) { SupBookRecord record = new SupBookRecord ( TestcaseRecordInputStream . create ( _NUM x _NUM _NUM AE , dataAIF ) ) ; expected flag assertTrue ( record . isAddInFunctions ( ) ) ; expected # of sheets assertEquals ( _NUM x _NUM , record . getNumberOfSheets ( ) ) ; sid + size + data assertEquals ( _NUM , record . getRecordSize ( ) ) ; } 
1190	private void replaceImpl ( final int startIndex , final int endIndex , final int removeLen , final String insertStr , final int insertLen ) { final int newSize = size - removeLen + insertLen ; if ( insertLen ! = removeLen ) { ensureCapacity ( newSize ) ; System . arraycopy ( buffer , endIndex , buffer , startIndex + insertLen , size - endIndex ) ; size = newSize ; } if ( insertLen > _NUM ) { insertStr . getChars ( _NUM , insertLen , buffer , startIndex ) ; } } 
1191	public void setAntiAliasingEnabled ( boolean enabled ) { boolean currentlyEnabled = aaHints ! = null ; if ( enabled ! = currentlyEnabled ) { if ( enabled ) { aaHints = RSyntaxUtilities . getDesktopAntiAliasHints ( ) ; call worked . if ( aaHints = = null ) { Map < RenderingHints . Key , Object > temp = new HashMap < RenderingHints . Key , Object > ( ) ; temp . put ( RenderingHints . KEY _ TEXT _ ANTIALIASING , RenderingHints . VALUE _ TEXT _ ANTIALIAS _ ON ) ; aaHints = temp ; } } else { aaHints = null ; } to be non - null . if ( isDisplayable ( ) ) { refreshFontMetrics ( getGraphics _NUM D ( getGraphics ( ) ) ) ; } firePropertyChange ( ANTIALIAS _ PROPERTY , ! enabled , enabled ) ; repaint ( ) ; } } 
1192	public void assertIsNotZero ( Description description , BigDecimal actual ) { comparables . assertNotEqual ( description , actual , ZERO ) ; } 
1193	protected Optional < Dataset > createJobProps ( Dataset dataset ) throws IOException { if ( this . recompactFromOutputPaths & & ( ! latePathsFound ( dataset ) ) ) { LOG . info ( String . format ( _STR , dataset . inputPaths ( ) , dataset . outputPath ( ) ) ) ; dataset . setJobProps ( jobProps ) ; return Optional . of ( dataset ) ; } else { return obtainDatasetWithJobProps ( jobProps , dataset ) ; } } 
1194	private synchronized String clientsString ( ) { if ( dfsclients . isEmpty ( ) ) { return _STR ) . toString ( ) ; } } 
1195	private void installIfAvailable ( ) { if ( mInstallBundle = = null | | mInstallBundle . isEmpty ( ) ) { return ; } Bundle bundle = mInstallBundle ; mInstallBundle = null ; final int uid = bundle . getInt ( Credentials . EXTRA _ INSTALL _ AS _ UID , KeyStore . UID _ SELF ) ; if ( uid ! = KeyStore . UID _ SELF & & ! UserHandle . isSameUser ( uid , Process . myUid ( ) ) ) { int dstUserId = UserHandle . getUserId ( uid ) ; int myUserId = UserHandle . myUserId ( ) ; Restrict install target to the wifi uid . if ( uid ! = Process . WIFI _ UID ) { Log . e ( TAG , _STR + uid ) ; return ; } } Send the broadcast . Intent broadcast = new Intent ( KeyChain . ACTION _ KEYCHAIN _ CHANGED ) ; sendBroadcast ( broadcast ) ; setResult ( RESULT _ OK ) ; } 
1196	public static void writeToPath ( BitMatrix matrix , String format , Path file , MatrixToImageConfig config ) throws IOException { BufferedImage image = toBufferedImage ( matrix , config ) ; if ( ! ImageIO . write ( image , format , file . toFile ( ) ) ) { throw new IOException ( _STR + file ) ; } } 
1197	public void listPage ( PdfImportedPage iPage ) { int pageNum = iPage . getPageNumber ( ) ; PdfReaderInstance readerInst = iPage . getPdfReaderInstance ( ) ; PdfReader reader = readerInst . getReader ( ) ; PdfDictionary page = reader . getPageN ( pageNum ) ; listDict ( page ) ; PdfObject obj = PdfReader . getPdfObject ( page . get ( PdfName . CONTENTS ) ) ; if ( obj = = null ) return ; switch ( obj . type ) { case PdfObject . STREAM : listStream ( ( PRStream ) obj , readerInst ) ; break ; case PdfObject . ARRAY : for ( Iterator i = ( ( PdfArray ) obj ) . listIterator ( ) ; i . hasNext ( ) ; ) { PdfObject o = PdfReader . getPdfObject ( ( PdfObject ) i . next ( ) ) ; listStream ( ( PRStream ) o , readerInst ) ; out . println ( _STR ) ; } break ; } } 
1198	private void expand ( StringBuilder builder , String path , int indent ) { try { GetChildrenBuilder childrenBuilder = curator . getChildren ( ) ; List < String > children = childrenBuilder . forPath ( path ) ; for ( String child : children ) { String childPath = path + _STR ) ; } } 
1199	private String getLastUsedFieldName ( String fieldType , String templateId ) { Connection conn = null ; Statement stat = null ; ResultSet rs = null ; String fieldName = _STR ) ; break ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { DbPoolConnection . getInstance ( ) . closeResultSet ( rs ) ; DbPoolConnection . getInstance ( ) . closeStatment ( stat ) ; DbPoolConnection . getInstance ( ) . closeConn ( conn ) ; } return fieldName ; } 
1200	public void testAuthPolicyPrecedence ( ) throws Exception { Bus bus = new ExtensionManagerBus ( ) ; EndpointInfo ei = new EndpointInfo ( ) ; ei . setAddress ( _STR ) . get ( _NUM ) ) ; } 
1201	public PrintDocument getDocument ( ) { PrintService . throwIfNotCalledOnMainThread ( ) ; return mDocument ; } 
1202	public Object opt ( int index ) { return ( index < _NUM | | index > = length ( ) ) ? null : this . myArrayList . get ( index ) ; } 
1203	private boolean isListChildUnderClipped ( float x , float y ) { final View listChild = findListChildUnder ( x , y ) ; return listChild ! = null & & isDescendantClipped ( listChild ) ; } 
1204	public static String toString ( Properties properties ) throws IOException { StringWriter writer = new StringWriter ( ) ; properties . store ( writer , null ) ; StringBuffer stringBuffer = writer . getBuffer ( ) ; filterPropertiesComment ( stringBuffer ) ; return stringBuffer . toString ( ) ; } 
1205	public void compile ( Script script , boolean performHOPRewrites ) { main steps in script execution setup ( script ) ; if ( statistics ) { Statistics . startCompileTimer ( ) ; } parseScript ( ) ; liveVariableAnalysis ( ) ; validateScript ( ) ; constructHops ( ) ; if ( performHOPRewrites ) rewriteHops ( ) ; rewritePersistentReadsAndWrites ( ) ; constructLops ( ) ; generateRuntimeProgram ( ) ; showExplanation ( ) ; countCompiledMRJobsAndSparkInstructions ( ) ; initializeCachingAndScratchSpace ( ) ; cleanupRuntimeProgram ( ) ; if ( statistics ) { Statistics . stopCompileTimer ( ) ; } } 
1206	public CollectionDatasource buildCollectionDatasource ( ) { init ( ) ; CollectionDatasource datasource ; try { if ( master = = null & & property = = null ) { if ( dsClass = = null ) { datasource = createCollectionDatasource ( ) ; } else { datasource = ( CollectionDatasource ) dsClass . newInstance ( ) ; } datasource . setup ( dsContext , dataSupplier , id , metaClass , view ) ; if ( maxResults > _NUM ) datasource . setMaxResults ( maxResults ) ; else if ( metaClass ! = null ) datasource . setMaxResults ( getPersistenceManager ( ) . getMaxFetchUI ( metaClass . getName ( ) ) ) ; if ( datasource instanceof AbstractCollectionDatasource ) ( ( AbstractCollectionDatasource ) datasource ) . setRefreshMode ( refreshMode ) ; } else { if ( dsClass = = null ) { datasource = createCollectionPropertyDatasource ( ) ; } else { datasource = ( CollectionDatasource ) dsClass . newInstance ( ) ; } ( ( NestedDatasource ) datasource ) . setup ( id , master , property ) ; } } catch ( InstantiationException | IllegalAccessException e ) { throw new RuntimeException ( e ) ; } datasource . setSoftDeletion ( softDeletion ) ; datasource . setCacheable ( cacheable ) ; datasource . setAllowCommit ( allowCommit ) ; registerDatasource ( datasource ) ; return datasource ; } 
1207	public static boolean dumpService ( String name , FileDescriptor fd , String [ ] args ) { IBinder service = ServiceManager . getService ( name ) ; if ( service = = null ) { Log . e ( TAG , _STR + name , e ) ; return false ; } } 
1208	public void setBorderColorTop ( Color borderColorTop ) { throwReadOnlyError ( ) ; } 
1209	public long readUTCDate ( ) throws IOException { int tag = read ( ) ; if ( tag = = BC _ DATE ) { return parseLong ( ) ; } else if ( tag = = BC _ DATE _ MINUTE ) { return parseInt ( ) * _NUM _NUM _NUM _NUM _NUM L ; } else throw expect ( _STR , tag ) ; } 
1210	public Package getRepositoryPackageInfo ( String packageName , Object version ) throws Exception { if ( getPackageRepositoryURL ( ) = = null ) { throw new Exception ( _STR ; URL packageURL = new URL ( packageS ) ; URLConnection conn = null ; setup the proxy ( if we are using one ) and open the connect if ( setProxyAuthentication ( ) ) { conn = packageURL . openConnection ( m _ httpProxy ) ; } else { conn = packageURL . openConnection ( ) ; } BufferedInputStream bi = new BufferedInputStream ( conn . getInputStream ( ) ) ; Properties packageProperties = new Properties ( ) ; packageProperties . load ( bi ) ; bi . close ( ) ; return new DefaultPackage ( m _ packageHome , this , packageProperties ) ; } 
1211	public void setLabel ( String label , String lang ) { checkProfile ( getProfile ( ) . LABEL ( ) , _STR ) ; removeAll ( getProfile ( ) . LABEL ( ) ) ; addLabel ( label , lang ) ; } 
1212	public boolean visit ( Result data ) throws IOException { if ( data = = null | | data . size ( ) < = _NUM ) { return true ; } Pair < RegionInfo , ServerName > pair = new Pair < > ( MetaTableAccessor . getRegionInfo ( data ) , MetaTableAccessor . getServerName ( data , _NUM ) ) ; if ( ! pair . getFirst ( ) . getTable ( ) . equals ( tableName ) ) { return false ; } result . set ( pair ) ; return true ; } } ; MetaTableAccessor . scanMeta ( clusterConnection , visitor , tableName , rowKey , _NUM ) ; return result . get ( ) ; } 
1213	public void testMutatingOutputThenOutputDoFnError ( ) throws Exception { Pipeline pipeline = getPipeline ( ) ; pipeline . apply ( Create . of ( _NUM _NUM ) ) . apply ( ParDo . of ( new DoFn < Integer , List < Integer > > ( ) { @ ProcessElement public void processElement ( ProcessContext c ) { List < Integer > outputList = Arrays . asList ( _NUM , _NUM , _NUM , _NUM ) ; c . output ( outputList ) ; outputList . set ( _NUM , _NUM _NUM ) ; c . output ( outputList ) ; } } ) ) ; thrown . expect ( IllegalMutationException . class ) ; thrown . expectMessage ( _STR ) ; pipeline . run ( ) ; } 
1214	private String getFormattedNumberString ( Cell cell , ConditionalFormattingEvaluator cfEvaluator ) { Format numberFormat = getFormat ( cell , cfEvaluator ) ; double d = cell . getNumericCellValue ( ) ; if ( numberFormat = = null ) { return String . valueOf ( d ) ; } String formatted = numberFormat . format ( Double . valueOf ( d ) ) ; to match Excel ' s E - notation return formatted . replaceFirst ( _STR ) ; } 
1215	public TBigDecimal abs ( ) { return ( ( signum ( ) < _NUM ) ? negate ( ) : this ) ; } 
1216	private void tidy ( List < MenuItem > menuItems ) { int assistItemIndex = - _NUM ; Drawable assistItemDrawable = null ; final int size = menuItems . size ( ) ; for ( int i = _NUM ; i < size ; i + + ) { final MenuItem menuItem = menuItems . get ( i ) ; if ( menuItem . getItemId ( ) = = android . R . id . textAssist ) { assistItemIndex = i ; assistItemDrawable = menuItem . getIcon ( ) ; } Remove icons for all menu items with text . if ( ! TextUtils . isEmpty ( menuItem . getTitle ( ) ) ) { menuItem . setIcon ( null ) ; } } if ( assistItemIndex > - _NUM ) { final MenuItem assistMenuItem = menuItems . remove ( assistItemIndex ) ; Ensure the assist menu item preserves its icon . assistMenuItem . setIcon ( assistItemDrawable ) ; Ensure the assist menu item is always the first item . menuItems . add ( _NUM , assistMenuItem ) ; } } 
1217	public void testSortSearchResults ( ) throws Exception { CmsObject cms = getCmsObject ( ) ; echo ( _STR ) ; TestCmsSearch . printResults ( searchResult , cms ) ; i = searchResult . iterator ( ) ; while ( i . hasNext ( ) ) { CmsSearchResult res = i . next ( ) ; if ( lastTime > _NUM ) { make sure result is sorted correctly assertTrue ( lastTime > = res . getDateLastModified ( ) . getTime ( ) ) ; assertTrue ( res . getScore ( ) < = _NUM _NUM _NUM ) ; } lastTime = res . getDateLastModified ( ) . getTime ( ) ; } assertNull ( searchBean . getSearchResultCategories ( ) ) ; } 
1218	public static void configure ( Appender appender ) { Logger root = Logger . getRootLogger ( ) ; root . addAppender ( appender ) ; } 
1219	 @ Test @ LocalAlluxioClusterResource . Config ( confParams = { PropertyKey . Name . SECURITY _ AUTHORIZATION _ PERMISSION _ ENABLED , _STR , files [ _NUM ] . getLastModificationTimeMs ( ) , hSize , _NUM _NUM , STATE _ FILE _ NOT _ IN _ ALLUXIO , files [ _NUM ] . getPersistenceState ( ) ) ; Assert . assertEquals ( expected , mOutput . toString ( ) ) ; } 
1220	public void testCompressDecompress ( ) { int BYTE _ SIZE = _NUM _NUM _NUM _NUM * _NUM _NUM ; byte [ ] bytes = generate ( BYTE _ SIZE ) ; Lz _NUM Compressor compressor = new Lz _NUM Compressor ( ) ; try { compressor . setInput ( bytes , _NUM , bytes . length ) ; assertTrue ( _STR ) ; } } 
1221	public int size ( ) { return ifStatements . isEmpty ( ) ? actionSteps . size ( ) : actionSteps . size ( ) + _NUM ; } 
1222	public void testPut ( ) throws IOException { LOG . info ( _STR ) ; this . region = initHRegion ( tableName , getName ( ) , fam _NUM ) ; long value = _NUM L ; Put put = new Put ( row ) ; put . addColumn ( fam _NUM , qual _NUM , Bytes . toBytes ( value ) ) ; region . put ( put ) ; assertGet ( this . region , row , fam _NUM , qual _NUM , Bytes . toBytes ( value ) ) ; } 
1223	public static Map < String , Map < String , ActionConfig > > getActionConfigs ( ) { if ( ! isXWorkStarted ) initXWork ( ) ; return cm . getConfiguration ( ) . getRuntimeConfiguration ( ) . getActionConfigs ( ) ; } 
1224	public void removeTable ( XSSFTable t ) { long id = t . getCTTable ( ) . getId ( ) ; Map . Entry < String , XSSFTable > toDelete = null ; for ( Map . Entry < String , XSSFTable > entry : tables . entrySet ( ) ) { if ( entry . getValue ( ) . getCTTable ( ) . getId ( ) = = id ) toDelete = entry ; } if ( toDelete ! = null ) { removeRelation ( getRelationById ( toDelete . getKey ( ) ) , true ) ; tables . remove ( toDelete . getKey ( ) ) ; toDelete . getValue ( ) . onTableDelete ( ) ; } } 
1225	public CMSTimeStampedData addTimeStamp ( TimeStampToken token ) throws CMSException { TimeStampAndCRL [ ] timeStamps = util . getTimeStamps ( ) ; TimeStampAndCRL [ ] newTimeStamps = new TimeStampAndCRL [ timeStamps . length + _NUM ] ; System . arraycopy ( timeStamps , _NUM , newTimeStamps , _NUM , timeStamps . length ) ; newTimeStamps [ timeStamps . length ] = new TimeStampAndCRL ( token . toCMSSignedData ( ) . toASN _NUM Structure ( ) ) ; return new CMSTimeStampedData ( new ContentInfo ( CMSObjectIdentifiers . timestampedData , new TimeStampedData ( timeStampedData . getDataUri ( ) , timeStampedData . getMetaData ( ) , timeStampedData . getContent ( ) , new Evidence ( new TimeStampTokenEvidence ( newTimeStamps ) ) ) ) ) ; } 
1226	public boolean isItemChecked ( int position ) { if ( mChoiceMode ! = CHOICE _ MODE _ NONE & & mCheckStates ! = null ) { return mCheckStates . get ( position ) ; } return false ; } 
1227	public static XmlNOTATION parse ( java . io . Reader r ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( XmlNOTATION ) XmlBeans . getContextTypeLoader ( ) . parse ( r , type , null ) ; } 
1228	public void nextNull ( ) throws IOException { peek ( ) ; if ( token ! = JsonToken . NULL ) { throw new IllegalStateException ( _STR + token ) ; } advance ( ) ; } 
1229	public void setItemViewCacheSize ( int size ) { mRecycler . setViewCacheSize ( size ) ; } 
1230	public < T extends Options > T assign ( final Item item , final T options , final QueryError error ) throws QueryException { if ( item ! = null ) { final TokenBuilder tb = new TokenBuilder ( ) ; try { if ( item instanceof Map ) { options . assign ( ( Map ) item , ! acceptUnknown , info ) ; } else { if ( test = = null ) throw MAP _ X _ X . get ( info , item . type , item ) ; if ( ! test . eq ( item ) ) throw ELMMAP _ X _ X _ X . get ( info , root . prefixId ( XML ) , item . type , item ) ; final String opts = optString ( ( ANode ) item , error ) ; options . assign ( tb . add ( opts ) . toString ( ) ) ; } } catch ( final BaseXException ex ) { throw error . get ( info , ex ) ; } } return options ; } 
1231	public static WallpaperColors fromBitmap ( @ NonNull Bitmap bitmap ) { if ( bitmap = = null ) { throw new IllegalArgumentException ( _STR ) ; } final int bitmapArea = bitmap . getWidth ( ) * bitmap . getHeight ( ) ; boolean shouldRecycle = false ; if ( bitmapArea > MAX _ WALLPAPER _ EXTRACTION _ AREA ) { shouldRecycle = true ; Size optimalSize = calculateOptimalSize ( bitmap . getWidth ( ) , bitmap . getHeight ( ) ) ; bitmap = Bitmap . createScaledBitmap ( bitmap , optimalSize . getWidth ( ) , optimalSize . getHeight ( ) , true ) ; } final Palette palette = Palette . from ( bitmap ) . setQuantizer ( new VariationalKMeansQuantizer ( ) ) . maximumColorCount ( _NUM ) . clearFilters ( ) . resizeBitmapArea ( MAX _ WALLPAPER _ EXTRACTION _ AREA ) . generate ( ) ; Remove insignificant colors and sort swatches by population final ArrayList < Palette . Swatch > swatches = new ArrayList < > ( palette . getSwatches ( ) ) ; final float minColorArea = bitmap . getWidth ( ) * bitmap . getHeight ( ) * MIN _ COLOR _ OCCURRENCE ; swatches . removeIf ( s - > s . getPopulation ( ) < minColorArea ) ; swatches . sort ( ( a , b ) - > b . getPopulation ( ) - a . getPopulation ( ) ) ; final int swatchesSize = swatches . size ( ) ; Color primary = null , secondary = null , tertiary = null ; swatchLoop : for ( int i = _NUM ; i < swatchesSize ; i + + ) { Color color = Color . valueOf ( swatches . get ( i ) . getRgb ( ) ) ; switch ( i ) { case _NUM : primary = color ; break ; case _NUM : secondary = color ; break ; case _NUM : tertiary = color ; break ; default : out of bounds break swatchLoop ; } } int hints = calculateDarkHints ( bitmap ) ; if ( shouldRecycle ) { bitmap . recycle ( ) ; } return new WallpaperColors ( primary , secondary , tertiary , HINT _ FROM _ BITMAP | hints ) ; } 
1232	public UpdateBuilder addInsert ( Object g , Triple t ) { Quad q = new Quad ( AbstractQueryBuilder . makeNode ( g , prefixHandler . getPrefixes ( ) ) , t ) ; inserts . add ( new SingleQuadHolder ( q ) ) ; return this ; } 
1233	public void appendLibAssetForMainAssetPath ( String assetPath , String libAsset ) { synchronized ( this ) { Record which ResourcesImpl need updating ( and what ResourcesKey they should update to ) . final ArrayMap < ResourcesImpl , ResourcesKey > updatedResourceKeys = new ArrayMap < > ( ) ; final int implCount = mResourceImpls . size ( ) ; for ( int i = _NUM ; i < implCount ; i + + ) { final ResourcesKey key = mResourceImpls . keyAt ( i ) ; final WeakReference < ResourcesImpl > weakImplRef = mResourceImpls . valueAt ( i ) ; final ResourcesImpl impl = weakImplRef ! = null ? weakImplRef . get ( ) : null ; if ( impl ! = null & & Objects . equals ( key . mResDir , assetPath ) ) { if ( ! ArrayUtils . contains ( key . mLibDirs , libAsset ) ) { final int newLibAssetCount = _NUM + ( key . mLibDirs ! = null ? key . mLibDirs . length : _NUM ) ; final String [ ] newLibAssets = new String [ newLibAssetCount ] ; if ( key . mLibDirs ! = null ) { System . arraycopy ( key . mLibDirs , _NUM , newLibAssets , _NUM , key . mLibDirs . length ) ; } newLibAssets [ newLibAssetCount - _NUM ] = libAsset ; updatedResourceKeys . put ( impl , new ResourcesKey ( key . mResDir , key . mSplitResDirs , key . mOverlayDirs , newLibAssets , key . mDisplayId , key . mOverrideConfiguration , key . mCompatInfo ) ) ; } } } redirectResourcesToNewImplLocked ( updatedResourceKeys ) ; } } 
1234	public void testEquiThetaJoin ( ) { CalciteAssert . hr ( ) . query ( _STR ) ; } 
1235	public List < Entry > filter ( List < Entry > points , double tolerance ) { if ( tolerance < = _NUM ) return points ; keep = new boolean [ points . size ( ) ] ; switch ( mType ) { case DOUGLAS _ PEUCKER : return reduceWithDouglasPeuker ( points , tolerance ) ; case NONE : return points ; default : return points ; } } 
1236	public void testTruncateMilliSecond ( ) throws Exception { final int calendarField = Calendar . MILLISECOND ; baseTruncateTest ( targetMilliSecondDate , targetMilliSecondDate , calendarField ) ; } 
1237	public void hmacSHA _NUM _NUM _NUM base _NUM _NUM ( ) { query ( _STR bp _NUM ym _NUM X
1238	private void updateRequestContextInfo ( ) { if ( ( m _ flexContextInfoList ! = null ) & & ! m _ flexContextInfoList . isEmpty ( ) ) { m _ cmsObject . getRequestContext ( ) . setAttribute ( CmsRequestUtil . HEADER _ LAST _ MODIFIED , m _ flexContextInfoList . get ( m _ flexContextInfoList . size ( ) - _NUM ) ) ; } } 
1239	public void add ( Hyp hypothesis ) { int slot = locate ( hypothesis ) ; if ( slot < _NUM ) { slot = - slot - _NUM ; hypotheses [ slot ] = hypothesis ; size + + ; } else { Viterbi merge . if ( hypotheses [ slot ] . getCost ( ) > hypothesis . getCost ( ) ) { hypotheses [ slot ] = hypothesis ; } } updateMinMax ( hypothesis . getCost ( ) ) ; if ( size = = expandLimit ) { expand ( ) ; } } 
1240	public void addTemplate ( PdfTemplate template , float a , float b , float c , float d , float e , float f ) { checkWriter ( ) ; checkNoPattern ( template ) ; PdfName name = writer . addDirectTemplateSimple ( template , null ) ; PageResources prs = getPageResources ( ) ; name = prs . addXObject ( name , template . getIndirectReference ( ) ) ; content . append ( _STR ) . append _ i ( separator ) ; } 
1241	protected void runEquivalenceChecks ( final IonDatagram datagram , boolean expectedEquality ) { int datagramSize = datagram . size ( ) ; assertTrue ( _STR + otherValue + ' \ n ' + e . getMessage ( ) ; fail ( message ) ; } } } } catch ( ClassCastException e ) { test file doesn ' t follow the agreed upon schema . if ( embeddedDocuments ) { fail ( SCHEMA _ CLASS _ CAST _ ERROR _ MSG _ EMBEDDED _ DOCUMENT ) ; } fail ( SCHEMA _ CLASS _ CAST _ ERROR _ MSG ) ; } } } 
1242	public static boolean testVariances ( TransposeDataCollection transposeDataCollection , double aLevel ) { int n = _NUM ; int k = transposeDataCollection . size ( ) ; if ( k < = _NUM ) { throw new IllegalArgumentException ( _STR ) ; } double W = ( ( n - k ) / ( k - _NUM . _NUM ) ) * ( numerator / denominator ) ; boolean rejectH _NUM = checkCriticalValue ( W , n , k , aLevel ) ; return rejectH _NUM ; } 
1243	public void insertElementAsOnly _NUM ( ) throws IOException { final Data data = context . data ( ) ; final long nextid = data . meta . lastid ; insertElement ( _NUM , _NUM , T _ JUNIT , Data . ELEM ) ; assertEquals ( size + _NUM , data . meta . size ) ; assertEquals ( _NUM , data . parent ( _NUM , Data . ELEM ) ) ; assertEquals ( Data . ATTR , data . kind ( _NUM ) ) ; assertEquals ( Data . ELEM , data . kind ( _NUM ) ) ; assertEquals ( _NUM , data . parent ( _NUM , Data . ELEM ) ) ; assertEquals ( _NUM , data . parent ( _NUM , Data . ELEM ) ) ; assertEquals ( nextid + _NUM , data . meta . lastid ) ; assertArraysEquals ( T _ JUNIT , data . name ( _NUM , Data . ELEM ) ) ; reload ( ) ; assertEquals ( size + _NUM , data . meta . size ) ; assertEquals ( _NUM , data . parent ( _NUM , Data . ELEM ) ) ; assertEquals ( Data . ATTR , data . kind ( _NUM ) ) ; assertEquals ( _NUM , data . parent ( _NUM , Data . ELEM ) ) ; assertEquals ( _NUM , data . parent ( _NUM , Data . ELEM ) ) ; assertEquals ( nextid + _NUM , data . meta . lastid ) ; assertArraysEquals ( T _ JUNIT , data . name ( _NUM , Data . ELEM ) ) ; } 
1244	public void destroyLoader ( int id ) { if ( mCreatingLoader ) { throw new IllegalStateException ( _STR + id ) ; int idx = mLoaders . indexOfKey ( id ) ; if ( idx > = _NUM ) { LoaderInfo info = mLoaders . valueAt ( idx ) ; mLoaders . removeAt ( idx ) ; info . destroy ( ) ; } idx = mInactiveLoaders . indexOfKey ( id ) ; if ( idx > = _NUM ) { LoaderInfo info = mInactiveLoaders . valueAt ( idx ) ; mInactiveLoaders . removeAt ( idx ) ; info . destroy ( ) ; } if ( mHost ! = null & & ! hasRunningLoaders ( ) ) { mHost . mFragmentManager . startPendingDeferredFragments ( ) ; } } 
1245	public Void call ( ) throws Exception { if ( options = = null ) { mFileSystem . createDirectory ( new AlluxioURI ( path ) , CreateDirectoryOptions . defaults ( ) ) ; } else { mFileSystem . createDirectory ( new AlluxioURI ( path ) , options ) ; } return null ; } } ) ; } 
1246	private static Credential buildCredentialFromP _NUM _NUM ( String privateKeyPath , Optional < String > fsUri , Optional < String > id , HttpTransport transport , Collection < String > serviceAccountScopes ) throws IOException , GeneralSecurityException { Preconditions . checkArgument ( id . isPresent ( ) , _STR ) ; } } } 
1247	public final int readInt ( ) throws IOException { int tag = _ offset < _ length ? ( _ buffer [ _ offset + + ] & _NUM xff ) : read ( ) ; int tag = read ( ) ; switch ( tag ) { case ' N ' : return _NUM ; case ' F ' : return _NUM ; case ' T ' : return _NUM ; direct integer case _NUM x _NUM _NUM : case _NUM x _NUM _NUM : case _NUM x _NUM _NUM : case _NUM x _NUM _NUM : case _NUM x _NUM _NUM : case _NUM x _NUM _NUM : case _NUM x _NUM _NUM : case _NUM x _NUM _NUM : case _NUM x _NUM _NUM : case _NUM x _NUM _NUM : case _NUM x _NUM a : case _NUM x _NUM b : case _NUM x _NUM c : case _NUM x _NUM d : case _NUM x _NUM e : case _NUM x _NUM f : case _NUM x _NUM _NUM : case _NUM x _NUM _NUM : case _NUM x _NUM _NUM : case _NUM x _NUM _NUM : case _NUM x _NUM _NUM : case _NUM x _NUM _NUM : case _NUM x _NUM _NUM : case _NUM x _NUM _NUM : case _NUM x _NUM _NUM : case _NUM x _NUM _NUM : case _NUM x _NUM a : case _NUM x _NUM b : case _NUM x _NUM c : case _NUM x _NUM d : case _NUM x _NUM e : case _NUM x _NUM f : case _NUM xa _NUM : case _NUM xa _NUM : case _NUM xa _NUM : case _NUM xa _NUM : case _NUM xa _NUM : case _NUM xa _NUM : case _NUM xa _NUM : case _NUM xa _NUM : case _NUM xa _NUM : case _NUM xa _NUM : case _NUM xaa : case _NUM xab : case _NUM xac : case _NUM xad : case _NUM xae : case _NUM xaf : case _NUM xb _NUM : case _NUM xb _NUM : case _NUM xb _NUM : case _NUM xb _NUM : case _NUM xb _NUM : case _NUM xb _NUM : case _NUM xb _NUM : case _NUM xb _NUM : case _NUM xb _NUM : case _NUM xb _NUM : case _NUM xba : case _NUM xbb : case _NUM xbc : case _NUM xbd : case _NUM xbe : case _NUM xbf : return tag - BC _ INT _ ZERO ; case _NUM xc _NUM : case _NUM xc _NUM : case _NUM xc _NUM : case _NUM xc _NUM : case _NUM xc _NUM : case _NUM xc _NUM : case _NUM xc _NUM : case _NUM xc _NUM : case _NUM xc _NUM : case _NUM xc _NUM : case _NUM xca : case _NUM xcb : case _NUM xcc : case _NUM xcd : case _NUM xce : case _NUM xcf : return ( ( tag - BC _ INT _ BYTE _ ZERO ) < < _NUM ) + read ( ) ; case _NUM xd _NUM : case _NUM xd _NUM : case _NUM xd _NUM : case _NUM xd _NUM : case _NUM xd _NUM : case _NUM xd _NUM : case _NUM xd _NUM : case _NUM xd _NUM : return ( ( tag - BC _ INT _ SHORT _ ZERO ) < < _NUM _NUM ) + _NUM _NUM _NUM * read ( ) + read ( ) ; case ' I ' : case BC _ LONG _ INT : return ( ( read ( ) < < _NUM _NUM ) + ( read ( ) < < _NUM _NUM ) + ( read ( ) < < _NUM ) + read ( ) ) ; direct long case _NUM xd _NUM : case _NUM xd _NUM : case _NUM xda : case _NUM xdb : case _NUM xdc : case _NUM xdd : case _NUM xde : case _NUM xdf : case _NUM xe _NUM : case _NUM xe _NUM : case _NUM xe _NUM : case _NUM xe _NUM : case _NUM xe _NUM : case _NUM xe _NUM : case _NUM xe _NUM : case _NUM xe _NUM : case _NUM xe _NUM : case _NUM xe _NUM : case _NUM xea : case _NUM xeb : case _NUM xec : case _NUM xed : case _NUM xee : case _NUM xef : return tag - BC _ LONG _ ZERO ; case _NUM xf _NUM : case _NUM xf _NUM : case _NUM xf _NUM : case _NUM xf _NUM : case _NUM xf _NUM : case _NUM xf _NUM : case _NUM xf _NUM : case _NUM xf _NUM : case _NUM xf _NUM : case _NUM xf _NUM : case _NUM xfa : case _NUM xfb : case _NUM xfc : case _NUM xfd : case _NUM xfe : case _NUM xff : return ( ( tag - BC _ LONG _ BYTE _ ZERO ) < < _NUM ) + read ( ) ; case _NUM x _NUM _NUM : case _NUM x _NUM _NUM : case _NUM x _NUM a : case _NUM x _NUM b : case _NUM x _NUM c : case _NUM x _NUM d : case _NUM x _NUM e : case _NUM x _NUM f : return ( ( tag - BC _ LONG _ SHORT _ ZERO ) < < _NUM _NUM ) + _NUM _NUM _NUM * read ( ) + read ( ) ; case ' L ' : return ( int ) parseLong ( ) ; case BC _ DOUBLE _ ZERO : return _NUM ; case BC _ DOUBLE _ ONE : return _NUM ; case LONG _ BYTE : case BC _ DOUBLE _ BYTE : return ( byte ) ( _ offset < _ length ? _ buffer [ _ offset + + ] : read ( ) ) ; case LONG _ SHORT : case BC _ DOUBLE _ SHORT : return ( short ) ( _NUM _NUM _NUM * read ( ) + read ( ) ) ; case BC _ DOUBLE _ MILL : { int mills = parseInt ( ) ; return ( int ) ( _NUM . _NUM _NUM _NUM * mills ) ; } case ' D ' : return ( int ) parseDouble ( ) ; default : throw expect ( _STR , tag ) ; } } 
1248	public FieldType getDynamicFieldType ( String fieldName ) { for ( DynamicField df : dynamicFields ) { if ( df . matches ( fieldName ) ) return df . prototype . getType ( ) ; } if ( ! fieldName . endsWith ( _STR + fieldName ) ; } 
1249	private static void validateXmlView ( PageData xmlView , Compiler compiler ) throws JasperException { StringBuffer errMsg = null ; ErrorDispatcher errDisp = compiler . getErrorDispatcher ( ) ; for ( Iterator iter = compiler . getPageInfo ( ) . getTaglibs ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { Object o = iter . next ( ) ; if ( ! ( o instanceof TagLibraryInfoImpl ) ) continue ; TagLibraryInfoImpl tli = ( TagLibraryInfoImpl ) o ; ValidationMessage [ ] errors = tli . validate ( xmlView ) ; if ( ( errors ! = null ) & & ( errors . length ! = _NUM ) ) { if ( errMsg = = null ) { errMsg = new StringBuffer ( ) ; } errMsg . append ( _STR ) ; } } } } if ( errMsg ! = null ) { errDisp . jspError ( errMsg . toString ( ) ) ; } } 
1250	public < T > T post ( boolean useToken , Class < T > type , Map entity , final QueryParameters queryParameters ) { WebTarget resource = getTarget ( useToken ) ; resource = addParametersToResource ( resource , queryParameters ) ; Invocation . Builder builder = resource . request ( ) . accept ( MediaType . APPLICATION _ JSON ) ; it ' s OK for the entity to be null GenericType < T > gt = new GenericType < > ( ( Class ) type ) ; return builder . post ( javax . ws . rs . client . Entity . json ( entity ) , gt ) ; } 
1251	public Collator collator ( final HashMap < String , String > args ) throws BaseXException { if ( fallback ) { for ( final Entry < String , String > entry : args . entrySet ( ) ) { final String name = entry . getKey ( ) ; String value = entry . getValue ( ) ; if ( name . equals ( STRENGTH . name ( ) ) ) { if ( eq ( value , _STR ) ) value = Strength . IDENTICAL . toString ( ) ; assign ( name , value ) ; } } } else { assign ( args ) ; } Locale locale = Locale . US ; if ( contains ( LANG ) ) { locale = Locales . MAP . get ( get ( LANG ) ) ; if ( locale = = null ) throw error ( LANG ) ; } final Collator coll = Collator . getInstance ( locale ) ; if ( contains ( STRENGTH ) ) coll . setStrength ( get ( STRENGTH ) . value ) ; if ( contains ( DECOMPOSITION ) ) coll . setDecomposition ( get ( DECOMPOSITION ) . value ) ; return coll ; } 
1252	public void visibleFileRect ( Rect fRect ) { if ( vTranslate = = null | | ! readySent ) { return ; } fRect . set ( _NUM , _NUM , getWidth ( ) , getHeight ( ) ) ; viewToFileRect ( fRect , fRect ) ; } 
1253	public void test _ ijd _ _NUM _NUM ( ) { Model m = modelWithStatements ( _STR ; _ f ja : reasonerURL http : OntModel om = ( OntModel ) ModelFactory . assembleModelFrom ( m ) ; proxyForReasoning ( om ) ; } 
1254	public RemoteInterpreterEvent getEvent ( ) throws TException { return eventClient . pollEvent ( ) ; } 
1255	public boolean isSet ( _ Fields field ) { if ( field = = null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case TYPE : return is _ set _ type ( ) ; case NAME : return is _ set _ name ( ) ; case ACCESS : return is _ set _ access ( ) ; } throw new IllegalStateException ( ) ; } 
1256	public void createNotificationChannels ( @ NonNull List < NotificationChannel > channels ) { INotificationManager service = getService ( ) ; try { service . createNotificationChannels ( mContext . getPackageName ( ) , new ParceledListSlice ( channels ) ) ; } catch ( RemoteException e ) { throw e . rethrowFromSystemServer ( ) ; } } 
1257	private void parseEntitiesAndConnectionsFromJson ( final JobExecution execution , final File file , final EntityManager em , final EntityManager rootEm , final FileImport fileImport , final FileImportTracker tracker ) throws Exception { tracker flushes every _NUM _NUM _NUM entities final FileImportTracker tracker = new FileImportTracker ( emf , fileImport , _NUM _NUM _NUM ) ; function to execute for each write event final Action _NUM < WriteEvent > doWork = new Action _NUM < WriteEvent > ( ) { @ Override public void call ( WriteEvent writeEvent ) { writeEvent . doWrite ( em , fileImport , tracker ) ; } } ; invokes the heartbeat every HEARTBEAT _ COUNT operations final Func _NUM < Integer , WriteEvent , Integer > heartbeatReducer = new Func _NUM < Integer , WriteEvent , Integer > ( ) { @ Override public Integer call ( final Integer integer , final WriteEvent writeEvent ) { final int next = integer . intValue ( ) + _NUM ; if ( next % HEARTBEAT _ COUNT = = _NUM ) { execution . heartbeat ( ) ; } return next ; } } ; FIRST PASS : import all entities in the file observable that parses JSON and emits write events JsonParser jp = getJsonParserForFile ( file ) ; TODO : move JSON parser into observable creation so open / close happens within the stream entitiesOnly = true final JsonEntityParserObservable jsonObservableEntities = new JsonEntityParserObservable ( jp , em , rootEm , fileImport , tracker , true ) ; final Observable < WriteEvent > entityEventObservable = Observable . create ( jsonObservableEntities ) ; only take while our stats tell us we should continue processing potentially skip the first n if this is a resume operation final int entityNumSkip = ( int ) tracker . getTotalEntityCount ( ) ; entityEventObservable . takeWhile ( writeEvent - > ! tracker . shouldStopProcessingEntities ( ) ) . skip ( entityNumSkip ) . flatMap ( writeEvent - > { return Observable . just ( writeEvent ) . doOnNext ( doWork ) ; } , _NUM _NUM ) . reduce ( _NUM , heartbeatReducer ) . toBlocking ( ) . last ( ) ; jp . close ( ) ; if ( FileImport . State . FAILED . equals ( fileImport . getState ( ) ) ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( _STR , fileImport . getFileName ( ) ) ; } } 
1258	public void executeRepoTasks ( ) { repoUpdateExecutor . execute ( ) ; } 
1259	public void setStackScroll ( float s ) { mStackScrollP = s ; if ( mCb ! = null ) { mCb . onScrollChanged ( mStackScrollP ) ; } } 
1260	 @ Overridevoid toXML ( StringBuilder xml , int level ) { indent ( xml , level ) ; xml . append ( _STR ) ; } 
1261	public void testClientRetryWithFailover ( final AtMostOnceOp op ) throws Exception { final Map < String , Object > results = new HashMap < String , Object > ( ) ; op . prepare ( ) ; set DummyRetryInvocationHandler # block to true DummyRetryInvocationHandler . block . set ( true ) ; new Thread ( ) { @ Override public void run ( ) { try { op . invoke ( ) ; Object result = op . getResult ( ) ; LOG . info ( _STR + updatedNN _NUM , expectedUpdateCount , updatedNN _NUM ) ; } } 
1262	protected List < KeyValueScanner > selectScannersFrom ( HStore store , List < ? extends KeyValueScanner > allScanners ) { boolean memOnly ; boolean filesOnly ; if ( scan instanceof InternalScan ) { InternalScan iscan = ( InternalScan ) scan ; memOnly = iscan . isCheckOnlyMemStore ( ) ; filesOnly = iscan . isCheckOnlyStoreFiles ( ) ; } else { memOnly = false ; filesOnly = false ; } List < KeyValueScanner > scanners = new ArrayList < > ( allScanners . size ( ) ) ; We can only exclude store files based on TTL if minVersions is set to _NUM . Otherwise , we might have to return KVs that have technically expired . long expiredTimestampCutoff = minVersions = = _NUM ? oldestUnexpiredTS : Long . MIN _ VALUE ; include only those scan files which pass all filters for ( KeyValueScanner kvs : allScanners ) { boolean isFile = kvs . isFileScanner ( ) ; if ( ( ! isFile & & filesOnly ) | | ( isFile & & memOnly ) ) { continue ; } if ( kvs . shouldUseScanner ( scan , store , expiredTimestampCutoff ) ) { scanners . add ( kvs ) ; } else { kvs . close ( ) ; } } return scanners ; } 
1263	public static long sizeOf ( final File file ) { if ( ! file . exists ( ) ) { final String message = file + _STR ; throw new IllegalArgumentException ( message ) ; } if ( file . isDirectory ( ) ) { private method ; expects directory return sizeOfDirectory _NUM ( file ) ; } return file . length ( ) ; } 
1264	public static long getMobileRxBytes ( ) { long total = _NUM ; for ( String iface : getMobileIfaces ( ) ) { total + = addIfSupported ( getRxBytes ( iface ) ) ; } return total ; } 
1265	public static ActionRequest getActionRequest ( ) { if ( ! getPhase ( ) . isAction ( ) ) { throw new IllegalStateException ( _STR ) ; } return ( ActionRequest ) getContext ( ) . get ( REQUEST ) ; } 
1266	public void update ( WifiP _NUM pDevice device ) { updateSupplicantDetails ( device ) ; mDevices . get ( device . deviceAddress ) . status = device . status ; } 
1267	public void write _NUM ( final int v ) throws IOException { write ( v ) ; } 
1268	public static XmlNMTOKENS parse ( java . lang . String s ) throws org . apache . xmlbeans . XmlException { return ( XmlNMTOKENS ) XmlBeans . getContextTypeLoader ( ) . parse ( s , type , null ) ; } 
1269	private static < T > T peekFromSet ( Set < T > set ) { if ( ! set . isEmpty ( ) ) { return set . iterator ( ) . next ( ) ; } return null ; } 
1270	public static Method getGetMethod ( Class < ? > configInterface , Method method ) { Method getMethod = null ; String methodName = method . getName ( ) ; Matcher matcher ; if ( ( matcher = ACCESS _ RE . matcher ( methodName ) ) . matches ( ) | | ( matcher = LISTENER _ RE . matcher ( methodName ) ) . matches ( ) ) { String prop = matcher . group ( _NUM ) ; try { getMethod = configInterface . getMethod ( _STR + prop , methodType ) ; } catch ( NoSuchMethodException ex _NUM ) { nothing } } } } } } return getMethod ; } 
1271	public Object setValue ( Object obj ) { Object old = getValue ( ) ; if ( parent . valueType > HARD ) { ( ( Reference ) value ) . clear ( ) ; } value = toReference ( parent . valueType , obj , hashCode ) ; return old ; } 
1272	public void getPicture ( String id , final ActionListener callback , Dimension toScale , boolean tempStorage ) throws IOException { checkAuthentication ( ) ; FacebookRESTService fb = new FacebookRESTService ( token , id , FacebookRESTService . PICTURE , false ) ; if ( toScale ! = null ) { fb . addArgument ( _STR ) ; } String cacheKey = id ; already has a permanent image if ( tempStorage & & ! Storage . getInstance ( ) . exists ( id ) ) { cacheKey = TEMP _ STORAGE + id ; } ImageDownloadService . createImageToStorage ( fb . requestURL ( ) , callback , cacheKey ) ; } 
1273	public Command addCommandToLeftBar ( String name , Image icon , final ActionListener ev ) { Command cmd = Command . create ( name , icon , ev ) ; addCommandToLeftBar ( cmd ) ; return cmd ; } 
1274	public void rotateImage ( int degrees ) { Matrix matrix = new Matrix ( ) ; matrix . postRotate ( degrees ) ; mBitmap = Bitmap . createBitmap ( mBitmap , _NUM , _NUM , mBitmap . getWidth ( ) , mBitmap . getHeight ( ) , matrix , true ) ; setImageBitmap ( mBitmap ) ; mDegreesRotated + = degrees ; mDegreesRotated = mDegreesRotated % _NUM _NUM _NUM ; } 
1275	public void removeNoChecksumAnchor ( ) { if ( slot ! = null ) { slot . removeAnchor ( ) ; } } 
1276	public List < CmsHistoryProject > getAllHistoricalProjects ( CmsDbContext dbc ) throws CmsException { user is allowed to access all existing projects for the ous he has the project _ manager role Set < CmsOrganizationalUnit > manOus = new HashSet < CmsOrganizationalUnit > ( getOrgUnitsForRole ( dbc , CmsRole . PROJECT _ MANAGER , true ) ) ; List < CmsHistoryProject > projects = getHistoryDriver ( dbc ) . readProjects ( dbc ) ; Iterator < CmsHistoryProject > itProjects = projects . iterator ( ) ; while ( itProjects . hasNext ( ) ) { CmsHistoryProject project = itProjects . next ( ) ; if ( project . isHidden ( ) ) { project is hidden itProjects . remove ( ) ; continue ; } if ( ! project . getOuFqn ( ) . startsWith ( dbc . currentUser ( ) . getOuFqn ( ) ) ) { project is not visible from the users ou itProjects . remove ( ) ; continue ; } CmsOrganizationalUnit ou = readOrganizationalUnit ( dbc , project . getOuFqn ( ) ) ; if ( manOus . contains ( ou ) ) { user is project manager for this project continue ; } else if ( project . getOwnerId ( ) . equals ( dbc . currentUser ( ) . getId ( ) ) ) { user is owner of the project continue ; } else { boolean found = false ; Iterator < CmsGroup > itGroups = getGroupsOfUser ( dbc , dbc . currentUser ( ) . getName ( ) , false ) . iterator ( ) ; while ( itGroups . hasNext ( ) ) { CmsGroup group = itGroups . next ( ) ; if ( project . getManagerGroupId ( ) . equals ( group . getId ( ) ) ) { found = true ; break ; } } if ( found ) { user is member of the manager group of the project continue ; } } itProjects . remove ( ) ; } return projects ; } 
1277	public boolean toBoolean ( String name , boolean defaultValue ) { try { return parseBoolean ( name ) ; } catch ( Exception e ) { return defaultValue ; } } 
1278	public void test _NUM _ _NUM Presets ( ) throws Exception { boolean result = false ; String msg = _STR ) ; } finally { releaseEqualizer ( ) ; } assertTrue ( msg , result ) ; } 
1279	private ActivityInfo getActivityInfoInternal ( ComponentName component , int flags , int filterCallingUid , int userId ) { if ( ! sUserManager . exists ( userId ) ) return null ; flags = updateFlagsForComponent ( flags , userId , component ) ; enforceCrossUserPermission ( Binder . getCallingUid ( ) , userId , false , false , _STR + a ) ; if ( a ! = null & & mSettings . isEnabledAndMatchLPr ( a . info , flags , userId ) ) { PackageSetting ps = mSettings . mPackages . get ( component . getPackageName ( ) ) ; if ( ps = = null ) return null ; if ( filterAppAccessLPr ( ps , filterCallingUid , component , TYPE _ ACTIVITY , userId ) ) { return null ; } return PackageParser . generateActivityInfo ( a , flags , ps . readUserState ( userId ) , userId ) ; } if ( mResolveComponentName . equals ( component ) ) { return PackageParser . generateActivityInfo ( mResolveActivity , flags , new PackageUserState ( ) , userId ) ; } } return null ; } 
1280	public void ftIndex ( ) { set ( MainOptions . FTINDEX , true ) ; try { map ( ) . forEach ( ( key , value ) - > { set ( MainOptions . FTINCLUDE , key ) ; execute ( new CreateDB ( NAME , FILE ) ) ; assertEquals ( _STR ) ; set ( MainOptions . FTINDEX , false ) ; } } 
1281	public void writeToParcel ( Parcel parcel , int flags ) { final boolean oldAllowFds = parcel . pushAllowFds ( false ) ; try { writeToParcelInner ( parcel , flags ) ; } finally { parcel . restoreAllowFds ( oldAllowFds ) ; } } 
1282	 @ Around ( _STR ) ; configAction . setSourceType ( Component . Controller ) ; configAction . setActionDetails ( configDetails ) ; actions . add ( configAction ) ; record the action saveActions ( actions , logger ) ; } } } 
1283	protected void initGUI ( ) { JPanel panel ; SpinnerNumberModel model ; JPanel panel _NUM ; getContentPane ( ) . setLayout ( new BorderLayout ( ) ) ; panel = new JPanel ( new GridLayout ( _NUM , _NUM ) ) ; panel . setBorder ( BorderFactory . createEmptyBorder ( _NUM , _NUM , _NUM , _NUM ) ) ; getContentPane ( ) . add ( panel , BorderLayout . CENTER ) ; mean precision m _ MeanPrecSpinner = new JSpinner ( ) ; m _ MeanPrecSpinner . addChangeListener ( new ChangeListener ( ) { public void stateChanged ( ChangeEvent e ) { getData ( ) ; } } ) ; model = ( SpinnerNumberModel ) m _ MeanPrecSpinner . getModel ( ) ; model . setMaximum ( new Integer ( _NUM _NUM ) ) ; model . setMinimum ( new Integer ( _NUM ) ) ; m _ MeanPrecLabel = new JLabel ( _STR ) ; m _ OkButton . setMnemonic ( ' O ' ) ; m _ OkButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { getData ( ) ; m _ Result = APPROVE _ OPTION ; setVisible ( false ) ; } } ) ; panel . add ( m _ OkButton ) ; panel . add ( m _ CancelButton ) ; default button getRootPane ( ) . setDefaultButton ( m _ OkButton ) ; initial layout ( to get widths and heights ) pack ( ) ; adjust dimensions m _ MeanPrecLabel . setPreferredSize ( new Dimension ( m _ RemoveFilterNameLabel . getWidth ( ) , m _ MeanPrecLabel . getHeight ( ) ) ) ; m _ MeanPrecSpinner . setPreferredSize ( new Dimension ( m _ MeanPrecSpinner . getWidth ( ) * _NUM , m _ MeanPrecSpinner . getHeight ( ) ) ) ; m _ StdDevPrecLabel . setPreferredSize ( new Dimension ( m _ RemoveFilterNameLabel . getWidth ( ) , m _ StdDevPrecLabel . getHeight ( ) ) ) ; m _ StdDevPrecSpinner . setPreferredSize ( new Dimension ( m _ StdDevPrecSpinner . getWidth ( ) * _NUM , m _ StdDevPrecSpinner . getHeight ( ) ) ) ; m _ OutputFormatLabel . setPreferredSize ( new Dimension ( m _ RemoveFilterNameLabel . getWidth ( ) , m _ OutputFormatLabel . getHeight ( ) ) ) ; m _ ShowAverageLabel . setPreferredSize ( new Dimension ( m _ RemoveFilterNameLabel . getWidth ( ) , m _ ShowAverageLabel . getHeight ( ) ) ) ; m _ ResultMatrixLabel . setPreferredSize ( new Dimension ( m _ RemoveFilterNameLabel . getWidth ( ) , m _ ResultMatrixLabel . getHeight ( ) ) ) ; m _ ResultMatrixPanel . setPreferredSize ( new Dimension ( ( int ) ( m _ ResultMatrixPanel . getWidth ( ) * _NUM . _NUM ) , m _ ResultMatrixPanel . getHeight ( ) ) ) ; final layout pack ( ) ; } 
1284	public final void commit ( Map < String , String > commitUserData ) throws CorruptIndexException , IOException { ensureOpen ( ) ; commitInternal ( commitUserData ) ; } 
1285	public XYDataItem addOrUpdate ( Number x , Number y ) { if ( x = = null ) { throw new IllegalArgumentException ( _STR ) ; } figure out if we need to iterate through all the y - values boolean iterate = false ; double oldY = existing . getYValue ( ) ; if ( ! Double . isNaN ( oldY ) ) { iterate = oldY < = this . minY | | oldY > = this . maxY ; } existing . setY ( y ) ; if ( iterate ) { findBoundsByIteration ( ) ; } else if ( y ! = null ) { double yy = y . doubleValue ( ) ; this . minY = minIgnoreNaN ( this . minY , yy ) ; this . maxY = minIgnoreNaN ( this . maxY , yy ) ; } } else { if the series is sorted , the negative index is a result from Collections . binarySearch ( ) and tells us where to insert the new item . . . otherwise it will be just - _NUM and we should just append the value to the list . . . XYDataItem item = new XYDataItem ( x , y ) ; if ( this . autoSort ) { this . data . add ( - index - _NUM , item ) ; } else { this . data . add ( item ) ; } updateBoundsForAddedItem ( item ) ; check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { XYDataItem removed = ( XYDataItem ) this . data . remove ( _NUM ) ; updateBoundsForRemovedItem ( removed ) ; } } fireSeriesChanged ( ) ; return overwritten ; } 
1286	private static void setOutEpicenter ( FragmentTransitionImpl impl , Object sharedElementTransition , Object exitTransition , ArrayMap < String , View > outSharedElements , boolean outIsPop , BackStackRecord outTransaction ) { if ( outTransaction . mSharedElementSourceNames ! = null & & ! outTransaction . mSharedElementSourceNames . isEmpty ( ) ) { final String sourceName = outIsPop ? outTransaction . mSharedElementTargetNames . get ( _NUM ) : outTransaction . mSharedElementSourceNames . get ( _NUM ) ; final View outEpicenterView = outSharedElements . get ( sourceName ) ; impl . setEpicenter ( sharedElementTransition , outEpicenterView ) ; if ( exitTransition ! = null ) { impl . setEpicenter ( exitTransition , outEpicenterView ) ; } } } 
1287	private void processWrites ( ) { while ( true ) { try { manageInputWriterChannel ( ) ; } catch ( InterruptedException e ) { if ( determineIfWeShouldExit ( ) ) { break ; } } } } 
1288	boolean applyDeliveryAssurance ( long mn , Message message ) { Continuation cont = getContinuation ( message ) ; RMConfiguration config = destination . getReliableEndpoint ( ) . getConfiguration ( ) ; DeliveryAssurance da = config . getDeliveryAssurance ( ) ; boolean canSkip = da ! = DeliveryAssurance . AT _ LEAST _ ONCE & & da ! = DeliveryAssurance . EXACTLY _ ONCE ; boolean robust = false ; boolean robustDelivering = false ; boolean inOrder = mn - nextInOrder = = _NUM ; if ( message ! = null ) { robust = MessageUtils . getContextualBoolean ( message , Message . ROBUST _ ONEWAY ) ; if ( robust ) { robustDelivering = PropertyUtils . isTrue ( message . get ( RMMessageConstants . DELIVERING _ ROBUST _ ONEWAY ) ) ; } } if ( robust & & ! robustDelivering ) { no check performed if in robust and not in delivering removeDeliveringMessageNumber ( mn ) ; if ( inOrder ) { nextInOrder + + ; } return true ; } if ( inOrder ) { nextInOrder + + ; } else { message out of order , schedule acknowledgement to update sender scheduleImmediateAcknowledgement ( ) ; if ( nextInOrder < mn ) { nextInOrder = mn + _NUM ; } } if ( cont ! = null & & config . isInOrder ( ) & & ! cont . isNew ( ) ) { return waitInQueue ( mn , canSkip , message , cont ) ; } if ( ( da = = DeliveryAssurance . EXACTLY _ ONCE | | da = = DeliveryAssurance . AT _ MOST _ ONCE ) & & ( isAcknowledged ( mn ) | | ( robustDelivering & & deliveringMessageNumbers . contains ( mn ) ) ) ) { org . apache . cxf . common . i _NUM _NUM n . Message msg = new org . apache . cxf . common . i _NUM _NUM n . Message ( _STR , LOG , mn , getIdentifier ( ) . getValue ( ) ) ; LOG . log ( Level . INFO , msg . toString ( ) ) ; return false ; } if ( robustDelivering ) { addDeliveringMessageNumber ( mn ) ; } if ( config . isInOrder ( ) ) { return waitInQueue ( mn , canSkip , message , cont ) ; } return true ; } 
1289	protected static JSONNode toJSON ( Instance inst ) { JSONNode result ; JSONNode values ; int i ; boolean sparse ; result = new JSONNode ( ) ; sparse = ( inst instanceof SparseInstance ) ; result . addPrimitive ( SPARSE , sparse ) ; result . addPrimitive ( WEIGHT , inst . weight ( ) ) ; values = result . addArray ( VALUES ) ; if ( sparse ) { for ( i = _NUM ; i < inst . numValues ( ) ; i + + ) values . addArrayElement ( inst . index ( i ) + SPARSE _ SEPARATOR + inst . toString ( inst . index ( i ) ) ) ; } else { for ( i = _NUM ; i < inst . numAttributes ( ) ; i + + ) values . addArrayElement ( inst . toString ( i ) ) ; } return result ; } 
1290	public void readOldFormat ( Reader reader ) throws Exception { StreamTokenizer tokenizer ; int currentToken ; double firstIndex , secondIndex , weight ; tokenizer = new StreamTokenizer ( reader ) ; initialize ( ) ; tokenizer . commentChar ( ' % ' ) ; tokenizer . eolIsSignificant ( true ) ; while ( StreamTokenizer . TT _ EOF ! = ( currentToken = tokenizer . nextToken ( ) ) ) { Skip empty lines if ( currentToken = = StreamTokenizer . TT _ EOL ) { continue ; } Get index of first class . if ( currentToken ! = StreamTokenizer . TT _ NUMBER ) { throw new Exception ( _STR ) ; } setCell ( ( int ) firstIndex , ( int ) secondIndex , new Double ( weight ) ) ; } } 
1291	public static int parseInt ( String string , int radix ) throws NumberFormatException { if ( radix < Character . MIN _ RADIX | | radix > Character . MAX _ RADIX ) { throw new NumberFormatException ( _STR + radix ) ; } if ( string = = null ) { throw invalidInt ( string ) ; } int length = string . length ( ) , i = _NUM ; if ( length = = _NUM ) { throw invalidInt ( string ) ; } boolean negative = string . charAt ( i ) = = ' - ' ; if ( negative & & + + i = = length ) { throw invalidInt ( string ) ; } return parse ( string , i , radix , negative ) ; } 
1292	public static Result dropCollection ( String name ) { if ( BaasBoxLogger . isTraceEnabled ( ) ) BaasBoxLogger . trace ( _STR ) ; return ok ( ) ; } 
1293	public boolean deleteDataStore ( DataStore dataStore ) { List < StoragePoolHostVO > hostPoolRecords = _ storagePoolHostDao . listByPoolId ( dataStore . getId ( ) ) ; HypervisorType hypervisorType = null ; if ( hostPoolRecords . size ( ) > _NUM ) { hypervisorType = getHypervisorType ( hostPoolRecords . get ( _NUM ) . getHostId ( ) ) ; } if ( ! isSupportedHypervisorType ( hypervisorType ) ) { throw new CloudRuntimeException ( hypervisorType + _STR + cluster . getUuid ( ) ; s _ logger . debug ( errMsg ) ; throw new CloudRuntimeException ( errMsg ) ; } try { removeVolumeFromVag ( storagePool . getId ( ) , clusterId ) ; } finally { lock . unlock ( ) ; lock . releaseRef ( ) ; } } if ( hostId ! = null ) { handleTargetsForVMware ( hostId , storagePool . getId ( ) ) ; } deleteSolidFireVolume ( storagePool . getId ( ) ) ; return _ primaryDataStoreHelper . deletePrimaryDataStore ( dataStore ) ; } 
1294	public EndpointRequest addMetricsEntry ( String key , Double value ) { if ( null = = this . metrics ) { this . metrics = new java . util . HashMap < String , Double > ( ) ; } if ( this . metrics . containsKey ( key ) ) throw new IllegalArgumentException ( _STR ) ; this . metrics . put ( key , value ) ; return this ; } 
1295	public Date getDate ( ) { return DateFormatter . adjustedFromUTCDateString ( time ) ; } 
1296	public void createTopics ( int numPartitions , int replicationFactor , String . . . topics ) { for ( String topic : topics ) { if ( topic ! = null ) createTopic ( topic , numPartitions , replicationFactor ) ; } } 
1297	public void testAclString ( ) { AccessControlList acl ; acl = new AccessControlList ( _STR ) ) ; validateGetAclString ( acl ) ; } 
1298	void add ( View view ) { final int id = view . getId ( ) ; final Node node = Node . acquire ( view ) ; if ( id ! = View . NO _ ID ) { mKeyNodes . put ( id , node ) ; } mNodes . add ( node ) ; } 
1299	void removeChannel ( StoredClientChannel channel ) { lock . lock ( ) ; try { mapChannels . remove ( channel . id , channel ) ; } finally { lock . unlock ( ) ; } updatedChannel ( channel ) ; } 
1300	 @ ThunkPair < Long , int [ ] > findSpaceForItem ( Context context , ArrayList < Long > workspaceScreens , ArrayList < Long > addedWorkspaceScreensFinal , int spanX , int spanY ) { LongSparseArray < ArrayList < ItemInfo > > screenItems = new LongSparseArray < > ( ) ; Use sBgItemsIdMap as all the items are already loaded . assertWorkspaceLoaded ( ) ; synchronized ( sBgLock ) { for ( ItemInfo info : sBgItemsIdMap ) { if ( info . container = = LauncherSettings . Favorites . CONTAINER _ DESKTOP ) { ArrayList < ItemInfo > items = screenItems . get ( info . screenId ) ; if ( items = = null ) { items = new ArrayList < > ( ) ; screenItems . put ( info . screenId , items ) ; } items . add ( info ) ; } } } Find appropriate space for the item . long screenId = _NUM ; int [ ] cordinates = new int [ _NUM ] ; boolean found = false ; int screenCount = workspaceScreens . size ( ) ; First check the preferred screen . int preferredScreenIndex = workspaceScreens . isEmpty ( ) ? _NUM : _NUM ; if ( preferredScreenIndex < screenCount ) { screenId = workspaceScreens . get ( preferredScreenIndex ) ; found = findNextAvailableIconSpaceInScreen ( screenItems . get ( screenId ) , cordinates , spanX , spanY ) ; } if ( ! found ) { Search on any of the screens starting from the first screen . for ( int screen = _NUM ; screen < screenCount ; screen + + ) { screenId = workspaceScreens . get ( screen ) ; if ( findNextAvailableIconSpaceInScreen ( screenItems . get ( screenId ) , cordinates , spanX , spanY ) ) { We found a space for it found = true ; break ; } } } if ( ! found ) { Still no position found . Add a new screen to the end . screenId = LauncherSettings . Settings . call ( context . getContentResolver ( ) , LauncherSettings . Settings . METHOD _ NEW _ SCREEN _ ID ) . getLong ( LauncherSettings . Settings . EXTRA _ VALUE ) ; Save the screen id for binding in the workspace workspaceScreens . add ( screenId ) ; addedWorkspaceScreensFinal . add ( screenId ) ; If we still can ' t find an empty space , then God help us all ! ! ! if ( ! findNextAvailableIconSpaceInScreen ( screenItems . get ( screenId ) , cordinates , spanX , spanY ) ) { throw new RuntimeException ( _STR ) ; } } return Pair . create ( screenId , cordinates ) ; } 
1301	protected String getMessageBundleSourceName ( String bundleName , Locale locale ) { if ( Locale . ENGLISH . equals ( locale ) ) { return bundleName ; } String fileName = CmsStringUtil . substitute ( bundleName , _STR ; String source = SOURCE _ FOLDER _ PREFIX + locale . toString ( ) + SOURCE _ FOLDER _ INFIX + locale . toString ( ) + SOURCE _ FOLDER _ SUFFIX + fileName ; if file from the localized folder is not readable take the file from the original module if ( ! new File ( source ) . canRead ( ) ) { source = getModuleMessagesBundleSourceName ( bundleName , locale ) ; } return source ; } 
1302	public Paint lookupLegendTextPaint ( int series ) { Paint result = getLegendTextPaint ( series ) ; if ( result = = null ) { result = this . baseLegendTextPaint ; } return result ; } 
1303	protected void adjustSteps ( ) { mIsAdjusted = adjustVertical ( ! Viewport . AxisBoundsStatus . FIX . equals ( mGraphView . getViewport ( ) . mYAxisBoundsStatus ) ) ; mIsAdjusted & = adjustVerticalSecondScale ( ) ; mIsAdjusted & = adjustHorizontal ( ! Viewport . AxisBoundsStatus . FIX . equals ( mGraphView . getViewport ( ) . mXAxisBoundsStatus ) ) ; } 
1304	private int [ ] [ ] div ( int [ ] a , int [ ] f ) { int df = computeDegree ( f ) ; int da = computeDegree ( a ) + _NUM ; if ( df = = - _NUM ) { throw new ArithmeticException ( _STR ) ; } int [ ] [ ] result = new int [ _NUM ] [ ] ; result [ _NUM ] = new int [ _NUM ] ; result [ _NUM ] = new int [ da ] ; int hc = headCoefficient ( f ) ; hc = field . inverse ( hc ) ; result [ _NUM ] [ _NUM ] = _NUM ; System . arraycopy ( a , _NUM , result [ _NUM ] , _NUM , result [ _NUM ] . length ) ; while ( df < = computeDegree ( result [ _NUM ] ) ) { int [ ] q ; int [ ] coeff = new int [ _NUM ] ; coeff [ _NUM ] = field . mult ( headCoefficient ( result [ _NUM ] ) , hc ) ; q = multWithElement ( f , coeff [ _NUM ] ) ; int n = computeDegree ( result [ _NUM ] ) - df ; q = multWithMonomial ( q , n ) ; coeff = multWithMonomial ( coeff , n ) ; result [ _NUM ] = add ( coeff , result [ _NUM ] ) ; result [ _NUM ] = add ( q , result [ _NUM ] ) ; } return result ; } 
1305	public void setOnPrintTickLabel ( OnPrintTickLabel onPrintTickLabel ) { this . onPrintTickLabel = onPrintTickLabel ; if ( ! isAttachedToWindow ( ) ) return ; updateBackgroundBitmap ( ) ; invalidate ( ) ; } 
1306	public static void main ( String [ ] args ) { boolean result = false ; boolean is _NUM _NUM Bit = VMRuntime . getRuntime ( ) . is _NUM _NUM Bit ( ) ; try { if ( args . length ! = _NUM | | args [ _NUM ] = = null | | args [ _NUM ] = = null ) { Log . e ( LOGTAG , _STR ) ; Must explicitly exit or else this process will just sit around after we return . System . exit ( _NUM ) ; } } 
1307	void unlock ( Path lockFile ) throws JobLockException { log . debug ( _STR , lockFile ) ; if ( ! isLocked ( lockFile ) ) { return ; } try { this . fs . delete ( lockFile , false ) ; } catch ( IOException e ) { throw new JobLockException ( e ) ; } } 
1308	private void createRScript ( ) throws InterpreterException { ClassLoader classLoader = getClass ( ) . getClassLoader ( ) ; File out = new File ( scriptPath ) ; if ( out . exists ( ) & & out . isDirectory ( ) ) { throw new InterpreterException ( _STR , scriptPath ) ; } 
1309	public void testDirFailuresOnStartup ( ) throws IOException { Configuration conf = new YarnConfiguration ( ) ; String localDir _NUM = new File ( testDir , _STR + logDir _NUM ) ; prepareDirToFail ( localDir _NUM ) ; prepareDirToFail ( logDir _NUM ) ; LocalDirsHandlerService dirSvc = new LocalDirsHandlerService ( ) ; dirSvc . init ( conf ) ; List < String > localDirs = dirSvc . getLocalDirs ( ) ; Assert . assertEquals ( _NUM , localDirs . size ( ) ) ; Assert . assertEquals ( new Path ( localDir _NUM ) . toString ( ) , localDirs . get ( _NUM ) ) ; List < String > logDirs = dirSvc . getLogDirs ( ) ; Assert . assertEquals ( _NUM , logDirs . size ( ) ) ; Assert . assertEquals ( new Path ( logDir _NUM ) . toString ( ) , logDirs . get ( _NUM ) ) ; } 
1310	public boolean equals ( Object obj ) { if ( obj = = null ) return false ; if ( obj instanceof MultiLayerNetwork ) { MultiLayerNetwork network = ( MultiLayerNetwork ) obj ; boolean paramsEquals = network . params ( ) . equals ( params ( ) ) ; boolean confEquals = getLayerWiseConfigurations ( ) . equals ( network . getLayerWiseConfigurations ( ) ) ; boolean updaterEquals = getUpdater ( ) . equals ( network . getUpdater ( ) ) ; return paramsEquals & & confEquals & & updaterEquals ; } return false ; } 
1311	public void handleMessage ( Message msg ) { if ( msg . what = = mValidDelayedMsgId ) { discardUndo ( ) ; } } 
1312	static Implementation getImplementation ( String baseName , String algorithm , String provider ) throws NoSuchProviderException { if ( provider = = null ) { Provider [ ] prov = Security . getProviders ( ) ; for ( int i = _NUM ; i ! = prov . length ; i + + ) { try case insensitive Implementation imp = findImplementation ( baseName , algorithm . toUpperCase ( Locale . ENGLISH ) , prov [ i ] ) ; if ( imp ! = null ) { return imp ; } imp = findImplementation ( baseName , algorithm , prov [ i ] ) ; if ( imp ! = null ) { return imp ; } } } else { Provider prov = Security . getProvider ( provider ) ; if ( prov = = null ) { throw new NoSuchProviderException ( _STR ) ; } try case insensitive Implementation imp = findImplementation ( baseName , algorithm . toUpperCase ( Locale . ENGLISH ) , prov ) ; if ( imp ! = null ) { return imp ; } return findImplementation ( baseName , algorithm , prov ) ; } return null ; } 
1313	private static void verifyChecksum ( long length , FileInputStream metaIn , FileChannel blockChannel , String blockFileName ) throws IOException , ChecksumException { Verify the checksum from the block ' s meta file Get the DataChecksum from the meta file header BlockMetadataHeader header = BlockMetadataHeader . readHeader ( new DataInputStream ( new BufferedInputStream ( metaIn , BlockMetadataHeader . getHeaderSize ( ) ) ) ) ; FileChannel metaChannel = null ; try { metaChannel = metaIn . getChannel ( ) ; if ( metaChannel = = null ) { throw new IOException ( _STR ) ; } blockBuf . flip ( ) ; Number of read chunks , including partial chunk at end int chunks = ( bytesRead + bytesPerChecksum - _NUM ) / bytesPerChecksum ; checksumBuf . limit ( chunks * checksumSize ) ; fillBuffer ( metaChannel , checksumBuf ) ; checksumBuf . flip ( ) ; checksum . verifyChunkedSums ( blockBuf , checksumBuf , blockFileName , bytesVerified ) ; Success bytesVerified + = bytesRead ; blockBuf . clear ( ) ; checksumBuf . clear ( ) ; } } finally { IOUtils . closeQuietly ( metaChannel ) ; } } 
1314	public void setOrientation ( Orientation orientation ) { this . orientation = orientation ; if ( ! isAttachedToWindow ( ) ) return ; requestLayout ( ) ; updateBackgroundBitmap ( ) ; invalidate ( ) ; } 
1315	public static List < String > revertForbid ( List < String > forbid , Set < URL > subscribed ) { if ( forbid ! = null & & ! forbid . isEmpty ( ) ) { List < String > newForbid = new ArrayList < String > ( ) ; for ( String serviceName : forbid ) { if ( ! serviceName . contains ( _STR ) ) { for ( URL url : subscribed ) { if ( serviceName . equals ( url . getServiceInterface ( ) ) ) { newForbid . add ( url . getServiceKey ( ) ) ; break ; } } } else { newForbid . add ( serviceName ) ; } } return newForbid ; } return forbid ; } 
1316	public int lemmaCount ( ) { int i = _NUM ; for ( DependencyItem item : items ) { if ( ! item . isPunctuation ( ) & & item . hasLemma ( ) ) { i + + ; } } return i ; } 
1317	public void updateStarvationStats ( ) { long now = scheduler . getClock ( ) . getTime ( ) ; if ( ! isStarvedForMinShare ( ) ) { setLastTimeAtMinShare ( now ) ; } if ( ! isStarvedForFairShare ( ) ) { setLastTimeAtFairShareThreshold ( now ) ; } } 
1318	File getBlockFile ( String bpid , long blockId ) throws IOException { File f = validateBlockFile ( bpid , blockId ) ; if ( f = = null ) { throw new IOException ( _STR ) ; } return f ; } 
1319	private MasterThread startMaster ( MasterThread master ) { master . start ( ) ; It takes a while until ServerManager creation to happen inside Master startup . while ( master . getMaster ( ) . getServerManager ( ) = = null ) { continue ; } Set a listener for the waiting - on - RegionServers state . We want to wait until this condition before we leave this method and start regionservers . final AtomicBoolean waiting = new AtomicBoolean ( false ) ; if ( master . getMaster ( ) . getServerManager ( ) = = null ) throw new NullPointerException ( _STR ) ; master . getMaster ( ) . getServerManager ( ) . registerListener ( new ServerListener ( ) { @ Override public void waiting ( ) { waiting . set ( true ) ; } } ) ; Wait until the Master gets to place where it is waiting on RegionServers to check in . while ( ! waiting . get ( ) ) { continue ; } Set the global master - is - active ; gets picked up by regionservers later . masterActive . set ( true ) ; return master ; } 
1320	public void setDataNetworkTypeForPhone ( int phoneId , int type ) { if ( SubscriptionManager . isValidPhoneId ( phoneId ) ) { setTelephonyProperty ( phoneId , TelephonyProperties . PROPERTY _ DATA _ NETWORK _ TYPE , ServiceState . rilRadioTechnologyToString ( type ) ) ; } } 
1321	void decreaseKBy _NUM ( ) { if ( k _ < = _NUM ) { throw new SketchesStateException ( _STR ) ; } if ( h _ = = _NUM & & r _ = = _NUM ) { exact mode , but no data yet ; this reduction is somewhat gratuitous - - k _ ; } else if ( h _ > _NUM & & r _ = = _NUM ) { exact mode , but we have some data - - k _ ; if ( h _ > k _ ) { transitionFromWarmup ( ) ; } } else if ( h _ > _NUM & & r _ > _NUM ) { reservoir mode , but we have some exact samples . Our strategy will be to pull an item out of H ( which we are allowed to do since it ' s still just data ) , reduce k , and then re - insert the item first , slide the R zone to the left by _NUM , temporarily filling the gap final int oldGapIdx = h _ ; final int oldFinalRIdx = ( h _ + _NUM + r _ ) - _NUM ; assert oldFinalRIdx = = k _ ; swapValues ( oldFinalRIdx , oldGapIdx ) ; now we pull an item out of H ; any item is ok , but if we grab the rightmost and then reduce h _ , the heap invariant will be preserved ( and the gap will be restored ) , plus the push ( ) of the item that will probably happen later will be cheap . final int pulledIdx = h _ - _NUM ; final T pulledItem = data _ . get ( pulledIdx ) ; final double pulledWeight = weights _ . get ( pulledIdx ) ; final boolean pulledMark = marks _ . get ( pulledIdx ) ; if ( pulledMark ) { - - numMarksInH _ ; } to make bugs easier to spot weights _ . set ( pulledIdx , - _NUM . _NUM ) ; - - h _ ; - - k _ ; will be re - incremented with the update - - n _ ; update ( pulledItem , pulledWeight , pulledMark ) ; } else if ( h _ = = _NUM & & r _ > _NUM ) { pure reservoir mode , so can simply eject a randomly chosen sample from the reservoir assert r _ > = _NUM ; _NUM for the gap final int rIdxToDelete = _NUM + SamplingUtil . rand . nextInt ( r _ ) ; final int rightmostRIdx = ( _NUM + r _ ) - _NUM ; swapValues ( rIdxToDelete , rightmostRIdx ) ; weights _ . set ( rightmostRIdx , - _NUM . _NUM ) ; - - k _ ; - - r _ ; } } 
1322	public void drawText ( BaseCanvas c , int start , int end , float x , float y , Paint p ) { checkRange ( _STR , start , end ) ; if ( end < = mGapStart ) { c . drawText ( mText , start , end - start , x , y , p ) ; } else if ( start > = mGapStart ) { c . drawText ( mText , start + mGapLength , end - start , x , y , p ) ; } else { char [ ] buf = TextUtils . obtain ( end - start ) ; getChars ( start , end , buf , _NUM ) ; c . drawText ( buf , _NUM , end - start , x , y , p ) ; TextUtils . recycle ( buf ) ; } } 
1323	public void stopEditing ( Component cmp ) { if ( isTextEditing ( cmp ) ) { impl . stopTextEditing ( ) ; } } 
1324	public void nodeCreated ( String path ) { refreshListIfRightPath ( path ) ; } 
1325	protected boolean [ ] canHandleClassAsNthAttribute ( boolean nominalPredictor , boolean numericPredictor , boolean stringPredictor , boolean datePredictor , boolean relationalPredictor , boolean multiInstance , int classType , int classIndex ) { if ( classIndex = = TestInstances . CLASS _ IS _ LAST ) print ( _STR ) ; FastVector accepts = new FastVector ( ) ; int numTrain = getNumInstances ( ) , numTest = getNumInstances ( ) , numClasses = _NUM , missingLevel = _NUM ; boolean predictorMissing = false , classMissing = false ; return runBasicTest ( nominalPredictor , numericPredictor , stringPredictor , datePredictor , relationalPredictor , multiInstance , classType , classIndex , missingLevel , predictorMissing , classMissing , numTrain , numTest , numClasses , accepts ) ; } 
1326	public void merge ( Map < String , Section > m ) { if ( m ! = null ) { for ( Entry < String , Section > entry : m . entrySet ( ) ) { Section section = this . getSection ( entry . getKey ( ) ) ; if ( section = = null ) { section = addSection ( entry . getKey ( ) ) ; } section . putAll ( entry . getValue ( ) ) ; } } } 
1327	public AlertGroupEntity createDefaultGroup ( long clusterId , String serviceName ) throws AmbariException { AMBARI is a special service that we let through , otherwise we need to verify that the service exists before we create the default group String ambariServiceName = RootService . AMBARI . name ( ) ; if ( ! ambariServiceName . equals ( serviceName ) ) { Cluster cluster = m _ clusters . get ( ) . getClusterById ( clusterId ) ; Map < String , Service > services = cluster . getServices ( ) ; if ( ! services . containsKey ( serviceName ) ) { String message = MessageFormat . format ( _STR , serviceName , cluster . getClusterName ( ) ) ; throw new AmbariException ( message ) ; } } Lock lock = m _ locksByService . get ( serviceName ) ; lock . lock ( ) ; try { AlertGroupEntity group = findDefaultServiceGroup ( clusterId , serviceName ) ; if ( null ! = group ) { return group ; } group = new AlertGroupEntity ( ) ; group . setClusterId ( clusterId ) ; group . setDefault ( true ) ; group . setGroupName ( serviceName ) ; group . setServiceName ( serviceName ) ; create ( group ) ; return group ; } finally { lock . unlock ( ) ; } } 
1328	public static long copyFile ( final File source , final File destination , final boolean lockInputFile , final boolean lockOutputFile , final boolean move , final Logger logger ) throws FileNotFoundException , IOException { FileInputStream fis = null ; FileOutputStream fos = null ; FileLock inLock = null ; FileLock outLock = null ; long fileSize = _NUM L ; if ( ! source . canRead ( ) ) { throw new IOException ( _STR + source . getAbsolutePath ( ) ) ; } } } finally { FileUtils . releaseQuietly ( inLock ) ; FileUtils . releaseQuietly ( outLock ) ; FileUtils . closeQuietly ( fos ) ; FileUtils . closeQuietly ( fis ) ; } } return fileSize ; } 
1329	public DescribeSpotFleetRequestsRequest withSpotFleetRequestIds ( String . . . spotFleetRequestIds ) { if ( getSpotFleetRequestIds ( ) = = null ) setSpotFleetRequestIds ( new java . util . ArrayList < String > ( spotFleetRequestIds . length ) ) ; for ( String value : spotFleetRequestIds ) { getSpotFleetRequestIds ( ) . add ( value ) ; } return this ; } 
1330	public int [ ] getAvailableHotPixelModesChecked ( ) { Key < int [ ] > key = CameraCharacteristics . HOT _ PIXEL _ AVAILABLE _ HOT _ PIXEL _ MODES ; int [ ] modes = getValueFromKeyNonNull ( key ) ; if ( modes = = null ) { return new int [ _NUM ] ; } List < Integer > modeList = Arrays . asList ( CameraTestUtils . toObject ( modes ) ) ; if ( isHardwareLevelFull ( ) ) { checkTrueForKey ( key , _STR , containsAllOrNone ( modeList , coupledModes ) ) ; } checkElementDistinct ( key , modeList ) ; checkArrayValuesInRange ( key , modes , CameraMetadata . HOT _ PIXEL _ MODE _ OFF , CameraMetadata . HOT _ PIXEL _ MODE _ HIGH _ QUALITY ) ; return modes ; } 
1331	public boolean requestFocus ( int direction , Rect previouslyFocusedRect ) { return requestFocusNoSearch ( direction , previouslyFocusedRect ) ; } 
1332	public void reset ( ) { getInfGraph ( ) . reset ( ) ; } 
1333	public CmsResource getPermissionCheckFolder ( CmsObject cms ) throws CmsException { CmsResource folder = getFolder ( cms ) ; if ( folder ! = null ) { return folder ; } String parentPath = CmsResource . getParentFolder ( m _ path ) ; CmsResource parent = cms . readResource ( parentPath ) ; return parent ; } 
1334	public Bitmap toBitmap ( int width , int height , int inset , int color ) { final Bitmap bitmap = Bitmap . createBitmap ( width , height , Bitmap . Config . ARGB _ _NUM _NUM _NUM _NUM ) ; final Canvas canvas = new Canvas ( bitmap ) ; final Paint paint = new Paint ( ) ; paint . setAntiAlias ( BITMAP _ RENDERING _ ANTIALIAS ) ; paint . setDither ( BITMAP _ RENDERING _ DITHER ) ; paint . setColor ( color ) ; paint . setStyle ( Paint . Style . STROKE ) ; paint . setStrokeJoin ( Paint . Join . ROUND ) ; paint . setStrokeCap ( Paint . Cap . ROUND ) ; paint . setStrokeWidth ( BITMAP _ RENDERING _ WIDTH ) ; final Path path = toPath ( ) ; final RectF bounds = new RectF ( ) ; path . computeBounds ( bounds , true ) ; final float sx = ( width - _NUM * inset ) / bounds . width ( ) ; final float sy = ( height - _NUM * inset ) / bounds . height ( ) ; final float scale = sx > sy ? sy : sx ; paint . setStrokeWidth ( _NUM . _NUM f / scale ) ; path . offset ( - bounds . left + ( width - bounds . width ( ) * scale ) / _NUM . _NUM f , - bounds . top + ( height - bounds . height ( ) * scale ) / _NUM . _NUM f ) ; canvas . translate ( inset , inset ) ; canvas . scale ( scale , scale ) ; canvas . drawPath ( path , paint ) ; return bitmap ; } 
1335	public void mergeComponents ( final ReportingTaskEntity clientEntity , final Map < NodeIdentifier , ReportingTaskEntity > entityMap ) { final ReportingTaskDTO clientDto = clientEntity . getComponent ( ) ; final Map < NodeIdentifier , ReportingTaskDTO > dtoMap = new HashMap < > ( ) ; for ( final Map . Entry < NodeIdentifier , ReportingTaskEntity > entry : entityMap . entrySet ( ) ) { final ReportingTaskEntity nodeReportingTaskEntity = entry . getValue ( ) ; final ReportingTaskDTO nodeReportingTaskDto = nodeReportingTaskEntity . getComponent ( ) ; dtoMap . put ( entry . getKey ( ) , nodeReportingTaskDto ) ; } mergeDtos ( clientDto , dtoMap ) ; } 
1336	public int getResourceTypeId ( ) { return getResourceType ( ) . getTypeId ( ) ; } 
1337	public Action execute ( Percept percept ) { state < - INTERPRET - INPUT ( percept ) ; ObjectWithDynamicAttributes state = interpretInput ( percept ) ; rule < - RULE - MATCH ( state , rules ) ; Rule rule = ruleMatch ( state , rules ) ; return action return ruleAction ( rule ) ; } 
1338	public static < T > T mandatoryLookup ( CamelContext context , String name , Class < T > beanType ) { T answer = lookup ( context , name , beanType ) ; if ( answer = = null ) { throw new NoSuchBeanException ( name , beanType . getName ( ) ) ; } return answer ; } 
1339	public static Object get ( Object key ) { return getMocks ( ) . get ( key ) ; } 
1340	public void testOnlineSnapshotRegionOperationsIndependent ( ) throws Exception { createAndCloneSnapshot ( true ) ; runTestRegionOperationsIndependent ( ) ; } 
1341	public static RexProgramBuilder create ( RexBuilder rexBuilder , final RelDataType inputRowType , final List < RexNode > exprList , final List < RexLocalRef > projectRefList , final RexLocalRef conditionRef , final RelDataType outputRowType , final RexShuttle shuttle , final boolean updateRefs ) { final RexProgramBuilder progBuilder = new RexProgramBuilder ( inputRowType , rexBuilder ) ; progBuilder . add ( exprList , projectRefList , conditionRef , outputRowType , shuttle , updateRefs ) ; return progBuilder ; } 
1342	protected void initializeConstraints ( Builder < ? > builder ) { Note : this has to be done AFTER all constructors have finished - otherwise the required fields may not yet be set yet List < LayerConstraint > allConstraints = new ArrayList < > ( ) ; if ( builder . allParamConstraints ! = null & & ! initializer ( ) . paramKeys ( this ) . isEmpty ( ) ) { for ( LayerConstraint c : builder . allParamConstraints ) { LayerConstraint c _NUM = c . clone ( ) ; c _NUM . setParams ( new HashSet < > ( initializer ( ) . paramKeys ( this ) ) ) ; allConstraints . add ( c _NUM ) ; } } if ( builder . weightConstraints ! = null & & ! initializer ( ) . weightKeys ( this ) . isEmpty ( ) ) { for ( LayerConstraint c : builder . weightConstraints ) { LayerConstraint c _NUM = c . clone ( ) ; c _NUM . setParams ( new HashSet < > ( initializer ( ) . weightKeys ( this ) ) ) ; allConstraints . add ( c _NUM ) ; } } if ( builder . biasConstraints ! = null & & ! initializer ( ) . biasKeys ( this ) . isEmpty ( ) ) { for ( LayerConstraint c : builder . biasConstraints ) { LayerConstraint c _NUM = c . clone ( ) ; c _NUM . setParams ( new HashSet < > ( initializer ( ) . biasKeys ( this ) ) ) ; allConstraints . add ( c _NUM ) ; } } if ( ! allConstraints . isEmpty ( ) ) { this . constraints = allConstraints ; } else { this . constraints = null ; } this . iDropout = builder . iDropout ; } 
1343	public void testVertexIdAndValue ( ) { Vertex < LongWritable , FloatWritable , DoubleWritable > vertex = instantiateVertex ( ArrayListEdges . class ) ; assertNotNull ( vertex ) ; vertex . initialize ( new LongWritable ( _NUM ) , new FloatWritable ( _NUM . _NUM f ) ) ; assertEquals ( _NUM , vertex . getId ( ) . get ( ) ) ; assertEquals ( _NUM . _NUM f , vertex . getValue ( ) . get ( ) , _NUM d ) ; vertex . setValue ( new FloatWritable ( _NUM . _NUM f ) ) ; assertEquals ( _NUM . _NUM f , vertex . getValue ( ) . get ( ) , _NUM d ) ; } 
1344	public static XmlENTITIES parse ( java . io . Reader r ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( XmlENTITIES ) XmlBeans . getContextTypeLoader ( ) . parse ( r , type , null ) ; } 
1345	private RequestStageContainer handleTestIdentity ( Cluster cluster , KerberosDetails kerberosDetails , Map < String , String > commandParameters , RequestStageContainer requestStageContainer , Handler handler ) throws AmbariException , KerberosOperationException { if ( kerberosDetails . manageIdentities ( ) ) { if ( commandParameters = = null ) { throw new AmbariException ( _STR ) ) , null , Sets . newHashSet ( principal ) , hostsWithValidKerberosClient ) ; handler . addFinalizeOperationStage ( cluster , clusterHostInfoJson , hostParamsJson , event , dataDirectory , roleCommandOrder , requestStageContainer , kerberosDetails ) ; } return requestStageContainer ; } 
1346	private final int createState ( ) { final int state = states . size ( ) ; states . add ( NO _ SUFFIX _ LINK ) ; return state ; } 
1347	public void startExitTransition ( @ NonNull Transition transition , @ Nullable final View anchorRoot , @ Nullable final Rect epicenter , @ NonNull final TransitionListener listener ) { if ( transition = = null ) { return ; } immediately and execute the listener to remove the popup . if ( anchorRoot ! = null ) { anchorRoot . addOnAttachStateChangeListener ( mOnAnchorRootDetachedListener ) ; } The cleanup runnable MUST be called even if the transition is canceled before it starts ( and thus can ' t call onTransitionEnd ) . mCleanupAfterExit = ( ) - > { listener . onTransitionEnd ( transition ) ; if ( anchorRoot ! = null ) { anchorRoot . removeOnAttachStateChangeListener ( mOnAnchorRootDetachedListener ) ; } The listener was called . Our job here is done . mCleanupAfterExit = null ; } ; final Transition exitTransition = transition . clone ( ) ; exitTransition . addListener ( new TransitionListenerAdapter ( ) { @ Override public void onTransitionEnd ( Transition t ) { t . removeListener ( this ) ; to check here than it is to test every possible case . if ( mCleanupAfterExit ! = null ) { mCleanupAfterExit . run ( ) ; } } } ) ; exitTransition . setEpicenterCallback ( new EpicenterCallback ( ) { @ Override public Rect onGetEpicenter ( Transition transition ) { return epicenter ; } } ) ; final int count = getChildCount ( ) ; for ( int i = _NUM ; i < count ; i + + ) { final View child = getChildAt ( i ) ; exitTransition . addTarget ( child ) ; } TransitionManager . beginDelayedTransition ( this , exitTransition ) ; for ( int i = _NUM ; i < count ; i + + ) { final View child = getChildAt ( i ) ; child . setVisibility ( View . INVISIBLE ) ; } } 
1348	UsageEvents queryEvents ( int userId , long beginTime , long endTime , boolean shouldObfuscateInstantApps ) { synchronized ( mLock ) { final long timeNow = checkAndGetTimeLocked ( ) ; if ( ! validRange ( timeNow , beginTime , endTime ) ) { return null ; } final UserUsageStatsService service = getUserDataAndInitializeIfNeededLocked ( userId , timeNow ) ; return service . queryEvents ( beginTime , endTime , shouldObfuscateInstantApps ) ; } } 
1349	public String getMeid ( int slotIndex ) { ITelephony telephony = getITelephony ( ) ; if ( telephony = = null ) return null ; try { return telephony . getMeidForSlot ( slotIndex , getOpPackageName ( ) ) ; } catch ( RemoteException ex ) { return null ; } catch ( NullPointerException ex ) { return null ; } } 
1350	public void cleanup ( ) { if ( null = = mImageView ) { cleanup already done return ; } final ImageView imageView = mImageView . get ( ) ; if ( null ! = imageView ) { Remove this as a global layout listener ViewTreeObserver observer = imageView . getViewTreeObserver ( ) ; if ( null ! = observer & & observer . isAlive ( ) ) { observer . removeGlobalOnLayoutListener ( this ) ; } Remove the ImageView ' s reference to this imageView . setOnTouchListener ( null ) ; make sure a pending fling runnable won ' t be run cancelFling ( ) ; } if ( null ! = mGestureDetector ) { mGestureDetector . setOnDoubleTapListener ( null ) ; } Clear listeners too mMatrixChangeListener = null ; mPhotoTapListener = null ; mViewTapListener = null ; Finally , clear ImageView mImageView = null ; } 
1351	public void init ( CmsDbContext dbc , CmsConfigurationManager configurationManager , List < String > successiveDrivers , CmsDriverManager driverManager ) { CmsParameterConfiguration config = configurationManager . getConfiguration ( ) ; String poolUrl = config . get ( _STR , CmsEncoder . ENCODING _ UTF _ _NUM ) ; if ( CmsLog . INIT . isInfoEnabled ( ) ) { CmsLog . INIT . info ( Messages . get ( ) . getBundle ( ) . key ( Messages . INIT _ DIGEST _ ENCODING _ _NUM , m _ digestFileEncoding ) ) ; } create the digest try { m _ digest = MessageDigest . getInstance ( m _ digestAlgorithm ) ; if ( CmsLog . INIT . isInfoEnabled ( ) ) { CmsLog . INIT . info ( Messages . get ( ) . getBundle ( ) . key ( Messages . INIT _ DIGEST _ ENC _ _NUM , m _ digest . getAlgorithm ( ) , m _ digest . getProvider ( ) . getName ( ) , String . valueOf ( m _ digest . getProvider ( ) . getVersion ( ) ) ) ) ; } } catch ( NoSuchAlgorithmException e ) { if ( CmsLog . INIT . isInfoEnabled ( ) ) { CmsLog . INIT . info ( Messages . get ( ) . getBundle ( ) . key ( Messages . INIT _ SET _ DIGEST _ ERROR _ _NUM ) , e ) ; } } if ( ( successiveDrivers ! = null ) & & ! successiveDrivers . isEmpty ( ) ) { if ( LOG . isWarnEnabled ( ) ) { LOG . warn ( Messages . get ( ) . getBundle ( ) . key ( Messages . LOG _ SUCCESSIVE _ DRIVERS _ UNSUPPORTED _ _NUM , getClass ( ) . getName ( ) ) ) ; } } } 
1352	public < K , V > void consume ( String groupId , String clientId , OffsetResetStrategy autoOffsetReset , Deserializer < K > keyDeserializer , Deserializer < V > valueDeserializer , BooleanSupplier continuation , OffsetCommitCallback offsetCommitCallback , Runnable completion , Collection < String > topics , java . util . function . Consumer < ConsumerRecord < K , V > > consumerFunction ) { Properties props = getConsumerProperties ( groupId , clientId , autoOffsetReset ) ; Thread t = new Thread ( ( ) - > { LOGGER . debug ( _STR ) ; t . start ( ) ; } 
1353	private ExtInputStreamReader getMediaSegment ( ExtInputStreamReader r , String encoding , HTMLComponent htmlC ) throws IOException { String token = nextToken ( r , true , true , true , true ) ; char c = r . readCharFromReader ( ) ; while ( ( ( ( byte ) c ) ! = - _NUM ) & & ( c ! = ' { ' ) ) { Find the first { that marks the start of the media segment c = r . readCharFromReader ( ) ; } StringBuilder segment = new StringBuilder ( ) ; boolean match = mediaTypeMatches ( token ) ; counts the number of opened curly brackets int count = _NUM ; while ( count > _NUM ) { c = r . readCharFromReader ( ) ; if ( ( ( ( byte ) c ) = = - _NUM ) ) { end of file break ; } if ( match ) { segment . append ( c ) ; } if ( c = = ' { ' ) { count + + ; } else if ( c = = ' } ' ) { count - - ; } } if ( match ) { ExtInputStreamReader segmentReader = null ; if ( encoding ! = null ) { try { segmentReader = new ExtInputStreamReader ( new InputStreamReader ( new ByteArrayInputStream ( segment . toString ( ) . getBytes ( ) ) , encoding ) ) ; } catch ( UnsupportedEncodingException uee ) { notifyError ( ParserCallback . ERROR _ ENCODING , _STR + uee . getMessage ( ) ) ; } } if ( segmentReader = = null ) { either no encoding , or encoding failed segmentReader = new ExtInputStreamReader ( new InputStreamReader ( new ByteArrayInputStream ( segment . toString ( ) . getBytes ( ) ) ) ) ; } return segmentReader ; } else { return null ; } } 
1354	public String toString ( ) { return _STR ; } 
1355	public synchronized void processResult ( int rc , String path , Object ctx , String name ) { if ( isStaleClient ( ctx ) ) return ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( _STR ) ; return ; } fatalError ( errorMessage ) ; } 
1356	public void setChannelCount ( int numberOfChannels ) { for ( int i = _NUM ; i < m _ allInputs . size ( ) ; + + i ) { UGenInput input = m _ allInputs . get ( i ) ; if ( input . getInputType ( ) = = InputType . AUDIO ) { input . setChannelCount ( numberOfChannels ) ; } } if ( m _ lastValues . length ! = numberOfChannels ) { m _ lastValues = new float [ numberOfChannels ] ; channelCountChanged ( ) ; } } 
1357	protected String leafString ( Tree parent ) throws Exception { if ( m _ Info . classAttribute ( ) . isNumeric ( ) ) { double classMean ; if ( m _ ClassProbs = = null ) { classMean = parent . m _ ClassProbs [ _NUM ] ; } else { classMean = m _ ClassProbs [ _NUM ] ; } StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( _STR ; } } 
1358	public void setCssclass ( String value ) { setAttribute ( ATTR _ CLASS , value ) ; } 
1359	public void close ( ) throws IOException { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( _STR + Long . toHexString ( getSessionId ( ) ) ) ; } try { RequestHeader h = new RequestHeader ( ) ; h . setType ( ZooDefs . OpCode . closeSession ) ; submitRequest ( h , null , null , null ) ; } catch ( InterruptedException e ) { ignore , close the send / event threads } finally { disconnect ( ) ; } } 
1360	public void testRegisterTimerEventInSeconds ( ) { final CountDownLatch timerEventLatch = new CountDownLatch ( _NUM ) ; Runnable r = new Runnable ( ) { @ Override public void run ( ) { isTimerEventInvoked = true ; timerEventLatch . countDown ( ) ; } } ; heronServer . registerTimerEvent ( Duration . ofSeconds ( _NUM ) , r ) ; runBase ( ) ; HeronServerTester . await ( timerEventLatch ) ; Assert . assertTrue ( isTimerEventInvoked ) ; } 
1361	public Builder clearSeed ( ) { if ( seedBuilder _ = = null ) { seed _ = java . util . Collections . emptyList ( ) ; bitField _NUM _ = ( bitField _NUM _ & ~ _NUM x _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM ) ; onChanged ( ) ; } else { seedBuilder _ . clear ( ) ; } return this ; } 
1362	private static String decodeAndCleanUriString ( HttpServletRequest request , String uri ) { uri = decodeRequestString ( request , uri ) ; int semicolonIndex = uri . indexOf ( ' ; ' ) ; return ( semicolonIndex ! = - _NUM ? uri . substring ( _NUM , semicolonIndex ) : uri ) ; } 
1363	public static boolean isEmpty ( Object value ) { return ! isNotEmpty ( value ) ; } 
1364	private void processWriteQueue ( ) throws InterruptedException { WriteStatus status = new WriteStatus ( ) ; while ( true ) { DataStoreRequest operation = writeOperationsQueue . poll ( dataStoreConfig . pollTimeoutMS ( ) , TimeUnit . MILLISECONDS ) ; while ( operation ! = null ) { status . tracker . addCall ( operation , outputDataQueue ) ; writeOperationsBatch . add ( operation ) ; if ( writeOperationsBatch . size ( ) > dataStoreConfig . processQueueMaxBatchSize ( ) ) { break ; } operation = writeOperationsQueue . poll ( ) ; } if ( writeOperationsBatch . size ( ) > _NUM ) { try { status . writeBatchSize . add ( writeOperationsBatch . size ( ) ) ; recievedWriteBatch ( new ArrayList < > ( writeOperationsBatch ) ) ; } finally { writeOperationsBatch . clear ( ) ; } } else { flushWritesIfNeeded ( ) ; } if ( status . writeBatchSize . size ( ) > _NUM _NUM _NUM _NUM ) { status . sendBatchSize ( source , outputDataQueue ) ; } } } 
1365	public void delete ( ) { try to delete a package which is not installed try { new RepoManager ( context ) . delete ( _STR ) ; } catch ( final QueryException ex ) { error ( null , ex , REPO _ DELETE _ X _ X ) ; } try to delete pkg _NUM ( use package name ) execute ( new RepoDelete ( PKG _NUM , null ) ) ; check if pkg _NUM is unregistered from the repo assertFalse ( context . repo . pkgDict ( ) . containsKey ( PKG _NUM ID ) ) ; check if pkg _NUM directory was deleted assertFalse ( isDir ( pkg _NUM Dir ) ) ; try to delete pkg _NUM ( use package dir ) execute ( new RepoDelete ( PKG _NUM ID , null ) ) ; check if pkg _NUM is unregistered from the repo assertFalse ( context . repo . pkgDict ( ) . containsKey ( PKG _NUM ID ) ) ; check if pkg _NUM directory was deleted assertFalse ( isDir ( pkg _NUM Dir ) ) ; } 
1366	public Builder clearChannels ( ) { if ( channelsBuilder _ = = null ) { channels _ = java . util . Collections . emptyList ( ) ; bitField _NUM _ = ( bitField _NUM _ & ~ _NUM x _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM ) ; onChanged ( ) ; } else { channelsBuilder _ . clear ( ) ; } return this ; } 
1367	public < R > StreamEx < R > flatMapToObj ( LongFunction < ? extends Stream < R > > mapper ) { return new StreamEx < > ( stream ( ) . mapToObj ( mapper ) . flatMap ( Function . identity ( ) ) , context ) ; } 
1368	public static Multimap < Object , EventLog > getTestMethodEventLogsByEventTypeForClass ( String suiteName , String testName , String className , TestNgRunEvent event ) { Multimap < Object , EventLog > testMethodEventLogs = ArrayListMultimap . create ( ) ; for ( EventLog eventLog : eventLogs ) { if ( eventLog . getEvent ( ) = = event & & belongsToClass ( suiteName , testName , className , eventLog ) ) { testMethodEventLogs . put ( eventLog . getData ( EventInfo . CLASS _ INSTANCE ) , eventLog ) ; } } return testMethodEventLogs ; } 
1369	public int get ( final byte [ ] key ) { final int i = id ( key ) ; return i = = _NUM ? - _NUM : values [ i ] ; } 
1370	private Download doDownload ( final GetObjectRequest getObjectRequest , final File file , final TransferStateChangeListener stateListener , final S _NUM ProgressListener s _NUM progressListener , final boolean resumeExistingDownload ) { appendSingleObjectUserAgent ( getObjectRequest ) ; final String description = _STR ) ; } final CountDownLatch latch = new CountDownLatch ( _NUM ) ; final Future < ? > future = submitDownloadTask ( getObjectRequest , file , resumeExistingDownload , latch , download ) ; download . setMonitor ( new DownloadMonitor ( download , future ) ) ; latch . countDown ( ) ; return download ; } 
1371	public String [ ] getHttpAccessPathInfo ( ) throws Exception { String [ ] pathInfo = new String [ _NUM ] ; Pair < DatacenterMO , String > dcInfo = getOwnerDatacenter ( ) ; VirtualMachineFileInfo fileInfo = getFileInfo ( ) ; String vmxFilePath = fileInfo . getVmPathName ( ) ; String [ ] vmxPathTokens = vmxFilePath . split ( _STR ) ; assert ( vmxPathTokens . length = = _NUM ) ; vSphere vm name pathInfo [ _NUM ] = vmxPathTokens [ _NUM ] . trim ( ) ; vSphere datacenter name pathInfo [ _NUM ] = dcInfo . second ( ) ; vSphere datastore name pathInfo [ _NUM ] = vmxPathTokens [ _NUM ] . trim ( ) ; return pathInfo ; } 
1372	public static int idxInt ( Object object , String path ) { String [ ] properties = propertyPathAsStringArray ( path ) ; return getPropertyInt ( object , properties ) ; } 
1373	public void refreshSpringConfigurations ( ) { Map < SpringConfig , String > springConfigMap = springConfigRegistry . getAllSpringConfig ( ) ; spinnerAdapter . clear ( ) ; mSpringConfigs . clear ( ) ; for ( Map . Entry < SpringConfig , String > entry : springConfigMap . entrySet ( ) ) { if ( entry . getKey ( ) = = SpringConfig . defaultConfig ) { continue ; } mSpringConfigs . add ( entry . getKey ( ) ) ; spinnerAdapter . add ( entry . getValue ( ) ) ; } Add the default config in last . mSpringConfigs . add ( SpringConfig . defaultConfig ) ; spinnerAdapter . add ( springConfigMap . get ( SpringConfig . defaultConfig ) ) ; spinnerAdapter . notifyDataSetChanged ( ) ; if ( mSpringConfigs . size ( ) > _NUM ) { mSpringSelectorSpinner . setSelection ( _NUM ) ; } } 
1374	private void uploadPartsInParallel ( UploadPartRequestFactory requestFactory , String uploadId ) { Map < Integer , PartSummary > partNumbers = identifyExistingPartsForResume ( uploadId ) ; while ( requestFactory . hasMoreRequests ( ) ) { if ( threadPool . isShutdown ( ) ) throw new CancellationException ( _STR ) ; UploadPartRequest request = requestFactory . getNextUploadPartRequest ( ) ; if ( partNumbers . containsKey ( request . getPartNumber ( ) ) ) { PartSummary summary = partNumbers . get ( request . getPartNumber ( ) ) ; eTagsToSkip . add ( new PartETag ( request . getPartNumber ( ) , summary . getETag ( ) ) ) ; transferProgress . updateProgress ( summary . getSize ( ) ) ; continue ; } futures . add ( threadPool . submit ( new UploadPartCallable ( s _NUM , request ) ) ) ; } } 
1375	public void setRotation ( float angle , float x , float y , float z ) { initNativeTransform ( ) ; setTransform ( makeRotation ( angle , x , y , z ) ) ; type = TYPE _ UNKNOWN ; } 
1376	public static boolean tonesProprietaryTest ( ) throws Exception { Log . v ( TAG , _STR ) ; ToneGenerator toneGen ; int type ; boolean result = true ; toneGen = new ToneGenerator ( AudioManager . STREAM _ MUSIC , _NUM _NUM _NUM ) ; for ( type = ToneGenerator . TONE _ PROP _ BEEP ; type < = ToneGenerator . TONE _ PROP _ BEEP _NUM ; type + + ) { if ( toneGen . startTone ( type ) ) { Thread . sleep ( _NUM _NUM _NUM _NUM ) ; toneGen . stopTone ( ) ; Thread . sleep ( _NUM _NUM _NUM ) ; } else { result = false ; break ; } } toneGen . release ( ) ; return result ; } 
1377	public boolean equals ( Object o ) { return ( compareTo ( ( AttributeLocator ) o ) = = _NUM ) ; } 
1378	void onReload ( boolean isResumingFromVisible ) { if ( ! isResumingFromVisible ) { Reset the focused task resetFocusedTask ( getFocusedTask ( ) ) ; } Reset the state of each of the task views List < TaskView > taskViews = new ArrayList < > ( ) ; taskViews . addAll ( getTaskViews ( ) ) ; taskViews . addAll ( mViewPool . getViews ( ) ) ; for ( int i = taskViews . size ( ) - _NUM ; i > = _NUM ; i - - ) { taskViews . get ( i ) . onReload ( isResumingFromVisible ) ; } Reset the stack state readSystemFlags ( ) ; mTaskViewsClipDirty = true ; mUIDozeTrigger . stopDozing ( ) ; if ( isResumingFromVisible ) { Animate in the freeform workspace int ffBgAlpha = mLayoutAlgorithm . getStackState ( ) . freeformBackgroundAlpha ; animateFreeformWorkspaceBackgroundAlpha ( ffBgAlpha , new AnimationProps ( _NUM _NUM _NUM , Interpolators . FAST _ OUT _ SLOW _ IN ) ) ; } else { mStackScroller . reset ( ) ; mStableLayoutAlgorithm . reset ( ) ; mLayoutAlgorithm . reset ( ) ; } Since we always animate to the same place in ( the initial state ) , always reset the stack to the initial state when resuming mStackReloaded = true ; mFinishedLayoutAfterStackReload = false ; mLaunchNextAfterFirstMeasure = false ; mInitialState = INITIAL _ STATE _ UPDATE _ ALL ; requestLayout ( ) ; } 
1379	private void open _ local _ symbol _ table _ copy ( ) { assert ( ! symbol _ table _ being _ collected ( ) ) ; _ symbol _ table _ value = _ symtab _ value _ factory . newEmptyStruct ( ) ; SymbolToken [ ] anns = _ system _ writer . getTypeAnnotationSymbols ( ) ; _ system _ writer . clearAnnotations ( ) ; _ symbol _ table _ value . setTypeAnnotationSymbols ( anns ) ; _ current _ writer = new IonWriterSystemTree ( activeSystemSymbolTable ( ) , _ catalog , _ symbol _ table _ value , null ) ; } 
1380	private I _ CmsXmlSchemaType getSchemaTypeRecusive ( String elementPath ) { String path = CmsXmlUtils . getFirstXpathElement ( elementPath ) ; I _ CmsXmlSchemaType type = m _ types . get ( path ) ; if ( type = = null ) { no node with the given path defined in schema return null ; } check if recursion is required to get value from a nested schema if ( type . isSimpleType ( ) | | ! CmsXmlUtils . isDeepXpath ( elementPath ) ) { no recursion required return type ; } recursion required since the path is an xpath and the type must be a nested content definition CmsXmlNestedContentDefinition nestedDefinition = ( CmsXmlNestedContentDefinition ) type ; path = CmsXmlUtils . removeFirstXpathElement ( elementPath ) ; return nestedDefinition . getNestedContentDefinition ( ) . getSchemaType ( path ) ; } 
1381	private boolean advance ( ) { TSource left = leftEnumerator . current ( ) ; TKey leftKey = outerKeySelector . apply ( left ) ; TInner right = rightEnumerator . current ( ) ; TKey rightKey = innerKeySelector . apply ( right ) ; for ( ; ; ) { int c = leftKey . compareTo ( rightKey ) ; if ( c = = _NUM ) { break ; } if ( c < _NUM ) { if ( ! leftEnumerator . moveNext ( ) ) { done = true ; return false ; } left = leftEnumerator . current ( ) ; leftKey = outerKeySelector . apply ( left ) ; } else { if ( ! rightEnumerator . moveNext ( ) ) { done = true ; return false ; } right = rightEnumerator . current ( ) ; rightKey = innerKeySelector . apply ( right ) ; } } lefts . clear ( ) ; lefts . add ( left ) ; for ( ; ; ) { if ( ! leftEnumerator . moveNext ( ) ) { done = true ; break ; } left = leftEnumerator . current ( ) ; TKey leftKey _NUM = outerKeySelector . apply ( left ) ; int c = leftKey . compareTo ( leftKey _NUM ) ; if ( c ! = _NUM ) { assert c < _NUM : _STR ; break ; } rights . add ( right ) ; } cartesians = Linq _NUM j . product ( ImmutableList . of ( Linq _NUM j . < Object > enumerator ( lefts ) , Linq _NUM j . < Object > enumerator ( rights ) ) ) ; return true ; } 
1382	public void testTxnLogWithNegativeZxid ( ) throws Exception { long peerZxid ; db . txnLog . add ( createProposal ( getZxid ( _NUM xf , _NUM ) ) ) ; db . txnLog . add ( createProposal ( getZxid ( _NUM xf , _NUM ) ) ) ; db . txnLog . add ( createProposal ( getZxid ( _NUM xf , _NUM ) ) ) ; db . txnLog . add ( createProposal ( getZxid ( _NUM xf , _NUM ) ) ) ; db . txnLog . add ( createProposal ( getZxid ( _NUM xf , _NUM ) ) ) ; db . txnLog . add ( createProposal ( getZxid ( _NUM xf , _NUM ) ) ) ; db . txnLog . add ( createProposal ( getZxid ( _NUM xf , _NUM ) ) ) ; db . lastProcessedZxid = getZxid ( _NUM xf , _NUM ) ; db . committedLog . add ( createProposal ( getZxid ( _NUM xf , _NUM ) ) ) ; db . committedLog . add ( createProposal ( getZxid ( _NUM xf , _NUM ) ) ) ; db . committedLog . add ( createProposal ( getZxid ( _NUM xf , _NUM ) ) ) ; Peer has zxid that we have never seen peerZxid = getZxid ( _NUM xf , _NUM ) ; assertFalse ( learnerHandler . syncFollower ( peerZxid , db , leader ) ) ; We send TRUNC to _NUM and forward any packet starting at maxCommittedLog assertOpType ( Leader . TRUNC , getZxid ( _NUM xf , _NUM ) , db . getmaxCommittedLog ( ) ) ; DIFF + _NUM proposals + _NUM commit assertEquals ( _NUM , learnerHandler . getQueuedPackets ( ) . size ( ) ) ; queuedPacketMatches ( new long [ ] { getZxid ( _NUM xf , _NUM ) , getZxid ( _NUM xf , _NUM ) , getZxid ( _NUM xf , _NUM ) , getZxid ( _NUM xf , _NUM ) } ) ; reset ( ) ; Peer zxid is in txnlog range peerZxid = getZxid ( _NUM xf , _NUM ) ; assertFalse ( learnerHandler . syncFollower ( peerZxid , db , leader ) ) ; We send DIFF and forward any packet starting at maxCommittedLog assertOpType ( Leader . DIFF , db . getmaxCommittedLog ( ) , db . getmaxCommittedLog ( ) ) ; DIFF + _NUM proposals + _NUM commit assertEquals ( _NUM , learnerHandler . getQueuedPackets ( ) . size ( ) ) ; queuedPacketMatches ( new long [ ] { getZxid ( _NUM xf , _NUM ) , getZxid ( _NUM xf , _NUM ) , getZxid ( _NUM xf , _NUM ) , getZxid ( _NUM xf , _NUM ) } ) ; reset ( ) ; } 
1383	public static String getDatacenter ( ) { String req = _STR ) ; return null ; } 
1384	public void writeTo ( final OutputStream out ) throws IOException { a file or memory . if ( ! closed ) { throw new IOException ( _STR ) ; } if ( isInMemory ( ) ) { memoryOutputStream . writeTo ( out ) ; } else { try ( FileInputStream fis = new FileInputStream ( outputFile ) ) { IOUtils . copy ( fis , out ) ; } } } 
1385	public void testDefaultRecordDelimiters ( ) throws IOException , InterruptedException , ClassNotFoundException { Configuration conf = new Configuration ( ) ; FileSystem localFs = FileSystem . getLocal ( conf ) ; cleanup localFs . delete ( workDir , true ) ; creating input test file createInputFile ( conf ) ; createAndRunJob ( conf ) ; String expected = _STR ; assertEquals ( expected , readOutputFile ( conf ) ) ; } 
1386	protected boolean onForwardingStarted ( ) { final ShowableListMenu popup = getPopup ( ) ; if ( popup ! = null & & ! popup . isShowing ( ) ) { popup . show ( ) ; } return true ; } 
1387	public static String formatEntry ( Entry < Key , Value > entry , DateFormat timestampFormat ) { StringBuilder sb = new StringBuilder ( ) ; Key key = entry . getKey ( ) ; Text buffer = new Text ( ) ; append row appendText ( sb , key . getRow ( buffer ) ) . append ( _STR ) ; appendValue ( sb , value ) ; } return sb . toString ( ) ; } 
1388	public PGPOnePassSignature generateOnePassVersion ( boolean isNested ) throws PGPException { return new PGPOnePassSignature ( new OnePassSignaturePacket ( sigType , contentSigner . getHashAlgorithm ( ) , contentSigner . getKeyAlgorithm ( ) , contentSigner . getKeyID ( ) , isNested ) ) ; } 
1389	public Iterable < COSName > getFontNames ( ) { return getNames ( COSName . FONT ) ; } 
1390	public int getVoiceActivationState ( int subId ) { try { ITelephony telephony = getITelephony ( ) ; if ( telephony ! = null ) return telephony . getVoiceActivationState ( subId , getOpPackageName ( ) ) ; } catch ( RemoteException ex ) { } catch ( NullPointerException ex ) { } return SIM _ ACTIVATION _ STATE _ UNKNOWN ; } 
1391	public static StatementBlock getStatementBlock ( Statement current ) { StatementBlock blk = null ; if ( current instanceof ParForStatement ) { blk = new ParForStatementBlock ( ) ; blk . addStatement ( current ) ; } else if ( current instanceof ForStatement ) { blk = new ForStatementBlock ( ) ; blk . addStatement ( current ) ; } else if ( current instanceof IfStatement ) { blk = new IfStatementBlock ( ) ; blk . addStatement ( current ) ; } else if ( current instanceof WhileStatement ) { blk = new WhileStatementBlock ( ) ; blk . addStatement ( current ) ; } else { This includes ImportStatement blk = new StatementBlock ( ) ; blk . addStatement ( current ) ; } return blk ; } 
1392	public void compose ( Transformation t ) { mAlpha * = t . getAlpha ( ) ; mMatrix . preConcat ( t . getMatrix ( ) ) ; if ( t . mHasClipRect ) { Rect bounds = t . getClipRect ( ) ; if ( mHasClipRect ) { setClipRect ( mClipRect . left + bounds . left , mClipRect . top + bounds . top , mClipRect . right + bounds . right , mClipRect . bottom + bounds . bottom ) ; } else { setClipRect ( bounds ) ; } } } 
1393	public double [ ] getPMF ( final double [ ] splitPoints ) { if ( isEmpty ( ) ) { return null ; } return DoublesPmfCdfImpl . getPMFOrCDF ( this , splitPoints , false ) ; } 
1394	protected Object writePreProcess ( Object o ) throws Exception { o = super . writePreProcess ( o ) ; gather all BeanInstances , also the ones in MetaBeans m _ BeanInstances = new Vector ( ) ; m _ BeanInstancesID = new Vector ( ) ; switch ( getDataType ( ) ) { case DATATYPE _ LAYOUT : addBeanInstances ( BeanInstance . getBeanInstances ( m _ vectorIndex ) ) ; break ; case DATATYPE _ USERCOMPONENTS : addBeanInstances ( ( Vector ) o ) ; break ; default : System . out . println ( _STR ) ; break ; } return o ; } 
1395	public static String getOnlyNameServiceIdOrNull ( Configuration conf ) { Collection < String > nsIds = DFSUtilClient . getNameServiceIds ( conf ) ; if ( _NUM = = nsIds . size ( ) ) { return nsIds . toArray ( new String [ _NUM ] ) [ _NUM ] ; } else { No nameservice ID was given and more than one is configured return null ; } } 
1396	public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( _STR ) ; return sb . toString ( ) ; } 
1397	public void putPersistableBundle ( @ Nullable String key , @ Nullable PersistableBundle value ) { unparcel ( ) ; mMap . put ( key , value ) ; } 
1398	public ParticleGroup createParticleGroup ( ParticleGroupDef def ) { assertNotLocked ( ) ; return particleSystem . createParticleGroup ( def ) ; } 
1399	public String installPackageFromArchive ( String packageArchivePath , PrintStream . . . progress ) throws Exception { Properties packageProps = ( Properties ) getPackageArchiveInfo ( packageArchivePath ) . getPackageMetaData ( ) ; String packageName = packageProps . getProperty ( _STR + packageArchivePath ) ; } installPackage ( packageArchivePath , packageName , progress ) ; return packageName ; } 
1400	void stopAnimation ( ) { mHasAnimation = false ; if ( mIndeterminateDrawable instanceof Animatable ) { ( ( Animatable ) mIndeterminateDrawable ) . stop ( ) ; mShouldStartAnimationDrawable = false ; } postInvalidate ( ) ; } 
1401	public void testOpenLed ( ) throws IOException { InstrumentationTestUtils . assertRaspberryPiOnly ( ) ; Gpio led = VoiceHat . openLed ( ) ; Assert . assertNotNull ( led ) ; led . close ( ) ; } 
1402	public void lineTo ( float x , float y ) throws IOException { if ( inTextMode ) { throw new IllegalStateException ( _STR ) ; } 
1403	public void addStep ( final String stepName , final Object . . . arguments ) { this . stepInstructions . add ( new Instruction ( stepName , flattenArguments ( arguments ) ) ) ; Bindings . clear ( ) ; } 
1404	void consumeUpdatesInOnePass ( ) { we still consume postponed updates ( if there is ) in case there was a pre - process call w / o a matching consumePostponedUpdates . consumePostponedUpdates ( ) ; final int count = mPendingUpdates . size ( ) ; for ( int i = _NUM ; i < count ; i + + ) { UpdateOp op = mPendingUpdates . get ( i ) ; switch ( op . cmd ) { case UpdateOp . ADD : mCallback . onDispatchSecondPass ( op ) ; mCallback . offsetPositionsForAdd ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . REMOVE : mCallback . onDispatchSecondPass ( op ) ; mCallback . offsetPositionsForRemovingInvisible ( op . positionStart , op . itemCount ) ; break ; case UpdateOp . UPDATE : mCallback . onDispatchSecondPass ( op ) ; mCallback . markViewHoldersUpdated ( op . positionStart , op . itemCount , op . payload ) ; break ; case UpdateOp . MOVE : mCallback . onDispatchSecondPass ( op ) ; mCallback . offsetPositionsForMove ( op . positionStart , op . itemCount ) ; break ; } if ( mOnItemProcessedCallback ! = null ) { mOnItemProcessedCallback . run ( ) ; } } recycleUpdateOpsAndClearList ( mPendingUpdates ) ; mExistingUpdateTypes = _NUM ; } 
1405	public void setTabTitle ( String title , Image icon , int index ) { checkIndex ( index ) ; setTabTitle ( tabsContainer . getComponentAt ( index ) , title , icon ) ; } 
1406	public int read ( byte [ ] buffer , int offset , int length ) throws IOException { if ( _ noConversionRequired ) { return super . read ( buffer , offset , length ) ; } if ( length < _NUM ) { return _NUM ; } int ch , off ; ch = available ( ) ; _ _ length = ( length > ch ? ch : length ) ; If nothing is available , block to read only one character if ( _ _ length < _NUM ) { _ _ length = _NUM ; } if ( ( ch = _ _ read ( ) ) = = - _NUM ) { return - _NUM ; } off = offset ; do { buffer [ offset + + ] = ( byte ) ch ; } while ( - - _ _ length > _NUM & & ( ch = _ _ read ( ) ) ! = - _NUM ) ; return ( offset - off ) ; } 
1407	public void actionPerformed ( ActionEvent evt ) { if ( evt . isConsumed ( ) ) { return ; } Object src = evt . getSource ( ) ; if ( commandList = = null ) { Button source = ( Button ) src ; for ( int iter = _NUM ; iter < soft . length ; iter + + ) { if ( source = = soft [ iter ] ) { if ( softCommand [ iter ] = = menuCommand ) { showMenu ( ) ; return ; } if ( softCommand [ iter ] ! = null ) { ActionEvent e = new ActionEvent ( softCommand [ iter ] , ActionEvent . Type . Command ) ; softCommand [ iter ] . actionPerformed ( e ) ; if ( ! e . isConsumed ( ) ) { parent . actionCommandImpl ( softCommand [ iter ] ) ; } } return ; } } } else { the list for the menu sent the event if ( src instanceof Button ) { for ( int iter = _NUM ; iter < soft . length ; iter + + ) { if ( src = = soft [ iter ] ) { Container parent = commandList . getParent ( ) ; while ( parent ! = null ) { if ( parent instanceof Dialog ) { ( ( Dialog ) parent ) . actionCommand ( softCommand [ iter ] ) ; return ; } parent = parent . getParent ( ) ; } } } } Command c = getComponentSelectedCommand ( commandList ) ; if ( ! c . isEnabled ( ) ) { return ; } Container p = commandList . getParent ( ) ; while ( p ! = null ) { if ( p instanceof Dialog ) { ( ( Dialog ) p ) . actionCommand ( c ) ; return ; } p = p . getParent ( ) ; } } } 
1408	public boolean equals ( Object other ) { if ( _ set . equals ( other ) ) { comparing two trove sets return true ; } else if ( other instanceof Set ) { Set that = ( Set ) other ; if ( that . size ( ) ! = _ set . size ( ) ) { different sizes , no need to compare return false ; } else { now we have to do it the hard way Iterator it = that . iterator ( ) ; for ( int i = that . size ( ) ; i - - > _NUM ; ) { Object val = it . next ( ) ; if ( val instanceof Integer ) { int v = ( ( Integer ) val ) . intValue ( ) ; if ( _ set . contains ( v ) ) { match , ok to continue } else { no match : we ' re done return false ; } } else { different type in other set return false ; } } all entries match return true ; } } else { return false ; } } 
1409	public void testLineExceedsMaxLineLength ( ) throws IOException { final int maxLineLength = _NUM _NUM ; File f _NUM = new File ( tmpDir . getAbsolutePath ( ) + _STR ) ) ; assertEquals ( _NUM , out _NUM . size ( ) ) ; parser . commit ( ) ; assertEquals ( _NUM , parser . readEvents ( _NUM ) . size ( ) ) ; } 
1410	public Character get ( Object key ) { double k ; if ( key ! = null ) { if ( key instanceof Double ) { k = unwrapKey ( key ) ; } else { return null ; } } else { k = _ map . getNoEntryKey ( ) ; } char v = _ map . get ( k ) ; check here . if ( v = = _ map . getNoEntryValue ( ) ) { return null ; } else { return wrapValue ( v ) ; } } 
1411	private void implicitlyTrackColumnsInRow ( Row row ) { track new columns if ( trackAllColumns ) { if column is not tracked , implicitly track the column if trackAllColumns is True and column has not been explicitly untracked for ( final Cell cell : row ) { final int column = cell . getColumnIndex ( ) ; implicitlyTrackColumn ( column ) ; } } } 
1412	 $ ANTLR start _STR , _NUM _NUM , _NUM , input ) ; throw nvae ; } switch ( alt _NUM _NUM ) { case _NUM : JPA . g : _NUM _NUM _NUM : _NUM : path _ expression { root _ _NUM = ( Object ) adaptor . nil ( ) ; pushFollow ( FOLLOW _ path _ expression _ in _ constructor _ item _NUM _NUM _NUM _NUM ) ; path _ expression _NUM _NUM = path _ expression ( ) ; state . _ fsp - - ; if ( state . failed ) return retval ; if ( state . backtracking = = _NUM ) adaptor . addChild ( root _ _NUM , path _ expression _NUM _NUM . getTree ( ) ) ; } break ; case _NUM : JPA . g : _NUM _NUM _NUM : _NUM _NUM : aggregate _ expression { root _ _NUM = ( Object ) adaptor . nil ( ) ; pushFollow ( FOLLOW _ aggregate _ expression _ in _ constructor _ item _NUM _NUM _NUM _NUM ) ; aggregate _ expression _NUM _NUM = aggregate _ expression ( ) ; state . _ fsp - - ; if ( state . failed ) return retval ; if ( state . backtracking = = _NUM ) adaptor . addChild ( root _ _NUM , aggregate _ expression _NUM _NUM . getTree ( ) ) ; } break ; } retval . stop = input . LT ( - _NUM ) ; if ( state . backtracking = = _NUM ) { retval . tree = ( Object ) adaptor . rulePostProcessing ( root _ _NUM ) ; adaptor . setTokenBoundaries ( retval . tree , retval . start , retval . stop ) ; } } catch ( RecognitionException re ) { reportError ( re ) ; recover ( input , re ) ; retval . tree = ( Object ) adaptor . errorNode ( input , retval . start , input . LT ( - _NUM ) , re ) ; } finally { } return retval ; } 
1413	public AxisSpace reserveSpace ( Graphics _NUM D g _NUM , Plot plot , Rectangle _NUM D plotArea , RectangleEdge edge , AxisSpace space ) { create a new space object if one wasn ' t supplied . . . if ( space = = null ) { space = new AxisSpace ( ) ; } if the axis is not visible , no additional space is required . . . if ( ! isVisible ( ) ) { return space ; } calculate the max size of the tick labels ( if visible ) . . . double tickLabelHeight = _NUM . _NUM ; double tickLabelWidth = _NUM . _NUM ; if ( isTickLabelsVisible ( ) ) { g _NUM . setFont ( getTickLabelFont ( ) ) ; AxisState state = new AxisState ( ) ; we call refresh ticks just to get the maximum width or height refreshTicks ( g _NUM , state , plotArea , edge ) ; if ( edge = = RectangleEdge . TOP ) { tickLabelHeight = state . getMax ( ) ; } else if ( edge = = RectangleEdge . BOTTOM ) { tickLabelHeight = state . getMax ( ) ; } else if ( edge = = RectangleEdge . LEFT ) { tickLabelWidth = state . getMax ( ) ; } else if ( edge = = RectangleEdge . RIGHT ) { tickLabelWidth = state . getMax ( ) ; } } get the axis label size and update the space object . . . Rectangle _NUM D labelEnclosure = getLabelEnclosure ( g _NUM , edge ) ; double labelHeight = _NUM . _NUM ; double labelWidth = _NUM . _NUM ; if ( RectangleEdge . isTopOrBottom ( edge ) ) { labelHeight = labelEnclosure . getHeight ( ) ; space . add ( labelHeight + tickLabelHeight + this . categoryLabelPositionOffset , edge ) ; } else if ( RectangleEdge . isLeftOrRight ( edge ) ) { labelWidth = labelEnclosure . getWidth ( ) ; space . add ( labelWidth + tickLabelWidth + this . categoryLabelPositionOffset , edge ) ; } return space ; } 
1414	public boolean onSeekTo ( int position ) { MediaPlayer player = mPlayer ; if ( player ! = null & & ( mState & CAN _ SEEK ) ! = _NUM ) { if ( position < _NUM | | position > = getDuration ( ) ) { return false ; } else { if ( mState = = STATE _ ENDED ) { player . start ( ) ; player . pause ( ) ; setState ( STATE _ PAUSED ) ; } player . seekTo ( position ) ; } } else if ( ( mState & CAN _ READY _ SEEK ) ! = _NUM ) { mSeekOnReady = position ; } else { return false ; } return true ; } 
1415	private int getBytesRemainingInCurrentPage ( ) throws IOException { if ( ! dataAvailableInBuffer ( ) ) { return _NUM ; } Calculate our current position relative to the start of the current page . int currentDataOffsetInPage = ( currentOffsetInBuffer % PAGE _ SIZE ) - PAGE _ HEADER _ SIZE ; int pageBoundary = getCurrentPageStartInBuffer ( ) ; Get the data size of the current page from the header . short sizeOfCurrentPage = getPageSize ( blob , currentBuffer , pageBoundary ) ; return sizeOfCurrentPage - currentDataOffsetInPage ; } 
1416	public void load ( CmsObject cms , CmsResource resource , HttpServletRequest req , HttpServletResponse res ) throws IOException , CmsException { if ( canSendLastModifiedHeader ( resource , req , res ) ) { no further processing required return ; } make sure we have the file contents available CmsFile file = cms . readFile ( resource ) ; set response status to _STR header CmsFlexController . setDateExpiresHeader ( res , expireTime , m _ clientCacheMaxAge ) ; } } service ( cms , file , req , res ) ; } 
1417	protected void loadStore ( ) throws IOException { auto create starting directory if needed if ( ! fileStore . exists ( ) ) { LOG . debug ( _STR , cache . size ( ) , fileStore ) ; } 
1418	public NewTableConfiguration setProperties ( Map < String , String > props ) { checkArgument ( props ! = null , _STR ) ; checkTableProperties ( props ) ; this . properties = new HashMap < > ( props ) ; return this ; } 
1419	private boolean clearPassword ( ) { File passwordHashFile = getPasswordHashFile ( ) ; if ( passwordHashFile . exists ( ) & & ! passwordHashFile . delete ( ) ) { Slog . e ( TAG , _STR ) ; return false ; } mPasswordHash = null ; mPasswordSalt = null ; return true ; } 
1420	public void setFixedHeight ( int fixedHeight ) { mMask . fixedHeight = fixedHeight ; resetAll ( ) ; } 
1421	public void setMaxPagesToStateSave ( int maxPagesToStateSave ) { if ( maxPagesToStateSave < _NUM ) { throw new IllegalArgumentException ( _STR ) ; } this . maxPagesToStateSave = maxPagesToStateSave ; ensurePagesSaved ( ) ; } 
1422	public void plotVocab ( BarnesHutTsne tsne , int numWords , UiConnectionInfo connectionInfo ) { try { final List < String > labels = fitTnseAndGetLabels ( tsne , numWords ) ; final INDArray reducedData = tsne . getData ( ) ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = _NUM ; i < reducedData . rows ( ) & & i < numWords ; i + + ) { String word = labels . get ( i ) ; INDArray wordVector = reducedData . getRow ( i ) ; for ( int j = _NUM ; j < wordVector . length ( ) ; j + + ) { sb . append ( String . valueOf ( wordVector . getDouble ( j ) ) ) . append ( _STR , uri , e ) ; } } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } 
1423	public < T extends Tree > List < T > getLeaves ( List < T > list ) { if ( isLeaf ( ) ) { list . add ( ( T ) this ) ; } else { for ( Tree kid : children ( ) ) { kid . getLeaves ( list ) ; } } return list ; } 
1424	public static MutableByte fromExternal ( final Supplier < Byte > s , final Consumer < Byte > c ) { return new MutableByte ( ) { @ Override public byte getAsByte ( ) { return s . get ( ) ; } @ Override public Byte get ( ) { return getAsByte ( ) ; } @ Override public MutableByte set ( final byte value ) { c . accept ( value ) ; return this ; } } ; } 
1425	public void setFormat ( Format format ) { this . format = format . toString ( ) ; } 
1426	String getSyncTimes ( ) { StringBuilder buf = new StringBuilder ( ) ; for ( JournalAndStream jas : journals ) { if ( jas . isActive ( ) ) { buf . append ( jas . getCurrentStream ( ) . getTotalSyncTime ( ) ) ; buf . append ( _STR ) ; } } return buf . toString ( ) ; } 
1427	protected void removeHyperlink ( HyperlinkRecord link ) { for ( Iterator < RecordBase > it = _ sheet . getRecords ( ) . iterator ( ) ; it . hasNext ( ) ; ) { RecordBase rec = it . next ( ) ; if ( rec instanceof HyperlinkRecord ) { HyperlinkRecord recLink = ( HyperlinkRecord ) rec ; if ( link = = recLink ) { it . remove ( ) ; if multiple HSSFHyperlinks refer to the same record return ; } } } } 
1428	public static String saveChartAsPNG ( JFreeChart chart , int width , int height , ChartRenderingInfo info , HttpSession session ) throws IOException { if ( chart = = null ) { throw new IllegalArgumentException ( _STR ) ) ) ; ChartUtilities . saveChartAsPNG ( tempFile , chart , width , height , info ) ; if ( session ! = null ) { ServletUtilities . registerChartForDeletion ( tempFile , session ) ; } return tempFile . getName ( ) ; } 
1429	public static PGPPublicKeyRing insertPublicKey ( PGPPublicKeyRing pubRing , PGPPublicKey pubKey ) { List keys = new ArrayList ( pubRing . keys ) ; boolean found = false ; boolean masterFound = false ; for ( int i = _NUM ; i ! = keys . size ( ) ; i + + ) { PGPPublicKey key = ( PGPPublicKey ) keys . get ( i ) ; if ( key . getKeyID ( ) = = pubKey . getKeyID ( ) ) { found = true ; keys . set ( i , pubKey ) ; } if ( key . isMasterKey ( ) ) { masterFound = true ; } } if ( ! found ) { if ( pubKey . isMasterKey ( ) ) { if ( masterFound ) { throw new IllegalArgumentException ( _STR ) ; } keys . add ( _NUM , pubKey ) ; } else { keys . add ( pubKey ) ; } } return new PGPPublicKeyRing ( keys ) ; } 
1430	 @ GET @ Path ( _STR , savedQuery ) ; return Response . ok ( object ) . build ( ) ; } } catch ( WebApplicationException ex ) { throw ex ; } catch ( ItemNotFound itemNotFound ) { throw new NotFoundFormattedException ( itemNotFound . getMessage ( ) , itemNotFound ) ; } catch ( Exception ex ) { throw new ServiceFormattedException ( ex . getMessage ( ) , ex ) ; } } 
1431	protected void addBeanConnectionRelation ( MetaBean meta , String connection ) { Vector relations ; Object key ; relations = getBeanConnectionRelation ( meta ) ; add relation relations . add ( connection ) ; update if ( meta = = null ) key = REGULAR _ CONNECTION ; else key = meta ; m _ BeanConnectionRelation . put ( key , relations ) ; } 
1432	public LineCap getLineCap ( ) { AbstractEscherOptRecord opt = getEscherOptRecord ( ) ; EscherSimpleProperty prop = getEscherProperty ( opt , EscherProperties . LINESTYLE _ _ LINEENDCAPSTYLE ) ; return ( prop = = null ) ? LineCap . FLAT : LineCap . fromNativeId ( prop . getPropertyValue ( ) ) ; } 
1433	public static CellRangeAddress createEnclosingCellRange ( CellRangeAddress crA , CellRangeAddress crB ) { if ( crB = = null ) { return crA . copy ( ) ; } int minRow = lt ( crB . getFirstRow ( ) , crA . getFirstRow ( ) ) ? crB . getFirstRow ( ) : crA . getFirstRow ( ) ; int maxRow = gt ( crB . getLastRow ( ) , crA . getLastRow ( ) ) ? crB . getLastRow ( ) : crA . getLastRow ( ) ; int minCol = lt ( crB . getFirstColumn ( ) , crA . getFirstColumn ( ) ) ? crB . getFirstColumn ( ) : crA . getFirstColumn ( ) ; int maxCol = gt ( crB . getLastColumn ( ) , crA . getLastColumn ( ) ) ? crB . getLastColumn ( ) : crA . getLastColumn ( ) ; return new CellRangeAddress ( minRow , maxRow , minCol , maxCol ) ; } 
1434	public boolean onPreferenceClick ( Preference preference ) { LocalBluetoothProfile profile = mProfileManager . getProfileByName ( preference . getKey ( ) ) ; if ( profile = = null ) { It might be the PbapServerProfile , which is not stored by name . PbapServerProfile psp = mManager . getProfileManager ( ) . getPbapProfile ( ) ; if ( TextUtils . equals ( preference . getKey ( ) , psp . toString ( ) ) ) { profile = psp ; } else { return false ; } } SwitchPreference profilePref = ( SwitchPreference ) preference ; BluetoothDevice device = mCachedDevice . getDevice ( ) ; if ( profilePref . isChecked ( ) ) { enableProfile ( profile , device , profilePref ) ; } else { disableProfile ( profile , device , profilePref ) ; } refreshProfilePreference ( profilePref , profile ) ; return true ; } 
1435	protected static MediaType detect ( Set < String > names , DirectoryEntry root ) { if ( names ! = null ) { if ( names . contains ( _STR ) ) { return MSG ; } } } } Couldn ' t detect a more specific type return OLE ; } 
1436	public boolean contains ( Component cmp ) { if ( cmp = = null ) { return false ; } cmp = cmp . getParent ( ) ; while ( cmp ! = null ) { if ( cmp = = this ) { return true ; } cmp = cmp . getParent ( ) ; } return false ; } 
1437	private void scrollToChild ( View child ) { child . getDrawingRect ( mTempRect ) ; offsetDescendantRectToMyCoords ( child , mTempRect ) ; int scrollDelta = computeScrollDeltaToGetChildRectOnScreen ( mTempRect ) ; if ( scrollDelta ! = _NUM ) { scrollBy ( _NUM , scrollDelta ) ; } } 
1438	public void notifyViewAccessibilityStateChangedIfNeeded ( int changeType ) { if ( ! AccessibilityManager . getInstance ( mContext ) . isEnabled ( ) | | mAttachInfo = = null ) { return ; } from this view immediately . Otherwise , we can let it propagate up . if ( getAccessibilityLiveRegion ( ) ! = ACCESSIBILITY _ LIVE _ REGION _ NONE ) { final AccessibilityEvent event = AccessibilityEvent . obtain ( ) ; event . setEventType ( AccessibilityEvent . TYPE _ WINDOW _ CONTENT _ CHANGED ) ; event . setContentChangeTypes ( changeType ) ; sendAccessibilityEventUnchecked ( event ) ; } else if ( mParent ! = null ) { try { mParent . notifySubtreeAccessibilityStateChanged ( this , this , changeType ) ; } catch ( AbstractMethodError e ) { Log . e ( VIEW _ LOG _ TAG , mParent . getClass ( ) . getSimpleName ( ) + _STR , e ) ; } } } 
1439	public void setSelectionAfterHeaderView ( ) { final int count = getHeaderViewsCount ( ) ; if ( count > _NUM ) { mNextSelectedPosition = _NUM ; return ; } if ( mAdapter ! = null ) { setSelection ( count ) ; } else { mNextSelectedPosition = count ; mLayoutMode = LAYOUT _ SET _ SELECTION ; } } 
1440	public static File createDirectory ( File parent , String name ) { File created = new File ( parent , name ) ; checkDirectory ( created ) ; return created ; } 
1441	public final int delete ( @ RequiresPermission . Write @ NonNull Uri url , @ Nullable String where , @ Nullable String [ ] selectionArgs ) { Preconditions . checkNotNull ( url , _STR , where ) ; return rowsDeleted ; } catch ( RemoteException e ) { Manager will kill this process shortly anyway . return - _NUM ; } finally { releaseProvider ( provider ) ; } } 
1442	public ValueAxis getRangeAxisForDataset ( int index ) { if ( index < _NUM ) { throw new IllegalArgumentException ( _STR ) ; } ValueAxis axis = null ; List axisIndices = ( List ) this . datasetToRangeAxesMap . get ( new Integer ( index ) ) ; if ( axisIndices ! = null ) { the first axis in the list is used for data < - - > Java _NUM D Integer axisIndex = ( Integer ) axisIndices . get ( _NUM ) ; axis = getRangeAxis ( axisIndex . intValue ( ) ) ; } else { axis = getRangeAxis ( _NUM ) ; } return axis ; } 
1443	default < C extends Collection < CompletableFuture < T > > > C toCollection ( final Supplier < C > collectionFactory ) { return toStream ( ) . collect ( Collectors . toCollection ( collectionFactory ) ) ; } 
1444	public PollRequest build ( ) { validate ( ) ; return new PollRequest ( term , candidate , lastLogIndex , lastLogTerm ) ; } 
1445	private void handleTaskAttemptCompletion ( TaskAttemptId attemptId , TaskAttemptCompletionEventStatus status ) { TaskAttempt attempt = attempts . get ( attemptId ) ; to nextAttemptNumber if ( attempt . getNodeHttpAddress ( ) ! = null ) { TaskAttemptCompletionEvent tce = recordFactory . newRecordInstance ( TaskAttemptCompletionEvent . class ) ; tce . setEventId ( - _NUM ) ; String scheme = ( encryptedShuffle ) ? _STR + attempt . getShufflePort ( ) ) ) ; tce . setStatus ( status ) ; tce . setAttemptId ( attempt . getID ( ) ) ; int runTime = _NUM ; if ( attempt . getFinishTime ( ) ! = _NUM & & attempt . getLaunchTime ( ) ! = _NUM ) runTime = ( int ) ( attempt . getFinishTime ( ) - attempt . getLaunchTime ( ) ) ; tce . setAttemptRunTime ( runTime ) ; raise the event to job so that it adds the completion event to its data structures eventHandler . handle ( new JobTaskAttemptCompletedEvent ( tce ) ) ; } } 
1446	public void deleteStaticExportPublishedResource ( CmsDbContext dbc , String resourceName , int linkType , String linkParameter ) throws CmsException { getProjectDriver ( dbc ) . deleteStaticExportPublishedResource ( dbc , resourceName , linkType , linkParameter ) ; } 
1447	protected int insertKey ( short val ) { int hash , index ; hash = HashFunctions . hash ( val ) & _NUM x _NUM fffffff ; index = hash % _ states . length ; byte state = _ states [ index ] ; consumeFreeSlot = false ; if ( state = = FREE ) { consumeFreeSlot = true ; insertKeyAt ( index , val ) ; empty , all done return index ; } if ( state = = FULL & & _ set [ index ] = = val ) { already stored return - index - _NUM ; } already FULL or REMOVED , must probe return insertKeyRehash ( val , index , hash , state ) ; } 
1448	public void testPrivatePresentationVirtualDisplay ( ) throws Exception { VirtualDisplay virtualDisplay = mDisplayManager . createVirtualDisplay ( NAME , WIDTH , HEIGHT , DENSITY , mSurface , DisplayManager . VIRTUAL _ DISPLAY _ FLAG _ PRESENTATION ) ; assertNotNull ( _STR , display , BLUEISH , WindowManager . LayoutParams . TYPE _ PRIVATE _ PRESENTATION , _NUM ) ; } finally { virtualDisplay . release ( ) ; } assertDisplayUnregistered ( display ) ; } 
1449	public static BlockListAsLongs encode ( final Collection < ? extends Replica > replicas ) { BlockListAsLongs . Builder builder = builder ( ) ; for ( Replica replica : replicas ) { builder . add ( replica ) ; } return builder . build ( ) ; } 
1450	public void finish ( final Context ctx ) { global write lock : no read locks required if ( writes . global ( ) ) reads . reset ( ) ; resolve context references , sort , remove duplicates final Data data = ctx . data ( ) ; final String name = data = = null ? null : data . meta . name ; writes . finish ( name ) ; reads . finish ( name ) ; remove read locks that are also defined as write locks reads . remove ( writes ) ; } 
1451	public org . apache . drill . exec . proto . UserBitShared . DrillPBError . Builder getErrorBuilder ( ) { bitField _NUM _ | = _NUM x _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM ; onChanged ( ) ; return getErrorFieldBuilder ( ) . getBuilder ( ) ; } 
1452	private float getFloatParameter ( final String param ) { final Float p = ( Float ) getParameter ( param ) ; if ( p = = null ) { return _NUM ; } return p . floatValue ( ) ; } 
1453	private static String skipResponseHeaders ( final BufferedReader reader ) throws Throwable { String line ; line = skipEmptyLines ( reader ) ; LOG . debug ( _STR + line ) ; } while ( isNotBlank ( line ) ) ; } return line ; } 
1454	public CmsI _NUM _NUM nInfo getI _NUM _NUM nInfo ( HttpServletRequest req , CmsUser user , CmsProject project , String resource ) { Locale locale = null ; try to read locale from session if ( req ! = null ) { set the request character encoding try { req . setCharacterEncoding ( m _ encoding ) ; } catch ( UnsupportedEncodingException e ) { should not ever really happen LOG . error ( Messages . get ( ) . getBundle ( ) . key ( Messages . LOG _ UNSUPPORTED _ ENCODING _ SET _ _NUM , m _ encoding ) , e ) ; } read workplace settings HttpSession session = req . getSession ( false ) ; if ( session ! = null ) { CmsWorkplaceSettings settings = ( CmsWorkplaceSettings ) session . getAttribute ( CmsWorkplaceManager . SESSION _ WORKPLACE _ SETTINGS ) ; if ( settings ! = null ) { locale = settings . getUserSettings ( ) . getLocale ( ) ; } } } if ( locale = = null ) { no session available , try to read the locale form the user additional info if ( ! user . isGuestUser ( ) ) { check user settings only for _STR users CmsUserSettings settings = new CmsUserSettings ( user ) ; locale = settings . getLocale ( ) ; } if ( req ! = null ) { List < Locale > acceptedLocales = ( new CmsAcceptLanguageHeaderParser ( req , getDefaultLocale ( ) ) ) . getAcceptedLocales ( ) ; if ( ( locale ! = null ) & & ( ! acceptedLocales . contains ( locale ) ) ) { acceptedLocales . add ( _NUM , locale ) ; } locale = OpenCms . getLocaleManager ( ) . getFirstMatchingLocale ( acceptedLocales , m _ locales ) ; } if no locale was found , use the default if ( locale = = null ) { locale = getDefaultLocale ( ) ; } } return new CmsI _NUM _NUM nInfo ( locale , m _ encoding ) ; } 
1455	protected Dimension calcScrollSize ( ) { return calcPreferredSize ( ) ; } 
1456	protected List < ShadedTriangle > getShadedTriangles ( CoordinateColorPair [ ] [ ] patchCC ) { List < ShadedTriangle > list = new ArrayList < > ( ) ; int szV = patchCC . length ; int szU = patchCC [ _NUM ] . length ; for ( int i = _NUM ; i < szV ; i + + ) { for ( int j = _NUM ; j < szU ; j + + ) { Point _NUM D p _NUM = patchCC [ i - _NUM ] [ j - _NUM ] . coordinate , p _NUM = patchCC [ i - _NUM ] [ j ] . coordinate , p _NUM = patchCC [ i ] [ j ] . coordinate , p _NUM = patchCC [ i ] [ j - _NUM ] . coordinate ; boolean ll = true ; if ( overlaps ( p _NUM , p _NUM ) | | overlaps ( p _NUM , p _NUM ) ) { ll = false ; } else { p _NUM , p _NUM and p _NUM are in counter clock wise order , p _NUM has priority over p _NUM , p _NUM has priority over p _NUM Point _NUM D [ ] llCorner = { p _NUM , p _NUM , p _NUM } ; float [ ] [ ] llColor = { patchCC [ i - _NUM ] [ j - _NUM ] . color , patchCC [ i - _NUM ] [ j ] . color , patchCC [ i ] [ j - _NUM ] . color } ; lower left triangle ShadedTriangle tmpll = new ShadedTriangle ( llCorner , llColor ) ; list . add ( tmpll ) ; } if ( ll & & ( overlaps ( p _NUM , p _NUM ) | | overlaps ( p _NUM , p _NUM ) ) ) { } else { p _NUM , p _NUM and p _NUM are in counter clock wise order , p _NUM has priority over p _NUM , p _NUM has priority over p _NUM Point _NUM D [ ] urCorner = { p _NUM , p _NUM , p _NUM } ; float [ ] [ ] urColor = { patchCC [ i ] [ j - _NUM ] . color , patchCC [ i - _NUM ] [ j ] . color , patchCC [ i ] [ j ] . color } ; upper right triangle ShadedTriangle tmpur = new ShadedTriangle ( urCorner , urColor ) ; list . add ( tmpur ) ; } } } return list ; } 
1457	public void resize ( double scale ) { XSSFClientAnchor anchor = getClientAnchor ( ) ; XSSFClientAnchor pref = getPreferredSize ( scale ) ; int row _NUM = anchor . getRow _NUM ( ) + ( pref . getRow _NUM ( ) - pref . getRow _NUM ( ) ) ; int col _NUM = anchor . getCol _NUM ( ) + ( pref . getCol _NUM ( ) - pref . getCol _NUM ( ) ) ; anchor . setCol _NUM ( col _NUM ) ; anchor . setDx _NUM ( _NUM ) ; anchor . setDx _NUM ( pref . getDx _NUM ( ) ) ; anchor . setRow _NUM ( row _NUM ) ; anchor . setDy _NUM ( _NUM ) ; anchor . setDy _NUM ( pref . getDy _NUM ( ) ) ; } 
1458	public boolean setSelection ( int start , int end ) { if ( DEBUG ) Log . v ( TAG , _STR + end ) ; final Editable content = getEditable ( ) ; if ( content = = null ) return false ; int len = content . length ( ) ; if ( start > len | | end > len | | start < _NUM | | end < _NUM ) { anyway . return true ; } if ( start = = end & & MetaKeyKeyListener . getMetaState ( content , MetaKeyKeyListener . META _ SELECTING ) ! = _NUM ) { If we are in selection mode , then we want to extend the selection instead of replacing it . Selection . extendSelection ( content , start ) ; } else { Selection . setSelection ( content , start , end ) ; } return true ; } 
1459	public ViewInstanceDataEntity getInstanceData ( String key ) { String user = getCurrentUserName ( ) ; for ( ViewInstanceDataEntity viewInstanceDataEntity : data ) { if ( viewInstanceDataEntity . getName ( ) . equals ( key ) & & viewInstanceDataEntity . getUser ( ) . equals ( user ) ) { return viewInstanceDataEntity ; } } return null ; } 
1460	public String sign ( Algorithm algorithm ) throws IllegalArgumentException , JWTCreationException { if ( algorithm = = null ) { throw new IllegalArgumentException ( _STR ) ; String signingKeyId = algorithm . getSigningKeyId ( ) ; if ( signingKeyId ! = null ) { withKeyId ( signingKeyId ) ; } return new JWTCreator ( algorithm , headerClaims , payloadClaims ) . sign ( ) ; } 
1461	private String buildMethodLookup ( String methodName , int paramCount ) { StringBuffer buf = new StringBuffer ( _NUM _NUM ) ; buf . append ( methodName . toLowerCase ( ) ) ; buf . append ( _STR ) ; return buf . toString ( ) ; } 
1462	public void setRadius ( double radius ) { this . radius = radius ; applyChanges ( ) ; } 
1463	public synchronized void appendRaw ( byte [ ] keyData , int keyOffset , int keyLength , ValueBytes val ) throws IOException { if ( keyLength < _NUM ) throw new IOException ( _STR ) ; int valLength = val . getSize ( ) ; Save key / value data in relevant buffers WritableUtils . writeVInt ( keyLenBuffer , keyLength ) ; keyBuffer . write ( keyData , keyOffset , keyLength ) ; WritableUtils . writeVInt ( valLenBuffer , valLength ) ; val . writeUncompressedBytes ( valBuffer ) ; Added another key / value pair + + noBufferedRecords ; Compress and flush ? int currentBlockSize = keyBuffer . getLength ( ) + valBuffer . getLength ( ) ; if ( currentBlockSize > = compressionBlockSize ) { sync ( ) ; } } 
1464	public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( _STR ) ; return sb . toString ( ) ; } 
1465	public void testDefaultGetQueryTimeout ( ) throws SQLException { try ( Statement stmt = connection . createStatement ( ) ) { int timeoutValue = stmt . getQueryTimeout ( ) ; assertEquals ( _NUM , timeoutValue ) ; } } 
1466	public OptionalInt minByInt ( IntUnaryOperator keyExtractor ) { int [ ] result = collect ( ( ) - > new int [ _NUM ] , ( acc , i ) - > { int key = keyExtractor . applyAsInt ( i ) ; if ( acc [ _NUM ] = = _NUM | | acc [ _NUM ] > key ) { acc [ _NUM ] = i ; acc [ _NUM ] = key ; acc [ _NUM ] = _NUM ; } } , ( acc _NUM , acc _NUM ) - > { if ( acc _NUM [ _NUM ] = = _NUM & & ( acc _NUM [ _NUM ] = = _NUM | | acc _NUM [ _NUM ] > acc _NUM [ _NUM ] ) ) System . arraycopy ( acc _NUM , _NUM , acc _NUM , _NUM , _NUM ) ; } ) ; return result [ _NUM ] = = _NUM ? OptionalInt . of ( result [ _NUM ] ) : OptionalInt . empty ( ) ; } 
1467	public StrBuilder append ( final StringBuffer str ) { if ( str = = null ) { return appendNull ( ) ; } final int strLen = str . length ( ) ; if ( strLen > _NUM ) { final int len = length ( ) ; ensureCapacity ( len + strLen ) ; str . getChars ( _NUM , strLen , buffer , len ) ; size + = strLen ; } return this ; } 
1468	public void run ( ) { int numRetries = _NUM ; InetSocketAddress addr ; Socket client = null ; while ( ( ! shutdown ) & & ( numRetries < _NUM ) ) { try { ss = new ServerSocket ( ) ; ss . setReuseAddress ( true ) ; if ( self . getQuorumListenOnAllIPs ( ) ) { int port = self . getElectionAddress ( ) . getPort ( ) ; addr = new InetSocketAddress ( port ) ; } else { Resolve hostname for this server in case the underlying ip address has changed . self . recreateSocketAddresses ( self . getId ( ) ) ; addr = self . getElectionAddress ( ) ; } LOG . info ( _STR , ie ) ; } } } 
1469	public void onStateNotSaved ( ) { mFragments . noteStateNotSaved ( ) ; } 
1470	public static Lang resourceNameToLang ( String resourceName ) { return filenameToLang ( resourceName ) ; } 
1471	public void setStartEndTrim ( float startAngle , float endAngle ) { mRing . setStartTrim ( startAngle ) ; mRing . setEndTrim ( endAngle ) ; } 
1472	public ApfGenerator addLoadData ( Register destinationRegister , int offset ) throws IllegalInstructionException { requireApfVersion ( _NUM ) ; Instruction instruction = new Instruction ( Opcodes . LDDW , destinationRegister ) ; instruction . setSignedImm ( offset ) ; addInstruction ( instruction ) ; return this ; } 
1473	protected double distribution ( double [ ] [ ] props , double [ ] [ ] [ ] dists , int att , Instances data ) throws Exception { double splitPoint = Double . NaN ; Attribute attribute = data . attribute ( att ) ; double [ ] [ ] dist = null ; int indexOfFirstMissingValue = - _NUM ; if ( attribute . isNominal ( ) ) { For nominal attributes dist = new double [ attribute . numValues ( ) ] [ data . numClasses ( ) ] ; for ( int i = _NUM ; i < data . numInstances ( ) ; i + + ) { Instance inst = data . instance ( i ) ; if ( inst . isMissing ( att ) ) { Skip missing values at this stage if ( indexOfFirstMissingValue < _NUM ) { indexOfFirstMissingValue = i ; } continue ; } dist [ ( int ) inst . value ( att ) ] [ ( int ) inst . classValue ( ) ] + = inst . weight ( ) ; } } else { For numeric attributes double [ ] [ ] currDist = new double [ _NUM ] [ data . numClasses ( ) ] ; dist = new double [ _NUM ] [ data . numClasses ( ) ] ; Sort data data . sort ( att ) ; Move all instances into second subset for ( int j = _NUM ; j < data . numInstances ( ) ; j + + ) { Instance inst = data . instance ( j ) ; if ( inst . isMissing ( att ) ) { Can stop as soon as we hit a missing value indexOfFirstMissingValue = j ; break ; } currDist [ _NUM ] [ ( int ) inst . classValue ( ) ] + = inst . weight ( ) ; } Value before splitting double priorVal = priorVal ( currDist ) ; Save initial distribution for ( int j = _NUM ; j < currDist . length ; j + + ) { System . arraycopy ( currDist [ j ] , _NUM , dist [ j ] , _NUM , dist [ j ] . length ) ; } Try all possible split points double currSplit = data . instance ( _NUM ) . value ( att ) ; double currVal , bestVal = - Double . MAX _ VALUE ; for ( int i = _NUM ; i < data . numInstances ( ) ; i + + ) { Instance inst = data . instance ( i ) ; if ( inst . isMissing ( att ) ) { Can stop as soon as we hit a missing value break ; } Can we place a sensible split point here ? if ( inst . value ( att ) > currSplit ) { Compute gain for split point currVal = gain ( currDist , priorVal ) ; Is the current split point the best point so far ? if ( currVal > bestVal ) { Store value of current point bestVal = currVal ; Save split point splitPoint = ( inst . value ( att ) + currSplit ) / _NUM . _NUM ; Save distribution for ( int j = _NUM ; j < currDist . length ; j + + ) { System . arraycopy ( currDist [ j ] , _NUM , dist [ j ] , _NUM , dist [ j ] . length ) ; } } } currSplit = inst . value ( att ) ; Shift over the weight currDist [ _NUM ] [ ( int ) inst . classValue ( ) ] + = inst . weight ( ) ; currDist [ _NUM ] [ ( int ) inst . classValue ( ) ] - = inst . weight ( ) ; } } Compute weights for subsets props [ att ] = new double [ dist . length ] ; for ( int k = _NUM ; k < props [ att ] . length ; k + + ) { props [ att ] [ k ] = Utils . sum ( dist [ k ] ) ; } if ( Utils . eq ( Utils . sum ( props [ att ] ) , _NUM ) ) { for ( int k = _NUM ; k < props [ att ] . length ; k + + ) { props [ att ] [ k ] = _NUM . _NUM / ( double ) props [ att ] . length ; } } else { Utils . normalize ( props [ att ] ) ; } Any instances with missing values ? if ( indexOfFirstMissingValue > - _NUM ) { Distribute weights for instances with missing values for ( int i = indexOfFirstMissingValue ; i < data . numInstances ( ) ; i + + ) { Instance inst = data . instance ( i ) ; if ( attribute . isNominal ( ) ) { Need to check if attribute value is missing if ( inst . isMissing ( att ) ) { for ( int j = _NUM ; j < dist . length ; j + + ) { dist [ j ] [ ( int ) inst . classValue ( ) ] + = props [ att ] [ j ] * inst . weight ( ) ; } } } else { Can be sure that value is missing , so no test required for ( int j = _NUM ; j < dist . length ; j + + ) { dist [ j ] [ ( int ) inst . classValue ( ) ] + = props [ att ] [ j ] * inst . weight ( ) ; } } } } Return distribution and split point dists [ att ] = dist ; return splitPoint ; } 
1474	 @ SuppressWarnings ( _STR ) ; return ( T ) services . get ( serviceKlass ) ; } 
1475	public static org . apache . xmlbeans . xml . stream . XMLInputStream newValidatingXMLInputStream ( org . apache . xmlbeans . xml . stream . XMLInputStream xis , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , org . apache . xmlbeans . xml . stream . XMLStreamException { return XmlBeans . getContextTypeLoader ( ) . newValidatingXMLInputStream ( xis , type , options ) ; } 
1476	public String toProperString ( ) { if ( toProperString = = null ) { if ( numerator = = _NUM ) { toProperString = _STR + getDenominator ( ) ; } } return toProperString ; } 
1477	public void testShutdownClosesSender ( ) throws Exception { testedService = new TestableGraphiteMetricReporterService ( ) ; runner . addControllerService ( SERVICE _ IDENTIFIER , testedService ) ; setServiceProperties ( TEST _ HOST , TEST _ PORT , TEST _ CHARSET , METRIC _ NAMES _ PREFIX ) ; runner . enableControllerService ( testedService ) ; runner . disableControllerService ( testedService ) ; verify ( graphiteSenderMock ) . close ( ) ; } 
1478	public synchronized void clear ( ) { clearAnnotations ( ) ; clearSeriesValues ( ) ; } 
1479	public static XmlNOTATION parse ( java . net . URL u , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( XmlNOTATION ) XmlBeans . getContextTypeLoader ( ) . parse ( u , type , options ) ; } 
1480	public static XmlAnySimpleType parse ( java . io . InputStream is ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( XmlAnySimpleType ) XmlBeans . getContextTypeLoader ( ) . parse ( is , type , null ) ; } 
1481	private void saveModel ( String fileName , Instances trainHeader , Object model ) { m _ fileFormat = validateFileFormat ( m _ fileFormat ) ; if ( m _ fileFormat = = null ) { default to binary if validation fails m _ fileFormat = s _ fileFormatsAvailable . get ( _NUM ) ; } try { switch ( m _ fileFormat . getID ( ) ) { case KOMLV : fileName = fileName + KOML . FILE _ EXTENSION + FILE _ EXTENSION ; saveKOML ( new File ( fileName ) , model , trainHeader ) ; break ; case XSTREAM : fileName = fileName + XStream . FILE _ EXTENSION + FILE _ EXTENSION ; saveXStream ( new File ( fileName ) , model , trainHeader ) ; break ; default : fileName = fileName + _STR ) ; } } } 
1482	private void processParameters ( ) throws IOException { type = JPEG _NUM _NUM _NUM _NUM ; originalType = ORIGINAL _ JPEG _NUM _NUM _NUM _NUM ; inp = null ; try { String errorID ; if ( rawData = = null ) { inp = url . openStream ( ) ; errorID = url . toString ( ) ; } else { inp = new java . io . ByteArrayInputStream ( rawData ) ; errorID = _STR ) ) ; } } finally { if ( inp ! = null ) { try { inp . close ( ) ; } catch ( Exception e ) { } inp = null ; } } plainWidth = getWidth ( ) ; plainHeight = getHeight ( ) ; } 
1483	private Drawable getActivityIconWithCache ( ComponentName component ) { First check the icon cache String componentIconKey = component . flattenToShortString ( ) ; Using containsKey ( ) since we also store null values . if ( mOutsideDrawablesCache . containsKey ( componentIconKey ) ) { Drawable . ConstantState cached = mOutsideDrawablesCache . get ( componentIconKey ) ; return cached = = null ? null : cached . newDrawable ( mProviderContext . getResources ( ) ) ; } Then try the activity or application icon Drawable drawable = getActivityIcon ( component ) ; Stick it in the cache so we don ' t do this lookup again . Drawable . ConstantState toCache = drawable = = null ? null : drawable . getConstantState ( ) ; mOutsideDrawablesCache . put ( componentIconKey , toCache ) ; return drawable ; } 
1484	public void setIndex ( String indexName ) { resetLastResult ( ) ; CmsSearchIndex index ; if ( CmsStringUtil . isNotEmpty ( indexName ) ) { try { index = OpenCms . getSearchManager ( ) . getIndex ( indexName ) ; if ( index = = null ) { throw new CmsException ( Messages . get ( ) . container ( Messages . ERR _ INDEX _ NOT _ FOUND _ _NUM , indexName ) ) ; } m _ parameters . setSearchIndex ( index ) ; } catch ( Exception exc ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( Messages . get ( ) . getBundle ( ) . key ( Messages . LOG _ INDEX _ ACCESS _ FAILED _ _NUM , indexName ) , exc ) ; } m _ lastException = exc ; } } } 
1485	public void removeGroup ( int removed ) { List < L > cards = getGroups ( ) ; if ( removed > = _NUM & & removed < cards . size ( ) ) { boolean changed = cards . remove ( removed ) ! = null ; if ( changed ) { setData ( cards ) ; } } } 
1486	public int [ ] getReordering ( int [ ] linebreaks ) { validateLineBreaks ( linebreaks , textLength ) ; byte [ ] levels = getLevels ( linebreaks ) ; return computeMultilineReordering ( levels , linebreaks ) ; } 
1487	public void shutdown ( ) throws Exception { for ( CacheType type : CacheType . values ( ) ) { flushCache ( type ) ; } } 
1488	public void setSectionPaint ( Comparable key , Paint paint ) { null argument check delegated . . . this . sectionPaintMap . put ( key , paint ) ; fireChangeEvent ( ) ; } 
1489	public static ObjectAnimator fade ( View view , float from , float to , int duration , AnimatorListenerAdapter listener ) { ObjectAnimator alpha = ObjectAnimator . ofFloat ( view , _STR , from , to ) ; alpha . setDuration ( duration ) ; if ( listener ! = null ) { alpha . addListener ( listener ) ; } alpha . start ( ) ; return alpha ; } 
1490	public void setDescription ( String description ) { mDesc = getTrimmedString ( description ) ; } 
1491	void setNextSelectedPositionInt ( int position ) { mNextSelectedPosition = position ; mNextSelectedRowId = getItemIdAtPosition ( position ) ; If we are trying to sync to the selection , update that too if ( mNeedSync & & mSyncMode = = SYNC _ SELECTED _ POSITION & & position > = _NUM ) { mSyncPosition = position ; mSyncRowId = mNextSelectedRowId ; } } 
1492	public void run ( Object arg ) { for ( Function < Object , Object > handler : handlers ) { handler . apply ( arg ) ; } for ( Function < Object , Object > handler : threadHandlers . get ( ) ) { handler . apply ( arg ) ; } } 
1493	public void expireMasterSession ( ) throws Exception { HMaster master = getMiniHBaseCluster ( ) . getMaster ( ) ; expireSession ( master . getZooKeeper ( ) , false ) ; } 
1494	public TaskStackBuilder addParentStack ( Activity sourceActivity ) { final Intent parent = sourceActivity . getParentActivityIntent ( ) ; if ( parent ! = null ) { We have the actual parent intent , build the rest from static metadata then add the direct parent intent to the end . ComponentName target = parent . getComponent ( ) ; if ( target = = null ) { target = parent . resolveActivity ( mSourceContext . getPackageManager ( ) ) ; } addParentStack ( target ) ; addNextIntent ( parent ) ; } return this ; } 
1495	public void onTextChanged ( CharSequence s , int start , int before , int count ) { if ( isTextFilterEnabled ( ) ) { createTextFilter ( true ) ; int length = s . length ( ) ; boolean showing = mPopup . isShowing ( ) ; if ( ! showing & & length > _NUM ) { Show the filter popup if necessary showPopup ( ) ; mFiltered = true ; } else if ( showing & & length = = _NUM ) { Remove the filter popup if the user has cleared all text dismissPopup ( ) ; mFiltered = false ; } if ( mAdapter instanceof Filterable ) { Filter f = ( ( Filterable ) mAdapter ) . getFilter ( ) ; Filter should not be null when we reach this part if ( f ! = null ) { f . filter ( s , this ) ; } else { throw new IllegalStateException ( _STR ) ; } } } } 
1496	protected void drawClippedArc ( @ NonNull Canvas canvas , @ NonNull Path path , int color , @ NonNull Region . Op combine ) { canvas . save ( ) ; try { canvas . clipPath ( path , combine ) ; } catch ( UnsupportedOperationException e ) { Log . w ( TAG , _STR ) ; canvas . restore ( ) ; return ; } int colorOld = mPaint . getColor ( ) ; Shader shaderOld = mPaint . getShader ( ) ; mPaint . setColor ( color ) ; mPaint . setShader ( null ) ; drawArc ( canvas ) ; mPaint . setColor ( colorOld ) ; mPaint . setShader ( shaderOld ) ; canvas . restore ( ) ; } 
1497	 - - - - - - - - - - - - - - bulletin board - - - - - - - - - - - - - - @ GET @ Consumes ( MediaType . WILDCARD ) @ Produces ( MediaType . APPLICATION _ JSON ) @ Path ( _STR ) IntegerParameter limit ) throws InterruptedException { authorizeFlow ( ) ; replicate if cluster manager if ( isReplicateRequest ( ) ) { return replicate ( HttpMethod . GET ) ; } build the bulletin query final BulletinQueryDTO query = new BulletinQueryDTO ( ) ; if ( sourceId ! = null ) { query . setSourceId ( sourceId . getRawPattern ( ) ) ; } if ( groupId ! = null ) { query . setGroupId ( groupId . getRawPattern ( ) ) ; } if ( sourceName ! = null ) { query . setName ( sourceName . getRawPattern ( ) ) ; } if ( message ! = null ) { query . setMessage ( message . getRawPattern ( ) ) ; } if ( after ! = null ) { query . setAfter ( after . getLong ( ) ) ; } if ( limit ! = null ) { query . setLimit ( limit . getInteger ( ) ) ; } get the bulletin board final BulletinBoardDTO bulletinBoard = serviceFacade . getBulletinBoard ( query ) ; create the response entity BulletinBoardEntity entity = new BulletinBoardEntity ( ) ; entity . setBulletinBoard ( bulletinBoard ) ; generate the response return generateOkResponse ( entity ) . build ( ) ; } 
1498	This currently supports only update of one row at a time . Response updateBinary ( final byte [ ] message , final HttpHeaders headers , final boolean replace ) { servlet . getMetrics ( ) . incrementRequests ( _NUM ) ; if ( servlet . isReadOnly ( ) ) { servlet . getMetrics ( ) . incrementFailedPutRequests ( _NUM ) ; return Response . status ( Response . Status . FORBIDDEN ) . type ( MIMETYPE _ TEXT ) . entity ( _STR , ioe ) ; } } } 
1499	public static void upgradeDescVarLengthRowKeys ( PhoenixConnection conn , List < String > tablesToUpgrade , boolean bypassUpgrade ) throws SQLException { if ( tablesToUpgrade . isEmpty ( ) ) { return ; } List < PTable > tablesNeedingUpgrading = Lists . newArrayListWithExpectedSize ( tablesToUpgrade . size ( ) ) ; List < String > invalidTables = Lists . newArrayListWithExpectedSize ( tablesToUpgrade . size ( ) ) ; for ( String fullTableName : tablesToUpgrade ) { PTable table = PhoenixRuntime . getTable ( conn , fullTableName ) ; if ( isInvalidTableToUpgrade ( table ) ) { invalidTables . add ( fullTableName ) ; } else { tablesNeedingUpgrading . add ( table ) ; } } if ( ! invalidTables . isEmpty ( ) ) { StringBuilder buf = new StringBuilder ( _STR + table . getName ( ) . getString ( ) ) ; } } } finally { upgradeConn . close ( ) ; } } 
1500	public Task findTaskWithId ( int taskId ) { ArrayList < Task > tasks = computeAllTasksList ( ) ; int taskCount = tasks . size ( ) ; for ( int i = _NUM ; i < taskCount ; i + + ) { Task task = tasks . get ( i ) ; if ( task . key . id = = taskId ) { return task ; } } return null ; } 
1501	protected void onHoverIn ( MouseOverEvent event ) { if ( ( getParentMenu ( ) . getSelectedItem ( ) ! = null ) & & ( getParentMenu ( ) . getSelectedItem ( ) ! = this ) & & getParentMenu ( ) . getSelectedItem ( ) . hasSubmenu ( ) ) { getParentMenu ( ) . getSelectedItem ( ) . getSubMenu ( ) . onClose ( ) ; getParentMenu ( ) . getSelectedItem ( ) . deselectItem ( ) ; } if ( hasSubmenu ( ) ) { getSubMenu ( ) . openPopup ( this ) ; } selectItem ( ) ; } 
1502	public double getAsDouble ( int index ) { switch ( type ) { case TIFF _ BYTE : return ( ( byte [ ] ) data ) [ index ] & _NUM xff ; case TIFF _ SBYTE : return ( ( byte [ ] ) data ) [ index ] ; case TIFF _ SHORT : return ( ( char [ ] ) data ) [ index ] & _NUM xffff ; case TIFF _ SSHORT : return ( ( short [ ] ) data ) [ index ] ; case TIFF _ SLONG : return ( ( int [ ] ) data ) [ index ] ; case TIFF _ LONG : return ( ( long [ ] ) data ) [ index ] ; case TIFF _ FLOAT : return ( ( float [ ] ) data ) [ index ] ; case TIFF _ DOUBLE : return ( ( double [ ] ) data ) [ index ] ; case TIFF _ SRATIONAL : int [ ] ivalue = getAsSRational ( index ) ; return ( double ) ivalue [ _NUM ] / ivalue [ _NUM ] ; case TIFF _ RATIONAL : long [ ] lvalue = getAsRational ( index ) ; return ( double ) lvalue [ _NUM ] / lvalue [ _NUM ] ; default : throw new ClassCastException ( ) ; } } 
1503	public Uid . Pkg . Serv getServiceStatsLocked ( int uid , String pkg , String name ) { uid = mapUid ( uid ) ; Uid u = getUidStatsLocked ( uid ) ; return u . getServiceStatsLocked ( pkg , name ) ; } 
1504	public void onCloseSystemDialogs ( ) { hide ( ) ; } 
1505	public GpodnetSubscriptionChange getSubscriptionChanges ( @ NonNull String username , @ NonNull String deviceId , long timestamp ) throws GpodnetServiceException { String params = String . format ( _STR , username , deviceId ) ; try { URL url = new URI ( BASE _ SCHEME , null , BASE _ HOST , - _NUM , path , params , null ) . toURL ( ) ; Request . Builder request = new Request . Builder ( ) . url ( url ) ; String response = executeRequest ( request ) ; JSONObject changes = new JSONObject ( response ) ; return readSubscriptionChangesFromJSONObject ( changes ) ; } catch ( URISyntaxException e ) { e . printStackTrace ( ) ; throw new IllegalStateException ( e ) ; } catch ( JSONException | MalformedURLException e ) { e . printStackTrace ( ) ; throw new GpodnetServiceException ( e ) ; } } 
1506	public static org . apache . xmlbeans . xml . stream . XMLInputStream newValidatingXMLInputStream ( org . apache . xmlbeans . xml . stream . XMLInputStream xis ) throws org . apache . xmlbeans . XmlException , org . apache . xmlbeans . xml . stream . XMLStreamException { return XmlBeans . getContextTypeLoader ( ) . newValidatingXMLInputStream ( xis , type , null ) ; } 
1507	public static < K , V > EntryStream < K , V > of ( Stream < ? extends Entry < K , V > > stream ) { if ( stream instanceof AbstractStreamEx ) { @ SuppressWarnings ( _STR ) AbstractStreamEx < Entry < K , V > , ? > ase = ( AbstractStreamEx < Entry < K , V > , ? > ) stream ; if ( ase . spliterator ! = null ) return new EntryStream < > ( ase . spliterator ( ) , ase . context ) ; return new EntryStream < > ( ase . stream ( ) , ase . context ) ; } return new EntryStream < > ( stream , StreamContext . of ( stream ) ) ; } 
1508	 @ Test ( groups = _STR ) ; } catch ( NoHostAvailableException e ) { assertThat ( e . getErrors ( ) . keySet ( ) ) . hasSize ( _NUM ) . containsOnly ( host _NUM . getSocketAddress ( ) , host _NUM . getSocketAddress ( ) , host _NUM . getSocketAddress ( ) ) ; assertThat ( e . getErrors ( ) . values ( ) ) . hasOnlyElementsOfType ( exception ) ; } assertOnRequestErrorWasCalled ( _NUM , exception ) ; assertThat ( errors . getOthers ( ) . getCount ( ) ) . isEqualTo ( _NUM ) ; assertThat ( errors . getRetries ( ) . getCount ( ) ) . isEqualTo ( _NUM ) ; assertThat ( errors . getRetriesOnOtherErrors ( ) . getCount ( ) ) . isEqualTo ( _NUM ) ; assertQueried ( _NUM , _NUM ) ; assertQueried ( _NUM , _NUM ) ; assertQueried ( _NUM , _NUM ) ; } 
1509	public static String encodeObject ( java . io . Serializable serializableObject , int options ) throws java . io . IOException { if ( serializableObject = = null ) { throw new NullPointerException ( _STR ) ; } end if : null Streams java . io . ByteArrayOutputStream baos = null ; java . io . OutputStream b _NUM _NUM os = null ; java . util . zip . GZIPOutputStream gzos = null ; java . io . ObjectOutputStream oos = null ; try { ObjectOutputStream - > ( GZIP ) - > Base _NUM _NUM - > ByteArrayOutputStream baos = new java . io . ByteArrayOutputStream ( ) ; b _NUM _NUM os = new OutputStream ( baos , ENCODE | options ) ; if ( ( options & GZIP ) ! = _NUM ) { Gzip gzos = new java . util . zip . GZIPOutputStream ( b _NUM _NUM os ) ; oos = new java . io . ObjectOutputStream ( gzos ) ; } else { Not gzipped oos = new java . io . ObjectOutputStream ( b _NUM _NUM os ) ; } oos . writeObject ( serializableObject ) ; } end try catch ( java . io . IOException e ) { the finally { } block is called for cleanup . throw e ; } finally end catch { try { oos . close ( ) ; } catch ( Exception e ) { } try { gzos . close ( ) ; } catch ( Exception e ) { } try { b _NUM _NUM os . close ( ) ; } catch ( Exception e ) { } try { baos . close ( ) ; } catch ( Exception e ) { } } Return value according to relevant encoding . try { return new String ( baos . toByteArray ( ) , PREFERRED _ ENCODING ) ; } end try catch ( java . io . UnsupportedEncodingException uue ) { Fall back to some Java default return new String ( baos . toByteArray ( ) ) ; } end catch } 
1510	private ActivityManager . RecentTaskInfo createRecentTaskInfoFromTaskRecord ( TaskRecord tr ) { Update the task description to reflect any changes in the task stack tr . updateTaskDescription ( ) ; Compose the recent task info ActivityManager . RecentTaskInfo rti = new ActivityManager . RecentTaskInfo ( ) ; rti . id = tr . getTopActivity ( ) = = null ? INVALID _ TASK _ ID : tr . taskId ; rti . persistentId = tr . taskId ; rti . baseIntent = new Intent ( tr . getBaseIntent ( ) ) ; rti . origActivity = tr . origActivity ; rti . realActivity = tr . realActivity ; rti . description = tr . lastDescription ; rti . stackId = tr . getStackId ( ) ; rti . userId = tr . userId ; rti . taskDescription = new ActivityManager . TaskDescription ( tr . lastTaskDescription ) ; rti . firstActiveTime = tr . firstActiveTime ; rti . lastActiveTime = tr . lastActiveTime ; rti . affiliatedTaskId = tr . mAffiliatedTaskId ; rti . affiliatedTaskColor = tr . mAffiliatedTaskColor ; rti . numActivities = _NUM ; if ( tr . mBounds ! = null ) { rti . bounds = new Rect ( tr . mBounds ) ; } rti . supportsSplitScreenMultiWindow = tr . supportsSplitScreen ( ) ; rti . resizeMode = tr . mResizeMode ; ActivityRecord base = null ; ActivityRecord top = null ; ActivityRecord tmp ; for ( int i = tr . mActivities . size ( ) - _NUM ; i > = _NUM ; - - i ) { tmp = tr . mActivities . get ( i ) ; if ( tmp . finishing ) { continue ; } base = tmp ; if ( top = = null | | ( top . state = = ActivityState . INITIALIZING ) ) { top = base ; } rti . numActivities + + ; } rti . baseActivity = ( base ! = null ) ? base . intent . getComponent ( ) : null ; rti . topActivity = ( top ! = null ) ? top . intent . getComponent ( ) : null ; return rti ; } 
1511	public void parseConfigFileWithInvalidMimeType ( ) throws Exception { String configStr = loadResourceFile ( PASSPOINT _ INSTALLATION _ FILE _ WITH _ CA _ CERT ) ; assertNull ( ConfigParser . parsePasspointConfig ( _STR , configStr . getBytes ( ) ) ) ; } 
1512	public void add ( int location , E object ) { insertElementAt ( object , location ) ; } 
1513	public void run ( Class testClass , String . . . methods ) { start ( testClass , methods ) ; } 
1514	public static void main ( String [ ] args ) throws Exception { if ( args . length ! = _NUM ) { System . out . println ( _STR ) ; } out . close ( ) ; in . close ( ) ; } 
1515	public static DataService buildDataServiceStd ( DatasetGraph dsg , boolean allowUpdate ) { DataService dataService = new DataService ( dsg ) ; populateStdServices ( dataService , allowUpdate ) ; return dataService ; } 
1516	public void doRun ( int run ) throws Exception { if ( getRawOutput ( ) ) { if ( m _ ZipDest = = null ) { m _ ZipDest = new OutputZipper ( m _ OutputFile ) ; } } if ( m _ Instances = = null ) { throw new Exception ( _STR ) ; m _ ZipDest . zipit ( m _ SplitEvaluator . getRawResultOutput ( ) , resultName ) ; } m _ ResultListener . acceptResult ( this , key , results ) ; } catch ( Exception ex ) { Save the train and test datasets for debugging purposes ? throw ex ; } } } } 
1517	private static boolean isSpringAopProxy ( Object object ) { Class < ? > clazz = object . getClass ( ) ; return ( implementsInterface ( clazz , SPRING _ SPRINGPROXY _ CLASS _ NAME ) & & ( Proxy . isProxyClass ( clazz ) | | isCglibProxyClass ( clazz ) ) ) ; } 
1518	public String getTagHtml ( Tag tag ) { StringBuffer result = new StringBuffer ( _NUM _NUM ) ; result . append ( ' < ' ) ; result . append ( tag . getText ( ) ) ; result . append ( ' > ' ) ; return result . toString ( ) ; } 
1519	public void dismissHover ( ) { if ( getHoverStatus ( ) ! = HOVER _ STATUS . APPEARED | | ! mPlayingAnimators . isEmpty ( ) ) return ; startBlurImageDisappearAnimator ( ) ; startHoverDisappearAnimator ( ) ; startChildrenDisappearAnimations ( ) ; } 
1520	public CipherParameters encrypt ( byte [ ] out , int outOff , int keyLen ) throws IllegalArgumentException { if ( ! ( key instanceof ECPublicKeyParameters ) ) { throw new IllegalArgumentException ( _STR ) ; } ECPublicKeyParameters ecPubKey = ( ECPublicKeyParameters ) key ; ECDomainParameters ecParams = ecPubKey . getParameters ( ) ; ECCurve curve = ecParams . getCurve ( ) ; BigInteger n = ecParams . getN ( ) ; BigInteger h = ecParams . getH ( ) ; Generate the ephemeral key pair BigInteger r = BigIntegers . createRandomInRange ( ONE , n , rnd ) ; Compute the static - ephemeral key agreement BigInteger rPrime = CofactorMode ? r . multiply ( h ) . mod ( n ) : r ; ECMultiplier basePointMultiplier = createBasePointMultiplier ( ) ; ECPoint [ ] ghTilde = new ECPoint [ ] { basePointMultiplier . multiply ( ecParams . getG ( ) , r ) , ecPubKey . getQ ( ) . multiply ( rPrime ) } ; NOTE : More efficient than normalizing each individually curve . normalizeAll ( ghTilde ) ; ECPoint gTilde = ghTilde [ _NUM ] , hTilde = ghTilde [ _NUM ] ; Encode the ephemeral public key byte [ ] C = gTilde . getEncoded ( false ) ; System . arraycopy ( C , _NUM , out , outOff , C . length ) ; Encode the shared secret value byte [ ] PEH = hTilde . getAffineXCoord ( ) . getEncoded ( ) ; return deriveKey ( keyLen , C , PEH ) ; } 
1521	public boolean isIrreducible ( ) { if ( isZero ( ) ) { return false ; } GF _NUM Polynomial f = new GF _NUM Polynomial ( this ) ; int d , i ; GF _NUM Polynomial u , g ; GF _NUM Polynomial dummy ; f . reduceN ( ) ; d = f . len - _NUM ; u = new GF _NUM Polynomial ( f . len , _STR ) ) ; if ( ! dummy . isZero ( ) ) { g = f . gcd ( dummy ) ; if ( ! g . isOne ( ) ) { return false ; } } else { return false ; } } return true ; } 
1522	public boolean checkGuard ( Task < E > control ) { No guard to check if ( guard = = null ) return true ; Check the guard of the guard recursively if ( ! guard . checkGuard ( control ) ) return false ; Use the tree ' s guard evaluator task to check the guard of this task guard . setControl ( control . tree . guardEvaluator ) ; guard . start ( ) ; guard . run ( ) ; switch ( guard . getStatus ( ) ) { case SUCCEEDED : return true ; case FAILED : return false ; default : throw new IllegalStateException ( _STR ) ; } } 
1523	public static XmlGYear parse ( java . io . InputStream is , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( XmlGYear ) XmlBeans . getContextTypeLoader ( ) . parse ( is , type , options ) ; } 
1524	public void writeBase _NUM _NUM ( ) throws IOException { Case _NUM : content is xs : base _NUM _NUM Binary final HttpRequest req _NUM = new HttpRequest ( ) ; req _NUM . payloadAtts . put ( _STR , out _NUM . toString ( ) ) ; } 
1525	public static void createKeyStore ( String filename , String password , String keyPassword , String alias , Key privateKey , Certificate cert ) throws GeneralSecurityException , IOException { KeyStore ks = createEmptyKeyStore ( ) ; ks . setKeyEntry ( alias , privateKey , keyPassword . toCharArray ( ) , new Certificate [ ] { cert } ) ; saveKeyStore ( ks , filename , password ) ; } 
1526	public static XmlNonNegativeInteger parse ( java . lang . String s ) throws org . apache . xmlbeans . XmlException { return ( XmlNonNegativeInteger ) XmlBeans . getContextTypeLoader ( ) . parse ( s , type , null ) ; } 
1527	public final double classProb ( int classIndex , Instance instance , int theSubset ) throws Exception { if ( theSubset < = - _NUM ) { double [ ] weights = weights ( instance ) ; if ( weights = = null ) { return m _ distribution . prob ( classIndex ) ; } else { double prob = _NUM ; for ( int i = _NUM ; i < weights . length ; i + + ) { prob + = weights [ i ] * m _ distribution . prob ( classIndex , i ) ; } return prob ; } } else { if ( Utils . gr ( m _ distribution . perBag ( theSubset ) , _NUM ) ) { return m _ distribution . prob ( classIndex , theSubset ) ; } else { return m _ distribution . prob ( classIndex ) ; } } } 
1528	public synchronized void acceptTrainingSet ( TrainingSetEvent e ) { TextEvent nt = new TextEvent ( e . getSource ( ) , e . getTrainingSet ( ) . toString ( ) , e . getTrainingSet ( ) . relationName ( ) ) ; acceptText ( nt ) ; } 
1529	private void populateConfigurationModules ( ) { ConfigurationDirectory configDirectory = serviceDirectory . getConfigurationDirectory ( serviceInfo . getConfigDir ( ) , StackDirectory . SERVICE _ PROPERTIES _ FOLDER _ NAME ) ; if ( configDirectory ! = null ) { for ( ConfigurationModule config : configDirectory . getConfigurationModules ( ) ) { ConfigurationInfo info = config . getModuleInfo ( ) ; if ( isValid ( ) ) { setValid ( config . isValid ( ) & & info . isValid ( ) ) ; if ( ! isValid ( ) ) { addErrors ( config . getErrors ( ) ) ; addErrors ( info . getErrors ( ) ) ; } } serviceInfo . getProperties ( ) . addAll ( info . getProperties ( ) ) ; serviceInfo . setTypeAttributes ( config . getConfigType ( ) , info . getAttributes ( ) ) ; configurationModules . put ( config . getConfigType ( ) , config ) ; } for ( String excludedType : serviceInfo . getExcludedConfigTypes ( ) ) { if ( ! configurationModules . containsKey ( excludedType ) ) { ConfigurationInfo configInfo = new ConfigurationInfo ( Collections . emptyList ( ) , Collections . emptyMap ( ) ) ; ConfigurationModule config = new ConfigurationModule ( excludedType , configInfo ) ; config . setDeleted ( true ) ; configurationModules . put ( excludedType , config ) ; } } } } 
1530	private void preParse ( ) { First off the { to start the object expect ( _STR , peekToken ( ) ) ; } } while ( true ) ; } 
1531	void scrapActiveViews ( ) { final View [ ] activeViews = mActiveViews ; final boolean multipleScraps = mViewTypeCount > _NUM ; ArrayList < View > scrapViews = mCurrentScrap ; final int count = activeViews . length ; for ( int i = count - _NUM ; i > = _NUM ; i - - ) { final View victim = activeViews [ i ] ; if ( victim ! = null ) { final LayoutParams lp = ( LayoutParams ) victim . getLayoutParams ( ) ; activeViews [ i ] = null ; final boolean scrapHasTransientState = ViewCompat . hasTransientState ( victim ) ; int viewType = lp . viewType ; if ( ! shouldRecycleViewType ( viewType ) | | scrapHasTransientState ) { Do not move views that should be ignored if ( viewType ! = ITEM _ VIEW _ TYPE _ HEADER _ OR _ FOOTER | | scrapHasTransientState ) { removeDetachedView ( victim , false ) ; } if ( scrapHasTransientState ) { if ( mTransientStateViews = = null ) { mTransientStateViews = new SparseArrayCompat < View > ( ) ; } mTransientStateViews . put ( mFirstActivePosition + i , victim ) ; } continue ; } if ( multipleScraps ) { scrapViews = mScrapViews [ viewType ] ; } lp . position = mFirstActivePosition + i ; scrapViews . add ( victim ) ; } } pruneScrapViews ( ) ; } 
1532	private boolean shouldLogDataBeProcessed ( ILogData logData ) { boolean shouldProcess = false ; for ( UUID id : logData . getStreams ( ) ) { if ( shouldStreamBeProcessed ( id ) ) { shouldProcess = true ; } } return shouldProcess ; } 
1533	public void setText ( String t ) { if ( isCapsText ( ) ) { putClientProperty ( _STR , t ) ; if ( t ! = null ) { super . setText ( getUIManager ( ) . localize ( t , t ) . toUpperCase ( ) ) ; return ; } } super . setText ( t ) ; } 
1534	public void setStartEndTrim ( float startAngle , float endAngle ) { mRing . setStartTrim ( startAngle ) ; mRing . setEndTrim ( endAngle ) ; } 
1535	public int getBoundariesFromSSTableDirectory ( Descriptor descriptor ) { for ( int i = _NUM ; i < directories . size ( ) ; i + + ) { Directories . DataDirectory directory = directories . get ( i ) ; if ( descriptor . directory . getAbsolutePath ( ) . startsWith ( directory . location . getAbsolutePath ( ) ) ) return i ; } return _NUM ; } 
1536	public void updateCategoriesTab ( ) { if ( m _ dialogBean . getCategories ( ) = = null ) { loadCategories ( ) ; } else { m _ handler . onCategoriesTabSelection ( ) ; } } 
1537	public static long getLeastCallCount ( String appName ) { FaultToleranceConfig config = getConfig ( appName ) ; return config . getLeastCallCount ( ) ; } 
1538	public void onSurfaceCreated ( GL _NUM _NUM glUnused , EGLConfig config ) { Log . d ( TAG , _STR ) ; } synchronized ( this ) { updateSurface = false ; } } 
1539	public void setBarColor ( @ ColorInt final int color ) { LinearLayout bottomBar = findViewById ( R . id . bottom ) ; bottomBar . setBackgroundColor ( color ) ; } 
1540	public void removeAllActions ( ) { if ( mActions ! = null ) { mActions . clear ( ) ; } } 
1541	public static < T > Stream < T > ofNullable ( Iterator < ? extends T > iterator ) { return ( iterator = = null ) ? Stream . < T > empty ( ) : Stream . of ( iterator ) ; } 
1542	public JSONObject getApplicationInfo ( ) throws IOException { String service = _STR + responseJson ) ; return new JSONObject ( responseJson ) ; } catch ( JSONException e ) { throw new IOException ( e ) ; } } 
1543	private String formatTypeAndValue ( Class < ? > declaredType , Object value ) { final String declaredTypePart = _STR ; actualValuePart = idPrefix + formatValue ( value ) ; } } } final String result = declaredTypePart + actualTypePart + actualValuePart ; return result ; } 
1544	public void attachToken ( IBinder token ) { if ( mToken = = null ) { mToken = token ; mWindow . setToken ( token ) ; } } 
1545	public void selectResource ( String resourcePath , String title ) { switch ( getGalleryMode ( ) ) { case widget : CmsPreviewUtil . setResourcePath ( resourcePath ) ; break ; case editor : CmsPreviewUtil . setLink ( resourcePath , title , null ) ; CmsPreviewUtil . closeDialog ( ) ; break ; case ade : case view : default : nothing to do here , should not be called break ; } } 
1546	public static long getMemoryAsBytes ( String str ) { char lastChar = str . charAt ( str . length ( ) - _NUM ) ; if ( lastChar = = ' % ' ) { try { int percent = Integer . parseInt ( str . substring ( _NUM , str . length ( ) - _NUM ) ) ; if ( percent < = _NUM | | percent > = _NUM _NUM _NUM ) { throw new IllegalArgumentException ( _STR ) ; } } return getFixedMemoryAsBytes ( str ) ; } 
1547	public Builder clearSchemaNameFilter ( ) { if ( schemaNameFilterBuilder _ = = null ) { schemaNameFilter _ = org . apache . drill . exec . proto . UserProtos . LikeFilter . getDefaultInstance ( ) ; onChanged ( ) ; } else { schemaNameFilterBuilder _ . clear ( ) ; } bitField _NUM _ = ( bitField _NUM _ & ~ _NUM x _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM ) ; return this ; } 
1548	public Drawable getOverflowIcon ( ) { getMenu ( ) ; return mPresenter . getOverflowIcon ( ) ; } 
1549	public Object nextMeta ( ) throws JSONException { char c ; char q ; do { c = next ( ) ; } while ( Character . isWhitespace ( c ) ) ; switch ( c ) { case _NUM : throw syntaxError ( _STR ' : case ' \ ' ' : back ( ) ; return Boolean . TRUE ; default : } } } } 
1550	public InetSocketAddress getPeer ( ) throws PeerDiscoveryException { try { return nextPeer ( ) ; } catch ( UnknownHostException e ) { throw new PeerDiscoveryException ( e ) ; } } 
1551	public String [ ] getTetherableUsbRegexs ( ) { enforceTetherAccessPermission ( ) ; if ( isTetheringSupported ( ) ) { return mTethering . getTetherableUsbRegexs ( ) ; } else { return new String [ _NUM ] ; } } 
1552	public byte [ ] getThumbnailAsWMF ( ) throws HPSFException { if ( ! ( getClipboardFormatTag ( ) = = CFTAG _ WINDOWS ) ) throw new HPSFException ( _STR ) ; } byte [ ] thumbnail = getThumbnail ( ) ; int wmfImageLength = thumbnail . length - OFFSET _ WMFDATA ; byte [ ] wmfImage = new byte [ wmfImageLength ] ; System . arraycopy ( thumbnail , OFFSET _ WMFDATA , wmfImage , _NUM , wmfImageLength ) ; return wmfImage ; } 
1553	protected boolean performButtonActionOnTouchDown ( MotionEvent event ) { if ( event . isFromSource ( InputDevice . SOURCE _ MOUSE ) & & ( event . getButtonState ( ) & MotionEvent . BUTTON _ SECONDARY ) ! = _NUM ) { showContextMenu ( event . getX ( ) , event . getY ( ) ) ; mPrivateFlags | = PFLAG _ CANCEL _ NEXT _ UP _ EVENT ; return true ; } return false ; } 
1554	public void paint ( Graphics g , Shape a ) { RSyntaxDocument document = ( RSyntaxDocument ) getDocument ( ) ; Rectangle alloc = a . getBounds ( ) ; tabBase = alloc . x ; host = ( RSyntaxTextArea ) getContainer ( ) ; Rectangle clip = g . getClipBounds ( ) ; An attempt to speed things up for files with long lines . Note that this will actually slow things down a bit for the common case of regular - length lines , but it doesn ' t make a perceivable difference . clipStart = clip . x ; clipEnd = clipStart + clip . width ; lineHeight = host . getLineHeight ( ) ; metrics . getAscent ( ) ; ascent = host . getMaxAscent ( ) ; int heightAbove = clip . y - alloc . y ; int linesAbove = Math . max ( _NUM , heightAbove / lineHeight ) ; FoldManager fm = host . getFoldManager ( ) ; linesAbove + = fm . getHiddenLineCountAbove ( linesAbove , true ) ; Rectangle lineArea = lineToRect ( a , linesAbove ) ; int y = lineArea . y + ascent ; int x = lineArea . x ; Element map = getElement ( ) ; int lineCount = map . getElementCount ( ) ; Whether token styles should always be painted , even in selections int selStart = host . getSelectionStart ( ) ; int selEnd = host . getSelectionEnd ( ) ; RSyntaxTextAreaHighlighter h = ( RSyntaxTextAreaHighlighter ) host . getHighlighter ( ) ; Graphics _NUM D g _NUM d = ( Graphics _NUM D ) g ; Token token ; System . err . println ( _STR + count ) ; } 
1555	 @ SuppressWarnings ( _STR , e ) ; } return answer ; } 
1556	public static String formatStats ( BloomFilterBase bloomFilter ) { StringBuilder sb = new StringBuilder ( ) ; long k = bloomFilter . getKeyCount ( ) ; long m = bloomFilter . getMaxKeys ( ) ; sb . append ( _STR + NumberFormat . getPercentInstance ( ) . format ( k * _NUM . _NUM / m ) ) ; } return sb . toString ( ) ; } 
1557	public void updateRotation ( boolean alwaysSendConfiguration , boolean forceRelayout ) { updateRotationUnchecked ( alwaysSendConfiguration , forceRelayout ) ; } 
1558	public void getDefaultDownloadableSubscriptionList ( PendingIntent callbackIntent ) { if ( ! isEnabled ( ) ) { sendUnavailableError ( callbackIntent ) ; return ; } try { getIEuiccController ( ) . getDefaultDownloadableSubscriptionList ( mContext . getOpPackageName ( ) , callbackIntent ) ; } catch ( RemoteException e ) { throw e . rethrowFromSystemServer ( ) ; } } 
1559	private void onEntryRemovedInternal ( NotificationData . Entry removed , final StatusBarNotification sbn ) { String groupKey = getGroupKey ( sbn ) ; final NotificationGroup group = mGroupMap . get ( groupKey ) ; if ( group = = null ) { the close future . See b / _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM for reference . return ; } if ( isGroupChild ( sbn ) ) { group . children . remove ( removed . key ) ; } else { group . summary = null ; } updateSuppression ( group ) ; if ( group . children . isEmpty ( ) ) { if ( group . summary = = null ) { mGroupMap . remove ( groupKey ) ; } } } 
1560	public boolean tryAcquire ( final long timeoutMs ) throws InterruptedException { if ( proc ! = null & & proc . isLocked ( ) ) { return true ; } Use new condition and procedure every time lock is requested . final CountDownLatch lockAcquireLatch = new CountDownLatch ( _NUM ) ; if ( regionInfos ! = null ) { proc = new LockProcedure ( master . getConfiguration ( ) , regionInfos , type , description , lockAcquireLatch ) ; } else if ( tableName ! = null ) { proc = new LockProcedure ( master . getConfiguration ( ) , tableName , type , description , lockAcquireLatch ) ; } else if ( namespace ! = null ) { proc = new LockProcedure ( master . getConfiguration ( ) , namespace , type , description , lockAcquireLatch ) ; } else { throw new UnsupportedOperationException ( _STR + proc . toString ( ) ) ; release ( ) ; return false ; } return true ; } 
1561	public void addMessage ( I vertexId , M message ) throws IOException { Basic _NUM ObjectMap < I , M > partitionMap = getPartitionMap ( vertexId ) ; synchronized ( partitionMap ) { M currentMessage = partitionMap . get ( vertexId ) ; if ( currentMessage = = null ) { M newMessage = messageCombiner . createInitialMessage ( ) ; currentMessage = partitionMap . put ( vertexId , newMessage ) ; if ( currentMessage = = null ) { currentMessage = newMessage ; } } messageCombiner . combine ( vertexId , currentMessage , message ) ; } } 
1562	private void changeSlider ( int slider , boolean increase , int jump ) { They differ a bit , especially in a sign flip on the vertical axis . if ( mMethod = = METHOD _ HS _ V _ PALETTE ) { slider * must * equal _NUM mHSV [ _NUM ] + = ( increase ? jump : - jump ) / _NUM _NUM _NUM . _NUM f ; mHSV [ _NUM ] = pinToUnit ( mHSV [ _NUM ] ) ; updateAllFromHSV ( ) ; mCoord [ _NUM ] = PALETTE _ DIM - ( int ) ( mHSV [ _NUM ] * PALETTE _ DIM ) ; mSwatchNew . setColor ( Color . HSVToColor ( mHSV ) ) ; setOvalValDimmer ( ) ; invalidate ( ) ; } } 
1563	public double calcScore ( BayesNet bayesNet ) throws Exception { switch ( m _ nCVType ) { case LOOCV : return leaveOneOutCV ( bayesNet ) ; case CUMCV : return cumulativeCV ( bayesNet ) ; case KFOLDCV : return kFoldCV ( bayesNet , m _ nNrOfFolds ) ; default : throw new Exception ( _STR + m _ nCVType ) ; } } 
1564	void retain ( JSObject obj ) { objectMap . put ( new Integer ( obj . objectId ) , Display . getInstance ( ) . createSoftWeakRef ( obj ) ) ; if ( objectMap . size ( ) > objectMapThresholdSize | | cleanupRandomizer . nextDouble ( ) < cleanupProbability ) { cleanup ( ) ; } } 
1565	static void deleteNamespaceAndTable ( final Admin admin ) throws IOException { if ( admin . tableExists ( MY _ TABLE _ NAME ) ) { System . out . println ( _STR ) ; admin . deleteNamespace ( MY _ NAMESPACE _ NAME ) ; } } 
1566	public int findActionPositionById ( long id ) { if ( mActions ! = null ) { for ( int i = _NUM ; i < mActions . size ( ) ; i + + ) { GuidedAction action = mActions . get ( i ) ; if ( mActions . get ( i ) . getId ( ) = = id ) { return i ; } } } return - _NUM ; } 
1567	public void nullable ( ) { getLast ( ) . nullable ( ) ; } 
1568	private boolean updateForNightMode ( @ ApplyableNightMode final int mode ) { final Resources res = mContext . getResources ( ) ; final Configuration conf = res . getConfiguration ( ) ; final int currentNightMode = conf . uiMode & Configuration . UI _ MODE _ NIGHT _ MASK ; final int newNightMode = ( mode = = MODE _ NIGHT _ YES ) ? Configuration . UI _ MODE _ NIGHT _ YES : Configuration . UI _ MODE _ NIGHT _ NO ; if ( currentNightMode ! = newNightMode ) { if ( shouldRecreateOnNightModeChange ( ) ) { if ( DEBUG ) { Log . d ( TAG , _STR + mode ) ; } } return false ; } 
1569	public void removeNonExistentChild ( ) { InodeDirectory inodeDirectory = createInodeDirectory ( ) ; InodeFile inodeFile _NUM = createInodeFile ( _NUM ) ; InodeFile inodeFile _NUM = createInodeFile ( _NUM ) ; inodeDirectory . addChild ( inodeFile _NUM ) ; Assert . assertEquals ( _NUM , inodeDirectory . getNumberOfChildren ( ) ) ; inodeDirectory . removeChild ( inodeFile _NUM ) ; Assert . assertEquals ( _NUM , inodeDirectory . getNumberOfChildren ( ) ) ; } 
1570	public void setQueryParams ( Collection queryParams , PreparedStatement ps ) throws Exception { if ( ( queryParams = = null ) | | ( queryParams . size ( ) = = _NUM ) ) return ; int i = _NUM ; Object key = null ; Iterator iter = queryParams . iterator ( ) ; while ( iter . hasNext ( ) ) { key = iter . next ( ) ; if ( key ! = null ) { convertType ( i , key , ps ) ; Debug . logVerbose ( _STR ) ; } i + + ; } } 
1571	public Preference findPreference ( CharSequence key ) { if ( TextUtils . equals ( getKey ( ) , key ) ) { return this ; } final int preferenceCount = getPreferenceCount ( ) ; for ( int i = _NUM ; i < preferenceCount ; i + + ) { final Preference preference = getPreference ( i ) ; final String curKey = preference . getKey ( ) ; if ( curKey ! = null & & curKey . equals ( key ) ) { return preference ; } if ( preference instanceof PreferenceGroup ) { final Preference returnedPreference = ( ( PreferenceGroup ) preference ) . findPreference ( key ) ; if ( returnedPreference ! = null ) { return returnedPreference ; } } } return null ; } 
1572	public static ASN _NUM Enumerated getInstance ( Object obj ) { if ( obj = = null | | obj instanceof ASN _NUM Enumerated ) { return ( ASN _NUM Enumerated ) obj ; } if ( obj instanceof byte [ ] ) { try { return ( ASN _NUM Enumerated ) fromByteArray ( ( byte [ ] ) obj ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( _STR + obj . getClass ( ) . getName ( ) ) ; } 
1573	public static < T extends Normalizer > T restoreNormalizerFromFile ( File file ) { try ( ZipFile zipFile = new ZipFile ( file ) ) { ZipEntry norm = zipFile . getEntry ( NORMALIZER _ BIN ) ; checking for file existence if ( norm = = null ) return null ; return NormalizerSerializer . getDefault ( ) . restore ( zipFile . getInputStream ( norm ) ) ; } catch ( Exception e ) { log . warn ( _STR ) ; addNormalizerToModel ( file , restoredDeprecated ) ; return ( T ) restoredDeprecated ; } } 
1574	public final Object onRetainNonConfigurationInstance ( ) { if ( mStopped ) { doReallyStop ( true ) ; } Object custom = onRetainCustomNonConfigurationInstance ( ) ; ArrayList < Fragment > fragments = mFragments . retainNonConfig ( ) ; boolean retainLoaders = false ; if ( mAllLoaderManagers ! = null ) { prune out any loader managers that were already stopped and so have nothing useful to retain . LoaderManagerImpl [ ] loaders = new LoaderManagerImpl [ mAllLoaderManagers . size ( ) ] ; mAllLoaderManagers . values ( ) . toArray ( loaders ) ; if ( loaders ! = null ) { for ( int i = _NUM ; i < loaders . length ; i + + ) { LoaderManagerImpl lm = loaders [ i ] ; if ( lm . mRetaining ) { retainLoaders = true ; } else { lm . doDestroy ( ) ; mAllLoaderManagers . remove ( lm . mWho ) ; } } } } if ( fragments = = null & & ! retainLoaders & & custom = = null ) { return null ; } NonConfigurationInstances nci = new NonConfigurationInstances ( ) ; nci . activity = null ; nci . custom = custom ; nci . children = null ; nci . fragments = fragments ; nci . loaders = mAllLoaderManagers ; return nci ; } 
1575	public int getChildCount ( UiSelector childPattern ) { Tracer . trace ( childPattern ) ; UiSelector patternSelector = UiSelector . patternBuilder ( getSelector ( ) , UiSelector . patternBuilder ( childPattern ) ) ; return getQueryController ( ) . getPatternCount ( patternSelector ) ; } 
1576	public long getStop ( ) { long result ; if ( isRunning ( ) ) result = getCurrentTime ( ) ; else result = m _ Stop ; return result ; } 
1577	public ConsumerLease obtainConsumer ( final ProcessSession session , final ProcessContext processContext ) { SimpleConsumerLease lease = pooledLeases . poll ( ) ; if ( lease = = null ) { final Consumer < byte [ ] , byte [ ] > consumer = createKafkaConsumer ( ) ; consumerCreatedCountRef . incrementAndGet ( ) ; lease = new SimpleConsumerLease ( consumer ) ; if ( topics ! = null ) { consumer . subscribe ( topics , lease ) ; } else { consumer . subscribe ( topicPattern , lease ) ; } } lease . setProcessSession ( session , processContext ) ; leasesObtainedCountRef . incrementAndGet ( ) ; return lease ; } 
1578	public void prepareUpdateStep _NUM b ( ) { if ( ! isInitialized ( ) ) { return ; } if ( ( m _ dbUpdateThread ! = null ) & & ( m _ dbUpdateThread . isFinished ( ) ) ) { update is already finished , just wait for client to collect final data return ; } if ( m _ dbUpdateThread = = null ) { m _ dbUpdateThread = new CmsUpdateDBThread ( this ) ; } if ( ! m _ dbUpdateThread . isAlive ( ) ) { m _ dbUpdateThread . start ( ) ; } } 
1579	private static List < String > listChildrenBFSAndWatchThem ( ZKWatcher zkw , final String znode ) throws KeeperException { Deque < String > queue = new LinkedList < > ( ) ; List < String > tree = new ArrayList < > ( ) ; queue . add ( znode ) ; while ( true ) { String node = queue . pollFirst ( ) ; if ( node = = null ) { break ; } List < String > children = listChildrenAndWatchThem ( zkw , node ) ; if ( children = = null ) { continue ; } for ( final String child : children ) { final String childPath = node + _STR + child ; queue . add ( childPath ) ; tree . add ( childPath ) ; } } return tree ; } 
1580	void addDefinedKeySetsToPackageLPw ( PackageSetting pkg , ArrayMap < String , ArraySet < PublicKey > > definedMapping ) { ArrayMap < String , Long > prevDefinedKeySets = pkg . keySetData . getAliases ( ) ; ArrayMap < String , Long > newKeySetAliases = new ArrayMap < String , Long > ( ) ; final int defMapSize = definedMapping . size ( ) ; for ( int i = _NUM ; i < defMapSize ; i + + ) { String alias = definedMapping . keyAt ( i ) ; ArraySet < PublicKey > pubKeys = definedMapping . valueAt ( i ) ; if ( alias ! = null & & pubKeys ! = null & & pubKeys . size ( ) > _NUM ) { KeySetHandle ks = addKeySetLPw ( pubKeys ) ; newKeySetAliases . put ( alias , ks . getId ( ) ) ; } } final int prevDefSize = prevDefinedKeySets . size ( ) ; for ( int i = _NUM ; i < prevDefSize ; i + + ) { decrementKeySetLPw ( prevDefinedKeySets . valueAt ( i ) ) ; } pkg . keySetData . removeAllUpgradeKeySets ( ) ; pkg . keySetData . setAliases ( newKeySetAliases ) ; return ; } 
1581	public static Node node ( String x ) { return NodeCreateUtils . create ( x ) ; } 
1582	public synchronized WritableComparable midKey ( ) throws IOException { readIndex ( ) ; if ( count = = _NUM ) { return null ; } return keys [ ( count - _NUM ) / _NUM ] ; } 
1583	public final void process ( CAS cas ) { if ( isRemoveExistingAnnotations ) { final AnnotationComboIterator sentenceNameCombo = new AnnotationComboIterator ( cas , mSentenceType , mNameType ) ; List < AnnotationFS > removeAnnotations = new LinkedList < > ( ) ; for ( AnnotationIteratorPair annotationIteratorPair : sentenceNameCombo ) { for ( AnnotationFS nameAnnotation : annotationIteratorPair . getSubIterator ( ) ) { removeAnnotations . add ( nameAnnotation ) ; } } for ( AnnotationFS annotation : removeAnnotations ) { cas . removeFsFromIndexes ( annotation ) ; } } final AnnotationComboIterator sentenceTokenCombo = new AnnotationComboIterator ( cas , mSentenceType , mTokenType ) ; for ( AnnotationIteratorPair annotationIteratorPair : sentenceTokenCombo ) { final List < AnnotationFS > sentenceTokenAnnotationList = new LinkedList < > ( ) ; final List < String > sentenceTokenList = new LinkedList < > ( ) ; for ( AnnotationFS tokenAnnotation : annotationIteratorPair . getSubIterator ( ) ) { sentenceTokenAnnotationList . add ( tokenAnnotation ) ; sentenceTokenList . add ( tokenAnnotation . getCoveredText ( ) ) ; } Span [ ] names = find ( cas , sentenceTokenList . toArray ( new String [ sentenceTokenList . size ( ) ] ) ) ; AnnotationFS [ ] nameAnnotations = new AnnotationFS [ names . length ] ; for ( int i = _NUM ; i < names . length ; i + + ) { int startIndex = sentenceTokenAnnotationList . get ( names [ i ] . getStart ( ) ) . getBegin ( ) ; int endIndex = sentenceTokenAnnotationList . get ( names [ i ] . getEnd ( ) - _NUM ) . getEnd ( ) ; Type nameType = mNameTypeMapping . get ( names [ i ] . getType ( ) ) ; if ( nameType = = null ) { nameType = mNameType ; } this allows the usage of only some types in the model if ( nameType ! = null ) { nameAnnotations [ i ] = cas . createAnnotation ( nameType , startIndex , endIndex ) ; cas . getIndexRepository ( ) . addFS ( nameAnnotations [ i ] ) ; } } postProcessAnnotations ( names , nameAnnotations ) ; } documentDone ( cas ) ; } 
1584	public void testToArray ( ) { Object [ ] a = set ( ) . toArray ( ) ; assertTrue ( Arrays . equals ( new Object [ _NUM ] , a ) ) ; assertSame ( Object [ ] . class , a . getClass ( ) ) ; int size = _NUM _NUM ; Integer [ ] elements = new Integer [ size ] ; for ( int i = _NUM ; i < size ; i + + ) { elements [ i ] = i ; } Collections . shuffle ( Arrays . asList ( elements ) ) ; Collection < Integer > full = populatedSet ( elements ) ; assertTrue ( Arrays . asList ( elements ) . containsAll ( Arrays . asList ( full . toArray ( ) ) ) ) ; assertTrue ( full . containsAll ( Arrays . asList ( full . toArray ( ) ) ) ) ; assertSame ( Object [ ] . class , full . toArray ( ) . getClass ( ) ) ; } 
1585	static void insertTestDocuments ( String collection , long numDocs , AuthorizedSolrClient client ) throws IOException { List < SolrInputDocument > data = createDocuments ( numDocs ) ; try { UpdateRequest updateRequest = new UpdateRequest ( ) ; updateRequest . setAction ( UpdateRequest . ACTION . COMMIT , true , true ) ; updateRequest . add ( data ) ; client . process ( collection , updateRequest ) ; } catch ( SolrServerException e ) { throw new IOException ( _STR , e ) ; } } 
1586	private static String unpack ( long v , boolean isDateTime ) { YYYY : MM : DD = > _NUM _NUM bits year , _NUM bits month , _NUM bits day = > _NUM _NUM bits int years = ( int ) BitsLong . unpack ( v , YEAR , YEAR + YEAR _ LEN ) ; int months = ( int ) BitsLong . unpack ( v , MONTH , MONTH + MONTH _ LEN ) ; int days = ( int ) BitsLong . unpack ( v , DAY , DAY + DAY _ LEN ) ; Hours : _NUM , mins _NUM , milli _NUM _NUM , TZ _NUM = > _NUM _NUM bits int hours = ( int ) BitsLong . unpack ( v , HOUR , HOUR + HOUR _ LEN ) ; int minutes = ( int ) BitsLong . unpack ( v , MINUTES , MINUTES + MINUTES _ LEN ) ; int milliSeconds = ( int ) BitsLong . unpack ( v , MILLI , MILLI + MILLI _ LEN ) ; int tz = ( int ) BitsLong . unpack ( v , TZ , TZ + TZ _ LEN ) ; int sec = milliSeconds / _NUM _NUM _NUM _NUM ; int fractionSec = milliSeconds % _NUM _NUM _NUM _NUM ; StringBuilder sb = new StringBuilder ( _NUM _NUM ) ; NumberUtils . formatInt ( sb , years , _NUM ) ; sb . append ( ' - ' ) ; NumberUtils . formatInt ( sb , months , _NUM ) ; sb . append ( ' - ' ) ; NumberUtils . formatInt ( sb , days , _NUM ) ; if ( isDateTime ) { sb . append ( ' T ' ) ; NumberUtils . formatInt ( sb , hours , _NUM ) ; sb . append ( ' : ' ) ; NumberUtils . formatInt ( sb , minutes , _NUM ) ; sb . append ( ' : ' ) ; NumberUtils . formatInt ( sb , sec , _NUM ) ; Formatting needed : int - > any if ( fractionSec ! = _NUM ) { sb . append ( _STR ) ; return sb . toString ( ) ; } if ( tz = = TZ _ NONE ) return sb . toString ( ) ; Sign extend . if ( BitsLong . isSet ( v , TZ + TZ _ LEN - _NUM ) ) tz = BitsInt . set ( tz , TZ _ LEN , _NUM _NUM ) ; if ( tz < _NUM ) { tz = - tz ; sb . append ( ' - ' ) ; } else sb . append ( ' + ' ) ; int tzH = tz / _NUM ; int tzM = ( tz % _NUM ) * _NUM _NUM ; NumberUtils . formatUnsignedInt ( sb , tzH , _NUM ) ; sb . append ( ' : ' ) ; NumberUtils . formatUnsignedInt ( sb , tzM , _NUM ) ; return sb . toString ( ) ; } 
1587	public Map < String , String > getCountMap ( String sql ) { Connection conn = null ; Statement stat = null ; ResultSet rs = null ; Map < String , String > dbMap = new HashMap < String , String > ( ) ; try { conn = this . getReadConnection ( ) ; stat = conn . createStatement ( ) ; rs = stat . executeQuery ( sql ) ; while ( rs . next ( ) ) { dbMap . put ( rs . getString ( _NUM ) , rs . getString ( _NUM ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { closeAll ( rs , stat , conn ) ; } return dbMap ; } 
1588	public boolean shouldNotifyWifiUnvalidated ( ) { return configRestrictsAvoidBadWifi ( ) & & getAvoidBadWifiSetting ( ) = = null ; } 
1589	public void add ( BindingVector env ) { Count c = get ( env ) ; if ( c = = null ) { put ( env , new Count ( _NUM ) ) ; } else { c . inc ( ) ; } } 
1590	public void closeIgniteCache ( ) { if ( getIgniteCache ( ) ! = null ) { getLogger ( ) . info ( _STR ) ; getIgniteCache ( ) . close ( ) ; } super . closeIgnite ( ) ; } 
1591	public String toString ( ) { String result = _STR + Utils . backQuoteChars ( m _ Instances . relationName ( ) ) ; } return result ; } 
1592	public void importUser ( ) { create a new user id String userName = m _ orgUnit . getName ( ) + m _ userName ; try { if ( m _ throwable ! = null ) { m _ user = null ; getReport ( ) . println ( m _ throwable ) ; CmsMessageContainer message = Messages . get ( ) . container ( Messages . ERR _ IMPORTEXPORT _ ERROR _ IMPORTING _ USER _ _NUM , userName ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( message . key ( ) , m _ throwable ) ; } m _ throwable = null ; return ; } getReport ( ) . print ( Messages . get ( ) . container ( Messages . RPT _ IMPORT _ USER _ _NUM ) , I _ CmsReport . FORMAT _ NOTE ) ; getReport ( ) . print ( org . opencms . report . Messages . get ( ) . container ( org . opencms . report . Messages . RPT _ ARGUMENT _ _NUM , userName ) ) ; getReport ( ) . print ( org . opencms . report . Messages . get ( ) . container ( org . opencms . report . Messages . RPT _ DOTS _ _NUM ) ) ; try { getCms ( ) . readUser ( userName ) ; user exists already getReport ( ) . println ( Messages . get ( ) . container ( Messages . RPT _ NOT _ CREATED _ _NUM ) , I _ CmsReport . FORMAT _ OK ) ; m _ user = null ; return ; } catch ( CmsDbEntryNotFoundException e ) { user does not exist } CmsParameterConfiguration config = OpenCms . getPasswordHandler ( ) . getConfiguration ( ) ; if ( ( config ! = null ) & & config . containsKey ( I _ CmsPasswordHandler . CONVERT _ DIGEST _ ENCODING ) ) { if ( config . getBoolean ( I _ CmsPasswordHandler . CONVERT _ DIGEST _ ENCODING , false ) ) { m _ userPassword = convertDigestEncoding ( m _ userPassword ) ; } } m _ user = getCms ( ) . importUser ( new CmsUUID ( ) . toString ( ) , userName , m _ userPassword , m _ userFirstname , m _ userLastname , m _ userEmail , m _ userFlags , m _ userDateCreated , m _ userInfos ) ; getReport ( ) . println ( org . opencms . report . Messages . get ( ) . container ( org . opencms . report . Messages . RPT _ OK _ _NUM ) , I _ CmsReport . FORMAT _ OK ) ; } catch ( Throwable e ) { m _ user = null ; getReport ( ) . println ( e ) ; CmsMessageContainer message = Messages . get ( ) . container ( Messages . ERR _ IMPORTEXPORT _ ERROR _ IMPORTING _ USER _ _NUM , userName ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( message . key ( ) , e ) ; } } finally { m _ userName = null ; m _ userPassword = null ; m _ userFirstname = null ; m _ userLastname = null ; m _ userEmail = null ; m _ userFlags = _NUM ; m _ userDateCreated = _NUM ; m _ userInfos = null ; } } 
1593	private LinkedHashMap < CmsUUID , CmsClientSitemapEntry > getModifiedList ( ) { CmsObject cms = getCmsObject ( ) ; CmsUser user = cms . getRequestContext ( ) . getCurrentUser ( ) ; Object obj = user . getAdditionalInfo ( ADDINFO _ ADE _ MODIFIED _ LIST ) ; LinkedHashMap < CmsUUID , CmsClientSitemapEntry > result = new LinkedHashMap < CmsUUID , CmsClientSitemapEntry > ( ) ; if ( obj instanceof String ) { try { JSONArray array = new JSONArray ( ( String ) obj ) ; for ( int i = _NUM ; i < array . length ( ) ; i + + ) { try { CmsUUID modId = new CmsUUID ( array . getString ( i ) ) ; CmsResource res = cms . readResource ( modId , CmsResourceFilter . ONLY _ VISIBLE ) ; String sitePath = cms . getSitePath ( res ) ; CmsJspNavElement navEntry = getNavBuilder ( ) . getNavigationForResource ( sitePath , CmsResourceFilter . ONLY _ VISIBLE ) ; if ( navEntry . isInNavigation ( ) ) { CmsClientSitemapEntry modEntry = toClientEntry ( navEntry , false ) ; result . put ( modId , modEntry ) ; } } catch ( Throwable e ) { should never happen , catches wrong or no longer existing values LOG . warn ( e . getLocalizedMessage ( ) ) ; } } } catch ( Throwable e ) { should never happen , catches json parsing LOG . warn ( e . getLocalizedMessage ( ) ) ; } } return result ; } 
1594	public void test _ remove _ folder _ deleted _ enabled ( ) throws Exception { Fs fs = startCrawlerDefinition ( ) . setRemoveDeleted ( true ) . build ( ) ; startCrawler ( getCrawlerName ( ) , fs , endCrawlerDefinition ( getCrawlerName ( ) ) , null ) ; We should have _NUM docs first countTestHelper ( new SearchRequest ( getCrawlerName ( ) ) , _NUM L , currentTestResourceDir ) ; logContentOfDir ( currentTestResourceDir , Level . DEBUG ) ; We remove a directory logger . info ( _STR ) ) ; logContentOfDir ( currentTestResourceDir , Level . DEBUG ) ; We expect to have _NUM docs now countTestHelper ( new SearchRequest ( getCrawlerName ( ) ) , _NUM L , currentTestResourceDir ) ; } 
1595	public int getParentPosition ( @ NonNull T item ) { int position = getItemPosition ( item ) ; if ( position = = - _NUM ) { return - _NUM ; } if the item is IExpandable , return a closest IExpandable item position whose level smaller than this . if it is not , return the closest IExpandable item position whose level is not negative int level ; if ( item instanceof IExpandable ) { level = ( ( IExpandable ) item ) . getLevel ( ) ; } else { level = Integer . MAX _ VALUE ; } if ( level = = _NUM ) { return position ; } else if ( level = = - _NUM ) { return - _NUM ; } for ( int i = position ; i > = _NUM ; i - - ) { T temp = mData . get ( i ) ; if ( temp instanceof IExpandable ) { IExpandable expandable = ( IExpandable ) temp ; if ( expandable . getLevel ( ) > = _NUM & & expandable . getLevel ( ) < level ) { return i ; } } } return - _NUM ; } 
1596	public boolean contains ( byte val ) { return index ( val ) > = _NUM ; } 
1597	public RelOptPredicateList getAllPredicates ( Join join , RelMetadataQuery mq ) { if ( join . getJoinType ( ) ! = JoinRelType . INNER ) { We cannot map origin of this expression . return null ; } final RexBuilder rexBuilder = join . getCluster ( ) . getRexBuilder ( ) ; final RexNode pred = join . getCondition ( ) ; final Multimap < List < String > , RelTableRef > qualifiedNamesToRefs = HashMultimap . create ( ) ; RelOptPredicateList newPreds = RelOptPredicateList . EMPTY ; for ( RelNode input : join . getInputs ( ) ) { final RelOptPredicateList inputPreds = mq . getAllPredicates ( input ) ; if ( inputPreds = = null ) { Bail out return null ; } Gather table references final Set < RelTableRef > tableRefs = mq . getTableReferences ( input ) ; if ( input = = join . getLeft ( ) ) { Left input references remain unchanged for ( RelTableRef leftRef : tableRefs ) { qualifiedNamesToRefs . put ( leftRef . getQualifiedName ( ) , leftRef ) ; } newPreds = newPreds . union ( rexBuilder , inputPreds ) ; } else { Right input references might need to be updated if there are table name clashes with left input final Map < RelTableRef , RelTableRef > currentTablesMapping = new HashMap < > ( ) ; for ( RelTableRef rightRef : tableRefs ) { int shift = _NUM ; Collection < RelTableRef > lRefs = qualifiedNamesToRefs . get ( rightRef . getQualifiedName ( ) ) ; if ( lRefs ! = null ) { shift = lRefs . size ( ) ; } currentTablesMapping . put ( rightRef , RelTableRef . of ( rightRef . getTable ( ) , shift + rightRef . getEntityNumber ( ) ) ) ; } final List < RexNode > updatedPreds = Lists . newArrayList ( Iterables . transform ( inputPreds . pulledUpPredicates , new Function < RexNode , RexNode > ( ) { @ Override public RexNode apply ( RexNode e ) { return RexUtil . swapTableReferences ( rexBuilder , e , currentTablesMapping ) ; } } ) ) ; newPreds = newPreds . union ( rexBuilder , RelOptPredicateList . of ( rexBuilder , updatedPreds ) ) ; } } Extract input fields referenced by Join condition final Set < RelDataTypeField > inputExtraFields = new LinkedHashSet < > ( ) ; final RelOptUtil . InputFinder inputFinder = new RelOptUtil . InputFinder ( inputExtraFields ) ; pred . accept ( inputFinder ) ; final ImmutableBitSet inputFieldsUsed = inputFinder . inputBitSet . build ( ) ; Infer column origin expressions for given references final Map < RexInputRef , Set < RexNode > > mapping = new LinkedHashMap < > ( ) ; for ( int idx : inputFieldsUsed ) { final RexInputRef inputRef = RexInputRef . of ( idx , join . getRowType ( ) . getFieldList ( ) ) ; final Set < RexNode > originalExprs = mq . getExpressionLineage ( join , inputRef ) ; if ( originalExprs = = null ) { Bail out return null ; } final RexInputRef ref = RexInputRef . of ( idx , join . getRowType ( ) . getFieldList ( ) ) ; mapping . put ( ref , originalExprs ) ; } Replace with new expressions and return union of predicates return newPreds . union ( rexBuilder , RelOptPredicateList . of ( rexBuilder , RelMdExpressionLineage . createAllPossibleExpressions ( rexBuilder , pred , mapping ) ) ) ; } 
1598	private boolean initCurrentPageIterator ( ) { List currentPage ; Level origLevel = level ; if ( overrideLevel ! = null ) { level = overrideLevel ; if ( results . getIds ( ) ! = null ) { List < EntityRef > userRefs = results . getIds ( ) . stream ( ) . map ( uuid - > new SimpleEntityRef ( _STR , uuid ) ) . collect ( Collectors . toList ( ) ) ; results . setRefs ( userRefs ) ; } } if ( results ! = null ) { switch ( level ) { case IDS : currentPage = results . getIds ( ) ; level = origLevel ; break ; case REFS : currentPage = results . getRefs ( ) ; level = origLevel ; break ; default : currentPage = results . getEntities ( ) ; level = origLevel ; } if ( currentPage . size ( ) > _NUM ) { currentPageIterator = currentPage . iterator ( ) ; } } else { currentPageIterator = null ; } return currentPageIterator ! = null & & currentPageIterator . hasNext ( ) ; } 
1599	protected void writeNamespace ( ) { String nsURI = determineNamespaceURI ( ) ; writeln ( _NUM , _STR ) ; writeln ( _NUM ) ; } 
1600	public static void writeDataset ( FileSystem fs , Path path , byte [ ] src , int len , int buffersize , boolean overwrite ) throws IOException { assertTrue ( _STR , src . length > = len ) ; FSDataOutputStream out = fs . create ( path , overwrite , fs . getConf ( ) . getInt ( IO _ FILE _ BUFFER _ SIZE , _NUM _NUM _NUM _NUM ) , ( short ) _NUM , buffersize ) ; out . write ( src , _NUM , len ) ; out . close ( ) ; assertFileHasLength ( fs , path , len ) ; } 
1601	public Number getStartValue ( Comparable rowKey , Comparable columnKey ) { int r = getRowIndex ( rowKey ) ; int c = getColumnIndex ( columnKey ) ; if ( c ! = - _NUM ) { return this . underlying . getStartValue ( r , c + this . firstCategoryIndex ) ; } else { throw new UnknownKeyException ( _STR + columnKey ) ; } } 
1602	private List < InstanceDescription > getServiceInstacesDescription ( final Zone zone ) { List < InstanceDescription > instancesDescriptionList = new ArrayList < InstanceDescription > ( ) ; if ( zone ! = null ) { for ( ProcessingUnitInstance processingUnitInstance : zone . getProcessingUnitInstances ( ) ) { InstanceDescription instanceDescription = getInstanceDescription ( processingUnitInstance ) ; instancesDescriptionList . add ( instanceDescription ) ; } } return instancesDescriptionList ; } 
1603	public static String readAllAsString ( Reader reader ) throws IOException { StringBuilder sb = new StringBuilder ( ) ; char [ ] buf = new char [ _NUM _NUM _NUM _NUM ] ; for ( ; ; ) { int n = reader . read ( buf ) ; if ( n = = - _NUM ) { break ; } sb . append ( buf , _NUM , n ) ; } return sb . toString ( ) ; } 
1604	public static < E > Iterator < Ord < E > > zip ( final Iterator < ? extends E > iterator ) { return new Iterator < Ord < E > > ( ) { int n = _NUM ; public boolean hasNext ( ) { return iterator . hasNext ( ) ; } public Ord < E > next ( ) { return Ord . of ( n + + , iterator . next ( ) ) ; } public void remove ( ) { iterator . remove ( ) ; } } ; } 
1605	public static byte [ ] toByteArray ( int [ ] input , int outLen ) { int intLen = input . length ; byte [ ] result = new byte [ outLen ] ; int index = _NUM ; for ( int i = _NUM ; i < = intLen - _NUM ; i + + , index + = _NUM ) { I _NUM OSP ( input [ i ] , result , index ) ; } I _NUM OSP ( input [ intLen - _NUM ] , result , index , outLen - index ) ; return result ; } 
1606	public void addScope ( CmsGallerySearchScope scope ) { m _ searchObject . setScope ( scope ) ; m _ searchObjectChanged = true ; ValueChangeEvent . fire ( this , m _ searchObject ) ; } 
1607	private boolean isRollback ( ) { return query . sql ( ) . equals ( ROLLBACK ) ; } 
1608	public static XmlDouble parse ( java . lang . String s , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException { return ( XmlDouble ) XmlBeans . getContextTypeLoader ( ) . parse ( s , type , options ) ; } 
1609	public void testFsckListCorruptFilesBlocks ( ) throws Exception { Configuration conf = new Configuration ( ) ; conf . setLong ( DFSConfigKeys . DFS _ BLOCKREPORT _ INTERVAL _ MSEC _ KEY , _NUM _NUM _NUM _NUM ) ; conf . setInt ( DFSConfigKeys . DFS _ DATANODE _ DIRECTORYSCAN _ INTERVAL _ KEY , _NUM ) ; FileSystem fs = null ; MiniDFSCluster cluster = null ; try { cluster = new MiniDFSCluster . Builder ( conf ) . build ( ) ; cluster . waitActive ( ) ; fs = cluster . getFileSystem ( ) ; DFSTestUtil util = new DFSTestUtil . Builder ( ) . setName ( _STR ) ; } finally { if ( cluster ! = null ) { cluster . shutdown ( ) ; } } } 
1610	public static XmlNormalizedString parse ( org . apache . xmlbeans . xml . stream . XMLInputStream xis ) throws org . apache . xmlbeans . XmlException , org . apache . xmlbeans . xml . stream . XMLStreamException { return ( XmlNormalizedString ) XmlBeans . getContextTypeLoader ( ) . parse ( xis , type , null ) ; } 
1611	public final void insertMedia ( int index , String mrl , String . . . mediaOptions ) { logger . debug ( _STR , index , mrl , Arrays . toString ( mediaOptions ) ) ; try { lock ( ) ; Create a new native media descriptor libvlc _ media _ t mediaDescriptor = newMediaDescriptor ( mrl , mediaOptions ) ; Insert the media descriptor into the media list libvlc . libvlc _ media _ list _ insert _ media ( mediaListInstance , mediaDescriptor , index ) ; Release the native reference releaseMediaDescriptor ( mediaDescriptor ) ; } finally { unlock ( ) ; } } 
1612	public static void putPerfLong ( long value , String name ) { ByteBuffer b = counters . get ( name ) ; synchronized ( b ) { b . putLong ( value ) ; b . rewind ( ) ; } } 
1613	public void addNewFontWizard ( ) { AddResourceDialog addResource = new AddResourceDialog ( loadedResources , AddResourceDialog . FONT ) ; if ( JOptionPane . OK _ OPTION = = JOptionPane . showConfirmDialog ( mainPanel , addResource , _STR , JOptionPane . OK _ CANCEL _ OPTION , JOptionPane . PLAIN _ MESSAGE ) ) { loadedResources . setFont ( addResource . getResourceName ( ) , font . createFont ( ) ) ; } } } 
1614	public static SQLiteDatabase openOrCreateDatabase ( @ NonNull String path , @ Nullable CursorFactory factory ) { return openDatabase ( path , factory , CREATE _ IF _ NECESSARY , null ) ; } 
1615	public static void writeProfile ( Path root , Profile profile ) throws IOException { Path path = root . resolve ( profile . getId ( ) . replaceAll ( _STR , root . getFileSystem ( ) . getSeparator ( ) ) + PROFILE _ FOLDER _ SUFFIX ) ; Files . createDirectories ( path ) ; for ( Map . Entry < String , byte [ ] > entry : profile . getFileConfigurations ( ) . entrySet ( ) ) { Files . write ( path . resolve ( entry . getKey ( ) ) , entry . getValue ( ) , StandardOpenOption . CREATE _ NEW ) ; } } 
1616	public Instances generateExamples ( Random random , Instances format ) throws Exception { Instance example = null ; if ( format = = null ) throw new Exception ( _STR + cNum ; for ( int i = _NUM ; i < instNum ; i + + ) { generate example example = generateInstance ( format , random , stdDev , center , cName ) ; if ( example ! = null ) example . setDataset ( format ) ; format . add ( example ) ; } } return ( format ) ; } 
1617	public void addFooterView ( View v , Object data , boolean isSelectable ) { NOTE : do not enforce the adapter being null here , since unlike in addHeaderView , it was never enforced here , and so existing apps are relying on being able to add a footer and then calling setAdapter to force creation of the HeaderViewListAdapter wrapper FixedViewInfo info = new FixedViewInfo ( ) ; info . view = v ; info . data = data ; info . isSelectable = isSelectable ; mFooterViewInfos . add ( info ) ; we need to notify the observer if ( mAdapter ! = null & & mObserver ! = null ) { mObserver . onChanged ( ) ; } } 
1618	public void addLast ( PDOutlineItem newChild ) { requireSingleNode ( newChild ) ; append ( newChild ) ; updateParentOpenCountForAddedChild ( newChild ) ; } 
1619	private static void checkDirAccess ( File dir ) throws DiskErrorException { if ( ! dir . isDirectory ( ) ) { throw new DiskErrorException ( _STR + dir . toString ( ) ) ; } checkAccessByFileMethods ( dir ) ; } 
1620	public List < CmsResource > addResourcesToFolder ( CmsObject cms , String resourcename , CmsResourceFilter filter ) throws CmsException { if ( m _ isWrappedResource ) { return cms . getResourcesInFolder ( resourcename , filter ) ; } return null ; } 
1621	public OptionalDouble findSingle ( ) { if ( ! iterator . hasNext ( ) ) { return OptionalDouble . empty ( ) ; } final double singleCandidate = iterator . nextDouble ( ) ; if ( iterator . hasNext ( ) ) { throw new IllegalStateException ( _STR ) ; } return OptionalDouble . of ( singleCandidate ) ; } 
1622	public LogEvent createEvent ( final String loggerName , final Marker marker , final String fqcn , final Level level , final Message message , final List < Property > properties , final Throwable t ) { MutableLogEvent result = mutableLogEventThreadLocal . get ( ) ; if ( result = = null | | result . reserved ) { final boolean initThreadLocal = result = = null ; result = new MutableLogEvent ( ) ; usually no need to re - initialize thread - specific fields since the event is stored in a ThreadLocal result . setThreadId ( Thread . currentThread ( ) . getId ( ) ) ; Thread . getName ( ) allocates Objects on each call result . setThreadName ( Thread . currentThread ( ) . getName ( ) ) ; result . setThreadPriority ( Thread . currentThread ( ) . getPriority ( ) ) ; if ( initThreadLocal ) { mutableLogEventThreadLocal . set ( result ) ; } } result . reserved = true ; ensure any previously cached values ( thrownProxy , source , etc . ) are cleared result . clear ( ) ; result . setLoggerName ( loggerName ) ; result . setMarker ( marker ) ; result . setLoggerFqcn ( fqcn ) ; result . setLevel ( level = = null ? Level . OFF : level ) ; result . setMessage ( message ) ; result . initTime ( CLOCK , Log _NUM jLogEvent . getNanoClock ( ) ) ; result . setThrown ( t ) ; result . setContextData ( injector . injectContextData ( properties , ( StringMap ) result . getContextData ( ) ) ) ; mutable copy result . setContextStack ( ThreadContext . getDepth ( ) = = _NUM ? ThreadContext . EMPTY _ STACK : ThreadContext . cloneStack ( ) ) ; if ( THREAD _ NAME _ CACHING _ STRATEGY = = ThreadNameCachingStrategy . UNCACHED ) { Thread . getName ( ) allocates Objects on each call result . setThreadName ( Thread . currentThread ( ) . getName ( ) ) ; result . setThreadPriority ( Thread . currentThread ( ) . getPriority ( ) ) ; } return result ; } 
1623	public CmsPermissionCheckResult hasPermissions ( CmsDbContext dbc , CmsResource resource , CmsPermissionSet requiredPermissions , boolean checkLock , CmsResourceFilter filter ) throws CmsException { if not , throw a CmsResourceNotFoundException if ( ! filter . isValid ( dbc . getRequestContext ( ) , resource ) ) { return I _ CmsPermissionHandler . PERM _ FILTERED ; } checking the filter is less cost intensive then checking the cache , this is why basic filter results are not cached String cacheKey = m _ keyGenerator . getCacheKeyForUserPermissions ( filter . requireVisible ( ) & & checkLock ? _STR flag is set for this user if ( ! canIgnorePermissions & & filter . requireVisible ( ) ) { filter requires visible permission - extend required permission set requiredPermissions = new CmsPermissionSet ( requiredPermissions . getAllowedPermissions ( ) | CmsPermissionSet . PERMISSION _ VIEW , requiredPermissions . getDeniedPermissions ( ) ) ; } else { view permissions can be ignored by filter permissions . setPermissions ( modify permissions so that view is allowed permissions . getAllowedPermissions ( ) | CmsPermissionSet . PERMISSION _ VIEW , permissions . getDeniedPermissions ( ) & ~ CmsPermissionSet . PERMISSION _ VIEW ) ; } } if ( requiredPermissions . requiresDirectPublishPermission ( ) ) { direct publish permission is required if ( ( permissions . getPermissions ( ) & CmsPermissionSet . PERMISSION _ DIRECT _ PUBLISH ) = = _NUM ) { but the user has no direct publish permission , so check if the user has the project manager role boolean canIgnorePublishPermission = m _ securityManager . hasRoleForResource ( dbc , dbc . currentUser ( ) , CmsRole . PROJECT _ MANAGER , resource ) ; if not , check the manageable projects if ( ! canIgnorePublishPermission ) { CmsUser user = dbc . currentUser ( ) ; Iterator < CmsProject > itProjects = m _ driverManager . getAllManageableProjects ( dbc , m _ driverManager . readOrganizationalUnit ( dbc , user . getOuFqn ( ) ) , true ) . iterator ( ) ; while ( itProjects . hasNext ( ) ) { CmsProject project = itProjects . next ( ) ; if ( CmsProject . isInsideProject ( m _ driverManager . readProjectResources ( dbc , project ) , resource ) ) { canIgnorePublishPermission = true ; break ; } } } if ( canIgnorePublishPermission ) { direct publish permission can be ignored permissions . setPermissions ( modify permissions so that direct publish is allowed permissions . getAllowedPermissions ( ) | CmsPermissionSet . PERMISSION _ DIRECT _ PUBLISH , permissions . getDeniedPermissions ( ) & ~ CmsPermissionSet . PERMISSION _ DIRECT _ PUBLISH ) ; } } } CmsPermissionCheckResult result ; if ( ( requiredPermissions . getPermissions ( ) & ( permissions . getPermissions ( ) ) ) = = requiredPermissions . getPermissions ( ) ) { result = I _ CmsPermissionHandler . PERM _ ALLOWED ; } else { result = I _ CmsPermissionHandler . PERM _ DENIED ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( Messages . get ( ) . getBundle ( ) . key ( Messages . LOG _ NO _ PERMISSION _ RESOURCE _ USER _ _NUM , new Object [ ] { dbc . getRequestContext ( ) . removeSiteRoot ( resource . getRootPath ( ) ) , dbc . currentUser ( ) . getName ( ) , requiredPermissions . getPermissionString ( ) , permissions . getPermissionString ( ) } ) ) ; } } if ( dbc . getProjectId ( ) . isNullUUID ( ) ) { OpenCms . getMemoryMonitor ( ) . cachePermission ( cacheKey , result ) ; } return result ; } 
1624	public static String getPathDataFromSVGFile ( File f ) { try { StringBuilder sb = new StringBuilder ( ) ; Document document = getXMLDocumentFromFile ( f ) ; NodeList nList = document . getElementsByTagName ( _STR ) ) ; } return sb . toString ( ) ; } catch ( Exception e ) { } return null ; } 
1625	public boolean hasValidationErrors ( ) { return getValidationHandler ( ) . hasErrors ( ) ; } 
1626	void resetList ( ) { mDataChanged = false ; mNeedSync = false ; removeAllViewsInLayout ( ) ; mOldSelectedPosition = INVALID _ POSITION ; mOldSelectedRowId = INVALID _ ROW _ ID ; setSelectedPositionInt ( INVALID _ POSITION ) ; setNextSelectedPositionInt ( INVALID _ POSITION ) ; invalidate ( ) ; } 
1627	 [ : p _STR ) ; writeClusterPredicateObjectList ( _NUM , cluster ) ; } } 
1628	protected void onTimeBlur ( ) { if ( m _ previewRegistration ! = null ) { m _ previewRegistration . removeHandler ( ) ; } checkTime ( ) ; } 
1629	public static BigDecimal bigDecValue ( Object value ) throws NumberFormatException { if ( value = = null ) return BigDecimal . valueOf ( _NUM L ) ; Class c = value . getClass ( ) ; if ( c = = BigDecimal . class ) return ( BigDecimal ) value ; if ( c = = BigInteger . class ) return new BigDecimal ( ( BigInteger ) value ) ; if ( c . getSuperclass ( ) = = Number . class ) return new BigDecimal ( ( ( Number ) value ) . doubleValue ( ) ) ; if ( c = = Boolean . class ) return BigDecimal . valueOf ( ( Boolean ) value ? _NUM : _NUM ) ; if ( c = = Character . class ) return BigDecimal . valueOf ( ( ( Character ) value ) . charValue ( ) ) ; return new BigDecimal ( stringValue ( value , true ) ) ; } 
1630	public static org . apache . xmlbeans . xml . stream . XMLInputStream newValidatingXMLInputStream ( org . apache . xmlbeans . xml . stream . XMLInputStream xis , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , org . apache . xmlbeans . xml . stream . XMLStreamException { return XmlBeans . getContextTypeLoader ( ) . newValidatingXMLInputStream ( xis , type , options ) ; } 
1631	public boolean isSet ( _ Fields field ) { if ( field = = null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case READ _ ONLY : return isSetReadOnly ( ) ; case PROPERTIES : return isSetProperties ( ) ; case SHARED : return isSetShared ( ) ; case COMMON _ OPTIONS : return isSetCommonOptions ( ) ; } throw new IllegalStateException ( ) ; } 
1632	public static String join ( CharSequence delimiter , Object [ ] tokens ) { StringBuilder sb = new StringBuilder ( ) ; boolean firstTime = true ; for ( Object token : tokens ) { if ( firstTime ) { firstTime = false ; } else { sb . append ( delimiter ) ; } sb . append ( token ) ; } return sb . toString ( ) ; } 
1633	public void testFilterClausesFactoredForPruning _NUM ( ) { String sql = _STR ) ; } 
1634	public void testLoadIR ( ) { SupBookRecord record = new SupBookRecord ( TestcaseRecordInputStream . create ( _NUM x _NUM _NUM AE , dataIR ) ) ; expected flag assertTrue ( record . isInternalReferences ( ) ) ; expected # of sheets assertEquals ( _NUM x _NUM , record . getNumberOfSheets ( ) ) ; sid + size + data assertEquals ( _NUM , record . getRecordSize ( ) ) ; } 
1635	public static StrTokenizer getCSVInstance ( final char [ ] input ) { final StrTokenizer tok = getCSVClone ( ) ; tok . reset ( input ) ; return tok ; } 
1636	public String prettyPrintConstraint ( Delegator delegator , boolean detailed , Locale locale ) { GenericValue content = null ; GenericValue contentAssocType = null ; try { content = EntityQuery . use ( delegator ) . from ( _STR ) ; } return ppBuf . toString ( ) ; } 
1637	private void updateSystemUiLocked ( IBinder token , int vis , int backDisposition ) { if ( ! calledWithValidToken ( token ) ) { return ; } TODO : Move this clearing calling identity block to setImeWindowStatus after making sure all updateSystemUi happens on system previlege . final long ident = Binder . clearCallingIdentity ( ) ; try { apply policy for binder calls if ( vis ! = _NUM & & isKeyguardLocked ( ) & & ! mCurClientInKeyguard ) { vis = _NUM ; } mImeWindowVis should be updated before calling shouldShowImeSwitcherLocked ( ) . final boolean needsToShowImeSwitcher = shouldShowImeSwitcherLocked ( vis ) ; if ( mStatusBar ! = null ) { mStatusBar . setImeWindowStatus ( token , vis , backDisposition , needsToShowImeSwitcher ) ; } final InputMethodInfo imi = mMethodMap . get ( mCurMethodId ) ; if ( imi ! = null & & needsToShowImeSwitcher ) { Used to load label final CharSequence title = mRes . getText ( com . android . internal . R . string . select _ input _ method ) ; final CharSequence summary = InputMethodUtils . getImeAndSubtypeDisplayName ( mContext , imi , mCurrentSubtype ) ; mImeSwitcherNotification . setContentTitle ( title ) . setContentText ( summary ) . setContentIntent ( mImeSwitchPendingIntent ) ; try { if ( ( mNotificationManager ! = null ) & & ! mIWindowManager . hasNavigationBar ( ) ) { if ( DEBUG ) { Slog . d ( TAG , _STR ) ; } mNotificationManager . cancelAsUser ( null , SystemMessage . NOTE _ SELECT _ INPUT _ METHOD , UserHandle . ALL ) ; mNotificationShown = false ; } } } finally { Binder . restoreCallingIdentity ( ident ) ; } } 
1638	private static NSObject parseObject ( Node n ) throws ParseException , IOException { String type = n . getNodeName ( ) ; if ( type . equals ( _STR ) ) { return new NSDate ( getNodeTextContents ( n ) ) ; } return null ; } 
1639	public static XmlNonNegativeInteger parse ( org . apache . xmlbeans . xml . stream . XMLInputStream xis , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , org . apache . xmlbeans . xml . stream . XMLStreamException { return ( XmlNonNegativeInteger ) XmlBeans . getContextTypeLoader ( ) . parse ( xis , type , options ) ; } 
1640	public final void setImageDrawable ( Drawable drawable ) { if ( mImageDrawable ! = drawable ) { mImageDrawable = drawable ; notifyImageDrawableChanged ( ) ; } } 
1641	public void setVideoUrl ( String videoUrl ) { setMediaSource ( videoUrl ) ; onMetadataChanged ( ) ; } 
1642	public boolean requestChildRectangleOnScreen ( RecyclerView parent , View child , Rect rect , boolean immediate , boolean focusedChildVisible ) { int [ ] scrollAmount = getChildRectangleOnScreenScrollAmount ( parent , child , rect , immediate ) ; int dx = scrollAmount [ _NUM ] ; int dy = scrollAmount [ _NUM ] ; if ( ! focusedChildVisible | | isFocusedChildVisibleAfterScrolling ( parent , dx , dy ) ) { if ( dx ! = _NUM | | dy ! = _NUM ) { if ( immediate ) { parent . scrollBy ( dx , dy ) ; } else { parent . smoothScrollBy ( dx , dy ) ; } return true ; } } return false ; } 
1643	private Date getNextFreq ( long startTime , long fromTime ) { Build a Calendar object Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( new Date ( startTime ) ) ; long nextStartTime = startTime ; while ( nextStartTime < fromTime ) { if ( Debug . verboseOn ( ) ) Debug . logVerbose ( _STR + getFrequency ( ) , module ) ; switch ( getFrequency ( ) ) { case SECONDLY : cal . add ( Calendar . SECOND , getIntervalInt ( ) ) ; break ; case MINUTELY : cal . add ( Calendar . MINUTE , getIntervalInt ( ) ) ; break ; case HOURLY : cal . add ( Calendar . HOUR _ OF _ DAY , getIntervalInt ( ) ) ; break ; case DAILY : cal . add ( Calendar . DAY _ OF _ MONTH , getIntervalInt ( ) ) ; break ; case WEEKLY : cal . add ( Calendar . WEEK _ OF _ YEAR , getIntervalInt ( ) ) ; break ; case MONTHLY : cal . add ( Calendar . MONTH , getIntervalInt ( ) ) ; break ; case YEARLY : cal . add ( Calendar . YEAR , getIntervalInt ( ) ) ; break ; default : should never happen return null ; } nextStartTime = cal . getTime ( ) . getTime ( ) ; } return new Date ( nextStartTime ) ; } 
1644	public Builder setDef ( org . apache . drill . exec . proto . UserBitShared . RecordBatchDef . Builder builderForValue ) { if ( defBuilder _ = = null ) { def _ = builderForValue . build ( ) ; onChanged ( ) ; } else { defBuilder _ . setMessage ( builderForValue . build ( ) ) ; } bitField _NUM _ | = _NUM x _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM ; return this ; } 
1645	public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( _STR ) ; return sb . toString ( ) ; } 
1646	public Object getInstance ( ComponentAdapter componentAdapter ) { Object componentKey = componentAdapter . getComponentKey ( ) ; Object instance = compKeyInstances . get ( componentKey ) ; if ( instance = = null ) { instance = loadSaveInstance ( componentAdapter , componentKey ) ; } return instance ; } 
1647	public void logIn ( View view ) { signInUser ( ) ; } 
1648	protected void appendDetail ( final StringBuffer buffer , final String fieldName , final byte value ) { buffer . append ( value ) ; } 
1649	public static Date toJava ( JsDate js ) { return js = = null ? null : new Date ( js . getTimeMs ( ) ) ; } 
1650	final void performRestoreInstanceState ( Bundle savedInstanceState ) { onRestoreInstanceState ( savedInstanceState ) ; restoreManagedDialogs ( savedInstanceState ) ; } 
1651	public void setGarbageCollectionHoldOnLateElements ( ) throws Exception { ReduceFnTester < Integer , Iterable < Integer > , IntervalWindow > tester = ReduceFnTester . nonCombining ( WindowingStrategy . of ( FixedWindows . of ( Duration . millis ( _NUM _NUM ) ) ) . withTrigger ( AfterWatermark . pastEndOfWindow ( ) . withLateFirings ( AfterPane . elementCountAtLeast ( _NUM ) ) ) . withMode ( AccumulationMode . DISCARDING _ FIRED _ PANES ) . withAllowedLateness ( Duration . millis ( _NUM _NUM _NUM ) ) . withClosingBehavior ( ClosingBehavior . FIRE _ IF _ NON _ EMPTY ) ) ; tester . advanceInputWatermark ( new Instant ( _NUM ) ) ; tester . advanceOutputWatermark ( new Instant ( _NUM ) ) ; tester . injectElements ( TimestampedValue . of ( _NUM , new Instant ( _NUM ) ) ) ; Fire ON _ TIME pane @ _NUM with _NUM tester . advanceInputWatermark ( new Instant ( _NUM _NUM _NUM ) ) ; tester . advanceOutputWatermark ( new Instant ( _NUM _NUM _NUM ) ) ; tester . injectElements ( TimestampedValue . of ( _NUM , new Instant ( _NUM ) ) ) ; We should have set a garbage collection hold for the final pane . Instant hold = tester . getWatermarkHold ( ) ; assertEquals ( new Instant ( _NUM _NUM _NUM ) , hold ) ; tester . advanceInputWatermark ( new Instant ( _NUM _NUM _NUM ) ) ; tester . advanceOutputWatermark ( new Instant ( _NUM _NUM _NUM ) ) ; Fire final LATE pane @ _NUM with _NUM List < WindowedValue < Iterable < Integer > > > output = tester . extractOutput ( ) ; assertEquals ( _NUM , output . size ( ) ) ; } 
1652	private static Map < String , Integer > appendDisplayNames ( final Calendar cal , final Locale locale , final int field , final StringBuilder regex ) { final Map < String , Integer > values = new HashMap < > ( ) ; final Map < String , Integer > displayNames = cal . getDisplayNames ( field , Calendar . ALL _ STYLES , locale ) ; final TreeSet < String > sorted = new TreeSet < > ( LONGER _ FIRST _ LOWERCASE ) ; for ( final Map . Entry < String , Integer > displayName : displayNames . entrySet ( ) ) { final String key = displayName . getKey ( ) . toLowerCase ( locale ) ; if ( sorted . add ( key ) ) { values . put ( key , displayName . getValue ( ) ) ; } } for ( final String symbol : sorted ) { simpleQuote ( regex , symbol ) . append ( ' | ' ) ; } return values ; } 
1653	private List _ asStructuredContentArray ( List array ) { if ( array = = null ) { return null ; } List children ; if ( array instanceof java . util . Vector ) { children = new java . util . Vector ( ) ; } else { children = new ArrayList ( ) ; } for ( Iterator elements = array . iterator ( ) ; elements . hasNext ( ) ; ) { Object o = elements . next ( ) ; for now prevent the critical cast exception . if ( o instanceof Map ) { children . add ( new MapContent ( ( Map ) o , this ) ) ; } else if ( o instanceof String ) { children . add ( new MapContent ( o , this ) ) ; } } return children ; } 
1654	public static XmlENTITIES parse ( java . lang . String s , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException { return ( XmlENTITIES ) XmlBeans . getContextTypeLoader ( ) . parse ( s , type , options ) ; } 
1655	public Settings overrideSettings ( final Settings settings ) { settings . channelizer = getChannelizer ( ) ; final String nameOfTest = name . getMethodName ( ) ; Settings . AuthenticationSettings authSettings = getAuthSettings ( ) ; switch ( nameOfTest ) { case _STR : settings . ssl = new Settings . SslSettings ( ) ; settings . ssl . enabled = true ; if ( authSettings ! = null ) { settings . authentication = getAuthSettings ( ) ; } break ; } return settings ; } 
1656	public synchronized boolean add ( Triple t ) { int triageClass = triage ( t ) ; switch ( triageClass & UPDATE _ MASK ) { case SUBCLASS : subClassCache . addRelation ( t ) ; break ; case SUBPROPERTY : subPropertyCache . addRelation ( t ) ; break ; case NOT _ RELEVANT : return false ; } If we get here we might need to some cache rebuilding if ( ( triageClass & REBUILD _ SUBPROPERTY ) ! = _NUM ) { TransitiveEngine . cacheSubPropUtility ( data , subPropertyCache ) ; isPrepared = false ; } if ( ( triageClass & REBUILD _ SUBCLASS ) ! = _NUM ) { TransitiveEngine . cacheSubClassUtility ( data , subPropertyCache , subClassCache ) ; isPrepared = false ; } return true ; } 
1657	public boolean hasDistinctMember ( Resource res ) { return getDistinctMembers ( ) . contains ( res ) ; } 
1658	private static byte [ ] createByteArray ( final byte [ ] row , final int roffset , final int rlength , final byte [ ] family , final int foffset , int flength , final byte [ ] qualifier , final int qoffset , int qlength , final long timestamp , final Type type , final byte [ ] value , final int voffset , int vlength , byte [ ] tags , int tagsOffset , int tagsLength ) { checkParameters ( row , rlength , family , flength , qlength , vlength ) ; RawCell . checkForTagsLength ( tagsLength ) ; Allocate right - sized byte array . int keyLength = ( int ) getKeyDataStructureSize ( rlength , flength , qlength ) ; byte [ ] bytes = new byte [ ( int ) getKeyValueDataStructureSize ( rlength , flength , qlength , vlength , tagsLength ) ] ; Write key , value and key row length . int pos = _NUM ; pos = Bytes . putInt ( bytes , pos , keyLength ) ; pos = Bytes . putInt ( bytes , pos , vlength ) ; pos = Bytes . putShort ( bytes , pos , ( short ) ( rlength & _NUM x _NUM _NUM _NUM _NUM ffff ) ) ; pos = Bytes . putBytes ( bytes , pos , row , roffset , rlength ) ; pos = Bytes . putByte ( bytes , pos , ( byte ) ( flength & _NUM x _NUM _NUM _NUM _NUM ff ) ) ; if ( flength ! = _NUM ) { pos = Bytes . putBytes ( bytes , pos , family , foffset , flength ) ; } if ( qlength ! = _NUM ) { pos = Bytes . putBytes ( bytes , pos , qualifier , qoffset , qlength ) ; } pos = Bytes . putLong ( bytes , pos , timestamp ) ; pos = Bytes . putByte ( bytes , pos , type . getCode ( ) ) ; if ( value ! = null & & value . length > _NUM ) { pos = Bytes . putBytes ( bytes , pos , value , voffset , vlength ) ; } Add the tags after the value part if ( tagsLength > _NUM ) { pos = Bytes . putAsShort ( bytes , pos , tagsLength ) ; pos = Bytes . putBytes ( bytes , pos , tags , tagsOffset , tagsLength ) ; } return bytes ; } 
1659	public BaseViewHolder setOnTouchListener ( @ IdRes int viewId , View . OnTouchListener listener ) { View view = getView ( viewId ) ; view . setOnTouchListener ( listener ) ; return this ; } 
1660	private List < List < Scan > > getParallelScans ( byte [ ] startKey , byte [ ] stopKey ) throws SQLException { List < HRegionLocation > regionLocations = getRegionBoundaries ( scanGrouper ) ; List < byte [ ] > regionBoundaries = toBoundaries ( regionLocations ) ; ScanRanges scanRanges = context . getScanRanges ( ) ; PTable table = getTable ( ) ; boolean isSalted = table . getBucketNum ( ) ! = null ; boolean isLocalIndex = table . getIndexType ( ) = = IndexType . LOCAL ; GuidePostsInfo gps = getGuidePosts ( ) ; case when stats wasn ' t collected hasGuidePosts = gps ! = GuidePostsInfo . NO _ GUIDEPOST ; Case when stats collection did run but there possibly wasn ' t enough data . In such a case we generate an empty guide post with the byte estimate being set as guide post width . boolean emptyGuidePost = gps . isEmptyGuidePost ( ) ; byte [ ] startRegionBoundaryKey = startKey ; byte [ ] stopRegionBoundaryKey = stopKey ; int columnsInCommon = _NUM ; ScanRanges prefixScanRanges = ScanRanges . EVERYTHING ; boolean traverseAllRegions = isSalted | | isLocalIndex ; if ( isLocalIndex ) { as we should always have a data plan when a local index is being used . if ( dataPlan ! = null & & dataPlan . getTableRef ( ) . getTable ( ) . getType ( ) ! = PTableType . INDEX ) { Sanity check prefixScanRanges = computePrefixScanRanges ( dataPlan . getContext ( ) . getScanRanges ( ) , columnsInCommon = computeColumnsInCommon ( ) ) ; KeyRange prefixRange = prefixScanRanges . getScanRange ( ) ; if ( ! prefixRange . lowerUnbound ( ) ) { startRegionBoundaryKey = prefixRange . getLowerRange ( ) ; } if ( ! prefixRange . upperUnbound ( ) ) { stopRegionBoundaryKey = prefixRange . getUpperRange ( ) ; } } } else if ( ! traverseAllRegions ) { byte [ ] scanStartRow = scan . getStartRow ( ) ; if ( scanStartRow . length ! = _NUM & & Bytes . compareTo ( scanStartRow , startKey ) > _NUM ) { startRegionBoundaryKey = startKey = scanStartRow ; } byte [ ] scanStopRow = scan . getStopRow ( ) ; if ( stopKey . length = = _NUM | | ( scanStopRow . length ! = _NUM & & Bytes . compareTo ( scanStopRow , stopKey ) < _NUM ) ) { stopRegionBoundaryKey = stopKey = scanStopRow ; } } int regionIndex = _NUM ; int startRegionIndex = _NUM ; int stopIndex = regionBoundaries . size ( ) ; if ( startRegionBoundaryKey . length > _NUM ) { startRegionIndex = regionIndex = getIndexContainingInclusive ( regionBoundaries , startRegionBoundaryKey ) ; } if ( stopRegionBoundaryKey . length > _NUM ) { stopIndex = Math . min ( stopIndex , regionIndex + getIndexContainingExclusive ( regionBoundaries . subList ( regionIndex , stopIndex ) , stopRegionBoundaryKey ) ) ; if ( isLocalIndex ) { stopKey = regionLocations . get ( stopIndex ) . getRegionInfo ( ) . getEndKey ( ) ; } } List < List < Scan > > parallelScans = Lists . newArrayListWithExpectedSize ( stopIndex - regionIndex + _NUM ) ; ImmutableBytesWritable currentKey = new ImmutableBytesWritable ( startKey ) ; int gpsSize = gps . getGuidePostsCount ( ) ; int estGuidepostsPerRegion = gpsSize = = _NUM ? _NUM : gpsSize / regionLocations . size ( ) + _NUM ; int keyOffset = _NUM ; ImmutableBytesWritable currentGuidePost = ByteUtil . EMPTY _ IMMUTABLE _ BYTE _ ARRAY ; List < Scan > scans = Lists . newArrayListWithExpectedSize ( estGuidepostsPerRegion ) ; ImmutableBytesWritable guidePosts = gps . getGuidePosts ( ) ; ByteArrayInputStream stream = null ; DataInput input = null ; PrefixByteDecoder decoder = null ; int guideIndex = _NUM ; GuidePostEstimate estimates = new GuidePostEstimate ( ) ; boolean gpsForFirstRegion = false ; boolean intersectWithGuidePosts = true ; Maintain min ts for gps in first or last region outside of gps that are in the scan range . We ' ll use this if we find no gps in range . long fallbackTs = Long . MAX _ VALUE ; Determination of whether of not we found a guidepost in every region between the start and stop key . If not , then we cannot definitively say at what time the guideposts were collected . boolean gpsAvailableForAllRegions = true ; try { boolean delayAddingEst = false ; ImmutableBytesWritable firstRegionStartKey = null ; if ( gpsSize > _NUM ) { stream = new ByteArrayInputStream ( guidePosts . get ( ) , guidePosts . getOffset ( ) , guidePosts . getLength ( ) ) ; input = new DataInputStream ( stream ) ; decoder = new PrefixByteDecoder ( gps . getMaxLength ( ) ) ; firstRegionStartKey = new ImmutableBytesWritable ( regionLocations . get ( regionIndex ) . getRegionInfo ( ) . getStartKey ( ) ) ; try { int c ; Continue walking guideposts until we get past the currentKey while ( ( c = currentKey . compareTo ( currentGuidePost = PrefixByteCodec . decode ( decoder , input ) ) ) > = _NUM ) { the first region . if ( ! gpsForFirstRegion & & firstRegionStartKey . compareTo ( currentGuidePost ) < = _NUM ) { gpsForFirstRegion = true ; } the min ts as a fallback for the time at which stas were calculated . if ( gpsForFirstRegion ) { fallbackTs = Math . min ( fallbackTs , gps . getGuidePostTimestamps ( ) [ guideIndex ] ) ; } Special case for gp = = startKey in which case we want to count this gp ( if it ' s in range ) though we go past it . delayAddingEst = ( c = = _NUM ) ; guideIndex + + ; } } catch ( EOFException e ) { expected . Thrown when we have decoded all guide posts . intersectWithGuidePosts = false ; } } byte [ ] endRegionKey = regionLocations . get ( stopIndex ) . getRegionInfo ( ) . getEndKey ( ) ; byte [ ] currentKeyBytes = currentKey . copyBytes ( ) ; intersectWithGuidePosts & = guideIndex < gpsSize ; Merge bisect with guideposts for all but the last region while ( regionIndex < = stopIndex ) { HRegionLocation regionLocation = regionLocations . get ( regionIndex ) ; HRegionInfo regionInfo = regionLocation . getRegionInfo ( ) ; byte [ ] currentGuidePostBytes = currentGuidePost . copyBytes ( ) ; byte [ ] endKey ; if ( regionIndex = = stopIndex ) { endKey = stopKey ; } else { endKey = regionBoundaries . get ( regionIndex ) ; } if ( isLocalIndex ) { based on the start / stop key . if ( columnsInCommon > _NUM & & prefixScanRanges . useSkipScanFilter ( ) ) { byte [ ] regionStartKey = regionInfo . getStartKey ( ) ; ImmutableBytesWritable ptr = context . getTempPtr ( ) ; clipKeyRangeBytes ( prefixScanRanges . getSchema ( ) , _NUM , columnsInCommon , regionStartKey , ptr , false ) ; regionStartKey = ByteUtil . copyKeyBytesIfNecessary ( ptr ) ; Prune this region if there ' s no intersection if ( ! prefixScanRanges . intersectRegion ( regionStartKey , regionInfo . getEndKey ( ) , false ) ) { currentKeyBytes = endKey ; regionIndex + + ; continue ; } } keyOffset = ScanUtil . getRowKeyOffset ( regionInfo . getStartKey ( ) , regionInfo . getEndKey ( ) ) ; } byte [ ] initialKeyBytes = currentKeyBytes ; int gpsComparedToEndKey = - _NUM ; boolean everNotDelayed = false ; while ( intersectWithGuidePosts & & ( endKey . length = = _NUM | | ( gpsComparedToEndKey = currentGuidePost . compareTo ( endKey ) ) < = _NUM ) ) { Scan newScan = scanRanges . intersectScan ( scan , currentKeyBytes , currentGuidePostBytes , keyOffset , false ) ; if ( newScan ! = null ) { ScanUtil . setLocalIndexAttributes ( newScan , keyOffset , regionInfo . getStartKey ( ) , regionInfo . getEndKey ( ) , newScan . getStartRow ( ) , newScan . getStopRow ( ) ) ; gp estimates now that we know they are in range . if ( delayAddingEst ) { updateEstimates ( gps , guideIndex - _NUM , estimates ) ; } current gp estimates . if ( ! ( delayAddingEst = gpsComparedToEndKey = = _NUM ) ) { updateEstimates ( gps , guideIndex , estimates ) ; } } else { delayAddingEst = false ; } everNotDelayed | = ! delayAddingEst ; scans = addNewScan ( parallelScans , scans , newScan , currentGuidePostBytes , false , regionLocation ) ; currentKeyBytes = currentGuidePostBytes ; try { currentGuidePost = PrefixByteCodec . decode ( decoder , input ) ; currentGuidePostBytes = currentGuidePost . copyBytes ( ) ; guideIndex + + ; } catch ( EOFException e ) { We have read all guide posts intersectWithGuidePosts = false ; } } boolean gpsInThisRegion = initialKeyBytes ! = currentKeyBytes ; if ( ! useStatsForParallelization ) { currentKeyBytes = initialKeyBytes ; } Scan newScan = scanRanges . intersectScan ( scan , currentKeyBytes , endKey , keyOffset , true ) ; if ( newScan ! = null ) { ScanUtil . setLocalIndexAttributes ( newScan , keyOffset , regionInfo . getStartKey ( ) , regionInfo . getEndKey ( ) , newScan . getStartRow ( ) , newScan . getStopRow ( ) ) ; Boundary case of no GP in region after delaying adding of estimates if ( ! gpsInThisRegion & & delayAddingEst ) { updateEstimates ( gps , guideIndex - _NUM , estimates ) ; gpsInThisRegion = true ; delayAddingEst = false ; } } else if ( ! gpsInThisRegion ) { delayAddingEst = false ; } scans = addNewScan ( parallelScans , scans , newScan , endKey , true , regionLocation ) ; currentKeyBytes = endKey ; We have a guide post in the region if the above loop was entered or if the current key is less than the region end key ( since the loop may not have been entered if our scan end key is smaller than the first guide post in that region ) . boolean gpsAfterStopKey = false ; gpsAvailableForAllRegions & = GP in this region ( gpsInThisRegion & & everNotDelayed ) | | GP in first region ( before start key ) ( regionIndex = = startRegionIndex & & gpsForFirstRegion ) | | ( gpsAfterStopKey = ( GP in last region ( after stop key ) regionIndex = = stopIndex & & intersectWithGuidePosts & & ( then check if gp is in the region endRegionKey . length = = _NUM | | currentGuidePost . compareTo ( endRegionKey ) < _NUM ) ) ) ; if ( gpsAfterStopKey ) { If gp after stop key , but still in last region , track min ts as fallback fallbackTs = Math . min ( fallbackTs , gps . getGuidePostTimestamps ( ) [ guideIndex ] ) ; } regionIndex + + ; } if ( scanRanges . isPointLookup ( ) ) { this . estimatedRows = Long . valueOf ( scanRanges . getPointLookupCount ( ) ) ; this . estimatedSize = this . estimatedRows * SchemaUtil . estimateRowSize ( table ) ; this . estimateInfoTimestamp = computeMinTimestamp ( gpsAvailableForAllRegions , estimates , fallbackTs ) ; } else if ( emptyGuidePost ) { In case of an empty guide post , we estimate the number of rows scanned by using the estimated row size this . estimatedRows = ( gps . getByteCounts ( ) [ _NUM ] / SchemaUtil . estimateRowSize ( table ) ) ; this . estimatedSize = gps . getByteCounts ( ) [ _NUM ] ; this . estimateInfoTimestamp = gps . getGuidePostTimestamps ( ) [ _NUM ] ; } else if ( hasGuidePosts ) { this . estimatedRows = estimates . rowsEstimate ; this . estimatedSize = estimates . bytesEstimate ; this . estimateInfoTimestamp = computeMinTimestamp ( gpsAvailableForAllRegions , estimates , fallbackTs ) ; } else { this . estimatedRows = null ; this . estimatedSize = null ; this . estimateInfoTimestamp = null ; } if ( ! scans . isEmpty ( ) ) { Add any remaining scans parallelScans . add ( scans ) ; } } finally { if ( stream ! = null ) Closeables . closeQuietly ( stream ) ; } sampleScans ( parallelScans , this . plan . getStatement ( ) . getTableSamplingRate ( ) ) ; return parallelScans ; } 
1661	public void publishVersions ( CmsDbContext dbc , CmsResource resource , boolean firstSibling ) throws CmsDataAccessException { if resource is null just flush the internal cache if ( resource = = null ) { m _ resOp . clear ( ) ; return ; } if ( ! dbc . getProjectId ( ) . isNullUUID ( ) | | dbc . currentProject ( ) . isOnlineProject ( ) ) { this method is supposed to be used only in the offline project return ; } if ( firstSibling ) { reset the resource operation flag m _ resOp . remove ( resource . getResourceId ( ) ) ; } assume structure operation boolean resOp = false ; CmsResourceState resState = internalReadResourceState ( dbc , dbc . currentProject ( ) . getUuid ( ) , resource ) ; CmsResourceState strState = internalReadStructureState ( dbc , dbc . currentProject ( ) . getUuid ( ) , resource ) ; if ( ! resState . isUnchanged ( ) ) { if ( strState . isDeleted ( ) ) { resOp = ( resState . isDeleted ( ) | | ( resource . getSiblingCount ( ) = = _NUM ) | | ( countSiblings ( dbc , dbc . currentProject ( ) . getUuid ( ) , resource . getResourceId ( ) ) = = _NUM ) ) ; } else { resOp = true ; } } if ( ! firstSibling ) { if ( resOp ) { return ; } if ( m _ resOp . contains ( resource . getResourceId ( ) ) ) { return ; } } read the offline version numbers Map versions = readVersions ( dbc , dbc . currentProject ( ) . getUuid ( ) , resource . getResourceId ( ) , resource . getStructureId ( ) ) ; int strVersion = ( ( Integer ) versions . get ( _STR ) ; stmt . setInt ( _NUM , strVersion ) ; stmt . setString ( _NUM , resource . getStructureId ( ) . toString ( ) ) ; stmt . executeUpdate ( ) ; m _ sqlManager . closeAll ( dbc , null , stmt , null ) ; } } catch ( SQLException e ) { throw new CmsDbSqlException ( Messages . get ( ) . container ( Messages . ERR _ GENERIC _ SQL _ _NUM , CmsDbSqlException . getErrorQuery ( stmt ) ) , e ) ; } finally { m _ sqlManager . closeAll ( dbc , conn , stmt , res ) ; } } 
1662	public void clearData ( boolean eager ) { deallocateMemoryOnDevice ( eager ) ; getGPUContext ( ) . getMemoryManager ( ) . removeGPUObject ( this ) ; } 
1663	public void test _NUM _ _NUM PollingCaptureVolumeScaling ( ) throws Exception { test that when playing a sound , the energy measured with Visualizer in SCALING _ MODE _ AS _ PLAYED mode decreases when lowering the volume boolean result = false ; String msg = _STR ) ; } finally { releaseVisualizer ( ) ; if ( mp ! = null ) { mp . release ( ) ; } if ( vc ! = null ) { vc . release ( ) ; } am . setRingerMode ( ringerMode ) ; } assertTrue ( msg , result ) ; } 
1664	public static void stopContext ( Context ctx ) { synchronized ( activeContexts ) { activeContexts . remove ( ctx ) ; if ( activeContexts . isEmpty ( ) ) { If we are the last context , we should deinitialize syncDeinitialize ( ) ; } else { if ( instance ! = null & & getActivity ( ) ! = null ) { if this is an activity , then we should clean up our UI resources anyways because the last context to be cleaned up might not have access to the UI thread . instance . deinitialize ( ) ; } } } } 
1665	public Container getFormLayeredPane ( Class c , boolean top ) { if ( formLayeredPane = = null ) { formLayeredPane = new Container ( new LayeredLayout ( ) ) { @ Override protected void paintBackground ( Graphics g ) { if ( getComponentCount ( ) > _NUM ) { if ( isVisible ( ) ) { setVisible ( false ) ; Form . this . paint ( g ) ; setVisible ( true ) ; } } } @ Override public void paintBackgrounds ( Graphics g ) { } } ; formLayeredPane . setName ( _STR , n ) ; return cnt ; } 
1666	protected void copyProxyCookie ( HttpServletRequest servletRequest , HttpServletResponse servletResponse , Header header ) { List < HttpCookie > cookies = HttpCookie . parse ( header . getValue ( ) ) ; path starts with / or is empty string String path = servletRequest . getContextPath ( ) ; servlet path starts with / or is empty string path + = servletRequest . getServletPath ( ) ; for ( HttpCookie cookie : cookies ) { set cookie name prefixed w / a proxy value so it won ' t collide w / other cookies String proxyCookieName = getCookieNamePrefix ( ) + cookie . getName ( ) ; Cookie servletCookie = new Cookie ( proxyCookieName , cookie . getValue ( ) ) ; servletCookie . setComment ( cookie . getComment ( ) ) ; servletCookie . setMaxAge ( ( int ) cookie . getMaxAge ( ) ) ; set to the path of the proxy servlet servletCookie . setPath ( path ) ; don ' t set cookie domain servletCookie . setSecure ( cookie . getSecure ( ) ) ; servletCookie . setVersion ( cookie . getVersion ( ) ) ; servletResponse . addCookie ( servletCookie ) ; } } 
1667	public List < KerberosIdentityDescriptor > findReferences ( ) { AbstractKerberosDescriptor root = getRoot ( ) ; if ( root instanceof AbstractKerberosDescriptorContainer ) { return findIdentityReferences ( ( AbstractKerberosDescriptorContainer ) root , getPath ( ) ) ; } else { return null ; } } 
1668	public float getAscender ( ) { float ascender = _NUM ; for ( int k = _NUM ; k < line . size ( ) ; + + k ) { PdfChunk ck = ( PdfChunk ) line . get ( k ) ; if ( ck . isImage ( ) ) ascender = Math . max ( ascender , ck . getImage ( ) . getScaledHeight ( ) + ck . getImageOffsetY ( ) ) ; else { PdfFont font = ck . font ( ) ; ascender = Math . max ( ascender , font . getFont ( ) . getFontDescriptor ( BaseFont . ASCENT , font . size ( ) ) ) ; } } return ascender ; } 
1669	private void makeCommandStage ( UpgradeContext context , RequestStageContainer request , RepositoryVersionEntity effectiveRepositoryVersion , UpgradeItemEntity entity , StageWrapper wrapper , boolean skippable , boolean supportsAutoSkipOnFailure , boolean allowRetry ) throws AmbariException { Cluster cluster = context . getCluster ( ) ; List < RequestResourceFilter > filters = new ArrayList < > ( ) ; for ( TaskWrapper tw : wrapper . getTasks ( ) ) { add each host to this stage filters . add ( new RequestResourceFilter ( tw . getService ( ) , tw . getComponent ( ) , new ArrayList < > ( tw . getHosts ( ) ) ) ) ; } String function = null ; switch ( wrapper . getType ( ) ) { case CONFIGURE : case START : case STOP : case RESTART : function = wrapper . getType ( ) . name ( ) ; break ; default : function = _STR to false in the Upgrade Pack group if ( allowRetry & & context . getType ( ) = = UpgradeType . HOST _ ORDERED ) { requestParams . put ( KeyNames . COMMAND _ RETRY _ ENABLED , Boolean . TRUE . toString ( ) . toLowerCase ( ) ) ; } s _ commandExecutionHelper . get ( ) . addExecutionCommandsToStage ( actionContext , stage , requestParams , jsons ) ; request . addStages ( Collections . singletonList ( stage ) ) ; } 
1670	public Token getTokenList ( Segment text , int initialTokenType , int startOffset ) { resetTokenList ( ) ; this . offsetShift = - text . offset + startOffset ; validJSString = true ; e _NUM x _ prevState = YYINITIAL ; e _NUM x _ inInternalDtd = false ; int languageIndex = LANG _ INDEX _ DEFAULT ; Start off in the proper state . int state = YYINITIAL ; switch ( initialTokenType ) { case INTERNAL _ IN _ JS _ MLC : state = JS _ MLC ; break ; case INTERNAL _ IN _ JS _ COMMENT _ DOCUMENTATION : state = JS _ DOCCOMMENT ; start = text . offset ; break ; case INTERNAL _ IN _ JS _ STRING _ INVALID : state = JS _ STRING ; validJSString = false ; break ; case INTERNAL _ IN _ JS _ STRING _ VALID : state = JS _ STRING ; break ; case INTERNAL _ IN _ JS _ CHAR _ INVALID : state = JS _ CHAR ; validJSString = false ; break ; case INTERNAL _ IN _ JS _ CHAR _ VALID : state = JS _ CHAR ; break ; case INTERNAL _ E _NUM X : state = E _NUM X ; languageIndex = LANG _ INDEX _ E _NUM X ; break ; case INTERNAL _ E _NUM X _ INTAG : state = E _NUM X _ INTAG ; languageIndex = LANG _ INDEX _ E _NUM X ; break ; case INTERNAL _ E _NUM X _ MARKUP _ PROCESSING _ INSTRUCTION : state = E _NUM X _ PI ; languageIndex = LANG _ INDEX _ E _NUM X ; break ; case INTERNAL _ E _NUM X _ DTD : state = E _NUM X _ DTD ; languageIndex = LANG _ INDEX _ E _NUM X ; break ; case INTERNAL _ E _NUM X _ DTD _ INTERNAL : state = E _NUM X _ DTD ; e _NUM x _ inInternalDtd = true ; languageIndex = LANG _ INDEX _ E _NUM X ; break ; case INTERNAL _ E _NUM X _ ATTR _ SINGLE : state = E _NUM X _ INATTR _ SINGLE ; languageIndex = LANG _ INDEX _ E _NUM X ; break ; case INTERNAL _ E _NUM X _ ATTR _ DOUBLE : state = E _NUM X _ INATTR _ DOUBLE ; languageIndex = LANG _ INDEX _ E _NUM X ; break ; case INTERNAL _ E _NUM X _ MARKUP _ CDATA : state = E _NUM X _ CDATA ; languageIndex = LANG _ INDEX _ E _NUM X ; break ; case INTERNAL _ IN _ JS _ TEMPLATE _ LITERAL _ VALID : state = JS _ TEMPLATE _ LITERAL ; validJSString = true ; break ; case INTERNAL _ IN _ JS _ TEMPLATE _ LITERAL _ INVALID : state = JS _ TEMPLATE _ LITERAL ; validJSString = false ; break ; default : if ( initialTokenType < - _NUM _NUM _NUM _NUM ) { INTERNAL _ IN _ E _NUM X _ COMMENT - prevState int main = - ( - initialTokenType & _NUM xffffff _NUM _NUM ) ; switch ( main ) { Should never happen default : case INTERNAL _ IN _ E _NUM X _ COMMENT : state = E _NUM X _ COMMENT ; break ; } e _NUM x _ prevState = - initialTokenType & _NUM xff ; languageIndex = LANG _ INDEX _ E _NUM X ; } else { Shouldn ' t happen state = Token . NULL ; } } setLanguageIndex ( languageIndex ) ; start = text . offset ; s = text ; try { yyreset ( zzReader ) ; yybegin ( state ) ; return yylex ( ) ; } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; return new TokenImpl ( ) ; } } 
1671	public static void destroyDstSubtree ( INode . ReclaimContext reclaimContext , INode inode , final int snapshot , final int prior ) { Preconditions . checkArgument ( prior ! = NO _ SNAPSHOT _ ID ) ; if ( inode . isReference ( ) ) { if ( inode instanceof INodeReference . WithName & & snapshot ! = Snapshot . CURRENT _ STATE _ ID ) { this inode has been renamed before the deletion of the DstReference subtree inode . cleanSubtree ( reclaimContext , snapshot , prior ) ; } else { for DstReference node , continue this process to its subtree destroyDstSubtree ( reclaimContext , inode . asReference ( ) . getReferredINode ( ) , snapshot , prior ) ; } } else if ( inode . isFile ( ) ) { inode . cleanSubtree ( reclaimContext , snapshot , prior ) ; } else if ( inode . isDirectory ( ) ) { Map < INode , INode > excludedNodes = null ; INodeDirectory dir = inode . asDirectory ( ) ; DirectoryWithSnapshotFeature sf = dir . getDirectoryWithSnapshotFeature ( ) ; if ( sf ! = null ) { DirectoryDiffList diffList = sf . getDiffs ( ) ; DirectoryDiff priorDiff = diffList . getDiffById ( prior ) ; if ( priorDiff ! = null & & priorDiff . getSnapshotId ( ) = = prior ) { List < INode > dList = priorDiff . diff . getList ( ListType . DELETED ) ; excludedNodes = cloneDiffList ( dList ) ; } if ( snapshot ! = Snapshot . CURRENT _ STATE _ ID ) { diffList . deleteSnapshotDiff ( reclaimContext , snapshot , prior , dir ) ; } priorDiff = diffList . getDiffById ( prior ) ; if ( priorDiff ! = null & & priorDiff . getSnapshotId ( ) = = prior ) { priorDiff . diff . destroyCreatedList ( reclaimContext , dir ) ; } } for ( INode child : inode . asDirectory ( ) . getChildrenList ( prior ) ) { if ( excludedNodes ! = null & & excludedNodes . containsKey ( child ) ) { continue ; } destroyDstSubtree ( reclaimContext , child , snapshot , prior ) ; } } } 
1672	public void process ( ) throws ProcessingException { Just in case we get a linked list , create an array of documents final Document [ ] documentArray = this . documents . toArray ( new Document [ this . documents . size ( ) ] ) ; Prepare an array of url parts final String [ ] [ ] urlParts = buildUrlParts ( documentArray ) ; Recursively build the cluster structure final List < Integer > documentIndexes = new ArrayList < Integer > ( documentArray . length ) ; for ( int i = _NUM ; i < documentArray . length ; i + + ) { documentIndexes . add ( i ) ; } this . clusters = createClusters ( documentArray , documentIndexes , urlParts , _NUM , _STR ) ; } } 
1673	public void onKeyguardViewManagerStatesUpdated ( ) { logStateToEventlog ( ) ; } 
1674	public Joint createJoint ( JointDef def ) { assertNotLocked ( ) ; Joint j = Joint . create ( this , def ) ; Connect to the world list . j . m _ prev = null ; j . m _ next = m _ jointList ; if ( m _ jointList ! = null ) { m _ jointList . m _ prev = j ; } m _ jointList = j ; + + jointCount ; Connect to the bodies ' doubly linked lists . j . m _ edgeA . joint = j ; j . m _ edgeA . other = j . getBodyB ( ) ; j . m _ edgeA . prev = null ; j . m _ edgeA . next = j . getBodyA ( ) . m _ jointList ; if ( j . getBodyA ( ) . m _ jointList ! = null ) { j . getBodyA ( ) . m _ jointList . prev = j . m _ edgeA ; } j . getBodyA ( ) . m _ jointList = j . m _ edgeA ; j . m _ edgeB . joint = j ; j . m _ edgeB . other = j . getBodyA ( ) ; j . m _ edgeB . prev = null ; j . m _ edgeB . next = j . getBodyB ( ) . m _ jointList ; if ( j . getBodyB ( ) . m _ jointList ! = null ) { j . getBodyB ( ) . m _ jointList . prev = j . m _ edgeB ; } j . getBodyB ( ) . m _ jointList = j . m _ edgeB ; Body bodyA = def . bodyA ; Body bodyB = def . bodyB ; If the joint prevents collisions , then flag any contacts for filtering . if ( ! def . collideConnected ) { ContactEdge edge = bodyB . getContactList ( ) ; while ( edge ! = null ) { if ( edge . other = = bodyA ) { Flag the contact for filtering at the next time step ( where either body is awake ) . edge . contact . flagForFiltering ( ) ; } edge = edge . next ; } } return j ; } 
1675	public ArrayList < View > findViewsByText ( String text ) { ArrayList < View > allViews = getViews ( ) ; ArrayList < View > views = new ArrayList < View > ( ) ; int viewNumber = allViews . size ( ) ; for ( int i = _NUM ; i < viewNumber ; i + + ) { View view = allViews . get ( i ) ; String t = getViewText ( view ) ; if ( t . indexOf ( text ) ! = - _NUM ) { views . add ( view ) ; } } return views ; } 
1676	public synchronized boolean isAlertRateLimited ( String packageName ) { AggregatedStats stats = getOrCreateAggregatedStatsLocked ( packageName ) ; if ( stats ! = null ) { return stats . isAlertRateLimited ( ) ; } else { return false ; } } 
1677	public static Map < String , Object > quickRunAllProductionRunTasks ( DispatchContext ctx , Map < String , ? extends Object > context ) { Map < String , Object > result = ServiceUtil . returnSuccess ( ) ; Delegator delegator = ctx . getDelegator ( ) ; LocalDispatcher dispatcher = ctx . getDispatcher ( ) ; Locale locale = ( Locale ) context . get ( _STR , locale ) ) ; } } return result ; } 
1678	public Date getKeyValidityForOriginationEnd ( ) { return Utils . cloneIfNotNull ( mKeyValidityForOriginationEnd ) ; } 
1679	TODO : Look into merging with # setVisibility ( ) void setVisible ( boolean newVisible ) { visible = newVisible ; mDeferHidingClient = ! visible & & mDeferHidingClient ; if ( ! visible & & mUpdateTaskThumbnailWhenHidden ) { updateThumbnailLocked ( screenshotActivityLocked ( ) , null ) ; mUpdateTaskThumbnailWhenHidden = false ; } setVisibility ( visible ) ; mStackSupervisor . mAppVisibilitiesChangedSinceLastPause = true ; } 
1680	public void getDecoratedBoundsWithMargins ( View view , Rect outBounds ) { getDecoratedBoundsWithMarginsInt ( view , outBounds ) ; } 
1681	public void testReduceFromDisk ( ) throws Exception { final int MAP _ TASKS = _NUM ; JobConf job = mrCluster . createJobConf ( ) ; job . set ( JobContext . REDUCE _ INPUT _ BUFFER _ PERCENT , _STR , some records hit twice spill > = _NUM * out + ( out / MAP _ TASKS ) ) ; } 
1682	public void createVolumeOnFiler ( String ipAddress , String aggName , String poolName , String volName , String volSize , String snapshotPolicy , Integer snapshotReservation , String username , String password ) throws UnknownHostException , ServerException , InvalidParameterValueException { if ( s _ logger . isDebugEnabled ( ) ) s _ logger . debug ( _STR , ioe ) ; } finally { if ( s ! = null ) s . close ( ) ; if ( pool ! = null ) _ poolDao . releaseFromLockTable ( pool . getId ( ) ) ; } } 
1683	public static XmlIDREFS parse ( java . net . URL u ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( XmlIDREFS ) XmlBeans . getContextTypeLoader ( ) . parse ( u , type , null ) ; } 
1684	public final OptionDescriptor resolveOption ( String name ) { OptionDescriptor option = getOption ( name ) ; if ( option = = null ) { CommandDescriptor < T > owner = getOwner ( ) ; if ( owner ! = null ) { option = owner . resolveOption ( name ) ; } } return option ; } 
1685	void removeTaskImpl ( FilteredTaskList taskList , Task t ) { Remove the task from the list taskList . remove ( t ) ; Remove it from the group as well , and if it is empty , remove the group TaskGrouping group = t . group ; if ( group ! = null ) { group . removeTask ( t ) ; if ( group . getTaskCount ( ) = = _NUM ) { removeGroup ( group ) ; } } } 
1686	boolean setEnabled ( @ NonNull final String packageName , final int userId , final boolean enable ) throws BadKeyException { final int idx = select ( packageName , userId ) ; if ( idx < _NUM ) { throw new BadKeyException ( packageName , userId ) ; } return mItems . get ( idx ) . setEnabled ( enable ) ; } 
1687	public static String escapeString ( String in , Map < String , String > headers , TimeZone timeZone , boolean needRounding , int unit , int roundDown , boolean useLocalTimeStamp ) { long ts = clock . currentTimeMillis ( ) ; Matcher matcher = tagPattern . matcher ( in ) ; StringBuffer sb = new StringBuffer ( ) ; while ( matcher . find ( ) ) { String replacement = _STR ) ; matcher . appendReplacement ( sb , replacement ) ; } matcher . appendTail ( sb ) ; return sb . toString ( ) ; } 
1688	private void startRtAlphaFadeIn ( ) { if ( mCircleRadius = = _NUM & & mPreviewView = = null ) { Paint modifiedPaint = new Paint ( mCirclePaint ) ; modifiedPaint . setColor ( mCircleColor ) ; modifiedPaint . setAlpha ( _NUM ) ; mHwCirclePaint = CanvasProperty . createPaint ( modifiedPaint ) ; RenderNodeAnimator animator = new RenderNodeAnimator ( mHwCirclePaint , RenderNodeAnimator . PAINT _ ALPHA , _NUM _NUM _NUM ) ; animator . setTarget ( this ) ; animator . setInterpolator ( Interpolators . ALPHA _ IN ) ; animator . setDuration ( _NUM _NUM _NUM ) ; animator . start ( ) ; } } 
1689	public void newBlock ( ) throws Exception { Block b _NUM = createFakeBlock ( blockStore , Block . BLOCK _ HEIGHT _ GENESIS ) . block ; blockChain . add ( b _NUM ) ; final Block b _NUM = makeSolvedTestBlock ( b _NUM ) ; Receive notification of a new block . final InventoryMessage inv = new InventoryMessage ( UNITTEST ) ; InventoryItem item = new InventoryItem ( InventoryItem . Type . Block , b _NUM . getHash ( ) ) ; inv . addItem ( item ) ; final AtomicInteger newBlockMessagesReceived = new AtomicInteger ( _NUM ) ; connect ( ) ; Round - trip a ping so that we never see the response verack if we attach too quick pingAndWait ( writeTarget ) ; peer . addPreMessageReceivedEventListener ( Threading . SAME _ THREAD , new PreMessageReceivedEventListener ( ) { @ Override public synchronized Message onPreMessageReceived ( Peer p , Message m ) { if ( p ! = peer ) fail . set ( true ) ; if ( m instanceof Pong ) return m ; int newValue = newBlockMessagesReceived . incrementAndGet ( ) ; if ( newValue = = _NUM & & ! inv . equals ( m ) ) fail . set ( true ) ; else if ( newValue = = _NUM & & ! b _NUM . equals ( m ) ) fail . set ( true ) ; else if ( newValue > _NUM ) fail . set ( true ) ; return m ; } } ) ; peer . addBlocksDownloadedEventListener ( Threading . SAME _ THREAD , new BlocksDownloadedEventListener ( ) { @ Override public synchronized void onBlocksDownloaded ( Peer p , Block block , @ Nullable FilteredBlock filteredBlock , int blocksLeft ) { int newValue = newBlockMessagesReceived . incrementAndGet ( ) ; if ( newValue ! = _NUM | | p ! = peer | | ! block . equals ( b _NUM ) | | blocksLeft ! = OTHER _ PEER _ CHAIN _ HEIGHT - _NUM ) fail . set ( true ) ; } } ) ; long height = peer . getBestHeight ( ) ; inbound ( writeTarget , inv ) ; pingAndWait ( writeTarget ) ; assertEquals ( height + _NUM , peer . getBestHeight ( ) ) ; Response to the getdata message . inbound ( writeTarget , b _NUM ) ; pingAndWait ( writeTarget ) ; Threading . waitForUserCode ( ) ; pingAndWait ( writeTarget ) ; assertEquals ( _NUM , newBlockMessagesReceived . get ( ) ) ; GetDataMessage getdata = ( GetDataMessage ) outbound ( writeTarget ) ; List < InventoryItem > items = getdata . getItems ( ) ; assertEquals ( _NUM , items . size ( ) ) ; assertEquals ( b _NUM . getHash ( ) , items . get ( _NUM ) . hash ) ; assertEquals ( InventoryItem . Type . Block , items . get ( _NUM ) . type ) ; } 
1690	public static Date parseRFC _NUM _NUM _NUM Date ( String dateString ) { return parse ( RFC _NUM _NUM _NUM _ DATE _ PATTERN , dateString ) ; } 
1691	public void testWindowAverageWithGroupBy ( ) { final String sql = _STR ; sql ( sql ) . ok ( ) ; } 
1692	private Instance readInstance ( ResultSet rs ) throws Exception { ResultSetMetaData md = rs . getMetaData ( ) ; int numAttributes = md . getColumnCount ( ) ; double [ ] vals = new double [ numAttributes ] ; m _ structure . delete ( ) ; for ( int i = _NUM ; i < = numAttributes ; i + + ) { switch ( m _ DataBaseConnection . translateDBColumnType ( md . getColumnTypeName ( i ) ) ) { case DatabaseConnection . STRING : String str = rs . getString ( i ) ; if ( rs . wasNull ( ) ) { vals [ i - _NUM ] = Utils . missingValue ( ) ; } else { Double index = ( Double ) m _ nominalIndexes [ i - _NUM ] . get ( str ) ; if ( index = = null ) { index = new Double ( m _ structure . attribute ( i - _NUM ) . addStringValue ( str ) ) ; } vals [ i - _NUM ] = index . doubleValue ( ) ; } break ; case DatabaseConnection . TEXT : str = rs . getString ( i ) ; if ( rs . wasNull ( ) ) { vals [ i - _NUM ] = Utils . missingValue ( ) ; } else { Double index = ( Double ) m _ nominalIndexes [ i - _NUM ] . get ( str ) ; if ( index = = null ) { index = new Double ( m _ structure . attribute ( i - _NUM ) . addStringValue ( str ) ) ; } vals [ i - _NUM ] = index . doubleValue ( ) ; } break ; case DatabaseConnection . BOOL : boolean boo = rs . getBoolean ( i ) ; if ( rs . wasNull ( ) ) { vals [ i - _NUM ] = Utils . missingValue ( ) ; } else { vals [ i - _NUM ] = ( boo ? _NUM . _NUM : _NUM . _NUM ) ; } break ; case DatabaseConnection . DOUBLE : BigDecimal bd = rs . getBigDecimal ( i , _NUM ) ; double dd = rs . getDouble ( i ) ; Use the column precision instead of _NUM ? if ( rs . wasNull ( ) ) { vals [ i - _NUM ] = Utils . missingValue ( ) ; } else { newInst . setValue ( i - _NUM , bd . doubleValue ( ) ) ; vals [ i - _NUM ] = dd ; } break ; case DatabaseConnection . BYTE : byte by = rs . getByte ( i ) ; if ( rs . wasNull ( ) ) { vals [ i - _NUM ] = Utils . missingValue ( ) ; } else { vals [ i - _NUM ] = ( double ) by ; } break ; case DatabaseConnection . SHORT : short sh = rs . getShort ( i ) ; if ( rs . wasNull ( ) ) { vals [ i - _NUM ] = Utils . missingValue ( ) ; } else { vals [ i - _NUM ] = ( double ) sh ; } break ; case DatabaseConnection . INTEGER : int in = rs . getInt ( i ) ; if ( rs . wasNull ( ) ) { vals [ i - _NUM ] = Utils . missingValue ( ) ; } else { vals [ i - _NUM ] = ( double ) in ; } break ; case DatabaseConnection . LONG : long lo = rs . getLong ( i ) ; if ( rs . wasNull ( ) ) { vals [ i - _NUM ] = Utils . missingValue ( ) ; } else { vals [ i - _NUM ] = ( double ) lo ; } break ; case DatabaseConnection . FLOAT : float fl = rs . getFloat ( i ) ; if ( rs . wasNull ( ) ) { vals [ i - _NUM ] = Utils . missingValue ( ) ; } else { vals [ i - _NUM ] = ( double ) fl ; } break ; case DatabaseConnection . DATE : Date date = rs . getDate ( i ) ; if ( rs . wasNull ( ) ) { vals [ i - _NUM ] = Utils . missingValue ( ) ; } else { TODO : Do a value check here . vals [ i - _NUM ] = ( double ) date . getTime ( ) ; } break ; case DatabaseConnection . TIME : Time time = rs . getTime ( i ) ; if ( rs . wasNull ( ) ) { vals [ i - _NUM ] = Utils . missingValue ( ) ; } else { TODO : Do a value check here . vals [ i - _NUM ] = ( double ) time . getTime ( ) ; } break ; default : vals [ i - _NUM ] = Utils . missingValue ( ) ; } } Instance inst ; if ( m _ CreateSparseData ) inst = new SparseInstance ( _NUM . _NUM , vals ) ; else inst = new DenseInstance ( _NUM . _NUM , vals ) ; get rid of m _ idColumn if ( m _ DataBaseConnection . getUpperCase ( ) ) m _ idColumn = m _ idColumn . toUpperCase ( ) ; if ( m _ structure . attribute ( _NUM ) . name ( ) . equals ( m _ idColumn ) ) { inst . deleteAttributeAt ( _NUM ) ; m _ oldStructure . add ( inst ) ; inst = m _ oldStructure . instance ( _NUM ) ; m _ oldStructure . delete ( _NUM ) ; } else { instances is added to and deleted from the structure to get the true nominal values instead of the index of the values . m _ structure . add ( inst ) ; inst = m _ structure . instance ( _NUM ) ; m _ structure . delete ( _NUM ) ; } return inst ; } 
1693	 @ NonNullDrawable inflateFromXmlForDensity ( @ NonNull String name , @ NonNull XmlPullParser parser , @ NonNull AttributeSet attrs , int density , @ Nullable Theme theme ) throws XmlPullParserException , IOException { to stay consistent with how LayoutInflater works . if ( name . equals ( _STR ) ; } } Drawable drawable = inflateFromTag ( name ) ; if ( drawable = = null ) { drawable = inflateFromClass ( name ) ; } drawable . setSrcDensityOverride ( density ) ; drawable . inflate ( mRes , parser , attrs , theme ) ; return drawable ; } 
1694	protected void restoreInputsInSymbolTable ( ) { Map < String , Object > inputs = script . getInputs ( ) ; Map < String , Metadata > inputMetadata = script . getInputMetadata ( ) ; LocalVariableMap symbolTable = script . getSymbolTable ( ) ; Set < String > inputVariables = script . getInputVariables ( ) ; for ( String inputVariable : inputVariables ) { if ( symbolTable . get ( inputVariable ) = = null ) { retrieve optional metadata if it exists Metadata m = inputMetadata . get ( inputVariable ) ; script . in ( inputVariable , inputs . get ( inputVariable ) , m ) ; } } } 
1695	protected void scanNumber ( ) throws SQLSyntaxErrorException { offsetCache = curIndex ; sizeCache = _NUM ; final boolean fstDot = ch = = ' . ' ; boolean dot = fstDot ; boolean sign = false ; int state = fstDot ? _NUM : _NUM ; for ( ; scanChar ( ) ! = MySQLLexer . EOI ; + + sizeCache ) { switch ( state ) { case _NUM : if ( CharTypes . isDigit ( ch ) ) { } else if ( ch = = ' . ' ) { dot = true ; state = _NUM ; } else if ( ch = = ' e ' | | ch = = ' E ' ) { state = _NUM ; } else if ( CharTypes . isIdentifierChar ( ch ) ) { scanIdentifierFromNumber ( offsetCache , sizeCache ) ; return ; } else { token = MySQLToken . LITERAL _ NUM _ PURE _ DIGIT ; return ; } break ; case _NUM : if ( CharTypes . isDigit ( ch ) ) { state = _NUM ; } else if ( ch = = ' e ' | | ch = = ' E ' ) { state = _NUM ; } else if ( CharTypes . isIdentifierChar ( ch ) & & fstDot ) { sizeCache = _NUM ; ch = sql [ curIndex = offsetCache + _NUM ] ; token = MySQLToken . PUNC _ DOT ; return ; } else { token = MySQLToken . LITERAL _ NUM _ MIX _ DIGIT ; return ; } break ; case _NUM : if ( CharTypes . isDigit ( ch ) ) { } else if ( ch = = ' e ' | | ch = = ' E ' ) { state = _NUM ; } else if ( CharTypes . isIdentifierChar ( ch ) & & fstDot ) { sizeCache = _NUM ; ch = sql [ curIndex = offsetCache + _NUM ] ; token = MySQLToken . PUNC _ DOT ; return ; } else { token = MySQLToken . LITERAL _ NUM _ MIX _ DIGIT ; return ; } break ; case _NUM : if ( CharTypes . isDigit ( ch ) ) { state = _NUM ; } else if ( ch = = ' + ' | | ch = = ' - ' ) { sign = true ; state = _NUM ; } else if ( fstDot ) { sizeCache = _NUM ; ch = sql [ curIndex = offsetCache + _NUM ] ; token = MySQLToken . PUNC _ DOT ; return ; } else if ( ! dot ) { if ( CharTypes . isIdentifierChar ( ch ) ) { scanIdentifierFromNumber ( offsetCache , sizeCache ) ; } else { updateStringValue ( sql , offsetCache , sizeCache ) ; MySQLToken tok = keywods . getKeyword ( stringValueUppercase ) ; token = tok = = null ? MySQLToken . IDENTIFIER : tok ; } return ; } else { throw err ( _STR + ch ) ; } return ; } } 
1696	public void addItemDecoration ( ItemDecoration decor , int index ) { if ( mLayout ! = null ) { mLayout . assertNotInLayoutOrScroll ( _STR ) ; } if ( mItemDecorations . isEmpty ( ) ) { setWillNotDraw ( false ) ; } if ( index < _NUM ) { mItemDecorations . add ( decor ) ; } else { mItemDecorations . add ( index , decor ) ; } markItemDecorInsetsDirty ( ) ; requestLayout ( ) ; } 
1697	public static void pidCheck ( String pidDir , String run ) throws ConfigurationException { String dir = pidDir = = null ? _STR , e ) ; } } 
1698	public Builder setTicker ( CharSequence tickerText , RemoteViews views ) { mNotification . tickerText = limitCharSequenceLength ( tickerText ) ; mTickerView = views ; return this ; } 
1699	public void persist ( ) throws IOException { if ( ! persist ) { return ; } if ( isUpdated ( ) ) { System . out . println ( _STR ) ; } } 
1700	public void treeAwareUpdates _NUM ( ) { final String doc = _STR , false ) ; auc . addDelete ( _NUM ) ; auc . addInsert ( _NUM , _NUM , ins ) ; auc . addInsert ( _NUM , _NUM , ins ) ; auc . addReplace ( _NUM , ins ) ; auc . addInsert ( _NUM , _NUM , ins ) ; assertEquals ( _NUM , auc . updatesSize ( ) ) ; auc . clear ( ) ; auc . addInsert ( _NUM , _NUM , ins ) ; auc . addDelete ( _NUM ) ; auc . addInsert ( _NUM , _NUM , ins ) ; auc . addInsert ( _NUM , _NUM , ins ) ; auc . addReplace ( _NUM , ins ) ; auc . addInsert ( _NUM , _NUM , ins ) ; auc . addInsert ( _NUM , _NUM , ins ) ; assertEquals ( _NUM , auc . updatesSize ( ) ) ; } 
1701	public I _ CmsExtractionResult extractContent ( CmsObject cms , CmsResource resource , CmsSearchIndex index ) throws CmsException { logContentExtraction ( resource , index ) ; try { CmsFile file = readFile ( cms , resource ) ; A _ CmsXmlDocument xmlContent = CmsXmlContentFactory . unmarshal ( cms , file ) ; Locale locale = index . getLocaleForResource ( cms , resource , xmlContent . getLocales ( ) ) ; List < String > elements = xmlContent . getNames ( locale ) ; StringBuffer content = new StringBuffer ( ) ; Map < String , String > items = new HashMap < String , String > ( ) ; for ( Iterator < String > i = elements . iterator ( ) ; i . hasNext ( ) ; ) { String xpath = i . next ( ) ; xpath will have the form _STR I _ CmsXmlContentValue value = xmlContent . getValue ( xpath , locale ) ; if ( value . getContentDefinition ( ) . getContentHandler ( ) . isSearchable ( value ) ) { the content value is searchable String extracted = value . getPlainText ( cms ) ; if ( CmsStringUtil . isNotEmptyOrWhitespaceOnly ( extracted ) ) { items . put ( xpath , extracted ) ; content . append ( extracted ) ; content . append ( ' \ n ' ) ; } } } return new CmsExtractionResult ( content . toString ( ) , items ) ; } catch ( Exception e ) { throw new CmsIndexException ( Messages . get ( ) . container ( Messages . ERR _ TEXT _ EXTRACTION _ _NUM , resource . getRootPath ( ) ) , e ) ; } } 
1702	private static boolean getOsMatchesName ( final String osNamePrefix ) { return isOsNameMatch ( OS _ NAME , osNamePrefix ) ; } 
1703	protected void failed ( Throwable e , Description description ) { final int lineNumber = getLineNumber ( e , description ) ; String lineOut = lineNumber = = - _NUM ? _STR ) . newline ( ) ) ; printThreads ( ) ; printLogs ( ) ; System . out . flush ( ) ; } 
1704	private GetCredentialsForIdentityResult retryGetCredentialsForIdentity ( ) { token = retryRefresh ( ) ; Map < String , String > logins ; if ( token ! = null & & ! token . isEmpty ( ) ) { logins = new HashMap < String , String > ( ) ; logins . put ( _STR , token ) ; } else { logins = getLogins ( ) ; } GetCredentialsForIdentityRequest request = new GetCredentialsForIdentityRequest ( ) . withIdentityId ( getIdentityId ( ) ) . withLogins ( logins ) . withCustomRoleArn ( customRoleArn ) ; return cib . getCredentialsForIdentity ( request ) ; } 
1705	public void registerCallback ( KeyguardUpdateMonitorCallback callback ) { if ( DEBUG ) Log . v ( TAG , _STR ) ) ; return ; } } mCallbacks . add ( new WeakReference < KeyguardUpdateMonitorCallback > ( callback ) ) ; remove unused references removeCallback ( null ) ; sendUpdates ( callback ) ; } 
1706	public int getSuggestionInfo ( SuggestionInfo [ ] suggestionInfos , @ Nullable SuggestionSpanInfo misspelledSpanInfo ) { final Spannable spannable = ( Spannable ) mTextView . getText ( ) ; final SuggestionSpan [ ] suggestionSpans = getSortedSuggestionSpans ( ) ; final int nbSpans = suggestionSpans . length ; if ( nbSpans = = _NUM ) return _NUM ; int numberOfSuggestions = _NUM ; for ( final SuggestionSpan suggestionSpan : suggestionSpans ) { final int spanStart = spannable . getSpanStart ( suggestionSpan ) ; final int spanEnd = spannable . getSpanEnd ( suggestionSpan ) ; if ( misspelledSpanInfo ! = null & & ( suggestionSpan . getFlags ( ) & SuggestionSpan . FLAG _ MISSPELLED ) ! = _NUM ) { misspelledSpanInfo . mSuggestionSpan = suggestionSpan ; misspelledSpanInfo . mSpanStart = spanStart ; misspelledSpanInfo . mSpanEnd = spanEnd ; } final String [ ] suggestions = suggestionSpan . getSuggestions ( ) ; final int nbSuggestions = suggestions . length ; suggestionLoop : for ( int suggestionIndex = _NUM ; suggestionIndex < nbSuggestions ; suggestionIndex + + ) { final String suggestion = suggestions [ suggestionIndex ] ; for ( int i = _NUM ; i < numberOfSuggestions ; i + + ) { final SuggestionInfo otherSuggestionInfo = suggestionInfos [ i ] ; if ( otherSuggestionInfo . mText . toString ( ) . equals ( suggestion ) ) { final int otherSpanStart = otherSuggestionInfo . mSuggestionSpanInfo . mSpanStart ; final int otherSpanEnd = otherSuggestionInfo . mSuggestionSpanInfo . mSpanEnd ; if ( spanStart = = otherSpanStart & & spanEnd = = otherSpanEnd ) { continue suggestionLoop ; } } } SuggestionInfo suggestionInfo = suggestionInfos [ numberOfSuggestions ] ; suggestionInfo . setSpanInfo ( suggestionSpan , spanStart , spanEnd ) ; suggestionInfo . mSuggestionIndex = suggestionIndex ; suggestionInfo . mSuggestionStart = _NUM ; suggestionInfo . mSuggestionEnd = suggestion . length ( ) ; suggestionInfo . mText . replace ( _NUM , suggestionInfo . mText . length ( ) , suggestion ) ; numberOfSuggestions + + ; if ( numberOfSuggestions > = suggestionInfos . length ) { return numberOfSuggestions ; } } } return numberOfSuggestions ; } 
1707	private void notifyPrintJobUpdated ( PrintJobInfo printJob ) { Message message = mHandlerCaller . obtainMessageO ( HandlerCallerCallback . MSG _ ON _ PRINT _ JOB _ STATE _ CHANGED , printJob ) ; mHandlerCaller . executeOrSendMessage ( message ) ; mNotificationController . onUpdateNotifications ( mPrintJobs ) ; } 
1708	protected final Weight createWeight ( Query query ) throws IOException { return createNormalizedWeight ( query ) ; } 
1709	public static boolean isSignedInteger ( String s ) { if ( isEmpty ( s ) ) return defaultEmptyOK ; try { Integer . parseInt ( s ) ; return true ; } catch ( Exception e ) { return false ; } } 
1710	public Rational subtract ( Rational val ) { Rational val _NUM = val . negate ( ) ; return ( add ( val _NUM ) ) ; } 
1711	public static FilterGraph readXmlGraph ( MffContext context , String xmlSource ) throws IOException { FilterGraph . Builder builder = getBuilderForXmlString ( context , xmlSource ) ; return builder . build ( ) ; } 
1712	public void replaceTextRange ( int start , int replaceLength , String text ) { int length = text . length ( ) ; if ( length ! = replaceLength | | start + length > data . length ( ) ) return ; data . replace ( start , start + length , text ) ; } 
1713	private void setMoreParams ( RequestContext rc , String pathInfo , Dest dest ) { checkState ( pathInfo . startsWith ( dest . prefix ) , _STR , parts , dest . pathParams ) ; for ( int i = _NUM ; i < dest . pathParams . size ( ) & & i < parts . length ; + + i ) { String key = dest . pathParams . get ( i ) ; if ( key . charAt ( _NUM ) = = ' : ' ) { rc . moreParams ( ) . put ( key . substring ( _NUM ) , parts [ i ] ) ; } } } 
1714	public Character get ( Object key ) { long k ; if ( key ! = null ) { if ( key instanceof Long ) { k = unwrapKey ( key ) ; } else { return null ; } } else { k = _ map . getNoEntryKey ( ) ; } char v = _ map . get ( k ) ; check here . if ( v = = _ map . getNoEntryValue ( ) ) { return null ; } else { return wrapValue ( v ) ; } } 
1715	static AttributeValueSets openAttributes ( ) { final IPath pathHint = FileDialogs . recallPath ( REMEMBER _ DIRECTORY ) ; final IPath readLocation = FileDialogs . openReadXML ( pathHint ) ; if ( readLocation ! = null ) { FileDialogs . rememberDirectory ( REMEMBER _ DIRECTORY , readLocation ) ; try { final Persister persister = new Persister ( ) ; final AttributeValueSets avs = persister . read ( AttributeValueSets . class , readLocation . toFile ( ) ) ; return avs ; } catch ( Exception e ) { Utils . showError ( new Status ( IStatus . ERROR , WorkbenchCorePlugin . PLUGIN _ ID , _STR + readLocation . toOSString ( ) , e ) ) ; } } return new AttributeValueSets ( ) ; } 
1716	public ComponentSelector selectSelectedStyle ( ) { currentStyle = getSelectedStyle ( ) ; currentStyleType = SELECTED _ STYLE ; return this ; } 
1717	public void addSlide ( @ NonNull Fragment fragment ) { if ( isRtl ( ) ) fragments . add ( _NUM , fragment ) ; else fragments . add ( fragment ) ; if ( isWizardMode ) { setOffScreenPageLimit ( fragments . size ( ) ) ; } mPagerAdapter . notifyDataSetChanged ( ) ; } 
1718	public static void UTF _NUM _NUM toUTF _NUM ( final String s , final int offset , final int length , UTF _NUM Result result ) { final int end = offset + length ; byte [ ] out = result . result ; int upto = _NUM ; for ( int i = offset ; i < end ; i + + ) { final int code = ( int ) s . charAt ( i ) ; if ( upto + _NUM > out . length ) { out = result . result = ArrayUtil . grow ( out , upto + _NUM ) ; } if ( code < _NUM x _NUM _NUM ) out [ upto + + ] = ( byte ) code ; else if ( code < _NUM x _NUM _NUM _NUM ) { out [ upto + + ] = ( byte ) ( _NUM xC _NUM | ( code > > _NUM ) ) ; out [ upto + + ] = ( byte ) ( _NUM x _NUM _NUM | ( code & _NUM x _NUM F ) ) ; } else if ( code < _NUM xD _NUM _NUM _NUM | | code > _NUM xDFFF ) { out [ upto + + ] = ( byte ) ( _NUM xE _NUM | ( code > > _NUM _NUM ) ) ; out [ upto + + ] = ( byte ) ( _NUM x _NUM _NUM | ( ( code > > _NUM ) & _NUM x _NUM F ) ) ; out [ upto + + ] = ( byte ) ( _NUM x _NUM _NUM | ( code & _NUM x _NUM F ) ) ; } else { confirm valid high surrogate if ( code < _NUM xDC _NUM _NUM & & ( i < end - _NUM ) ) { int utf _NUM _NUM = ( int ) s . charAt ( i + _NUM ) ; confirm valid low surrogate and write pair if ( utf _NUM _NUM > = _NUM xDC _NUM _NUM & & utf _NUM _NUM < = _NUM xDFFF ) { utf _NUM _NUM = ( ( code - _NUM xD _NUM C _NUM ) < < _NUM _NUM ) + ( utf _NUM _NUM & _NUM x _NUM FF ) ; i + + ; out [ upto + + ] = ( byte ) ( _NUM xF _NUM | ( utf _NUM _NUM > > _NUM _NUM ) ) ; out [ upto + + ] = ( byte ) ( _NUM x _NUM _NUM | ( ( utf _NUM _NUM > > _NUM _NUM ) & _NUM x _NUM F ) ) ; out [ upto + + ] = ( byte ) ( _NUM x _NUM _NUM | ( ( utf _NUM _NUM > > _NUM ) & _NUM x _NUM F ) ) ; out [ upto + + ] = ( byte ) ( _NUM x _NUM _NUM | ( utf _NUM _NUM & _NUM x _NUM F ) ) ; continue ; } } replace unpaired surrogate or out - of - order low surrogate with substitution character out [ upto + + ] = ( byte ) _NUM xEF ; out [ upto + + ] = ( byte ) _NUM xBF ; out [ upto + + ] = ( byte ) _NUM xBD ; } } assert matches ( s , offset , length , out , upto ) ; result . length = upto ; } 
1719	public void clearFormData ( ) { checkThread ( ) ; mProvider . clearFormData ( ) ; } 
1720	public void testIsEmpty ( ) { Graph g = getGraph ( ) ; if ( canBeEmpty ( g ) ) { assertTrue ( g . isEmpty ( ) ) ; g . add ( NodeCreateUtils . createTriple ( _STR ) ) ; assertTrue ( g . isEmpty ( ) ) ; } } 
1721	public TelecomAnalytics dumpAnalytics ( ) { ITelecomService service = getTelecomService ( ) ; TelecomAnalytics result = null ; if ( service ! = null ) { try { result = service . dumpCallAnalytics ( ) ; } catch ( RemoteException e ) { Log . e ( TAG , _STR , e ) ; } } return result ; } 
1722	public E createEdgeValue ( ) { return getEdgeValueFactory ( ) . newInstance ( ) ; } 
1723	public static void openExternally ( String url , Context context ) { url = StringEscapeUtils . unescapeHtml _NUM ( Html . fromHtml ( url ) . toString ( ) ) ; Uri uri = formatURL ( url ) ; final String id = BuildConfig . APPLICATION _ ID ; final Intent intent = new Intent ( Intent . ACTION _ VIEW , uri ) ; final PackageManager packageManager = context . getPackageManager ( ) ; String resolvedName ; try { resolvedName = intent . resolveActivity ( packageManager ) . getPackageName ( ) ; } catch ( Exception e ) { resolvedName = context . getPackageName ( ) ; } if ( resolvedName = = null ) return ; if ( resolvedName . matches ( id ) ) { context . startActivity ( Intent . createChooser ( intent , context . getString ( R . string . misc _ link _ chooser ) ) ) ; return ; } context . startActivity ( intent ) ; } 
1724	public void eval ( INDArray labels , INDArray predictions ) { if ( labels . rank ( ) = = _NUM & & predictions . rank ( ) = = _NUM ) { Assume time series input - > reshape to _NUM d evalTimeSeries ( labels , predictions ) ; } if ( labels . rank ( ) > _NUM | | predictions . rank ( ) > _NUM | | labels . size ( _NUM ) ! = predictions . size ( _NUM ) | | labels . size ( _NUM ) > _NUM ) { throw new IllegalArgumentException ( _STR probAndLabel = Nd _NUM j . create ( new int [ ] { initialSize , _NUM } , ' c ' ) ; } Allocate a larger array if necessary if ( exampleCount + labels . size ( _NUM ) > = probAndLabel . size ( _NUM ) ) { int newSize = probAndLabel . size ( _NUM ) + Math . max ( exactAllocBlockSize , labels . size ( _NUM ) ) ; INDArray newProbAndLabel = Nd _NUM j . create ( new int [ ] { newSize , _NUM } , ' c ' ) ; if ( exampleCount > _NUM ) { If statement to handle edge case : no examples , but we need to re - allocate right away newProbAndLabel . get ( interval ( _NUM , exampleCount ) , all ( ) ) . assign ( probAndLabel . get ( interval ( _NUM , exampleCount ) , all ( ) ) ) ; } probAndLabel = newProbAndLabel ; } put values INDArray probClass _NUM ; INDArray labelClass _NUM ; if ( singleOutput ) { probClass _NUM = predictions ; labelClass _NUM = labels ; } else { probClass _NUM = predictions . getColumn ( _NUM ) ; labelClass _NUM = labels . getColumn ( _NUM ) ; } int currMinibatchSize = labels . size ( _NUM ) ; probAndLabel . get ( interval ( exampleCount , exampleCount + currMinibatchSize ) , NDArrayIndex . point ( _NUM ) ) . assign ( probClass _NUM ) ; probAndLabel . get ( interval ( exampleCount , exampleCount + currMinibatchSize ) , NDArrayIndex . point ( _NUM ) ) . assign ( labelClass _NUM ) ; int countClass _NUM CurrMinibatch = labelClass _NUM . sumNumber ( ) . intValue ( ) ; countActualPositive + = countClass _NUM CurrMinibatch ; countActualNegative + = labels . size ( _NUM ) - countClass _NUM CurrMinibatch ; } else { Thresholded approach INDArray positivePredictedClassColumn ; INDArray positiveActualClassColumn ; INDArray negativeActualClassColumn ; if ( singleOutput ) { Single binary variable case positiveActualClassColumn = labels ; _NUM . _NUM - label negativeActualClassColumn = labels . rsub ( _NUM . _NUM ) ; positivePredictedClassColumn = predictions ; } else { Standard case - _NUM output variables ( probability distribution ) positiveActualClassColumn = labels . getColumn ( _NUM ) ; negativeActualClassColumn = labels . getColumn ( _NUM ) ; positivePredictedClassColumn = predictions . getColumn ( _NUM ) ; } Increment global counts - actual positive / negative observed countActualPositive + = positiveActualClassColumn . sumNumber ( ) . intValue ( ) ; countActualNegative + = negativeActualClassColumn . sumNumber ( ) . intValue ( ) ; Here : calculate true positive rate ( TPR ) vs . false positive rate ( FPR ) at different threshold INDArray ppc = null ; INDArray itp = null ; INDArray ifp = null ; for ( int i = _NUM ; i < = thresholdSteps ; i + + ) { double currThreshold = i * step ; Work out true / false positives - do this by replacing probabilities ( predictions ) with _NUM or _NUM based on threshold Condition condGeq = Conditions . greaterThanOrEqual ( currThreshold ) ; Condition condLeq = Conditions . lessThanOrEqual ( currThreshold ) ; if ( ppc = = null ) { ppc = positivePredictedClassColumn . dup ( positiveActualClassColumn . ordering ( ) ) ; } else { ppc . assign ( positivePredictedClassColumn ) ; } Op op = new CompareAndSet ( ppc , _NUM . _NUM , condGeq ) ; INDArray predictedClass _NUM = Nd _NUM j . getExecutioner ( ) . execAndReturn ( op ) ; op = new CompareAndSet ( predictedClass _NUM , _NUM . _NUM , condLeq ) ; predictedClass _NUM = Nd _NUM j . getExecutioner ( ) . execAndReturn ( op ) ; True positives : occur when positive predicted class and actual positive actual class . . . False positive occurs when positive predicted class , but negative actual class = predictedClass _NUM . mul ( positiveActualClassColumn ) ; predicted = = _NUM and actual = = _NUM at this threshold : _NUM x _NUM = _NUM . _NUM otherwise INDArray isTruePositive ; = predictedClass _NUM . mul ( negativeActualClassColumn ) ; predicted = = _NUM and actual = = _NUM at this threshold : _NUM x _NUM = _NUM . _NUM otherwise INDArray isFalsePositive ; if ( i = = _NUM ) { isTruePositive = predictedClass _NUM . mul ( positiveActualClassColumn ) ; isFalsePositive = predictedClass _NUM . mul ( negativeActualClassColumn ) ; itp = isTruePositive ; ifp = isFalsePositive ; } else { isTruePositive = Nd _NUM j . getExecutioner ( ) . execAndReturn ( new OldMulOp ( predictedClass _NUM , positiveActualClassColumn , itp ) ) ; isFalsePositive = Nd _NUM j . getExecutioner ( ) . execAndReturn ( new OldMulOp ( predictedClass _NUM , negativeActualClassColumn , ifp ) ) ; } Counts for this batch : int truePositiveCount = isTruePositive . sumNumber ( ) . intValue ( ) ; int falsePositiveCount = isFalsePositive . sumNumber ( ) . intValue ( ) ; Increment counts for this thold CountsForThreshold thresholdCounts = counts . get ( currThreshold ) ; thresholdCounts . incrementTruePositive ( truePositiveCount ) ; thresholdCounts . incrementFalsePositive ( falsePositiveCount ) ; } } exampleCount + = labels . size ( _NUM ) ; auc = null ; auprc = null ; rocCurve = null ; prCurve = null ; } 
1725	public static boolean hasSameId ( GraphObject a , GraphObject b ) { if ( a = = null | | b = = null | | ! a . asMap ( ) . containsKey ( _STR ) ; if ( idA = = null | | idB = = null | | ! ( idA instanceof String ) | | ! ( idB instanceof String ) ) { return false ; } return idA . equals ( idB ) ; } 
1726	private static void testRootLoggerSetError ( ) { Properties props = new Properties ( ) ; ByteArrayOutputStream out _NUM = new ByteArrayOutputStream ( ) ; ByteArrayOutputStream err _NUM = new ByteArrayOutputStream ( ) ; PrintStream out _NUM = new PrintStream ( out _NUM ) ; PrintStream err _NUM = new PrintStream ( err _NUM ) ; props . put ( _STR ) ; } } 
1727	public void addLineageRDD ( String varParent , String varChild ) { RDDObject parent = getCacheableData ( varParent ) . getRDDHandle ( ) ; RDDObject child = getCacheableData ( varChild ) . getRDDHandle ( ) ; parent . addLineageChild ( child ) ; } 
1728	public boolean process ( Namespace ns ) { boolean suppressOutput = ns . getBoolean ( _STR , suppressOutput ) ; } return false ; } } 
1729	public boolean isReachable ( InetAddress ip ) { final List < RouteInfo > allRoutes = getAllRoutes ( ) ; If we don ' t have a route to this IP address , it ' s not reachable . final RouteInfo bestRoute = RouteInfo . selectBestRoute ( allRoutes , ip ) ; if ( bestRoute = = null ) { return false ; } if ( ip instanceof Inet _NUM Address ) { For IPv _NUM , it suffices for now to simply have any address . return hasIPv _NUM AddressOnInterface ( bestRoute . getInterface ( ) ) ; } else if ( ip instanceof Inet _NUM Address ) { if ( ip . isLinkLocalAddress ( ) ) { TODO : verify it matches the ifindex of one of the interfaces . return ( ( ( Inet _NUM Address ) ip ) . getScopeId ( ) ! = _NUM ) ; } else { TODO : reconsider all cases ( disconnected ULA networks , . . . ) . return ( ! bestRoute . hasGateway ( ) | | hasGlobalIPv _NUM Address ( ) ) ; } } return false ; } 
1730	private void parseGroup ( ) throws XMLStreamException { int groupCounter = _NUM ; while ( reader . hasNext ( ) ) { int event = reader . next ( ) ; if ( event = = XMLStreamConstants . START _ ELEMENT ) { applyTransform ( ) ; final String elementName = reader . getLocalName ( ) ; if ( elementName . equalsIgnoreCase ( CIRCLE _ ELEMENT ) ) parseCircle ( ) ; else if ( elementName . equalsIgnoreCase ( ELLIPSE _ ELEMENT ) ) parseEllipse ( ) ; else if ( elementName . equalsIgnoreCase ( LINE _ ELEMENT ) ) parseLine ( ) ; else if ( elementName . equalsIgnoreCase ( POLYLINE _ ELEMENT ) ) parsePolyline ( ) ; else if ( elementName . equalsIgnoreCase ( POLYGON _ ELEMENT ) ) parsePolygon ( ) ; else if ( elementName . equalsIgnoreCase ( RECT _ ELEMENT ) ) parseRect ( ) ; } else if ( event = = XMLStreamConstants . END _ ELEMENT ) { applyTransformEnd ( ) ; if ( reader . getLocalName ( ) . equalsIgnoreCase ( GROUP _ ELEMENT ) ) { groupCounter - - ; if ( groupCounter = = _NUM ) break ; } } } } 
1731	private void checkResolutionLevelIsSufficientForProviderUse ( int allowedResolutionLevel , String providerName ) { int requiredResolutionLevel = getMinimumResolutionLevelForProviderUse ( providerName ) ; if ( allowedResolutionLevel < requiredResolutionLevel ) { switch ( requiredResolutionLevel ) { case RESOLUTION _ LEVEL _ FINE : throw new SecurityException ( _STR ) ; } } } 
1732	public boolean isDeleted ( int n ) { Don ' t call ensureOpen ( ) here ( it could affect performance ) if ( readers . size ( ) > _NUM ) return readers . get ( _NUM ) . isDeleted ( n ) ; return false ; } 
1733	public String getString ( String key ) { return ( String ) getObject ( key ) ; } 
1734	isNotTabuOperation getOptimalOperation ( BayesNet bayesNet , Instances instances ) throws Exception { Operation oBestOperation = new Operation ( ) ; Add ? ? ? oBestOperation = findBestArcToAdd ( bayesNet , instances , oBestOperation ) ; Delete ? ? ? oBestOperation = findBestArcToDelete ( bayesNet , instances , oBestOperation ) ; Reverse ? ? ? if ( getUseArcReversal ( ) ) { oBestOperation = findBestArcToReverse ( bayesNet , instances , oBestOperation ) ; } did we find something ? if ( oBestOperation . m _ fScore = = - _NUM E _NUM _NUM _NUM ) { return null ; } return oBestOperation ; } 
1735	public XMLStringBuffer getSuiteBuffer ( ) { if ( null = = m _ suiteBuffer ) { m _ suiteBuffer = createContentBuffer ( ) ; } return m _ suiteBuffer ; } 
1736	public Object clone ( ) { try { return super . clone ( ) ; } catch ( CloneNotSupportedException ex ) { throw new InternalError ( ex . toString ( ) ) ; } } 
1737	protected final double calcVariancePop ( ) { ( N * sum ( ? x * ? x ) - sum ( ? x ) ) / N * N return AccStatLib . calcVariancePopulation ( sumSquared , sum , count ) ; } 
1738	private int writeScenarioDetails ( List < ClassResult > classResults , int startingScenarioIndex ) { int scenarioIndex = startingScenarioIndex ; for ( ClassResult classResult : classResults ) { String className = classResult . getClassName ( ) ; for ( MethodResult methodResult : classResult . getMethodResults ( ) ) { List < ITestResult > results = methodResult . getResults ( ) ; assert ! results . isEmpty ( ) ; String label = Utils . escapeHtml ( className + _STR + results . iterator ( ) . next ( ) . getMethod ( ) . getMethodName ( ) ) ; for ( ITestResult result : results ) { writeScenario ( scenarioIndex , label , result ) ; scenarioIndex + + ; } } } return scenarioIndex - startingScenarioIndex ; } 
1739	protected boolean onRequestFocusInDescendants ( int direction , Rect previouslyFocusedRect ) { int index ; int increment ; int end ; int count = getChildCount ( ) ; if ( ( direction & FOCUS _ FORWARD ) ! = _NUM ) { index = _NUM ; increment = _NUM ; end = count ; } else { index = count - _NUM ; increment = - _NUM ; end = - _NUM ; } for ( int i = index ; i ! = end ; i + = increment ) { View child = getChildAt ( i ) ; if ( child . getVisibility ( ) = = VISIBLE ) { ItemInfo ii = infoForChild ( child ) ; if ( ii ! = null & & ii . position = = mCurItem ) { if ( child . requestFocus ( direction , previouslyFocusedRect ) ) { return true ; } } } } return false ; } 
1740	public Map < String , Object > readUserInfos ( CmsDbContext dbc , CmsUUID userId ) throws CmsDataAccessException { Map < String , Object > infos = new HashMap < String , Object > ( ) ; try { Query q = m _ sqlManager . createQuery ( dbc , C _ USERDATA _ READ _ _NUM ) ; q . setParameter ( _NUM , userId . toString ( ) ) ; @ SuppressWarnings ( _STR ) List < CmsDAOUserData > res = q . getResultList ( ) ; read the infos for ( CmsDAOUserData ud : res ) { String key = ud . getDataKey ( ) ; String type = ud . getDataType ( ) ; byte [ ] value = ud . getDataValue ( ) ; deserialize Object data = null ; try { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( org . opencms . db . generic . Messages . get ( ) . getBundle ( ) . key ( org . opencms . db . generic . Messages . LOG _ DBG _ READUSERINFO _ _NUM , key , type ) ) ; if ( value ! = null ) { try { LOG . debug ( org . opencms . db . generic . Messages . get ( ) . getBundle ( ) . key ( org . opencms . db . generic . Messages . LOG _ DBG _ READUSERINFO _ VALUE _ _NUM , new String ( value ) ) ) ; } catch ( Exception e ) { noop } } else { LOG . debug ( org . opencms . db . generic . Messages . get ( ) . getBundle ( ) . key ( org . opencms . db . generic . Messages . LOG _ DBG _ READUSERINFO _ VALUE _ _NUM , null ) ) ; } } data = CmsDataTypeUtil . dataDeserialize ( value , type ) ; } catch ( Exception e ) { LOG . warn ( Messages . get ( ) . container ( Messages . ERR _ READING _ ADDITIONAL _ INFO _ _NUM , userId . toString ( ) ) . key ( ) , e ) ; } if ( key ! = null ) { infos . put ( key , data ) ; } } } catch ( PersistenceException e ) { throw new CmsDataAccessException ( Messages . get ( ) . container ( Messages . ERR _ JPA _ PERSITENCE , e ) , e ) ; } return infos ; } 
1741	public int remove ( String id ) throws Exception { id = Preconditions . checkNotNull ( id , _STR ) ; queue . checkState ( ) ; int count = _NUM ; for ( String name : queue . getChildren ( ) ) { if ( parseId ( name ) . id . equals ( id ) ) { if ( queue . tryRemove ( name ) ) { + + count ; } } } return count ; } 
1742	public Void call ( ) throws Exception { if ( options = = null ) { mFileSystem . setAttribute ( new AlluxioURI ( path ) , SetAttributeOptions . defaults ( ) ) ; } else { mFileSystem . setAttribute ( new AlluxioURI ( path ) , options ) ; } return null ; } } ) ; } 
1743	public String readLine ( ) throws IOException { StringBuffer s = null ; int startChar ; synchronized ( lock ) { ensureOpen ( ) ; bufferLoop : for ( ; ; ) { if ( nextChar > = nChars ) { fill ( ) ; } if ( nextChar > = nChars ) { if ( s ! = null & & s . length ( ) > _NUM ) { return s . toString ( ) ; } else { return null ; } } boolean eol = false ; char c = _NUM ; int i ; charLoop : for ( i = nextChar ; i < nChars ; i + + ) { c = cb [ i ] ; if ( ( c = = ' \ n ' ) | | ( c = = ' \ r ' ) ) { if ( ( c = = ' \ r ' ) & & ( cb . length > i + _NUM ) & & cb [ i + _NUM ] = = ' \ n ' ) { windows case ' \ r \ n ' here verify the next character i + _NUM i + + ; } eol = true ; break charLoop ; } } startChar = nextChar ; nextChar = i ; if ( eol ) { String str ; if ( s = = null ) { str = new String ( cb , startChar , ( i + _NUM ) - startChar ) ; } else { s . append ( cb , startChar , ( i + _NUM ) - startChar ) ; str = s . toString ( ) ; } nextChar + + ; return str ; } if ( s = = null ) { s = new StringBuffer ( defaultExpectedLineLength ) ; } s . append ( cb , startChar , i - startChar ) ; } } } 
1744	public V put ( Character key , V value ) { char k ; if ( key = = null ) { k = _ map . getNoEntryKey ( ) ; } else { k = unwrapKey ( key ) ; } return _ map . put ( k , value ) ; } 
1745	public I _ CmsPrincipal lookupPrincipal ( CmsDbContext dbc , String principalName ) { try { CmsGroup group = getUserDriver ( dbc ) . readGroup ( dbc , principalName ) ; if ( group ! = null ) { return group ; } } catch ( Exception e ) { ignore this exception } try { CmsUser user = readUser ( dbc , principalName ) ; if ( user ! = null ) { return user ; } } catch ( Exception e ) { ignore this exception } return null ; } 
1746	public void readMatching ( Reader reader , long matchStartMillis , long matchEndMillis ) throws IOException { final FileInfo info = new FileInfo ( mPrefix ) ; for ( String name : mBasePath . list ( ) ) { if ( ! info . parse ( name ) ) continue ; read file when it overlaps if ( info . startMillis < = matchEndMillis & & matchStartMillis < = info . endMillis ) { if ( LOGD ) Slog . d ( TAG , _STR + name ) ; final File file = new File ( mBasePath , name ) ; readFile ( file , reader ) ; } } } 
1747	public boolean isSet ( _ Fields field ) { if ( field = = null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case CAPACITY _ BYTES : return isSetCapacityBytes ( ) ; case CAPACITY _ BYTES _ ON _ TIERS : return isSetCapacityBytesOnTiers ( ) ; case FREE _ BYTES : return isSetFreeBytes ( ) ; case LIVE _ WORKER _ NUM : return isSetLiveWorkerNum ( ) ; case LOST _ WORKER _ NUM : return isSetLostWorkerNum ( ) ; case USED _ BYTES : return isSetUsedBytes ( ) ; case USED _ BYTES _ ON _ TIERS : return isSetUsedBytesOnTiers ( ) ; } throw new IllegalStateException ( ) ; } 
1748	static void write ( ByteBuffer buf , int offset , Cell cell , byte [ ] value , byte [ ] tags ) { Key length offset = ByteBufferUtils . putInt ( buf , offset , KeyValueUtil . keyLength ( cell ) ) ; Value length offset = ByteBufferUtils . putInt ( buf , offset , value . length ) ; offset = KeyValueUtil . appendKeyTo ( cell , buf , offset ) ; ByteBufferUtils . copyFromArrayToBuffer ( buf , offset , value , _NUM , value . length ) ; offset + = value . length ; int tagsLen = tags = = null ? _NUM : tags . length ; if ( tagsLen > _NUM ) { offset = ByteBufferUtils . putAsShort ( buf , offset , tagsLen ) ; ByteBufferUtils . copyFromArrayToBuffer ( buf , offset , tags , _NUM , tagsLen ) ; } } 
1749	public Builder setActions ( Action . . . actions ) { mActions . clear ( ) ; for ( int i = _NUM ; i < actions . length ; i + + ) { if ( actions [ i ] ! = null ) { mActions . add ( actions [ i ] ) ; } } return this ; } 
1750	private AccessibilityEvent createEvent ( int virtualViewId , int eventType ) { switch ( virtualViewId ) { case HOST _ ID : return createEventForHost ( eventType ) ; default : return createEventForChild ( virtualViewId , eventType ) ; } } 
1751	public double [ ] getPMF ( final T [ ] splitPoints ) { if ( isEmpty ( ) ) { return null ; } return ItemsPmfCdfImpl . getPMFOrCDF ( this , splitPoints , false ) ; } 
1752	public String globalInfo ( ) { return _STR + getTechnicalInformation ( ) . toString ( ) ; } 
1753	public static void debug ( Throwable t , Object . . . messages ) { _ log ( ) . debug ( t , messages ) ; } 
1754	public boolean isHardwareLevelLimited ( ) { return getHardwareLevelChecked ( ) = = CameraMetadata . INFO _ SUPPORTED _ HARDWARE _ LEVEL _ LIMITED ; } 
1755	public boolean setCompressedThumbnail ( byte [ ] thumb ) { mData . clearThumbnailAndStrips ( ) ; mData . setCompressedThumbnail ( thumb ) ; return true ; } 
1756	public void setTextColor ( int textColor ) { textPaint . setColor ( textColor ) ; if ( ! attachedToWindow ) return ; updateBackgroundBitmap ( ) ; invalidate ( ) ; } 
1757	protected JoinAccumulator doLeftJoin ( JoinAccumulator probe , Map < Object , ArrayList < Tuple > > buildInput , JoinInfo joinInfo , boolean finalJoin ) { String [ ] probeKeyName = joinInfo . getOtherField ( ) ; JoinAccumulator result = new JoinAccumulator ( ) ; FieldSelector fieldSelector = new FieldSelector ( joinInfo . other . getStreamName ( ) , probeKeyName ) ; for ( ResultRecord rec : probe . getRecords ( ) ) { Object probeKey = rec . getField ( fieldSelector ) ; if ( probeKey ! = null ) { ok if its return null ArrayList < Tuple > matchingBuildRecs = buildInput . get ( probeKey ) ; if ( matchingBuildRecs ! = null & & ! matchingBuildRecs . isEmpty ( ) ) { for ( Tuple matchingRec : matchingBuildRecs ) { ResultRecord mergedRecord = new ResultRecord ( rec , matchingRec , finalJoin ) ; result . insert ( mergedRecord ) ; } } else { ResultRecord mergedRecord = new ResultRecord ( rec , null , finalJoin ) ; result . insert ( mergedRecord ) ; } } } return result ; } 
1758	public static long sizeof ( final Object obj ) { if ( null = = obj | | isSharedFlyweight ( obj ) ) { return _NUM ; } final IdentityHashMap visited = new IdentityHashMap ( _NUM _NUM _NUM _NUM _NUM ) ; try { return computeSizeof ( obj , visited , CLASS _ METADATA _ CACHE ) ; } catch ( RuntimeException re ) { re . printStackTrace ( ) ; return - _NUM ; } catch ( NoClassDefFoundError ncdfe ) { System . err . println ( ncdfe ) ; return - _NUM ; } } 
1759	public void testLimitSumUngroupedAggregation ( ) throws Exception { String tablename = generateUniqueName ( ) ; String tenantId = getOrganizationId ( ) ; No count ( _NUM ) aggregation , so it will get added automatically LIMIT has no effect , since it ' s applied at the end and we ' ll always have a single row for ungrouped aggregation String query = _STR ; Properties props = PropertiesUtil . deepCopy ( TEST _ PROPERTIES ) ; Connection conn = DriverManager . getConnection ( getUrl ( ) , props ) ; try { initTableValues ( tablename , tenantId , getSplits ( tenantId ) ) ; PreparedStatement statement = conn . prepareStatement ( query ) ; statement . setString ( _NUM , tenantId ) ; ResultSet rs = statement . executeQuery ( ) ; assertTrue ( rs . next ( ) ) ; assertEquals ( _NUM _NUM _NUM , rs . getInt ( _NUM ) ) ; assertEquals ( BigDecimal . valueOf ( _NUM _NUM . _NUM ) , rs . getBigDecimal ( _NUM ) ) ; assertEquals ( _NUM _NUM _NUM _NUM L , rs . getLong ( _NUM ) ) ; assertEquals ( BigDecimal . valueOf ( _NUM . _NUM ) , rs . getBigDecimal ( _NUM ) ) ; assertEquals ( _NUM , rs . getLong ( _NUM ) ) ; assertEquals ( true , rs . wasNull ( ) ) ; assertFalse ( rs . next ( ) ) ; } finally { conn . close ( ) ; } } 
1760	public Object getVariable ( String variableName , boolean fetchAllVariables ) { Object value = null ; VariableInstance variable = getVariableInstance ( variableName , fetchAllVariables ) ; if ( variable ! = null ) { value = variable . getValue ( ) ; } return value ; } 
1761	public void loop ( ) { long currentTimeMillis = mClock . now ( ) ; if ( mLastTimeMillis = = - _NUM ) { mLastTimeMillis = currentTimeMillis - _NUM ; } long ellapsedMillis = currentTimeMillis - mLastTimeMillis ; mLastTimeMillis = currentTimeMillis ; for ( SpringSystemListener listener : mListeners ) { listener . onBeforeIntegrate ( this ) ; } advance ( currentTimeMillis , ellapsedMillis ) ; synchronized ( this ) { if ( mActiveSprings . isEmpty ( ) ) { mIdle = true ; mLastTimeMillis = - _NUM ; } } for ( SpringSystemListener listener : mListeners ) { listener . onAfterIntegrate ( this ) ; } if ( mIdle ) { mSpringLooper . stop ( ) ; } } 
1762	protected < T extends Entity > Response withWriteLock ( final NiFiServiceFacade serviceFacade , final T entity , final AuthorizeAccess authorizer , final Runnable verifier , final Function < T , Response > action ) { if ( isTwoPhaseRequest ( httpServletRequest ) ) { if ( isValidationPhase ( httpServletRequest ) ) { authorize access serviceFacade . authorizeAccess ( authorizer ) ; verify if necessary if ( verifier ! = null ) { verifier . run ( ) ; } store the request phaseOneStoreTransaction ( entity , null , null ) ; return generateContinueResponse ( ) . build ( ) ; } else if ( isExecutionPhase ( httpServletRequest ) ) { get the original request and run the action final Request < T > phaseOneRequest = phaseTwoVerifyTransaction ( ) ; return action . apply ( phaseOneRequest . getRequest ( ) ) ; } else if ( isCancellationPhase ( httpServletRequest ) ) { cancelTransaction ( ) ; return generateOkResponse ( ) . build ( ) ; } else { throw new IllegalStateException ( _STR ) ; } } else { authorize access serviceFacade . authorizeAccess ( authorizer ) ; verify if necessary if ( verifier ! = null ) { verifier . run ( ) ; } run the action return action . apply ( entity ) ; } } 
1763	public double getAnnotationY ( int index ) { return mStringXY . getYByIndex ( index ) ; } 
1764	public static void visit ( String page , String referer ) { instance . visitPage ( page , referer ) ; } 
1765	public TBigDecimal setScale ( int newScale , TRoundingMode roundingMode ) { if ( roundingMode = = null ) { throw new NullPointerException ( ) ; } long diffScale = newScale - ( long ) scale ; Let be : ' this ' = [ u , s ] if ( diffScale = = _NUM ) { return this ; } if ( diffScale > _NUM ) { return [ u * _NUM _NUM ^ ( s _NUM - s ) , newScale ] if ( diffScale < LONG _ TEN _ POW . length & & ( this . bitLength + LONG _ TEN _ POW _ BIT _ LENGTH [ ( int ) diffScale ] ) < _NUM _NUM ) { return valueOf ( this . smallValue * LONG _ TEN _ POW [ ( int ) diffScale ] , newScale ) ; } return new TBigDecimal ( TMultiplication . multiplyByTenPow ( getUnscaledValue ( ) , ( int ) diffScale ) , newScale ) ; } return [ u , s ] / [ _NUM , newScale ] with the appropriate scale and rounding if ( this . bitLength < _NUM _NUM & & - diffScale < LONG _ TEN _ POW . length ) { return dividePrimitiveLongs ( this . smallValue , LONG _ TEN _ POW [ ( int ) - diffScale ] , newScale , roundingMode ) ; } return divideBigIntegers ( this . getUnscaledValue ( ) , TMultiplication . powerOf _NUM _NUM ( - diffScale ) , newScale , roundingMode ) ; } 
1766	public static boolean toBoolean ( Object obj , boolean defaultValue ) { if ( obj = = null ) { return defaultValue ; } if ( obj instanceof Boolean ) { return ( ( Boolean ) obj ) . booleanValue ( ) ; } else if ( obj instanceof Number | | obj . getClass ( ) . isPrimitive ( ) ) { int value = toInt ( obj ) ; return value ! = _NUM ? true : false ; } else if ( obj instanceof String | | obj instanceof CharSequence ) { String str = Conversions . toString ( obj ) ; if ( str . length ( ) = = _NUM ) { return false ; } if ( str . equals ( _STR ) ) { return false ; } else { return true ; } } else if ( Boon . isArray ( obj ) ) { return Boon . len ( obj ) > _NUM ; } else if ( obj instanceof Collection ) { if ( len ( obj ) > _NUM ) { List list = Lists . list ( ( Collection ) obj ) ; while ( list . remove ( null ) ) { } return Lists . len ( list ) > _NUM ; } else { return false ; } } else { return toBoolean ( Conversions . toString ( obj ) ) ; } } 
1767	private double evaluateImprovement ( CandidateInfo < Unit > candidate , double optTokenOwnership , double newUnitMult ) { double tokenChange = _NUM ; UnitInfo < Unit > candidateUnit = candidate . owningUnit ; Token candidateEnd = candidate . token ; Form a chain of units affected by the insertion to be able to qualify change of unit ownership . A unit may be affected more than once . UnitAdjustmentTracker < Unit > unitTracker = new UnitAdjustmentTracker < > ( candidateUnit ) ; Reflect change in ownership of the splitting token ( candidate ) . tokenChange + = applyOwnershipAdjustment ( candidate , candidateUnit , candidate . replicationStart , candidateEnd , optTokenOwnership , unitTracker ) ; Loop through all vnodes that replicate candidate or split and update their ownership . ReplicationVisitor replicationVisitor = new ReplicationVisitor ( ) ; for ( TokenInfo < Unit > curr = candidate . split ; ! replicationVisitor . visitedAll ( ) ; curr = curr . next ) { UnitInfo < Unit > currUnit = curr . owningUnit ; if ( ! replicationVisitor . add ( currUnit . group ) ) If this group is already seen , the token cannot be affected . continue ; Token replicationEnd = curr . token ; Token replicationStart = findUpdatedReplicationStart ( curr , candidate ) ; tokenChange + = applyOwnershipAdjustment ( curr , currUnit , replicationStart , replicationEnd , optTokenOwnership , unitTracker ) ; } replicationVisitor . clean ( ) ; double nodeChange = unitTracker . calculateUnitChange ( newUnitMult , optTokenOwnership ) ; return - ( tokenChange + nodeChange ) ; } 
1768	public final byte [ ] atom ( final int pre ) { switch ( kind ( pre ) ) { case TEXT : case COMM : return text ( pre , true ) ; case ATTR : return text ( pre , false ) ; case PI : byte [ ] txt = text ( pre , true ) ; final int i = indexOf ( txt , ' ' ) ; return i = = - _NUM ? EMPTY : substring ( txt , i + _NUM ) ; default : create atomized text node TokenBuilder tb = null ; byte [ ] t = EMPTY ; int p = pre ; final int s = p + size ( p , kind ( p ) ) ; while ( p < s ) { final int k = kind ( p ) ; if ( k = = TEXT ) { txt = text ( p , true ) ; if ( t = = EMPTY ) { t = txt ; } else { if ( tb = = null ) tb = new TokenBuilder ( t ) ; tb . add ( txt ) ; } } p + = attSize ( p , k ) ; } return tb = = null ? t : tb . finish ( ) ; } } 
1769	public boolean readBoolean ( ) throws IOException { int tag = read ( ) ; switch ( tag ) { case ' T ' : return true ; case ' F ' : return false ; case ' I ' : return parseInt ( ) = = _NUM ; case ' L ' : return parseLong ( ) = = _NUM ; case ' D ' : return parseDouble ( ) = = _NUM . _NUM ; case ' N ' : return false ; default : throw expect ( _STR , tag ) ; } } 
1770	public static String encodeBytes ( byte [ ] source , int off , int len , int options ) throws java . io . IOException { byte [ ] encoded = encodeBytesToBytes ( source , off , len , options ) ; Return value according to relevant encoding . try { return new String ( encoded , PREFERRED _ ENCODING ) ; } end try catch ( java . io . UnsupportedEncodingException uue ) { return new String ( encoded ) ; } end catch } 
1771	public void setInitialRotation ( float initialRotation ) { float old _ rot = rotationRadians - this . initialRotation ; this . initialRotation = initialRotation ; setRotation ( old _ rot ) ; } 
1772	protected void pushAttrib ( PdfDictionary dict ) { PdfDictionary dic = null ; if ( ! stack . isEmpty ( ) ) { dic = ( PdfDictionary ) stack . get ( stack . size ( ) - _NUM ) ; } dic = mergeAttrib ( dic , dict ) ; stack . add ( dic ) ; } 
1773	public Var copy ( final Var var , final IntObjMap < Var > vm ) { if ( var = = null ) return null ; final VarScope vs = vs ( ) ; final Var vr = vs . add ( new Var ( var , qc , vs . sc ) ) ; if ( vm ! = null ) vm . put ( var . id , vr ) ; return vr ; } 
1774	public String contextMenu ( ) { get the resource path list List < String > resourceList = CmsStringUtil . splitAsList ( getParamResourcelist ( ) , _STR ) ; return menu . toString ( ) ; } 
1775	public String getHash ( String clusterName , String hostName ) { ConcurrentMap < String , String > clusterMapping = m _ hashes . get ( hostName ) ; if ( null = = clusterMapping ) { clusterMapping = new ConcurrentHashMap < > ( ) ; ConcurrentMap < String , String > temp = m _ hashes . putIfAbsent ( hostName , clusterMapping ) ; if ( temp ! = null ) { clusterMapping = temp ; } } String hash = clusterMapping . get ( hostName ) ; if ( null ! = hash ) { return hash ; } hash = hash ( clusterName , hostName ) ; clusterMapping . put ( clusterName , hash ) ; return hash ; } 
1776	public static boolean isNegativeInteger ( String s ) { if ( isEmpty ( s ) ) return defaultEmptyOK ; try { int temp = Integer . parseInt ( s ) ; if ( temp < _NUM ) return true ; return false ; } catch ( Exception e ) { return false ; } } 
1777	public static boolean isValidClassLoaderName ( String name ) { This method is used to parse package data and does not accept null names . return name ! = null & & ( isPathClassLoaderName ( name ) | | isDelegateLastClassLoaderName ( name ) ) ; } 
1778	protected static String getTokenClass ( JobContext context ) { return getAuthenticationToken ( context ) . getClass ( ) . getName ( ) ; } 
1779	public boolean removeAnnotation ( CategoryAnnotation annotation , boolean notify ) { if ( annotation = = null ) { throw new IllegalArgumentException ( _STR ) ; } boolean removed = this . annotations . remove ( annotation ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } return removed ; } 
1780	public long normalize ( boolean ignoreDst ) { calculator . copyFieldsFromTime ( this ) ; long timeInMillis = calculator . toMillis ( ignoreDst ) ; calculator . copyFieldsToTime ( this ) ; return timeInMillis ; } 
1781	public boolean [ ] getAsBooleanArray ( final String path ) throws IllegalArgumentException { final List jarr = _ internalGetAsArray ( path ) ; final boolean [ ] arr = new boolean [ jarr = = null ? _NUM : jarr . size ( ) ] ; int alen = arr . length ; for ( int i = _NUM ; i < alen ; i + + ) { StructuredContent element = ( StructuredContent ) jarr . get ( i ) ; String s = ( String ) element . getText ( ) ; boolean b = false ; if ( _STR . equals ( s ) ) { b = true ; } arr [ i ] = b ; } return arr ; } 
1782	public COSStream getStream ( ) throws IOException { stream . setItem ( COSName . TYPE , COSName . XREF ) ; if ( size = = - _NUM ) { throw new IllegalArgumentException ( _STR if ( COSName . ROOT . equals ( cosName ) | | COSName . INFO . equals ( cosName ) | | COSName . PREV . equals ( cosName ) ) { continue ; } this one too , because it has already been written in COSWriter . doWriteBody ( ) if ( COSName . ENCRYPT . equals ( cosName ) ) { continue ; } COSBase dictionaryObject = this . stream . getDictionaryObject ( cosName ) ; dictionaryObject . setDirect ( true ) ; } return this . stream ; } 
1783	protected WOTSPlusPublicKeyParameters getPublicKeyFromSignature ( byte [ ] messageDigest , WOTSPlusSignature signature , OTSHashAddress otsHashAddress ) { if ( messageDigest = = null ) { throw new NullPointerException ( _STR ) ; } List < Integer > baseWMessage = convertToBaseW ( messageDigest , params . getWinternitzParameter ( ) , params . getLen _NUM ( ) ) ; int checksum = _NUM ; for ( int i = _NUM ; i < params . getLen _NUM ( ) ; i + + ) { checksum + = params . getWinternitzParameter ( ) - _NUM - baseWMessage . get ( i ) ; } checksum < < = ( _NUM - ( ( params . getLen _NUM ( ) * XMSSUtil . log _NUM ( params . getWinternitzParameter ( ) ) ) % _NUM ) ) ; int len _NUM Bytes = ( int ) Math . ceil ( ( double ) ( params . getLen _NUM ( ) * XMSSUtil . log _NUM ( params . getWinternitzParameter ( ) ) ) / _NUM ) ; List < Integer > baseWChecksum = convertToBaseW ( XMSSUtil . toBytesBigEndian ( checksum , len _NUM Bytes ) , params . getWinternitzParameter ( ) , params . getLen _NUM ( ) ) ; baseWMessage . addAll ( baseWChecksum ) ; byte [ ] [ ] publicKey = new byte [ params . getLen ( ) ] [ ] ; for ( int i = _NUM ; i < params . getLen ( ) ; i + + ) { otsHashAddress = ( OTSHashAddress ) new OTSHashAddress . Builder ( ) . withLayerAddress ( otsHashAddress . getLayerAddress ( ) ) . withTreeAddress ( otsHashAddress . getTreeAddress ( ) ) . withOTSAddress ( otsHashAddress . getOTSAddress ( ) ) . withChainAddress ( i ) . withHashAddress ( otsHashAddress . getHashAddress ( ) ) . withKeyAndMask ( otsHashAddress . getKeyAndMask ( ) ) . build ( ) ; publicKey [ i ] = chain ( signature . toByteArray ( ) [ i ] , baseWMessage . get ( i ) , params . getWinternitzParameter ( ) - _NUM - baseWMessage . get ( i ) , otsHashAddress ) ; } return new WOTSPlusPublicKeyParameters ( params , publicKey ) ; } 
1784	public static boolean restoreBackup ( File checkpointDir , File backupDir ) throws IOException { if ( ! backupExists ( backupDir ) ) { return false ; } Serialization . deleteAllFiles ( checkpointDir , Log . EXCLUDES ) ; File [ ] backupFiles = backupDir . listFiles ( ) ; if ( backupFiles = = null ) { return false ; } else { for ( File backupFile : backupFiles ) { String fileName = backupFile . getName ( ) ; if ( ! fileName . equals ( BACKUP _ COMPLETE _ FILENAME ) & & ! fileName . equals ( Log . FILE _ LOCK ) ) { if ( fileName . endsWith ( COMPRESSED _ FILE _ EXTENSION ) ) { Serialization . decompressFile ( backupFile , new File ( checkpointDir , fileName . substring ( _NUM , fileName . lastIndexOf ( _STR ) ) ) ) ; } else { Serialization . copyFile ( backupFile , new File ( checkpointDir , fileName ) ) ; } } } return true ; } } 
1785	String internalsprintf ( long s ) throws CmsIllegalArgumentException { String s _NUM = _STR , new Character ( m _ conversionCharacter ) ) ) ; } return s _NUM ; } 
1786	 @ PUT @ Consumes ( MediaType . APPLICATION _ JSON ) @ Produces ( MediaType . APPLICATION _ JSON ) @ Path ( _STR , ex ) ; throw new ServiceFormattedException ( ex . getMessage ( ) , ex ) ; } return readLatestConfiguration ( ) ; } 
1787	public void setPieRotation ( int rotation ) { mPieRotation = ( rotation % _NUM _NUM _NUM + _NUM _NUM _NUM ) % _NUM _NUM _NUM ; mGraph . rotateTo ( mPieRotation ) ; calcCurrentItem ( ) ; } 
1788	public ASN _NUM Primitive toASN _NUM Primitive ( ) { try { return getLoadedObject ( ) ; } catch ( IOException e ) { throw new ASN _NUM ParsingException ( e . getMessage ( ) , e ) ; } } 
1789	public boolean bodyCall ( Node [ ] args , int length , RuleContext context ) { checkArgs ( length , context ) ; BindingEnvironment env = context . getEnv ( ) ; Node n _NUM = getArg ( _NUM , args , context ) ; Node n _NUM = getArg ( _NUM , args , context ) ; if ( n _NUM . isLiteral ( ) & & n _NUM . isLiteral ( ) ) { Object v _NUM = n _NUM . getLiteralValue ( ) ; Object v _NUM = n _NUM . getLiteralValue ( ) ; Node sum = null ; if ( v _NUM instanceof Number & & v _NUM instanceof Number ) { Number nv _NUM = ( Number ) v _NUM ; Number nv _NUM = ( Number ) v _NUM ; if ( v _NUM instanceof Float | | v _NUM instanceof Double | | v _NUM instanceof Float | | v _NUM instanceof Double ) { sum = Util . makeDoubleNode ( nv _NUM . doubleValue ( ) / nv _NUM . doubleValue ( ) ) ; } else { sum = Util . makeLongNode ( nv _NUM . longValue ( ) / nv _NUM . longValue ( ) ) ; } return env . bind ( args [ _NUM ] , sum ) ; } } Doesn ' t ( yet ) handle partially bound cases return false ; } 
1790	private void stats ( ) { long nowMsSinceEpoch = now ( ) ; if ( lastLogTimestampMsSinceEpoch < _NUM ) { lastLogTimestampMsSinceEpoch = nowMsSinceEpoch ; return ; } long deltaMs = nowMsSinceEpoch - lastLogTimestampMsSinceEpoch ; if ( deltaMs < LOG _ PERIOD . getMillis ( ) ) { return ; } String messageSkew = _STR , subscription , numReceived , notYetRead . size ( ) , notYetReadBytes , inFlight . size ( ) , oldestInFlight , numInFlightCheckpoints . get ( ) , maxInFlightCheckpoints , numReadBytes . get ( nowMsSinceEpoch ) / ( SAMPLE _ PERIOD . getMillis ( ) / _NUM _NUM _NUM _NUM L ) , numReceivedRecently . get ( nowMsSinceEpoch ) , numExtendedDeadlines . get ( nowMsSinceEpoch ) , numLateDeadlines . get ( nowMsSinceEpoch ) , numAcked . get ( nowMsSinceEpoch ) , numNacked . get ( nowMsSinceEpoch ) , numExpired . get ( nowMsSinceEpoch ) , messageSkew , watermarkSkew , numLateMessages . get ( nowMsSinceEpoch ) , new Instant ( lastWatermarkMsSinceEpoch ) ) ; lastLogTimestampMsSinceEpoch = nowMsSinceEpoch ; } 
1791	public void replaceChild ( Text newChild , Node oldChild ) throws DOMException { replaceChild _ ( newChild , oldChild ) ; notifyObservers ( ) ; } 
1792	public void setSpanCount ( int spanCount ) { assertNotInLayoutOrScroll ( null ) ; if ( spanCount ! = mSpanCount ) { invalidateSpanAssignments ( ) ; mSpanCount = spanCount ; mRemainingSpans = new BitSet ( mSpanCount ) ; mSpans = new Span [ mSpanCount ] ; for ( int i = _NUM ; i < mSpanCount ; i + + ) { mSpans [ i ] = new Span ( i ) ; } requestLayout ( ) ; } } 
1793	public int getWaiting ( ) { if ( ! hasWaiters ( ) ) return _NUM ; Iterator < RegisteredSignal > iter = queue . iterator ( ) ; int count = _NUM ; while ( iter . hasNext ( ) ) { Signal next = iter . next ( ) ; if ( ! next . isCancelled ( ) ) count + + ; } return count ; } 
1794	private void doTestFileWithSpecifiedLines ( final int lineCount ) throws IOException { final String encoding = _STR ) ; } catch ( final NoSuchElementException expected ) { ignore , expected result } } finally { LineIterator . closeQuietly ( iterator ) ; } } 
1795	private void input ( ) throws QueryException { skipWs ( ) ; boolean f = false ; for ( final String d : DAYS ) { if ( consume ( d ) ) { f = true ; break ; } } consume ( ' , ' ) ; if ( f & & ! skipWs ( ) ) throw error ( _STR ) ; } 
1796	public boolean isMysterious ( int cellID , int signalStrength ) { If moving , return false if ( deviceIsMoving ( ) ) { log . info ( _STR + signalStrength ) ; return result ; } 
1797	protected TrapSecurity getSecurityLevel ( Map < String , String > dispatchProperties ) throws InvalidSnmpConfigurationException { String securityLevel = getDispatchProperty ( dispatchProperties , SECURITY _ LEVEL _ PROPERTY ) ; try { return TrapSecurity . valueOf ( securityLevel ) ; } catch ( IllegalArgumentException ex ) { String errorMessage = String . format ( _STR , securityLevel , SECURITY _ LEVEL _ PROPERTY , Arrays . toString ( TrapSecurity . values ( ) ) ) ; throw new InvalidSnmpConfigurationException ( errorMessage ) ; } } 
1798	public static Query transform ( Query query , ElementTransform transform , ExprTransform exprTransform ) { Query q _NUM = QueryTransformOps . shallowCopy ( query ) ; _STR transformVarExprList ( q _NUM . getProject ( ) , exprTransform ) ; transformVarExprList ( q _NUM . getGroupBy ( ) , exprTransform ) ; transformExprList ( q _NUM . getHavingExprs ( ) , exprTransform ) ; if ( q _NUM . getOrderBy ( ) ! = null ) { transformSortConditions ( q _NUM . getOrderBy ( ) , exprTransform ) ; } ? ? DOES NOT WORK : transformExprListAgg ( q _NUM . getAggregators ( ) , exprTransform ) ; ? ? if ( q _NUM . hasHaving ( ) ) { } if ( q _NUM . hasAggregators ( ) ) { } Element el = q _NUM . getQueryPattern ( ) ; Element el _NUM = ElementTransformer . transform ( el , transform , exprTransform ) ; Top level is always a group . if ( ! ( el _NUM instanceof ElementGroup ) ) { ElementGroup eg = new ElementGroup ( ) ; eg . addElement ( el _NUM ) ; el _NUM = eg ; } q _NUM . setQueryPattern ( el _NUM ) ; return q _NUM ; } 
1799	public static XmlNCName parse ( org . apache . xmlbeans . xml . stream . XMLInputStream xis ) throws org . apache . xmlbeans . XmlException , org . apache . xmlbeans . xml . stream . XMLStreamException { return ( XmlNCName ) XmlBeans . getContextTypeLoader ( ) . parse ( xis , type , null ) ; } 
1800	public void addOnUidImportanceListener ( OnUidImportanceListener listener , @ RunningAppProcessInfo . Importance int importanceCutpoint ) { synchronized ( this ) { if ( mImportanceListeners . containsKey ( listener ) ) { throw new IllegalArgumentException ( _STR + listener ) ; } TODO : implement the cut point in the system process to avoid IPCs . UidObserver observer = new UidObserver ( listener , mContext ) ; try { getService ( ) . registerUidObserver ( observer , UID _ OBSERVER _ PROCSTATE | UID _ OBSERVER _ GONE , RunningAppProcessInfo . importanceToProcState ( importanceCutpoint ) , mContext . getOpPackageName ( ) ) ; } catch ( RemoteException e ) { throw e . rethrowFromSystemServer ( ) ; } mImportanceListeners . put ( listener , observer ) ; } } 
1801	public static void finish ( IndentedWriter out , String tag ) { _ finish ( out , tag , Tags . RPAREN ) ; } 
1802	void add ( BackupOperation operation ) { operations . add ( operation ) ; maybeBackup ( ) ; } 
1803	public RelWriter collectExplainTerms ( String prefix , RelWriter pw , SqlExplainLevel level ) { final List < RelDataTypeField > inFields = inputRowType . getFieldList ( ) ; final List < RelDataTypeField > outFields = outputRowType . getFieldList ( ) ; assert outFields . size ( ) = = projects . size ( ) : _STR , condition ) ; } return pw ; } 
1804	private void release ( BitmapRegionDecoder decoder ) { if ( markAsUnused ( decoder ) ) { available . release ( ) ; } } 
1805	public void paintComponent ( Graphics g ) { if ( ! m _ HasCustomPanel ) { Insets i = getInsets ( ) ; Rectangle box = new Rectangle ( i . left , i . top , getSize ( ) . width - i . left - i . right - _NUM , getSize ( ) . height - i . top - i . bottom - _NUM ) ; g . clearRect ( i . left , i . top , getSize ( ) . width - i . right - i . left , getSize ( ) . height - i . bottom - i . top ) ; m _ Editor . paintValue ( g , box ) ; } } 
1806	public boolean tryPublish ( Object obj ) { if ( currentBatch . size ( ) > = batchSz ) { if ( ! tryFlush ( ) ) { return false ; } } currentBatch . add ( obj ) ; return true ; } 
1807	public void jumpToCurrentState ( ) { if ( mRunningAnimator ! = null ) { mRunningAnimator . end ( ) ; } } 
1808	private String loadXmlFromNetwork ( String urlString ) throws XmlPullParserException , IOException { InputStream stream = null ; StackOverflowXmlParser stackOverflowXmlParser = new StackOverflowXmlParser ( ) ; List < Entry > entries = null ; String title = null ; String url = null ; String summary = null ; Calendar rightNow = Calendar . getInstance ( ) ; DateFormat formatter = new SimpleDateFormat ( _STR ) ; adds it to the display . if ( pref ) { htmlString . append ( entry . summary ) ; } } return htmlString . toString ( ) ; } 
1809	public InputStream openNoMap ( String filenameOrURI ) { TypedStream in = openNoMapOrNull ( filenameOrURI ) ; if ( in = = null ) return null ; throw new NotFoundException ( filenameOrURI ) ; return in . getInput ( ) ; } 
1810	public boolean beginFakeDrag ( ) { if ( mIsBeingDragged ) { return false ; } mFakeDragging = true ; setScrollState ( SCROLL _ STATE _ DRAGGING ) ; mInitialMotionX = mLastMotionX = _NUM ; if ( mVelocityTracker = = null ) { mVelocityTracker = VelocityTracker . obtain ( ) ; } else { mVelocityTracker . clear ( ) ; } final long time = SystemClock . uptimeMillis ( ) ; final MotionEvent ev = MotionEvent . obtain ( time , time , MotionEvent . ACTION _ DOWN , _NUM , _NUM , _NUM ) ; mVelocityTracker . addMovement ( ev ) ; ev . recycle ( ) ; mFakeDragBeginTime = time ; return true ; } 
1811	public IO thesaurus ( final String path , final StaticContext sc ) { return thes ! = null ? thes . get ( path ) : sc . resolve ( path , null ) ; } 
1812	public void setRotate ( int axis , float degrees ) { reset ( ) ; double radians = degrees * Math . PI / _NUM _NUM _NUM d ; float cosine = ( float ) Math . cos ( radians ) ; float sine = ( float ) Math . sin ( radians ) ; switch ( axis ) { Rotation around the red color case _NUM : mArray [ _NUM ] = mArray [ _NUM _NUM ] = cosine ; mArray [ _NUM ] = sine ; mArray [ _NUM _NUM ] = - sine ; break ; Rotation around the green color case _NUM : mArray [ _NUM ] = mArray [ _NUM _NUM ] = cosine ; mArray [ _NUM ] = - sine ; mArray [ _NUM _NUM ] = sine ; break ; Rotation around the blue color case _NUM : mArray [ _NUM ] = mArray [ _NUM ] = cosine ; mArray [ _NUM ] = sine ; mArray [ _NUM ] = - sine ; break ; default : throw new RuntimeException ( ) ; } } 
1813	public void testSaml _NUM StaticEndpointClaims ( ) throws Exception { TokenProvider samlTokenProvider = new SAMLTokenProvider ( ) ; TokenProviderParameters providerParameters = createProviderParameters ( WSS _NUM JConstants . WSS _ SAML _NUM _ TOKEN _ TYPE , STSConstants . BEARER _ KEY _ KEYTYPE , null ) ; ClaimsManager claimsManager = new ClaimsManager ( ) ; StaticEndpointClaimsHandler claimsHandler = new StaticEndpointClaimsHandler ( ) ; Create claims map for specific application Map < String , String > endpointClaimsMap = new HashMap < > ( ) ; endpointClaimsMap . put ( CLAIM _ APPLICATION . toString ( ) , CLAIM _ APPLICATION _ VALUE ) ; Map < String , Map < String , String > > staticClaims = new HashMap < > ( ) ; staticClaims . put ( APPLICATION _ APPLIES _ TO , endpointClaimsMap ) ; claimsHandler . setEndpointClaims ( staticClaims ) ; List < URI > supportedClaims = new ArrayList < > ( ) ; supportedClaims . add ( CLAIM _ APPLICATION ) ; claimsHandler . setSupportedClaims ( supportedClaims ) ; claimsManager . setClaimHandlers ( Collections . singletonList ( ( ClaimsHandler ) claimsHandler ) ) ; providerParameters . setClaimsManager ( claimsManager ) ; ClaimCollection claims = new ClaimCollection ( ) ; Claim claim = new Claim ( ) ; claim . setClaimType ( CLAIM _ APPLICATION ) ; claims . add ( claim ) ; providerParameters . setRequestedPrimaryClaims ( claims ) ; assertTrue ( samlTokenProvider . canHandleToken ( WSS _NUM JConstants . WSS _ SAML _NUM _ TOKEN _ TYPE ) ) ; TokenProviderResponse providerResponse = samlTokenProvider . createToken ( providerParameters ) ; assertTrue ( providerResponse ! = null ) ; assertTrue ( providerResponse . getToken ( ) ! = null & & providerResponse . getTokenId ( ) ! = null ) ; Element token = ( Element ) providerResponse . getToken ( ) ; String tokenString = DOM _NUM Writer . nodeToString ( token ) ; assertTrue ( tokenString . contains ( providerResponse . getTokenId ( ) ) ) ; assertTrue ( tokenString . contains ( _STR ) ) ; assertTrue ( tokenString . contains ( SAML _NUM Constants . CONF _ BEARER ) ) ; SamlAssertionWrapper assertion = new SamlAssertionWrapper ( token ) ; List < Attribute > attributes = assertion . getSaml _NUM ( ) . getAttributeStatements ( ) . get ( _NUM ) . getAttributes ( ) ; assertEquals ( attributes . size ( ) , _NUM ) ; assertEquals ( attributes . get ( _NUM ) . getName ( ) , CLAIM _ APPLICATION . toString ( ) ) ; XMLObject valueObj = attributes . get ( _NUM ) . getAttributeValues ( ) . get ( _NUM ) ; assertEquals ( valueObj . getDOM ( ) . getTextContent ( ) , CLAIM _ APPLICATION _ VALUE ) ; } 
1814	public void putDoubleArray ( @ Nullable String key , @ Nullable double [ ] value ) { unparcel ( ) ; mMap . put ( key , value ) ; } 
1815	protected String getUnprocessedNameOfMatchingTab ( TabMetadata tabMetadata , Set < String > tabMetadataKeySet ) { for ( String tabKey : tabMetadataKeySet ) { String tabName = tabMetadata . getTabName ( ) ; if ( processedTabKeyMatchesTabName ( tabName , tabKey ) ) { return tabKey ; } } return null ; } 
1816	private void handleTableCell ( HTMLElement tdTag , int align ) { newLineIfNotEmpty ( align ) ; tableCells . addElement ( curContainer ) ; Container cell = new Container ( ) ; cell . getStyle ( ) . setBgTransparency ( _NUM ) ; cell . setLayout ( new BoxLayout ( BoxLayout . Y _ AXIS ) ) ; int border = _NUM ; HTMLElement trTag = ( HTMLElement ) tdTag . getParent ( ) ; while ( ( trTag ! = null ) & & ( trTag . getTagId ( ) ! = HTMLElement . TAG _ TR ) ) { Though in strict XHTML TR can only contain TD / TH - in some HTMLs TR doesn ' t have to be the direct parent of the tdTag , i . e . : < tr > < b > < td > . . . < / td > . . . < / b > < / tr > trTag = ( HTMLElement ) trTag . getParent ( ) ; } Commented since the table border should not affect cell border Constraint constraint = new Constraint ( ) ; CellConstraint constraint = new CellConstraint ( ) ; int halign = align ; int valign = Component . CENTER ; if ( trTag ! = null ) { HTMLElement tGroupTag = ( HTMLElement ) trTag . getParent ( ) ; int tagId = tGroupTag . getTagId ( ) ; if ( ( tagId = = HTMLElement . TAG _ TBODY ) | | ( tagId = = HTMLElement . TAG _ THEAD ) | | ( tagId = = HTMLElement . TAG _ TFOOT ) ) { Get the default TR alignment halign = getHorizAlign ( tGroupTag . getAttributeById ( HTMLElement . ATTR _ ALIGN ) , halign , false ) ; Get the default TR valignment valign = getVertAlign ( tGroupTag . getAttributeById ( HTMLElement . ATTR _ VALIGN ) , valign ) ; } Get the default TR alignment halign = getHorizAlign ( trTag . getAttributeById ( HTMLElement . ATTR _ ALIGN ) , halign , false ) ; Get the default TR valignment valign = getVertAlign ( trTag . getAttributeById ( HTMLElement . ATTR _ VALIGN ) , valign ) ; } halign = getHorizAlign ( tdTag . getAttributeById ( HTMLElement . ATTR _ ALIGN ) , halign , false ) ; valign = getVertAlign ( tdTag . getAttributeById ( HTMLElement . ATTR _ VALIGN ) , valign ) ; int colspan = getInt ( tdTag . getAttributeById ( HTMLElement . ATTR _ COLSPAN ) ) ; int rowspan = getInt ( tdTag . getAttributeById ( HTMLElement . ATTR _ ROWSPAN ) ) ; String cWidth = tdTag . getAttributeById ( HTMLElement . ATTR _ WIDTH ) ; int pW = getPercentage ( cWidth ) ; if ( ( pW > _NUM ) & & ( pW < _NUM _NUM _NUM ) ) { constraint . setWidthPercentage ( pW ) ; - Setting a width constraint currently makes the field width _NUM - needs to be fixed in TableLayout } else { pW = getInt ( cWidth ) ; if ( pW ! = _NUM ) { cell . setPreferredW ( pW ) ; } } String cHeight = tdTag . getAttributeById ( HTMLElement . ATTR _ HEIGHT ) ; int pH = getPercentage ( cHeight ) ; if ( ( pH > _NUM ) & & ( pH < _NUM _NUM _NUM ) ) { constraint . setHeightPercentage ( pH ) ; - Setting a height constraint currently makes the field height _NUM - needs to be fixed in TableLayout } else { pH = getInt ( cHeight ) ; if ( pH ! = _NUM ) { cell . setPreferredH ( pH ) ; } } constraint . setHorizontalAlign ( halign ) ; constraint . setVerticalAlign ( valign ) ; if ( colspan > _NUM ) { constraint . setHorizontalSpan ( colspan ) ; } if ( rowspan > _NUM ) { constraint . setVerticalSpan ( rowspan ) ; } curContainer = cell ; if ( curTable ! = null ) { curTable . addCell ( cell , ( tdTag . getTagId ( ) = = HTMLElement . TAG _ TH ) , constraint ) ; } if ( loadCSS ) { tdTag . setAssociatedComponents ( cell ) ; if ( trTag ! = null ) { trTag . addAssociatedComponent ( cell ) ; } } } 
1817	private Predicate processUserPredicate ( Predicate predicate ) { if ( predicate = = null ) { return null ; } ProcessingPredicateVisitor visitor = new ProcessingPredicateVisitor ( this ) ; PredicateHelper . visit ( predicate , visitor ) ; add the sub - resource to the request Set < String > categories = visitor . getSubResourceCategories ( ) ; for ( String category : categories ) { addPropertyToSubResource ( category , null ) ; } record the sub - resource properties on this query subResourcePredicateProperties . addAll ( visitor . getSubResourceProperties ( ) ) ; if ( hasSubResourcePredicate ( ) ) { for ( Map . Entry < String , QueryImpl > entry : requestedSubResources . entrySet ( ) ) { subResourcePredicate = getSubResourcePredicate ( predicate , entry . getKey ( ) ) ; entry . getValue ( ) . processUserPredicate ( subResourcePredicate ) ; } } processedPredicate = visitor . getProcessedPredicate ( ) ; return processedPredicate ; } 
1818	public void acceptClassifier ( IncrementalClassifierEvent e ) { weka . classifiers . Classifier classifier = e . getClassifier ( ) ; Instance currentI = e . getCurrentInstance ( ) ; int status = e . getStatus ( ) ; int oldNumAtts = _NUM ; if ( status = = IncrementalClassifierEvent . NEW _ BATCH ) { oldNumAtts = e . getStructure ( ) . numAttributes ( ) ; } else { oldNumAtts = currentI . dataset ( ) . numAttributes ( ) ; } if ( status = = IncrementalClassifierEvent . NEW _ BATCH ) { m _ instanceEvent = new InstanceEvent ( this , null , _NUM ) ; create new header structure Instances oldStructure = new Instances ( e . getStructure ( ) , _NUM ) ; String relationNameModifier = oldStructure . relationName ( ) + _STR ; if ( ! m _ appendProbabilities | | oldStructure . classAttribute ( ) . isNumeric ( ) ) { try { m _ format = makeDataSetClass ( oldStructure , oldStructure , classifier , relationNameModifier ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; return ; } } else if ( m _ appendProbabilities ) { try { m _ format = makeDataSetProbabilities ( oldStructure , oldStructure , classifier , relationNameModifier ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; return ; } } Pass on the structure m _ instanceEvent . setStructure ( m _ format ) ; notifyInstanceAvailable ( m _ instanceEvent ) ; return ; } double [ ] instanceVals = new double [ m _ format . numAttributes ( ) ] ; Instance newInst = null ; try { process the actual instance for ( int i = _NUM ; i < oldNumAtts ; i + + ) { instanceVals [ i ] = currentI . value ( i ) ; } if ( ! m _ appendProbabilities | | currentI . dataset ( ) . classAttribute ( ) . isNumeric ( ) ) { double predClass = classifier . classifyInstance ( currentI ) ; instanceVals [ instanceVals . length - _NUM ] = predClass ; } else if ( m _ appendProbabilities ) { double [ ] preds = classifier . distributionForInstance ( currentI ) ; for ( int i = oldNumAtts ; i < instanceVals . length ; i + + ) { instanceVals [ i ] = preds [ i - oldNumAtts ] ; } } } catch ( Exception ex ) { ex . printStackTrace ( ) ; return ; } finally { newInst = new DenseInstance ( currentI . weight ( ) , instanceVals ) ; newInst . setDataset ( m _ format ) ; m _ instanceEvent . setInstance ( newInst ) ; m _ instanceEvent . setStatus ( status ) ; notify listeners notifyInstanceAvailable ( m _ instanceEvent ) ; } if ( status = = IncrementalClassifierEvent . BATCH _ FINISHED ) { clean up m _ incrementalStructure = null ; m _ instanceEvent = null ; } } 
1819	public void testCopyableFileGenerator ( ) { Properties props = new Properties ( ) ; props . put ( TimestampBasedCopyableDataset . COPY _ POLICY , TimeBasedCopyPolicyForTest . class . getName ( ) ) ; props . put ( TimestampBasedCopyableDataset . DATASET _ VERSION _ FINDER , TimestampedDatasetVersionFinderForTest . class . getName ( ) ) ; TimestampBasedCopyableDataset copyabledataset = new TimestampBasedCopyableDataset ( localFs , props , new Path ( _STR ) ) ; TimestampBasedCopyableDataset . CopyableFileGenerator emptyGenerator = copyabledataset . getCopyableFileGenetator ( localFs , configuration , emptyVersion , copyableFileList ) ; emptyGenerator . run ( ) ; Assert . assertEquals ( copyableFileList . size ( ) , _NUM ) ; The src path is null . TimestampedDatasetVersion versionHasNullPath = new TimestampedDatasetVersion ( new DateTime ( ) , null ) ; TimestampBasedCopyableDataset . CopyableFileGenerator exceptionGenerator = copyabledataset . getCopyableFileGenetator ( localFs , configuration , versionHasNullPath , copyableFileList ) ; exceptionGenerator . run ( ) ; } 
1820	private final void updateTelephony ( ) { if ( DEBUG ) { Log . d ( mTag , _STR + mSignalStrength ) ; } mCurrentState . connected = hasService ( ) & & mSignalStrength ! = null ; if ( mCurrentState . connected ) { if ( ! mSignalStrength . isGsm ( ) & & mConfig . alwaysShowCdmaRssi ) { mCurrentState . level = mSignalStrength . getCdmaLevel ( ) ; } else { mCurrentState . level = mSignalStrength . getLevel ( ) ; } } if ( mNetworkToIconLookup . indexOfKey ( mDataNetType ) > = _NUM ) { mCurrentState . iconGroup = mNetworkToIconLookup . get ( mDataNetType ) ; } else { mCurrentState . iconGroup = mDefaultIcons ; } mCurrentState . dataConnected = mCurrentState . connected & & mDataState = = TelephonyManager . DATA _ CONNECTED ; mCurrentState . roaming = isRoaming ( ) ; if ( isCarrierNetworkChangeActive ( ) ) { mCurrentState . iconGroup = TelephonyIcons . CARRIER _ NETWORK _ CHANGE ; } else if ( isDataDisabled ( ) & & ! mConfig . alwaysShowDataRatIcon ) { mCurrentState . iconGroup = TelephonyIcons . DATA _ DISABLED ; } if ( isEmergencyOnly ( ) ! = mCurrentState . isEmergency ) { mCurrentState . isEmergency = isEmergencyOnly ( ) ; mNetworkController . recalculateEmergency ( ) ; } Fill in the network name if we think we have it . if ( mCurrentState . networkName = = mNetworkNameDefault & & mServiceState ! = null & & ! TextUtils . isEmpty ( mServiceState . getOperatorAlphaShort ( ) ) ) { mCurrentState . networkName = mServiceState . getOperatorAlphaShort ( ) ; } notifyListenersIfNecessary ( ) ; } 
1821	private static EnforcedAdmin checkForLockSetting ( Context context , @ UserIdInt int userId , LockSettingCheck check ) { final DevicePolicyManager dpm = ( DevicePolicyManager ) context . getSystemService ( Context . DEVICE _ POLICY _ SERVICE ) ; if ( dpm = = null ) { return null ; } final LockPatternUtils lockPatternUtils = new LockPatternUtils ( context ) ; EnforcedAdmin enforcedAdmin = null ; user that do not use a separate work challenge . for ( UserInfo userInfo : UserManager . get ( context ) . getProfiles ( userId ) ) { final List < ComponentName > admins = dpm . getActiveAdminsAsUser ( userInfo . id ) ; if ( admins = = null ) { continue ; } final boolean isSeparateProfileChallengeEnabled = sProxy . isSeparateProfileChallengeEnabled ( lockPatternUtils , userInfo . id ) ; for ( ComponentName admin : admins ) { if ( ! isSeparateProfileChallengeEnabled ) { if ( check . isEnforcing ( dpm , admin , userInfo . id ) ) { if ( enforcedAdmin = = null ) { enforcedAdmin = new EnforcedAdmin ( admin , userInfo . id ) ; } else { return EnforcedAdmin . MULTIPLE _ ENFORCED _ ADMIN ; } has set policy on the parent admin . continue ; } } if ( userInfo . isManagedProfile ( ) ) { If userInfo . id is a managed profile , we also need to look at the policies set on the parent . DevicePolicyManager parentDpm = sProxy . getParentProfileInstance ( dpm , userInfo ) ; if ( check . isEnforcing ( parentDpm , admin , userInfo . id ) ) { if ( enforcedAdmin = = null ) { enforcedAdmin = new EnforcedAdmin ( admin , userInfo . id ) ; } else { return EnforcedAdmin . MULTIPLE _ ENFORCED _ ADMIN ; } } } } } return enforcedAdmin ; } 
1822	public void testServerSideSAMLTokenCaching ( ) throws Exception { SpringBusFactory bf = new SpringBusFactory ( ) ; URL busFile = ServerCachingTest . class . getResource ( _STR ) ; } catch ( Exception ex ) { expected } Try again using the original SAML token - this should work as it should be cached by the service tok . setToken ( storedToken ) ; doubleIt ( port , _NUM _NUM ) ; ( ( java . io . Closeable ) port ) . close ( ) ; bus . shutdown ( true ) ; } 
1823	public void error ( String message , long line , long col ) { logError ( message , line , col ) ; throw new RiotException ( fmtMessage ( message , line , col ) ) ; } 
1824	public static String getDigestHashOldFunnyHexEncode ( String str , String hashType ) { return digestHashOldFunnyHex ( hashType , str ) ; } 
1825	public GutterIconInfo [ ] getBookmarks ( ) { List < GutterIconInfo > retVal = new ArrayList < GutterIconInfo > ( _NUM ) ; if ( trackingIcons ! = null ) { for ( int i = _NUM ; i < trackingIcons . size ( ) ; i + + ) { GutterIconImpl ti = getTrackingIcon ( i ) ; if ( ti . getIcon ( ) = = bookmarkIcon ) { retVal . add ( ti ) ; } } } GutterIconInfo [ ] array = new GutterIconInfo [ retVal . size ( ) ] ; return retVal . toArray ( array ) ; } 
1826	public String getLexicalForm ( ) { if ( lexicalForm = = null ) lexicalForm = ( dtype = = null ? value . toString ( ) : dtype . unparse ( value ) ) ; return lexicalForm ; } 
1827	public static SmsMessage createFromEfRecord ( int index , byte [ ] data ) { SmsMessageBase wrappedMessage ; if ( isCdmaVoice ( ) ) { wrappedMessage = com . android . internal . telephony . cdma . SmsMessage . createFromEfRecord ( index , data ) ; } else { wrappedMessage = com . android . internal . telephony . gsm . SmsMessage . createFromEfRecord ( index , data ) ; } if ( wrappedMessage ! = null ) { return new SmsMessage ( wrappedMessage ) ; } else { Rlog . e ( LOG _ TAG , _STR ) ; return null ; } } 
1828	public void setConnectionId ( int connectionId ) { enforceNotSealed ( ) ; mConnectionId = connectionId ; } 
1829	public static boolean isEncodedValue ( PositionedByteRange src ) { return isNull ( src ) | | isNumeric ( src ) | | isFixedInt _NUM ( src ) | | isFixedInt _NUM _NUM ( src ) | | isFixedInt _NUM _NUM ( src ) | | isFixedInt _NUM _NUM ( src ) | | isFixedFloat _NUM _NUM ( src ) | | isFixedFloat _NUM _NUM ( src ) | | isText ( src ) | | isBlobCopy ( src ) | | isBlobVar ( src ) ; } 
1830	private void buildViewForMeasuring ( ) { clear all items if ( itemsLayout ! = null ) { recycle . recycleItems ( itemsLayout , firstItem , new ItemsRange ( ) ) ; } else { createItemsLayout ( ) ; } add views int addItems = visibleItems / _NUM ; for ( int i = currentItem + addItems ; i > = currentItem - addItems ; i - - ) { if ( addViewItem ( i , true ) ) { firstItem = i ; } } } 
1831	public final E _ StrSubstring substr ( Object src , Object loc ) { return new E _ StrSubstring ( asExpr ( src ) , asExpr ( loc ) , null ) ; } 
1832	public void setScope ( String scope ) { if ( CmsStringUtil . isNotEmpty ( scope ) ) { scope = scope . trim ( ) . toLowerCase ( ) ; m _ scope = getScopeAsInt ( scope ) ; } else { empty scope , use default _STR scope m _ scope = PageContext . PAGE _ SCOPE ; } } 
1833	boolean notifyExtFocusPolicyFocusAbandon _ syncAf ( AudioFocusInfo afi ) { if ( mFocusPolicy = = null ) { return false ; } final FocusRequester fr = mFocusOwnersForFocusPolicy . remove ( afi . getClientId ( ) ) ; if ( fr ! = null ) { fr . release ( ) ; } try { oneway mFocusPolicy . notifyAudioFocusAbandon ( afi ) ; } catch ( RemoteException e ) { Log . e ( TAG , _STR + mFocusPolicy . asBinder ( ) , e ) ; } return true ; } 
1834	public void binderDied ( ) { synchronized ( mLock ) { Only do this once per service death if ( mCameraService = = null ) return ; mCameraService = null ; and torch statuses will be updated . for ( int i = _NUM ; i < mDeviceStatus . size ( ) ; i + + ) { String cameraId = mDeviceStatus . keyAt ( i ) ; onStatusChangedLocked ( ICameraServiceListener . STATUS _ NOT _ PRESENT , cameraId ) ; } for ( int i = _NUM ; i < mTorchStatus . size ( ) ; i + + ) { String cameraId = mTorchStatus . keyAt ( i ) ; onTorchStatusChangedLocked ( ICameraServiceListener . TORCH _ STATUS _ NOT _ AVAILABLE , cameraId ) ; } scheduleCameraServiceReconnectionLocked ( ) ; } } 
1835	public static RDD < String > matrixObjectToRDDStringIJV ( MatrixObject matrixObject ) { NOTE : The following works when called from Java but does not currently work when called from Spark Shell ( when you call collect ( ) on the RDD < String > ) . JavaRDD < String > javaRDD = jsc . parallelize ( list ) ; RDD < String > rdd = JavaRDD . toRDD ( javaRDD ) ; Therefore , we call parallelize ( ) on the SparkContext rather than the JavaSparkContext to produce the RDD < String > for Scala . List < String > list = matrixObjectToListStringIJV ( matrixObject ) ; ClassTag < String > tag = scala . reflect . ClassTag $ . MODULE $ . apply ( String . class ) ; return sc ( ) . parallelize ( JavaConversions . asScalaBuffer ( list ) , sc ( ) . defaultParallelism ( ) , tag ) ; } 
1836	public Set < RexNode > getExpressionLineage ( TableScan rel , RelMetadataQuery mq , RexNode outputExpression ) { final RexBuilder rexBuilder = rel . getCluster ( ) . getRexBuilder ( ) ; Extract input fields referenced by expression final Set < RelDataTypeField > inputExtraFields = new LinkedHashSet < > ( ) ; final RelOptUtil . InputFinder inputFinder = new RelOptUtil . InputFinder ( inputExtraFields ) ; outputExpression . accept ( inputFinder ) ; final ImmutableBitSet inputFieldsUsed = inputFinder . inputBitSet . build ( ) ; Infer column origin expressions for given references final Map < RexInputRef , Set < RexNode > > mapping = new LinkedHashMap < > ( ) ; for ( int idx : inputFieldsUsed ) { final RexNode inputRef = RexTableInputRef . of ( RelTableRef . of ( rel . getTable ( ) , _NUM ) , RexInputRef . of ( idx , rel . getRowType ( ) . getFieldList ( ) ) ) ; final Set < RexNode > originalExprs = Sets . newHashSet ( inputRef ) ; final RexInputRef ref = RexInputRef . of ( idx , rel . getRowType ( ) . getFieldList ( ) ) ; mapping . put ( ref , originalExprs ) ; } Return result return createAllPossibleExpressions ( rexBuilder , outputExpression , mapping ) ; } 
1837	public static Geom ST _ Buffer ( Geom geom , double bufferSize , String style ) { int quadSegCount = _NUM ; CapStyle endCapStyle = CapStyle . ROUND ; JoinStyle joinStyle = JoinStyle . ROUND ; float mitreLimit = _NUM f ; int i = _NUM ; parse : for ( ; ; ) { int equals = style . indexOf ( ' = ' , i ) ; if ( equals < _NUM ) { break ; } int space = style . indexOf ( ' ' , equals ) ; if ( space < _NUM ) { space = style . length ( ) ; } String name = style . substring ( i , equals ) ; String value = style . substring ( equals + _NUM , space ) ; switch ( name ) { case _STR : mitreLimit = Float . parseFloat ( value ) ; break ; default : } i = space ; for ( ; ; ) { if ( i > = style . length ( ) ) { break parse ; } if ( style . charAt ( i ) ! = ' ' ) { break ; } + + i ; } } return buffer ( geom , bufferSize , quadSegCount , endCapStyle , joinStyle , mitreLimit ) ; } 
1838	private int [ ] evaluateIntervalLiteralAsMonth ( RelDataTypeSystem typeSystem , int sign , String value , String originalValue , SqlParserPos pos ) { BigDecimal month ; validate as MONTH ( startPrecision ) , e . g . ' MM ' String intervalPattern = _STR ; Matcher m = Pattern . compile ( intervalPattern ) . matcher ( value ) ; if ( m . matches ( ) ) { Break out field values try { month = parseField ( m , _NUM ) ; } catch ( NumberFormatException e ) { throw invalidValueException ( pos , originalValue ) ; } Validate individual fields checkLeadFieldInRange ( typeSystem , sign , month , TimeUnit . MONTH , pos ) ; package values up for return return fillIntervalValueArray ( sign , ZERO , month ) ; } else { throw invalidValueException ( pos , originalValue ) ; } } 
1839	public java . util . List < org . apache . mina . generated . protoc . AddressBookProtos . Person . Builder > getPersonBuilderList ( ) { return getPersonFieldBuilder ( ) . getBuilderList ( ) ; } 
1840	private void processConfigurationsIfRequired ( UpgradeContext upgradeContext ) throws AmbariException { AmbariManagementController controller = m _ controllerProvider . get ( ) ; Cluster cluster = upgradeContext . getCluster ( ) ; Direction direction = upgradeContext . getDirection ( ) ; String userName = controller . getAuthName ( ) ; Set < String > servicesInUpgrade = upgradeContext . getSupportedServices ( ) ; Set < String > clusterConfigTypes = new HashSet < > ( ) ; Set < String > processedClusterConfigTypes = new HashSet < > ( ) ; Set < String > servicesWithUpdatedConfigs = new HashSet < > ( ) ; merge or revert configurations for any service that needs it for ( String serviceName : servicesInUpgrade ) { boolean configsChanged = false ; RepositoryVersionEntity sourceRepositoryVersion = upgradeContext . getSourceRepositoryVersion ( serviceName ) ; RepositoryVersionEntity targetRepositoryVersion = upgradeContext . getTargetRepositoryVersion ( serviceName ) ; StackId sourceStackId = sourceRepositoryVersion . getStackId ( ) ; StackId targetStackId = targetRepositoryVersion . getStackId ( ) ; only work with configurations when crossing stacks if ( sourceStackId . equals ( targetStackId ) ) { RepositoryVersionEntity associatedRepositoryVersion = upgradeContext . getRepositoryVersion ( ) ; LOG . info ( _STR , direction . getText ( true ) , direction . getPreposition ( ) , upgradeContext . getRepositoryVersion ( ) . getVersion ( ) ) ; configHelper . createConfigTypes ( cluster , targetStackId , controller , newServiceDefaultConfigsByType , userName , serviceVersionNote ) ; configsChanged = true ; } if ( configsChanged ) { servicesWithUpdatedConfigs . add ( serviceName ) ; } } if ( ! servicesWithUpdatedConfigs . isEmpty ( ) ) { m _ configHelperProvider . get ( ) . updateAgentConfigs ( Collections . singletonMap ( cluster . getClusterName ( ) , servicesWithUpdatedConfigs ) ) ; } } 
1841	public void putAll ( Map < ? extends K , ? extends V > map ) { ensureCapacity ( mSize + map . size ( ) ) ; for ( Map . Entry < ? extends K , ? extends V > entry : map . entrySet ( ) ) { put ( entry . getKey ( ) , entry . getValue ( ) ) ; } } 
1842	public void trackRunnableApp ( FSAppAttempt app ) { String user = app . getUser ( ) ; FSLeafQueue queue = app . getQueue ( ) ; Increment running counts for all parent queues FSParentQueue parent = queue . getParent ( ) ; while ( parent ! = null ) { parent . incrementRunnableApps ( ) ; parent = parent . getParent ( ) ; } Integer userNumRunnable = usersNumRunnableApps . get ( user ) ; usersNumRunnableApps . put ( user , ( userNumRunnable = = null ? _NUM : userNumRunnable ) + _NUM ) ; } 
1843	public static String resourceFromHandleBarsTemplate ( String path , Object context ) { if ( ! IO . exists ( IO . path ( path ) ) ) { path = add ( _STR , path ) ; } String str = IO . read ( path ) ; if ( str ! = null ) { str = Boon . handlebars ( str , context ) ; } return str ; } 
1844	private void populateTokenCache ( Configuration conf , Credentials credentials ) throws IOException { readTokensFromFiles ( conf , credentials ) ; add the delegation tokens from configuration String [ ] nameNodes = conf . getStrings ( MRJobConfig . JOB _ NAMENODES ) ; LOG . debug ( _STR + Arrays . toString ( nameNodes ) ) ; if ( nameNodes ! = null ) { Path [ ] ps = new Path [ nameNodes . length ] ; for ( int i = _NUM ; i < nameNodes . length ; i + + ) { ps [ i ] = new Path ( nameNodes [ i ] ) ; } TokenCache . obtainTokensForNamenodes ( credentials , ps , conf ) ; } } 
1845	public static IComplexNDArray createComplex ( float [ ] data , int [ ] shape , int [ ] stride , long offset , char ordering ) { shape = getEnsuredShape ( shape ) ; checkShapeValues ( shape ) ; IComplexNDArray ret = INSTANCE . createComplex ( data , shape , stride , offset , ordering ) ; logCreationIfNecessary ( ret ) ; return ret ; } 
1846	public static CipherParameters makePBEParameters ( byte [ ] pbeKey , int scheme , int digest , int keySize , int ivSize , AlgorithmParameterSpec spec , String targetAlgorithm ) throws InvalidAlgorithmParameterException { if ( ( spec = = null ) | | ! ( spec instanceof PBEParameterSpec ) ) { throw new InvalidAlgorithmParameterException ( _STR ) ) { if ( param instanceof ParametersWithIV ) { KeyParameter kParam = ( KeyParameter ) ( ( ParametersWithIV ) param ) . getParameters ( ) ; DESParameters . setOddParity ( kParam . getKey ( ) ) ; } else { KeyParameter kParam = ( KeyParameter ) param ; DESParameters . setOddParity ( kParam . getKey ( ) ) ; } } return param ; } 
1847	public void close ( ) throws IOException { removeDebounceCallback ( ) ; mListener = null ; if ( mButtonGpio ! = null ) { mButtonGpio . unregisterGpioCallback ( mInterruptCallback ) ; try { mButtonGpio . close ( ) ; } finally { mButtonGpio = null ; } } } 
1848	public boolean hasUnsupportedCriticalExtension ( ) { Set extns = getCriticalExtensionOIDs ( ) ; if ( extns = = null ) { return false ; } extns . remove ( Extension . issuingDistributionPoint . getId ( ) ) ; extns . remove ( Extension . deltaCRLIndicator . getId ( ) ) ; return ! extns . isEmpty ( ) ; } 
1849	private int editEncodedSize ( int rawSize ) { int objectStart = mBuffer . getReadPos ( ) ; int objectEnd = objectStart + rawSize ; int encodedSize = _NUM ; int tagPos ; while ( ( tagPos = mBuffer . getReadPos ( ) ) < objectEnd ) { int tag = readRawTag ( ) ; encodedSize + = EncodedBuffer . getRawVarint _NUM _NUM Size ( tag ) ; final int wireType = tag & WIRE _ TYPE _ MASK ; switch ( wireType ) { case WIRE _ TYPE _ VARINT : encodedSize + + ; while ( ( mBuffer . readRawByte ( ) & _NUM x _NUM _NUM ) ! = _NUM ) { encodedSize + + ; } break ; case WIRE _ TYPE _ FIXED _NUM _NUM : encodedSize + = _NUM ; mBuffer . skipRead ( _NUM ) ; break ; case WIRE _ TYPE _ LENGTH _ DELIMITED : { This object is not of a fixed - size type . So we need to figure out how big it should be . final int childRawSize = mBuffer . readRawFixed _NUM _NUM ( ) ; final int childEncodedSizePos = mBuffer . getReadPos ( ) ; int childEncodedSize = mBuffer . readRawFixed _NUM _NUM ( ) ; if ( childRawSize > = _NUM ) { We know the size , just skip ahead . if ( childEncodedSize ! = childRawSize ) { throw new RuntimeException ( _STR + mBuffer . getDebugString ( ) ) ; } } return encodedSize ; } 
1850	public AttributeList setAttributes ( AttributeList attributes ) { Check attributes is not null to avoid NullPointerException later on if ( attributes = = null ) { throw new RuntimeOperationsException ( new IllegalArgumentException ( _STR + dClassName ) ; } AttributeList resultList = new AttributeList ( ) ; if attributeNames is empty , nothing more to do if ( attributes . isEmpty ( ) ) { return resultList ; } for each attribute , try to set it and add to the result list if successfull for ( Iterator i = attributes . iterator ( ) ; i . hasNext ( ) ; ) { Attribute attr = ( Attribute ) i . next ( ) ; try { setAttribute ( attr ) ; String name = attr . getName ( ) ; Object value = getAttribute ( name ) ; resultList . add ( new Attribute ( name , value ) ) ; } catch ( JMException e ) { e . printStackTrace ( ) ; } catch ( RuntimeException e ) { e . printStackTrace ( ) ; } } return ( resultList ) ; } 
1851	public static byte [ ] dataSerialize ( Object data ) throws IOException { if ( isParseable ( data . getClass ( ) ) ) { return format ( data ) . getBytes ( ) ; } serialize the data ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; ObjectOutputStream oout = new ObjectOutputStream ( bout ) ; Object obj = data ; if ( data instanceof Map ) { Hashtable ht = new Hashtable ( ) ; Iterator it = ( ( Map ) data ) . entrySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { Map . Entry entry = ( Entry ) it . next ( ) ; if ( ( entry . getKey ( ) ! = null ) & & ( entry . getValue ( ) ! = null ) ) { ht . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } } obj = ht ; } oout . writeObject ( obj ) ; oout . close ( ) ; return bout . toByteArray ( ) ; } 
1852	private void testSessionClose ( Replication replication ) throws Throwable { createServers ( _NUM ) ; PrimaryBackupClient client _NUM = createClient ( ) ; PrimitiveProxy session _NUM = createProxy ( client _NUM , _NUM , replication ) ; PrimaryBackupClient client _NUM = createClient ( ) ; session _NUM . invoke ( CLOSE ) . thenRun ( this : : resume ) ; await ( Duration . ofSeconds ( _NUM _NUM ) . toMillis ( ) , _NUM ) ; session _NUM . addEventListener ( CLOSE _ EVENT , this : : resume ) ; PrimitiveProxy session _NUM = createProxy ( client _NUM , _NUM , replication ) ; session _NUM . invoke ( READ ) . thenRun ( this : : resume ) ; await ( _NUM _NUM _NUM _NUM ) ; session _NUM . close ( ) . thenRun ( this : : resume ) ; await ( Duration . ofSeconds ( _NUM _NUM ) . toMillis ( ) , _NUM ) ; } 
1853	protected void performBoot ( ) { configure the classloader from the properties - file . ObjectUtilities . setClassLoaderSource ( getConfiguration ( ) . getConfigProperty ( _STR ) ; getPackageManager ( ) . initializeModules ( ) ; } 
1854	public String getRunningFlowIds ( ) { final List < Integer > allIds = new ArrayList < > ( ) ; getRunningFlowsIdsHelper ( allIds , this . queuedFlows . getAllEntries ( ) ) ; getRunningFlowsIdsHelper ( allIds , this . runningFlows . values ( ) ) ; Collections . sort ( allIds ) ; return allIds . toString ( ) ; } 
1855	public static boolean isPropertyInitialized ( Object object ) { Class < ? > cl = getHibernateClass ( ) ; if ( cl = = null ) { return true ; } Method method = getInitializeMethod ( cl ) ; return checkInitialize ( method , object ) ; } 
1856	protected Container createSideNavigationComponent ( Vector commands , String placement ) { return sideMenu . createSideNavigationPanel ( commands , placement ) ; } 
1857	public TimePeriod getTimePeriod ( int index ) { return getDataItem ( index ) . getPeriod ( ) ; } 
1858	public Map < String , Set < String > > recognise ( String text ) { Map < String , Set < String > > entities = new HashMap < String , Set < String > > ( ) ; Set < String > measurementNumberSet = new HashSet < String > ( ) ; Set < String > unitSet = new HashSet < String > ( ) ; Set < String > measurementSet = new HashSet < String > ( ) ; Set < String > normalizedMeasurementSet = new HashSet < String > ( ) ; Set < String > measurementTypeSet = new HashSet < String > ( ) ; try { String url = restHostUrlStr + readRestEndpoint ( ) ; Response response = WebClient . create ( url ) . accept ( MediaType . APPLICATION _ JSON ) . post ( _STR , measurementTypeSet ) ; } } catch ( Exception e ) { LOG . info ( e . getMessage ( ) , e ) ; } ENTITY _ TYPES . clear ( ) ; ENTITY _ TYPES . addAll ( entities . keySet ( ) ) ; return entities ; } 
1859	public void deleteBackupInfo ( String backupId ) throws IOException { if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( _STR + backupId ) ; } try ( Table table = connection . getTable ( tableName ) ) { Delete del = createDeleteForBackupInfo ( backupId ) ; table . delete ( del ) ; } } 
1860	protected void parseTagContent ( Element element , Reader is ) throws IOException { if ( ( HTMLComponent . SUPPORT _ CSS ) & & ( htmlC . loadCSS ) & & ( ( ( HTMLElement ) element ) . getTagId ( ) = = HTMLElement . TAG _ STYLE ) ) { We aren ' t strict and don ' t require text / css in a style tag & & _STR . equals ( element . getAttributeById ( Element . ATTR _ TYPE ) ) ) ) { CSSElement addTo = CSSParser . getInstance ( ) . parseCSSSegment ( is , null , htmlC , null ) ; htmlC . addToEmebeddedCSS ( addTo ) ; return ; } super . parseTagContent ( element , is ) ; } 
1861	private void setupInputStream ( ) { if ( parseBoolean ( CREATE _ STREAM _ SOURCE , DEFAULT _ CREATE _ STREAM _ SOURCE , properties ) ) { String inputFile = properties . getProperty ( INPUT _ STREAM _ FILE ) ; StreamSource streamSource ; if ( config . BATCH _ RECORDS _ IN _ PUT _ REQUEST ) { streamSource = new BatchedStreamSource ( config , inputFile , parseBoolean ( LOOP _ OVER _ STREAM _ SOURCE , DEFAULT _ LOOP _ OVER _ STREAM _ SOURCE , properties ) ) ; } else { streamSource = new StreamSource ( config , inputFile , parseBoolean ( LOOP _ OVER _ STREAM _ SOURCE , DEFAULT _ LOOP _ OVER _ STREAM _ SOURCE , properties ) ) ; } Thread streamSourceThread = new Thread ( streamSource ) ; LOG . info ( _STR ) ; streamSourceThread . start ( ) ; } } 
1862	private for testSchemaKTable tableForJoin ( final StreamsBuilder builder , final KsqlConfig ksqlConfig , final KafkaTopicClient kafkaTopicClient , final FunctionRegistry functionRegistry , final Map < String , Object > props , final SchemaRegistryClient schemaRegistryClient ) { Map < String , Object > joinTableProps = new HashMap < > ( props ) ; joinTableProps . put ( ConsumerConfig . AUTO _ OFFSET _ RESET _ CONFIG , _STR + getRight ( ) ) ; } return ( SchemaKTable ) schemaKStream ; } 
1863	public void setConnectionFactory ( ConnectionFactory connectionFactory ) { getConfiguration ( ) . setConnectionFactory ( connectionFactory ) ; } 
1864	public void setAssociator ( weka . associations . Associator c ) { boolean loadImages = true ; if ( c . getClass ( ) . getName ( ) . compareTo ( m _ Associator . getClass ( ) . getName ( ) ) = = _NUM ) { loadImages = false ; } m _ Associator = c ; String associatorName = c . getClass ( ) . toString ( ) ; associatorName = associatorName . substring ( associatorName . lastIndexOf ( ' . ' ) + _NUM , associatorName . length ( ) ) ; if ( loadImages ) { if ( ! m _ visual . loadIcons ( BeanVisual . ICON _ PATH + associatorName + _STR ) ) { useDefaultVisual ( ) ; } } m _ visual . setText ( associatorName ) ; get global info m _ globalInfo = KnowledgeFlowApp . getGlobalInfo ( m _ Associator ) ; } 
1865	public int compare ( Task task , Task task _NUM ) { return Long . compare ( task . key . firstActiveTime , task _NUM . key . firstActiveTime ) ; } } ) ; Create groups when sequential packages are the same NamedCounter counter = new NamedCounter ( _STR ; TaskGrouping group ; if ( packageName . equals ( prevPackage ) & & groupCountDown > _NUM ) { group = getGroupWithAffiliation ( prevAffiliation ) ; groupCountDown - - ; } else { int affiliation = IndividualTaskIdOffset + t . key . id ; group = new TaskGrouping ( affiliation ) ; addGroup ( group ) ; prevAffiliation = affiliation ; prevPackage = packageName ; groupCountDown = RecentsDebugFlags . Static . MockTaskGroupsTaskCount ; } group . addTask ( t ) ; taskMap . put ( t . key , t ) ; } Sort groups by increasing latestActiveTime of the group Collections . sort ( mGroups , new Comparator < TaskGrouping > ( ) { @ Override public int compare ( TaskGrouping taskGrouping , TaskGrouping taskGrouping _NUM ) { return Long . compare ( taskGrouping . latestActiveTimeInGroup , taskGrouping _NUM . latestActiveTimeInGroup ) ; } } ) ; Sort group tasks by increasing firstActiveTime of the task , and also build a new list of tasks int taskIndex = _NUM ; int groupCount = mGroups . size ( ) ; for ( int i = _NUM ; i < groupCount ; i + + ) { TaskGrouping group = mGroups . get ( i ) ; Collections . sort ( group . mTaskKeys , new Comparator < Task . TaskKey > ( ) { @ Override public int compare ( Task . TaskKey taskKey , Task . TaskKey taskKey _NUM ) { return Long . compare ( taskKey . firstActiveTime , taskKey _NUM . firstActiveTime ) ; } } ) ; ArrayList < Task . TaskKey > groupTasks = group . mTaskKeys ; int groupTaskCount = groupTasks . size ( ) ; for ( int j = _NUM ; j < groupTaskCount ; j + + ) { tasks . set ( taskIndex , taskMap . get ( groupTasks . get ( j ) ) ) ; taskIndex + + ; } } mStackTaskList . set ( tasks ) ; } else { Create the task groups ArrayMap < Task . TaskKey , Task > tasksMap = new ArrayMap < > ( ) ; ArrayList < Task > tasks = mStackTaskList . getTasks ( ) ; int taskCount = tasks . size ( ) ; for ( int i = _NUM ; i < taskCount ; i + + ) { Task t = tasks . get ( i ) ; TaskGrouping group ; if ( RecentsDebugFlags . Static . EnableAffiliatedTaskGroups ) { int affiliation = t . affiliationTaskId > _NUM ? t . affiliationTaskId : IndividualTaskIdOffset + t . key . id ; if ( mAffinitiesGroups . containsKey ( affiliation ) ) { group = getGroupWithAffiliation ( affiliation ) ; } else { group = new TaskGrouping ( affiliation ) ; addGroup ( group ) ; } } else { group = new TaskGrouping ( t . key . id ) ; addGroup ( group ) ; } group . addTask ( t ) ; tasksMap . put ( t . key , t ) ; } Update the task colors for each of the groups float minAlpha = context . getResources ( ) . getFloat ( R . dimen . recents _ task _ affiliation _ color _ min _ alpha _ percentage ) ; int taskGroupCount = mGroups . size ( ) ; for ( int i = _NUM ; i < taskGroupCount ; i + + ) { TaskGrouping group = mGroups . get ( i ) ; taskCount = group . getTaskCount ( ) ; Ignore the groups that only have one task if ( taskCount < = _NUM ) continue ; Calculate the group color distribution int affiliationColor = tasksMap . get ( group . mTaskKeys . get ( _NUM ) ) . affiliationColor ; float alphaStep = ( _NUM f - minAlpha ) / taskCount ; float alpha = _NUM f ; for ( int j = _NUM ; j < taskCount ; j + + ) { Task t = tasksMap . get ( group . mTaskKeys . get ( j ) ) ; t . colorPrimary = Utilities . getColorWithOverlay ( affiliationColor , Color . WHITE , alpha ) ; alpha - = alphaStep ; } } } } 
1866	public void testAuditWebHdfsStat ( ) throws Exception { final Path file = new Path ( fnames [ _NUM ] ) ; fs . setPermission ( file , new FsPermission ( ( short ) _NUM _NUM _NUM _NUM ) ) ; fs . setOwner ( file , _STR , st ! = null & & st . isFile ( ) ) ; } 
1867	public boolean isHidden ( ) { return sizeRequestedByUser & & preferredSize ! = null & & preferredSize . getWidth ( ) = = _NUM & & preferredSize . getHeight ( ) = = _NUM ; } 
1868	public final void testReadArrayFormula ( ) throws IOException { Cell [ ] cells ; Workbook workbook _NUM = _ testDataProvider . createWorkbook ( ) ; Sheet sheet _NUM = workbook _NUM . createSheet ( ) ; cells = sheet _NUM . setArrayFormula ( _STR ) ) . getFlattenedCells ( ) ; assertEquals ( _NUM , cells . length ) ; Workbook workbook _NUM = _ testDataProvider . writeOutAndReadBack ( workbook _NUM ) ; workbook _NUM . close ( ) ; sheet _NUM = workbook _NUM . getSheetAt ( _NUM ) ; for ( int rownum = _NUM ; rownum < = _NUM ; rownum + + ) { Cell cell _NUM = sheet _NUM . getRow ( rownum ) . getCell ( _NUM ) ; assertTrue ( cell _NUM . isPartOfArrayFormulaGroup ( ) ) ; Cell cell _NUM = sheet _NUM . getRow ( rownum ) . getCell ( _NUM ) ; assertTrue ( cell _NUM . isPartOfArrayFormulaGroup ( ) ) ; } sheet _NUM = workbook _NUM . getSheetAt ( _NUM ) ; for ( int rownum = _NUM ; rownum < = _NUM ; rownum + + ) { Cell cell _NUM = sheet _NUM . getRow ( rownum ) . getCell ( _NUM ) ; assertTrue ( cell _NUM . isPartOfArrayFormulaGroup ( ) ) ; } workbook _NUM . close ( ) ; } 
1869	public void iterateSample ( T w _NUM , T w _NUM , AtomicLong nextRandom , double alpha ) { if ( w _NUM = = null | | w _NUM . getIndex ( ) < _NUM | | w _NUM . getIndex ( ) = = w _NUM . getIndex ( ) | | w _NUM . getLabel ( ) . equals ( _STR + point ) ; other word vector INDArray syn _NUM = this . syn _NUM . slice ( point ) ; double dot = Nd _NUM j . getBlasWrapper ( ) . dot ( l _NUM , syn _NUM ) ; if ( dot < - MAX _ EXP | | dot > = MAX _ EXP ) continue ; int idx = ( int ) ( ( dot + MAX _ EXP ) * ( ( double ) expTable . length / MAX _ EXP / _NUM . _NUM ) ) ; if ( idx > = expTable . length ) continue ; score double f = expTable [ idx ] ; gradient double g = useAdaGrad ? w _NUM . getGradient ( i , ( _NUM - code - f ) , lr . get ( ) ) : ( _NUM - code - f ) * alpha ; Nd _NUM j . getBlasWrapper ( ) . level _NUM ( ) . axpy ( syn _NUM . length ( ) , g , syn _NUM , neu _NUM e ) ; Nd _NUM j . getBlasWrapper ( ) . level _NUM ( ) . axpy ( syn _NUM . length ( ) , g , l _NUM , syn _NUM ) ; } int target = w _NUM . getIndex ( ) ; int label ; negative sampling if ( negative > _NUM ) for ( int d = _NUM ; d < negative + _NUM ; d + + ) { if ( d = = _NUM ) label = _NUM ; else { nextRandom . set ( nextRandom . get ( ) * _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM L + _NUM _NUM ) ; int idx = Math . abs ( ( int ) ( nextRandom . get ( ) > > _NUM _NUM ) % table . length ( ) ) ; target = table . getInt ( idx ) ; if ( target < = _NUM ) target = ( int ) nextRandom . get ( ) % ( vocab . numWords ( ) - _NUM ) + _NUM ; if ( target = = w _NUM . getIndex ( ) ) continue ; label = _NUM ; } if ( target > = syn _NUM Neg . rows ( ) | | target < _NUM ) continue ; double f = Nd _NUM j . getBlasWrapper ( ) . dot ( l _NUM , syn _NUM Neg . slice ( target ) ) ; double g ; if ( f > MAX _ EXP ) g = useAdaGrad ? w _NUM . getGradient ( target , ( label - _NUM ) , alpha ) : ( label - _NUM ) * alpha ; else if ( f < - MAX _ EXP ) g = label * ( useAdaGrad ? w _NUM . getGradient ( target , alpha , alpha ) : alpha ) ; else g = useAdaGrad ? w _NUM . getGradient ( target , label - expTable [ ( int ) ( ( f + MAX _ EXP ) * ( expTable . length / MAX _ EXP / _NUM ) ) ] , alpha ) : ( label - expTable [ ( int ) ( ( f + MAX _ EXP ) * ( expTable . length / MAX _ EXP / _NUM ) ) ] ) * alpha ; if ( syn _NUM . data ( ) . dataType ( ) = = DataBuffer . Type . DOUBLE ) Nd _NUM j . getBlasWrapper ( ) . axpy ( g , syn _NUM Neg . slice ( target ) , neu _NUM e ) ; else Nd _NUM j . getBlasWrapper ( ) . axpy ( ( float ) g , syn _NUM Neg . slice ( target ) , neu _NUM e ) ; if ( syn _NUM . data ( ) . dataType ( ) = = DataBuffer . Type . DOUBLE ) Nd _NUM j . getBlasWrapper ( ) . axpy ( g , l _NUM , syn _NUM Neg . slice ( target ) ) ; else Nd _NUM j . getBlasWrapper ( ) . axpy ( ( float ) g , l _NUM , syn _NUM Neg . slice ( target ) ) ; } if ( syn _NUM . data ( ) . dataType ( ) = = DataBuffer . Type . DOUBLE ) Nd _NUM j . getBlasWrapper ( ) . axpy ( _NUM . _NUM , neu _NUM e , l _NUM ) ; else Nd _NUM j . getBlasWrapper ( ) . axpy ( _NUM . _NUM f , neu _NUM e , l _NUM ) ; } 
1870	public void putAll ( final Props p ) { if ( p = = null ) { return ; } for ( final String key : p . getKeySet ( ) ) { this . put ( key , p . get ( key ) ) ; } } 
1871	public void close ( ) { if ( ! server _ mode ) proxy . endSession ( ) ; super . close ( ) ; } 
1872	public void configure ( PDF _NUM XHTML pdf _NUM XHTML ) { pdf _NUM XHTML . setSortByPosition ( getSortByPosition ( ) ) ; if ( getEnableAutoSpace ( ) ) { pdf _NUM XHTML . setWordSeparator ( _STR ) ; } if ( getAverageCharTolerance ( ) ! = null ) { pdf _NUM XHTML . setAverageCharTolerance ( getAverageCharTolerance ( ) ) ; } if ( getSpacingTolerance ( ) ! = null ) { pdf _NUM XHTML . setSpacingTolerance ( getSpacingTolerance ( ) ) ; } pdf _NUM XHTML . setSuppressDuplicateOverlappingText ( getSuppressDuplicateOverlappingText ( ) ) ; } 
1873	public final E _ StrSubstring substr ( Object src , Object loc , Object len ) { return new E _ StrSubstring ( asExpr ( src ) , asExpr ( loc ) , asExpr ( len ) ) ; } 
1874	public static SQLException parseLocalOrRemoteServerException ( Throwable t ) { while ( t . getCause ( ) ! = null ) { if ( t instanceof NotServingRegionException ) { return parseRemoteException ( new StaleRegionBoundaryCacheException ( ) ) ; } else if ( t instanceof SQLException ) { return ( SQLException ) t ; } t = t . getCause ( ) ; } return parseRemoteException ( t ) ; } 
1875	private void sendErrorCallbacksToAllLocked ( int errorCode ) { for ( ModelData modelData : mModelDataMap . values ( ) ) { IRecognitionStatusCallback callback = modelData . getCallback ( ) ; if ( callback ! = null ) { try { callback . onError ( errorCode ) ; } catch ( RemoteException e ) { Slog . w ( TAG , _STR + modelData . getHandle ( ) , e ) ; } } } } 
1876	public static void setInput ( Job job , Class < ? extends DBWritable > inputClass , String inputQuery , String inputCountQuery ) { job . setInputFormatClass ( DBInputFormat . class ) ; DBConfiguration dbConf = new DBConfiguration ( job . getConfiguration ( ) ) ; dbConf . setInputClass ( inputClass ) ; dbConf . setInputQuery ( inputQuery ) ; dbConf . setInputCountQuery ( inputCountQuery ) ; } 
1877	private void doParse ( InputStream stream , ContentHandler handler , Metadata metadata , ParseContext context ) throws IOException , SAXException { tmpPos = _NUM ; outPos = _NUM ; xhtml = new XHTMLContentHandler ( handler , metadata ) ; xhtml . startDocument ( ) ; int i = _NUM ; do { inSize = _NUM ; while ( ( i = stream . read ( input , inSize , BUF _ SIZE - inSize ) ) > _NUM ) { inSize + = i ; } inPos = _NUM ; while ( inPos < inSize ) { byte c = input [ inPos + + ] ; boolean utf _NUM = false ; if ( c = = ( byte ) _NUM xC _NUM ) { byte c _ = inPos < inSize ? input [ inPos + + ] : ( byte ) stream . read ( ) ; if ( c _ > = ( byte ) _NUM x _NUM _NUM & & c _ < = ( byte ) _NUM xBF ) { utf _NUM = true ; output [ tmpPos + + ] = ( byte ) ( c _ + _NUM x _NUM _NUM ) ; } else { output [ tmpPos + + ] = c ; c = c _ ; } if ( tmpPos = = BUF _ SIZE ) flushBuffer ( ) ; } else if ( c = = ( byte ) _NUM xC _NUM ) { byte c _ = inPos < inSize ? input [ inPos + + ] : ( byte ) stream . read ( ) ; if ( c _ > = ( byte ) _NUM xA _NUM & & c _ < = ( byte ) _NUM xBF ) { utf _NUM = true ; output [ tmpPos + + ] = c _ ; } else { output [ tmpPos + + ] = c ; c = c _ ; } if ( tmpPos = = BUF _ SIZE ) flushBuffer ( ) ; } if ( ! utf _NUM ) if ( isChar ( c ) ) { output [ tmpPos + + ] = c ; if ( tmpPos = = BUF _ SIZE ) flushBuffer ( ) ; } else { if ( c ! = _NUM | | ( inPos > = _NUM & & isChar ( input [ inPos - _NUM ] ) ) | | ( inPos + _NUM < inSize & & isChar ( input [ inPos + _NUM ] ) ) ) { if ( tmpPos - outPos > = minSize ) { output [ tmpPos + + ] = _NUM x _NUM A ; outPos = tmpPos ; if ( tmpPos = = BUF _ SIZE ) flushBuffer ( ) ; } else tmpPos = outPos ; } } } } while ( i ! = - _NUM & & ! Thread . currentThread ( ) . isInterrupted ( ) ) ; if ( tmpPos - outPos > = minSize ) { output [ tmpPos + + ] = _NUM x _NUM A ; outPos = tmpPos ; } xhtml . characters ( new String ( output , _NUM , outPos , _STR ) ) ; xhtml . endDocument ( ) ; } 
1878	public void addIncomingRangeFrom ( Range < Token > range , InetAddressAndPort streamFromNode ) { logger . trace ( _STR , range , streamFromNode ) ; Set < Range < Token > > newInput = RangeDenormalizer . denormalize ( range , incoming ) ; for ( Range < Token > input : newInput ) { incoming . computeIfAbsent ( input , ( newRange ) - > new StreamFromOptions ( differences , newRange ) ) . add ( streamFromNode ) ; } } 
1879	public AccessibilityNodeInfo getChild ( int index ) { enforceSealed ( ) ; if ( mChildNodeIds = = null ) { return null ; } if ( ! canPerformRequestOverConnection ( mSourceNodeId ) ) { return null ; } final long childId = mChildNodeIds . get ( index ) ; AccessibilityInteractionClient client = AccessibilityInteractionClient . getInstance ( ) ; return client . findAccessibilityNodeInfoByAccessibilityId ( mConnectionId , mWindowId , childId , false , FLAG _ PREFETCH _ DESCENDANTS , null ) ; } 
1880	public void addSymmetricEdge ( Number fromVertex , Number toVertex ) { addEdge ( fromVertex , toVertex ) ; addEdge ( toVertex , fromVertex ) ; } 
1881	 @ Deprecateddefault void trackPeerConfigChanges ( ReplicationPeerConfigListener listener ) { registerPeerConfigListener ( listener ) ; } 
1882	public void paginate ( String bucket , BucketKeyListener listener ) { AmazonS _NUM s _NUM = getClient ( ) ; ObjectListing list = s _NUM . listObjects ( bucket ) ; for ( S _NUM ObjectSummary summary : list . getObjectSummaries ( ) ) { if ( listener ! = null ) listener . onKey ( s _NUM , bucket , summary . getKey ( ) ) ; } while ( list . isTruncated ( ) ) { list = s _NUM . listNextBatchOfObjects ( list ) ; for ( S _NUM ObjectSummary summary : list . getObjectSummaries ( ) ) { if ( listener ! = null ) listener . onKey ( s _NUM , bucket , summary . getKey ( ) ) ; } } } 
1883	public final SymbolTable [ ] getImports ( ) { return safeCopy ( myImports ) ; } 
1884	protected String htmlComponent ( CmsSetupComponent component ) { StringBuffer html = new StringBuffer ( _NUM _NUM _NUM ) ; html . append ( _STR ) ; return html . toString ( ) ; } 
1885	public SignalStrength getSignalStrength ( ) { try { ITelephony service = getITelephony ( ) ; if ( service ! = null ) { return service . getSignalStrength ( getSubId ( ) ) ; } } catch ( RemoteException e ) { Log . e ( TAG , _STR , e ) ; } return null ; } 
1886	public ExplainingPredicate < IOException > predicateNoRegionsInTransition ( ) { return new ExplainingPredicate < IOException > ( ) { @ Override public String explainFailure ( ) throws IOException { final RegionStates regionStates = getMiniHBaseCluster ( ) . getMaster ( ) . getAssignmentManager ( ) . getRegionStates ( ) ; return _STR + regionStates . getRegionsInTransition ( ) . toString ( ) ; } @ Override public boolean evaluate ( ) throws IOException { HMaster master = getMiniHBaseCluster ( ) . getMaster ( ) ; if ( master = = null ) return false ; AssignmentManager am = master . getAssignmentManager ( ) ; if ( am = = null ) return false ; return ! am . hasRegionsInTransition ( ) ; } } ; } 
1887	public synchronized Map < String , Map < String , String > > getDefaultConfigAttributesForConfigType ( String configType ) { if ( configPropertyAttributes = = null ) { configPropertyAttributes = getDefaultConfigAttributes ( ) ; } if ( configPropertyAttributes . containsKey ( configType ) ) { return configPropertyAttributes . get ( configType ) ; } return null ; } 
1888	public Set < Map . Entry < Integer , Float > > entrySet ( ) { return new AbstractSet < Map . Entry < Integer , Float > > ( ) { public int size ( ) { return _ map . size ( ) ; } public boolean isEmpty ( ) { return TIntFloatMapDecorator . this . isEmpty ( ) ; } public boolean contains ( Object o ) { if ( o instanceof Map . Entry ) { Object k = ( ( Map . Entry ) o ) . getKey ( ) ; Object v = ( ( Map . Entry ) o ) . getValue ( ) ; return TIntFloatMapDecorator . this . containsKey ( k ) & & TIntFloatMapDecorator . this . get ( k ) . equals ( v ) ; } else { return false ; } } public Iterator < Map . Entry < Integer , Float > > iterator ( ) { return new Iterator < Map . Entry < Integer , Float > > ( ) { private final TIntFloatIterator it = _ map . iterator ( ) ; public Map . Entry < Integer , Float > next ( ) { it . advance ( ) ; int ik = it . key ( ) ; final Integer key = ( ik = = _ map . getNoEntryKey ( ) ) ? null : wrapKey ( ik ) ; float iv = it . value ( ) ; final Float v = ( iv = = _ map . getNoEntryValue ( ) ) ? null : wrapValue ( iv ) ; return new Map . Entry < Integer , Float > ( ) { private Float val = v ; public boolean equals ( Object o ) { return o instanceof Map . Entry & & ( ( Map . Entry ) o ) . getKey ( ) . equals ( key ) & & ( ( Map . Entry ) o ) . getValue ( ) . equals ( val ) ; } public Integer getKey ( ) { return key ; } public Float getValue ( ) { return val ; } public int hashCode ( ) { return key . hashCode ( ) + val . hashCode ( ) ; } public Float setValue ( Float value ) { val = value ; return put ( key , value ) ; } } ; } public boolean hasNext ( ) { return it . hasNext ( ) ; } public void remove ( ) { it . remove ( ) ; } } ; } public boolean add ( Map . Entry < Integer , Float > o ) { throw new UnsupportedOperationException ( ) ; } public boolean remove ( Object o ) { boolean modified = false ; if ( contains ( o ) ) { noinspection unchecked Integer key = ( ( Map . Entry < Integer , Float > ) o ) . getKey ( ) ; _ map . remove ( unwrapKey ( key ) ) ; modified = true ; } return modified ; } public boolean addAll ( Collection < ? extends Map . Entry < Integer , Float > > c ) { throw new UnsupportedOperationException ( ) ; } public void clear ( ) { TIntFloatMapDecorator . this . clear ( ) ; } } ; } 
1889	public static String findFreeCamelContextName ( BundleContext context , String prefix , String key , AtomicInteger counter , boolean checkFirst ) { String candidate = null ; boolean clash = false ; do { try { clash = false ; if ( candidate = = null & & checkFirst ) { try candidate as - is candidate = prefix ; } else { generate new candidate candidate = prefix + _STR , new Object [ ] { context . getBundle ( ) . getBundleId ( ) , clash , candidate } ) ; return candidate ; } 
1890	public static void main ( String [ ] args ) { Create an instance of this sample to work with . DateTime sample = new DateTime ( ) ; Create an schema type instance from the XML indicated by the path . DatetimeDocument doc = sample . parseXml ( args [ _NUM ] ) ; sample . printInstance ( doc ) ; Validate the XML . boolean exampleIsValid = sample . validateXml ( doc ) ; assert exampleIsValid ; Creating a new XML document sample . createDocument ( doc , args [ _NUM ] ) ; } 
1891	public boolean isHit ( BloomFilterData filterData , BitsArray bits ) { if ( ! isValid ( filterData ) ) { throw new IllegalArgumentException ( String . format ( _STR , filterData , this . toString ( ) ) ) ; } return isHit ( filterData . getBitPos ( ) , bits ) ; } 
1892	public synchronized void highlight ( final boolean hits ) { final BaseXTextField tf = textField ( ) ; ( tf ! = null ? tf : this ) . setBackground ( hits ? GUIConstants . BACK : GUIConstants . LRED ) ; } 
1893	public void testCleanerDoesNotDeleteDirectoryWithLateAddedFiles ( ) throws IOException { Stoppable stop = new StoppableImplementation ( ) ; Configuration conf = UTIL . getConfiguration ( ) ; final Path testDir = UTIL . getDataTestDir ( ) ; final FileSystem fs = UTIL . getTestFileSystem ( ) ; String confKey = _STR , fs . exists ( file ) ) ; Mockito . verify ( spy , Mockito . times ( _NUM ) ) . isFileDeletable ( Mockito . any ( ) ) ; Mockito . reset ( spy ) ; } 
1894	public void inflateMenu ( int resId ) { mPresenter . setUpdateSuspended ( true ) ; getMenuInflater ( ) . inflate ( resId , mMenu ) ; mPresenter . setUpdateSuspended ( false ) ; mPresenter . updateMenuView ( false ) ; } 
1895	public void setRange ( double lower , double upper ) { this . lowerBound = lower ; this . upperBound = upper ; setAxisRange ( ) ; } 
1896	private static Pointer denseIm _NUM col ( GPUContext gCtx , String instName , MatrixObject image , boolean isSparseImage , long N , long C , long H , long W , int R , int S , int pad _ h , int pad _ w , int stride _ h , int stride _ w , int P , int Q ) { Pointer im _NUM colPointer = null ; long t _NUM = DMLScript . FINEGRAINED _ STATISTICS ? System . nanoTime ( ) : _NUM ; if ( isSparseImage ) { CSRPointer inPointer = getSparsePointer ( gCtx , image , instName ) ; if ( inPointer . nnz < _NUM ) { throw new DMLRuntimeException ( _STR , ExecutionConfig . getConfigForSimpleVectorOperations ( toInt ( N * C * H * W ) ) , imagePointer , im _NUM colPointer , N * C * H * W , C * H * W , H * W , W , R , S , P , Q , P * Q , R * S , N * P * Q , stride _ h , stride _ w , pad _ h , pad _ w ) ; if ( DMLScript . FINEGRAINED _ STATISTICS ) GPUStatistics . maintainCPMiscTimes ( instName , GPUInstruction . MISC _ TIMER _ DENSE _ IM _NUM COL _ KERNEL , System . nanoTime ( ) - t _NUM ) ; } return im _NUM colPointer ; } 
1897	public void copyAsRtf ( ) { int selStart = getSelectionStart ( ) ; int selEnd = getSelectionEnd ( ) ; if ( selStart = = selEnd ) { return ; } Make sure there is a system clipboard , and that we can write to it . SecurityManager sm = System . getSecurityManager ( ) ; if ( sm ! = null ) { try { sm . checkSystemClipboardAccess ( ) ; } catch ( SecurityException se ) { UIManager . getLookAndFeel ( ) . provideErrorFeedback ( null ) ; return ; } } Clipboard cb = getToolkit ( ) . getSystemClipboard ( ) ; Create the RTF selection . RtfGenerator gen = new RtfGenerator ( ) ; Token tokenList = getTokenListFor ( selStart , selEnd ) ; for ( Token t = tokenList ; t ! = null ; t = t . getNextToken ( ) ) { if ( t . isPaintable ( ) ) { if ( t . length ( ) = = _NUM & & t . charAt ( _NUM ) = = ' \ n ' ) { gen . appendNewline ( ) ; } else { Font font = getFontForTokenType ( t . getType ( ) ) ; Color bg = getBackgroundForToken ( t ) ; boolean underline = getUnderlineForToken ( t ) ; is a whitespace color . Saves on RTF size . if ( t . isWhitespace ( ) ) { gen . appendToDocNoFG ( t . getLexeme ( ) , font , bg , underline ) ; } else { Color fg = getForegroundForToken ( t ) ; gen . appendToDoc ( t . getLexeme ( ) , font , fg , bg , underline ) ; } } } } Set the system clipboard contents to the RTF selection . RtfTransferable contents = new RtfTransferable ( gen . getRtf ( ) . getBytes ( ) ) ; System . out . println ( _STR + new String ( gen . getRtf ( ) . getBytes ( ) ) ) ; try { cb . setContents ( contents , null ) ; } catch ( IllegalStateException ise ) { UIManager . getLookAndFeel ( ) . provideErrorFeedback ( null ) ; return ; } } 
1898	public void lockObjects ( boolean enabled ) { safeGetProtectionField ( ) . setObjects ( enabled ) ; } 
1899	public void onVisibilityAggregated ( boolean isVisible ) { if ( isVisible & & mAttachInfo ! = null ) { initialAwakenScrollBars ( ) ; } final Drawable dr = mBackground ; if ( dr ! = null & & isVisible ! = dr . isVisible ( ) ) { dr . setVisible ( isVisible , false ) ; } final Drawable hl = mDefaultFocusHighlight ; if ( hl ! = null & & isVisible ! = hl . isVisible ( ) ) { hl . setVisible ( isVisible , false ) ; } final Drawable fg = mForegroundInfo ! = null ? mForegroundInfo . mDrawable : null ; if ( fg ! = null & & isVisible ! = fg . isVisible ( ) ) { fg . setVisible ( isVisible , false ) ; } if ( isAutofillable ( ) ) { AutofillManager afm = getAutofillManager ( ) ; if ( afm ! = null & & getAutofillViewId ( ) > LAST _ APP _ AUTOFILL _ ID ) { if ( mVisibilityChangeForAutofillHandler ! = null ) { mVisibilityChangeForAutofillHandler . removeMessages ( _NUM ) ; } with isVisible = false . Hence visibility = = false requires further checks if ( isVisible ) { afm . notifyViewVisibilityChanged ( this , true ) ; } else { if ( mVisibilityChangeForAutofillHandler = = null ) { mVisibilityChangeForAutofillHandler = new VisibilityChangeForAutofillHandler ( afm , this ) ; } Let current operation ( e . g . removal of the view from the hierarchy ) finish before checking state mVisibilityChangeForAutofillHandler . obtainMessage ( _NUM , this ) . sendToTarget ( ) ; } } } } 
1900	protected void customizeEnvironment ( WebEnvironment environment ) { if ( environment instanceof ResourceBasedWebEnvironment ) { ResourceBasedWebEnvironment env = ( ResourceBasedWebEnvironment ) environment ; String [ ] locations = env . getConfigLocations ( ) ; String loc = huntForShiroIni ( locations ) ; Fuseki . configLog . info ( _STR + loc ) ; if ( loc ! = null ) locations = new String [ ] { loc } ; env . setConfigLocations ( locations ) ; } } 
1901	public void testDataBlockEncoding ( ) throws IOException { testInternals ( ) ; } 
1902	public void deleteVisits ( CmsDbContext dbc , String poolName , CmsVisitEntryFilter filter ) throws CmsDataAccessException { try { compose statement StringBuffer queryBuf = new StringBuffer ( _NUM _NUM _NUM ) ; queryBuf . append ( m _ sqlManager . readQuery ( C _ VISIT _ DELETE _ ENTRIES ) ) ; CmsPair < String , List < I _ CmsQueryParameter > > conditionsAndParams = prepareVisitConditions ( filter ) ; queryBuf . append ( conditionsAndParams . getFirst ( ) ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( queryBuf . toString ( ) ) ; } Query q = m _ sqlManager . createQueryFromJPQL ( dbc , queryBuf . toString ( ) ) ; List < I _ CmsQueryParameter > params = conditionsAndParams . getSecond ( ) ; for ( int i = _NUM ; i < params . size ( ) ; i + + ) { I _ CmsQueryParameter param = conditionsAndParams . getSecond ( ) . get ( i ) ; param . insertIntoQuery ( q , i + _NUM ) ; } execute q . executeUpdate ( ) ; } catch ( PersistenceException e ) { throw new CmsDbSqlException ( Messages . get ( ) . container ( Messages . ERR _ GENERIC _ SQL _ _NUM , C _ VISIT _ DELETE _ ENTRIES ) , e ) ; } } 
1903	public void shapeReadLock ( Object object , AllocationShape shape ) { objectReadLock ( object ) ; } 
1904	protected int addRowsByKeys ( final AbstractMemStore hmc , String [ ] keys , byte [ ] val ) { byte [ ] fam = Bytes . toBytes ( _STR + kv . getTimestamp ( ) ) ; } regionServicesForStores . addMemStoreSize ( new MemStoreSize ( hmc . getActive ( ) . keySize ( ) - size , hmc . getActive ( ) . heapSize ( ) - heapOverhead , _NUM ) ) ; return totalLen ; } 
1905	public static synchronized Data create ( final String name , final Parser parser , final Context ctx , final MainOptions options , final boolean mem ) throws IOException { check permissions if ( ! ctx . user ( ) . has ( Perm . CREATE ) ) throw new BaseXException ( PERM _ REQUIRED _ X , Perm . CREATE ) ; create main - memory or disk - based database instance final Data data ; if ( mem ) { data = MemBuilder . build ( name , parser ) ; } else { database is currently locked by another job if ( ctx . pinned ( name ) ) throw new BaseXException ( DB _ PINNED _ X , name ) ; new DiskBuilder ( name , parser , ctx . soptions , options ) . build ( ) . close ( ) ; data = Open . open ( name , ctx , options ) ; } CreateIndex . create ( data , null ) ; return data ; } 
1906	public void putAll ( Map < ? extends K , ? extends V > m ) { int numKeysToBeAdded = m . size ( ) ; if ( numKeysToBeAdded = = _NUM ) return ; if ( numKeysToBeAdded > threshold ) { int targetCapacity = ( int ) ( numKeysToBeAdded / loadFactor + _NUM ) ; if ( targetCapacity > MAXIMUM _ CAPACITY ) targetCapacity = MAXIMUM _ CAPACITY ; int newCapacity = table . length ; while ( newCapacity < targetCapacity ) newCapacity < < = _NUM ; if ( newCapacity > table . length ) resize ( newCapacity ) ; } for ( Iterator < ? extends Map . Entry < ? extends K , ? extends V > > i = m . entrySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { Map . Entry < ? extends K , ? extends V > e = i . next ( ) ; put ( e . getKey ( ) , e . getValue ( ) ) ; } } 
1907	public GenericSearchBuilder < T , K > op ( String name , Object field , Op op ) { return left ( field , op , name ) ; } 
1908	public static File makeTestDataPath ( final Class clazz , final String . . . childPath ) { final File root = getRootOfBuildDirectory ( clazz ) ; final List < String > cleanedPaths = Stream . of ( childPath ) . map ( TestHelper : : cleanPathSegment ) . collect ( Collectors . toList ( ) ) ; use the class name in the directory structure cleanedPaths . add ( _NUM , cleanPathSegment ( clazz . getSimpleName ( ) ) ) ; final File f = new File ( root , TEST _ DATA _ RELATIVE _ DIR + SEP + String . join ( SEP , cleanedPaths ) ) ; if ( ! f . exists ( ) ) f . mkdirs ( ) ; return f ; } 
1909	protected Event doExecute ( final RequestContext context ) { try { final HttpServletRequest request = WebUtils . getHttpServletRequestFromExternalWebflowContext ( context ) ; final String wa = request . getParameter ( WA ) ; if ( StringUtils . isNotBlank ( wa ) & & wa . equalsIgnoreCase ( WSIGNIN ) ) { return handleWsFederationAuthenticationRequest ( context ) ; } prepareLoginViewWithWsFederationClients ( context ) ; } catch ( final Exception ex ) { LOGGER . error ( ex . getMessage ( ) , ex ) ; throw new UnauthorizedServiceException ( UnauthorizedServiceException . CODE _ UNAUTHZ _ SERVICE , ex . getMessage ( ) ) ; } return new EventFactorySupport ( ) . event ( this , CasWebflowConstants . TRANSITION _ ID _ PROCEED ) ; } 
1910	private void maskWidgetsViewsLocked ( Provider provider , Widget targetWidget ) { final int widgetCount = provider . widgets . size ( ) ; if ( widgetCount = = _NUM ) { return ; } final String providerPackage = provider . info . provider . getPackageName ( ) ; final int providerUserId = provider . getUserId ( ) ; Bitmap iconBitmap = createMaskedWidgetBitmap ( providerPackage , providerUserId ) ; if ( iconBitmap = = null ) { return ; } final boolean showBadge ; final Intent onClickIntent ; final long identity = Binder . clearCallingIdentity ( ) ; try { if ( provider . maskedBySuspendedPackage ) { UserInfo userInfo = mUserManager . getUserInfo ( providerUserId ) ; showBadge = userInfo . isManagedProfile ( ) ; onClickIntent = mDevicePolicyManagerInternal . createShowAdminSupportIntent ( providerUserId , true ) ; } else if ( provider . maskedByQuietProfile ) { showBadge = true ; onClickIntent = UnlaunchableAppActivity . createInQuietModeDialogIntent ( providerUserId ) ; } else { showBadge = true ; onClickIntent = mKeyguardManager . createConfirmDeviceCredentialIntent ( null , null , providerUserId ) ; if ( onClickIntent ! = null ) { onClickIntent . setFlags ( FLAG _ ACTIVITY _ NEW _ TASK | FLAG _ ACTIVITY _ EXCLUDE _ FROM _ RECENTS ) ; } } for ( int j = _NUM ; j < widgetCount ; j + + ) { Widget widget = provider . widgets . get ( j ) ; if ( targetWidget ! = null & & targetWidget ! = widget ) continue ; PendingIntent intent = null ; if ( onClickIntent ! = null ) { intent = PendingIntent . getActivity ( mContext , widget . appWidgetId , onClickIntent , PendingIntent . FLAG _ UPDATE _ CURRENT ) ; } RemoteViews views = createMaskedWidgetRemoteViews ( iconBitmap , showBadge , intent ) ; if ( widget . replaceWithMaskedViewsLocked ( views ) ) { scheduleNotifyUpdateAppWidgetLocked ( widget , widget . getEffectiveViewsLocked ( ) ) ; } } } finally { Binder . restoreCallingIdentity ( identity ) ; } } 
1911	public static int getInt ( String attrName , Map < String , String > runtimeAttributes , Node docElement ) { String stringValue = getStringValue ( attrName , runtimeAttributes , docElement ) ; if ( stringValue ! = null ) { try { return Integer . parseInt ( stringValue ) ; } catch ( NumberFormatException e ) { swallow } } throw new RuntimeException ( _STR ) ; } 
1912	public void clear ( ) { mAttachedScrap . clear ( ) ; recycleAndClearCachedViews ( ) ; } 
1913	private void testEquivalenceOfScanWithHeartbeats ( final Scan scan , int rowSleepTime , int cfSleepTime , boolean sleepBeforeCf ) throws Exception { disableSleeping ( ) ; final ResultScanner scanner = TABLE . getScanner ( scan ) ; final ResultScanner scannerWithHeartbeats = TABLE . getScanner ( scan ) ; Result r _NUM = null ; Result r _NUM = null ; while ( ( r _NUM = scanner . next ( ) ) ! = null ) { Enforce the specified sleep conditions during calls to the heartbeat scanner configureSleepTime ( rowSleepTime , cfSleepTime , sleepBeforeCf ) ; r _NUM = scannerWithHeartbeats . next ( ) ; disableSleeping ( ) ; assertTrue ( r _NUM ! = null ) ; try { Result . compareResults ( r _NUM , r _NUM ) ; } catch ( Exception e ) { fail ( e . getMessage ( ) ) ; } } assertTrue ( scannerWithHeartbeats . next ( ) = = null ) ; scanner . close ( ) ; scannerWithHeartbeats . close ( ) ; } 
1914	public static AbstractTransactionalContext newContext ( AbstractTransactionalContext context ) { log . debug ( _STR , context ) ; getTransactionStack ( ) . addFirst ( context ) ; return context ; } 
1915	public static org . apache . xmlbeans . xml . stream . XMLInputStream newValidatingXMLInputStream ( org . apache . xmlbeans . xml . stream . XMLInputStream xis , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , org . apache . xmlbeans . xml . stream . XMLStreamException { return XmlBeans . getContextTypeLoader ( ) . newValidatingXMLInputStream ( xis , type , options ) ; } 
1916	private float readFloat ( ) throws IOException { String theFloat = readString ( ) ; return Float . parseFloat ( theFloat ) ; } 
1917	private void updateStateFromTypedArray ( @ NonNull TypedArray a ) { final LayerState state = mLayerState ; Account for any configuration changes . state . mChangingConfigurations | = a . getChangingConfigurations ( ) ; Extract the theme attributes , if any . state . mThemeAttrs = a . extractThemeAttrs ( ) ; final int N = a . getIndexCount ( ) ; for ( int i = _NUM ; i < N ; i + + ) { final int attr = a . getIndex ( i ) ; switch ( attr ) { case R . styleable . LayerDrawable _ opacity : state . mOpacityOverride = a . getInt ( attr , state . mOpacityOverride ) ; break ; case R . styleable . LayerDrawable _ paddingTop : state . mPaddingTop = a . getDimensionPixelOffset ( attr , state . mPaddingTop ) ; break ; case R . styleable . LayerDrawable _ paddingBottom : state . mPaddingBottom = a . getDimensionPixelOffset ( attr , state . mPaddingBottom ) ; break ; case R . styleable . LayerDrawable _ paddingLeft : state . mPaddingLeft = a . getDimensionPixelOffset ( attr , state . mPaddingLeft ) ; break ; case R . styleable . LayerDrawable _ paddingRight : state . mPaddingRight = a . getDimensionPixelOffset ( attr , state . mPaddingRight ) ; break ; case R . styleable . LayerDrawable _ paddingStart : state . mPaddingStart = a . getDimensionPixelOffset ( attr , state . mPaddingStart ) ; break ; case R . styleable . LayerDrawable _ paddingEnd : state . mPaddingEnd = a . getDimensionPixelOffset ( attr , state . mPaddingEnd ) ; break ; case R . styleable . LayerDrawable _ autoMirrored : state . mAutoMirrored = a . getBoolean ( attr , state . mAutoMirrored ) ; break ; case R . styleable . LayerDrawable _ paddingMode : state . mPaddingMode = a . getInteger ( attr , state . mPaddingMode ) ; break ; } } } 
1918	public final SparseBooleanArray readSparseBooleanArray ( ) { int N = readInt ( ) ; if ( N < _NUM ) { return null ; } SparseBooleanArray sa = new SparseBooleanArray ( N ) ; readSparseBooleanArrayInternal ( sa , N ) ; return sa ; } 
1919	protected void showError ( ) { if ( hasError ( ) ) { m _ label . getElement ( ) . getStyle ( ) . clearDisplay ( ) ; CmsFadeAnimation . fadeIn ( m _ label . getElement ( ) , new Command ( ) { public void execute ( ) { noop } } , _NUM _NUM _NUM ) ; } } 
1920	public static void decodeToFile ( String dataToDecode , String filename ) throws java . io . IOException { OutputStream bos = null ; try { bos = new OutputStream ( new java . io . FileOutputStream ( filename ) , Base _NUM _NUM . DECODE ) ; bos . write ( dataToDecode . getBytes ( PREFERRED _ ENCODING ) ) ; } end try catch ( java . io . IOException e ) { Catch and throw to execute finally { } block throw e ; } finally end catch : java . io . IOException { try { bos . close ( ) ; } catch ( Exception e ) { } } end finally } 
1921	public String getDisplayedCurrentValue ( ) { if ( Boolean . TRUE . equals ( secret ) & & isDatatypeMayBeHidden ( ) ) { return AppBeans . get ( Messages . class ) . getMessage ( AppPropertyEntity . class , _STR ) ; } else { return currentValue ; } } 
1922	protected void processObjectTag ( ObjectTag tag ) { CmsRelationType type = CmsRelationType . valueOf ( tag . getTagName ( ) ) ; for ( int i = _NUM ; i < OBJECT _ TAG _ LINKED _ ATTRIBS . length ; i + + ) { String attr = OBJECT _ TAG _ LINKED _ ATTRIBS [ i ] ; processLink ( tag , attr , type ) ; if ( ( i = = _NUM ) & & ( tag . getAttribute ( attr ) ! = null ) ) { if code base is available , the other attributes are relative to it , so do not process them break ; } } SimpleNodeIterator itChildren = tag . children ( ) ; while ( itChildren . hasMoreNodes ( ) ) { Node node = itChildren . nextNode ( ) ; if ( node instanceof Tag ) { Tag childTag = ( Tag ) node ; if ( TAG _ PARAM . equals ( childTag . getTagName ( ) ) ) { processLink ( childTag , ATTRIBUTE _ VALUE , type ) ; } } } } 
1923	private ExchangeClient getSharedClient ( URL url ) { String key = url . getAddress ( ) ; ReferenceCountExchangeClient client = referenceClientMap . get ( key ) ; if ( client ! = null ) { if ( ! client . isClosed ( ) ) { client . incrementAndGetCount ( ) ; return client ; } else { referenceClientMap . remove ( key ) ; } } synchronized ( key . intern ( ) ) { ExchangeClient exchangeClient = initClient ( url ) ; client = new ReferenceCountExchangeClient ( exchangeClient , ghostClientMap ) ; referenceClientMap . put ( key , client ) ; ghostClientMap . remove ( key ) ; return client ; } } 
1924	public String getLinkInFileMetadata ( String key ) throws AzureException { if ( null = = storageInteractionLayer ) { final String errMsg = String . format ( _STR , sessionUri ) ; throw new AssertionError ( errMsg ) ; } try { checkContainer ( ContainerAccessType . PureRead ) ; CloudBlobWrapper blob = getBlobReference ( key ) ; blob . downloadAttributes ( getInstrumentedContext ( ) ) ; return getLinkAttributeValue ( blob ) ; } catch ( Exception e ) { storage exception . throw new AzureException ( e ) ; } } 
1925	public SendQueue < T > sendQueueWithAutoFlush ( int interval , TimeUnit timeUnit ) { final SendQueue < String > sendQueue = queue . sendQueueWithAutoFlush ( interval , timeUnit ) ; return createJsonSendQueue ( sendQueue ) ; } 
1926	private int findImageVersion ( DataInputStream in ) throws IOException { arbitrary amount , resetting immediately in . mark ( _NUM _NUM ) ; int version = in . readInt ( ) ; in . reset ( ) ; return version ; } 
1927	public void doFilter ( ServletRequest request , ServletResponse response , FilterChain filterChain ) throws IOException , ServletException { HttpServletRequest httpRequest = ( HttpServletRequest ) request ; logger . debug ( _STR ) ) { filterChain . doFilter ( request , response ) ; } } else { httpResponse . sendError ( errCode , authenticationEx . getMessage ( ) ) ; } } } } 
1928	Location getBlockContainsKey ( RawComparable key , boolean greater ) throws IOException { if ( ! isSorted ( ) ) { throw new RuntimeException ( _STR ) ; } checkTFileDataIndex ( ) ; int blkIndex = ( greater ) ? tfileIndex . upperBound ( key ) : tfileIndex . lowerBound ( key ) ; if ( blkIndex < _NUM ) return end ; return new Location ( blkIndex , _NUM ) ; } 
1929	public String buildDialogOptions ( ) { StringBuffer result = new StringBuffer ( _NUM _NUM _NUM ) ; boolean isMoved = isOperationOnMovedResource ( ) ; if ( ! isMultiOperation ( ) ) { result . append ( dialogSpacer ( ) ) ; result . append ( key ( Messages . GUI _ UNDO _ LASTMODIFIED _ INFO _ _NUM , new Object [ ] { getFileName ( ) , getLastModifiedDate ( ) , getLastModifiedUser ( ) } ) ) ; if ( isMoved ) { result . append ( dialogSpacer ( ) ) ; result . append ( key ( Messages . GUI _ UNDO _ MOVE _ OPERATION _ INFO _ _NUM , new Object [ ] { getFileName ( ) , resourceOriginalPath ( getCms ( ) , getParamResource ( ) ) } ) ) ; } } result . append ( dialogSpacer ( ) ) ; result . append ( key ( Messages . GUI _ UNDO _ CONFIRMATION _ _NUM ) ) ; if ( isMoved | | isOperationOnFolder ( ) ) { show undo move option if both options are available result . append ( dialogSpacer ( ) ) ; result . append ( _STR ) ; if ( isMultiOperation ( ) ) { result . append ( key ( Messages . GUI _ UNDO _ CHANGES _ RECURSIVE _ MULTI _ SUBRESOURCES _ _NUM ) ) ; } else { result . append ( key ( Messages . GUI _ UNDO _ CHANGES _ RECURSIVE _ SUBRESOURCES _ _NUM ) ) ; } result . append ( dialogBlockEnd ( ) ) ; } return result . toString ( ) ; } 
1930	protected void addFiles ( List < CmsFileInfo > fileInfos ) { if ( fileInfos ! = null ) { for ( CmsFileInfo file : fileInfos ) { store all files m _ allFiles . put ( file . getFileName ( ) , file ) ; add those files to the list of files to upload that potential candidates if ( ! isTooLarge ( file ) & & ( file . getFileSize ( ) ! = _NUM ) ) { m _ filesToUpload . put ( file . getFileName ( ) , file ) ; } remove those files from the list to upload that were previously unchecked by the user if ( ( m _ listItems . get ( file . getFileName ( ) ) ! = null ) & & ( m _ listItems . get ( file . getFileName ( ) ) . getCheckBox ( ) ! = null ) & & ! m _ listItems . get ( file . getFileName ( ) ) . getCheckBox ( ) . isChecked ( ) ) { m _ filesToUpload . remove ( file . getFileName ( ) ) ; } } now rebuild the list : handle all files m _ fileList . clearList ( ) ; List < String > sortedFileNames = new ArrayList < String > ( m _ allFiles . keySet ( ) ) ; Collections . sort ( sortedFileNames , String . CASE _ INSENSITIVE _ ORDER ) ; for ( String filename : sortedFileNames ) { CmsFileInfo file = m _ allFiles . get ( filename ) ; addFileToList ( file , false , isTooLarge ( file ) ) ; } } loadAndShow ( ) ; } 
1931	public TBuilder withRemoteIp ( String ip ) { this . remoteIp = ip ; return self ( ) ; } 
1932	public void testContinuedRecord ( ) throws IOException { byte [ ] origData ; SSTRecord record ; byte [ ] ser _ output ; origData = concatHexDumps ( _STR ) ; } if ( false ) { TODO - trivial differences in ContinueRecord break locationsSample data should be checked against what most recent Excel version produces . maybe tweaks are required in ContinuableRecordOutputassertArrayEquals ( origData , ser _ output ) ; } } 
1933	public final void acquireShared ( long arg ) { if ( tryAcquireShared ( arg ) < _NUM ) doAcquireShared ( arg ) ; } 
1934	public void toFilesIterable _ DisallowOverwrite _ MultipleFiles _ AllOutputFilesExist ( ) throws IOException { set up File sourceFile = new File ( _STR ) ; copy the image to a temporary file . TestUtils . copyFile ( sourceFile , originalFile ) ; TestUtils . copyFile ( sourceFile , fileThatExists _NUM ) ; TestUtils . copyFile ( sourceFile , fileThatExists _NUM ) ; given when Thumbnails . of ( originalFile , originalFile ) . size ( _NUM _NUM _NUM , _NUM _NUM _NUM ) . allowOverwrite ( false ) . toFiles ( Arrays . asList ( fileThatExists _NUM , fileThatExists _NUM ) ) ; then assertTrue ( fileThatExists _NUM . exists ( ) ) ; assertTrue ( fileThatExists _NUM . exists ( ) ) ; assertTrue ( sourceFile . length ( ) = = fileThatExists _NUM . length ( ) ) ; assertTrue ( sourceFile . length ( ) = = fileThatExists _NUM . length ( ) ) ; clean up originalFile . delete ( ) ; fileThatExists _NUM . delete ( ) ; fileThatExists _NUM . delete ( ) ; } 
1935	public INDArray [ ] getArrays ( ) throws Exception { if ( ! started ) { start ( ) ; started = true ; } return consumerTemplate . receiveBody ( DIRECT _ ROUTE , INDArray [ ] . class ) ; } 
1936	public TransitiveGraphCache deepCopy ( ) { TransitiveGraphCache copy = new TransitiveGraphCache ( directPredicate , closedPredicate ) ; Iterator < Triple > i = find ( new TriplePattern ( null , directPredicate , null ) ) ; while ( i . hasNext ( ) ) { Triple t = i . next ( ) ; copy . addRelation ( t . getSubject ( ) , t . getObject ( ) ) ; } return copy ; } 
1937	public void clickOnScreenRight ( ) { float x = getDisplayX ( ) ; float y = getDisplayY ( ) ; clickOnScreen ( x / _NUM , y / _NUM ) ; } 
1938	public void createKeySpaces ( StressSettings settings ) { JavaDriverClient client = settings . getJavaDriverClient ( false ) ; try { Keyspace client . execute ( createKeyspaceStatementCQL _NUM ( ) , org . apache . cassandra . db . ConsistencyLevel . LOCAL _ ONE ) ; client . execute ( _STR , e ) ; } } 
1939	public ComponentSelector setMarginPercent ( double top , double right , double bottom , double left ) { for ( Component c : this ) { Component parent = c . getParent ( ) ; if ( parent ! = null ) { Style s = getStyle ( c ) ; s . setMarginUnit ( Style . UNIT _ TYPE _ PIXELS , Style . UNIT _ TYPE _ PIXELS , Style . UNIT _ TYPE _ PIXELS , Style . UNIT _ TYPE _ PIXELS ) ; s . setMargin ( percentHeight ( top , parent ) , percentHeight ( bottom , parent ) , percentWidth ( left , parent ) , percentWidth ( right , parent ) ) ; } } return this ; } 
1940	public Response getInfo ( @ QueryParam ( QUERY _ RAW _ CONFIGURATION ) final Boolean rawConfiguration ) { TODO ( jiri ) : Add a mechanism for retrieving only a subset of the fields . return RestUtils . call ( new RestUtils . RestCallable < AlluxioWorkerInfo > ( ) { @ Override public AlluxioWorkerInfo call ( ) throws Exception { boolean rawConfig = false ; if ( rawConfiguration ! = null ) { rawConfig = rawConfiguration ; } AlluxioWorkerInfo result = new AlluxioWorkerInfo ( ) . setCapacity ( getCapacityInternal ( ) ) . setConfiguration ( getConfigurationInternal ( rawConfig ) ) . setMetrics ( getMetricsInternal ( ) ) . setRpcAddress ( mWorkerProcess . getRpcAddress ( ) . toString ( ) ) . setStartTimeMs ( mWorkerProcess . getStartTimeMs ( ) ) . setTierCapacity ( getTierCapacityInternal ( ) ) . setTierPaths ( getTierPathsInternal ( ) ) . setUptimeMs ( mWorkerProcess . getUptimeMs ( ) ) . setVersion ( RuntimeConstants . VERSION ) ; return result ; } } ) ; } 
1941	private static PropertyValuesHolder loadPvh ( Context context , Resources res , Theme theme , XmlPullParser parser , String propertyName , int valueType ) throws XmlPullParserException , IOException { PropertyValuesHolder value = null ; ArrayList < Keyframe > keyframes = null ; int type ; while ( ( type = parser . next ( ) ) ! = XmlPullParser . END _ TAG & & type ! = XmlPullParser . END _ DOCUMENT ) { String name = parser . getName ( ) ; if ( name . equals ( _STR ) ) { if ( valueType = = VALUE _ TYPE _ UNDEFINED ) { valueType = inferValueTypeOfKeyframe ( res , theme , Xml . asAttributeSet ( parser ) , parser ) ; } Keyframe keyframe = loadKeyframe ( context , res , theme , Xml . asAttributeSet ( parser ) , valueType , parser ) ; if ( keyframe ! = null ) { if ( keyframes = = null ) { keyframes = new ArrayList < Keyframe > ( ) ; } keyframes . add ( keyframe ) ; } parser . next ( ) ; } } int count ; if ( keyframes ! = null & & ( count = keyframes . size ( ) ) > _NUM ) { make sure we have keyframes at _NUM and _NUM If we have keyframes with set fractions , add keyframes at start / end appropriately . If start / end have no set fractions : if there ' s only one keyframe , set its fraction to _NUM and add one at _NUM if > _NUM keyframe , set the last fraction to _NUM , the first fraction to _NUM Keyframe firstKeyframe = keyframes . get ( _NUM ) ; Keyframe lastKeyframe = keyframes . get ( count - _NUM ) ; float endFraction = lastKeyframe . getFraction ( ) ; if ( endFraction < _NUM ) { if ( endFraction < _NUM ) { lastKeyframe . setFraction ( _NUM ) ; } else { keyframes . add ( keyframes . size ( ) , createNewKeyframe ( lastKeyframe , _NUM ) ) ; + + count ; } } float startFraction = firstKeyframe . getFraction ( ) ; if ( startFraction ! = _NUM ) { if ( startFraction < _NUM ) { firstKeyframe . setFraction ( _NUM ) ; } else { keyframes . add ( _NUM , createNewKeyframe ( firstKeyframe , _NUM ) ) ; + + count ; } } Keyframe [ ] keyframeArray = new Keyframe [ count ] ; keyframes . toArray ( keyframeArray ) ; for ( int i = _NUM ; i < count ; + + i ) { Keyframe keyframe = keyframeArray [ i ] ; if ( keyframe . getFraction ( ) < _NUM ) { if ( i = = _NUM ) { keyframe . setFraction ( _NUM ) ; } else if ( i = = count - _NUM ) { keyframe . setFraction ( _NUM ) ; } else { figure out the start / end parameters of the current gap in fractions and distribute the gap among those keyframes int startIndex = i ; int endIndex = i ; for ( int j = startIndex + _NUM ; j < count - _NUM ; + + j ) { if ( keyframeArray [ j ] . getFraction ( ) > = _NUM ) { break ; } endIndex = j ; } float gap = keyframeArray [ endIndex + _NUM ] . getFraction ( ) - keyframeArray [ startIndex - _NUM ] . getFraction ( ) ; distributeKeyframes ( keyframeArray , gap , startIndex , endIndex ) ; } } } value = PropertyValuesHolder . ofKeyframe ( propertyName , keyframeArray ) ; if ( valueType = = VALUE _ TYPE _ COLOR ) { value . setEvaluator ( ArgbEvaluator . getInstance ( ) ) ; } } return value ; } 
1942	 @ SuppressWarnings ( { _STR + entry . getAction ( ) ) ; } 
1943	public long getTotalTopologyMemoryUsed ( ) { updateMemoryAccounting ( ) ; return _ usedMemory . values ( ) . stream ( ) . filter ( ( topoAndMem ) - > _ topologyId . equals ( topoAndMem . topoId ) ) . mapToLong ( ( topoAndMem ) - > topoAndMem . memory ) . sum ( ) ; } 
1944	public static List < Query > parseFuncs ( IndexSchema s , String in ) throws ParseException { Map < String , Float > ff = parseFieldBoosts ( in ) ; List < Query > funcs = new ArrayList < Query > ( ff . keySet ( ) . size ( ) ) ; for ( String f : ff . keySet ( ) ) { Query fq = QueryParsing . parseFunction ( f , s ) ; Float b = ff . get ( f ) ; if ( null ! = b ) { fq . setBoost ( b ) ; } funcs . add ( fq ) ; } return funcs ; } 
1945	public void invisibleNoTransitions ( ) throws Throwable { if ( ! mReorderingAllowed ) { only reordered transitions can avoid interaction return ; } enter transition TransitionFragment fragment = new InvisibleFragment ( ) ; fragment . setLayoutId ( R . layout . scene _NUM ) ; mFragmentManager . beginTransaction ( ) . setReorderingAllowed ( mReorderingAllowed ) . add ( R . id . fragmentContainer , fragment ) . addToBackStack ( null ) . commit ( ) ; FragmentTestUtil . waitForExecution ( mActivityRule ) ; fragment . waitForNoTransition ( ) ; verifyNoOtherTransitions ( fragment ) ; exit transition mFragmentManager . beginTransaction ( ) . setReorderingAllowed ( mReorderingAllowed ) . remove ( fragment ) . addToBackStack ( null ) . commit ( ) ; fragment . waitForNoTransition ( ) ; verifyNoOtherTransitions ( fragment ) ; reenter transition FragmentTestUtil . popBackStackImmediate ( mActivityRule ) ; fragment . waitForNoTransition ( ) ; verifyNoOtherTransitions ( fragment ) ; return transition FragmentTestUtil . popBackStackImmediate ( mActivityRule ) ; fragment . waitForNoTransition ( ) ; verifyNoOtherTransitions ( fragment ) ; } 
1946	public void jspForwardPage ( CmsWorkplace wp , String pagePath , Map < String , String [ ] > params ) throws IOException , ServletException { Map < String , String [ ] > newParams = createToolParams ( wp , pagePath , params ) ; if ( pagePath . indexOf ( _STR ) ) ; } wp . setForwarded ( true ) ; forward to the requested page uri CmsRequestUtil . forwardRequest ( wp . getJsp ( ) . link ( pagePath ) , CmsRequestUtil . createParameterMap ( newParams ) , wp . getJsp ( ) . getRequest ( ) , wp . getJsp ( ) . getResponse ( ) ) ; } 
1947	private List < HiveQueryId > parseHqidJsonFromATS ( JSONObject entities ) { JSONArray jobs = ( JSONArray ) entities . get ( _STR ) ; return getHqidListFromJsonArray ( jobs ) ; } 
1948	public void toThrift ( ) throws IOException { Random random = new Random ( ) ; String owner = CommonUtils . randomAlphaNumString ( _NUM _NUM ) ; String group = CommonUtils . randomAlphaNumString ( _NUM _NUM ) ; Mode mode = new Mode ( ( short ) random . nextInt ( ) ) ; CreateUfsFileOptions options = CreateUfsFileOptions . defaults ( ) ; options . setOwner ( owner ) ; options . setGroup ( group ) ; options . setMode ( mode ) ; CreateUfsFileTOptions thriftOptions = options . toThrift ( ) ; Assert . assertEquals ( owner , thriftOptions . getOwner ( ) ) ; Assert . assertEquals ( group , thriftOptions . getGroup ( ) ) ; Assert . assertEquals ( mode . toShort ( ) , thriftOptions . getMode ( ) ) ; } 
1949	public void setAdapter ( PagerAdapter adapter ) { if ( mAdapter ! = null ) { mAdapter . unregisterDataSetObserver ( mObserver ) ; mAdapter . startUpdate ( this ) ; for ( int i = _NUM ; i < mItems . size ( ) ; i + + ) { final ItemInfo ii = mItems . get ( i ) ; mAdapter . destroyItem ( this , ii . position , ii . object ) ; } mAdapter . finishUpdate ( this ) ; mItems . clear ( ) ; removeNonDecorViews ( ) ; mCurItem = _NUM ; scrollTo ( _NUM , _NUM ) ; } final PagerAdapter oldAdapter = mAdapter ; mAdapter = adapter ; mExpectedAdapterCount = _NUM ; if ( mAdapter ! = null ) { if ( mObserver = = null ) { mObserver = new PagerObserver ( ) ; } mAdapter . registerDataSetObserver ( mObserver ) ; mPopulatePending = false ; final boolean wasFirstLayout = mFirstLayout ; mFirstLayout = true ; mExpectedAdapterCount = mAdapter . getCount ( ) ; if ( mRestoredCurItem > = _NUM ) { mAdapter . restoreState ( mRestoredAdapterState , mRestoredClassLoader ) ; setCurrentItemInternal ( mRestoredCurItem , false , true ) ; mRestoredCurItem = - _NUM ; mRestoredAdapterState = null ; mRestoredClassLoader = null ; } else if ( ! wasFirstLayout ) { populate ( ) ; } else { requestLayout ( ) ; } } if ( mAdapterChangeListener ! = null & & oldAdapter ! = adapter ) { mAdapterChangeListener . onAdapterChanged ( oldAdapter , adapter ) ; } } 
1950	void processMessagesForDevice ( int address ) { ArrayList < HdmiCecMessage > copiedBuffer = new ArrayList < HdmiCecMessage > ( mBuffer ) ; mBuffer . clear ( ) ; HdmiLogger . debug ( _STR + message ) ; } } 
1951	public Rectangle getPageSize ( PdfDictionary page ) { PdfArray mediaBox = page . getAsArray ( PdfName . MEDIABOX ) ; return getNormalizedRectangle ( mediaBox ) ; } 
1952	public < S > void addSource ( @ NonNull LiveData < S > source , @ NonNull Observer < S > onChanged ) { Source < S > e = new Source < > ( source , onChanged ) ; Source < ? > existing = mSources . putIfAbsent ( source , e ) ; if ( existing ! = null & & existing . mObserver ! = onChanged ) { throw new IllegalArgumentException ( _STR ) ; } if ( existing ! = null ) { return ; } if ( hasActiveObservers ( ) ) { e . plug ( ) ; } } 
1953	public void checkModuleSelectionList ( List < String > moduleNames , String rfsAbsPath , boolean forDeletion ) throws CmsIllegalArgumentException , CmsConfigurationException { Map < String , List < String > > moduleDependencies = buildDepsForAllModules ( rfsAbsPath , forDeletion ) ; Iterator < String > itMods = moduleNames . iterator ( ) ; while ( itMods . hasNext ( ) ) { String moduleName = itMods . next ( ) ; List < String > dependencies = moduleDependencies . get ( moduleName ) ; if ( dependencies ! = null ) { List < String > depModules = new ArrayList < String > ( dependencies ) ; depModules . removeAll ( moduleNames ) ; if ( ! depModules . isEmpty ( ) ) { throw new CmsIllegalArgumentException ( Messages . get ( ) . container ( Messages . ERR _ MODULE _ SELECTION _ INCONSISTENT _ _NUM , moduleName , depModules . toString ( ) ) ) ; } } } } 
1954	public void testSimpleJoinConditionWithIsNullOperators ( ) { String query = _STR ; sql ( query ) . ok ( expected ) ; } 
1955	synchronized void connectOne ( long sid ) { if ( senderWorkerMap . get ( sid ) ! = null ) { LOG . debug ( _STR + sid ) ; return ; } } } 
1956	public void setOrientation ( int orientation ) { if ( orientation ! = HORIZONTAL & & orientation ! = VERTICAL ) { throw new IllegalArgumentException ( _STR ) ; } assertNotInLayoutOrScroll ( null ) ; if ( orientation = = mOrientation ) { return ; } mOrientation = orientation ; OrientationHelper tmp = mPrimaryOrientation ; mPrimaryOrientation = mSecondaryOrientation ; mSecondaryOrientation = tmp ; requestLayout ( ) ; } 
1957	public void setInterfaceUp ( ) { mFlags . remove ( FLAG _ DOWN ) ; mFlags . add ( FLAG _ UP ) ; } 
1958	int findSyncPosition ( ) { int count = mItemCount ; if ( count = = _NUM ) { return INVALID _ POSITION ; } long idToMatch = mSyncRowId ; int seed = mSyncPosition ; If there isn ' t a selection don ' t hunt for it if ( idToMatch = = INVALID _ ROW _ ID ) { return INVALID _ POSITION ; } Pin seed to reasonable values seed = Math . max ( _NUM , seed ) ; seed = Math . min ( count - _NUM , seed ) ; long endTime = SystemClock . uptimeMillis ( ) + SYNC _ MAX _ DURATION _ MILLIS ; long rowId ; first position scanned so far int first = seed ; last position scanned so far int last = seed ; True if we should move down on the next iteration boolean next = false ; True when we have looked at the first item in the data boolean hitFirst ; True when we have looked at the last item in the data boolean hitLast ; Get the item ID locally ( instead of getItemIdAtPosition ) , so we need the adapter T adapter = getAdapter ( ) ; if ( adapter = = null ) { return INVALID _ POSITION ; } while ( SystemClock . uptimeMillis ( ) < = endTime ) { rowId = adapter . getItemId ( seed ) ; if ( rowId = = idToMatch ) { Found it ! return seed ; } hitLast = last = = count - _NUM ; hitFirst = first = = _NUM ; if ( hitLast & & hitFirst ) { Looked at everything break ; } if ( hitFirst | | ( next & & ! hitLast ) ) { Either we hit the top , or we are trying to move down last + + ; seed = last ; Try going up next time next = false ; } else if ( hitLast | | ( ! next & & ! hitFirst ) ) { Either we hit the bottom , or we are trying to move up first - - ; seed = first ; Try going down next time next = true ; } } return INVALID _ POSITION ; } 
1959	public void enforceRestrictionOnPreference ( RestrictedPreference preference , String userRestriction , @ UserIdInt int userId ) { if ( preference = = null ) { return ; } if ( hasBaseUserRestriction ( userRestriction , userId ) ) { preference . setEnabled ( false ) ; } else { preference . checkRestrictionAndSetDisabled ( userRestriction , userId ) ; } } 
1960	public static int toInteger ( Object obj ) { Integer result = toIntegerObject ( obj ) ; return result = = null ? _NUM : result . intValue ( ) ; } 
1961	public Map < String , Object > addCategoryDefaults ( String catalogId , String categoryId , String itemGroupNumber ) { List < String > errorMsgs = new ArrayList < String > ( ) ; Map < String , Object > result = null ; String errMsg = null ; if ( UtilValidate . isEmpty ( categoryId ) ) { errMsg = UtilProperties . getMessage ( resource _ error , _STR , totalQuantity ) ; return result ; } 
1962	public String toString ( ) { String result ; result = super . toString ( ) ; remove _STR ; return result ; } 
1963	public static EntityManager createEntityManager ( String unitName ) { EntityManager em = null ; EntityManagerFactory factory = getFactory ( unitName ) ; if ( factory ! = null ) { em = factory . createEntityManager ( ) ; } return em ; } 
1964	public static String paramToQueryString ( Map < String , String > params , String charset ) { if ( params = = null | | params . isEmpty ( ) ) { return null ; } StringBuilder paramString = new StringBuilder ( ) ; boolean first = true ; for ( Entry < String , String > p : params . entrySet ( ) ) { String key = p . getKey ( ) ; String value = p . getValue ( ) ; if ( ! first ) { paramString . append ( _STR ) . append ( urlEncode ( value , charset ) ) ; } first = false ; } return paramString . toString ( ) ; } 
1965	public void register ( ) throws Exception { Register this object with the MBeanServer MBeanServer mbs = ManagementFactory . getPlatformMBeanServer ( ) ; if ( null = = getObjectName ( ) ) throw new IllegalArgumentException ( _STR ) ; mbs . registerMBean ( this , getObjectName ( ) ) ; setupLogging ( ) ; } 
1966	public void setReleaseLabel ( CharSequence releaseLabel , Mode mode ) { getLoadingLayoutProxy ( mode . showHeaderLoadingLayout ( ) , mode . showFooterLoadingLayout ( ) ) . setReleaseLabel ( releaseLabel ) ; } 
1967	protected boolean onForwardingStopped ( ) { final ShowableListMenu popup = getPopup ( ) ; if ( popup ! = null & & popup . isShowing ( ) ) { popup . dismiss ( ) ; } return true ; } 
1968	public BluetoothServerSocket listenUsingL _NUM capOn ( int port , boolean mitm , boolean min _NUM _NUM DigitPin ) throws IOException { BluetoothServerSocket socket = new BluetoothServerSocket ( BluetoothSocket . TYPE _ L _NUM CAP , true , true , port , mitm , min _NUM _NUM DigitPin ) ; int errno = socket . mSocket . bindListen ( ) ; if ( port = = SOCKET _ CHANNEL _ AUTO _ STATIC _ NO _ SDP ) { int assignedChannel = socket . mSocket . getPort ( ) ; if ( DBG ) Log . d ( TAG , _STR + errno ) ; } return socket ; } 
1969	public static boolean testPercentages ( double p _NUM bar , double p _NUM bar , int n _NUM , int n _NUM , boolean is _ twoTailed , double aLevel ) { if ( n _NUM < = _NUM | | p _NUM bar < _NUM | | n _NUM < = _NUM | | p _NUM bar < _NUM ) { throw new IllegalArgumentException ( _STR ) ; } standardize it double z = ( p _NUM bar - p _NUM bar ) / Math . sqrt ( p _NUM bar * ( _NUM . _NUM - p _NUM bar ) / n _NUM + p _NUM bar * ( _NUM . _NUM - p _NUM bar ) / n _NUM ) ; boolean rejectH _NUM = checkCriticalValue ( z , is _ twoTailed , aLevel ) ; return rejectH _NUM ; } 
1970	public Class getParameterDefinition ( final String name ) { if ( name . equals ( _STR ) ) { return Integer . TYPE ; } final int par = parseParameterName ( name ) ; if ( par < _NUM ) { return null ; } return Object . class ; } 
1971	public void setColorMultiply ( @ ColorInt int mul ) { if ( mMul ! = mul ) { mMul = mul ; discardNativeInstance ( ) ; } } 
1972	public void testOnMessage ( ) { runBase ( ) ; Map < SocketChannel , SocketChannelHelper > activeConnections = heronServer . getActiveConnections ( ) ; heronServer . onMessage ( activeConnections . keySet ( ) . iterator ( ) . next ( ) , null ) ; Assert . assertTrue ( isOnMessageInvoked ) ; } 
1973	default ReactiveSeq < T > deleteBetween ( int start , int end ) { long check = new Long ( start ) ; long endCheck = new Long ( end ) ; return zipWithIndex ( ) . flatMap ( t - > { if ( t . _ _NUM ( ) < check ) return ReactiveSeq . of ( t . _ _NUM ( ) ) ; if ( t . _ _NUM ( ) < endCheck ) { return ReactiveSeq . of ( ) ; } return ReactiveSeq . of ( t . _ _NUM ( ) ) ; } ) ; } 
1974	public boolean waitTableExclusiveLock ( final Procedure procedure , final TableName table ) { schedLock ( ) ; try { final String namespace = table . getNamespaceAsString ( ) ; final LockAndQueue namespaceLock = locking . getNamespaceLock ( namespace ) ; final LockAndQueue tableLock = locking . getTableLock ( table ) ; if ( ! namespaceLock . trySharedLock ( ) ) { waitProcedure ( namespaceLock , procedure ) ; logLockedResource ( LockedResourceType . NAMESPACE , namespace ) ; return true ; } if ( ! tableLock . tryExclusiveLock ( procedure ) ) { namespaceLock . releaseSharedLock ( ) ; waitProcedure ( tableLock , procedure ) ; logLockedResource ( LockedResourceType . TABLE , table . getNameAsString ( ) ) ; return true ; } removeFromRunQueue ( tableRunQueue , getTableQueue ( table ) ) ; return false ; } finally { schedUnlock ( ) ; } } 
1975	private String readLine ( String line , BufferedReader in ) throws IOException { line = line . trim ( ) ; boolean more = line . endsWith ( _STR ) ) { line = vars . expand ( line ) ; } return line ; } 
1976	public void testSimpleAppend ( ) throws IOException { final Configuration conf = new HdfsConfiguration ( ) ; if ( simulatedStorage ) { SimulatedFSDataset . setFactory ( conf ) ; } conf . setInt ( DFSConfigKeys . DFS _ DATANODE _ HANDLER _ COUNT _ KEY , _NUM _NUM ) ; fileContents = AppendTestUtil . initBuffer ( AppendTestUtil . FILE _ SIZE ) ; MiniDFSCluster cluster = new MiniDFSCluster . Builder ( conf ) . build ( ) ; FileSystem fs = cluster . getFileSystem ( ) ; try { { test appending to a file . create a new file . Path file _NUM = new Path ( _STR + e ) ; } finally { fs . close ( ) ; cluster . shutdown ( ) ; } } 
1977	public Range < Double > getSupportedFrameRatesFor ( int width , int height ) { Range < Integer > range = mHeightRange ; if ( ! supports ( width , height , null ) ) { throw new IllegalArgumentException ( _STR ) ; } final int blockCount = Utils . divUp ( width , mBlockWidth ) * Utils . divUp ( height , mBlockHeight ) ; return Range . create ( Math . max ( mBlocksPerSecondRange . getLower ( ) / ( double ) blockCount , ( double ) mFrameRateRange . getLower ( ) ) , Math . min ( mBlocksPerSecondRange . getUpper ( ) / ( double ) blockCount , ( double ) mFrameRateRange . getUpper ( ) ) ) ; } 
1978	public static String getCommonPrefixPath ( String first , String second ) { List < String > firstComponents = getPathComponents ( first ) ; List < String > secondComponents = getPathComponents ( second ) ; int minSize = Math . min ( firstComponents . size ( ) , secondComponents . size ( ) ) ; StringBuffer resultBuffer = new StringBuffer ( ) ; for ( int i = _NUM ; i < minSize ; i + + ) { if ( firstComponents . get ( i ) . equals ( secondComponents . get ( i ) ) ) { resultBuffer . append ( _STR ; } return result ; } 
1979	public float getFloat ( String name , float defaultValue ) { String valueString = get ( name ) ; if ( valueString = = null ) return defaultValue ; try { return Float . parseFloat ( valueString ) ; } catch ( NumberFormatException e ) { return defaultValue ; } } 
1980	public void addCookie ( final RequestContext requestContext , final String cookieValue ) { final HttpServletRequest request = WebUtils . getHttpServletRequestFromExternalWebflowContext ( requestContext ) ; final HttpServletResponse response = WebUtils . getHttpServletResponseFromExternalWebflowContext ( requestContext ) ; final String theCookieValue = this . casCookieValueManager . buildCookieValue ( cookieValue , request ) ; if ( isRememberMeAuthentication ( requestContext ) ) { LOGGER . debug ( _STR , getCookieName ( ) ) ; super . addCookie ( response , theCookieValue ) ; } } 
1981	public Iterator getSignatureAlgNames ( ) { return X _NUM _NUM _NUM Util . getAlgNames ( ) ; } 
1982	private synchronized void decrementSafeBlockCount ( short replication ) { if ( replication = = safeReplication - _NUM ) { this . blockSafe - - ; blockSafe is set to - _NUM in manual / low resources safemode assert blockSafe > = _NUM | | isManual ( ) | | areResourcesLow ( ) ; checkMode ( ) ; } } 
1983	 @ GET @ Consumes ( MediaType . WILDCARD ) @ Produces ( MediaType . APPLICATION _ JSON ) necessary due to a bug in swagger @ Path ( _STR ) ; } return replicate ( HttpMethod . GET , targetNode ) ; } } final CountersDTO countersReport = serviceFacade . getCounters ( ) ; create the response entity final CountersEntity entity = new CountersEntity ( ) ; entity . setCounters ( countersReport ) ; generate the response return generateOkResponse ( entity ) . build ( ) ; } 
1984	private void initializeDrawableForDisplay ( Drawable d ) { if ( mBlockInvalidateCallback = = null ) { mBlockInvalidateCallback = new BlockInvalidateCallback ( ) ; } Temporary fix for suspending callbacks during initialization . We don ' t want any of these setters causing an invalidate ( ) since that may call back into DrawableContainer . d . setCallback ( mBlockInvalidateCallback . wrap ( d . getCallback ( ) ) ) ; try { if ( mDrawableContainerState . mEnterFadeDuration < = _NUM & & mHasAlpha ) { d . setAlpha ( mAlpha ) ; } if ( mDrawableContainerState . mHasColorFilter ) { Color filter always overrides tint . d . setColorFilter ( mDrawableContainerState . mColorFilter ) ; } else { if ( mDrawableContainerState . mHasTintList ) { d . setTintList ( mDrawableContainerState . mTintList ) ; } if ( mDrawableContainerState . mHasTintMode ) { d . setTintMode ( mDrawableContainerState . mTintMode ) ; } } d . setVisible ( isVisible ( ) , true ) ; d . setDither ( mDrawableContainerState . mDither ) ; d . setState ( getState ( ) ) ; d . setLevel ( getLevel ( ) ) ; d . setBounds ( getBounds ( ) ) ; d . setLayoutDirection ( getLayoutDirection ( ) ) ; d . setAutoMirrored ( mDrawableContainerState . mAutoMirrored ) ; final Rect hotspotBounds = mHotspotBounds ; if ( hotspotBounds ! = null ) { d . setHotspotBounds ( hotspotBounds . left , hotspotBounds . top , hotspotBounds . right , hotspotBounds . bottom ) ; } } finally { d . setCallback ( mBlockInvalidateCallback . unwrap ( ) ) ; } } 
1985	public synchronized void halt ( ) { ArrayList < LPInterpreter > copy = new ArrayList < > ( activeInterpreters ) ; Copy because closing the LPInterpreter will detach it from this engine which affects activeInterpreters for ( LPInterpreter aCopy : copy ) { aCopy . close ( ) ; } } 
1986	public Path getWorkingDirectory ( ) { if ( workingDir = = null ) { workingDir = getHomeDirectory ( ) ; } return workingDir ; } 
1987	public Image fill ( int width , int height ) { if ( getWidth ( ) = = width & & getHeight ( ) = = height ) { return this ; } Image nimage = scaledLargerRatio ( width , height ) ; if ( nimage . getWidth ( ) > width ) { int diff = nimage . getWidth ( ) - width ; nimage = nimage . subImage ( diff / _NUM , _NUM , width , height , true ) ; } else { if ( nimage . getHeight ( ) > height ) { int diff = nimage . getHeight ( ) - height ; nimage = nimage . subImage ( _NUM , diff / _NUM , width , height , true ) ; } } return nimage ; } 
1988	public void clearWindowAnimationFrameStats ( ) { synchronized ( mLock ) { throwIfNotConnectedLocked ( ) ; } try { if ( DEBUG ) { Log . i ( LOG _ TAG , _STR , re ) ; } } 
1989	public E pollLast ( ) { if ( size = = _NUM ) return null ; return removeLast ( ) ; } 
1990	public void testActivitySignalEvents ( ) throws Exception { Two paths are active in the process , one receive - task and one intermediate catching signal - event ProcessInstance processInstance = runtimeService . startProcessInstanceByKey ( _STR , signalEvent . getSignalName ( ) ) ; assertNotNull ( signalEvent . getSignalData ( ) ) ; listener . clearEventsReceived ( ) ; assertDatabaseEventPresent ( ActivitiEventType . ACTIVITY _ SIGNALED ) ; } 
1991	public void testFormatWithNonInteractiveAndForce ( ) throws IOException { if ( ! hdfsDir . mkdirs ( ) ) { fail ( _STR ) ) ) ; } 
1992	 @ GET @ Path ( _STR ) String artifactName ) { ResourceInstance resource = createArtifactResource ( clusterName , artifactName ) ; return handleRequest ( headers , body , ui , Request . Type . GET , resource ) ; } 
1993	public void pauseAllWithType ( TransferType type ) { Cursor c = null ; try { c = dbUtil . queryAllTransfersWithType ( type ) ; while ( c . moveToNext ( ) ) { final int id = c . getInt ( c . getColumnIndexOrThrow ( TransferTable . COLUMN _ ID ) ) ; pause ( id ) ; } } finally { if ( c ! = null ) { c . close ( ) ; } } } 
1994	private boolean readNextEntryAndRecordReaderPosition ( ) throws IOException { Entry readEntry = reader . next ( ) ; long readerPos = reader . getPosition ( ) ; OptionalLong fileLength = walFileLengthProvider . getLogFileSizeIfBeingWritten ( currentPath ) ; if ( fileLength . isPresent ( ) & & readerPos > fileLength . getAsLong ( ) ) { data , so we need to make sure that we do not read beyond the committed file length . if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( _STR + readerPos ) ; } resetReader ( ) ; return true ; } if ( readEntry ! = null ) { metrics . incrLogEditsRead ( ) ; metrics . incrLogReadInBytes ( readerPos - currentPositionOfEntry ) ; } could be null currentEntry = readEntry ; this . currentPositionOfReader = readerPos ; return fileLength . isPresent ( ) ; } 
1995	public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( _STR ) ; return sb . toString ( ) ; } 
1996	public void pause ( ) { mRunLoop . pushEvent ( PAUSE _ EVENT ) ; } 
1997	public static Document parseXml ( final InputStream is , final String rootNames , final String forceNamespace ) throws Exception { final Document doc ; SAXParser parser ; final SAXParserFactory factory = SAXParserFactory . newInstance ( ) ; parser = factory . newSAXParser ( ) ; final DocumentBuilderFactory dbf = DocumentBuilderFactory . newInstance ( ) ; turn off validator and loading external dtd dbf . setValidating ( false ) ; dbf . setNamespaceAware ( true ) ; dbf . setFeature ( _STR ) ) ; } Outputs text accumulated under the current node private void addTextIfNeeded ( ) { if ( textBuffer . length ( ) > _NUM ) { final Element el = elementStack . isEmpty ( ) ? null : elementStack . peek ( ) ; if ( el ! = null ) { final Node textNode = doc . createTextNode ( textBuffer . toString ( ) ) ; el . appendChild ( textNode ) ; textBuffer . delete ( _NUM , textBuffer . length ( ) ) ; } } } } ; parser . parse ( is , handler ) ; return doc ; } 
1998	public static String compactPath ( String path ) { if ( path = = null ) { return null ; } only normalize if contains a path separator if ( path . indexOf ( File . separator ) = = - _NUM ) { return path ; } preserve ending slash if given in input path boolean endsWithSlash = path . endsWith ( _STR ) ; } } return sb . toString ( ) ; } 
1999	public static Parser rulesParserFromReader ( BufferedReader src , BuiltinRegistry registry ) { try { StringBuilder result = new StringBuilder ( ) ; String line ; Map < String , String > prefixes = new HashMap < > ( ) ; List < Rule > preloadedRules = new ArrayList < > ( ) ; while ( ( line = src . readLine ( ) ) ! = null ) { Skip comment lines if ( line . startsWith ( _STR ) ; } } Parser parser = new Parser ( result . toString ( ) , registry ) ; parser . registerPrefixMap ( prefixes ) ; parser . addRulesPreload ( preloadedRules ) ; return parser ; } catch ( IOException e ) { throw new WrappedIOException ( e ) ; } } 
2000	static synchronized void assertClosedShardsAreCoveredOrAbsent ( Map < String , Shard > shardIdToShardMap , Map < String , Set < String > > shardIdToChildShardIdsMap , Set < String > shardIdsOfClosedShards ) throws KinesisClientLibIOException { String exceptionMessageSuffix = _STR + exceptionMessageSuffix ) ; } assertHashRangeOfClosedShardIsCovered ( shard , shardIdToShardMap , childShardIds ) ; } } 
2001	public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { Log . e ( TAG , _STR + newVersion ) ; } } 
2002	public static IndexReader subReader ( IndexReader reader , int subIndex ) { List < IndexReader > subReadersList = new ArrayList < IndexReader > ( ) ; ReaderUtil . gatherSubReaders ( subReadersList , reader ) ; IndexReader [ ] subReaders = subReadersList . toArray ( new IndexReader [ subReadersList . size ( ) ] ) ; return subReaders [ subIndex ] ; } 
2003	public void testSmallBlock ( ) throws IOException { Configuration conf = new HdfsConfiguration ( ) ; if ( simulatedStorage ) { SimulatedFSDataset . setFactory ( conf ) ; } conf . set ( DFSConfigKeys . DFS _ BYTES _ PER _ CHECKSUM _ KEY , _STR ) ; writeFile ( fileSys , file _NUM ) ; checkFile ( fileSys , file _NUM ) ; cleanupFile ( fileSys , file _NUM ) ; } finally { fileSys . close ( ) ; cluster . shutdown ( ) ; } } 
2004	public ECFieldElement sqrt ( ) { int [ ] c = this . x ; if ( Nat _NUM _NUM _NUM . isZero ( c ) | | Nat _NUM _NUM _NUM . isOne ( c ) ) { return this ; } int [ ] nc = Nat _NUM _NUM _NUM . create ( ) ; SecP _NUM _NUM _NUM R _NUM Field . negate ( c , nc ) ; int [ ] r = Mod . random ( SecP _NUM _NUM _NUM R _NUM Field . P ) ; int [ ] t = Nat _NUM _NUM _NUM . create ( ) ; if ( ! isSquare ( c ) ) { return null ; } while ( ! trySqrt ( nc , r , t ) ) { SecP _NUM _NUM _NUM R _NUM Field . addOne ( r , r ) ; } SecP _NUM _NUM _NUM R _NUM Field . square ( t , r ) ; return Nat _NUM _NUM _NUM . eq ( c , r ) ? new SecP _NUM _NUM _NUM R _NUM FieldElement ( t ) : null ; } 
2005	public org . fife . ui . rsyntaxtextarea . Token yylex ( ) throws java . io . IOException { int zzInput ; int zzAction ; cached fields : int zzCurrentPosL ; int zzMarkedPosL ; int zzEndReadL = zzEndRead ; char [ ] zzBufferL = zzBuffer ; char [ ] zzCMapL = ZZ _ CMAP ; int [ ] zzTransL = ZZ _ TRANS ; int [ ] zzRowMapL = ZZ _ ROWMAP ; int [ ] zzAttrL = ZZ _ ATTRIBUTE ; while ( true ) { zzMarkedPosL = zzMarkedPos ; zzAction = - _NUM ; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL ; zzState = zzLexicalState ; zzForAction : { while ( true ) { if ( zzCurrentPosL < zzEndReadL ) zzInput = zzBufferL [ zzCurrentPosL + + ] ; else if ( zzAtEOF ) { zzInput = YYEOF ; break zzForAction ; } else { store back cached positions zzCurrentPos = zzCurrentPosL ; zzMarkedPos = zzMarkedPosL ; boolean eof = zzRefill ( ) ; get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos ; zzMarkedPosL = zzMarkedPos ; zzBufferL = zzBuffer ; zzEndReadL = zzEndRead ; if ( eof ) { zzInput = YYEOF ; break zzForAction ; } else { zzInput = zzBufferL [ zzCurrentPosL + + ] ; } } int zzNext = zzTransL [ zzRowMapL [ zzState ] + zzCMapL [ zzInput ] ] ; if ( zzNext = = - _NUM ) break zzForAction ; zzState = zzNext ; int zzAttributes = zzAttrL [ zzState ] ; if ( ( zzAttributes & _NUM ) = = _NUM ) { zzAction = zzState ; zzMarkedPosL = zzCurrentPosL ; if ( ( zzAttributes & _NUM ) = = _NUM ) break zzForAction ; } } } store back cached position zzMarkedPos = zzMarkedPosL ; switch ( zzAction < _NUM ? zzAction : ZZ _ ACTION [ zzAction ] ) { case _NUM _NUM : { int temp = zzMarkedPos ; addToken ( start , zzStartRead + _NUM , Token . MARKUP _ COMMENT ) ; start = temp ; yybegin ( prevState ) ; } case _NUM _NUM : break ; case _NUM _NUM : { yybegin ( INTAG ) ; addToken ( start , zzStartRead , Token . MARKUP _ TAG _ ATTRIBUTE _ VALUE ) ; } case _NUM _NUM : break ; case _NUM : { addNullToken ( ) ; return firstToken ; } case _NUM _NUM : break ; case _NUM _NUM : { int temp = zzStartRead ; addToken ( start , zzStartRead - _NUM , Token . MARKUP _ DTD ) ; start = temp ; prevState = zzLexicalState ; yybegin ( COMMENT ) ; } case _NUM _NUM : break ; case _NUM _NUM : { inInternalDtd = false ; } case _NUM _NUM : break ; case _NUM : { addToken ( Token . MARKUP _ TAG _ DELIMITER ) ; yybegin ( INTAG ) ; } case _NUM _NUM : break ; case _NUM _NUM : { int count = yylength ( ) ; addToken ( zzStartRead , zzStartRead + _NUM , Token . MARKUP _ TAG _ DELIMITER ) ; addToken ( zzMarkedPos - ( count - _NUM ) , zzMarkedPos - _NUM , Token . MARKUP _ TAG _ NAME ) ; yybegin ( INTAG ) ; } case _NUM _NUM : break ; case _NUM : { addToken ( start , zzStartRead - _NUM , Token . MARKUP _ DTD ) ; addEndToken ( inInternalDtd ? INTERNAL _ DTD _ INTERNAL : INTERNAL _ DTD ) ; return firstToken ; } case _NUM _NUM : break ; case _NUM _NUM : { addToken ( Token . MARKUP _ TAG _ DELIMITER ) ; } case _NUM _NUM : break ; case _NUM : { addToken ( start , zzStartRead - _NUM , Token . MARKUP _ COMMENT ) ; addEndToken ( INTERNAL _ IN _ XML _ COMMENT - prevState ) ; return firstToken ; } case _NUM _NUM : break ; case _NUM : { addToken ( Token . WHITESPACE ) ; } case _NUM _NUM : break ; case _NUM _NUM : { start = zzStartRead ; prevState = zzLexicalState ; yybegin ( COMMENT ) ; } case _NUM _NUM : break ; case _NUM _NUM : { int temp = zzStartRead ; yybegin ( YYINITIAL ) ; addToken ( start , zzStartRead - _NUM , Token . MARKUP _ CDATA ) ; addToken ( temp , zzMarkedPos - _NUM , Token . MARKUP _ CDATA _ DELIMITER ) ; } case _NUM _NUM : break ; case _NUM : { addToken ( Token . MARKUP _ ENTITY _ REFERENCE ) ; } case _NUM _NUM : break ; case _NUM _NUM : { if ( ! inInternalDtd ) { yybegin ( YYINITIAL ) ; addToken ( start , zzStartRead , Token . MARKUP _ DTD ) ; } } case _NUM _NUM : break ; case _NUM : { addToken ( Token . IDENTIFIER ) ; } case _NUM _NUM : break ; case _NUM _NUM : { inInternalDtd = true ; } case _NUM _NUM : break ; case _NUM _NUM : { yybegin ( YYINITIAL ) ; addToken ( start , zzStartRead + _NUM , Token . MARKUP _ PROCESSING _ INSTRUCTION ) ; } case _NUM _NUM : break ; case _NUM _NUM : { start = zzMarkedPos - _NUM ; inInternalDtd = false ; yybegin ( DTD ) ; } case _NUM _NUM : break ; case _NUM _NUM : { int count = yylength ( ) ; addToken ( zzStartRead , zzStartRead , Token . MARKUP _ TAG _ DELIMITER ) ; addToken ( zzMarkedPos - ( count - _NUM ) , zzMarkedPos - _NUM , Token . MARKUP _ TAG _ NAME ) ; yybegin ( INTAG ) ; } case _NUM _NUM : break ; case _NUM _NUM : { start = zzMarkedPos - _NUM ; yybegin ( PI ) ; } case _NUM _NUM : break ; case _NUM : { addToken ( start , zzStartRead - _NUM , Token . MARKUP _ PROCESSING _ INSTRUCTION ) ; return firstToken ; } case _NUM _NUM : break ; case _NUM _NUM : { start = zzMarkedPos - _NUM ; yybegin ( INATTR _ DOUBLE ) ; } case _NUM _NUM : break ; case _NUM _NUM : { int temp = zzStartRead ; addToken ( start , zzStartRead - _NUM , Token . MARKUP _ COMMENT ) ; addHyperlinkToken ( temp , zzMarkedPos - _NUM , Token . MARKUP _ COMMENT ) ; start = zzMarkedPos ; } case _NUM _NUM : break ; case _NUM _NUM : { yybegin ( YYINITIAL ) ; addToken ( Token . MARKUP _ TAG _ DELIMITER ) ; } case _NUM _NUM : break ; case _NUM _NUM : { start = zzMarkedPos - _NUM ; yybegin ( INATTR _ SINGLE ) ; } case _NUM _NUM : break ; case _NUM _NUM : { addToken ( Token . OPERATOR ) ; } case _NUM _NUM : break ; case _NUM _NUM : { addToken ( Token . MARKUP _ CDATA _ DELIMITER ) ; start = zzMarkedPos ; yybegin ( CDATA ) ; } case _NUM _NUM : break ; case _NUM _NUM : { addToken ( Token . MARKUP _ TAG _ ATTRIBUTE ) ; } case _NUM _NUM : break ; case _NUM : { } case _NUM _NUM : break ; default : if ( zzInput = = YYEOF & & zzStartRead = = zzCurrentPos ) { zzAtEOF = true ; switch ( zzLexicalState ) { case INTAG : { addToken ( start , zzStartRead - _NUM , INTERNAL _ INTAG ) ; return firstToken ; } case _NUM _NUM : break ; case DTD : { addToken ( start , zzStartRead - _NUM , Token . MARKUP _ DTD ) ; addEndToken ( inInternalDtd ? INTERNAL _ DTD _ INTERNAL : INTERNAL _ DTD ) ; return firstToken ; } case _NUM _NUM : break ; case INATTR _ DOUBLE : { addToken ( start , zzStartRead - _NUM , Token . MARKUP _ TAG _ ATTRIBUTE _ VALUE ) ; addEndToken ( INTERNAL _ ATTR _ DOUBLE ) ; return firstToken ; } case _NUM _NUM : break ; case YYINITIAL : { addNullToken ( ) ; return firstToken ; } case _NUM _NUM : break ; case COMMENT : { addToken ( start , zzStartRead - _NUM , Token . MARKUP _ COMMENT ) ; addEndToken ( INTERNAL _ IN _ XML _ COMMENT - prevState ) ; return firstToken ; } case _NUM _NUM : break ; case CDATA : { addToken ( start , zzStartRead - _NUM , Token . MARKUP _ CDATA ) ; return firstToken ; } case _NUM _NUM : break ; case INATTR _ SINGLE : { addToken ( start , zzStartRead - _NUM , Token . MARKUP _ TAG _ ATTRIBUTE _ VALUE ) ; addEndToken ( INTERNAL _ ATTR _ SINGLE ) ; return firstToken ; } case _NUM _NUM : break ; case PI : { addToken ( start , zzStartRead - _NUM , Token . MARKUP _ PROCESSING _ INSTRUCTION ) ; return firstToken ; } case _NUM _NUM : break ; default : return null ; } } else { zzScanError ( ZZ _ NO _ MATCH ) ; } } } } 
2006	public void drawItem ( Graphics _NUM D g _NUM , XYItemRendererState state , Rectangle _NUM D dataArea , PlotRenderingInfo info , XYPlot plot , ValueAxis domainAxis , ValueAxis rangeAxis , XYDataset dataset , int series , int item , CrosshairState crosshairState , int pass ) { if ( ! getItemVisible ( series , item ) ) { return ; } get the data point . . . double x _NUM = dataset . getXValue ( series , item ) ; double y _NUM = dataset . getYValue ( series , item ) ; if ( Double . isNaN ( y _NUM ) ) { y _NUM = _NUM . _NUM ; } double transX _NUM = domainAxis . valueToJava _NUM D ( x _NUM , dataArea , plot . getDomainAxisEdge ( ) ) ; double transY _NUM = rangeAxis . valueToJava _NUM D ( y _NUM , dataArea , plot . getRangeAxisEdge ( ) ) ; get the previous point and the next point so we can calculate a _STR for the area ( used by the chart entity ) . . . double x _NUM = dataset . getXValue ( series , Math . max ( item - _NUM , _NUM ) ) ; double y _NUM = dataset . getYValue ( series , Math . max ( item - _NUM , _NUM ) ) ; if ( Double . isNaN ( y _NUM ) ) { y _NUM = _NUM . _NUM ; } double transX _NUM = domainAxis . valueToJava _NUM D ( x _NUM , dataArea , plot . getDomainAxisEdge ( ) ) ; double transY _NUM = rangeAxis . valueToJava _NUM D ( y _NUM , dataArea , plot . getRangeAxisEdge ( ) ) ; int itemCount = dataset . getItemCount ( series ) ; double x _NUM = dataset . getXValue ( series , Math . min ( item + _NUM , itemCount - _NUM ) ) ; double y _NUM = dataset . getYValue ( series , Math . min ( item + _NUM , itemCount - _NUM ) ) ; if ( Double . isNaN ( y _NUM ) ) { y _NUM = _NUM . _NUM ; } double transX _NUM = domainAxis . valueToJava _NUM D ( x _NUM , dataArea , plot . getDomainAxisEdge ( ) ) ; double transY _NUM = rangeAxis . valueToJava _NUM D ( y _NUM , dataArea , plot . getRangeAxisEdge ( ) ) ; double transZero = rangeAxis . valueToJava _NUM D ( _NUM . _NUM , dataArea , plot . getRangeAxisEdge ( ) ) ; Polygon hotspot = null ; if ( plot . getOrientation ( ) = = PlotOrientation . HORIZONTAL ) { hotspot = new Polygon ( ) ; hotspot . addPoint ( ( int ) transZero , ( int ) ( ( transX _NUM + transX _NUM ) / _NUM . _NUM ) ) ; hotspot . addPoint ( ( int ) ( ( transY _NUM + transY _NUM ) / _NUM . _NUM ) , ( int ) ( ( transX _NUM + transX _NUM ) / _NUM . _NUM ) ) ; hotspot . addPoint ( ( int ) transY _NUM , ( int ) transX _NUM ) ; hotspot . addPoint ( ( int ) ( ( transY _NUM + transY _NUM ) / _NUM . _NUM ) , ( int ) ( ( transX _NUM + transX _NUM ) / _NUM . _NUM ) ) ; hotspot . addPoint ( ( int ) transZero , ( int ) ( ( transX _NUM + transX _NUM ) / _NUM . _NUM ) ) ; } else { vertical orientation hotspot = new Polygon ( ) ; hotspot . addPoint ( ( int ) ( ( transX _NUM + transX _NUM ) / _NUM . _NUM ) , ( int ) transZero ) ; hotspot . addPoint ( ( int ) ( ( transX _NUM + transX _NUM ) / _NUM . _NUM ) , ( int ) ( ( transY _NUM + transY _NUM ) / _NUM . _NUM ) ) ; hotspot . addPoint ( ( int ) transX _NUM , ( int ) transY _NUM ) ; hotspot . addPoint ( ( int ) ( ( transX _NUM + transX _NUM ) / _NUM . _NUM ) , ( int ) ( ( transY _NUM + transY _NUM ) / _NUM . _NUM ) ) ; hotspot . addPoint ( ( int ) ( ( transX _NUM + transX _NUM ) / _NUM . _NUM ) , ( int ) transZero ) ; } PlotOrientation orientation = plot . getOrientation ( ) ; Paint paint = getItemPaint ( series , item ) ; Stroke stroke = getItemStroke ( series , item ) ; g _NUM . setPaint ( paint ) ; g _NUM . setStroke ( stroke ) ; Check if the item is the last item for the series . and number of items > _NUM . We can ' t draw an area for a single point . g _NUM . fill ( hotspot ) ; draw an outline around the Area . if ( isOutline ( ) ) { g _NUM . setStroke ( lookupSeriesOutlineStroke ( series ) ) ; g _NUM . setPaint ( lookupSeriesOutlinePaint ( series ) ) ; g _NUM . draw ( hotspot ) ; } int domainAxisIndex = plot . getDomainAxisIndex ( domainAxis ) ; int rangeAxisIndex = plot . getRangeAxisIndex ( rangeAxis ) ; updateCrosshairValues ( crosshairState , x _NUM , y _NUM , domainAxisIndex , rangeAxisIndex , transX _NUM , transY _NUM , orientation ) ; collect entity and tool tip information . . . if ( state . getInfo ( ) ! = null ) { EntityCollection entities = state . getEntityCollection ( ) ; if ( entities ! = null & & hotspot ! = null ) { String tip = null ; XYToolTipGenerator generator = getToolTipGenerator ( series , item ) ; if ( generator ! = null ) { tip = generator . generateToolTip ( dataset , series , item ) ; } String url = null ; if ( getURLGenerator ( ) ! = null ) { url = getURLGenerator ( ) . generateURL ( dataset , series , item ) ; } XYItemEntity entity = new XYItemEntity ( hotspot , dataset , series , item , tip , url ) ; entities . add ( entity ) ; } } } 
2007	public void undoRename _NUM ScrParent ( final INodeReference oldChild , final INode newChild ) throws QuotaExceededException { DirectoryWithSnapshotFeature sf = getDirectoryWithSnapshotFeature ( ) ; assert sf ! = null : _STR ; sf . getDiffs ( ) . removeChild ( ListType . DELETED , oldChild ) ; sf . getDiffs ( ) . replaceChild ( ListType . CREATED , oldChild , newChild ) ; addChild ( newChild , true , Snapshot . CURRENT _ STATE _ ID ) ; } 
2008	public static String strip ( String str , final String stripChars ) { if ( isEmpty ( str ) ) { return str ; } str = stripStart ( str , stripChars ) ; return stripEnd ( str , stripChars ) ; } 
2009	protected String capitalizeTitle ( String title ) { StringTokenizer str = new StringTokenizer ( title ) ; String resultTitle = _STR ; } return ( Character . toUpperCase ( resultTitle . charAt ( _NUM ) ) + resultTitle . substring ( _NUM ) ) . trim ( ) ; } 
2010	public void setRotationX ( float rotationX ) { if ( rotationX ! = getRotationX ( ) ) { invalidateViewProperty ( true , false ) ; mRenderNode . setRotationX ( rotationX ) ; invalidateViewProperty ( false , true ) ; invalidateParentIfNeededAndWasQuickRejected ( ) ; notifySubtreeAccessibilityStateChangedIfNeeded ( ) ; } } 
2011	public void setCurrentPlayTime ( long playTime ) { initAnimation ( ) ; long currentTime = AnimationUtils . currentAnimationTimeMillis ( ) ; if ( mPlayingState ! = RUNNING ) { mSeekTime = playTime ; mPlayingState = SEEKED ; } mStartTime = currentTime - playTime ; animationFrame ( currentTime ) ; } 
2012	public void write ( byte [ ] b , int off , int len ) throws IOException { must always verify the invariant that at least METASIZE bytes are available beyond kvindex , even when len = = _NUM bufferRemaining - = len ; if ( bufferRemaining < = _NUM ) { writing these bytes could exhaust available buffer space or fill the buffer to soft limit . check if spill or blocking are necessary boolean blockwrite = false ; spillLock . lock ( ) ; try { do { checkSpillException ( ) ; final int kvbidx = _NUM * kvindex ; final int kvbend = _NUM * kvend ; ser distance to key index final int distkvi = distanceTo ( bufindex , kvbidx ) ; ser distance to spill end index final int distkve = distanceTo ( bufindex , kvbend ) ; if kvindex is closer than kvend , then a spill is neither in progress nor complete and reset since the lock was held . The write should block only if there is insufficient space to complete the current write , write the metadata for this record , and write the metadata for the next record . If kvend is closer , then the write should block if there is too little space for either the metadata or the current write . Note that collect ensures its metadata requirement with a zero - length write blockwrite = distkvi < = distkve ? distkvi < = len + _NUM * METASIZE : distkve < = len | | distanceTo ( bufend , kvbidx ) < _NUM * METASIZE ; if ( ! spillInProgress ) { if ( blockwrite ) { if ( ( kvbend + METASIZE ) % kvbuffer . length ! = equator - ( equator % METASIZE ) ) { spill finished , reclaim space need to use meta exclusively ; zero - len rec & _NUM _NUM _NUM % spill pcnt would fail resetSpill doesn ' t move bufindex , kvindex resetSpill ( ) ; bufferRemaining = Math . min ( distkvi - _NUM * METASIZE , softLimit - distanceTo ( kvbidx , bufindex ) ) - len ; continue ; } we have records we can spill ; only spill if blocked if ( kvindex ! = kvend ) { startSpill ( ) ; Blocked on this write , waiting for the spill just initiated to finish . Instead of repositioning the marker and copying the partial record , we set the record start to be the new equator setEquator ( bufmark ) ; } else { We have no buffered records , and this record is too large to write into kvbuffer . We must spill it directly from collect final int size = distanceTo ( bufstart , bufindex ) + len ; setEquator ( _NUM ) ; bufstart = bufend = bufindex = equator ; kvstart = kvend = kvindex ; bufvoid = kvbuffer . length ; throw new MapBufferTooSmallException ( size + _STR , e ) ; } } } while ( blockwrite ) ; } finally { spillLock . unlock ( ) ; } } here , we know that we have sufficient space to write if ( bufindex + len > bufvoid ) { final int gaplen = bufvoid - bufindex ; System . arraycopy ( b , off , kvbuffer , bufindex , gaplen ) ; len - = gaplen ; off + = gaplen ; bufindex = _NUM ; } System . arraycopy ( b , off , kvbuffer , bufindex , len ) ; bufindex + = len ; } 
2013	private void createConfigGroupsAndRegisterHost ( ClusterTopology topology , String groupName ) throws AmbariException { Map < String , Map < String , Config > > groupConfigs = new HashMap < > ( ) ; Stack stack = topology . getBlueprint ( ) . getStack ( ) ; get the host - group config with cluster creation template overrides Configuration topologyHostGroupConfig = topology . getHostGroupInfo ( ) . get ( groupName ) . getConfiguration ( ) ; only get user provided configuration for host group which includes only CCT / HG and BP / HG properties Map < String , Map < String , String > > userProvidedGroupProperties = topologyHostGroupConfig . getFullProperties ( _NUM ) ; iterate over topo host group configs which were defined in for ( Map . Entry < String , Map < String , String > > entry : userProvidedGroupProperties . entrySet ( ) ) { String type = entry . getKey ( ) ; List < String > services = stack . getServicesForConfigType ( type ) ; String service = services . stream ( ) . filter ( each - > topology . getBlueprint ( ) . getServices ( ) . contains ( each ) ) . findFirst ( ) . orElseThrow ( ( ) - > new IllegalArgumentException ( _STR + e , e ) ; } } } 
2014	public boolean isFatalEnabled ( ) { return log . isErrorEnabled ( ) ; } 
2015	synchronized void cleanup ( ) { mLogRecVector . clear ( ) ; } 
2016	public static void validateOptions ( Class < ? > implementingClass , Configuration conf ) throws IOException { Map < String , InputTableConfig > inputTableConfigs = getInputTableConfigs ( implementingClass , conf ) ; if ( ! isConnectorInfoSet ( implementingClass , conf ) ) throw new IOException ( _STR + SortedKeyValueIterator . class . getName ( ) ) ; } } } } } catch ( AccumuloException | TableNotFoundException | AccumuloSecurityException e ) { throw new IOException ( e ) ; } } 
2017	public void testIOExceptionInWriterConstructor ( ) { Path dirNameSpy = spy ( TEST _ FILE ) ; BloomMapFile . Reader reader = null ; BloomMapFile . Writer writer = null ; try { writer = new BloomMapFile . Writer ( conf , TEST _ FILE , MapFile . Writer . keyClass ( IntWritable . class ) , MapFile . Writer . valueClass ( Text . class ) ) ; writer . append ( new IntWritable ( _NUM ) , new Text ( _STR ) ; } finally { IOUtils . cleanup ( null , writer , reader ) ; } } 
2018	public void testUnlinkingReplicasInFileDescriptorCache ( ) throws Exception { BlockReaderTestUtil . enableShortCircuitShmTracing ( ) ; TemporarySocketDirectory sockDir = new TemporarySocketDirectory ( ) ; Configuration conf = createShortCircuitConf ( _STR , e ) ; } return done . booleanValue ( ) ; } } , _NUM _NUM , _NUM _NUM _NUM _NUM _NUM ) ; cluster . shutdown ( ) ; sockDir . close ( ) ; } 
2019	public boolean inRanges ( Instance instance , double [ ] [ ] ranges ) { boolean isIn = true ; updateRangesFirst must have been called on ranges for ( int j = _NUM ; isIn & & ( j < ranges . length ) ; j + + ) { if ( ! instance . isMissing ( j ) ) { double value = instance . value ( j ) ; isIn = value < = ranges [ j ] [ R _ MAX ] ; if ( isIn ) isIn = value > = ranges [ j ] [ R _ MIN ] ; } } return isIn ; } 
2020	public void testAccessDenied ( ) throws Exception { FileUtil . fullyDelete ( new File ( _STR ) ) ; } 
2021	public void postUrl ( String url , byte [ ] postData ) { checkThread ( ) ; if ( URLUtil . isNetworkUrl ( url ) ) { mProvider . postUrl ( url , postData ) ; } else { mProvider . loadUrl ( url ) ; } } 
2022	private static byte [ ] ntlmv _NUM Hash ( String target , String user , String password ) throws NTLMEngineException { try { byte [ ] ntlmHash = ntlmHash ( password ) ; HMACMD _NUM hmacMD _NUM = new HMACMD _NUM ( ntlmHash ) ; Upper case username , mixed case target ! ! hmacMD _NUM . update ( user . toUpperCase ( Locale . US ) . getBytes ( _STR + e . getMessage ( ) , e ) ; } } 
2023	public static Object [ ] createCertPath ( X _NUM _NUM _NUM Certificate signerCert , Set trustanchors , List systemCertStores , List userCertStores ) throws GeneralSecurityException { Set certSet = new LinkedHashSet ( ) ; List userProvidedList = new ArrayList ( ) ; add signer certificate X _NUM _NUM _NUM Certificate cert = signerCert ; certSet . add ( cert ) ; userProvidedList . add ( new Boolean ( true ) ) ; boolean trustAnchorFound = false ; X _NUM _NUM _NUM Certificate taCert = null ; add other certs to the cert path while ( cert ! = null & & ! trustAnchorFound ) { check if cert Issuer is Trustanchor Iterator trustIt = trustanchors . iterator ( ) ; while ( trustIt . hasNext ( ) ) { TrustAnchor anchor = ( TrustAnchor ) trustIt . next ( ) ; X _NUM _NUM _NUM Certificate anchorCert = anchor . getTrustedCert ( ) ; if ( anchorCert ! = null ) { if ( anchorCert . getSubjectX _NUM _NUM _NUM Principal ( ) . equals ( cert . getIssuerX _NUM _NUM _NUM Principal ( ) ) ) { try { cert . verify ( anchorCert . getPublicKey ( ) , _STR ) . generateCertPath ( new ArrayList ( certSet ) ) ; return new Object [ ] { certPath , userProvidedList } ; } 
2024	public void TXBegin ( ) { WWTXBegin ( ) ; } 
2025	public VpcEndpoint withRouteTableIds ( String . . . routeTableIds ) { if ( getRouteTableIds ( ) = = null ) setRouteTableIds ( new java . util . ArrayList < String > ( routeTableIds . length ) ) ; for ( String value : routeTableIds ) { getRouteTableIds ( ) . add ( value ) ; } return this ; } 
2026	public int getMaxTransceiveLength ( ) { return getMaxTransceiveLengthInternal ( ) ; } 
2027	public void testRbwBlocksNotConsideredUnderReplicated ( ) throws IOException { List < FSDataOutputStream > stms = Lists . newArrayList ( ) ; try { Create some junk blocks so that the NN doesn ' t just immediately exit safemode on restart . DFSTestUtil . createFile ( fs , new Path ( _STR + i ) , true , BLOCK _ SIZE , ( short ) _NUM , BLOCK _ SIZE ) ; stms . add ( stm ) ; stm . write ( _NUM ) ; stm . hflush ( ) ; } cluster . restartNameNode ( ) ; FSNamesystem ns = cluster . getNameNode ( _NUM ) . getNamesystem ( ) ; BlockManagerTestUtil . updateState ( ns . getBlockManager ( ) ) ; assertEquals ( _NUM , ns . getPendingReplicationBlocks ( ) ) ; assertEquals ( _NUM , ns . getCorruptReplicaBlocks ( ) ) ; assertEquals ( _NUM , ns . getMissingBlocksCount ( ) ) ; } finally { for ( FSDataOutputStream stm : stms ) { IOUtils . closeStream ( stm ) ; } cluster . shutdown ( ) ; } } 
2028	public void deletePath ( String path ) { if ( path = = null ) { return ; } String [ ] pathComponents = path . split ( _STR , parent ) ; } TrieNode realParent = parent . getParent ( ) ; realParent . deleteChild ( part ) ; } 
2029	protected void adjust ( ) { mDynamicLabelFormatter . setViewport ( mViewport ) ; if ( mVerticalLabels ! = null ) { if ( mVerticalLabels . length < _NUM ) { throw new IllegalStateException ( _STR ) ; } mGraphView . getGridLabelRenderer ( ) . setNumHorizontalLabels ( mHorizontalLabels . length ) ; } } 
2030	public double doubleValue ( ) { return getDoubleValue ( ) ; } 
2031	public void processMessage ( ) { if ( clipboard . isTracking ( this . originatorId , this . getTaskId ( ) ) ) { clipboard . pin ( this ) ; if ( clipboard . isReady ( this . originatorId , taskId ) ) { VoidAggregation aggregation = clipboard . unpin ( this . originatorId , taskId ) ; FIXME : probably there ' s better solution , then _STR one if ( aggregation = = null ) return ; VectorCompleteMessage msg = new VectorCompleteMessage ( taskId , aggregation . getAccumulatedResult ( ) ) ; msg . setOriginatorId ( aggregation . getOriginatorId ( ) ) ; transport . sendMessage ( msg ) ; } } } 
2032	public boolean getBoolean ( final Object key , final boolean defaultValue ) { final Object value = getValue ( key ) ; if ( value instanceof Boolean ) { return ( Boolean ) value ; } return ( value = = null ) ? defaultValue : Boolean . parseBoolean ( value . toString ( ) ) ; } 
2033	public synchronized int getResponseCode ( ) throws IOException { if ( ( mReplyHeader . responseCode = = - _NUM ) | | ( mReplyHeader . responseCode = = ResponseCodes . OBEX _ HTTP _ CONTINUE ) ) { validateConnection ( ) ; } return mReplyHeader . responseCode ; } 
2034	protected void onDayTapped ( CalendarDay day ) { mController . tryVibrate ( ) ; mController . onDayOfMonthSelected ( day . year , day . month , day . day ) ; setSelectedDay ( day ) ; } 
2035	public long getEarliestStartTime ( ) { readLock . lock ( ) ; try { if ( cumulativeCapacity . isEmpty ( ) ) { return - _NUM ; } else { return cumulativeCapacity . firstKey ( ) ; } } finally { readLock . unlock ( ) ; } } 
2036	public boolean dismissPopup ( ) { if ( isShowingPopup ( ) ) { getListPopupWindow ( ) . dismiss ( ) ; ViewTreeObserver viewTreeObserver = getViewTreeObserver ( ) ; if ( viewTreeObserver . isAlive ( ) ) { viewTreeObserver . removeGlobalOnLayoutListener ( mOnGlobalLayoutListener ) ; } } return true ; } 
2037	private Scan createScanForReadRegionServerLastLogRollResult ( String backupRoot ) { Scan scan = new Scan ( ) ; byte [ ] startRow = rowkey ( RS _ LOG _ TS _ PREFIX , backupRoot ) ; byte [ ] stopRow = Arrays . copyOf ( startRow , startRow . length ) ; stopRow [ stopRow . length - _NUM ] = ( byte ) ( stopRow [ stopRow . length - _NUM ] + _NUM ) ; scan . setStartRow ( startRow ) ; scan . setStopRow ( stopRow ) ; scan . addFamily ( BackupSystemTable . META _ FAMILY ) ; scan . setMaxVersions ( _NUM ) ; return scan ; } 
2038	private void twoWayMergeInternalStandard ( final ReservoirLongsSketch source ) { assert ( source . getN ( ) < = source . getK ( ) ) ; final int numInputSamples = source . getNumSamples ( ) ; for ( int i = _NUM ; i < numInputSamples ; + + i ) { gadget _ . update ( source . getValueAtPosition ( i ) ) ; } } 
2039	public void submitTopology ( ) throws TopologySubmissionException { build primary runtime config first Config primaryRuntime = Config . newBuilder ( ) . putAll ( LauncherUtils . getInstance ( ) . createPrimaryRuntime ( topology ) ) . build ( ) ; call launcher directly here if in dry - run mode if ( Context . dryRun ( config ) ) { callLauncherRunner ( primaryRuntime ) ; return ; } _NUM . Do prepare work create an instance of state manager String statemgrClass = Context . stateManagerClass ( config ) ; IStateManager statemgr ; Create an instance of the launcher class String launcherClass = Context . launcherClass ( config ) ; ILauncher launcher ; create an instance of the uploader class String uploaderClass = Context . uploaderClass ( config ) ; IUploader uploader ; create an instance of state manager try { statemgr = ReflectionUtils . newInstance ( statemgrClass ) ; } catch ( IllegalAccessException | InstantiationException | ClassNotFoundException e ) { throw new TopologySubmissionException ( String . format ( _STR , topology . getName ( ) ) ; Config runtimeWithoutPackageURI = Config . newBuilder ( ) . putAll ( primaryRuntime ) . putAll ( LauncherUtils . getInstance ( ) . createAdaptorRuntime ( adaptor ) ) . put ( Key . LAUNCHER _ CLASS _ INSTANCE , launcher ) . build ( ) ; PackingPlan packingPlan = LauncherUtils . getInstance ( ) . createPackingPlan ( config , runtimeWithoutPackageURI ) ; The packing plan might call for a number of containers different than the config settings . If that ' s the case we need to modify the configs to match . runtimeWithoutPackageURI = updateNumContainersIfNeeded ( runtimeWithoutPackageURI , topology , packingPlan ) ; If the packing plan is valid we will upload necessary packages URI packageURI = uploadPackage ( uploader ) ; Update the runtime config with the packageURI Config runtimeAll = Config . newBuilder ( ) . putAll ( runtimeWithoutPackageURI ) . put ( Key . TOPOLOGY _ PACKAGE _ URI , packageURI ) . build ( ) ; callLauncherRunner ( runtimeAll ) ; } catch ( LauncherException | PackingException e ) { we undo uploading of topology package only if launcher fails to launch topology , which will throw LauncherException or PackingException uploader . undo ( ) ; throw e ; } finally { SysUtils . closeIgnoringExceptions ( uploader ) ; SysUtils . closeIgnoringExceptions ( launcher ) ; SysUtils . closeIgnoringExceptions ( statemgr ) ; } } 
2040	public void deleteUser ( CmsDbContext dbc , String userFqn ) throws CmsDataAccessException { CmsUser user = readUser ( dbc , userFqn ) ; Connection conn = null ; PreparedStatement stmt = null ; try { conn = getSqlManager ( ) . getConnection ( dbc ) ; stmt = m _ sqlManager . getPreparedStatement ( conn , _STR ) ; stmt . setString ( _NUM , CmsOrganizationalUnit . getSimpleName ( userFqn ) ) ; stmt . setString ( _NUM , CmsOrganizationalUnit . SEPARATOR + CmsOrganizationalUnit . getParentFqn ( userFqn ) ) ; stmt . executeUpdate ( ) ; } catch ( SQLException e ) { throw new CmsDbSqlException ( Messages . get ( ) . container ( Messages . ERR _ GENERIC _ SQL _ _NUM , CmsDbSqlException . getErrorQuery ( stmt ) ) , e ) ; } finally { m _ sqlManager . closeAll ( dbc , conn , stmt , null ) ; } delete the additional infos deleteUserInfos ( dbc , user . getId ( ) ) ; if ( OpenCms . getSubscriptionManager ( ) . isEnabled ( ) ) { delete visited resource information from log CmsVisitEntryFilter filter = CmsVisitEntryFilter . ALL . filterUser ( user . getId ( ) ) ; m _ driverManager . getSubscriptionDriver ( ) . deleteVisits ( dbc , OpenCms . getSubscriptionManager ( ) . getPoolName ( ) , filter ) ; delete all subscribed resources for user m _ driverManager . getSubscriptionDriver ( ) . unsubscribeAllResourcesFor ( dbc , OpenCms . getSubscriptionManager ( ) . getPoolName ( ) , user ) ; } } 
2041	public void rotate ( float rot ) { Matrix _NUM f tmp = new Matrix _NUM f ( ) ; tmp . loadRotate ( rot ) ; multiply ( tmp ) ; } 
2042	private void initFromDatabase ( ) throws SQLException , BlockStoreException { PreparedStatement ps = conn . get ( ) . prepareStatement ( getSelectSettingsSQL ( ) ) ; ResultSet rs ; ps . setString ( _NUM , CHAIN _ HEAD _ SETTING ) ; rs = ps . executeQuery ( ) ; if ( ! rs . next ( ) ) { throw new BlockStoreException ( _STR ) ; } } 
2043	public Result [ ] askList ( String question , float relThresh ) { question = QuestionNormalizer . transformList ( question ) ; Result [ ] results = askFactoid ( question , Integer . MAX _ VALUE , _NUM ) ; get results with a score of at least relThresh * top score ArrayList < Result > confident = new ArrayList < Result > ( ) ; if ( results . length > _NUM ) { float topScore = results [ _NUM ] . getScore ( ) ; for ( Result result : results ) if ( result . getScore ( ) > = relThresh * topScore ) confident . add ( result ) ; } return confident . toArray ( new Result [ confident . size ( ) ] ) ; } 
2044	public void forceMergeWith ( EditOperation edit ) { if ( DEBUG _ UNDO ) Log . d ( TAG , _STR ) ; if ( mergeWith ( edit ) ) { return ; } Editor editor = getOwnerData ( ) ; Copy the text of the current field . NOTE : Using StringBuilder instead of SpannableStringBuilder would be somewhat faster , but would require two parallel implementations of modifyText ( ) because Editable and StringBuilder do not share an interface for replace / delete / insert . Editable editable = ( Editable ) editor . mTextView . getText ( ) ; Editable originalText = new SpannableStringBuilder ( editable . toString ( ) ) ; Roll back the last operation . modifyText ( originalText , mStart , getNewTextEnd ( ) , mOldText , mStart , mOldCursorPos ) ; Clone the text again and apply the new operation . Editable finalText = new SpannableStringBuilder ( editable . toString ( ) ) ; modifyText ( finalText , edit . mStart , edit . getOldTextEnd ( ) , edit . mNewText , edit . mStart , edit . mNewCursorPos ) ; Convert this operation into a replace operation . mType = TYPE _ REPLACE ; mNewText = finalText . toString ( ) ; mOldText = originalText . toString ( ) ; mStart = _NUM ; mNewCursorPos = edit . mNewCursorPos ; mIsComposition = edit . mIsComposition ; mOldCursorPos is unchanged . } 
2045	public boolean flingToEnd ( int maxSwipes ) throws UiObjectNotFoundException { Tracer . trace ( maxSwipes ) ; return scrollToEnd ( maxSwipes , FLING _ STEPS ) ; } 
2046	protected static String eval ( final String query ) throws QueryException , IOException { final ArrayOutput ao = new ArrayOutput ( ) ; try ( QueryProcessor qp = new QueryProcessor ( query , BASEURI , context ) ) { update flag will be set in parsing step qp . parse ( ) ; qp . register ( context ) ; try ( Serializer ser = qp . getSerializer ( ao ) ) { qp . value ( ) . serialize ( ser ) ; } finally { qp . unregister ( context ) ; } } return ao . toString ( ) ; } 
2047	public void setAttribute ( final int index ) { setHeader ( index ) ; if ( m _ AttributeStats [ index ] = = null ) { Thread t = new Thread ( ) { public void run ( ) { m _ AttributeStats [ index ] = m _ Instances . attributeStats ( index ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { setDerived ( index ) ; m _ StatsTable . sizeColumnsToFit ( - _NUM ) ; m _ StatsTable . revalidate ( ) ; m _ StatsTable . repaint ( ) ; } } ) ; } } ; t . setPriority ( Thread . MIN _ PRIORITY ) ; t . start ( ) ; } else { setDerived ( index ) ; } } 
2048	public void dec ( ) { checkWriteTxn ( ) ; IntegerState ts = getDataState ( ) ; ts . txnValue - - ; } 
2049	private RaftPartitionClient createClient ( PartitionManagementService managementService ) { return new RaftPartitionClient ( this , managementService . getClusterService ( ) . getLocalNode ( ) . id ( ) , new RaftClientCommunicator ( name ( ) , Serializer . using ( RaftNamespaces . RAFT _ PROTOCOL ) , managementService . getCommunicationService ( ) ) ) ; } 
2050	public ComponentSelector addStyleListener ( StyleListener l ) { currentStyle ( ) . addStyleListener ( l ) ; return this ; } 
2051	private static void runApplicationMaster ( final CommandLine cliParser ) throws Exception { int numWorkers = Integer . parseInt ( cliParser . getOptionValue ( _STR ) ; ApplicationMaster applicationMaster = new ApplicationMaster ( numWorkers , masterAddress , resourcePath ) ; applicationMaster . start ( ) ; applicationMaster . requestAndLaunchContainers ( ) ; applicationMaster . waitForShutdown ( ) ; applicationMaster . stop ( ) ; } 
2052	public void addSubjectAlternativeName ( int type , String name ) throws IOException { TODO full implementation of CertUtil . parseGeneralName byte [ ] encoded = CertUtil . parseGeneralName ( type , name ) ; List tmpList = new ArrayList ( ) ; tmpList . add ( Integers . valueOf ( type ) ) ; tmpList . add ( name ) ; subjectAltNames . add ( tmpList ) ; tmpList . set ( _NUM , encoded ) ; subjectAltNamesByte . add ( tmpList ) ; } 
2053	private long insertInternal ( ContentValues values , boolean allowReplace ) { Start a transaction even though we don ' t really need one . This is to help maintain compatibility with applications that access InsertHelper from multiple threads even though they never should have . The original code used to lock the InsertHelper itself which was prone to deadlocks . Starting a transaction achieves the same mutual exclusion effect as grabbing a lock but without the potential for deadlocks . mDb . beginTransactionNonExclusive ( ) ; try { SQLiteStatement stmt = getStatement ( allowReplace ) ; stmt . clearBindings ( ) ; if ( DEBUG ) Log . v ( TAG , _STR + mTableName , e ) ; return - _NUM ; } finally { mDb . endTransaction ( ) ; } } 
2054	public void parse ( UsbDescriptorParser parser ) { ArrayList < UsbDescriptor > descriptors = parser . getDescriptors ( ) ; for ( int descrIndex = _NUM ; descrIndex < descriptors . size ( ) ; descrIndex + + ) { UsbDescriptor descriptor = descriptors . get ( descrIndex ) ; switch ( descriptor . getType ( ) ) { case UsbDescriptor . DESCRIPTORTYPE _ DEVICE : addDeviceDescriptor ( ( UsbDeviceDescriptor ) descriptor ) ; break ; case UsbDescriptor . DESCRIPTORTYPE _ CONFIG : addConfigDescriptor ( ( UsbConfigDescriptor ) descriptor ) ; break ; case UsbDescriptor . DESCRIPTORTYPE _ INTERFACE : addInterfaceDescriptor ( ( UsbInterfaceDescriptor ) descriptor ) ; break ; case UsbDescriptor . DESCRIPTORTYPE _ ENDPOINT : addEndpointDescriptor ( ( UsbEndpointDescriptor ) descriptor ) ; break ; case UsbDescriptor . DESCRIPTORTYPE _ AUDIO _ INTERFACE : addACInterface ( ( UsbACInterface ) descriptor ) ; break ; case UsbDescriptor . DESCRIPTORTYPE _ AUDIO _ ENDPOINT : break ; } } } 
2055	public static boolean interfaceOf ( Object obj , String interfaceName ) throws ClassNotFoundException { Class < ? > interfaceClass = loadClass ( interfaceName ) ; return interfaceOf ( obj , interfaceClass ) ; } 
2056	public void cloneStyleFrom ( CellStyle source ) { if ( source instanceof XSSFCellStyle ) { XSSFCellStyle src = ( XSSFCellStyle ) source ; Is it on our Workbook ? if ( src . _ stylesSource = = _ stylesSource ) { Nice and easy _ cellXf . set ( src . getCoreXf ( ) ) ; _ cellStyleXf . set ( src . getStyleXf ( ) ) ; } else { Copy the style try { avoid orphaned nodes if ( _ cellXf . isSetAlignment ( ) ) _ cellXf . unsetAlignment ( ) ; if ( _ cellXf . isSetExtLst ( ) ) _ cellXf . unsetExtLst ( ) ; Create a new Xf with the same contents _ cellXf = CTXf . Factory . parse ( src . getCoreXf ( ) . toString ( ) , DEFAULT _ XML _ OPTIONS ) ; bug _NUM _NUM _NUM _NUM _NUM : ensure that the fills is available and set correctly CTFill fill = CTFill . Factory . parse ( src . getCTFill ( ) . toString ( ) , DEFAULT _ XML _ OPTIONS ) ; addFill ( fill ) ; bug _NUM _NUM _NUM _NUM _NUM : set borders correctly CTBorder border = CTBorder . Factory . parse ( src . getCTBorder ( ) . toString ( ) , DEFAULT _ XML _ OPTIONS ) ; addBorder ( border ) ; Swap it over _ stylesSource . replaceCellXfAt ( _ cellXfId , _ cellXf ) ; } catch ( XmlException e ) { throw new POIXMLException ( e ) ; } Copy the format String fmt = src . getDataFormatString ( ) ; setDataFormat ( ( new XSSFDataFormat ( _ stylesSource ) ) . getFormat ( fmt ) ) ; Copy the font try { CTFont ctFont = CTFont . Factory . parse ( src . getFont ( ) . getCTFont ( ) . toString ( ) , DEFAULT _ XML _ OPTIONS ) ; XSSFFont font = new XSSFFont ( ctFont ) ; font . registerTo ( _ stylesSource ) ; setFont ( font ) ; } catch ( XmlException e ) { throw new POIXMLException ( e ) ; } } Clear out cached details _ font = null ; _ cellAlignment = null ; } else { throw new IllegalArgumentException ( _STR ) ; } } 
2057	private boolean syncMetadata ( JournalContext journalContext , LockedInodePath inodePath , LockingScheme lockingScheme , DescendantType syncDescendantType , BlockDeletionContext blockDeletionContext ) { if ( ! lockingScheme . shouldSync ( ) ) { return false ; } The high - level process for the syncing is : _NUM . Find all Alluxio paths which are not consistent with the corresponding UFS path . This means the UFS path does not exist , or is different from the Alluxio metadata . _NUM . If possible , update an Alluxio directory with the corresponding UFS directory . _NUM . Delete any Alluxio path not consistent with UFS , or not in UFS . After this step , all the paths in Alluxio are consistent with UFS , and there may be additional UFS paths to load . _NUM . Load metadata from UFS . Set to true if ufs metadata must be loaded . boolean loadMetadata = false ; Set to true if the given inode was deleted . boolean deletedInode = false ; try { if ( ! inodePath . fullPathExists ( ) ) { The requested path does not exist in Alluxio , so just load metadata . loadMetadata = true ; } else { SyncResult result = syncInodeMetadata ( journalContext , inodePath , syncDescendantType , blockDeletionContext ) ; deletedInode = result . getDeletedInode ( ) ; loadMetadata = result . getLoadMetadata ( ) ; } } catch ( Exception e ) { LOG . error ( _STR , inodePath . getUri ( ) , e ) ; return false ; } } mUfsSyncPathCache . notifySyncedPath ( inodePath . getUri ( ) . getPath ( ) ) ; return true ; } 
2058	public XmlOptions setValidateTreatLaxAsSkip ( ) { return set ( VALIDATE _ TREAT _ LAX _ AS _ SKIP ) ; } 
2059	public static boolean hasDuplicateItems ( final Object [ ] array ) { for ( int i = _NUM ; i < array . length ; i + + ) { for ( int j = _NUM ; j < i ; j + + ) { final Object o _NUM = array [ i ] ; final Object o _NUM = array [ j ] ; if ( o _NUM ! = null & & o _NUM ! = null ) { if ( o _NUM . equals ( o _NUM ) ) { return true ; } } } } return false ; } 
2060	int getDSTOffset ( Calendar source ) { TimeZone localTimezone = Calendar . getInstance ( ) . getTimeZone ( ) ; int rawOffset = localTimezone . getRawOffset ( ) / MILLIS _ TO _ MINUTES ; return getOffsetInMinutes ( source , localTimezone ) - rawOffset ; } 
2061	protected HashEntry getEntry ( Object key ) { key = convertKey ( key ) ; int hashCode = hash ( key ) ; no local for hash index HashEntry entry = data [ hashIndex ( hashCode , data . length ) ] ; while ( entry ! = null ) { if ( entry . hashCode = = hashCode & & isEqualKey ( key , entry . key ) ) { return entry ; } entry = entry . next ; } return null ; } 
2062	public boolean isSet ( _ Fields field ) { if ( field = = null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case VALUE : return isSetValue ( ) ; case SCALE : return isSetScale ( ) ; } throw new IllegalStateException ( ) ; } 
2063	public static long getLong ( String key , long def ) { String value = get ( key ) ; if ( value = = null ) { return def ; } value = value . trim ( ) . toLowerCase ( ) ; if ( INTEGER _ PATTERN . matcher ( value ) . matches ( ) ) { try { return Long . parseLong ( value ) ; } catch ( Exception e ) { Ignore } } logger . warn ( _STR , key , value , def ) ; return def ; } 
2064	public void tokenize ( String s ) { m _ N = m _ NMax ; m _ SplitString = s . split ( _STR ) ; filterOutEmptyStrings ( ) ; m _ CurrentPosition = _NUM ; m _ MaxPosition = m _ SplitString . length ; } 
2065	private boolean ensureActiveMobilePolicyAL ( int subId , String subscriberId ) { Poke around to see if we already have a policy final NetworkIdentity probeIdent = new NetworkIdentity ( TYPE _ MOBILE , TelephonyManager . NETWORK _ TYPE _ UNKNOWN , subscriberId , null , false , true , true ) ; for ( int i = mNetworkPolicy . size ( ) - _NUM ; i > = _NUM ; i - - ) { final NetworkTemplate template = mNetworkPolicy . keyAt ( i ) ; if ( template . matches ( probeIdent ) ) { if ( LOGD ) { Slog . d ( TAG , _STR ) ; final NetworkPolicy policy = buildDefaultMobilePolicy ( subId , subscriberId ) ; addNetworkPolicyAL ( policy ) ; return true ; } 
2066	protected HttpsURLConnection getSSLConnection ( String spec ) throws IOException , IllegalStateException { if ( sslSocketFactory = = null ) { synchronized ( this ) { if ( sslSocketFactory = = null ) { if ( trustStorePath = = null | | trustStorePassword = = null ) { String msg = String . format ( _STR , e ) ; } finally { if ( in ! = null ) { in . close ( ) ; } } } } } HttpsURLConnection connection = ( HttpsURLConnection ) ( new URL ( spec ) . openConnection ( ) ) ; connection . setSSLSocketFactory ( sslSocketFactory ) ; return connection ; } 
2067	private boolean cacheResults ( int n ) { for ( int i = _NUM ; i < n ; i + + ) { if ( parseNextBinding ( ) ) { this . cache . add ( this . binding ) ; this . binding = null ; } else { return true ; } } return false ; } 
2068	public AppendObjectResult appendObject ( AppendObjectRequest appendObjectRequest ) throws OSSException , ClientException { assertParameterNotNull ( appendObjectRequest , _STR ) ; AppendObjectResult result = writeObjectInternal ( WriteMode . APPEND , appendObjectRequest , appendObjectResponseParser ) ; if ( appendObjectRequest . getInitCRC ( ) ! = null & & result . getClientCRC ( ) ! = null ) { result . setClientCRC ( CRC _NUM _NUM . combine ( appendObjectRequest . getInitCRC ( ) , result . getClientCRC ( ) , ( result . getNextPosition ( ) - appendObjectRequest . getPosition ( ) ) ) ) ; } if ( isCrcCheckEnabled ( ) & & appendObjectRequest . getInitCRC ( ) ! = null ) { OSSUtils . checkChecksum ( result . getClientCRC ( ) , result . getServerCRC ( ) , result . getRequestId ( ) ) ; } return result ; } 
2069	public static void encodeToFile ( byte [ ] dataToEncode , String filename ) throws java . io . IOException { if ( dataToEncode = = null ) { throw new NullPointerException ( _STR ) ; } end iff OutputStream bos = null ; try { bos = new OutputStream ( new java . io . FileOutputStream ( filename ) , Base _NUM _NUM . ENCODE ) ; bos . write ( dataToEncode ) ; } end try catch ( java . io . IOException e ) { Catch and throw to execute finally { } block throw e ; } finally end catch : java . io . IOException { try { bos . close ( ) ; } catch ( Exception e ) { } } end finally } 
2070	public void upload ( File file , String bucketName ) { AmazonS _NUM client = new AmazonS _NUM Client ( creds ) ; bucketName = ensureValidBucketName ( bucketName ) ; List < Bucket > buckets = client . listBuckets ( ) ; for ( Bucket b : buckets ) if ( b . getName ( ) . equals ( bucketName ) ) { client . putObject ( bucketName , file . getName ( ) , file ) ; return ; } bucket didn ' t exist : create it client . createBucket ( bucketName ) ; client . putObject ( bucketName , file . getName ( ) , file ) ; } 
2071	public void noStarvationOfReadRequestsTest ( ) throws Exception { final String path = _STR , ! processedRequests . contains ( r ) ) ; } } 
2072	protected String getResourceTypeFromResources ( Set < Resource > resources ) { String resType = null ; if ( resources ! = null ) { Iterator < Resource > itr = resources . iterator ( ) ; if ( itr . hasNext ( ) ) { Pick the _NUM st resource , as the passed in resources will have same Type , in a given call . Resource res = itr . next ( ) ; if ( res ! = null ) { resType = res . getType ( ) . toString ( ) ; } } } return resType ; } 
2073	public HdfsDataInputStream createWrappedInputStream ( DFSInputStream dfsis ) throws IOException { final FileEncryptionInfo feInfo = dfsis . getFileEncryptionInfo ( ) ; if ( feInfo ! = null ) { File is encrypted , wrap the stream in a crypto stream . Currently only one version , so no special logic based on the version # getCryptoProtocolVersion ( feInfo ) ; final CryptoCodec codec = getCryptoCodec ( conf , feInfo ) ; final KeyVersion decrypted = decryptEncryptedDataEncryptionKey ( feInfo ) ; final CryptoInputStream cryptoIn = new CryptoInputStream ( dfsis , codec , decrypted . getMaterial ( ) , feInfo . getIV ( ) ) ; return new HdfsDataInputStream ( cryptoIn ) ; } else { No FileEncryptionInfo so no encryption . return new HdfsDataInputStream ( dfsis ) ; } } 
2074	private void processTagsForArticleUpdate ( final JSONObject oldArticle , final JSONObject newArticle ) throws Exception { final String oldArticleId = oldArticle . getString ( Keys . OBJECT _ ID ) ; final List < JSONObject > oldTags = tagRepository . getByArticleId ( oldArticleId ) ; final String tagsString = newArticle . getString ( Article . ARTICLE _ TAGS _ REF ) ; String [ ] tagStrings = tagsString . split ( _STR } : tagIdsDropped ) ; tagStrings = new String [ tagsNeedToAdd . size ( ) ] ; for ( int i = _NUM ; i < tagStrings . length ; i + + ) { final JSONObject tag = tagsNeedToAdd . get ( i ) ; final String tagTitle = tag . getString ( Tag . TAG _ TITLE ) ; tagStrings [ i ] = tagTitle ; } final JSONArray tags = tag ( tagStrings , newArticle ) ; addTagArticleRelation ( tags , newArticle ) ; } 
2075	public final boolean incrementToken ( ) throws IOException { if ( input . incrementToken ( ) ) { if ( ! keywordAttr . isKeyword ( ) ) { final String term = termAtt . toString ( ) ; final String s = stemmer . stem ( term ) ; if ( s ! = null & & ! s . equals ( term ) ) termAtt . setEmpty ( ) . append ( s ) ; } return true ; } else { return false ; } } 
2076	public void printBitmap ( final String jobName , final Uri imageFile , final OnPrintFinishCallback callback ) throws FileNotFoundException { final int fittingMode = mScaleMode ; PrintDocumentAdapter printDocumentAdapter = new PrintDocumentAdapter ( ) { private PrintAttributes mAttributes ; AsyncTask < Uri , Boolean , Bitmap > mLoadBitmap ; Bitmap mBitmap = null ; @ Override public void onLayout ( final PrintAttributes oldPrintAttributes , final PrintAttributes newPrintAttributes , final CancellationSignal cancellationSignal , final LayoutResultCallback layoutResultCallback , Bundle bundle ) { synchronized ( this ) { mAttributes = newPrintAttributes ; } if ( cancellationSignal . isCanceled ( ) ) { layoutResultCallback . onLayoutCancelled ( ) ; return ; } we finished the load if ( mBitmap ! = null ) { PrintDocumentInfo info = new PrintDocumentInfo . Builder ( jobName ) . setContentType ( PrintDocumentInfo . CONTENT _ TYPE _ PHOTO ) . setPageCount ( _NUM ) . build ( ) ; boolean changed = ! newPrintAttributes . equals ( oldPrintAttributes ) ; layoutResultCallback . onLayoutFinished ( info , changed ) ; return ; } mLoadBitmap = new AsyncTask < Uri , Boolean , Bitmap > ( ) { @ Override protected void onPreExecute ( ) { First register for cancellation requests . cancellationSignal . setOnCancelListener ( new CancellationSignal . OnCancelListener ( ) { @ Override public void onCancel ( ) { on different thread cancelLoad ( ) ; cancel ( false ) ; } } ) ; } @ Override protected Bitmap doInBackground ( Uri . . . uris ) { try { return loadConstrainedBitmap ( imageFile ) ; } catch ( FileNotFoundException e ) { } return null ; } @ Override protected void onPostExecute ( Bitmap bitmap ) { super . onPostExecute ( bitmap ) ; the current paper by potentially rotating the bitmap by _NUM _NUM degrees . if ( bitmap ! = null & & ( ! mPrintActivityRespectsOrientation | | mOrientation = = _NUM ) ) { PrintAttributes . MediaSize mediaSize ; synchronized ( this ) { mediaSize = mAttributes . getMediaSize ( ) ; } if ( mediaSize ! = null ) { if ( mediaSize . isPortrait ( ) ! = isPortrait ( bitmap ) ) { Matrix rotation = new Matrix ( ) ; rotation . postRotate ( _NUM _NUM ) ; bitmap = Bitmap . createBitmap ( bitmap , _NUM , _NUM , bitmap . getWidth ( ) , bitmap . getHeight ( ) , rotation , true ) ; } } } mBitmap = bitmap ; if ( bitmap ! = null ) { PrintDocumentInfo info = new PrintDocumentInfo . Builder ( jobName ) . setContentType ( PrintDocumentInfo . CONTENT _ TYPE _ PHOTO ) . setPageCount ( _NUM ) . build ( ) ; boolean changed = ! newPrintAttributes . equals ( oldPrintAttributes ) ; layoutResultCallback . onLayoutFinished ( info , changed ) ; } else { layoutResultCallback . onLayoutFailed ( null ) ; } mLoadBitmap = null ; } @ Override protected void onCancelled ( Bitmap result ) { Task was cancelled , report that . layoutResultCallback . onLayoutCancelled ( ) ; mLoadBitmap = null ; } } . execute ( ) ; } private void cancelLoad ( ) { synchronized ( mLock ) { prevent race with set null below if ( mDecodeOptions ! = null ) { mDecodeOptions . requestCancelDecode ( ) ; mDecodeOptions = null ; } } } @ Override public void onFinish ( ) { super . onFinish ( ) ; cancelLoad ( ) ; if ( mLoadBitmap ! = null ) { mLoadBitmap . cancel ( true ) ; } if ( callback ! = null ) { callback . onFinish ( ) ; } if ( mBitmap ! = null ) { mBitmap . recycle ( ) ; mBitmap = null ; } } @ Override public void onWrite ( PageRange [ ] pageRanges , ParcelFileDescriptor fileDescriptor , CancellationSignal cancellationSignal , WriteResultCallback writeResultCallback ) { writeBitmap ( mAttributes , fittingMode , mBitmap , fileDescriptor , cancellationSignal , writeResultCallback ) ; } } ; PrintManager printManager = ( PrintManager ) mContext . getSystemService ( Context . PRINT _ SERVICE ) ; PrintAttributes . Builder builder = new PrintAttributes . Builder ( ) ; builder . setColorMode ( mColorMode ) ; if ( mOrientation = = ORIENTATION _ LANDSCAPE | | mOrientation = = _NUM ) { builder . setMediaSize ( PrintAttributes . MediaSize . UNKNOWN _ LANDSCAPE ) ; } else if ( mOrientation = = ORIENTATION _ PORTRAIT ) { builder . setMediaSize ( PrintAttributes . MediaSize . UNKNOWN _ PORTRAIT ) ; } PrintAttributes attr = builder . build ( ) ; printManager . print ( jobName , printDocumentAdapter , attr ) ; } 
2077	public synchronized ValidationResponse validate ( StackAdvisorRequest request ) throws StackAdvisorException { requestId = generateRequestId ( ) ; TODO , need frontend to pass the Service Name that was modified . For now , hardcode . Once fixed , change StackAdvisorHelperTest . java to use the actual service name . String serviceName = _STR ; ServiceInfo . ServiceAdvisorType serviceAdvisorType = getServiceAdvisorType ( request . getStackName ( ) , request . getStackVersion ( ) , serviceName ) ; StackAdvisorCommand < ValidationResponse > command = createValidationCommand ( serviceName , request ) ; return command . invoke ( request , serviceAdvisorType ) ; } 
2078	void putIntegerArrayList ( @ Nullable String key , @ Nullable ArrayList < Integer > value ) { unparcel ( ) ; mMap . put ( key , value ) ; } 
2079	public static Map < TableName , TableState > getTableStates ( Connection conn ) throws IOException { final Map < TableName , TableState > states = new LinkedHashMap < > ( ) ; Visitor collector = new Visitor ( ) { @ Override public boolean visit ( Result r ) throws IOException { TableState state = getTableState ( r ) ; if ( state ! = null ) states . put ( state . getTableName ( ) , state ) ; return true ; } } ; fullScanTables ( conn , collector ) ; return states ; } 
2080	private Command < Void > getDeleteCommand ( final Predicate predicate ) { return new Command < Void > ( ) { @ Override public Void invoke ( ) throws AmbariException { Comparable deletedCluster = ( ( EqualsPredicate ) predicate ) . getValue ( ) ; String toDelete = deletedCluster . toString ( ) ; RemoteAmbariClusterEntity clusterEntity = remoteAmbariClusterDAO . findByName ( toDelete ) ; if ( clusterEntity = = null ) { throw new IllegalArgumentException ( _STR ) ; } remoteAmbariClusterRegistry . delete ( clusterEntity ) ; return null ; } } ; } 
2081	static void setFieldsFromCursor ( Cursor cursor , Builder builder ) { TODO : Add additional API which does not use costly getColumnIndex ( ) . int index ; if ( ( index = cursor . getColumnIndex ( BaseTvColumns . _ ID ) ) > = _NUM & & ! cursor . isNull ( index ) ) { builder . setId ( cursor . getLong ( index ) ) ; } if ( ( index = cursor . getColumnIndex ( BaseTvColumns . COLUMN _ PACKAGE _ NAME ) ) > = _NUM & & ! cursor . isNull ( index ) ) { builder . setPackageName ( cursor . getString ( index ) ) ; } if ( ( index = cursor . getColumnIndex ( ProgramColumns . COLUMN _ TITLE ) ) > = _NUM & & ! cursor . isNull ( index ) ) { builder . setTitle ( cursor . getString ( index ) ) ; } if ( ( index = cursor . getColumnIndex ( ProgramColumns . COLUMN _ EPISODE _ TITLE ) ) > = _NUM & & ! cursor . isNull ( index ) ) { builder . setEpisodeTitle ( cursor . getString ( index ) ) ; } if ( Build . VERSION . SDK _ INT > = Build . VERSION _ CODES . N ) { if ( ( index = cursor . getColumnIndex ( ProgramColumns . COLUMN _ SEASON _ DISPLAY _ NUMBER ) ) > = _NUM & & ! cursor . isNull ( index ) ) { builder . setSeasonNumber ( cursor . getString ( index ) , INVALID _ INT _ VALUE ) ; } } else { if ( ( index = cursor . getColumnIndex ( Programs . COLUMN _ SEASON _ NUMBER ) ) > = _NUM & & ! cursor . isNull ( index ) ) { builder . setSeasonNumber ( cursor . getInt ( index ) ) ; } } if ( Build . VERSION . SDK _ INT > = Build . VERSION _ CODES . N ) { if ( ( index = cursor . getColumnIndex ( ProgramColumns . COLUMN _ EPISODE _ DISPLAY _ NUMBER ) ) > = _NUM & & ! cursor . isNull ( index ) ) { builder . setEpisodeNumber ( cursor . getString ( index ) , INVALID _ INT _ VALUE ) ; } } else { if ( ( index = cursor . getColumnIndex ( Programs . COLUMN _ EPISODE _ NUMBER ) ) > = _NUM & & ! cursor . isNull ( index ) ) { builder . setEpisodeNumber ( cursor . getInt ( index ) ) ; } } if ( ( index = cursor . getColumnIndex ( ProgramColumns . COLUMN _ SHORT _ DESCRIPTION ) ) > = _NUM & & ! cursor . isNull ( index ) ) { builder . setDescription ( cursor . getString ( index ) ) ; } if ( ( index = cursor . getColumnIndex ( ProgramColumns . COLUMN _ LONG _ DESCRIPTION ) ) > = _NUM & & ! cursor . isNull ( index ) ) { builder . setLongDescription ( cursor . getString ( index ) ) ; } if ( ( index = cursor . getColumnIndex ( ProgramColumns . COLUMN _ POSTER _ ART _ URI ) ) > = _NUM & & ! cursor . isNull ( index ) ) { builder . setPosterArtUri ( Uri . parse ( cursor . getString ( index ) ) ) ; } if ( ( index = cursor . getColumnIndex ( ProgramColumns . COLUMN _ THUMBNAIL _ URI ) ) > = _NUM & & ! cursor . isNull ( index ) ) { builder . setThumbnailUri ( Uri . parse ( cursor . getString ( index ) ) ) ; } if ( ( index = cursor . getColumnIndex ( ProgramColumns . COLUMN _ AUDIO _ LANGUAGE ) ) > = _NUM & & ! cursor . isNull ( index ) ) { builder . setAudioLanguages ( TvContractUtils . stringToAudioLanguages ( cursor . getString ( index ) ) ) ; } if ( ( index = cursor . getColumnIndex ( ProgramColumns . COLUMN _ CANONICAL _ GENRE ) ) > = _NUM & & ! cursor . isNull ( index ) ) { builder . setCanonicalGenres ( Programs . Genres . decode ( cursor . getString ( index ) ) ) ; } if ( ( index = cursor . getColumnIndex ( ProgramColumns . COLUMN _ CONTENT _ RATING ) ) > = _NUM & & ! cursor . isNull ( index ) ) { builder . setContentRatings ( TvContractUtils . stringToContentRatings ( cursor . getString ( index ) ) ) ; } if ( ( index = cursor . getColumnIndex ( ProgramColumns . COLUMN _ VIDEO _ WIDTH ) ) > = _NUM & & ! cursor . isNull ( index ) ) { builder . setVideoWidth ( ( int ) cursor . getLong ( index ) ) ; } if ( ( index = cursor . getColumnIndex ( ProgramColumns . COLUMN _ VIDEO _ HEIGHT ) ) > = _NUM & & ! cursor . isNull ( index ) ) { builder . setVideoHeight ( ( int ) cursor . getLong ( index ) ) ; } if ( ( index = cursor . getColumnIndex ( ProgramColumns . COLUMN _ INTERNAL _ PROVIDER _ DATA ) ) > = _NUM & & ! cursor . isNull ( index ) ) { builder . setInternalProviderData ( cursor . getBlob ( index ) ) ; } if ( Build . VERSION . SDK _ INT > = Build . VERSION _ CODES . M ) { if ( ( index = cursor . getColumnIndex ( ProgramColumns . COLUMN _ SEARCHABLE ) ) > = _NUM & & ! cursor . isNull ( index ) ) { builder . setSearchable ( cursor . getInt ( index ) = = IS _ SEARCHABLE ) ; } if ( ( index = cursor . getColumnIndex ( ProgramColumns . COLUMN _ INTERNAL _ PROVIDER _ FLAG _NUM ) ) > = _NUM & & ! cursor . isNull ( index ) ) { builder . setInternalProviderFlag _NUM ( cursor . getLong ( index ) ) ; } if ( ( index = cursor . getColumnIndex ( ProgramColumns . COLUMN _ INTERNAL _ PROVIDER _ FLAG _NUM ) ) > = _NUM & & ! cursor . isNull ( index ) ) { builder . setInternalProviderFlag _NUM ( cursor . getLong ( index ) ) ; } if ( ( index = cursor . getColumnIndex ( ProgramColumns . COLUMN _ INTERNAL _ PROVIDER _ FLAG _NUM ) ) > = _NUM & & ! cursor . isNull ( index ) ) { builder . setInternalProviderFlag _NUM ( cursor . getLong ( index ) ) ; } if ( ( index = cursor . getColumnIndex ( ProgramColumns . COLUMN _ INTERNAL _ PROVIDER _ FLAG _NUM ) ) > = _NUM & & ! cursor . isNull ( index ) ) { builder . setInternalProviderFlag _NUM ( cursor . getLong ( index ) ) ; } } if ( Build . VERSION . SDK _ INT > = Build . VERSION _ CODES . N ) { if ( ( index = cursor . getColumnIndex ( ProgramColumns . COLUMN _ SEASON _ TITLE ) ) > = _NUM & & ! cursor . isNull ( index ) ) { builder . setSeasonTitle ( cursor . getString ( index ) ) ; } } if ( Build . VERSION . SDK _ INT > = Build . VERSION _ CODES . O ) { if ( ( index = cursor . getColumnIndex ( ProgramColumns . COLUMN _ REVIEW _ RATING _ STYLE ) ) > = _NUM & & ! cursor . isNull ( index ) ) { builder . setReviewRatingStyle ( cursor . getInt ( index ) ) ; } if ( ( index = cursor . getColumnIndex ( ProgramColumns . COLUMN _ REVIEW _ RATING ) ) > = _NUM & & ! cursor . isNull ( index ) ) { builder . setReviewRating ( cursor . getString ( index ) ) ; } } } 
2082	default < C extends Collection < U > > FutureStream < C > group ( final Function < Supplier < U > , Supplier < C > > fn ) { final Queue queue = toQueue ( ) ; return fromStream ( queue . streamBatchNoTimeout ( getSubscription ( ) , fn ) ) ; } 
2083	public boolean input ( Instance instance ) { if ( getInputFormat ( ) = = null ) throw new IllegalStateException ( _STR ) ; if ( m _ NewBatch ) { resetQueue ( ) ; m _ NewBatch = false ; } if ( m _ Means = = null ) { bufferInput ( instance ) ; return false ; } else { convertInstance ( instance ) ; return true ; } } 
2084	public void testReadWrite ( ) { final File file = new File ( getContext ( ) . getCacheDir ( ) , _STR ) . getValue ( ) ) ; } } 
2085	public String nextTo ( String delimiters ) throws JSONException { char c ; StringBuffer sb = new StringBuffer ( ) ; for ( ; ; ) { c = next ( ) ; if ( ( delimiters . indexOf ( c ) > = _NUM ) | | ( c = = _NUM ) | | ( c = = ' \ n ' ) | | ( c = = ' \ r ' ) ) { if ( c ! = _NUM ) { back ( ) ; } return sb . toString ( ) . trim ( ) ; } sb . append ( c ) ; } } 
2086	public Builder add ( String name , double value ) { initializeArgs ( ) ; argsStringHelper . add ( name , value ) ; return this ; } 
2087	public void logFatal ( String message , long line , long col ) { if ( log ! = null ) logError ( message , line , col ) ; } 
2088	protected void encryptBlock ( byte [ ] input , int inOff , byte [ ] output , int outOff ) { X _NUM = Pack . littleEndianToInt ( input , inOff ) ; X _NUM = Pack . littleEndianToInt ( input , inOff + _NUM ) ; X _NUM = Pack . littleEndianToInt ( input , inOff + _NUM ) ; X _NUM = Pack . littleEndianToInt ( input , inOff + _NUM _NUM ) ; sb _NUM ( wKey [ _NUM ] ^ X _NUM , wKey [ _NUM ] ^ X _NUM , wKey [ _NUM ] ^ X _NUM , wKey [ _NUM ] ^ X _NUM ) ; LT ( ) ; sb _NUM ( wKey [ _NUM ] ^ X _NUM , wKey [ _NUM ] ^ X _NUM , wKey [ _NUM ] ^ X _NUM , wKey [ _NUM ] ^ X _NUM ) ; LT ( ) ; sb _NUM ( wKey [ _NUM ] ^ X _NUM , wKey [ _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM ) ; LT ( ) ; sb _NUM ( wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM ) ; LT ( ) ; sb _NUM ( wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM ) ; LT ( ) ; sb _NUM ( wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM ) ; LT ( ) ; sb _NUM ( wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM ) ; LT ( ) ; sb _NUM ( wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM ) ; LT ( ) ; sb _NUM ( wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM ) ; LT ( ) ; sb _NUM ( wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM ) ; LT ( ) ; sb _NUM ( wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM ) ; LT ( ) ; sb _NUM ( wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM ) ; LT ( ) ; sb _NUM ( wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM ) ; LT ( ) ; sb _NUM ( wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM ) ; LT ( ) ; sb _NUM ( wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM ) ; LT ( ) ; sb _NUM ( wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM ) ; LT ( ) ; sb _NUM ( wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM ) ; LT ( ) ; sb _NUM ( wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM ) ; LT ( ) ; sb _NUM ( wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM ) ; LT ( ) ; sb _NUM ( wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM ) ; LT ( ) ; sb _NUM ( wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM ) ; LT ( ) ; sb _NUM ( wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM ) ; LT ( ) ; sb _NUM ( wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM ) ; LT ( ) ; sb _NUM ( wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM ) ; LT ( ) ; sb _NUM ( wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM ] ^ X _NUM ) ; LT ( ) ; sb _NUM ( wKey [ _NUM _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM _NUM ] ^ X _NUM ) ; LT ( ) ; sb _NUM ( wKey [ _NUM _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM _NUM ] ^ X _NUM ) ; LT ( ) ; sb _NUM ( wKey [ _NUM _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM _NUM ] ^ X _NUM ) ; LT ( ) ; sb _NUM ( wKey [ _NUM _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM _NUM ] ^ X _NUM ) ; LT ( ) ; sb _NUM ( wKey [ _NUM _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM _NUM ] ^ X _NUM ) ; LT ( ) ; sb _NUM ( wKey [ _NUM _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM _NUM ] ^ X _NUM ) ; LT ( ) ; sb _NUM ( wKey [ _NUM _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM _NUM ] ^ X _NUM , wKey [ _NUM _NUM _NUM ] ^ X _NUM ) ; Pack . intToLittleEndian ( wKey [ _NUM _NUM _NUM ] ^ X _NUM , output , outOff ) ; Pack . intToLittleEndian ( wKey [ _NUM _NUM _NUM ] ^ X _NUM , output , outOff + _NUM ) ; Pack . intToLittleEndian ( wKey [ _NUM _NUM _NUM ] ^ X _NUM , output , outOff + _NUM ) ; Pack . intToLittleEndian ( wKey [ _NUM _NUM _NUM ] ^ X _NUM , output , outOff + _NUM _NUM ) ; } 
2089	public void setOmega ( double value ) { m _ omega = value ; m _ factor = computeFactor ( m _ omega , m _ sigma ) ; } 
2090	private static boolean eq ( Object o _NUM , Object o _NUM ) { return o _NUM = = null ? o _NUM = = null : o _NUM . equals ( o _NUM ) ; } 
2091	public Collection < ArbitraryAttributeModel > toModelCollection ( ) { return new AbstractCollection < ArbitraryAttributeModel > ( ) { @ Override public void clear ( ) { ArbitraryAttributeMap . this . clear ( ) ; } @ Override public boolean remove ( Object o ) { only ArbitraryAttributeModel objects if ( ! ( o instanceof ArbitraryAttributeModel ) ) return false ; Remove only if key is actually present ArbitraryAttributeModel model = ( ArbitraryAttributeModel ) o ; if ( ! ArbitraryAttributeMap . this . containsKey ( model . getName ( ) ) ) return false ; The attribute should be removed only if the value matches String currentValue = ArbitraryAttributeMap . this . get ( model . getName ( ) ) ; if ( currentValue = = null ) { if ( model . getValue ( ) ! = null ) return false ; } else if ( ! currentValue . equals ( model . getValue ( ) ) ) return false ; ArbitraryAttributeMap . this . remove ( model . getName ( ) ) ; return true ; } @ Override public boolean add ( ArbitraryAttributeModel e ) { String newValue = e . getValue ( ) ; String oldValue = put ( e . getName ( ) , newValue ) ; old value was non - null if ( newValue = = null ) return oldValue ! = null ; Collection changed if value changed return ! newValue . equals ( oldValue ) ; } @ Override public boolean contains ( Object o ) { only ArbitraryAttributeModel objects if ( ! ( o instanceof ArbitraryAttributeModel ) ) return false ; No need to check the value of the attribute if the attribute is not even present ArbitraryAttributeModel model = ( ArbitraryAttributeModel ) o ; String value = get ( model . getName ( ) ) ; if ( value = = null ) return false ; The name / value pair is present only if the value matches return value . equals ( model . getValue ( ) ) ; } @ Override public Iterator < ArbitraryAttributeModel > iterator ( ) { Get iterator over all string name / value entries final Iterator < Map . Entry < String , String > > iterator = entrySet ( ) . iterator ( ) ; corresponding attribute model object as iteration continues return new Iterator < ArbitraryAttributeModel > ( ) { @ Override public boolean hasNext ( ) { return iterator . hasNext ( ) ; } @ Override public ArbitraryAttributeModel next ( ) { Map . Entry < String , String > entry = iterator . next ( ) ; return new ArbitraryAttributeModel ( entry . getKey ( ) , entry . getValue ( ) ) ; } @ Override public void remove ( ) { iterator . remove ( ) ; } } ; } @ Override public int size ( ) { return ArbitraryAttributeMap . this . size ( ) ; } } ; } 
2092	public static String saveChartAsJPEG ( JFreeChart chart , int width , int height , ChartRenderingInfo info , HttpSession session ) throws IOException { if ( chart = = null ) { throw new IllegalArgumentException ( _STR ) ) ) ; ChartUtilities . saveChartAsJPEG ( tempFile , chart , width , height , info ) ; if ( session ! = null ) { ServletUtilities . registerChartForDeletion ( tempFile , session ) ; } return tempFile . getName ( ) ; } 
2093	public void completeCall ( ) throws IOException { int tag = read ( ) ; if ( tag = = ' z ' ) { } else throw error ( _STR ) ; } 
2094	public static VectorContainer getTransferClone ( VectorAccessible incoming , OperatorContext oContext ) { VectorContainer vc = new VectorContainer ( oContext ) ; for ( VectorWrapper < ? > w : incoming ) { vc . cloneAndTransfer ( w ) ; } return vc ; } 
2095	private void deferActiveSyncH ( ActiveSyncContext asc , String why ) { SyncOperation op = asc . mSyncOperation ; runSyncFinishedOrCanceledH ( null , asc ) ; deferSyncH ( op , SYNC _ DELAY _ ON _ CONFLICT , why ) ; } 
2096	public void testHttpsBindHostKey ( ) throws Exception { Configuration conf = new HdfsConfiguration ( ) ; MiniDFSCluster cluster = null ; LOG . info ( _STR , address . startsWith ( WILDCARD _ ADDRESS ) ) ; } finally { if ( cluster ! = null ) { cluster . shutdown ( ) ; } } } 
2097	public < T > T execute ( final HttpHost target , final ClassicHttpRequest request , final HttpClientResponseHandler < ? extends T > HttpClientResponseHandler , final HttpContext context ) throws IOException { Args . notNull ( HttpClientResponseHandler , _STR , t _NUM ) ; } throw new ClientProtocolException ( t ) ; } } } 
2098	public boolean validateStateTransition ( ) { Log . v ( LOG _ TAG , String . format ( _STR ) ; return false ; } } 
2099	public boolean run ( ) throws IOException , YarnException { LOG . info ( _STR ) ; yarnClient . submitApplication ( appContext ) ; Monitor the application return monitorApplication ( appId ) ; } 
2100	public synchronized void purge ( ) { producers . clear ( ) ; pool . purge ( ) ; if ( statistics ! = null ) { statistics . clear ( ) ; } } 
2101	void startSecondaryUserServicesIfNeeded ( ) { startServicesIfNeeded ( SERVICES _ PER _ USER ) ; } 
2102	public List < String > getTokenList ( ) { checkTokenized ( ) ; final List < String > list = new ArrayList < > ( tokens . length ) ; list . addAll ( Arrays . asList ( tokens ) ) ; return list ; } 
2103	public float getVolume ( ) { return getValue ( VOLUME ) ; } 
2104	public Set < Map . Entry < K , V > > entrySet ( ) { return getCollection ( ) . getEntrySet ( ) ; } 
2105	public void clearTriples ( ) { table . clear ( ) ; } 
2106	public Finder getFinder ( TriplePattern pattern , Finder continuation ) { if ( ! isPrepared ) prepare ( ) ; Node predicate = pattern . getPredicate ( ) ; if ( predicate . isVariable ( ) ) { Want everything in the cache , the tbox and the continuation return FinderUtil . cascade ( subPropertyCache , subClassCache , continuation ) ; } else if ( subPropertyAliases . contains ( predicate ) ) { return subPropertyCache ; } else if ( subClassAliases . contains ( predicate ) ) { return subClassCache ; } else { return continuation ; } } 
2107	private void reportAGpsStatus ( int type , int status , byte [ ] ipaddr ) { switch ( status ) { case GPS _ REQUEST _ AGPS _ DATA _ CONN : if ( DEBUG ) Log . d ( TAG , _STR + status ) ; } } 
2108	public void writeCloseTag ( final Writer w , final String tag ) throws IOException { check whether the tag contains CData - we ma not indent such tags if ( this . newLineOk | | getSafeTags ( ) . isSafeForOpen ( tag ) ) { if ( this . newLineOk ) { w . write ( getLineSeparator ( ) ) ; } indent ( w , CLOSE _ TAG _ DECREASE ) ; } else { decreaseIndent ( ) ; } w . write ( _STR ) ; if ( getSafeTags ( ) . isSafeForClose ( tag ) ) { w . write ( getLineSeparator ( ) ) ; } this . newLineOk = false ; } 
2109	public static < ST , T , RT > LazyEither _NUM < ST , T , RT > fromIterable ( final Iterable < RT > iterable ) { final Iterator < RT > it = iterable . iterator ( ) ; return it . hasNext ( ) ? LazyEither _NUM . right ( it . next ( ) ) : LazyEither _NUM . left _NUM ( null ) ; } 
2110	public static Dimension measureHtmlText ( String html ) { JFrame testFrame = new JFrame ( ) ; testFrame . setLayout ( new BoxLayout ( testFrame . getContentPane ( ) , BoxLayout . PAGE _ AXIS ) ) ; JLabel testLabel = new JLabel ( html ) ; testFrame . add ( testLabel ) ; testFrame . pack ( ) ; Dimension size = testLabel . getSize ( ) ; testFrame . dispose ( ) ; return new Dimension ( size ) ; } 
2111	public static boolean isColliding ( HitBox box _NUM , HitBox box _NUM , double angle _NUM , double angle _NUM ) { populateAxes ( angle _NUM ) ; populateAxes ( angle _NUM ) ; corners ( box _NUM , angle _NUM , corners _NUM ) ; corners ( box _NUM , angle _NUM , corners _NUM ) ; boolean result = true ; for ( Vec _NUM axis : axes ) { float e _NUM Min = getMin ( corners _NUM , axis ) ; float e _NUM Max = getMax ( corners _NUM , axis ) ; float e _NUM Min = getMin ( corners _NUM , axis ) ; float e _NUM Max = getMax ( corners _NUM , axis ) ; if ( e _NUM Max < e _NUM Min | | e _NUM Max < e _NUM Min ) { result = false ; break ; } } cleanArrays ( ) ; return result ; } 
2112	public void invalidateItemsAfter ( int index ) { if ( index < _NUM ) { return ; } if ( mLastVisibleIndex < _NUM ) { return ; } if ( mLastVisibleIndex > = index ) { mLastVisibleIndex = index - _NUM ; } resetVisibleIndexIfEmpty ( ) ; if ( getFirstVisibleIndex ( ) < _NUM ) { setStart ( index ) ; } } 
2113	public static String path _NUM String ( final Object path ) { return path = = null ? null : path instanceof String ? ( String ) path : path instanceof byte [ ] [ ] ? byteArray _NUM PathString ( ( byte [ ] [ ] ) path ) : path . toString ( ) ; } 
2114	private TokenList tokens ( final QueryContext qc ) throws QueryException { final TokenList tl = new TokenList ( ) ; final Iter iter = query . iter ( qc ) ; for ( Item item ; ( item = qc . next ( iter ) ) ! = null ; ) { skip empty tokens if not all results are needed final byte [ ] qu = toToken ( item ) ; if ( qu . length ! = _NUM | | mode = = FTMode . ALL | | mode = = FTMode . ALL _ WORDS ) tl . add ( qu ) ; } return tl ; } 
2115	private static Word _NUM Vec readBinaryModel ( File modelFile , boolean linebreaks , boolean normalize ) throws NumberFormatException , IOException { InMemoryLookupTable < VocabWord > lookupTable ; VocabCache < VocabWord > cache ; INDArray syn _NUM ; int words , size ; int originalFreq = Nd _NUM j . getMemoryManager ( ) . getOccasionalGcFrequency ( ) ; boolean originalPeriodic = Nd _NUM j . getMemoryManager ( ) . isPeriodicGcActive ( ) ; if ( originalPeriodic ) Nd _NUM j . getMemoryManager ( ) . togglePeriodicGc ( false ) ; Nd _NUM j . getMemoryManager ( ) . setOccasionalGcFrequency ( _NUM _NUM _NUM _NUM _NUM ) ; try ( BufferedInputStream bis = new BufferedInputStream ( GzipUtils . isCompressedFilename ( modelFile . getName ( ) ) ? new GZIPInputStream ( new FileInputStream ( modelFile ) ) : new FileInputStream ( modelFile ) ) ; DataInputStream dis = new DataInputStream ( bis ) ) { words = Integer . parseInt ( readString ( dis ) ) ; size = Integer . parseInt ( readString ( dis ) ) ; syn _NUM = Nd _NUM j . create ( words , size ) ; cache = new AbstractCache < > ( ) ; printOutProjectedMemoryUse ( words , size , _NUM ) ; lookupTable = ( InMemoryLookupTable < VocabWord > ) new InMemoryLookupTable . Builder < VocabWord > ( ) . cache ( cache ) . useHierarchicSoftmax ( false ) . vectorLength ( size ) . build ( ) ; String word ; float [ ] vector = new float [ size ] ; for ( int i = _NUM ; i < words ; i + + ) { word = readString ( dis ) ; log . trace ( _STR + i ) ; for ( int j = _NUM ; j < size ; j + + ) { vector [ j ] = readFloat ( dis ) ; } syn _NUM . putRow ( i , normalize ? Transforms . unitVec ( Nd _NUM j . create ( vector ) ) : Nd _NUM j . create ( vector ) ) ; VocabWord vw = new VocabWord ( _NUM . _NUM , word ) ; vw . setIndex ( cache . numWords ( ) ) ; cache . addToken ( vw ) ; cache . addWordToIndex ( vw . getIndex ( ) , vw . getLabel ( ) ) ; cache . putVocabWord ( word ) ; if ( linebreaks ) { line break dis . readByte ( ) ; } Nd _NUM j . getMemoryManager ( ) . invokeGcOccasionally ( ) ; } } finally { if ( originalPeriodic ) Nd _NUM j . getMemoryManager ( ) . togglePeriodicGc ( true ) ; Nd _NUM j . getMemoryManager ( ) . setOccasionalGcFrequency ( originalFreq ) ; } lookupTable . setSyn _NUM ( syn _NUM ) ; Word _NUM Vec ret = new Word _NUM Vec . Builder ( ) . useHierarchicSoftmax ( false ) . resetModel ( false ) . layerSize ( syn _NUM . columns ( ) ) . allowParallelTokenization ( true ) . elementsLearningAlgorithm ( new SkipGram < VocabWord > ( ) ) . learningRate ( _NUM . _NUM _NUM _NUM ) . windowSize ( _NUM ) . workers ( _NUM ) . build ( ) ; ret . setVocab ( cache ) ; ret . setLookupTable ( lookupTable ) ; return ret ; } 
2116	public void deleteInsertTwo ( ) { execute ( new CreateDB ( NAME , _STR ; query ( qu ) ; } check ( size ) ; } 
2117	public String getLastTraversedText ( ) { mUiAutomatorBridge . waitForIdle ( ) ; synchronized ( mLock ) { if ( mLastTraversedText . length ( ) > _NUM ) { return mLastTraversedText ; } } return null ; } 
2118	public static void reboot ( final Context context , String reason , boolean confirm ) { mReboot = true ; mRebootSafeMode = false ; mRebootHasProgressBar = false ; mReason = reason ; shutdownInner ( context , confirm ) ; } 
2119	public static int getShiftedColor ( int color , int amount ) { final double [ ] result = ColorUtilsFromCompat . getTempDouble _NUM Array ( ) ; ColorUtilsFromCompat . colorToLAB ( color , result ) ; if ( result [ _NUM ] > = _NUM ) { result [ _NUM ] = Math . max ( _NUM , result [ _NUM ] - amount ) ; } else { result [ _NUM ] = Math . min ( _NUM _NUM _NUM , result [ _NUM ] + amount ) ; } return ColorUtilsFromCompat . LABToColor ( result [ _NUM ] , result [ _NUM ] , result [ _NUM ] ) ; } 
2120	private void setNumberOfThumbsInternal ( ) { while ( getChildCount ( ) > mNumOfThumbs ) { removeView ( getChildAt ( getChildCount ( ) - _NUM ) ) ; } while ( getChildCount ( ) < mNumOfThumbs ) { View view = createThumbView ( this ) ; LinearLayout . LayoutParams lp = new LinearLayout . LayoutParams ( mThumbWidthInPixel , mThumbHeightInPixel ) ; addView ( view , lp ) ; } int heroIndex = getHeroIndex ( ) ; for ( int i = _NUM ; i < getChildCount ( ) ; i + + ) { View child = getChildAt ( i ) ; LinearLayout . LayoutParams lp = ( LinearLayout . LayoutParams ) child . getLayoutParams ( ) ; if ( heroIndex = = i ) { lp . width = mHeroThumbWidthInPixel ; lp . height = mHeroThumbHeightInPixel ; } else { lp . width = mThumbWidthInPixel ; lp . height = mThumbHeightInPixel ; } child . setLayoutParams ( lp ) ; } } 
2121	void openPanelsAfterRestore ( ) { PanelFeatureState [ ] panels = mPanels ; if ( panels = = null ) { return ; } PanelFeatureState st ; for ( int i = panels . length - _NUM ; i > = _NUM ; i - - ) { st = panels [ i ] ; opens it when we are resuming . if ( st ! = null ) { st . applyFrozenState ( ) ; if ( ! st . isOpen & & st . wasLastOpen ) { st . isInExpandedMode = st . wasLastExpanded ; openPanel ( st , null ) ; } } } } 
2122	public boolean isAppEligibleForBackup ( String packageName ) { checkServiceBinder ( ) ; if ( sService ! = null ) { try { return sService . isAppEligibleForBackup ( packageName ) ; } catch ( RemoteException e ) { Log . e ( TAG , _STR ) ; } } return false ; } 
2123	private void addChildren ( CmsTreeItem parent , List < CmsCategoryTreeEntry > children , List < String > selectedCategories ) { if ( children ! = null ) { for ( CmsCategoryTreeEntry child : children ) { set the category tree item and add to parent tree item CmsTreeItem treeItem = buildTreeItem ( child , selectedCategories ) ; if ( ( selectedCategories ! = null ) & & selectedCategories . contains ( child . getPath ( ) ) ) { parent . setOpen ( true ) ; openParents ( parent ) ; } parent . addChild ( treeItem ) ; addChildren ( treeItem , child . getChildren ( ) , selectedCategories ) ; } } } 
2124	protected void runTest ( ) throws Throwable { Some VMs crash when calling getMethod ( null , null ) ; assertNotNull ( _STR ) ; } try { runMethod . invoke ( this ) ; } catch ( InvocationTargetException e ) { e . fillInStackTrace ( ) ; throw e . getTargetException ( ) ; } catch ( IllegalAccessException e ) { e . fillInStackTrace ( ) ; throw e ; } } 
2125	public void testComplexFailoverIntoSafemode ( ) throws Exception { banner ( _STR ) ; NameNodeAdapter . abortEditLogs ( nn _NUM ) ; cluster . transitionToActive ( _NUM ) ; assertSafeMode ( nn _NUM , _NUM , _NUM , _NUM , _NUM ) ; } 
2126	public void onDetailLevelChanged ( ) { updateTileSet ( ) ; } 
2127	private void measureChild ( View view , int otherDirParentSpecMode , boolean alreadyMeasured ) { final LayoutParams lp = ( LayoutParams ) view . getLayoutParams ( ) ; final Rect decorInsets = lp . mDecorInsets ; final int verticalInsets = decorInsets . top + decorInsets . bottom + lp . topMargin + lp . bottomMargin ; final int horizontalInsets = decorInsets . left + decorInsets . right + lp . leftMargin + lp . rightMargin ; final int availableSpaceInOther = getSpaceForSpanRange ( lp . mSpanIndex , lp . mSpanSize ) ; final int wSpec ; final int hSpec ; if ( mOrientation = = VERTICAL ) { wSpec = getChildMeasureSpec ( availableSpaceInOther , otherDirParentSpecMode , horizontalInsets , lp . width , false ) ; hSpec = getChildMeasureSpec ( mOrientationHelper . getTotalSpace ( ) , getHeightMode ( ) , verticalInsets , lp . height , true ) ; } else { hSpec = getChildMeasureSpec ( availableSpaceInOther , otherDirParentSpecMode , verticalInsets , lp . height , false ) ; wSpec = getChildMeasureSpec ( mOrientationHelper . getTotalSpace ( ) , getWidthMode ( ) , horizontalInsets , lp . width , true ) ; } measureChildWithDecorationsAndMargin ( view , wSpec , hSpec , alreadyMeasured ) ; } 
2128	protected void initialize ( ) { initializeAttributeIndices ( ) ; initializeRanges ( ) ; } 
2129	public org . bitcoinj . wallet . Protos . TransactionOutput . Builder addTransactionOutputBuilder ( ) { return getTransactionOutputFieldBuilder ( ) . addBuilder ( org . bitcoinj . wallet . Protos . TransactionOutput . getDefaultInstance ( ) ) ; } 
2130	public int readLength ( ) throws IOException { int code = read ( ) ; if ( code ! = ' l ' ) { _ peek = code ; return - _NUM ; } return parseInt ( ) ; } 
2131	public String getCdmaEriText ( int subId ) { try { ITelephony telephony = getITelephony ( ) ; if ( telephony = = null ) return null ; return telephony . getCdmaEriTextForSubscriber ( subId , getOpPackageName ( ) ) ; } catch ( RemoteException ex ) { the phone process is restarting . return null ; } catch ( NullPointerException ex ) { return null ; } } 
2132	public boolean acquireHostRead ( String instName ) { boolean copied = false ; if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( _STR + getGPUContext ( ) ) ; } copyFromDeviceToHost ( instName , false ) ; copied = true ; } return copied ; } 
2133	private static double averageWordsPerSentence ( String strText ) { int intSentenceCount = sentenceCount ( strText ) ; int intWordCount = wordCount ( strText ) ; return ( intWordCount / ( double ) intSentenceCount ) ; } 
2134	public org . apache . drill . exec . proto . UserBitShared . OperatorProfile . Builder getOperatorProfileBuilder ( int index ) { return getOperatorProfileFieldBuilder ( ) . getBuilder ( index ) ; } 
2135	public static ObjectAnimator ofObject ( Object target , String propertyName , TypeEvaluator evaluator , Object . . . values ) { ObjectAnimator anim = new ObjectAnimator ( target , propertyName ) ; anim . setObjectValues ( values ) ; anim . setEvaluator ( evaluator ) ; return anim ; } 
2136	public void addSubKey ( PGPKeyPair keyPair , PGPSignatureSubpacketVector hashedPcks , PGPSignatureSubpacketVector unhashedPcks ) throws PGPException { try { generate the certification PGPSignatureGenerator sGen = new PGPSignatureGenerator ( keySignerBuilder ) ; sGen . init ( PGPSignature . SUBKEY _ BINDING , masterKey . getPrivateKey ( ) ) ; sGen . setHashedSubpackets ( hashedPcks ) ; sGen . setUnhashedSubpackets ( unhashedPcks ) ; List subSigs = new ArrayList ( ) ; subSigs . add ( sGen . generateCertification ( masterKey . getPublicKey ( ) , keyPair . getPublicKey ( ) ) ) ; keys . add ( new PGPSecretKey ( keyPair . getPrivateKey ( ) , new PGPPublicKey ( keyPair . getPublicKey ( ) , null , subSigs ) , checksumCalculator , keyEncryptor ) ) ; } catch ( PGPException e ) { throw e ; } catch ( Exception e ) { throw new PGPException ( _STR , e ) ; } } 
2137	public AngularObject addAndNotifyRemoteProcess ( final String name , final Object o , final String noteId , final String paragraphId ) { RemoteInterpreterProcess remoteInterpreterProcess = getRemoteInterpreterProcess ( ) ; if ( ! remoteInterpreterProcess . isRunning ( ) ) { return super . add ( name , o , noteId , paragraphId , true ) ; } remoteInterpreterProcess . callRemoteFunction ( new RemoteInterpreterProcess . RemoteFunction < Void > ( ) { @ Override public Void call ( Client client ) throws Exception { Gson gson = new Gson ( ) ; client . angularObjectAdd ( name , noteId , paragraphId , gson . toJson ( o ) ) ; return null ; } } ) ; return super . add ( name , o , noteId , paragraphId , true ) ; } 
2138	protected void fixHyphens ( ) { NodeList list ; Vector < Element > hyphens ; int i ; Node node ; Node tmpNode ; boolean isLast ; get all option tags list = m _ XMLDocument . findNodes ( " + TAG _ OPTION ) ; get all hyphen tags hyphens = new Vector < Element > ( ) ; for ( i = _NUM ; i < list . getLength ( ) ; i + + ) { if ( ( ( Element ) list . item ( i ) ) . getAttribute ( ATT _ TYPE ) . equals ( VAL _ TYPE _ HYPHENS ) ) hyphens . add ( ( Element ) list . item ( i ) ) ; } check all hyphen tags whether they are at the end , if not fix it for ( i = _NUM ; i < hyphens . size ( ) ; i + + ) { node = ( Node ) hyphens . get ( i ) ; at the end ? isLast = true ; tmpNode = node ; while ( tmpNode . getNextSibling ( ) ! = null ) { normal tag ? if ( tmpNode . getNextSibling ( ) . getNodeType ( ) = = Node . ELEMENT _ NODE ) { isLast = false ; break ; } tmpNode = tmpNode . getNextSibling ( ) ; } move if ( ! isLast ) { tmpNode = node . getParentNode ( ) ; tmpNode . removeChild ( node ) ; tmpNode . appendChild ( node ) ; } } } 
2139	public static ArrayOfDoublesUpdatableSketch heapifyUpdatableSketch ( final Memory mem , final long seed ) { return ArrayOfDoublesUpdatableSketch . heapify ( mem , seed ) ; } 
2140	public static Locale parseLocale ( String localeString ) { if ( UtilValidate . isEmpty ( localeString ) ) { return null ; } Locale locale = null ; if ( localeString . length ( ) = = _NUM ) { two letter language code locale = new Locale ( localeString ) ; } else if ( localeString . length ( ) = = _NUM ) { positions _NUM - _NUM language , _NUM - _NUM are country String language = localeString . substring ( _NUM , _NUM ) ; String country = localeString . substring ( _NUM , _NUM ) ; locale = new Locale ( language , country ) ; } else if ( localeString . length ( ) > _NUM ) { positions _NUM - _NUM language , _NUM - _NUM are country , _NUM and on are special extensions String language = localeString . substring ( _NUM , _NUM ) ; String country = localeString . substring ( _NUM , _NUM ) ; String extension = localeString . substring ( _NUM ) ; locale = new Locale ( language , country , extension ) ; } else { Debug . logWarning ( _STR , module ) ; } return locale ; } 
2141	public void testSoftAlertTransitionToHardOKDoesNotCreateNotification ( ) throws Exception { AlertDefinitionEntity definition = getMockAlertDefinition ( ) ; AlertCurrentEntity current = getMockedAlertCurrentEntity ( ) ; AlertHistoryEntity history = createNiceMock ( AlertHistoryEntity . class ) ; AlertStateChangeEvent event = createNiceMock ( AlertStateChangeEvent . class ) ; Alert alert = createNiceMock ( Alert . class ) ; register a HARD / OK for the brand new alert coming in EasyMock . expect ( current . getAlertHistory ( ) ) . andReturn ( history ) . anyTimes ( ) ; EasyMock . expect ( current . getFirmness ( ) ) . andReturn ( AlertFirmness . HARD ) . atLeastOnce ( ) ; EasyMock . expect ( history . getAlertDefinition ( ) ) . andReturn ( definition ) . atLeastOnce ( ) ; EasyMock . expect ( history . getAlertState ( ) ) . andReturn ( AlertState . OK ) . atLeastOnce ( ) ; EasyMock . expect ( alert . getText ( ) ) . andReturn ( _STR ) . atLeastOnce ( ) ; EasyMock . expect ( alert . getState ( ) ) . andReturn ( AlertState . OK ) . atLeastOnce ( ) ; set the old state as being a SOFT / CRITICAL EasyMock . expect ( event . getFromState ( ) ) . andReturn ( AlertState . CRITICAL ) . anyTimes ( ) ; EasyMock . expect ( event . getFromFirmness ( ) ) . andReturn ( AlertFirmness . SOFT ) . atLeastOnce ( ) ; EasyMock . expect ( event . getCurrentAlert ( ) ) . andReturn ( current ) . atLeastOnce ( ) ; EasyMock . expect ( event . getNewHistoricalEntry ( ) ) . andReturn ( history ) . atLeastOnce ( ) ; EasyMock . expect ( event . getAlert ( ) ) . andReturn ( alert ) . atLeastOnce ( ) ; replayAll ( ) ; eventPublisher . publish ( event ) ; verifyAll ( ) ; } 
2142	public ServiceInfo < V > getServiceInfo ( V type , int userId ) { synchronized ( mServicesLock ) { Find user and lazily populate cache final UserServices < V > user = findOrCreateUserLocked ( userId ) ; if ( user . services = = null ) { generateServicesMap ( null , userId ) ; } return user . services . get ( type ) ; } } 
2143	public synchronized void write ( final Event event ) throws WriteException , InterruptedException { if ( closed ) { throw new IllegalStateException ( _STR + endPoint ) ; } batch . add ( event ) ; if ( batch . size ( ) = = writeBatchSz ) { write the event writeEventBatchToSerializer ( ) ; } Update Statistics processSize + = event . getBody ( ) . length ; eventCounter + + ; } 
2144	protected void checkPath ( Path path ) { URI uri = path . toUri ( ) ; String thatScheme = uri . getScheme ( ) ; if ( fs is relative thatScheme = = null ) return ; URI thisUri = getCanonicalUri ( ) ; String thisScheme = thisUri . getScheme ( ) ; authority and scheme are not case sensitive if ( thisScheme . equalsIgnoreCase ( thatScheme ) ) { schemes match String thisAuthority = thisUri . getAuthority ( ) ; String thatAuthority = uri . getAuthority ( ) ; if ( path ' s authority is null thatAuthority = = null & & thisAuthority ! = null ) { fs has an authority URI defaultUri = getDefaultUri ( getConf ( ) ) ; if ( thisScheme . equalsIgnoreCase ( defaultUri . getScheme ( ) ) ) { schemes match , so use this uri instead uri = defaultUri ; } else { can ' t determine auth of the path uri = null ; } } if ( uri ! = null ) { canonicalize uri before comparing with this fs uri = canonicalizeUri ( uri ) ; thatAuthority = uri . getAuthority ( ) ; if ( authorities match thisAuthority = = thatAuthority | | ( thisAuthority ! = null & & thisAuthority . equalsIgnoreCase ( thatAuthority ) ) ) return ; } } throw new IllegalArgumentException ( _STR + this . getUri ( ) ) ; } 
2145	private ExtendedIterator < Resource > allInfiniteLeft ( ) { return new LazyIterator < Resource > ( ) { @ Override public ExtendedIterator < Resource > create ( ) { return WrappedIterator . create ( infinite . iterator ( ) ) ; } } ; } 
2146	public ListenableFuture < List < Transaction > > doMaintenance ( @ Nullable KeyParameter aesKey , boolean signAndSend ) throws DeterministicUpgradeRequiresPassword { List < Transaction > txns ; lock . lock ( ) ; keyChainGroupLock . lock ( ) ; try { txns = maybeRotateKeys ( aesKey , signAndSend ) ; if ( ! signAndSend ) return Futures . immediateFuture ( txns ) ; } finally { keyChainGroupLock . unlock ( ) ; lock . unlock ( ) ; } checkState ( ! lock . isHeldByCurrentThread ( ) ) ; ArrayList < ListenableFuture < Transaction > > futures = new ArrayList < > ( txns . size ( ) ) ; TransactionBroadcaster broadcaster = vTransactionBroadcaster ; for ( Transaction tx : txns ) { try { final ListenableFuture < Transaction > future = broadcaster . broadcastTransaction ( tx ) . future ( ) ; futures . add ( future ) ; Futures . addCallback ( future , new FutureCallback < Transaction > ( ) { @ Override public void onSuccess ( Transaction transaction ) { log . info ( _STR , e ) ; } } return Futures . allAsList ( futures ) ; } 
2147	protected T initialize ( ) throws Exception { return callable . call ( ) ; } 
2148	public Set < String > getComponentStreams ( String componentId ) { return getComponentCommon ( componentId ) . get _ streams ( ) . keySet ( ) ; } 
2149	public WarmupRegionResponse warmupRegion ( final RpcController controller , final WarmupRegionRequest request ) throws ServiceException { final RegionInfo region = ProtobufUtil . toRegionInfo ( request . getRegionInfo ( ) ) ; TableDescriptor htd ; WarmupRegionResponse response = WarmupRegionResponse . getDefaultInstance ( ) ; try { checkOpen ( ) ; String encodedName = region . getEncodedName ( ) ; byte [ ] encodedNameBytes = region . getEncodedNameAsBytes ( ) ; final HRegion onlineRegion = regionServer . getRegion ( encodedName ) ; if ( onlineRegion ! = null ) { LOG . info ( _STR + region . getRegionNameAsString ( ) , ie ) ; throw new ServiceException ( ie ) ; } return response ; } 
2150	protected void doGet ( final HttpServletRequest req , final HttpServletResponse resp ) throws ServletException , IOException { doPost ( req , resp ) ; } 
2151	public synchronized boolean remove ( String key ) throws IOException { checkNotClosed ( ) ; validateKey ( key ) ; Entry entry = lruEntries . get ( key ) ; if ( entry = = null | | entry . currentEditor ! = null ) { return false ; } for ( int i = _NUM ; i < valueCount ; i + + ) { File file = entry . getCleanFile ( i ) ; if ( file . exists ( ) & & ! file . delete ( ) ) { throw new IOException ( _STR + file ) ; } size - = entry . lengths [ i ] ; entry . lengths [ i ] = _NUM ; } redundantOpCount + + ; journalWriter . append ( REMOVE + ' ' + key + ' \ n ' ) ; lruEntries . remove ( key ) ; if ( journalRebuildRequired ( ) ) { executorService . submit ( cleanupCallable ) ; } return true ; } 
2152	private void callOnActive ( Runnable r ) { synchronized ( onActiveListeners ) { if ( isActive ) { r . run ( ) ; } else { onActiveListeners . add ( r ) ; } } } 
2153	public JarEntry getNextJarEntry ( ) throws IOException { return ( JarEntry ) getNextEntry ( ) ; } 
2154	public GenericValue next ( ) { try { if ( resultSet . next ( ) ) { return currentGenericValue ( ) ; } else { return null ; } } catch ( SQLException e ) { if ( ! closed ) { try { this . close ( ) ; } catch ( GenericEntityException e _NUM ) { Debug . logError ( e _NUM , _STR , e ) ; } } 
2155	protected void selectionChanged ( String changedSelector ) { if ( controller ! = null ) { controller . prepare ( changedSelector ) ; updateEnabledState ( ) ; } } 
2156	public boolean verifyRemote ( Socket socket ) { InetAddress host _NUM , host _NUM ; host _NUM = socket . getInetAddress ( ) ; host _NUM = getRemoteAddress ( ) ; return host _NUM . equals ( host _NUM ) ; } 
2157	protected void onClickAllAppsButton ( View v ) { if ( LOGD ) Log . d ( TAG , _STR ) ; if ( ! isAppsViewVisible ( ) ) { getUserEventDispatcher ( ) . logActionOnControl ( LauncherLogProto . Action . TAP , LauncherLogProto . ALL _ APPS _ BUTTON ) ; showAppsView ( true , true , false ) ; } } 
2158	public void testEnable ( ) { int iterations = BluetoothTestRunner . sEnableIterations ; if ( iterations = = _NUM ) { return ; } for ( int i = _NUM ; i < iterations ; i + + ) { mTestUtils . writeOutput ( _STR + iterations ) ; mTestUtils . enable ( mAdapter ) ; mTestUtils . disable ( mAdapter ) ; } } 
2159	private Process startProxy ( MiniAccumuloConfigImpl cfg ) throws IOException { File proxyPropertiesFile = generateNewProxyConfiguration ( cfg ) ; return mac . exec ( Proxy . class , _STR , proxyPropertiesFile . getCanonicalPath ( ) ) ; } 
2160	public void failedFlushInternal ( boolean batchingEnabled ) throws Exception { setupAsyncJournalWriter ( batchingEnabled ) ; int entries = _NUM ; for ( int i = _NUM ; i < entries ; i + + ) { long flushCounter = mAsyncJournalWriter . appendEntry ( JournalEntry . getDefaultInstance ( ) ) ; Assuming the flush counter starts from _NUM assertEquals ( i + _NUM , flushCounter ) ; } Start failing journal flushes . doThrow ( new IOException ( _STR ) ; } catch ( IOException e ) { This is expected . } } Allow journal flushes to succeed . doNothing ( ) . when ( mMockJournalWriter ) . flush ( ) ; Flushes should succeed . for ( int i = _NUM ; i < = entries ; i + + ) { mAsyncJournalWriter . flush ( i ) ; } if ( batchingEnabled ) { verify ( mMockJournalWriter , atLeastOnce ( ) ) . flush ( ) ; } else { The first half of the calls were the failed flush calls . verify ( mMockJournalWriter , times ( _NUM * entries ) ) . flush ( ) ; } } 
2161	public static NSObject parse ( File f ) throws IOException , PropertyListFormatException , ParseException , ParserConfigurationException , SAXException { FileInputStream fis = new FileInputStream ( f ) ; int type = determineType ( fis ) ; fis . close ( ) ; switch ( type ) { case TYPE _ BINARY : return BinaryPropertyListParser . parse ( f ) ; case TYPE _ XML : return XMLPropertyListParser . parse ( f ) ; case TYPE _ ASCII : return ASCIIPropertyListParser . parse ( f ) ; default : throw new PropertyListFormatException ( _STR ) ; } } 
2162	public void propertyChange ( PropertyChangeEvent event ) { fireChangeEvent ( ) ; } 
2163	public String getCacheKeyForUserPermissions ( String prefix , CmsDbContext context , CmsResource resource , CmsPermissionSet requiredPermissions ) { if ( ! context . getProjectId ( ) . isNullUUID ( ) ) { return _STR ) ; cacheBuffer . append ( requiredPermissions . getPermissionString ( ) ) ; cacheBuffer . append ( ' _ ' ) ; cacheBuffer . append ( resource . getStructureId ( ) . toString ( ) ) ; return cacheBuffer . toString ( ) ; } 
2164	public static int getGCount ( Node r , int n ) { Edge e ; if ( r . getChild ( _NUM ) ! = null & & r . getCVisible ( ) ) { n + + ; for ( int noa = _NUM ; ( e = r . getChild ( noa ) ) ! = null ; noa + + ) { n = getGCount ( e . getTarget ( ) , n ) ; } } return n ; } 
2165	protected boolean addChunk ( Chunk chunk ) { Font f = chunk . getFont ( ) ; String c = chunk . getContent ( ) ; if ( font ! = null & & ! font . isStandardFont ( ) ) { f = font . difference ( chunk . getFont ( ) ) ; } if ( size ( ) > _NUM & & ! chunk . hasAttributes ( ) ) { try { Chunk previous = ( Chunk ) get ( size ( ) - _NUM ) ; if ( ! previous . hasAttributes ( ) & & ( f = = null | | f . compareTo ( previous . getFont ( ) ) = = _NUM ) & & ! _STR . equals ( c . trim ( ) ) ) { previous . append ( c ) ; return true ; } } catch ( ClassCastException cce ) { } } Chunk newChunk = new Chunk ( c , f ) ; newChunk . setAttributes ( chunk . getAttributes ( ) ) ; if ( hyphenation ! = null & & newChunk . getHyphenation ( ) = = null & & ! newChunk . isEmpty ( ) ) { newChunk . setHyphenation ( hyphenation ) ; } return super . add ( newChunk ) ; } 
2166	public void performRequest ( String request ) { if ( request . compareTo ( _STR ) ; } } 
2167	 / * * * Search the specified arrays for a contiguous sequence of identical bytes , starting at the * specified _STR offsets and scanning as far ahead as possible till one or the other of the * arrays ends or a non - matching byte is found . Returns the length of the matching sequence of * bytes , which may be zero . * * @ param oldData the old data to scan * @ param oldStart the position in the old data at which to start the scan * @ param newData the new data to scan * @ param newStart the position in the new data at which to start the scan * @ return the number of matching bytes in the two arrays starting at the specified indices ; zero * if the first byte fails to match * Visible for testing onlystatic int lengthOfMatch ( final RandomAccessObject oldData , final int oldStart , final RandomAccessObject newData , final int newStart ) throws IOException { final int max = Math . min ( ( int ) oldData . length ( ) - oldStart , ( int ) newData . length ( ) - newStart ) ; if ( max > _NUM ) { If max is _NUM , it ' s sometimes possible for this seek to seek to length + _NUM and throw an exception unnecessarily . oldData . seek ( oldStart ) ; newData . seek ( newStart ) ; for ( int offset = _NUM ; offset < max ; offset + + ) { if ( oldData . readByte ( ) ! = newData . readByte ( ) ) { return offset ; } } } return max ; } 
2168	public V get ( K key ) { return map ( key ) . get ( key ) ; } 
2169	public String getOuFqn ( ) { return CmsOrganizationalUnit . removeLeadingSeparator ( m _ ouFqn ) ; } 
2170	protected void processCommit ( Exchange exchange ) { try { if ( shouldDelete ( exchange ) ) { String receiptHandle = exchange . getIn ( ) . getHeader ( SqsConstants . RECEIPT _ HANDLE , String . class ) ; DeleteMessageRequest deleteRequest = new DeleteMessageRequest ( getQueueUrl ( ) , receiptHandle ) ; LOG . trace ( _STR , exchange , e ) ; } } 
2171	public static < I extends WritableComparable , E extends WritableComparable > boolean equal ( Edge < I , E > e _NUM , Edge < I , E > e _NUM ) { return compareEdges ( e _NUM , e _NUM ) = = _NUM ; } 
2172	public void cleanUpAfterInit ( ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( _STR ) ; } ContainerHolder . clear ( ) ; } 
2173	public boolean validateStructureIdExists ( CmsDbContext dbc , CmsUUID projectId , CmsUUID structureId ) throws CmsDataAccessException { Connection conn = null ; PreparedStatement stmt = null ; ResultSet res = null ; boolean found = false ; int count = _NUM ; try { conn = m _ sqlManager . getConnection ( dbc ) ; stmt = m _ sqlManager . getPreparedStatement ( conn , projectId , _STR ) ; stmt . setString ( _NUM , structureId . toString ( ) ) ; res = stmt . executeQuery ( ) ; if ( res . next ( ) ) { count = res . getInt ( _NUM ) ; found = ( count = = _NUM ) ; while ( res . next ( ) ) { do nothing only move through all rows because of mssql odbc driver } } else { found = false ; } } catch ( SQLException e ) { throw new CmsDbSqlException ( Messages . get ( ) . container ( Messages . ERR _ GENERIC _ SQL _ _NUM , CmsDbSqlException . getErrorQuery ( stmt ) ) , e ) ; } finally { m _ sqlManager . closeAll ( dbc , conn , stmt , res ) ; } return found ; } 
2174	public void setSelected ( boolean selected ) { this . selected = selected ; repaint ( ) ; } 
2175	public BigInteger calculateKeyingMaterial ( ) { if ( this . state > = STATE _ KEY _ CALCULATED ) { throw new IllegalStateException ( _STR + participantId ) ; } BigInteger s = JPAKEUtil . calculateS ( password ) ; Arrays . fill ( password , ( char ) _NUM ) ; this . password = null ; BigInteger keyingMaterial = JPAKEUtil . calculateKeyingMaterial ( p , q , gx _NUM , x _NUM , s , b ) ; this . x _NUM = null ; this . x _NUM = null ; this . b = null ; this . state = STATE _ KEY _ CALCULATED ; return keyingMaterial ; } 
2176	Modify the preference key with prefix _STR + key + String . valueOf ( slotId ) ; pref . setKey ( key ) ; updateTitle ( pref , slotId ) ; } } } 
2177	public void callEvent ( Event event ) { if ( event . isAsynchronous ( ) ) { if ( Thread . holdsLock ( this ) ) { throw new IllegalStateException ( event . getEventName ( ) + _STR ) ; } fireEvent ( event ) ; } else { synchronized ( this ) { fireEvent ( event ) ; } } } 
2178	public byte [ ] getSecondaryKey ( ) throws NTLMEngineException { if ( secondaryKey = = null ) { secondaryKey = makeSecondaryKey ( random ) ; } return secondaryKey ; } 
2179	public int getLayoutHeight ( ) { if ( scrollableY ) { return Math . max ( getHeight ( ) , getPreferredH ( ) ) ; } else { Container parent = getScrollableParent ( ) ; if ( parent ! = null & & parent . scrollableY ) { return Math . max ( getHeight ( ) , getPreferredH ( ) ) ; } int height = getHeight ( ) ; if ( height < = _NUM ) { return getPreferredH ( ) ; } return height ; } } 
2180	public void notifyChildMoved ( int parentPosition , int fromChildPosition , int toChildPosition ) { P parent = mParentList . get ( parentPosition ) ; int flatParentPosition = getFlatParentPosition ( parentPosition ) ; ExpandableWrapper < P , C > parentWrapper = mFlatItemList . get ( flatParentPosition ) ; parentWrapper . setParent ( parent ) ; if ( parentWrapper . isExpanded ( ) ) { ExpandableWrapper < P , C > fromChild = mFlatItemList . remove ( flatParentPosition + _NUM + fromChildPosition ) ; mFlatItemList . add ( flatParentPosition + _NUM + toChildPosition , fromChild ) ; notifyItemMoved ( flatParentPosition + _NUM + fromChildPosition , flatParentPosition + _NUM + toChildPosition ) ; } } 
2181	private boolean parseBackticks ( ) { String ticks = match ( TICKS _ HERE ) ; if ( ticks = = null ) { return false ; } int afterOpenTicks = index ; String matched ; while ( ( matched = match ( TICKS ) ) ! = null ) { if ( matched . equals ( ticks ) ) { Code node = new Code ( ) ; String content = input . substring ( afterOpenTicks , index - ticks . length ( ) ) ; String literal = WHITESPACE . matcher ( content . trim ( ) ) . replaceAll ( _STR ) ; node . setLiteral ( literal ) ; appendNode ( node ) ; return true ; } } If we got here , we didn ' t match a closing backtick sequence . index = afterOpenTicks ; appendText ( ticks ) ; return true ; } 
2182	public Identifier generateSequenceIdentifier ( ) { return reliableEndpoint . getManager ( ) . getIdGenerator ( ) . generateSequenceIdentifier ( ) ; } 
2183	public void testHeaders _NUM ( ) throws Exception { MessageSerializer serializer = MAINNET . getDefaultSerializer ( ) ; byte [ ] headersMessageBytes = HEX . decode ( _STR , thirdBlock . getHashAsString ( ) ) ; assertEquals ( _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM L , thirdBlock . getNonce ( ) ) ; ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream ( ) ; serializer . serialize ( headersMessage , byteArrayOutputStream ) ; byte [ ] serializedBytes = byteArrayOutputStream . toByteArray ( ) ; assertArrayEquals ( headersMessageBytes , serializedBytes ) ; } 
2184	public Node getMatchObject ( ) { return anyToNull ( obj ) ; } 
2185	protected final int appendVisibleItemToRow ( int itemIndex , int rowIndex , int location ) { int offset ; if ( mLastVisibleIndex > = _NUM ) { if ( mLastVisibleIndex ! = getLastIndex ( ) | | mLastVisibleIndex ! = itemIndex - _NUM ) { should never hit this when we append a new item with a new Location object . throw new IllegalStateException ( ) ; } } if ( mLastVisibleIndex < _NUM ) { the offset later when prependVisbleItemsWithCache ( ) if ( mLocations . size ( ) > _NUM & & itemIndex = = getLastIndex ( ) + _NUM ) { offset = calculateOffsetAfterLastItem ( rowIndex ) ; } else { offset = _NUM ; } } else { offset = location - mProvider . getEdge ( mLastVisibleIndex ) ; } Location loc = new Location ( rowIndex , offset , _NUM ) ; mLocations . addLast ( loc ) ; Object item ; if ( mPendingItem ! = null ) { loc . size = mPendingItemSize ; item = mPendingItem ; mPendingItem = null ; } else { loc . size = mProvider . createItem ( itemIndex , true , mTmpItem , false ) ; item = mTmpItem [ _NUM ] ; } if ( mLocations . size ( ) = = _NUM ) { mFirstIndex = mFirstVisibleIndex = mLastVisibleIndex = itemIndex ; } else { if ( mLastVisibleIndex < _NUM ) { mFirstVisibleIndex = mLastVisibleIndex = itemIndex ; } else { mLastVisibleIndex + + ; } } mProvider . addItem ( item , itemIndex , loc . size , rowIndex , location ) ; return loc . size ; } 
2186	public void testReplaceStreamWithLess ( ) throws Exception { NPOIFSFileSystem fs = new NPOIFSFileSystem ( _ inst . openResourceAsStream ( _STR ) ) ; byte [ ] data = new byte [ _NUM _NUM _NUM ] ; for ( int i = _NUM ; i < data . length ; i + + ) { data [ i ] = ( byte ) ( i % _NUM _NUM _NUM ) ; } _NUM _NUM - > _NUM _NUM - > end assertEquals ( _NUM _NUM , fs . getNextBlock ( _NUM _NUM ) ) ; assertEquals ( POIFSConstants . END _ OF _ CHAIN , fs . getNextBlock ( _NUM _NUM ) ) ; Create a _NUM block stream , will become a _NUM block one NPOIFSStream stream = new NPOIFSStream ( fs , _NUM _NUM ) ; stream . updateContents ( data ) ; _NUM _NUM should now be the end , and _NUM _NUM free assertEquals ( POIFSConstants . END _ OF _ CHAIN , fs . getNextBlock ( _NUM _NUM ) ) ; assertEquals ( POIFSConstants . UNUSED _ BLOCK , fs . getNextBlock ( _NUM _NUM ) ) ; Check the reading of blocks Iterator < ByteBuffer > it = stream . getBlockIterator ( ) ; assertEquals ( true , it . hasNext ( ) ) ; ByteBuffer b = it . next ( ) ; assertEquals ( false , it . hasNext ( ) ) ; Now check the contents data = new byte [ _NUM _NUM _NUM ] ; b . get ( data ) ; for ( int i = _NUM ; i < data . length ; i + + ) { byte exp = ( byte ) ( i % _NUM _NUM _NUM ) ; assertEquals ( exp , data [ i ] ) ; } fs . close ( ) ; } 
2187	public ArrayList getChunks ( ) { ArrayList tmp = new ArrayList ( ) ; for ( Iterator i = iterator ( ) ; i . hasNext ( ) ; ) { tmp . addAll ( ( ( Element ) i . next ( ) ) . getChunks ( ) ) ; } return tmp ; } 
2188	public void asFilesIterable _ DisallowOverwrite _ MultipleFiles _ SomeOutputFilesDoNotExist ( ) throws IOException { set up File sourceFile = new File ( _STR ) ; copy the image to a temporary file . TestUtils . copyFile ( sourceFile , originalFile ) ; TestUtils . copyFile ( sourceFile , fileThatExists ) ; given when List < File > list = Thumbnails . of ( originalFile , originalFile ) . size ( _NUM _NUM _NUM , _NUM _NUM _NUM ) . allowOverwrite ( false ) . asFiles ( Arrays . asList ( fileThatDoesntExist , fileThatExists ) ) ; then assertTrue ( fileThatDoesntExist . exists ( ) ) ; assertTrue ( fileThatExists . exists ( ) ) ; assertTrue ( sourceFile . length ( ) = = fileThatExists . length ( ) ) ; assertEquals ( Arrays . asList ( fileThatDoesntExist ) , list ) ; clean up originalFile . delete ( ) ; fileThatDoesntExist . delete ( ) ; fileThatExists . delete ( ) ; } 
2189	public void setParams ( INDArray params ) { if ( flattenedParams = = params ) { No op return ; } if ( flattenedParams ! = null & & params . length ( ) = = flattenedParams . length ( ) ) { if ( params ! = flattenedParams ) { flattenedParams . assign ( params ) ; } } else { if ( flattenedParams = = null ) flattenedParams = params . dup ( ) ; int idx = _NUM ; for ( int i = _NUM ; i < getLayers ( ) . length ; i + + ) { Layer layer = getLayer ( i ) ; int range = layer . numParams ( ) ; if ( range < = _NUM ) Some layers : no parameters ( subsampling , etc ) continue ; INDArray get = params . get ( NDArrayIndex . point ( _NUM ) , NDArrayIndex . interval ( idx , range + idx ) ) ; layer . setParams ( get ) ; idx + = range ; } } } 
2190	public static String format ( final Date date , final String pattern , final TimeZone timeZone , final Locale locale ) { final FastDateFormat df = FastDateFormat . getInstance ( pattern , timeZone , locale ) ; return df . format ( date ) ; } 
2191	public static Map < Integer , NodePort > computeNewTaskToNodePort ( NimbusData data , String topologyid , Assignment existingAssignment , StormClusterState stormClusterState , RunnableCallback callback , Map < String , SupervisorInfo > supInfos , boolean isScratch ) throws IOException { taskheartcache ( Map < stormid , Map < taskid , Map < tkHbCacheTime , time > > > ) ConcurrentHashMap < String , Map < Integer , Map < TkHbCacheTime , Integer > > > taskHeartbeatsCache = data . getTaskHeartbeatsCache ( ) ; Map < ? , ? > topology _ conf = readStormConf ( data . getConf ( ) , topologyid ) ; ï¿½ ï¿½ È¡ ï¿½ ï¿½ ï¿½ Ð¿ ï¿½ ï¿½ ï¿½ Slots , ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ Ç° topology timeout ï¿½ Ä¶ Ë¿ Ú£ ï¿½ ï¿½ Úº ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ timeout ï¿½ Ä¶ Ë¿ Ú½ ï¿½ ï¿½ ï¿½ add Set < NodePort > availableSlots = availableSlots ( supInfos , stormClusterState , callback ) ; ï¿½ ï¿½ È¡ ï¿½ ï¿½ ï¿½ ï¿½ taskid = = / tasks / topologyid / ï¿½ Â½ Úµ ï¿½ ï¿½ Ð± ï¿½ Set < Integer > allTaskIds = StormUtils . listToSet ( stormClusterState . task _ ids ( topologyid ) ) ; Map < NodePort , List < Integer > > existingAssigned = new HashMap < NodePort , List < Integer > > ( ) ; if ( existingAssignment ! = null ) { Map < NodePort , List > existingAssigned = StormUtils . reverse _ map ( existingAssignment . getTaskToNodeport ( ) ) ; } Í¨ ï¿½ ï¿½ taskheartcache ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ È¡ ï¿½ ï¿½ Ç° ï¿½ ï¿½ ï¿½ ï¿½ task Set < Integer > aliveIds = null ; if ( isScratch ) { isScratch rebalance ï¿½ Ð¶ Ï£ ï¿½ aliveIds = allTaskIds ; } else if ( existingAssignment ! = null ) { aliveIds = aliveTasks ( data . getConf ( ) , topologyid , stormClusterState , allTaskIds , existingAssignment . getTaskStartTimeSecs ( ) , taskHeartbeatsCache ) ; } Map < NodePort , List < Integer > > aliveAssigned = new HashMap < NodePort , List < Integer > > ( ) ; if ( existingAssignment ! = null ) { ï¿½ ï¿½ È¡ ï¿½ Ñ± ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ NodePort ï¿½ ï¿½ task ï¿½ Ð± ï¿½ ï¿½ ï¿½ Ï¢ for ( Entry < NodePort , List < Integer > > entry : existingAssigned . entrySet ( ) ) { NodePort np = entry . getKey ( ) ; List < Integer > tasks = entry . getValue ( ) ; if ( aliveIds ! = null & & aliveIds . containsAll ( tasks ) ) { ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ Ò» ï¿½ ï¿½ taskid ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ aliveIds ï¿½ Ð£ ï¿½ ï¿½ ï¿½ ï¿½ NodePort ï¿½ ï¿½ ï¿½ ï¿½ task ï¿½ ï¿½ ï¿½ á±» ï¿½ ï¿½ ï¿½ Â· ï¿½ ï¿½ ä¡£ aliveAssigned . put ( np , tasks ) ; } } } ï¿½ ï¿½ È¡ TOPOLOGY _ WORKERS Integer workers = _NUM ; if ( topology _ conf . get ( Config . TOPOLOGY _ WORKERS ) instanceof Long ) { Long tmp = ( Long ) topology _ conf . get ( Config . TOPOLOGY _ WORKERS ) ; workers = Integer . parseInt ( tmp . toString ( ) ) ; } else { workers = ( Integer ) topology _ conf . get ( Config . TOPOLOGY _ WORKERS ) ; } ï¿½ ï¿½ È¡ ï¿½ Üµ ï¿½ slots Ê¹ ï¿½ ï¿½ ï¿½ ï¿½ int totalSlotsToUse = Math . min ( workers , availableSlots . size ( ) + aliveAssigned . size ( ) ) ; IAssignment customAssignment = CustomAssignment . getAssignmentInstance ( topology _ conf ) ; Map < NodePort , List < Integer > > keepAssigned = null ; if ( ! isScratch & & allTaskIds ! = null ) { ï¿½ ï¿½ È¡ ï¿½ ï¿½ ï¿½ Ö¾ ï¿½ ï¿½ ï¿½ ï¿½ nodeport ï¿½ ï¿½ task ï¿½ Ä· ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ Ï¢ if ( customAssignment ! = null ) { keepAssigned = customAssignment . keeperSlots ( aliveAssigned , allTaskIds . size ( ) , totalSlotsToUse ) ; } else { < NodePort , List > keepAssigned = keeperSlots ( aliveAssigned , allTaskIds . size ( ) , totalSlotsToUse ) ; } } ï¿½ ï¿½ ï¿½ Â· ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ int reassign _ num = totalSlotsToUse ; if ( keepAssigned ! = null ) { for ( Entry < NodePort , List < Integer > > entry : keepAssigned . entrySet ( ) ) { aliveAssigned . remove ( entry . getKey ( ) ) ; } reassign _ num = totalSlotsToUse - keepAssigned . size ( ) ; } ï¿½ ï¿½ È¡ ï¿½ ï¿½ ï¿½ Ð¿ ï¿½ ï¿½ Ðµ ï¿½ slot Set < NodePort > freedSlots = new HashSet < NodePort > ( ) ; Set < NodePort > freedSlotstmp = aliveAssigned . keySet ( ) ; if ( freedSlotstmp . size ( ) = = _NUM ) { freedSlotstmp = new HashSet < NodePort > ( ) ; } freedSlots . addAll ( freedSlotstmp ) ; freedSlots . addAll ( availableSlots ) ; if ( customAssignment ! = null ) { customAssignment . setup ( topology _ conf , topologyid , stormClusterState , keepAssigned , supInfos ) ; } Collection < List < Integer > > keepAssignedTaskSet = null ; if ( keepAssigned ! = null ) { keepAssignedTaskSet = keepAssigned . values ( ) ; } Set < Integer > reassignIds = null ; if ( allTaskIds ! = null ) { reassignIds = new HashSet < Integer > ( allTaskIds ) ; } if ( keepAssignedTaskSet ! = null & & reassignIds ! = null ) { FIXME ï¿½ ï¿½ ï¿½ ï¿½ Ö± ï¿½ Ó¶ ï¿½ keepAssignedTaskSet ï¿½ ï¿½ ï¿½ ï¿½ removeAll , ï¿½ ï¿½ Ð§ ï¿½ ï¿½ yannian add for ( List < Integer > rm : keepAssignedTaskSet ) { reassignIds . removeAll ( rm ) ; } } ï¿½ ï¿½ ï¿½ ï¿½ Î´ keep ï¿½ ï¿½ task ï¿½ ï¿½ ï¿½ ï¿½ Ó¦ ï¿½ ï¿½ slot ï¿½ ï¿½ ï¿½ æ¡£ Map < Integer , NodePort > reassignment = new HashMap < Integer , NodePort > ( ) ; List < NodePort > reassignSlots = null ; List < NodePort > sortedFreeSlots = sortSlots ( freedSlots ) ; ï¿½ ï¿½ È¡ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ Òª ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ slots ï¿½ Úµ ï¿½ if ( customAssignment ! = null ) { reassignSlots = customAssignment . slotsAssignment ( sortedFreeSlots , reassign _ num , reassignIds ) ; } else { if ( sortedFreeSlots ! = null ) { reassignSlots = sortedFreeSlots . subList ( _NUM , reassign _ num ) ; } } ï¿½ ï¿½ ï¿½ ï¿½ Î´ keep ï¿½ ï¿½ task ï¿½ ï¿½ ï¿½ ï¿½ Ó¦ ï¿½ ï¿½ slot ï¿½ ï¿½ ï¿½ æ¡£ if ( customAssignment ! = null ) { reassignment = customAssignment . tasksAssignment ( reassignSlots , reassignIds ) ; } else { int index = _NUM ; if ( reassignIds ! = null & & reassignSlots ! = null & & reassignSlots . size ( ) ! = _NUM ) { for ( Iterator < Integer > it = reassignIds . iterator ( ) ; it . hasNext ( ) ; ) { Integer entry = it . next ( ) ; if ( index > = reassignSlots . size ( ) ) { index = _NUM ; } reassignment . put ( entry , reassignSlots . get ( index ) ) ; index + + ; } } } ×ª ï¿½ ï¿½ ï¿½ ï¿½ È¡ keepAssigned ï¿½ ï¿½ ï¿½ Ãµ ï¿½ key Îª taskid ï¿½ ï¿½ value Îª NodePort ï¿½ ï¿½ map Map < Integer , NodePort > stayAssignment = new HashMap < Integer , NodePort > ( ) ; if ( keepAssigned ! = null ) { for ( Entry < NodePort , List < Integer > > entry : keepAssigned . entrySet ( ) ) { NodePort np = entry . getKey ( ) ; List < Integer > tasks = entry . getValue ( ) ; for ( Integer taskid : tasks ) { stayAssignment . put ( taskid , np ) ; } } } if ( reassignment . size ( ) > _NUM ) { LOG . info ( _STR + availableSlots ) ; } ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ Â· ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ ï¿½ reassignment . putAll ( stayAssignment ) ; if ( customAssignment ! = null ) { customAssignment . cleanup ( ) ; } return reassignment ; } 
2192	public static UnfilteredRowIterator merge ( List < UnfilteredRowIterator > iterators , int nowInSec ) { assert ! iterators . isEmpty ( ) ; if ( iterators . size ( ) = = _NUM ) return iterators . get ( _NUM ) ; return UnfilteredRowMergeIterator . create ( iterators , nowInSec , null ) ; } 
2193	public static boolean isValidKeyLengthForAlgorithm ( int keyLength , final String algorithm ) { if ( StringUtils . isEmpty ( algorithm ) ) { return false ; } return getValidKeyLengthsForAlgorithm ( algorithm ) . contains ( keyLength ) ; } 
2194	private RegionInfo [ ] cloneHdfsRegions ( final ThreadPoolExecutor exec , final Map < String , SnapshotRegionManifest > regionManifests , final List < RegionInfo > regions ) throws IOException { if ( regions = = null | | regions . isEmpty ( ) ) return null ; final Map < String , RegionInfo > snapshotRegions = new HashMap < > ( regions . size ( ) ) ; clone region info ( change embedded tableName with the new one ) RegionInfo [ ] clonedRegionsInfo = new RegionInfo [ regions . size ( ) ] ; for ( int i = _NUM ; i < clonedRegionsInfo . length ; + + i ) { clone the region info from the snapshot region info RegionInfo snapshotRegionInfo = regions . get ( i ) ; clonedRegionsInfo [ i ] = cloneRegionInfo ( snapshotRegionInfo ) ; add the region name mapping between snapshot and cloned String snapshotRegionName = snapshotRegionInfo . getEncodedName ( ) ; String clonedRegionName = clonedRegionsInfo [ i ] . getEncodedName ( ) ; regionsMap . put ( Bytes . toBytes ( snapshotRegionName ) , Bytes . toBytes ( clonedRegionName ) ) ; LOG . info ( _STR + clonedRegionName ) ; Add mapping between cloned region name and snapshot region info snapshotRegions . put ( clonedRegionName , snapshotRegionInfo ) ; } create the regions on disk ModifyRegionUtils . createRegions ( exec , conf , rootDir , tableDesc , clonedRegionsInfo , new ModifyRegionUtils . RegionFillTask ( ) { @ Override public void fillRegion ( final HRegion region ) throws IOException { RegionInfo snapshotHri = snapshotRegions . get ( region . getRegionInfo ( ) . getEncodedName ( ) ) ; cloneRegion ( region , snapshotHri , regionManifests . get ( snapshotHri . getEncodedName ( ) ) ) ; } } ) ; return clonedRegionsInfo ; } 
2195	CompletableFuture < Void > close ( ) { return closeClient ( ) . thenCompose ( v - > closeServer ( ) ) ; } 
2196	public String multiResultsetSummary ( int comparisonColumn ) throws Exception { int [ ] [ ] nonSigWin = new int [ getNumResultsets ( ) ] [ getNumResultsets ( ) ] ; int [ ] [ ] win = multiResultsetWins ( comparisonColumn , nonSigWin ) ; initResultMatrix ( ) ; m _ ResultMatrix . setSummary ( nonSigWin , win ) ; return m _ ResultMatrix . toStringSummary ( ) ; } 
2197	public static INDArray create ( List < ? extends Number > list ) { INDArray array = create ( list . size ( ) ) ; int cnt = _NUM ; if ( dataType ( ) = = DataBuffer . Type . DOUBLE ) { for ( Number element : list ) { array . putScalar ( cnt + + , element . doubleValue ( ) ) ; } } else { for ( Number element : list ) { array . putScalar ( cnt + + , element . floatValue ( ) ) ; } } return array ; } 
2198	private boolean isRw _NUM Format ( byte [ ] signatureCheckBytes ) throws IOException { ByteOrderedDataInputStream signatureInputStream = new ByteOrderedDataInputStream ( signatureCheckBytes ) ; Read byte order mExifByteOrder = readByteOrder ( signatureInputStream ) ; Set byte order signatureInputStream . setByteOrder ( mExifByteOrder ) ; short signatureByte = signatureInputStream . readShort ( ) ; signatureInputStream . close ( ) ; return signatureByte = = RW _NUM _ SIGNATURE ; } 
2199	public void releaseMatrixInput ( String varName ) { getMatrixObject ( varName ) . release ( ) ; } 
2200	void hide ( long duration ) { if ( mShowing & & ( mTargetAlpha ! = _NUM | | durationEndsEarlier ( duration ) ) ) { if ( DEBUG _ DIM _ LAYER ) Slog . v ( TAG , _STR + duration ) ; show ( mLayer , _NUM , duration ) ; } } 
2201	private List < FSFontInfo > loadDiskCache ( List < File > files ) { Set < String > pending = new HashSet < > ( ) ; for ( File file : files ) { pending . add ( file . getAbsolutePath ( ) ) ; } List < FSFontInfo > results = new ArrayList < > ( ) ; Get the disk cache File file = null ; boolean fileExists = false ; try { file = getDiskCacheFile ( ) ; fileExists = file . exists ( ) ; } catch ( SecurityException e ) { LOG . debug ( _STR ) ; return null ; } return results ; } 
2202	public void addOwner ( String value ) { addQualifiedBagValue ( OWNER , value ) ; } 
2203	protected void addIoRegistries ( final Map < String , Object > config , final Mapper . Builder builder ) { final List < String > classNameList = getListStringFromConfig ( TOKEN _ IO _ REGISTRIES , config ) ; classNameList . stream ( ) . forEach ( className - > { try { final Class < ? > clazz = Class . forName ( className ) ; try { try instance ( ) first and then instance ( ) which was deprecated in _NUM . _NUM . _NUM final Method instanceMethod = tryInstanceMethod ( clazz ) ; if ( IoRegistry . class . isAssignableFrom ( instanceMethod . getReturnType ( ) ) ) builder . addRegistry ( ( IoRegistry ) instanceMethod . invoke ( null ) ) ; else throw new Exception ( ) ; } catch ( Exception methodex ) { tried instance ( ) and that failed so try newInstance ( ) no - arg constructor builder . addRegistry ( ( IoRegistry ) clazz . newInstance ( ) ) ; } } catch ( Exception ex ) { throw new IllegalStateException ( ex ) ; } } ) ; } 
2204	public void startService ( ) { final ActivityManager am = ( ActivityManager ) mContext . getSystemService ( Context . ACTIVITY _ SERVICE ) ; if ( ! am . isUserRunning ( setting . mUserHandle . getIdentifier ( ) ) ) { if ( Log . isLoggable ( TAG , Log . VERBOSE ) ) { Log . v ( TAG , _STR + handler ) ; startMillis = SystemClock . elapsedRealtime ( ) ; } else { startMillis = _NUM ; } Start the service , making sure that this is attributed to the user associated with the setting rather than the system user . mContext . startServiceAsUser ( intent , setting . mUserHandle ) ; } 
2205	public void zoomInBoth ( double x , double y ) { Plot plot = this . chart . getPlot ( ) ; if ( plot = = null ) { return ; } here we tweak the notify flag on the plot so that only one notification happens even though we update multiple axes . . . boolean savedNotify = plot . isNotify ( ) ; plot . setNotify ( false ) ; zoomInDomain ( x , y ) ; zoomInRange ( x , y ) ; plot . setNotify ( savedNotify ) ; } 
2206	static String constructMetadataParamQuery ( List < String > metadataSelectCols ) { String pkColsCsv = getPksCsv ( ) ; String query = QueryUtil . constructSelectStatement ( OUTPUT _ METADATA _ TABLE _ NAME , metadataSelectCols , pkColsCsv , null , true ) ; String inClause = _STR + QueryUtil . constructParameterizedInClause ( _NUM , _NUM ) ; return query + inClause ; } 
2207	public MatrixObject getMatrixObject ( String outputName ) { Data data = getData ( outputName ) ; if ( ! ( data instanceof MatrixObject ) ) { throw new MLContextException ( _STR ) ; } return ( MatrixObject ) data ; } 
2208	protected String createMessageId ( ) { String uuid = null ; if ( exchange ! = null ) { uuid = exchange . getContext ( ) . getUuidGenerator ( ) . generateUuid ( ) ; } fall back to the simple UUID generator if ( uuid = = null ) { uuid = new SimpleUuidGenerator ( ) . generateUuid ( ) ; } return uuid ; } 
2209	public void updateSizes ( StorageVolumeProvider svp , VolumeInfo volume ) { final long sharedDataSize = volume . getPath ( ) . getTotalSpace ( ) ; long totalSize = svp . getPrimaryStorageSize ( ) ; if ( totalSize < = _NUM ) { totalSize = sharedDataSize ; } final long usedBytes = totalSize - volume . getPath ( ) . getFreeSpace ( ) ; updateBytes ( usedBytes , totalSize ) ; } 
2210	public void testStartedServerWithRequestLog ( ) throws Throwable { HttpRequestLogAppender requestLogAppender = new HttpRequestLogAppender ( ) ; requestLogAppender . setName ( _STR ) . removeAppender ( requestLogAppender ) ; } 
2211	public void checkNodeCount ( int numSlaves ) throws Exception { HBaseCluster cluster = getHBaseClusterInterface ( ) ; if ( cluster . getClusterMetrics ( ) . getLiveServerMetrics ( ) . size ( ) < numSlaves ) { throw new Exception ( _STR + numSlaves ) ; } } 
2212	public static void skip ( DataInput in ) throws IOException { int length = in . readUnsignedShort ( ) ; WritableUtils . skipFully ( in , length ) ; } 
2213	public void println ( ) { m _ Owner . append ( m _ LineFeed ) ; } 
2214	public NSObject parse ( ) throws ParseException { index = _NUM ; Skip Unicode byte order mark ( BOM ) if ( data . length > = _NUM & & ( data [ _NUM ] & _NUM xFF ) = = _NUM xEF & & ( data [ _NUM ] & _NUM xFF ) = = _NUM xBB & & ( data [ _NUM ] & _NUM xFF ) = = _NUM xBF ) skip ( _NUM ) ; skipWhitespacesAndComments ( ) ; expect ( DICTIONARY _ BEGIN _ TOKEN , ARRAY _ BEGIN _ TOKEN , COMMENT _ BEGIN _ TOKEN ) ; try { return parseObject ( ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { throw new ParseException ( _STR , index ) ; } } 
2215	public long getMaxSharedMemory ( ) { cudaDeviceProp deviceProp = getGPUProperties ( ) ; return deviceProp . sharedMemPerBlock ; } 
2216	public void testPreWrite ( ) throws IOException { createBasicDirectoryProperty ( ) ; _ property . preWrite ( ) ; shouldn ' t change anything at all verifyProperty ( ) ; verifyChildren ( _NUM ) ; now try adding _NUM property createBasicDirectoryProperty ( ) ; _ property . addChild ( new LocalProperty ( _NUM ) ) ; _ property . preWrite ( ) ; update children index _ testblock [ _NUM x _NUM C ] = _NUM ; _ testblock [ _NUM x _NUM D ] = _NUM ; _ testblock [ _NUM x _NUM E ] = _NUM ; _ testblock [ _NUM x _NUM F ] = _NUM ; verifyProperty ( ) ; verifyChildren ( _NUM ) ; now try adding _NUM properties createBasicDirectoryProperty ( ) ; _ property . addChild ( new LocalProperty ( _NUM ) ) ; _ property . addChild ( new LocalProperty ( _NUM ) ) ; _ property . preWrite ( ) ; update children index _ testblock [ _NUM x _NUM C ] = _NUM ; _ testblock [ _NUM x _NUM D ] = _NUM ; _ testblock [ _NUM x _NUM E ] = _NUM ; _ testblock [ _NUM x _NUM F ] = _NUM ; verifyProperty ( ) ; verifyChildren ( _NUM ) ; beat on the children allocation code for ( int count = _NUM ; count < _NUM _NUM _NUM ; count + + ) { createBasicDirectoryProperty ( ) ; for ( int j = _NUM ; j < ( count + _NUM ) ; j + + ) { _ property . addChild ( new LocalProperty ( j ) ) ; } _ property . preWrite ( ) ; verifyChildren ( count ) ; } } 
2217	public int getNettyServerExecutionConcurrency ( ) { if ( getNettyServerUseExecutionHandler ( ) ) { return getNettyServerExecutionThreads ( ) ; } else { return getNettyServerThreads ( ) ; } } 
2218	public boolean isHeaderViewOrFooterView ( int position ) { return isHeaderView ( position ) | | isFooterView ( position ) ; } 
2219	public static boolean isCreditCard ( String stPassed ) { if ( isEmpty ( stPassed ) ) return defaultEmptyOK ; String st = stripCharsInBag ( stPassed , creditCardDelimiters ) ; if ( ! isInteger ( st ) ) return false ; encoding only works on cars with less the _NUM _NUM digits if ( st . length ( ) > _NUM _NUM ) return false ; return sumIsMod _NUM _NUM ( getLuhnSum ( st ) ) ; } 
2220	public float [ ] generateTransformedValuesLine ( List < ? extends Entry > entries , float phaseX , float phaseY , int from , int to ) { final int count = ( int ) Math . ceil ( ( to - from ) * phaseX ) * _NUM ; float [ ] valuePoints = new float [ count ] ; for ( int j = _NUM ; j < count ; j + = _NUM ) { Entry e = entries . get ( j / _NUM + from ) ; if ( e ! = null ) { valuePoints [ j ] = e . getXIndex ( ) ; valuePoints [ j + _NUM ] = e . getVal ( ) * phaseY ; } } pointValuesToPixel ( valuePoints ) ; return valuePoints ; } 
2221	private void animatePropertyBy ( int constantName , float byValue ) { float fromValue = getValue ( constantName ) ; animatePropertyBy ( constantName , fromValue , byValue ) ; } 
2222	public static void debug ( final Logger logger , final String pattern , final Object argument ) { if ( logger . isDebugEnabled ( ) ) { forcedLog ( logger , Level . DEBUG , format ( pattern , argument ) ) ; } } 
2223	protected PackingPlan doScalingTest ( TopologyAPI . Topology testTopology , Map < String , Integer > componentChanges , ByteAmount boltRam , int testBoltParallelism , ByteAmount spoutRam , int testSpoutParallelism , int numContainersBeforeRepack , int totalInstancesExpected ) { PackingPlan packingPlan = pack ( testTopology ) ; Assert . assertEquals ( numContainersBeforeRepack , packingPlan . getContainers ( ) . size ( ) ) ; Assert . assertEquals ( totalInstancesExpected , ( int ) packingPlan . getInstanceCount ( ) ) ; AssertPacking . assertContainers ( packingPlan . getContainers ( ) , BOLT _ NAME , SPOUT _ NAME , boltRam , spoutRam , null ) ; AssertPacking . assertNumInstances ( packingPlan . getContainers ( ) , BOLT _ NAME , testBoltParallelism ) ; AssertPacking . assertNumInstances ( packingPlan . getContainers ( ) , SPOUT _ NAME , testSpoutParallelism ) ; PackingPlan newPackingPlan = repack ( testTopology , packingPlan , componentChanges ) ; AssertPacking . assertContainerRam ( newPackingPlan . getContainers ( ) , packingPlan . getMaxContainerResources ( ) . getRam ( ) ) ; return newPackingPlan ; } 
2224	public void captureChildView ( View childView , int activePointerId ) { if ( childView . getParent ( ) ! = mParentView ) { throw new IllegalArgumentException ( _STR ) ; } mCapturedView = childView ; mActivePointerId = activePointerId ; mCallback . onViewCaptured ( childView , activePointerId ) ; setDragState ( STATE _ DRAGGING ) ; } 
2225	public void stop ( ) { mRetryCounter = _NUM ; mHandlerAdapter . removeCallbacks ( mRunnable ) ; } 
2226	public static void assertAllResultsEqual ( Collection < ? > objects ) throws AssertionError { if ( objects . size ( ) = = _NUM | | objects . size ( ) = = _NUM ) return ; Object [ ] resultsArray = objects . toArray ( ) ; for ( int i = _NUM ; i < resultsArray . length ; i + + ) { Object currElement = resultsArray [ i ] ; Object lastElement = resultsArray [ i - _NUM ] ; if ( ( currElement = = null & & currElement ! = lastElement ) | | ( currElement ! = null & & ! currElement . equals ( lastElement ) ) ) { throw new AssertionError ( _STR + Arrays . toString ( resultsArray ) ) ; } } } 
2227	public String mapURI ( String filenameOrURI ) { if ( fmMapper = = null ) return filenameOrURI ; String uri = fmMapper . altMapping ( filenameOrURI , null ) ; if ( uri = = null ) { if ( FileManager . logAllLookups & & log . isDebugEnabled ( ) ) log . debug ( _STR + uri ) ; } return uri ; } 
2228	private synchronized void sortTemplates ( ) { Get the maximum length of a template ID . maxTemplateIDLength = _NUM ; the remaining list . for ( Iterator < CodeTemplate > i = templates . iterator ( ) ; i . hasNext ( ) ; ) { CodeTemplate temp = i . next ( ) ; if ( temp = = null | | temp . getID ( ) = = null ) { i . remove ( ) ; } else { maxTemplateIDLength = Math . max ( maxTemplateIDLength , temp . getID ( ) . length ( ) ) ; } } Collections . sort ( templates ) ; } 
2229	private void extractWeightedSpanTerms ( Map < String , WeightedSpanTerm > terms , SpanQuery spanQuery ) throws IOException { Set < String > fieldNames ; if ( fieldName = = null ) { fieldNames = new HashSet < String > ( ) ; collectSpanQueryFields ( spanQuery , fieldNames ) ; } else { fieldNames = new HashSet < String > ( _NUM ) ; fieldNames . add ( fieldName ) ; } To support the use of the default field name if ( defaultField ! = null ) { fieldNames . add ( defaultField ) ; } Map < String , SpanQuery > queries = new HashMap < String , SpanQuery > ( ) ; Set < Term > nonWeightedTerms = new HashSet < Term > ( ) ; final boolean mustRewriteQuery = mustRewriteQuery ( spanQuery ) ; if ( mustRewriteQuery ) { for ( final String field : fieldNames ) { final SpanQuery rewrittenQuery = ( SpanQuery ) spanQuery . rewrite ( getReaderForField ( field ) ) ; queries . put ( field , rewrittenQuery ) ; rewrittenQuery . extractTerms ( nonWeightedTerms ) ; } } else { spanQuery . extractTerms ( nonWeightedTerms ) ; } List < PositionSpan > spanPositions = new ArrayList < PositionSpan > ( ) ; for ( final String field : fieldNames ) { IndexReader reader = getReaderForField ( field ) ; final Spans spans ; if ( mustRewriteQuery ) { spans = queries . get ( field ) . getSpans ( reader ) ; } else { spans = spanQuery . getSpans ( reader ) ; } collect span positions while ( spans . next ( ) ) { spanPositions . add ( new PositionSpan ( spans . start ( ) , spans . end ( ) - _NUM ) ) ; } } if ( spanPositions . size ( ) = = _NUM ) { no spans found return ; } for ( final Term queryTerm : nonWeightedTerms ) { if ( fieldNameComparator ( queryTerm . field ( ) ) ) { WeightedSpanTerm weightedSpanTerm = terms . get ( queryTerm . text ( ) ) ; if ( weightedSpanTerm = = null ) { weightedSpanTerm = new WeightedSpanTerm ( spanQuery . getBoost ( ) , queryTerm . text ( ) ) ; weightedSpanTerm . addPositionSpans ( spanPositions ) ; weightedSpanTerm . positionSensitive = true ; terms . put ( queryTerm . text ( ) , weightedSpanTerm ) ; } else { if ( spanPositions . size ( ) > _NUM ) { weightedSpanTerm . addPositionSpans ( spanPositions ) ; } } } } } 
2230	private void mmChainRelinkHops ( Hop h , int i , int j , ArrayList < Hop > mmChain , ArrayList < Hop > mmOperators , int opIndex , int [ ] [ ] split , int level ) { single matrix - end of recursion if ( i = = j ) { logTraceHop ( h , level ) ; return ; } if ( LOG . isTraceEnabled ( ) ) { String offset = Explain . getIdentation ( level ) ; LOG . trace ( offset + _STR ) ; } } 
2231	public int release ( String path , FuseFileInfo fi ) { LOG . trace ( _STR , path , e ) ; } return _NUM ; } 
2232	public Collection < StageEntity > getStages ( ) { ensureInitialized ( ) ; Collection < StageEntity > stages = new ArrayList < > ( ) ; for ( LogicalRequest logicalRequest : allRequests . values ( ) ) { stages . addAll ( logicalRequest . getStageEntities ( ) ) ; } return stages ; } 
2233	protected Document createIndexDocument ( CmsObject cms , CmsResource res , CmsSearchIndex index , int count , I _ CmsReport report ) throws CmsException { Document result = null ; if ( report ! = null ) { report . print ( org . opencms . report . Messages . get ( ) . container ( org . opencms . report . Messages . RPT _ SUCCESSION _ _NUM , String . valueOf ( count ) ) , I _ CmsReport . FORMAT _ NOTE ) ; report . print ( Messages . get ( ) . container ( Messages . RPT _ SEARCH _ INDEXING _ FILE _ BEGIN _ _NUM ) , I _ CmsReport . FORMAT _ NOTE ) ; report . print ( org . opencms . report . Messages . get ( ) . container ( org . opencms . report . Messages . RPT _ ARGUMENT _ _NUM , report . removeSiteRoot ( res . getRootPath ( ) ) ) ) ; report . print ( org . opencms . report . Messages . get ( ) . container ( org . opencms . report . Messages . RPT _ DOTS _ _NUM ) , I _ CmsReport . FORMAT _ DEFAULT ) ; } check if this resource should be excluded from the index , if so skip it boolean excludeFromIndex = index . excludeFromIndex ( cms , res ) ; if ( ! excludeFromIndex ) { resource is to be included in the index I _ CmsDocumentFactory documentFactory = index . getDocumentFactory ( res ) ; if ( documentFactory ! = null ) { some resources e . g . JSP do not have a default document factory if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( Messages . get ( ) . getBundle ( ) . key ( Messages . LOG _ INDEXING _ WITH _ FACTORY _ _NUM , res . getRootPath ( ) , documentFactory . getName ( ) ) ) ; } create the document result = documentFactory . createDocument ( cms , res , index ) ; } } if ( result = = null ) { this resource is not contained in the given search index or locale did not match if ( report ! = null ) { report . println ( org . opencms . report . Messages . get ( ) . container ( org . opencms . report . Messages . RPT _ SKIPPED _ _NUM ) , I _ CmsReport . FORMAT _ NOTE ) ; } if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( Messages . get ( ) . getBundle ( ) . key ( Messages . LOG _ SKIPPED _ _NUM , res . getRootPath ( ) ) ) ; } } else { index document was successfully created if ( ( m _ report ! = null ) ) { m _ report . println ( org . opencms . report . Messages . get ( ) . container ( org . opencms . report . Messages . RPT _ OK _ _NUM ) , I _ CmsReport . FORMAT _ OK ) ; } } return result ; } 
2234	Map < ServerName , List < String > > getDeployedHRIs ( final Admin admin ) throws IOException { ClusterMetrics status = admin . getClusterMetrics ( EnumSet . of ( Option . LIVE _ SERVERS ) ) ; Collection < ServerName > regionServers = status . getLiveServerMetrics ( ) . keySet ( ) ; Map < ServerName , List < String > > mm = new HashMap < > ( ) ; for ( ServerName hsi : regionServers ) { AdminProtos . AdminService . BlockingInterface server = connection . getAdmin ( hsi ) ; list all online regions from this region server List < RegionInfo > regions = ProtobufUtil . getOnlineRegions ( server ) ; List < String > regionNames = new ArrayList < > ( regions . size ( ) ) ; for ( RegionInfo hri : regions ) { regionNames . add ( hri . getRegionNameAsString ( ) ) ; } mm . put ( hsi , regionNames ) ; } return mm ; } 
2235	private void updateRecordingTime ( ) { if ( ! isRecording & & ! onPause ) { mRecordingTimeView . setText ( _STR ) ; mRecorded = _NUM ; return ; } if ( onPause ) { mRecorded = timeStringToMillisecond ( mRecordingTimeView . getText ( ) . toString ( ) ) ; blinkPause ( ) ; return ; } long now = SystemClock . uptimeMillis ( ) ; long delta = now - mRecordingStartTime + mRecorded ; Starting a minute before reaching the max duration limit , we ' ll countdown the remaining time instead . boolean countdownRemainingTime = ( mMaxVideoDurationInMs ! = _NUM & & delta > = mMaxVideoDurationInMs - _NUM _NUM _NUM _NUM _NUM ) ; long deltaAdjusted = ( long ) ( delta * captureRate / _NUM _NUM ) ; * captureRate / _NUM _NUM needed for time lapse if ( countdownRemainingTime ) { deltaAdjusted = Math . max ( _NUM , mMaxVideoDurationInMs - deltaAdjusted ) + _NUM _NUM _NUM ; } String text ; long targetNextUpdateDelay ; text = millisecondToTimeString ( deltaAdjusted , false ) ; targetNextUpdateDelay = _NUM _NUM _NUM ; mRecordingTimeView . setText ( text ) ; if ( mRecordingTimeCountsDown ! = countdownRemainingTime ) { Avoid setting the color on every update , do it only when it needs changing . mRecordingTimeCountsDown = countdownRemainingTime ; int color = ApplicationScreen . getAppResources ( ) . getColor ( R . color . recording _ time _ remaining _ text ) ; mRecordingTimeView . setTextColor ( color ) ; } long actualNextUpdateDelay = targetNextUpdateDelay - ( delta % targetNextUpdateDelay ) ; new CountDownTimer ( actualNextUpdateDelay , actualNextUpdateDelay ) { public void onTick ( long millisUntilFinished ) { } public void onFinish ( ) { updateRecordingTime ( ) ; } } . start ( ) ; show recording shutter if ( showRecording ) { stopVideoButton . setImageDrawable ( ApplicationScreen . getAppResources ( ) . getDrawable ( R . drawable . plugin _ capture _ video _ stop _ square ) ) ; showRecording = false ; } else { stopVideoButton . setImageDrawable ( ApplicationScreen . getAppResources ( ) . getDrawable ( R . drawable . plugin _ capture _ video _ stop _ square _ red ) ) ; showRecording = true ; } } 
2236	public static StringBuilder appendKeyValue ( final StringBuilder sb , final String key , final Object value , final String separator , final String keyValueSeparator ) { if ( sb . length ( ) > _NUM ) { sb . append ( keyValueSeparator ) ; } return sb . append ( key ) . append ( separator ) . append ( value ) ; } 
2237	public void setStringValue ( CmsObject cms , String value ) { Element content = m _ element . element ( CmsXmlPage . NODE _ CONTENT ) ; Element links = m _ element . element ( CmsXmlPage . NODE _ LINKS ) ; CmsLinkProcessor linkProcessor = null ; String encoding = m _ document . getEncoding ( ) ; linkProcessor = m _ document . getLinkProcessor ( cms , new CmsLinkTable ( ) ) ; String finalValue = value ; if ( finalValue ! = null ) { nested CDATA tags are not allowed , so replace CDATA tags with their contents special case for embedded Javascript finalValue = finalValue . replaceAll ( _STR ) ; } if ( encoding ! = null ) { ensure all chars in the given content are valid chars for the selected charset finalValue = CmsEncoder . adjustHtmlEncoding ( finalValue , encoding ) ; } remove unnecessary tags if required String contentConversion = m _ document . getConversion ( ) ; if ( CmsHtmlConverter . isConversionEnabled ( contentConversion ) ) { CmsHtmlConverter converter = new CmsHtmlConverter ( encoding , contentConversion ) ; finalValue = converter . convertToStringSilent ( finalValue ) ; } if ( linkProcessor ! = null ) { try { replace links in HTML by macros and fill link table finalValue = linkProcessor . replaceLinks ( finalValue ) ; } catch ( Exception exc ) { throw new CmsRuntimeException ( Messages . get ( ) . container ( Messages . ERR _ HTML _ DATA _ PROCESSING _ _NUM ) , exc ) ; } } content . clearContent ( ) ; links . clearContent ( ) ; if ( CmsStringUtil . isNotEmptyOrWhitespaceOnly ( finalValue ) ) { content . addCDATA ( finalValue ) ; if ( linkProcessor ! = null ) { may be null in case of default value generation ( i . e . setStringValue ( String ) was called ) CmsLinkTable linkTable = linkProcessor . getLinkTable ( ) ; for ( Iterator < CmsLink > i = linkTable . iterator ( ) ; i . hasNext ( ) ; ) { CmsLink link = i . next ( ) ; CmsLinkUpdateUtil . updateXmlForHtmlValue ( link , link . getName ( ) , links . addElement ( CmsXmlPage . NODE _ LINK ) ) ; } } } ensure the String value is re - calculated next time m _ stringValue = null ; } 
2238	public String buttonHtml ( CmsWorkplace wp ) { if ( ! m _ handler . isVisible ( wp ) ) { return _STR ; return A _ CmsHtmlIconButton . defaultButtonHtml ( CmsHtmlIconButtonStyleEnum . BIG _ ICON _ TEXT , getId ( ) , m _ handler . getShortName ( ) , m _ handler . isEnabled ( wp ) ? m _ handler . getHelpText ( ) : m _ handler . getDisabledHelpText ( ) , m _ handler . isEnabled ( wp ) , m _ handler . getIconPath ( ) , m _ handler . getConfirmationMessage ( ) , onClic ) ; } 
2239	public void viewClicked ( View view ) { final boolean focusChanged = mServedView ! = mNextServedView ; checkFocus ( ) ; synchronized ( mH ) { if ( ( mServedView ! = view & & ( mServedView = = null | | ! mServedView . checkInputConnectionProxy ( view ) ) ) | | mCurrentTextBoxAttribute = = null | | mCurMethod = = null ) { return ; } try { if ( DEBUG ) Log . v ( TAG , _STR + mCurId , e ) ; } } } 
2240	public void run ( ) throws IOException , InterruptedException { if ( ! this . workUnits . hasNext ( ) ) { log . warn ( _STR ) ) ; } 
2241	protected boolean detectTierSmartphones ( ) { if ( detectSmartphone ( ) & & ( ! detectTierIphone ( ) ) ) { return true ; } return false ; } 
2242	public String getHtmlForDbSelection ( ) { StringBuffer buf = new StringBuffer ( _NUM _NUM _NUM _NUM ) ; buf . append ( _STR ) ; return buf . toString ( ) ; } 
2243	public < T _NUM , T _NUM > Transformer < R , Tuple _NUM < T _NUM , T _NUM > > getAs ( Class < T _NUM > cls _NUM , Class < T _NUM > cls _NUM ) { return get ( Tuples . tuple ( cls _NUM , cls _NUM ) ) ; } 
2244	public void clients _NUM _NUM runs _NUM _NUM ( ) throws Exception { run ( _NUM _NUM , _NUM _NUM ) ; } 
2245	public boolean getMethodBooleanParameter ( String method , String key , boolean defaultValue ) { return getMethodParameter ( method , key , defaultValue ) ; } 
2246	public Object remove ( String key ) { entries = null ; Object value = get ( key ) ; context . removeAttribute ( key ) ; return value ; } 
2247	public static Triple triple ( PrefixMapping pm , String fact ) { return NodeCreateUtils . createTriple ( pm , fact ) ; } 
2248	private Pair < Gradient , INDArray > getGradientsAndDelta ( INDArray preOut ) { delta calculation ILossFunction lossFunction = layerConf ( ) . getLossFn ( ) ; INDArray delta = lossFunction . computeGradient ( getLabels _NUM d ( ) , preOut , layerConf ( ) . getActivationFn ( ) , maskArray ) ; grab the empty gradient Gradient gradient = new DefaultGradient ( ) ; return new Pair < > ( gradient , delta ) ; } 
2249	public boolean onKeyUp ( int keyCode , @ NonNull KeyEvent event ) { if ( keyCode = = KeyEvent . KEYCODE _ BACK & & event . isTracking ( ) & & ! event . isCanceled ( ) ) { onBackPressed ( ) ; return true ; } return false ; } 
2250	protected void decryptBlock ( byte [ ] input , int inOff , byte [ ] output , int outOff ) { X _NUM = wKey [ _NUM _NUM _NUM ] ^ Pack . littleEndianToInt ( input , inOff ) ; X _NUM = wKey [ _NUM _NUM _NUM ] ^ Pack . littleEndianToInt ( input , inOff + _NUM ) ; X _NUM = wKey [ _NUM _NUM _NUM ] ^ Pack . littleEndianToInt ( input , inOff + _NUM ) ; X _NUM = wKey [ _NUM _NUM _NUM ] ^ Pack . littleEndianToInt ( input , inOff + _NUM _NUM ) ; ib _NUM ( X _NUM , X _NUM , X _NUM , X _NUM ) ; X _NUM ^ = wKey [ _NUM _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM _NUM ] ; inverseLT ( ) ; ib _NUM ( X _NUM , X _NUM , X _NUM , X _NUM ) ; X _NUM ^ = wKey [ _NUM _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM _NUM ] ; inverseLT ( ) ; ib _NUM ( X _NUM , X _NUM , X _NUM , X _NUM ) ; X _NUM ^ = wKey [ _NUM _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM _NUM ] ; inverseLT ( ) ; ib _NUM ( X _NUM , X _NUM , X _NUM , X _NUM ) ; X _NUM ^ = wKey [ _NUM _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM _NUM ] ; inverseLT ( ) ; ib _NUM ( X _NUM , X _NUM , X _NUM , X _NUM ) ; X _NUM ^ = wKey [ _NUM _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM _NUM ] ; inverseLT ( ) ; ib _NUM ( X _NUM , X _NUM , X _NUM , X _NUM ) ; X _NUM ^ = wKey [ _NUM _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM _NUM ] ; inverseLT ( ) ; ib _NUM ( X _NUM , X _NUM , X _NUM , X _NUM ) ; X _NUM ^ = wKey [ _NUM _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM _NUM ] ; inverseLT ( ) ; ib _NUM ( X _NUM , X _NUM , X _NUM , X _NUM ) ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; inverseLT ( ) ; ib _NUM ( X _NUM , X _NUM , X _NUM , X _NUM ) ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; inverseLT ( ) ; ib _NUM ( X _NUM , X _NUM , X _NUM , X _NUM ) ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; inverseLT ( ) ; ib _NUM ( X _NUM , X _NUM , X _NUM , X _NUM ) ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; inverseLT ( ) ; ib _NUM ( X _NUM , X _NUM , X _NUM , X _NUM ) ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; inverseLT ( ) ; ib _NUM ( X _NUM , X _NUM , X _NUM , X _NUM ) ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; inverseLT ( ) ; ib _NUM ( X _NUM , X _NUM , X _NUM , X _NUM ) ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; inverseLT ( ) ; ib _NUM ( X _NUM , X _NUM , X _NUM , X _NUM ) ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; inverseLT ( ) ; ib _NUM ( X _NUM , X _NUM , X _NUM , X _NUM ) ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; inverseLT ( ) ; ib _NUM ( X _NUM , X _NUM , X _NUM , X _NUM ) ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; inverseLT ( ) ; ib _NUM ( X _NUM , X _NUM , X _NUM , X _NUM ) ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; inverseLT ( ) ; ib _NUM ( X _NUM , X _NUM , X _NUM , X _NUM ) ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; inverseLT ( ) ; ib _NUM ( X _NUM , X _NUM , X _NUM , X _NUM ) ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; inverseLT ( ) ; ib _NUM ( X _NUM , X _NUM , X _NUM , X _NUM ) ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; inverseLT ( ) ; ib _NUM ( X _NUM , X _NUM , X _NUM , X _NUM ) ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; inverseLT ( ) ; ib _NUM ( X _NUM , X _NUM , X _NUM , X _NUM ) ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; inverseLT ( ) ; ib _NUM ( X _NUM , X _NUM , X _NUM , X _NUM ) ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; inverseLT ( ) ; ib _NUM ( X _NUM , X _NUM , X _NUM , X _NUM ) ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; inverseLT ( ) ; ib _NUM ( X _NUM , X _NUM , X _NUM , X _NUM ) ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; inverseLT ( ) ; ib _NUM ( X _NUM , X _NUM , X _NUM , X _NUM ) ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; inverseLT ( ) ; ib _NUM ( X _NUM , X _NUM , X _NUM , X _NUM ) ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; inverseLT ( ) ; ib _NUM ( X _NUM , X _NUM , X _NUM , X _NUM ) ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; inverseLT ( ) ; ib _NUM ( X _NUM , X _NUM , X _NUM , X _NUM ) ; X _NUM ^ = wKey [ _NUM ] ; X _NUM ^ = wKey [ _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; X _NUM ^ = wKey [ _NUM _NUM ] ; inverseLT ( ) ; ib _NUM ( X _NUM , X _NUM , X _NUM , X _NUM ) ; X _NUM ^ = wKey [ _NUM ] ; X _NUM ^ = wKey [ _NUM ] ; X _NUM ^ = wKey [ _NUM ] ; X _NUM ^ = wKey [ _NUM ] ; inverseLT ( ) ; ib _NUM ( X _NUM , X _NUM , X _NUM , X _NUM ) ; Pack . intToLittleEndian ( X _NUM ^ wKey [ _NUM ] , output , outOff ) ; Pack . intToLittleEndian ( X _NUM ^ wKey [ _NUM ] , output , outOff + _NUM ) ; Pack . intToLittleEndian ( X _NUM ^ wKey [ _NUM ] , output , outOff + _NUM ) ; Pack . intToLittleEndian ( X _NUM ^ wKey [ _NUM ] , output , outOff + _NUM _NUM ) ; } 
2251	public ConcurrentTestCommand addExplainCommand ( int threadId , int order , String sql ) { assert sql ! = null ; ConcurrentTestCommand command = new ExplainCommand ( sql ) ; return addCommand ( threadId , order , command ) ; } 
2252	protected int init ( String [ ] args ) throws IOException { no args should print the help message if ( _NUM = = args . length ) { printCredShellUsage ( ) ; ToolRunner . printGenericCommandUsage ( System . err ) ; return _NUM ; } for ( int i = _NUM ; i < args . length ; i + + ) { parse command line if ( args [ i ] . equals ( _STR ) ) { printCredShellUsage ( ) ; return _NUM ; } else { printCredShellUsage ( ) ; ToolRunner . printGenericCommandUsage ( System . err ) ; return _NUM ; } } return _NUM ; } 
2253	public void execute ( Runnable command ) { command . run ( ) ; } 
2254	public void hideMenuButton ( final boolean animate ) { if ( ! isMenuButtonHidden ( ) & & ! mIsMenuButtonAnimationRunning ) { mIsMenuButtonAnimationRunning = true ; if ( isOpened ( ) ) { close ( animate ) ; mUiHandler . postDelayed ( new Runnable ( ) { @ Override public void run ( ) { hideMenuButtonWithImage ( animate ) ; } } , mAnimationDelayPerItem * mButtonsCount ) ; } else { hideMenuButtonWithImage ( animate ) ; } } } 
2255	public Map < FileStatus , Boolean > areWALFilesDeletable ( Iterable < FileStatus > files ) throws IOException { final int BUF _ SIZE = _NUM _NUM _NUM ; Map < FileStatus , Boolean > ret = new HashMap < > ( ) ; try ( Table table = connection . getTable ( tableName ) ) { List < Get > getBuffer = new ArrayList < > ( ) ; List < FileStatus > fileStatuses = new ArrayList < > ( ) ; for ( FileStatus file : files ) { String wal = file . getPath ( ) . toString ( ) ; Get get = createGetForCheckWALFile ( wal ) ; getBuffer . add ( get ) ; fileStatuses . add ( file ) ; if ( getBuffer . size ( ) > = BUF _ SIZE ) { Result [ ] results = table . get ( getBuffer ) ; for ( int i = _NUM ; i < results . length ; i + + ) { ret . put ( fileStatuses . get ( i ) , ! results [ i ] . isEmpty ( ) ) ; } getBuffer . clear ( ) ; fileStatuses . clear ( ) ; } } if ( ! getBuffer . isEmpty ( ) ) { Result [ ] results = table . get ( getBuffer ) ; for ( int i = _NUM ; i < results . length ; i + + ) { ret . put ( fileStatuses . get ( i ) , ! results [ i ] . isEmpty ( ) ) ; } } } return ret ; } 
2256	public void setSelectable ( boolean selectable ) { if ( mSelectable ! = selectable ) { mSelectable = selectable ; notifyChanged ( ) ; } } 
2257	public int enterFrame ( final int size ) { final int e = end , ne = e + size ; ensureCapacity ( ne ) ; final int s = start ; start = e ; end = ne ; return s ; } 
2258	public static Dataset load ( Configuration conf , Path path ) throws IOException { FileSystem fs = path . getFileSystem ( conf ) ; long bytesToRead = fs . getFileStatus ( path ) . getLen ( ) ; byte [ ] buff = new byte [ Long . valueOf ( bytesToRead ) . intValue ( ) ] ; FSDataInputStream input = fs . open ( path ) ; try { input . readFully ( buff ) ; } finally { Closeables . close ( input , true ) ; } String json = new String ( buff , Charset . defaultCharset ( ) ) ; return fromJSON ( json ) ; } 
2259	public Builder clearError ( ) { if ( errorBuilder _ = = null ) { error _ = org . apache . drill . exec . proto . UserBitShared . DrillPBError . getDefaultInstance ( ) ; onChanged ( ) ; } else { errorBuilder _ . clear ( ) ; } bitField _NUM _ = ( bitField _NUM _ & ~ _NUM x _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM ) ; return this ; } 
2260	protected COSDictionary parseCOSDictionary ( ) throws IOException { readExpectedChar ( ' < ' ) ; readExpectedChar ( ' < ' ) ; skipSpaces ( ) ; COSDictionary obj = new COSDictionary ( ) ; boolean done = false ; while ( ! done ) { skipSpaces ( ) ; char c = ( char ) seqSource . peek ( ) ; if ( c = = ' > ' ) { done = true ; } else if ( c = = ' / ' ) { parseCOSDictionaryNameValuePair ( obj ) ; } else { invalid dictionary , we were expecting a / Name , read until the end or until we can recover LOG . warn ( _STR + seqSource . getPosition ( ) ) ; if ( readUntilEndOfCOSDictionary ( ) ) { we couldn ' t recover return obj ; } } } readExpectedChar ( ' > ' ) ; readExpectedChar ( ' > ' ) ; return obj ; } 
2261	static void insertTestData ( Map < String , String > configMap ) throws Exception { WriterContext cntxt = getWriterContext ( configMap ) ; writeRecords ( cntxt ) ; commitRecords ( configMap , cntxt ) ; } 
2262	public int getNumEntries ( ) { return entries . size ( ) ; } 
2263	protected void propertyToAnswer ( JCas jcas , PropertyValue property , int isLast , JCas questionView ) throws Exception { jcas . setDocumentText ( property . getValue ( ) ) ; XXX jcas . setDocumentLanguage ( _STR , ap , property . getValue ( ) , property . getScore ( ) , gloVeScore ) ; addConceptFeatures ( questionView , fv , property . getObject ( ) ) ; matchCluesInName ( questionView , property . getProperty ( ) , fv ) ; addTypeLAT ( jcas , fv , property . getProperty ( ) ) ; AnswerInfo ai = new AnswerInfo ( jcas ) ; ai . setFeatures ( fv . toFSArray ( jcas ) ) ; ai . setIsLast ( _NUM ) ; ai . setAnswerID ( AnswerIDGenerator . getInstance ( ) . generateID ( ) ) ; ai . setSnippetIDs ( new IntegerArray ( jcas , _NUM ) ) ; ai . setSnippetIDs ( _NUM , ap . getSnippetID ( ) ) ; if ( property . getValRes ( ) ! = null ) { AnswerResource ar = new AnswerResource ( jcas ) ; ar . setIri ( property . getValRes ( ) ) ; ar . addToIndexes ( ) ; ArrayList < AnswerResource > ars = new ArrayList < > ( ) ; ars . add ( ar ) ; ai . setResources ( FSCollectionFactory . createFSArray ( jcas , ars ) ) ; } ai . addToIndexes ( ) ; createPropertyLabels ( questionView , property , jcas ) ; } 
2264	public void testLocalIndexScanAfterRegionsMerge ( ) throws Exception { String schemaName = generateUniqueName ( ) ; String tableName = schemaName + _STR ) ) ; } } finally { conn _NUM . close ( ) ; } } 
2265	public void fragmentComplete ( ) { if ( totalFragments . get ( ) = = completedFragments . incrementAndGet ( ) ) { nodeComplete ( ) ; } } 
2266	public void setVisible ( boolean flag ) { if ( flag ! = this . visible ) { this . visible = flag ; fireChangeEvent ( ) ; } } 
2267	private int doWork ( String [ ] args ) { if ( args . length > = _NUM ) { CommandHandler handler = Command . getHandler ( args [ _NUM ] ) ; if ( handler ! = null ) { return handler . doWork ( this , Arrays . copyOfRange ( args , _NUM , args . length ) ) ; } } printUsage ( ) ; return - _NUM ; } 
2268	public void reportErrorOnFile ( File f ) { We use getAbsolutePath here instead of getCanonicalPath since we know that there is some IO problem on that drive . getCanonicalPath may need to call stat ( ) or readlink ( ) and it ' s likely those calls would fail due to the same underlying IO problem . String absPath = f . getAbsolutePath ( ) ; for ( StorageDirectory sd : storageDirs ) { String dirPath = sd . getRoot ( ) . getAbsolutePath ( ) ; if ( ! dirPath . endsWith ( File . separator ) ) { dirPath + = File . separator ; } if ( absPath . startsWith ( dirPath ) ) { reportErrorsOnDirectory ( sd ) ; return ; } } } 
2269	public String getName ( ) { return type . toString ( ) ; } 
2270	public static void pollEndpoint ( Endpoint endpoint , Processor processor , long timeout ) throws Exception { PollingConsumer consumer = endpoint . createPollingConsumer ( ) ; try { ServiceHelper . startService ( consumer ) ; while ( true ) { Exchange exchange = consumer . receive ( timeout ) ; if ( exchange = = null ) { break ; } else { processor . process ( exchange ) ; } } } finally { try { ServiceHelper . stopAndShutdownService ( consumer ) ; } catch ( Exception e ) { LOG . warn ( _STR , e ) ; } } } 
2271	public void removeActiveSync ( SyncInfo syncInfo , int userId ) { synchronized ( mAuthorities ) { if ( Log . isLoggable ( TAG , Log . VERBOSE ) ) { Slog . v ( TAG , _STR + syncInfo . authority ) ; } getCurrentSyncs ( userId ) . remove ( syncInfo ) ; } reportActiveChange ( ) ; } 
2272	public void setDestination ( ) { try { checkEnv ( ) ; m _ DataBaseConnection = newDatabaseConnection ( ) ; setUser ( m _ Username ) ; setPassword ( m _ Password ) ; m _ DataBaseConnection . setUsername ( m _ Username ) ; m _ DataBaseConnection . setPassword ( m _ Password ) ; } catch ( Exception ex ) { printException ( ex ) ; } } 
2273	public void assertIsZero ( Description description , BigDecimal actual ) { comparables . assertEqual ( description , actual , ZERO ) ; } 
2274	public void acceptClusterer ( BatchClustererEvent ce ) { if ( ce . getTestSet ( ) = = null | | ce . getTestOrTrain ( ) = = BatchClustererEvent . TEST | | ce . getTestSet ( ) . isStructureOnly ( ) ) { return ; } Instances trainHeader = new Instances ( ce . getTestSet ( ) . getDataSet ( ) , _NUM ) ; String titleString = ce . getClusterer ( ) . getClass ( ) . getName ( ) ; titleString = titleString . substring ( titleString . lastIndexOf ( ' . ' ) + _NUM , titleString . length ( ) ) ; String prefix = _STR ) ; } else { System . err . println ( message ) ; } return ; } File tempFile = new File ( dirName ) ; fileName = tempFile . getAbsolutePath ( ) + File . separator + fileName ; saveModel ( fileName , trainHeader , ce . getClusterer ( ) ) ; } 
2275	public void setSwipeListener ( SwipeListener listener ) { addSwipeListener ( listener ) ; } 
2276	public DescribeHostsResult withHosts ( Host . . . hosts ) { if ( getHosts ( ) = = null ) setHosts ( new java . util . ArrayList < Host > ( hosts . length ) ) ; for ( Host value : hosts ) { getHosts ( ) . add ( value ) ; } return this ; } 
2277	public void testClobber ( ) throws Exception { Context ctx = new Context ( ) ; default behavior ctx . put ( _STR , Charsets . UTF _ _NUM ) ; eventBeforeIntercept . getHeaders ( ) . put ( Constants . HOST , ORIGINAL _ HOST ) ; Assert . assertEquals ( ORIGINAL _ HOST , eventBeforeIntercept . getHeaders ( ) . get ( Constants . HOST ) ) ; String expectedHost = InetAddress . getLocalHost ( ) . getHostAddress ( ) ; Event eventAfterIntercept = interceptor . intercept ( eventBeforeIntercept ) ; String actualHost = eventAfterIntercept . getHeaders ( ) . get ( Constants . HOST ) ; Assert . assertNotNull ( actualHost ) ; Assert . assertEquals ( expectedHost , actualHost ) ; } 
2278	private static boolean isAssignable ( final Type type , final GenericArrayType toGenericArrayType , final Map < TypeVariable < ? > , Type > typeVarAssigns ) { if ( type = = null ) { return true ; } would have cause the previous to return true if ( toGenericArrayType = = null ) { return false ; } all types are assignable to themselves if ( toGenericArrayType . equals ( type ) ) { return true ; } final Type toComponentType = toGenericArrayType . getGenericComponentType ( ) ; if ( type instanceof Class < ? > ) { final Class < ? > cls = ( Class < ? > ) type ; compare the component types return cls . isArray ( ) & & isAssignable ( cls . getComponentType ( ) , toComponentType , typeVarAssigns ) ; } if ( type instanceof GenericArrayType ) { compare the component types return isAssignable ( ( ( GenericArrayType ) type ) . getGenericComponentType ( ) , toComponentType , typeVarAssigns ) ; } if ( type instanceof WildcardType ) { so long as one of the upper bounds is assignable , it ' s good for ( final Type bound : getImplicitUpperBounds ( ( WildcardType ) type ) ) { if ( isAssignable ( bound , toGenericArrayType ) ) { return true ; } } return false ; } if ( type instanceof TypeVariable < ? > ) { type variables cannot specify arrays as bounds . for ( final Type bound : getImplicitBounds ( ( TypeVariable < ? > ) type ) ) { if ( isAssignable ( bound , toGenericArrayType ) ) { return true ; } } return false ; } if ( type instanceof ParameterizedType ) { Collection [ ] < ? extends String > collection ; return false ; } throw new IllegalStateException ( _STR + type ) ; } 
2279	public Map < JreDeflateParameters , String > getIncompatibleValues ( ) { Map < JreDeflateParameters , String > incompatible = new HashMap < JreDeflateParameters , String > ( ) ; Map < JreDeflateParameters , String > systemValues = getSystemValues ( ) ; for ( Map . Entry < JreDeflateParameters , String > baselineEntry : getBaselineValues ( ) . entrySet ( ) ) { String computedSHA _NUM _NUM _NUM = systemValues . get ( baselineEntry . getKey ( ) ) ; if ( ! computedSHA _NUM _NUM _NUM . equals ( baselineEntry . getValue ( ) ) ) { incompatible . put ( baselineEntry . getKey ( ) , computedSHA _NUM _NUM _NUM ) ; } } return incompatible ; } 
2280	private byte [ ] Block _ Cipher _ df ( byte [ ] inputString , int bitLength ) { int outLen = _ engine . getBlockSize ( ) ; already in bytes int L = inputString . length ; int N = bitLength / _NUM ; _NUM S = L | | N | | inputstring | | _NUM x _NUM _NUM int sLen = _NUM + _NUM + L + _NUM ; int blockLen = ( ( sLen + outLen - _NUM ) / outLen ) * outLen ; byte [ ] S = new byte [ blockLen ] ; copyIntToByteArray ( S , L , _NUM ) ; copyIntToByteArray ( S , N , _NUM ) ; System . arraycopy ( inputString , _NUM , S , _NUM , L ) ; S [ _NUM + L ] = ( byte ) _NUM x _NUM _NUM ; S already padded with zeros byte [ ] temp = new byte [ _ keySizeInBits / _NUM + outLen ] ; byte [ ] bccOut = new byte [ outLen ] ; byte [ ] IV = new byte [ outLen ] ; int i = _NUM ; byte [ ] K = new byte [ _ keySizeInBits / _NUM ] ; System . arraycopy ( K _ BITS , _NUM , K , _NUM , K . length ) ; while ( i * outLen * _NUM < _ keySizeInBits + outLen * _NUM ) { copyIntToByteArray ( IV , i , _NUM ) ; BCC ( bccOut , K , IV , S ) ; int bytesToCopy = ( ( temp . length - i * outLen ) > outLen ) ? outLen : ( temp . length - i * outLen ) ; System . arraycopy ( bccOut , _NUM , temp , i * outLen , bytesToCopy ) ; + + i ; } byte [ ] X = new byte [ outLen ] ; System . arraycopy ( temp , _NUM , K , _NUM , K . length ) ; System . arraycopy ( temp , K . length , X , _NUM , X . length ) ; temp = new byte [ bitLength / _NUM ] ; i = _NUM ; _ engine . init ( true , new KeyParameter ( expandKey ( K ) ) ) ; while ( i * outLen < temp . length ) { _ engine . processBlock ( X , _NUM , X , _NUM ) ; int bytesToCopy = ( ( temp . length - i * outLen ) > outLen ) ? outLen : ( temp . length - i * outLen ) ; System . arraycopy ( X , _NUM , temp , i * outLen , bytesToCopy ) ; i + + ; } return temp ; } 
2281	public void testZeroCopyReadOfCachedData ( ) throws Exception { BlockReaderTestUtil . enableShortCircuitShmTracing ( ) ; BlockReaderTestUtil . enableBlockReaderFactoryTracing ( ) ; BlockReaderTestUtil . enableHdfsCachingTracing ( ) ; final int TEST _ FILE _ LENGTH = BLOCK _ SIZE ; final Path TEST _ PATH = new Path ( _STR ) ; } Assert . assertArrayEquals ( Arrays . copyOfRange ( original , _NUM , BLOCK _ SIZE ) , byteBufferToArray ( result _NUM ) ) ; fsIn _NUM . releaseBuffer ( result _NUM ) ; fsIn _NUM . close ( ) ; check that the replica is anchored final ExtendedBlock firstBlock = DFSTestUtil . getFirstBlock ( fs , TEST _ PATH ) ; final ShortCircuitCache cache = ClientContext . get ( CONTEXT , new DfsClientConf ( conf ) ) . getShortCircuitCache ( ) ; waitForReplicaAnchorStatus ( cache , firstBlock , true , true , _NUM ) ; Uncache the replica fs . removeCacheDirective ( directiveId ) ; waitForReplicaAnchorStatus ( cache , firstBlock , false , true , _NUM ) ; fsIn . releaseBuffer ( result ) ; waitForReplicaAnchorStatus ( cache , firstBlock , false , false , _NUM ) ; DFSTestUtil . verifyExpectedCacheUsage ( _NUM , _NUM , fsd ) ; fsIn . close ( ) ; fs . close ( ) ; cluster . shutdown ( ) ; } 
2282	public static < T , R > void checkDoubleOnSubscribeMaybe ( Function < Maybe < T > , ? extends MaybeSource < R > > transform ) { List < Throwable > errors = trackPluginErrors ( ) ; try { final Boolean [ ] b = { null , null } ; final CountDownLatch cdl = new CountDownLatch ( _NUM ) ; Maybe < T > source = new Maybe < T > ( ) { @ Override protected void subscribeActual ( MaybeObserver < ? super T > observer ) { try { Disposable d _NUM = Disposables . empty ( ) ; observer . onSubscribe ( d _NUM ) ; Disposable d _NUM = Disposables . empty ( ) ; observer . onSubscribe ( d _NUM ) ; b [ _NUM ] = d _NUM . isDisposed ( ) ; b [ _NUM ] = d _NUM . isDisposed ( ) ; } finally { cdl . countDown ( ) ; } } } ; MaybeSource < R > out = transform . apply ( source ) ; out . subscribe ( NoOpConsumer . INSTANCE ) ; try { assertTrue ( _STR ) ; } catch ( Throwable ex ) { throw ExceptionHelper . wrapOrThrow ( ex ) ; } finally { RxJavaPlugins . reset ( ) ; } } 
2283	public static final < T > Tuple _NUM < Stream < T > , Stream < T > > splitBy ( final Stream < T > stream , final Predicate < T > splitter ) { final Tuple _NUM < Stream < T > , Stream < T > > Tuple _NUM = duplicate ( stream ) ; return Tuple . tuple ( limitWhile ( Tuple _NUM . _ _NUM ( ) , splitter ) , skipWhile ( Tuple _NUM . _ _NUM ( ) , splitter ) ) ; } 
2284	protected void startWherePattern ( ) { queryLevel + = _NUM ; if ( queryLevel = = _NUM ) { pushLabelState ( ) ; clearLabelState ( ) ; } } 
2285	public void testWinRowNumber ( ) { CalciteAssert . hr ( ) . query ( _STR ) ; } 
2286	public OptionalLong indexOf ( IntPredicate predicate ) { return boxed ( ) . indexOf ( predicate : : test ) ; } 
2287	public String getToolTipText ( Object value ) { return getText ( value ) ; } 
2288	public void setIgnoredProperties ( String value ) { String [ ] props ; int i ; m _ IgnoredProperties . clear ( ) ; props = value . split ( _STR ) ; for ( i = _NUM ; i < props . length ; i + + ) m _ IgnoredProperties . add ( props [ i ] ) ; } 
2289	public AndroidCheckinResponse checkin ( ) throws Exception { this first checkin is for generating android - id AndroidCheckinResponse checkinResponse = postCheckin ( Utils . generateAndroidCheckinRequest ( ) . toByteArray ( ) ) ; this . setAndroidID ( BigInteger . valueOf ( checkinResponse . getAndroidId ( ) ) . toString ( _NUM _NUM ) ) ; setSecurityToken ( ( BigInteger . valueOf ( checkinResponse . getSecurityToken ( ) ) . toString ( _NUM _NUM ) ) ) ; String c _NUM dmAuth = loginAC _NUM DM ( ) ; AndroidCheckinRequest . Builder checkInbuilder = AndroidCheckinRequest . newBuilder ( Utils . generateAndroidCheckinRequest ( ) ) ; AndroidCheckinRequest build = checkInbuilder . setId ( new BigInteger ( this . getAndroidID ( ) , _NUM _NUM ) . longValue ( ) ) . setSecurityToken ( new BigInteger ( getSecurityToken ( ) , _NUM _NUM ) . longValue ( ) ) . addAccountCookie ( _STR ) . addAccountCookie ( c _NUM dmAuth ) . build ( ) ; this is the second checkin to match credentials with android - id return postCheckin ( build . toByteArray ( ) ) ; } 
2290	public static String getSqlQueryAllInvalidRows ( Connection conn , SourceTargetColumnNames columnNames , long scrutinyTimeMillis ) throws SQLException { String paramQuery = getAllInvalidParamQuery ( conn , columnNames ) ; paramQuery = bindPkCols ( columnNames , scrutinyTimeMillis , paramQuery ) ; return paramQuery ; } 
2291	public void testQueueFullDropData ( ) { int numRecords = MAX _ QUEUE _ SIZE + _NUM ; harness . enqueueRandom ( numRecords ) ; harness . getRunnable ( ) . shutdown ( ) ; for ( int i = _NUM ; i < MAX _ QUEUE _ SIZE ; i + = FLUSH _ SIZE ) { harness . runAndAssert ( i , Math . min ( MAX _ QUEUE _ SIZE - i , FLUSH _ SIZE ) ) ; } Assert . assertTrue ( harness . getRunnable ( ) . isShutdown ( ) ) ; } 
2292	int getNumReportedRegions ( TableName table , QuotaSnapshotStore < TableName > tableStore ) throws IOException { return Iterables . size ( tableStore . filterBySubject ( table ) ) ; } 
2293	public static XmlFloat parse ( java . io . InputStream is ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( XmlFloat ) XmlBeans . getContextTypeLoader ( ) . parse ( is , type , null ) ; } 
2294	public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( _STR ) ; return sb . toString ( ) ; } 
2295	public void setJmsOperations ( JmsOperations jmsOperations ) { getConfiguration ( ) . setJmsOperations ( jmsOperations ) ; } 
2296	public java . lang . StringBuilder append ( char [ ] chars , int offset , int length ) { Arrays . checkOffsetAndCount ( chars . length , offset , length ) ; int newCount = count + length ; if ( newCount > value . length ) { enlargeBuffer ( newCount ) ; } System . arraycopy ( chars , offset , value , count , length ) ; count = newCount ; return this ; } 
2297	public Type id ( String id ) { if ( isOutputSupported ( ) & & getOutputs ( ) . isEmpty ( ) ) { set id on this setId ( id ) ; } else { set it on last output as this is what the user means to do for Block ( s ) with non empty getOutputs ( ) the id probably refers to the last definition in the current Block List < ProcessorDefinition < ? > > outputs = getOutputs ( ) ; if ( ! blocks . isEmpty ( ) ) { if ( blocks . getLast ( ) instanceof ProcessorDefinition ) { ProcessorDefinition < ? > block = ( ProcessorDefinition < ? > ) blocks . getLast ( ) ; if ( ! block . getOutputs ( ) . isEmpty ( ) ) { outputs = block . getOutputs ( ) ; } } } if ( ! getOutputs ( ) . isEmpty ( ) ) { outputs . get ( outputs . size ( ) - _NUM ) . setId ( id ) ; } else { the output could be empty setId ( id ) ; } } return ( Type ) this ; } 
2298	public ApfGenerator addDiv ( int value ) { Instruction instruction = new Instruction ( Opcodes . DIV ) ; instruction . setSignedImm ( value ) ; addInstruction ( instruction ) ; return this ; } 
2299	private void doTestThreading ( final int numFakeEdits , final int bufferSize , final int writerSlowness ) throws Exception { Configuration localConf = new Configuration ( conf ) ; localConf . setInt ( _STR , regions . size ( ) , outputCounts . size ( ) ) ; } 
2300	public void updateBlocks ( int startLine , int endLine , int newLineCount ) { if ( mBlockEndLines = = null ) { createBlocks ( ) ; return ; } int firstBlock = - _NUM ; int lastBlock = - _NUM ; for ( int i = _NUM ; i < mNumberOfBlocks ; i + + ) { if ( mBlockEndLines [ i ] > = startLine ) { firstBlock = i ; break ; } } for ( int i = firstBlock ; i < mNumberOfBlocks ; i + + ) { if ( mBlockEndLines [ i ] > = endLine ) { lastBlock = i ; break ; } } final int lastBlockEndLine = mBlockEndLines [ lastBlock ] ; boolean createBlockBefore = startLine > ( firstBlock = = _NUM ? _NUM : mBlockEndLines [ firstBlock - _NUM ] + _NUM ) ; boolean createBlock = newLineCount > _NUM ; boolean createBlockAfter = endLine < mBlockEndLines [ lastBlock ] ; int numAddedBlocks = _NUM ; if ( createBlockBefore ) numAddedBlocks + + ; if ( createBlock ) numAddedBlocks + + ; if ( createBlockAfter ) numAddedBlocks + + ; final int numRemovedBlocks = lastBlock - firstBlock + _NUM ; final int newNumberOfBlocks = mNumberOfBlocks + numAddedBlocks - numRemovedBlocks ; if ( newNumberOfBlocks = = _NUM ) { Even when text is empty , there is actually one line and hence one block mBlockEndLines [ _NUM ] = _NUM ; mBlockIndices [ _NUM ] = INVALID _ BLOCK _ INDEX ; mNumberOfBlocks = _NUM ; return ; } if ( newNumberOfBlocks > mBlockEndLines . length ) { int [ ] blockEndLines = ArrayUtils . newUnpaddedIntArray ( Math . max ( mBlockEndLines . length * _NUM , newNumberOfBlocks ) ) ; int [ ] blockIndices = new int [ blockEndLines . length ] ; System . arraycopy ( mBlockEndLines , _NUM , blockEndLines , _NUM , firstBlock ) ; System . arraycopy ( mBlockIndices , _NUM , blockIndices , _NUM , firstBlock ) ; System . arraycopy ( mBlockEndLines , lastBlock + _NUM , blockEndLines , firstBlock + numAddedBlocks , mNumberOfBlocks - lastBlock - _NUM ) ; System . arraycopy ( mBlockIndices , lastBlock + _NUM , blockIndices , firstBlock + numAddedBlocks , mNumberOfBlocks - lastBlock - _NUM ) ; mBlockEndLines = blockEndLines ; mBlockIndices = blockIndices ; } else if ( numAddedBlocks + numRemovedBlocks ! = _NUM ) { System . arraycopy ( mBlockEndLines , lastBlock + _NUM , mBlockEndLines , firstBlock + numAddedBlocks , mNumberOfBlocks - lastBlock - _NUM ) ; System . arraycopy ( mBlockIndices , lastBlock + _NUM , mBlockIndices , firstBlock + numAddedBlocks , mNumberOfBlocks - lastBlock - _NUM ) ; } if ( numAddedBlocks + numRemovedBlocks ! = _NUM & & mBlocksAlwaysNeedToBeRedrawn ! = null ) { final ArraySet < Integer > set = new ArraySet < > ( ) ; for ( int i = _NUM ; i < mBlocksAlwaysNeedToBeRedrawn . size ( ) ; i + + ) { Integer block = mBlocksAlwaysNeedToBeRedrawn . valueAt ( i ) ; if ( block > firstBlock ) { block + = numAddedBlocks - numRemovedBlocks ; } set . add ( block ) ; } mBlocksAlwaysNeedToBeRedrawn = set ; } mNumberOfBlocks = newNumberOfBlocks ; int newFirstChangedBlock ; final int deltaLines = newLineCount - ( endLine - startLine + _NUM ) ; if ( deltaLines ! = _NUM ) { Display list whose index is > = mIndexFirstChangedBlock is valid but it needs to update its drawing location . newFirstChangedBlock = firstBlock + numAddedBlocks ; for ( int i = newFirstChangedBlock ; i < mNumberOfBlocks ; i + + ) { mBlockEndLines [ i ] + = deltaLines ; } } else { newFirstChangedBlock = mNumberOfBlocks ; } mIndexFirstChangedBlock = Math . min ( mIndexFirstChangedBlock , newFirstChangedBlock ) ; int blockIndex = firstBlock ; if ( createBlockBefore ) { mBlockEndLines [ blockIndex ] = startLine - _NUM ; updateAlwaysNeedsToBeRedrawn ( blockIndex ) ; mBlockIndices [ blockIndex ] = INVALID _ BLOCK _ INDEX ; blockIndex + + ; } if ( createBlock ) { mBlockEndLines [ blockIndex ] = startLine + newLineCount - _NUM ; updateAlwaysNeedsToBeRedrawn ( blockIndex ) ; mBlockIndices [ blockIndex ] = INVALID _ BLOCK _ INDEX ; blockIndex + + ; } if ( createBlockAfter ) { mBlockEndLines [ blockIndex ] = lastBlockEndLine + deltaLines ; updateAlwaysNeedsToBeRedrawn ( blockIndex ) ; mBlockIndices [ blockIndex ] = INVALID _ BLOCK _ INDEX ; } } 
2301	public static String encodeBytes ( byte [ ] source , int off , int len , int options ) throws java . io . IOException { byte [ ] encoded = encodeBytesToBytes ( source , off , len , options ) ; Return value according to relevant encoding . try { return new String ( encoded , PREFERRED _ ENCODING ) ; } end try catch ( java . io . UnsupportedEncodingException uue ) { return new String ( encoded ) ; } end catch } 
2302	public void showList ( ) { hideProgress ( ) ; mList . setVisibility ( View . VISIBLE ) ; } 
2303	public static byte [ ] ASCIIHexDecode ( byte [ ] in ) { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; boolean first = true ; int n _NUM = _NUM ; for ( int k = _NUM ; k < in . length ; + + k ) { int ch = in [ k ] & _NUM xff ; if ( ch = = ' > ' ) break ; if ( PRTokeniser . isWhitespace ( ch ) ) continue ; int n = PRTokeniser . getHex ( ch ) ; if ( n = = - _NUM ) throw new RuntimeException ( MessageLocalization . getComposedMessage ( _STR ) ) ; if ( first ) n _NUM = n ; else out . write ( ( byte ) ( ( n _NUM < < _NUM ) + n ) ) ; first = ! first ; } if ( ! first ) out . write ( ( byte ) ( n _NUM < < _NUM ) ) ; return out . toByteArray ( ) ; } 
2304	public static void run ( Path input , Path output , boolean runSequential ) throws IOException , InterruptedException , ClassNotFoundException { if ( runSequential ) { postProcessSeq ( input , output ) ; } else { Configuration conf = new Configuration ( ) ; postProcessMR ( conf , input , output ) ; movePartFilesToRespectiveDirectories ( conf , output ) ; } } 
2305	public boolean draw ( Canvas c , Paint p ) { final boolean hasContent ; hasContent = drawSoftware ( c , p ) ; return hasContent ; } 
2306	public Builder loadFromStream ( String resourceName , InputStream is ) throws SettingsException { try { Map < String , String > loadedSettings = YamlSettingsLoader . load ( Streams . copyToString ( new InputStreamReader ( is , _STR , e ) ; } return this ; } 
2307	public void reset ( ) { mDrawMode = DecoEvent . EventType . EVENT _ MOVE ; mVisible = mSeriesItem . getInitialVisibility ( ) ; cancelAnimation ( ) ; mPositionStart = mSeriesItem . getMinValue ( ) ; mPositionEnd = mSeriesItem . getInitialValue ( ) ; mPositionCurrentEnd = mSeriesItem . getInitialValue ( ) ; mPercentComplete = _NUM . _NUM f ; mPaint = new Paint ( ) ; mPaint . setColor ( mSeriesItem . getColor ( ) ) ; mPaint . setStyle ( ( mSeriesItem . getChartStyle ( ) = = SeriesItem . ChartStyle . STYLE _ DONUT ) ? Paint . Style . STROKE : Paint . Style . FILL ) ; mPaint . setStrokeWidth ( mSeriesItem . getLineWidth ( ) ) ; mPaint . setStrokeCap ( mSeriesItem . getRoundCap ( ) ? Paint . Cap . ROUND : Paint . Cap . BUTT ) ; mPaint . setAntiAlias ( true ) ; if ( mSeriesItem . getShadowSize ( ) > _NUM ) { mPaint . setShadowLayer ( mSeriesItem . getShadowSize ( ) , _NUM , _NUM , mSeriesItem . getShadowColor ( ) ) ; } We need to reset the bounds for the case we are drawing a gradient and need to recreate based on the bounds mBounds = null ; for ( SeriesItem . SeriesItemListener seriesItemListener : mSeriesItem . getListeners ( ) ) { seriesItemListener . onSeriesItemAnimationProgress ( mPercentComplete , mPositionCurrentEnd ) ; } } 
2308	public void recycle ( ) { if ( mStrategy = = null ) { clear ( ) ; sPool . release ( this ) ; } } 
2309	public Permutation getPermutation ( ) { Permutation permutation = new Permutation ( projects . size ( ) ) ; if ( projects . size ( ) ! = inputRowType . getFieldList ( ) . size ( ) ) { return null ; } for ( int i = _NUM ; i < projects . size ( ) ; + + i ) { int sourceField = getSourceField ( i ) ; if ( sourceField < _NUM ) { return null ; } permutation . set ( i , sourceField ) ; } return permutation ; } 
2310	public static boolean isJava _NUM _NUM ( ) { return getJavaMajorVersion ( ) = = _NUM ; } 
2311	public int read ( final byte [ ] bts ) throws IOException { try { beforeRead ( bts ! = null ? bts . length : _NUM ) ; final int n = in . read ( bts ) ; afterRead ( n ) ; return n ; } catch ( final IOException e ) { handleIOException ( e ) ; return EOF ; } } 
2312	Pair < List < String > , List < String > > getKeyFields ( String columnFamily , boolean view ) { AbstractTableMetadata table ; if ( view ) { table = getKeyspace ( ) . getMaterializedView ( columnFamily ) ; } else { table = getKeyspace ( ) . getTable ( columnFamily ) ; } List < ColumnMetadata > partitionKey = table . getPartitionKey ( ) ; List < String > pKeyFields = new ArrayList < String > ( ) ; for ( ColumnMetadata column : partitionKey ) { pKeyFields . add ( column . getName ( ) ) ; } List < ColumnMetadata > clusteringKey = table . getClusteringColumns ( ) ; List < String > cKeyFields = new ArrayList < String > ( ) ; for ( ColumnMetadata column : clusteringKey ) { cKeyFields . add ( column . getName ( ) ) ; } return Pair . of ( ( List < String > ) ImmutableList . copyOf ( pKeyFields ) , ( List < String > ) ImmutableList . copyOf ( cKeyFields ) ) ; } 
2313	private int loadChildren ( INodeDirectory parent , DataInput in , Counter counter ) throws IOException { int numChildren = in . readInt ( ) ; for ( int i = _NUM ; i < numChildren ; i + + ) { load single inode INode newNode = loadINodeWithLocalName ( false , in , true , counter ) ; addToParent ( parent , newNode ) ; } return numChildren ; } 
2314	public static byte [ ] serializeDoc ( Node n ) throws IOException { XmlDomWriter xw = new XmlDomWriter ( ) ; ByteArrayOutputStream fout = new ByteArrayOutputStream ( ) ; xw . setOutput ( fout , null ) ; xw . setCanonical ( false ) ; xw . write ( n ) ; fout . close ( ) ; return fout . toByteArray ( ) ; } 
2315	public String getOoxmlName ( ) { if ( this = = SEAL ) return STAR _ _NUM _NUM . getOoxmlName ( ) ; if ( ooxmlId = = - _NUM ) { return ( name ( ) . startsWith ( _STR ) ) ? RECT . getOoxmlName ( ) : null ; } StringBuilder sb = new StringBuilder ( ) ; boolean toLower = true ; for ( char ch : name ( ) . toCharArray ( ) ) { if ( ch = = ' _ ' ) { toLower = false ; continue ; } sb . append ( toLower ? StringUtil . toLowerCase ( ch ) : StringUtil . toUpperCase ( ch ) ) ; toLower = true ; } return sb . toString ( ) ; } 
2316	public void map ( LongWritable key , HarEntry value , OutputCollector < IntWritable , Text > out , Reporter reporter ) throws IOException { Path relPath = new Path ( value . path ) ; int hash = HarFileSystem . getHarHash ( relPath ) ; String towrite = null ; Path srcPath = realPath ( relPath , rootPath ) ; long startPos = partStream . getPos ( ) ; FileSystem srcFs = srcPath . getFileSystem ( conf ) ; FileStatus srcStatus = srcFs . getFileStatus ( srcPath ) ; String propStr = encodeProperties ( srcStatus ) ; if ( value . isDir ( ) ) { towrite = encodeName ( relPath . toString ( ) ) + _STR ; } out . collect ( new IntWritable ( hash ) , new Text ( towrite ) ) ; } 
2317	public void moveBlock ( ) throws Exception { TieredBlockStoreTestUtils . cache ( SESSION _ ID _NUM , BLOCK _ ID _NUM , BLOCK _ SIZE , mTestDir _NUM , mMetaManager , mEvictor ) ; mBlockStore . moveBlock ( SESSION _ ID _NUM , BLOCK _ ID _NUM , mTestDir _NUM . toBlockStoreLocation ( ) ) ; assertFalse ( mTestDir _NUM . hasBlockMeta ( BLOCK _ ID _NUM ) ) ; assertTrue ( mTestDir _NUM . hasBlockMeta ( BLOCK _ ID _NUM ) ) ; assertTrue ( mBlockStore . hasBlockMeta ( BLOCK _ ID _NUM ) ) ; assertFalse ( FileUtils . exists ( BlockMeta . commitPath ( mTestDir _NUM , BLOCK _ ID _NUM ) ) ) ; assertTrue ( FileUtils . exists ( BlockMeta . commitPath ( mTestDir _NUM , BLOCK _ ID _NUM ) ) ) ; Move block from the specific Dir TieredBlockStoreTestUtils . cache ( SESSION _ ID _NUM , BLOCK _ ID _NUM , BLOCK _ SIZE , mTestDir _NUM , mMetaManager , mEvictor ) ; Move block from wrong Dir mThrown . expect ( BlockDoesNotExistException . class ) ; mThrown . expectMessage ( ExceptionMessage . BLOCK _ NOT _ FOUND _ AT _ LOCATION . getMessage ( BLOCK _ ID _NUM , mTestDir _NUM . toBlockStoreLocation ( ) ) ) ; mBlockStore . moveBlock ( SESSION _ ID _NUM , BLOCK _ ID _NUM , mTestDir _NUM . toBlockStoreLocation ( ) , mTestDir _NUM . toBlockStoreLocation ( ) ) ; Move block from right Dir mBlockStore . moveBlock ( SESSION _ ID _NUM , BLOCK _ ID _NUM , mTestDir _NUM . toBlockStoreLocation ( ) , mTestDir _NUM . toBlockStoreLocation ( ) ) ; assertFalse ( mTestDir _NUM . hasBlockMeta ( BLOCK _ ID _NUM ) ) ; assertTrue ( mTestDir _NUM . hasBlockMeta ( BLOCK _ ID _NUM ) ) ; assertTrue ( mBlockStore . hasBlockMeta ( BLOCK _ ID _NUM ) ) ; assertFalse ( FileUtils . exists ( BlockMeta . commitPath ( mTestDir _NUM , BLOCK _ ID _NUM ) ) ) ; assertTrue ( FileUtils . exists ( BlockMeta . commitPath ( mTestDir _NUM , BLOCK _ ID _NUM ) ) ) ; Move block from the specific tier mBlockStore . moveBlock ( SESSION _ ID _NUM , BLOCK _ ID _NUM , BlockStoreLocation . anyDirInTier ( mTestDir _NUM . getParentTier ( ) . getTierAlias ( ) ) , mTestDir _NUM . toBlockStoreLocation ( ) ) ; assertFalse ( mTestDir _NUM . hasBlockMeta ( BLOCK _ ID _NUM ) ) ; assertTrue ( mTestDir _NUM . hasBlockMeta ( BLOCK _ ID _NUM ) ) ; assertTrue ( mBlockStore . hasBlockMeta ( BLOCK _ ID _NUM ) ) ; assertFalse ( FileUtils . exists ( BlockMeta . commitPath ( mTestDir _NUM , BLOCK _ ID _NUM ) ) ) ; assertTrue ( FileUtils . exists ( BlockMeta . commitPath ( mTestDir _NUM , BLOCK _ ID _NUM ) ) ) ; } 
2318	public Builder setEmptyKeyValueColFamily ( org . apache . phoenix . coprocessor . generated . ServerCachingProtos . ImmutableBytesWritable . Builder builderForValue ) { if ( emptyKeyValueColFamilyBuilder _ = = null ) { emptyKeyValueColFamily _ = builderForValue . build ( ) ; onChanged ( ) ; } else { emptyKeyValueColFamilyBuilder _ . setMessage ( builderForValue . build ( ) ) ; } bitField _NUM _ | = _NUM x _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM ; return this ; } 
2319	public void testFindByCluster ( ) { Assert . assertEquals ( _NUM , hostVersionDAO . findByCluster ( _STR ) . size ( ) ) ; } 
2320	public Enumeration listOptions ( ) { Vector < Option > result ; Enumeration en ; result = new Vector < Option > ( ) ; en = super . listOptions ( ) ; while ( en . hasMoreElements ( ) ) result . addElement ( ( Option ) en . nextElement ( ) ) ; result . addElement ( new Option ( _STR ) ) ; return result . elements ( ) ; } 
2321	public static List < EventLog > getTestLevelEventLogsForSuite ( String suiteName ) { List < EventLog > testEventLogs = new ArrayList < > ( ) ; for ( EventLog eventLog : eventLogs ) { if ( isTestLevelEventLog ( eventLog ) & & belongsToSuite ( suiteName , eventLog ) ) { testEventLogs . add ( eventLog ) ; } } return testEventLogs ; } 
2322	public void verifyThatSuitesRunInParallelThreads ( ) { verifyParallelSuitesWithUnequalExecutionTimes ( suiteLevelEventLogs , THREAD _ POOL _ SIZE ) ; } 
2323	public void register ( String noteId , String className , String event , String cmd ) throws InvalidHookException { synchronized ( registry ) { if ( ! HookType . ValidEvents . contains ( event ) ) { throw new InvalidHookException ( _STR ) ; } if ( noteId = = null ) { noteId = GLOBAL _ KEY ; } addRepl ( noteId , className ) ; registry . get ( noteId ) . get ( className ) . put ( event , cmd ) ; } } 
2324	public void load ( CmsObject cms , CmsResource resource , HttpServletRequest req , HttpServletResponse res ) throws IOException , CmsException { if ( m _ enabled ) { if ( canSendLastModifiedHeader ( resource , req , res ) ) { no image processing required at all return ; } get the scale information from the request CmsImageScaler scaler = new CmsImageScaler ( req , m _ maxScaleSize , m _ maxBlurSize ) ; load the file from the cache CmsFile file = getScaledImage ( cms , resource , scaler ) ; now perform standard load operation inherited from dump loader super . load ( cms , file , req , res ) ; } else { scaling is disabled super . load ( cms , resource , req , res ) ; } } 
2325	public byte [ ] toASN _NUM ( ) { try { byte [ ] privKeyBytes = getPrivKeyBytes ( ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( _NUM _NUM _NUM ) ; ASN _NUM _ SEQUENCE ( EC _ PRIVATEKEY ) = { ASN _NUM _ SIMPLE ( EC _ PRIVATEKEY , version , LONG ) , ASN _NUM _ SIMPLE ( EC _ PRIVATEKEY , privateKey , ASN _NUM _ OCTET _ STRING ) , ASN _NUM _ EXP _ OPT ( EC _ PRIVATEKEY , parameters , ECPKPARAMETERS , _NUM ) , ASN _NUM _ EXP _ OPT ( EC _ PRIVATEKEY , publicKey , ASN _NUM _ BIT _ STRING , _NUM ) } ASN _NUM _ SEQUENCE _ END ( EC _ PRIVATEKEY ) DERSequenceGenerator seq = new DERSequenceGenerator ( baos ) ; version seq . addObject ( new ASN _NUM Integer ( _NUM ) ) ; seq . addObject ( new DEROctetString ( privKeyBytes ) ) ; seq . addObject ( new DERTaggedObject ( _NUM , CURVE _ PARAMS . toASN _NUM Primitive ( ) ) ) ; seq . addObject ( new DERTaggedObject ( _NUM , new DERBitString ( getPubKey ( ) ) ) ) ; seq . close ( ) ; return baos . toByteArray ( ) ; } catch ( IOException e ) { Cannot happen , writing to memory stream . throw new RuntimeException ( e ) ; } } 
2326	public void write ( OutputStream stream ) throws IOException { flushSheets ( ) ; Save the template File tmplFile = TempFile . createTempFile ( _STR + tmplFile ) ; } } 
2327	public void missingVolumePreferredVolumeChooser ( ) throws Exception { log . info ( _STR ; thrown . expect ( AccumuloException . class ) ; connector . tableOperations ( ) . create ( tableName ) ; } 
2328	public boolean connect ( BluetoothDevice device ) { if ( DBG ) log ( _STR ) ; return false ; } 
2329	public PDAction getV ( ) { COSDictionary v = ( COSDictionary ) actions . getDictionaryObject ( COSName . V ) ; PDAction retval = null ; if ( v ! = null ) { retval = PDActionFactory . createAction ( v ) ; } return retval ; } 
2330	protected NeighborList findKNearest ( final Instance target , final int k ) throws Exception { Stack < d _ node > cover _ set _ current = new Stack < d _ node > ( ) , cover _ set _ next , zero _ set = new Stack < d _ node > ( ) ; CoverTreeNode parent , child ; d _ node par ; MyHeap upper _ k = new MyHeap ( k ) ; double d = Math . sqrt ( m _ DistanceFunction . distance ( m _ Root . p ( ) , target , Double . POSITIVE _ INFINITY , m _ TreeStats ) ) , upper _ bound ; cover _ set _ current . push ( new d _ node ( d , m _ Root ) ) ; setter ( upper _ k , Double . POSITIVE _ INFINITY , k ) ; this . update ( upper _ k , d ) ; updating stats for the root node if ( m _ TreeStats ! = null ) { if ( m _ Root . num _ children > _NUM ) m _ TreeStats . incrIntNodeCount ( ) ; else m _ TreeStats . incrLeafCount ( ) ; m _ TreeStats . incrPointCount ( ) ; } if root is the only node if ( m _ Root . num _ children = = _NUM ) { NeighborList list = new NeighborList ( k ) ; list . insertSorted ( d , m _ Root . p ( ) ) ; return list ; } else while ( cover _ set _ current . length > _NUM ) { cover _ set _ next = new Stack < d _ node > ( ) ; for ( int i = _NUM ; i < cover _ set _ current . length ; i + + ) { par = cover _ set _ current . element ( i ) ; parent = par . n ; for ( int c = _NUM ; c < parent . num _ children ; c + + ) { child = parent . children . element ( c ) ; upper _ bound = upper _ k . peek ( ) . distance ; if ( c = = _NUM ) d = par . dist ; else { d = upper _ bound + child . max _ dist ; d = Math . sqrt ( m _ DistanceFunction . distance ( child . p ( ) , target , d * d , m _ TreeStats ) ) ; if ( m _ TreeStats ! = null ) m _ TreeStats . incrPointCount ( ) ; } if ( d < = ( upper _ bound + child . max _ dist ) ) { if ( c > _NUM & & d < upper _ bound ) { update ( upper _ k , d ) ; } if ( child . num _ children > _NUM ) { cover _ set _ next . push ( new d _ node ( d , child ) ) ; if ( m _ TreeStats ! = null ) m _ TreeStats . incrIntNodeCount ( ) ; } else if ( d < = upper _ bound ) { zero _ set . push ( new d _ node ( d , child ) ) ; if ( m _ TreeStats ! = null ) m _ TreeStats . incrLeafCount ( ) ; } } } end for current _ set children } end for current _ set elements cover _ set _ current = cover _ set _ next ; } end while ( curret _ set not empty ) NeighborList list = new NeighborList ( k ) ; d _ node tmpnode ; upper _ bound = upper _ k . peek ( ) . distance ; for ( int i = _NUM ; i < zero _ set . length ; i + + ) { tmpnode = zero _ set . element ( i ) ; if ( tmpnode . dist < = upper _ bound ) list . insertSorted ( tmpnode . dist , tmpnode . n . p ( ) ) ; } if ( list . currentLength ( ) < = _NUM ) throw new Exception ( _STR ) ; return list ; } 
2331	protected static String [ ] listToArray ( String value ) { StringTokenizer tok ; Vector < String > list ; list = new Vector < String > ( ) ; tok = new StringTokenizer ( value , _STR ) ; while ( tok . hasMoreTokens ( ) ) list . add ( tok . nextToken ( ) ) ; return ( String [ ] ) list . toArray ( new String [ list . size ( ) ] ) ; } 
2332	public static void main ( String [ ] args ) throws IOException { ExtractTTFFonts extractor = new ExtractTTFFonts ( ) ; extractor . extractFonts ( args ) ; } 
2333	public void testTrackingCompactionRequest ( ) throws Exception { setup a compact / split thread on a mock server HRegionServer mockServer = Mockito . mock ( HRegionServer . class ) ; Mockito . when ( mockServer . getConfiguration ( ) ) . thenReturn ( r . getBaseConf ( ) ) ; CompactSplit thread = new CompactSplit ( mockServer ) ; Mockito . when ( mockServer . getCompactSplitThread ( ) ) . thenReturn ( thread ) ; setup a region / store with some files HStore store = r . getStore ( COLUMN _ FAMILY ) ; createStoreFile ( r ) ; for ( int i = _NUM ; i < MAX _ FILES _ TO _ COMPACT + _NUM ; i + + ) { createStoreFile ( r ) ; } CountDownLatch latch = new CountDownLatch ( _NUM ) ; Tracker tracker = new Tracker ( latch ) ; thread . requestCompaction ( r , store , _STR , PRIORITY _ USER , tracker , null ) ; wait for the latch to complete . latch . await ( ) ; thread . interruptIfNecessary ( ) ; } 
2334	public void testReduceConstantsDup ( ) throws Exception { HepProgram program = new HepProgramBuilder ( ) . addRuleInstance ( ReduceExpressionsRule . PROJECT _ INSTANCE ) . addRuleInstance ( ReduceExpressionsRule . FILTER _ INSTANCE ) . addRuleInstance ( ReduceExpressionsRule . JOIN _ INSTANCE ) . build ( ) ; final String sql = _STR ; checkPlanning ( new HepPlanner ( program ) , sql ) ; } 
2335	protected void createContents ( ) { initShell ( ) ; initMenu ( ) ; initImage ( ) ; initSash ( ) ; } 
2336	public static Integer getIntParameter ( String param , String [ ] args ) { String value = getParameter ( param , args ) ; try { if ( value ! = null ) return Integer . parseInt ( value ) ; } catch ( NumberFormatException ignored ) { in this case return null } return null ; } 
2337	private void setActivityChooserPolicyIfNeeded ( ) { if ( mOnShareTargetSelectedListener = = null ) { return ; } if ( mOnChooseActivityListener = = null ) { mOnChooseActivityListener = new ShareActivityChooserModelPolicy ( ) ; } ActivityChooserModel dataModel = ActivityChooserModel . get ( mContext , mShareHistoryFileName ) ; dataModel . setOnChooseActivityListener ( mOnChooseActivityListener ) ; } 
2338	public final long computeFileSize ( boolean includesLastUcBlock , boolean usePreferredBlockSize _NUM LastUcBlock ) { if ( blocks = = null | | blocks . length = = _NUM ) { return _NUM ; } final int last = blocks . length - _NUM ; check if the last block is BlockInfoUnderConstruction long size = blocks [ last ] . getNumBytes ( ) ; if ( blocks [ last ] instanceof BlockInfoContiguousUnderConstruction ) { if ( ! includesLastUcBlock ) { size = _NUM ; } else if ( usePreferredBlockSize _NUM LastUcBlock ) { size = getPreferredBlockSize ( ) ; } } sum other blocks for ( int i = _NUM ; i < last ; i + + ) { size + = blocks [ i ] . getNumBytes ( ) ; } return size ; } 
2339	public boolean addRule ( Rule r ) { if ( ! super . validRule ( r ) | | ! validRule ( r ) ) { return false ; } rules . add ( r ) ; return true ; } 
2340	 @ POST @ Consumes ( MediaType . APPLICATION _ JSON ) @ Produces ( MediaType . APPLICATION _ JSON ) @ Path ( _STR , requestProcessGroupEntity . getComponent ( ) . getParentGroupId ( ) , groupId ) ) ; } requestProcessGroupEntity . getComponent ( ) . setParentGroupId ( groupId ) ; Step _NUM : Ensure that user has write permissions to the Process Group . If not , then immediately fail . Step _NUM : Retrieve flow from Flow Registry Step _NUM : Resolve Bundle info Step _NUM : Update contents of the ProcessGroupDTO passed in to include the components that need to be added . Step _NUM : If any of the components is a Restricted Component , then we must authorize the user for write access to the RestrictedComponents resource Step _NUM : Replicate the request or call serviceFacade . updateProcessGroup final VersionControlInformationDTO versionControlInfo = requestProcessGroupEntity . getComponent ( ) . getVersionControlInformation ( ) ; if ( versionControlInfo ! = null & & requestProcessGroupEntity . getVersionedFlowSnapshot ( ) = = null ) { Step _NUM : Ensure that user has write permissions to the Process Group . If not , then immediately fail . Step _NUM : Retrieve flow from Flow Registry final VersionedFlowSnapshot flowSnapshot = serviceFacade . getVersionedFlowSnapshot ( versionControlInfo , true ) ; final Bucket bucket = flowSnapshot . getBucket ( ) ; final VersionedFlow flow = flowSnapshot . getFlow ( ) ; versionControlInfo . setBucketName ( bucket . getName ( ) ) ; versionControlInfo . setFlowName ( flow . getName ( ) ) ; versionControlInfo . setFlowDescription ( flow . getDescription ( ) ) ; versionControlInfo . setRegistryName ( serviceFacade . getFlowRegistryName ( versionControlInfo . getRegistryId ( ) ) ) ; final VersionedFlowState flowState = flowSnapshot . isLatest ( ) ? VersionedFlowState . UP _ TO _ DATE : VersionedFlowState . STALE ; versionControlInfo . setState ( flowState . name ( ) ) ; Step _NUM : Resolve Bundle info BundleUtils . discoverCompatibleBundles ( flowSnapshot . getFlowContents ( ) ) ; Step _NUM : Update contents of the ProcessGroupDTO passed in to include the components that need to be added . requestProcessGroupEntity . setVersionedFlowSnapshot ( flowSnapshot ) ; } if ( versionControlInfo ! = null ) { final VersionedFlowSnapshot flowSnapshot = requestProcessGroupEntity . getVersionedFlowSnapshot ( ) ; serviceFacade . verifyImportProcessGroup ( versionControlInfo , flowSnapshot . getFlowContents ( ) , groupId ) ; } Step _NUM : Replicate the request or call serviceFacade . updateProcessGroup if ( isReplicateRequest ( ) ) { return replicate ( HttpMethod . POST , requestProcessGroupEntity ) ; } return withWriteLock ( serviceFacade , requestProcessGroupEntity , lookup - > { final Authorizable processGroup = lookup . getProcessGroup ( groupId ) . getAuthorizable ( ) ; processGroup . authorize ( authorizer , RequestAction . WRITE , NiFiUserUtils . getNiFiUser ( ) ) ; Step _NUM : If any of the components is a Restricted Component , then we must authorize the user for write access to the RestrictedComponents resource final VersionedFlowSnapshot versionedFlowSnapshot = requestProcessGroupEntity . getVersionedFlowSnapshot ( ) ; if ( versionedFlowSnapshot ! = null ) { final Set < ConfigurableComponent > restrictedComponents = FlowRegistryUtils . getRestrictedComponents ( versionedFlowSnapshot . getFlowContents ( ) ) ; restrictedComponents . forEach ( restrictedComponent - > { final ComponentAuthorizable restrictedComponentAuthorizable = lookup . getConfigurableComponent ( restrictedComponent ) ; authorizeRestrictions ( authorizer , restrictedComponentAuthorizable ) ; } ) ; } } , ( ) - > { final VersionedFlowSnapshot versionedFlowSnapshot = requestProcessGroupEntity . getVersionedFlowSnapshot ( ) ; if ( versionedFlowSnapshot ! = null ) { serviceFacade . verifyComponentTypes ( versionedFlowSnapshot . getFlowContents ( ) ) ; } } , processGroupEntity - > { final ProcessGroupDTO processGroup = processGroupEntity . getComponent ( ) ; set the processor id as appropriate processGroup . setId ( generateUuid ( ) ) ; ensure the group name comes from the versioned flow final VersionedFlowSnapshot flowSnapshot = processGroupEntity . getVersionedFlowSnapshot ( ) ; if ( flowSnapshot ! = null & & StringUtils . isNotBlank ( flowSnapshot . getFlowContents ( ) . getName ( ) ) & & StringUtils . isBlank ( processGroup . getName ( ) ) ) { processGroup . setName ( flowSnapshot . getFlowContents ( ) . getName ( ) ) ; } create the process group contents final Revision revision = getRevision ( processGroupEntity , processGroup . getId ( ) ) ; ProcessGroupEntity entity = serviceFacade . createProcessGroup ( revision , groupId , processGroup ) ; if ( flowSnapshot ! = null ) { final RevisionDTO revisionDto = entity . getRevision ( ) ; final String newGroupId = entity . getComponent ( ) . getId ( ) ; final Revision newGroupRevision = new Revision ( revisionDto . getVersion ( ) , revisionDto . getClientId ( ) , newGroupId ) ; We don ' t want the Process Group ' s position to be updated because we want to keep the position where the user placed the Process Group . However , we do want to use the name of the Process Group that is in the Flow Contents . To accomplish this , we call updateProcessGroupContents ( ) passing ' true ' for the updateSettings flag but null out the position . flowSnapshot . getFlowContents ( ) . setPosition ( null ) ; entity = serviceFacade . updateProcessGroupContents ( NiFiUserUtils . getNiFiUser ( ) , newGroupRevision , newGroupId , versionControlInfo , flowSnapshot , getIdGenerationSeed ( ) . orElse ( null ) , false , true , true ) ; } populateRemainingProcessGroupEntityContent ( entity ) ; generate a _NUM _NUM _NUM created response String uri = entity . getUri ( ) ; return generateCreatedResponse ( URI . create ( uri ) , entity ) . build ( ) ; } ) ; } 
2341	public static MatrixObject dataFrameToMatrixObject ( Dataset < Row > dataFrame , MatrixMetadata matrixMetadata ) { matrixMetadata = ( matrixMetadata ! = null ) ? matrixMetadata : new MatrixMetadata ( ) ; JavaPairRDD < MatrixIndexes , MatrixBlock > binaryBlock = dataFrameToMatrixBinaryBlocks ( dataFrame , matrixMetadata ) ; MatrixObject mo = binaryBlocksToMatrixObject ( binaryBlock , matrixMetadata , false ) ; keep lineage of original dataset to allow bypassing binary block conversion if possible mo . getRDDHandle ( ) . addLineageChild ( new DatasetObject ( dataFrame , isDataFrameWithIDColumn ( matrixMetadata ) , isVectorBasedDataFrame ( matrixMetadata ) ) ) ; return mo ; } 
2342	protected void removeClustersCrossingThreshold ( List < Long > clusterListForVmAllocation , ExcludeList avoid , VirtualMachineProfile vmProfile , DeploymentPlan plan ) { Check if cluster threshold for cpu / memory has to be checked or not . By default we always check cluster threshold isn ' t crossed . However , the check may be skipped for starting ( not deploying ) an instance . VirtualMachine vm = vmProfile . getVirtualMachine ( ) ; Map < String , String > details = vmDetailsDao . listDetailsKeyPairs ( vm . getId ( ) ) ; Boolean isThresholdEnabled = ClusterThresholdEnabled . value ( ) ; if ( ! ( isThresholdEnabled | | ( details ! = null & & details . containsKey ( _STR ) ; } } } 
2343	public void setBackgroundTintMode ( @ Nullable PorterDuff . Mode tintMode ) { if ( mBackgroundTintMode ! = tintMode ) { mBackgroundTintMode = tintMode ; getImpl ( ) . setBackgroundTintMode ( tintMode ) ; } } 
2344	public String toString ( ) { String result ; result = super . toString ( ) ; if ( m _ CapabilitiesFilter ! = null ) { initCapabilities ( ) ; if ( m _ Capabilities ! = null ) { if ( m _ Capabilities . supportsMaybe ( m _ CapabilitiesFilter ) & & ! m _ Capabilities . supports ( m _ CapabilitiesFilter ) ) result = _STR ; } } return result ; } 
2345	public Map < String , Properties > getDatabaseProperties ( ) { if ( m _ databaseProperties = = null ) { readDatabaseConfig ( ) ; } return m _ databaseProperties ; } 
2346	public void header ( String version ) { out . print ( _STR ) ; out . flush ( ) ; tagsWritten + + ; } 
2347	public static < T > void checkBadSourceObservable ( Function < Observable < T > , Object > mapper , final boolean error , final T goodValue , final T badValue , final Object . . . expected ) { List < Throwable > errors = trackPluginErrors ( ) ; try { Observable < T > bad = new Observable < T > ( ) { boolean once ; @ Override protected void subscribeActual ( Observer < ? super T > observer ) { observer . onSubscribe ( Disposables . empty ( ) ) ; if ( once ) { return ; } once = true ; if ( goodValue ! = null ) { observer . onNext ( goodValue ) ; } if ( error ) { observer . onError ( new TestException ( _STR ) ; } catch ( AssertionError ex ) { throw ex ; } catch ( Throwable ex ) { throw new RuntimeException ( ex ) ; } finally { RxJavaPlugins . reset ( ) ; } } 
2348	private MonitoredTask getMonitorStatus ( ) { if ( monitorStatus = = null ) { monitorStatus = TaskMonitor . get ( ) . createStatus ( _STR + getTableName ( ) ) ; } return monitorStatus ; } 
2349	public void performBackup ( ParcelFileDescriptor oldState , BackupDataOutput output , ParcelFileDescriptor newState ) { try { JSONObject dataJSON = serializeAccountSyncSettingsToJSON ( ) ; if ( DEBUG ) { Log . d ( TAG , _STR + e ) ; } } 
2350	public static SqlLiteral concatenateLiterals ( List < SqlLiteral > lits ) { if ( lits . size ( ) = = _NUM ) { nothing to do return lits . get ( _NUM ) ; } return ( ( SqlAbstractStringLiteral ) lits . get ( _NUM ) ) . concat _NUM ( lits ) ; } 
2351	private void parseMenu ( XmlPullParser parser , AttributeSet attrs , Menu menu ) throws XmlPullParserException , IOException { MenuState menuState = new MenuState ( menu ) ; int eventType = parser . getEventType ( ) ; String tagName ; boolean lookingForEndOfUnknownTag = false ; String unknownTagName = null ; This loop will skip to the menu start tag do { if ( eventType = = XmlPullParser . START _ TAG ) { tagName = parser . getName ( ) ; if ( tagName . equals ( XML _ MENU ) ) { Go to next tag eventType = parser . next ( ) ; break ; } throw new RuntimeException ( _STR ) ; } eventType = parser . next ( ) ; } } 
2352	private ArrayList < Rect > calculateAllBounds ( Paint paint ) { ArrayList < Rect > list = new ArrayList < Rect > ( ) ; For each views ( If no values then add a fake one ) final int count = mViewPager . getAdapter ( ) . getCount ( ) ; final int width = getWidth ( ) ; final int halfWidth = width / _NUM ; for ( int i = _NUM ; i < count ; i + + ) { Rect bounds = calcBounds ( i , paint ) ; int w = bounds . right - bounds . left ; int h = bounds . bottom - bounds . top ; bounds . left = ( int ) ( halfWidth - ( w / _NUM f ) + ( ( i - mCurrentPage - mPageOffset ) * width ) ) ; bounds . right = bounds . left + w ; bounds . top = _NUM ; bounds . bottom = h ; list . add ( bounds ) ; } return list ; } 
2353	public static Expression skipExpression ( final String expression , final int number ) { return new ExpressionAdapter ( ) { public Object evaluate ( Exchange exchange ) { use simple language Expression exp = exchange . getContext ( ) . resolveLanguage ( _STR ; } } ; } 
2354	 @ OverrideString getExecutionArgument ( int daemonId ) { return getClientName ( daemonId ) ; } 
2355	public void setCindex ( int c ) { m _ cIndex = c ; if ( m _ span ! = null ) { if ( m _ cIndex < m _ plotInstances . numAttributes ( ) & & m _ plotInstances . attribute ( m _ cIndex ) . isNumeric ( ) ) { double min = Double . POSITIVE _ INFINITY ; double max = Double . NEGATIVE _ INFINITY ; double value ; for ( int i = _NUM ; i < m _ plotInstances . numInstances ( ) ; i + + ) { if ( ! m _ plotInstances . instance ( i ) . isMissing ( m _ cIndex ) ) { value = m _ plotInstances . instance ( i ) . value ( m _ cIndex ) ; if ( value < min ) { min = value ; } if ( value > max ) { max = value ; } } } m _ minC = min ; m _ maxC = max ; } else { if ( m _ plotInstances . attribute ( m _ cIndex ) . numValues ( ) > m _ colorList . size ( ) ) { extendColourMap ( ) ; } } this . repaint ( ) ; } } 
2356	public void doFilter ( final ServletRequest request , final ServletResponse response , final FilterChain chain ) throws IOException , ServletException { final HttpServletRequest httpServletRequest = ( HttpServletRequest ) request ; final HttpServletResponse httpServletResponse = ( HttpServletResponse ) response ; final String requestURI = httpServletRequest . getRequestURI ( ) ; LOGGER . log ( Level . DEBUG , _STR + article . optString ( Keys . OBJECT _ ID ) ) ; return ; } catch ( final Exception e ) { httpServletResponse . sendError ( HttpServletResponse . SC _ NOT _ FOUND ) ; return ; } } dispatchToArticleOrPageProcessor ( request , response , article , page ) ; } 
2357	public void before ( ) throws Exception { String alluxioHome = mTestFolder . newFolder ( ) . getAbsolutePath ( ) ; mMetadataManager = TieredBlockStoreTestUtils . defaultMetadataManager ( alluxioHome ) ; Add and commit COMMITTED _ BLOCKS _ NUM temp blocks repeatedly StorageDir dir = mMetadataManager . getTier ( _STR ) . getDir ( _NUM ) ; for ( long blockId = _NUM L ; blockId < COMMITTED _ BLOCKS _ NUM ; blockId + + ) { TieredBlockStoreTestUtils . cache ( TEST _ SESSION _ ID , blockId , TEST _ BLOCK _ SIZE , dir , mMetadataManager , null ) ; } mBlockStoreMeta = BlockStoreMeta . Factory . create ( mMetadataManager ) ; mBlockStoreMetaFull = BlockStoreMeta . Factory . createFull ( mMetadataManager ) ; } 
2358	public String getPictureName ( ) { AbstractEscherOptRecord opt = getEscherOptRecord ( ) ; EscherComplexProperty prop = getEscherProperty ( opt , EscherProperties . BLIP _ _ BLIPFILENAME ) ; if ( prop = = null ) return null ; String name = StringUtil . getFromUnicodeLE ( prop . getComplexData ( ) ) ; return name . trim ( ) ; } 
2359	public void testLeaseExpiration ( ) throws Exception { Configuration conf = new Configuration ( ) ; conf . setInt ( DFS _ NAMENODE _ MAX _ FULL _ BLOCK _ REPORT _ LEASES , _NUM ) ; conf . setLong ( DFS _ NAMENODE _ FULL _ BLOCK _ REPORT _ LEASE _ LENGTH _ MS , _NUM _NUM _NUM L ) ; final Semaphore gotFbrSem = new Semaphore ( _NUM ) ; final AtomicReference < String > failure = new AtomicReference < > ( ) ; final AtomicReference < MiniDFSCluster > cluster = new AtomicReference < > ( ) ; final AtomicReference < String > datanodeToStop = new AtomicReference < > ( ) ; final BlockManagerFaultInjector injector = new BlockManagerFaultInjector ( ) { @ Override public void incomingBlockReportRpc ( DatanodeID nodeID , BlockReportContext context ) throws IOException { if ( context . getLeaseId ( ) = = _NUM ) { setFailure ( failure , _STR + nodeID ) ; } gotFbrSem . release ( ) ; } @ Override public void requestBlockReportLease ( DatanodeDescriptor node , long leaseId ) { if ( leaseId = = _NUM ) { return ; } datanodeToStop . compareAndSet ( null , node . getXferAddr ( ) ) ; } @ Override public void removeBlockReportLease ( DatanodeDescriptor node , long leaseId ) { } } ; try { BlockManagerFaultInjector . instance = injector ; cluster . set ( new MiniDFSCluster . Builder ( conf ) . numDataNodes ( _NUM ) . build ( ) ) ; cluster . get ( ) . waitActive ( ) ; Assert . assertNotNull ( cluster . get ( ) . stopDataNode ( datanodeToStop . get ( ) ) ) ; gotFbrSem . acquire ( ) ; Assert . assertNull ( failure . get ( ) ) ; } finally { if ( cluster . get ( ) ! = null ) { cluster . get ( ) . shutdown ( ) ; } } } 
2360	public float getFloat ( String key , float def ) { Object tmp = mMap . get ( key ) ; return tmp ! = null & & tmp instanceof Number ? ( ( Number ) tmp ) . floatValue ( ) : def ; } 
2361	public void setPageTransformer ( boolean reverseDrawingOrder , PageTransformer transformer ) { final boolean hasTransformer = transformer ! = null ; final boolean needsPopulate = hasTransformer ! = ( mPageTransformer ! = null ) ; mPageTransformer = transformer ; setChildrenDrawingOrderEnabledCompat ( hasTransformer ) ; if ( hasTransformer ) { mDrawingOrder = reverseDrawingOrder ? DRAW _ ORDER _ REVERSE : DRAW _ ORDER _ FORWARD ; } else { mDrawingOrder = DRAW _ ORDER _ DEFAULT ; } if ( needsPopulate ) populate ( ) ; } 
2362	private String convert ( ) throws IOException { Skip over first curly brace as the whole file is in ' { ' and ' } ' int i = r . read ( ) ; if ( i ! = ' { ' ) { throw new IOException ( _STR sb . append ( ' \ \ ' ) ; controlWord . setLength ( _NUM ) ; inControlWord = false ; } else { endControlWord ( ) ; inControlWord = true ; } } else { inControlWord = true ; } } break ; case ' ' : if ( blockCount = = _NUM ) { if ( inControlWord ) { endControlWord ( ) ; } else { sb . append ( ' ' ) ; } } break ; case ' \ r ' : case ' \ n ' : if ( blockCount = = _NUM ) { if ( inControlWord ) { endControlWord ( ) ; } Otherwise , ignore } break ; default : if ( blockCount = = _NUM ) { if ( inControlWord ) { controlWord . append ( ch ) ; } else { sb . append ( ch ) ; } } break ; } } return sb . toString ( ) ; } 
2363	public static org . apache . xmlbeans . xml . stream . XMLInputStream newValidatingXMLInputStream ( org . apache . xmlbeans . xml . stream . XMLInputStream xis , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , org . apache . xmlbeans . xml . stream . XMLStreamException { return XmlBeans . getContextTypeLoader ( ) . newValidatingXMLInputStream ( xis , type , options ) ; } 
2364	public void shrink ( int maximumCapacity ) { if ( maximumCapacity < _NUM ) throw new IllegalArgumentException ( _STR + maximumCapacity ) ; if ( size > maximumCapacity ) maximumCapacity = size ; if ( capacity < = maximumCapacity ) return ; maximumCapacity = FXGLMath . nextPowerOfTwo ( maximumCapacity ) ; resize ( maximumCapacity ) ; } 
2365	public File getFileForKey ( String key ) { return new File ( mRootDirectory , getFilenameForKey ( key ) ) ; } 
2366	public static String [ ] sentDetect ( String text ) { if ( sentenceModel = = null ) return null ; tokenize text ArrayList < String > tokenList = new ArrayList < String > ( ) ; ArrayList < String > whiteList = new ArrayList < String > ( ) ; Tokenizer tokenizer = tokenizerFactory . tokenizer ( text . toCharArray ( ) , _NUM , text . length ( ) ) ; tokenizer . tokenize ( tokenList , whiteList ) ; String [ ] tokens = tokenList . toArray ( new String [ tokenList . size ( ) ] ) ; String [ ] whites = whiteList . toArray ( new String [ whiteList . size ( ) ] ) ; detect sentences int [ ] sentenceBoundaries = sentenceModel . boundaryIndices ( tokens , whites ) ; int sentStartTok = _NUM ; int sentEndTok = _NUM ; String [ ] sentences = new String [ sentenceBoundaries . length ] ; for ( int i = _NUM ; i < sentenceBoundaries . length ; i + + ) { sentEndTok = sentenceBoundaries [ i ] ; StringBuilder sb = new StringBuilder ( ) ; for ( int j = sentStartTok ; j < = sentEndTok ; j + + ) { sb . append ( tokens [ j ] ) ; if ( whites [ j + _NUM ] . length ( ) > _NUM & & j < sentEndTok ) sb . append ( _STR ) ; } sentences [ i ] = sb . toString ( ) ; sentStartTok = sentEndTok + _NUM ; } return sentences ; } 
2367	public Collection < V > values ( ) { if ( valuesCollection = = null ) { valuesCollection = new AbstractCollection < V > ( ) { @ Override public boolean contains ( Object object ) { return containsValue ( object ) ; } @ Override public int size ( ) { return HashMap . this . size ( ) ; } @ Override public void clear ( ) { HashMap . this . clear ( ) ; } @ Override public Iterator < V > iterator ( ) { return new ValueIterator < K , V > ( HashMap . this ) ; } } ; } return valuesCollection ; } 
2368	public static Uri addCall ( CallerInfo ci , Context context , String number , String postDialDigits , String viaNumber , int presentation , int callType , int features , PhoneAccountHandle accountHandle , long start , int duration , Long dataUsage , boolean addForAllUsers , UserHandle userToBeInsertedTo , boolean is _ read ) { if ( VERBOSE _ LOG ) { Log . v ( LOG _ TAG , String . format ( _STR , new String [ ] { String . valueOf ( ci . contactIdOrZero ) } , null ) ; } if ( cursor ! = null ) { try { if ( cursor . getCount ( ) > _NUM & & cursor . moveToFirst ( ) ) { final String dataId = cursor . getString ( _NUM ) ; updateDataUsageStatForData ( resolver , dataId ) ; if ( duration > = MIN _ DURATION _ FOR _ NORMALIZED _ NUMBER _ UPDATE _ MS & & callType = = Calls . OUTGOING _ TYPE & & TextUtils . isEmpty ( ci . normalizedNumber ) ) { updateNormalizedNumber ( context , resolver , dataId , number ) ; } } } finally { cursor . close ( ) ; } } } Uri result = null ; final UserManager userManager = context . getSystemService ( UserManager . class ) ; final int currentUserId = userManager . getUserHandle ( ) ; if ( addForAllUsers ) { First , insert to the system user . final Uri uriForSystem = addEntryAndRemoveExpiredEntries ( context , userManager , UserHandle . SYSTEM , values ) ; if ( uriForSystem = = null | | SHADOW _ AUTHORITY . equals ( uriForSystem . getAuthority ( ) ) ) { Nothing further to do ; just return null . return null ; } if ( UserHandle . USER _ SYSTEM = = currentUserId ) { result = uriForSystem ; } Otherwise , insert to all other users that are running and unlocked . final List < UserInfo > users = userManager . getUsers ( true ) ; final int count = users . size ( ) ; for ( int i = _NUM ; i < count ; i + + ) { final UserInfo userInfo = users . get ( i ) ; final UserHandle userHandle = userInfo . getUserHandle ( ) ; final int userId = userHandle . getIdentifier ( ) ; if ( userHandle . isSystem ( ) ) { Already written . continue ; } if ( ! shouldHaveSharedCallLogEntries ( context , userManager , userId ) ) { Shouldn ' t have calllog entries . continue ; } start . if ( userManager . isUserRunning ( userHandle ) & & userManager . isUserUnlocked ( userHandle ) ) { final Uri uri = addEntryAndRemoveExpiredEntries ( context , userManager , userHandle , values ) ; if ( userId = = currentUserId ) { result = uri ; } } } } else { Single - user entry . Just write to that user , assuming it ' s running . If the user is encrypted , we write to the shadow calllog . final UserHandle targetUserHandle = userToBeInsertedTo ! = null ? userToBeInsertedTo : UserHandle . of ( currentUserId ) ; result = addEntryAndRemoveExpiredEntries ( context , userManager , targetUserHandle , values ) ; } return result ; } 
2369	public void testPreCompactReturningNull ( ) throws IOException { RegionCoprocessorHost rch = getRegionCoprocessorHost ( ) ; rch . preCompact ( null , null , null , null , null , null ) ; } 
2370	private static ConcurrentMap map _NUM ( ) { ConcurrentMap map = map ( ) ; assertTrue ( map . isEmpty ( ) ) ; map . put ( one , _STR ) ; assertFalse ( map . isEmpty ( ) ) ; assertEquals ( _NUM , map . size ( ) ) ; return map ; } 
2371	protected void handleRequest ( final HttpServletRequest request , final HttpServletResponse response , final HttpSession hSession ) throws ServletException , IOException { final PrintWriter out = response . getWriter ( ) ; final User user = ( User ) hSession . getAttribute ( SessionAttribute . USER ) ; if ( null ! = user ) { user . userDidSomething ( ) ; } int serial = - _NUM ; if ( request . getParameter ( AjaxRequest . SERIAL . toString ( ) ) ! = null ) { try { serial = Integer . parseInt ( request . getParameter ( AjaxRequest . SERIAL . toString ( ) ) ) ; } catch ( final NumberFormatException nfe ) { returnError ( user , out , ErrorCode . BAD _ REQUEST , - _NUM ) ; return ; } } final String op = request . getParameter ( AjaxRequest . OP . toString ( ) ) ; if ( op = = null | | op . equals ( _STR + e . toString ( ) ) ; returnError ( user , out , ErrorCode . BAD _ OP , serial ) ; return ; } final Map < ReturnableData , Object > data = handler . handle ( new RequestWrapper ( request ) , hSession ) ; data . put ( AjaxResponse . SERIAL , serial ) ; returnData ( user , out , data ) ; return ; } 
2372	public void recoverIncompleteTriggerInstances ( ) { final Collection < TriggerInstance > unfinishedTriggerInstances = this . flowTriggerInstanceLoader . getIncompleteTriggerInstances ( ) ; for ( final TriggerInstance triggerInstance : unfinishedTriggerInstances ) { if ( triggerInstance . getFlowTrigger ( ) ! = null ) { recover ( triggerInstance ) ; } else { logger . error ( String . format ( _STR , triggerInstance . getId ( ) ) ) ; trigger at all if ( isDoneButFlowNotExecuted ( triggerInstance ) ) { triggerInstance . setFlowExecId ( Constants . FAILED _ EXEC _ ID ) ; this . flowTriggerInstanceLoader . updateAssociatedFlowExecId ( triggerInstance ) ; } else { for ( final DependencyInstance depInst : triggerInstance . getDepInstances ( ) ) { if ( ! Status . isDone ( depInst . getStatus ( ) ) ) { processStatusAndCancelCauseUpdate ( depInst , Status . CANCELLED , CancellationCause . FAILURE ) ; this . triggerProcessor . processTermination ( depInst . getTriggerInstance ( ) ) ; } } } } } } 
2373	public synchronized Node getTemp ( Node instance , Node prop , Node pclass ) { NodePair ip = new NodePair ( instance , prop ) ; Node result = null ; for ( Iterator < Node > i = ipMap . getAll ( ip ) ; i . hasNext ( ) ; ) { Node t = i . next ( ) ; if ( pclass ! = null ) { Object tClass = classMap . get ( t ) ; if ( tClass ! = null & & tClass . equals ( pclass ) ) { result = t ; break ; } } else { result = t ; break ; } } if ( result = = null ) { No value yet , so create one result = NodeFactory . createBlankNode ( ) ; ipMap . put ( ip , result ) ; if ( pclass ! = null ) { classMap . put ( result , pclass ) ; } } return result ; } 
2374	protected List < UTXO > getStoredOutputsFromUTXOProvider ( ) throws UTXOProviderException { UTXOProvider utxoProvider = checkNotNull ( vUTXOProvider , _STR ) ; List < UTXO > candidates = new ArrayList < > ( ) ; List < ECKey > keys = getImportedKeys ( ) ; keys . addAll ( getActiveKeyChain ( ) . getLeafKeys ( ) ) ; candidates . addAll ( utxoProvider . getOpenTransactionOutputs ( keys ) ) ; return candidates ; } 
2375	public void setWindowTitle ( CharSequence title ) { if ( ! mUserTitle ) { setTitleImpl ( title ) ; } } 
2376	ActivityInfo getAndUpdateActivityInfo ( Task . TaskKey taskKey ) { SystemServicesProxy ssp = Recents . getSystemServices ( ) ; ComponentName cn = taskKey . getComponent ( ) ; ActivityInfo activityInfo = mActivityInfoCache . get ( cn ) ; if ( activityInfo = = null ) { activityInfo = ssp . getActivityInfo ( cn , taskKey . userId ) ; if ( cn = = null | | activityInfo = = null ) { Log . e ( TAG , _STR + activityInfo ) ; return null ; } mActivityInfoCache . put ( cn , activityInfo ) ; } return activityInfo ; } 
2377	public Statement rewriteStatement ( String prefix ) { OutputStatement newStatement = new OutputStatement ( null , Expression . DataOp . WRITE , this ) ; rewrite outputStatement variable name ( creates deep copy ) newStatement . _ id = ( DataIdentifier ) this . _ id . rewriteExpression ( prefix ) ; rewrite parameter expressions ( creates deep copy ) DataOp op = _ paramsExpr . getOpCode ( ) ; HashMap < String , Expression > newExprParams = new HashMap < > ( ) ; for ( String key : _ paramsExpr . getVarParams ( ) . keySet ( ) ) { Expression newExpr = _ paramsExpr . getVarParam ( key ) . rewriteExpression ( prefix ) ; newExprParams . put ( key , newExpr ) ; } DataExpression newParamerizedExpr = new DataExpression ( op , newExprParams , this ) ; newStatement . setExprParams ( newParamerizedExpr ) ; return newStatement ; } 
2378	public void testDirectory ( ) throws IOException { fs . mkdirs ( DIR _NUM ) ; test empty directory RemoteIterator < LocatedFileStatus > itor = fs . listFiles ( DIR _NUM , true ) ; assertFalse ( itor . hasNext ( ) ) ; itor = fs . listFiles ( DIR _NUM , false ) ; assertFalse ( itor . hasNext ( ) ) ; testing directory with _NUM file writeFile ( fs , FILE _NUM , FILE _ LEN ) ; itor = fs . listFiles ( DIR _NUM , true ) ; LocatedFileStatus stat = itor . next ( ) ; assertFalse ( itor . hasNext ( ) ) ; assertTrue ( stat . isFile ( ) ) ; assertEquals ( FILE _ LEN , stat . getLen ( ) ) ; assertEquals ( fs . makeQualified ( FILE _NUM ) , stat . getPath ( ) ) ; assertEquals ( _NUM , stat . getBlockLocations ( ) . length ) ; itor = fs . listFiles ( DIR _NUM , false ) ; stat = itor . next ( ) ; assertFalse ( itor . hasNext ( ) ) ; assertTrue ( stat . isFile ( ) ) ; assertEquals ( FILE _ LEN , stat . getLen ( ) ) ; assertEquals ( fs . makeQualified ( FILE _NUM ) , stat . getPath ( ) ) ; assertEquals ( _NUM , stat . getBlockLocations ( ) . length ) ; test more complicated directory writeFile ( fs , FILE _NUM , FILE _ LEN ) ; writeFile ( fs , FILE _NUM , FILE _ LEN ) ; Set < Path > filesToFind = new HashSet < Path > ( ) ; filesToFind . add ( fs . makeQualified ( FILE _NUM ) ) ; filesToFind . add ( fs . makeQualified ( FILE _NUM ) ) ; filesToFind . add ( fs . makeQualified ( FILE _NUM ) ) ; itor = fs . listFiles ( TEST _ DIR , true ) ; stat = itor . next ( ) ; assertTrue ( stat . isFile ( ) ) ; assertTrue ( _STR , filesToFind . remove ( stat . getPath ( ) ) ) ; assertFalse ( itor . hasNext ( ) ) ; assertTrue ( filesToFind . isEmpty ( ) ) ; itor = fs . listFiles ( TEST _ DIR , false ) ; stat = itor . next ( ) ; assertTrue ( stat . isFile ( ) ) ; assertEquals ( fs . makeQualified ( FILE _NUM ) , stat . getPath ( ) ) ; assertFalse ( itor . hasNext ( ) ) ; fs . delete ( TEST _ DIR , true ) ; } 
2379	public int getOuterX ( ) { return getX ( ) - getStyle ( ) . getMarginLeftNoRTL ( ) ; } 
2380	public void generateKeys ( ) { XMSSMTKeyPairGenerator kpGen = new XMSSMTKeyPairGenerator ( ) ; kpGen . init ( new XMSSMTKeyGenerationParameters ( getParams ( ) , prng ) ) ; AsymmetricCipherKeyPair kp = kpGen . generateKeyPair ( ) ; privateKey = ( XMSSMTPrivateKeyParameters ) kp . getPrivate ( ) ; publicKey = ( XMSSMTPublicKeyParameters ) kp . getPublic ( ) ; importState ( privateKey , publicKey ) ; } 
2381	 @ GET @ Path ( _STR ) ) { acceptedStates . add ( NodeState . valueOf ( StringUtils . toUpperCase ( stateStr ) ) ) ; } } Collection < RMNode > rmNodes = RMServerUtils . queryRMNodes ( this . rm . getRMContext ( ) , acceptedStates ) ; NodesInfo nodesInfo = new NodesInfo ( ) ; for ( RMNode rmNode : rmNodes ) { NodeInfo nodeInfo = new NodeInfo ( rmNode , sched ) ; if ( EnumSet . of ( NodeState . LOST , NodeState . DECOMMISSIONED , NodeState . REBOOTED ) . contains ( rmNode . getState ( ) ) ) { nodeInfo . setNodeHTTPAddress ( EMPTY ) ; } nodesInfo . add ( nodeInfo ) ; } return nodesInfo ; } 
2382	boolean smoothSlideTo ( float slideOffset , int velocity ) { if ( ! mCanSlide ) { Nothing to do . return false ; } final boolean isLayoutRtl = isLayoutRtlSupport ( ) ; final LayoutParams lp = ( LayoutParams ) mSlideableView . getLayoutParams ( ) ; int x ; if ( isLayoutRtl ) { int startBound = getPaddingRight ( ) + lp . rightMargin ; int childWidth = mSlideableView . getWidth ( ) ; x = ( int ) ( getWidth ( ) - ( startBound + slideOffset * mSlideRange + childWidth ) ) ; } else { int startBound = getPaddingLeft ( ) + lp . leftMargin ; x = ( int ) ( startBound + slideOffset * mSlideRange ) ; } if ( mDragHelper . smoothSlideViewTo ( mSlideableView , x , mSlideableView . getTop ( ) ) ) { setAllChildrenVisible ( ) ; ViewCompat . postInvalidateOnAnimation ( this ) ; return true ; } return false ; } 
2383	public static ORID getRidLinkByUUID ( String id ) { ODatabaseRecordTx db = DbHelper . getConnection ( ) ; OIndex < ? > index = db . getMetadata ( ) . getIndexManager ( ) . getIndex ( LinkDao . MODEL _ NAME + _STR ) ; ORID rid = ( ORID ) index . get ( id ) ; return rid ; } 
2384	private static int parseToSingleInt ( String version ) { try { String [ ] parts = split _NUM ( ' . ' , version ) ; return parse ( parts ) ; } catch ( Exception e ) { log . debug ( _STR , version , e . getMessage ( ) ) ; } return _NUM ; } 
2385	public Instance generateExample ( ) throws Exception { Instance result ; int centroid ; double [ ] atts ; double magnitude ; double desiredMag ; double scale ; int i ; double label ; Random rand ; result = null ; rand = getRandom ( ) ; if ( m _ DatasetFormat = = null ) throw new Exception ( _STR ) ; generate class label based on class probs centroid = chooseRandomIndexBasedOnProportions ( m _ centroidWeights , rand ) ; label = m _ centroidClasses [ centroid ] ; generate attributes atts = new double [ getNumAttributes ( ) + _NUM ] ; for ( i = _NUM ; i < getNumAttributes ( ) ; i + + ) atts [ i ] = ( rand . nextDouble ( ) * _NUM . _NUM ) - _NUM . _NUM ; atts [ atts . length - _NUM ] = label ; magnitude = _NUM . _NUM ; for ( i = _NUM ; i < getNumAttributes ( ) ; i + + ) magnitude + = atts [ i ] * atts [ i ] ; magnitude = Math . sqrt ( magnitude ) ; desiredMag = rand . nextGaussian ( ) * m _ centroidStdDevs [ centroid ] ; scale = desiredMag / magnitude ; for ( i = _NUM ; i < getNumAttributes ( ) ; i + + ) { atts [ i ] * = scale ; atts [ i ] + = m _ centroids [ centroid ] [ i ] ; result = new DenseInstance ( _NUM . _NUM , atts ) ; } dataset reference result . setDataset ( m _ DatasetFormat ) ; return result ; } 
2386	public void cacheContentDefinition ( String systemId , CmsXmlContentDefinition contentDefinition ) { String cacheKey = getCacheKeyForCurrentProject ( systemId ) ; m _ cacheContentDefinitions . put ( cacheKey , contentDefinition ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( Messages . get ( ) . getBundle ( ) . key ( Messages . LOG _ ERR _ CACHED _ SYSTEM _ ID _ _NUM , cacheKey ) ) ; } } 
2387	public void clearCache ( RegionInfo hri ) { ConcurrentMap < byte [ ] , RegionLocations > tableLocations = getTableLocations ( hri . getTable ( ) ) ; RegionLocations regionLocations = tableLocations . get ( hri . getStartKey ( ) ) ; if ( regionLocations ! = null ) { HRegionLocation oldLocation = regionLocations . getRegionLocation ( hri . getReplicaId ( ) ) ; if ( oldLocation = = null ) return ; RegionLocations updatedLocations = regionLocations . remove ( oldLocation ) ; boolean removed ; if ( updatedLocations ! = regionLocations ) { if ( updatedLocations . isEmpty ( ) ) { removed = tableLocations . remove ( hri . getStartKey ( ) , regionLocations ) ; } else { removed = tableLocations . replace ( hri . getStartKey ( ) , regionLocations , updatedLocations ) ; } if ( removed ) { if ( metrics ! = null ) { metrics . incrMetaCacheNumClearRegion ( ) ; } if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( _STR ) ; } } } } } 
2388	public final boolean run ( final Context ctx , final OutputStream os ) { check if database is opened final Data data = ctx . data ( ) ; if ( data = = null & & openDB ) return error ( NO _ DB _ OPENED ) ; check permissions if ( ! ctx . perm ( perm , data ! = null & & ! data . inMemory ( ) ? data . meta . name : null ) ) return error ( PERM _ REQUIRED _ X , perm ) ; init ( ctx , os ) ; try { check if job was stopped before it was started checkStop ( ) ; return run ( ) ; } catch ( final JobException ex ) { job was interrupted by the user or server return error ( ex . getMessage ( ) ) ; } catch ( final OutOfMemoryError ex ) { out of memory Performance . gc ( _NUM ) ; Util . debug ( ex ) ; return error ( OUT _ OF _ MEM + ( perm = = Perm . CREATE ? H _ OUT _ OF _ MEM : _STR ) ) ; } catch ( final Throwable ex ) { any other unexpected error return error ( Util . bug ( ex ) + Prop . NL + info ) ; } finally { flushes the output try { if ( out ! = null ) out . flush ( ) ; } catch ( final IOException ex ) { Util . debug ( ex ) ; } } } 
2389	private static DetectionState extractPageParam ( List < PageParamInfo . PageInfo > ascendingNumbers , ParsedUrl parsedDocUrl , String acceptedPagePattern ) { Eliminate calendar date links . if ( areCalendarDates ( ascendingNumbers ) ) return null ; String firstPageUrl = _STR ) ; extractPageParamCandidatesFromQuery ( url , page . mPageNum , i , pageCandidates ) ; if ( page . mPageNum = = _NUM ) firstPageUrl = page . mUrl ; } } If query components yield nothing , try paths of URLs . if ( pageCandidates . map . isEmpty ( ) ) { for ( int i = _NUM ; i < ascendingNumbers . size ( ) ; i + + ) { final PageParamInfo . PageInfo page = ascendingNumbers . get ( i ) ; if ( parsedUrls [ i ] ! = null ) { extractPageParamCandidatesFromPath ( parsedUrls [ i ] , page . mPageNum , i , pageCandidates ) ; } } } Determine which URL page pattern is valid with a valid , and the best , PageParamInfo . DetectionState state = new DetectionState ( ) ; for ( Map . Entry < String , PageCandidatesMap . Info > entry : pageCandidates . map . entrySet ( ) ) { final String patternStr = entry . getKey ( ) ; final PageCandidatesMap . Info info = entry . getValue ( ) ; if ( patternStr . equals ( acceptedPagePattern ) | | info . mLinks . size ( ) > MAX _ PAGING _ DOCS | | ! info . mPattern . isValidFor ( parsedDocUrl ) ) { continue ; } PageParamInfo pageParamInfo = PageParamInfo . evaluate ( info . mPattern , info . mLinks , ascendingNumbers , firstPageUrl ) ; if ( pageParamInfo = = null ) continue ; If feasible , insert current document URL as first page . Otherwise , we enhance the heuristic : if current document URL fits the paging pattern of the potential pagination URLs , consider it as first page too . final String docUrl = parsedDocUrl . getCleanHref ( ) ; if ( pageParamInfo . canInsertFirstPage ( docUrl , ascendingNumbers ) ) { pageParamInfo . insertFirstPage ( docUrl ) ; } else if ( info . mPattern . isPagingUrl ( docUrl ) ) { final PageParamInfo . PageInfo firstPage = pageParamInfo . mAllPageInfo . get ( _NUM ) ; if ( firstPage . mPageNum = = _NUM & & ! firstPage . mUrl . equals ( docUrl ) & & docUrl . length ( ) < firstPage . mUrl . length ( ) ) { pageParamInfo . insertFirstPage ( docUrl ) ; } } state . compareAndUpdate ( new DetectionState ( pageParamInfo ) ) ; } return state . isEmpty ( ) ? null : state ; } 
2390	public GF _NUM Polynomial add ( GF _NUM Polynomial b ) { return xor ( b ) ; } 
2391	public void printCallStack ( DMLFrame currFrame , Stack < DMLFrame > callStack ) { int frameID = _NUM ; if ( currFrame = = null ) System . out . println ( _STR + frameID + + ) ; printFrame ( currFrame ) ; } } 
2392	boolean advanceProcessingTimeBy ( Duration duration ) throws Exception { currentProcessingTime = currentProcessingTime . plus ( duration ) ; timerInternals . advanceProcessingTime ( currentProcessingTime ) ; List < TimerInternals . TimerData > timers = new ArrayList < > ( ) ; TimerInternals . TimerData nextTimer ; while ( ( nextTimer = timerInternals . removeNextProcessingTimer ( ) ) ! = null ) { timers . add ( nextTimer ) ; } if ( timers . isEmpty ( ) ) { return false ; } tester . processElement ( KeyedWorkItems . timersWorkItem ( _STR , timers ) ) ; return true ; } 
2393	public void setFont ( Font font , boolean override ) { if ( proxyTo ! = null ) { for ( Style s : proxyTo ) { s . setFont ( font , override ) ; } return ; } if ( this . font = = null & & font ! = null | | ( this . font ! = null & & ! this . font . equals ( font ) ) ) { this . font = font ; if ( ! override ) { modifiedFlag | = FONT _ MODIFIED ; } firePropertyChanged ( FONT ) ; } } 
2394	public static String getImageFileMD _NUM IgnoringTxId ( File imageFile ) throws IOException { File tmpFile = File . createTempFile ( _STR ) ; try { raf . seek ( IMAGE _ TXID _ POS ) ; raf . writeLong ( _NUM ) ; } finally { IOUtils . closeStream ( raf ) ; } return getFileMD _NUM ( tmpFile ) ; } finally { tmpFile . delete ( ) ; } } 
2395	public URI relativize ( URI uri ) { if ( isOpaque ( ) | | uri . isOpaque ( ) ) { return uri ; } if ( getScheme ( ) = = null | | uri . getScheme ( ) = = null | | getScheme ( ) . equals ( uri . getScheme ( ) ) = = false ) { return uri ; } String thisAuthority = null ; String thatAuthority = null ; String thisPath = null ; String thatPath = null ; if ( ( thisAuthority = getAuthority ( ) ) = = null | | ( thatAuthority = uri . getAuthority ( ) ) = = null | | thisAuthority . equals ( thatAuthority ) = = false ) { return uri ; } if ( ( thisPath = getPath ( ) ) = = null | | ( thatPath = uri . getPath ( ) ) = = null | | thatPath . startsWith ( thisPath + PATH _ SEPARATOR ) = = false ) { return uri ; } try { return new URI ( null , null , thatPath . substring ( thisPath . length ( ) + _NUM ) , uri . getQuery ( ) , uri . getFragment ( ) ) ; } catch ( URISyntaxException e ) { Since the two URIs are pre - validated , we should never get here . throw new IllegalArgumentException ( e . getMessage ( ) ) ; } } 
2396	public void buildTree ( Instances data , SimpleLinearRegression [ ] [ ] higherRegressions , double totalInstanceWeight , double higherNumParameters ) throws Exception { save some stuff m _ totalInstanceWeight = totalInstanceWeight ; m _ train = new Instances ( data ) ; m _ isLeaf = true ; m _ sons = null ; m _ numInstances = m _ train . numInstances ( ) ; m _ numClasses = m _ train . numClasses ( ) ; init m _ numericData = getNumericData ( m _ train ) ; m _ numericDataHeader = new Instances ( m _ numericData , _NUM ) ; m _ regressions = initRegressions ( ) ; m _ numRegressions = _NUM ; if ( higherRegressions ! = null ) m _ higherRegressions = higherRegressions ; else m _ higherRegressions = new SimpleLinearRegression [ m _ numClasses ] [ _NUM ] ; m _ numHigherRegressions = m _ higherRegressions [ _NUM ] . length ; m _ numParameters = higherNumParameters ; build logistic model if ( m _ numInstances > = m _ numFoldsBoosting ) { if ( m _ fixedNumIterations > _NUM ) { performBoosting ( m _ fixedNumIterations ) ; } else if ( getUseAIC ( ) ) { performBoostingInfCriterion ( ) ; } else { performBoostingCV ( ) ; } } m _ numParameters + = m _ numRegressions ; only keep the simple regression functions that correspond to the selected number of LogitBoost iterations m _ regressions = selectRegressions ( m _ regressions ) ; boolean grow ; split node if more than minNumInstances . . . if ( m _ numInstances > m _ minNumInstances ) { split node : either splitting on class value ( a la C _NUM . _NUM ) or splitting on residuals if ( m _ modelSelection instanceof ResidualModelSelection ) { need ps / Ys / Zs / weights double [ ] [ ] probs = getProbs ( getFs ( m _ numericData ) ) ; double [ ] [ ] trainYs = getYs ( m _ train ) ; double [ ] [ ] dataZs = getZs ( probs , trainYs ) ; double [ ] [ ] dataWs = getWs ( probs , trainYs ) ; m _ localModel = ( ( ResidualModelSelection ) m _ modelSelection ) . selectModel ( m _ train , dataZs , dataWs ) ; } else { m _ localModel = m _ modelSelection . selectModel ( m _ train ) ; } . . . and valid split found grow = ( m _ localModel . numSubsets ( ) > _NUM ) ; } else { grow = false ; } if ( grow ) { create and build children of node m _ isLeaf = false ; Instances [ ] localInstances = m _ localModel . split ( m _ train ) ; m _ sons = new LMTNode [ m _ localModel . numSubsets ( ) ] ; for ( int i = _NUM ; i < m _ sons . length ; i + + ) { m _ sons [ i ] = new LMTNode ( m _ modelSelection , m _ fixedNumIterations , m _ fastRegression , m _ errorOnProbabilities , m _ minNumInstances , getWeightTrimBeta ( ) , getUseAIC ( ) ) ; the _STR at this node plus the regressions added at this node ( m _ regressions ) . m _ sons [ i ] . buildTree ( localInstances [ i ] , mergeArrays ( m _ regressions , m _ higherRegressions ) , m _ totalInstanceWeight , m _ numParameters ) ; localInstances [ i ] = null ; } } } 
2397	protected String readString ( ) throws IOException { skipSpaces ( ) ; StringBuilder buffer = new StringBuilder ( ) ; int c = seqSource . read ( ) ; while ( ! isEndOfName ( ( char ) c ) & & c ! = - _NUM ) { buffer . append ( ( char ) c ) ; c = seqSource . read ( ) ; } if ( c ! = - _NUM ) { seqSource . unread ( c ) ; } return buffer . toString ( ) ; } 
2398	public boolean isDetachedSignature ( ) { return signedData . getEncapContentInfo ( ) . getContent ( ) = = null & & signedData . getSignerInfos ( ) . size ( ) > _NUM ; } 
2399	public InputStream getData ( ) { if ( isCompressed ( ) ) { int size = LittleEndian . getInt ( _ data ) ; InputStream compressedStream = new ByteArrayInputStream ( _ data , _NUM , _ data . length ) ; return new BoundedInputStream ( new InflaterInputStream ( compressedStream ) , size ) ; } else { return new ByteArrayInputStream ( _ data , _NUM , _ data . length ) ; } } 
2400	public FluentInitializer withSelectedDates ( Collection < Date > selectedDates ) { if ( selectionMode = = SelectionMode . SINGLE & & selectedDates . size ( ) > _NUM ) { throw new IllegalArgumentException ( _STR ) ; } if ( selectedDates ! = null ) { for ( Date date : selectedDates ) { selectDate ( date ) ; } } scrollToSelectedDates ( ) ; validateAndUpdate ( ) ; return this ; } 
2401	public static File generateTempDataFile ( List < Shard > shardList , int numRecordsPerShard , String fileNamePrefix ) throws IOException { File file = File . createTempFile ( fileNamePrefix , FILE _ NAME _ SUFFIX ) ; try ( BufferedWriter fileWriter = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( file ) , StandardCharsets . UTF _ _NUM ) ) ) { ObjectMapper objectMapper = new ObjectMapper ( ) ; String serializedShardList = objectMapper . writeValueAsString ( new KinesisLocalFileProxy . SerializedShardList ( shardList ) ) ; fileWriter . write ( serializedShardList ) ; fileWriter . newLine ( ) ; BigInteger sequenceNumberIncrement = new BigInteger ( _STR + timestamp ; fileWriter . write ( line ) ; fileWriter . newLine ( ) ; sequenceNumberIncrement = sequenceNumberIncrement . add ( BigInteger . ONE ) ; sequenceNumberIncrement = sequenceNumberIncrement . add ( new BigInteger ( NUM _ BITS , randomGenerator ) ) ; } } } return file ; } 
2402	public void activateNextMasterKey ( ) { super . writeLock . lock ( ) ; try { LOG . info ( _STR + this . nextMasterKey . getMasterKey ( ) . getKeyId ( ) ) ; this . currentMasterKey = this . nextMasterKey ; this . nextMasterKey = null ; clearApplicationNMTokenKeys ( ) ; } finally { super . writeLock . unlock ( ) ; } } 
2403	 @ Nullable @ VisibleForTestingActivityInfo injectGetActivityInfoWithMetadataWithUninstalled ( ComponentName activity , @ UserIdInt int userId ) { final long start = injectElapsedRealtime ( ) ; final long token = injectClearCallingIdentity ( ) ; try { return mIPackageManager . getActivityInfo ( activity , ( PACKAGE _ MATCH _ FLAGS | PackageManager . GET _ META _ DATA ) , userId ) ; } catch ( RemoteException e ) { Shouldn ' t happen . Slog . wtf ( TAG , _STR , e ) ; return null ; } finally { injectRestoreCallingIdentity ( token ) ; logDurationStat ( Stats . GET _ ACTIVITY _ WITH _ METADATA , start ) ; } } 
2404	public void close ( ) { if ( DBG ) Log . d ( TAG , _STR ) ; unregisterApp ( ) ; mConnState = CONN _ STATE _ CLOSED ; mAuthRetryState = AUTH _ RETRY _ STATE _ IDLE ; } 
2405	public Resources createBaseActivityResources ( @ NonNull IBinder activityToken , @ Nullable String resDir , @ Nullable String [ ] splitResDirs , @ Nullable String [ ] overlayDirs , @ Nullable String [ ] libDirs , int displayId , @ Nullable Configuration overrideConfig , @ NonNull CompatibilityInfo compatInfo , @ Nullable ClassLoader classLoader ) { try { Trace . traceBegin ( Trace . TRACE _ TAG _ RESOURCES , _STR + key ) ; } synchronized ( this ) { Force the creation of an ActivityResourcesStruct . getOrCreateActivityResourcesStructLocked ( activityToken ) ; } Update any existing Activity Resources references . updateResourcesForActivity ( activityToken , overrideConfig , displayId , false ) ; Now request an actual Resources object . return getOrCreateResources ( activityToken , key , classLoader ) ; } finally { Trace . traceEnd ( Trace . TRACE _ TAG _ RESOURCES ) ; } } 
2406	void updateResizingWindowIfNeeded ( ) { final WindowStateAnimator winAnimator = mWinAnimator ; if ( ! mHasSurface | | mService . mLayoutSeq ! = mLayoutSeq | | isGoneForLayoutLw ( ) ) { return ; } final Task task = getTask ( ) ; phases in the animation , and the client will become sad and confused . if ( task ! = null & & task . mStack . isAnimatingBounds ( ) ) { return ; } setReportResizeHints ( ) ; boolean configChanged = isConfigChanged ( ) ; if ( DEBUG _ CONFIGURATION & & configChanged ) { Slog . v ( TAG _ WM , _STR + winAnimator . mSurfaceController ) ; setOrientationChanging ( false ) ; mLastFreezeDuration = ( int ) ( SystemClock . elapsedRealtime ( ) - mService . mDisplayFreezeTime ) ; } } } 
2407	public static boolean isContained ( File folder , File file ) { String folderPath = getCanonicalPath ( folder ) ; String filePath = getCanonicalPath ( file ) ; return filePath . startsWith ( folderPath ) ; } 
2408	public CmsResourceFilter addRequireReleaseAfter ( long time ) { CmsResourceFilter extendedFilter = ( CmsResourceFilter ) clone ( ) ; extendedFilter . m _ filterRelease = true ; extendedFilter . m _ releaseAfter = time ; extendedFilter . updateCacheId ( ) ; return extendedFilter ; } 
2409	public void outOfBandFolder _ rename _ rootLevelFiles ( ) throws Exception { NOTE : manual use of CloubBlockBlob targets working directory explicitly . WASB driver methods prepend working directory implicitly . CloudBlockBlob blob = testAccount . getBlobReference ( _STR ) ; fs . rename ( srcFilePath , destFilePath ) ; } 
2410	public boolean match ( FeatureStructure featureStructure ) { if ( ! ( featureStructure instanceof AnnotationFS ) ) { return false ; } AnnotationFS annotation = ( AnnotationFS ) featureStructure ; for ( AnnotationFS containingAnnotation : mContainingAnnotations ) { if ( isContaining ( annotation , containingAnnotation ) ) { return true ; } } return false ; } 
2411	protected Size _NUM D arrangeRF ( BlockContainer container , Graphics _NUM D g _NUM , RectangleConstraint constraint ) { Size _NUM D s = arrangeNF ( container , g _NUM , constraint ) ; if ( constraint . getWidthRange ( ) . contains ( s . width ) ) { return s ; } else { RectangleConstraint c = constraint . toFixedWidth ( constraint . getWidthRange ( ) . constrain ( s . getWidth ( ) ) ) ; return arrangeFF ( container , g _NUM , c ) ; } } 
2412	static void verifyReaders ( XMLStreamReader teacher , XMLStreamReader reader , boolean eec , boolean pfx ) throws XMLStreamException { compare the elements and attributes while ignoring comments , line breaks , etc for ( ; ; ) { int revent = getNextEvent ( reader ) ; int tevent = getNextEvent ( teacher ) ; if ( revent = = - _NUM & & tevent = = - _NUM ) { break ; } LOG . fine ( _STR , teacher . getText ( ) , reader . getText ( ) ) ; break ; default : } } } 
2413	public static void saveAsXML ( NSObject root , File out ) throws IOException { File parent = out . getParentFile ( ) ; if ( ! parent . exists ( ) ) if ( ! parent . mkdirs ( ) ) throw new IOException ( _STR ) ; FileOutputStream fous = new FileOutputStream ( out ) ; saveAsXML ( root , fous ) ; fous . close ( ) ; } 
2414	public void setPropertyValueTagReplaceID ( String propertyValueTagreplaceID ) throws CmsIllegalArgumentException { if ( CmsStringUtil . isEmptyOrWhitespaceOnly ( propertyValueTagreplaceID ) ) { m _ propertyValueTagReplaceID = getDefaultTagReplaceID ( ) ; } else { m _ propertyValueTagReplaceID = propertyValueTagreplaceID ; } } 
2415	void add ( Task t ) { mTasks . add ( t ) ; updateFilteredTasks ( ) ; } 
2416	public void unset ( Symbol property ) { context . remove ( property ) ; } 
2417	public static CollectionType frozenSet ( DataType elementType ) { return set ( elementType , true ) ; } 
2418	void logSetPermissions ( String src , FsPermission permissions ) { SetPermissionsOp op = SetPermissionsOp . getInstance ( cache . get ( ) ) . setSource ( src ) . setPermissions ( permissions ) ; logEdit ( op ) ; } 
2419	public void saveAttributes ( ) throws IOException { if ( ! mIsSupportedFile | | mMimeType ! = IMAGE _ TYPE _ JPEG ) { throw new IOException ( _STR + tempFile . getAbsolutePath ( ) ) ; } FileInputStream in = null ; FileOutputStream out = null ; try { Save the new file . in = new FileInputStream ( tempFile ) ; out = new FileOutputStream ( mFilename ) ; saveJpegAttributes ( in , out ) ; } finally { closeQuietly ( in ) ; closeQuietly ( out ) ; tempFile . delete ( ) ; } Discard the thumbnail in memory mThumbnailBytes = null ; } 
2420	public void stop ( ) { if ( acceptChannel = = null | | ! acceptChannel . isOpen ( ) ) { LOG . info ( _STR , e ) ; } } 
2421	public static String escape ( String string ) { char c ; String s = string . trim ( ) ; StringBuilder sb = new StringBuilder ( ) ; int len = s . length ( ) ; for ( int i = _NUM ; i < len ; i + = _NUM ) { c = s . charAt ( i ) ; if ( c < ' ' | | c = = ' + ' | | c = = ' % ' | | c = = ' = ' | | c = = ' ; ' ) { sb . append ( ' % ' ) ; sb . append ( Character . forDigit ( ( char ) ( ( c > > > _NUM ) & _NUM x _NUM f ) , _NUM _NUM ) ) ; sb . append ( Character . forDigit ( ( char ) ( c & _NUM x _NUM f ) , _NUM _NUM ) ) ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; } 
2422	public RegularTimePeriod getPeriod ( int index ) { final OHLCItem item = ( OHLCItem ) getDataItem ( index ) ; return item . getPeriod ( ) ; } 
2423	private void paintSelectionAndBorder ( final Object [ ] objects , final Color borderColor , final int borderThickness , final MTTabsPainter tabsPainter ) throws ClassNotFoundException , NoSuchFieldException , IllegalAccessException { Get the shapeinfo class because it is protected final Class < ? > clazz = Class . forName ( _STR ) ; final ShapeTransform path = ( ShapeTransform ) pathField . get ( selectedShape ) ; final ShapeTransform fillPath = ( ShapeTransform ) fillPathField . get ( selectedShape ) ; final ShapeTransform labelPath = ( ShapeTransform ) labelPathField . get ( selectedShape ) ; Other properties needed for drawing final Insets i = path . transformInsets ( insets ) ; final int rectX = rect . x ; final int rectY = rect . y ; final int rectHeight = rect . height ; The tabs component final JBEditorTabs tabsComponent = tabsPainter . getTabsComponent ( ) ; Position of tabs final JBTabsPosition position = tabsComponent . getTabsPosition ( ) ; color me tabsPainter . fillSelectionAndBorder ( g _NUM d , fillPath , tabColor , rectX , rectY , rectHeight ) ; paint the bottom bar in non darcula lafs if ( ! UIUtil . isUnderDarcula ( ) ) { final Color lineColor = tabsPainter . getContrastColor ( ) ; g _NUM d . setColor ( lineColor ) ; g _NUM d . fillRect ( i . left , labelPath . getMaxY ( ) - _NUM , path . getMaxX ( ) , _NUM ) ; } Finally paint the active tab highlighter g _NUM d . setColor ( borderColor ) ; if ( position = = JBTabsPosition . bottom ) { Paint on top g _NUM d . fillRect ( rect . x , rect . y - _NUM , rect . width , borderThickness ) ; } else if ( position = = JBTabsPosition . top ) { Paint on bottom g _NUM d . fillRect ( rect . x , rect . y + rect . height - borderThickness + _NUM , rect . width , borderThickness ) ; g _NUM d . setColor ( UIUtil . CONTRAST _ BORDER _ COLOR ) ; g _NUM d . drawLine ( Math . max ( _NUM , rect . x - _NUM ) , rect . y , rect . x + rect . width , rect . y ) ; } else if ( position = = JBTabsPosition . left ) { g _NUM d . fillRect ( rect . x , rect . y , borderThickness , rect . height ) ; } else if ( position = = JBTabsPosition . right ) { g _NUM d . fillRect ( rect . x + rect . width - borderThickness + _NUM , rect . y , borderThickness , rect . height ) ; } } 
2424	public void bug _NUM _NUM _NUM _NUM _NUM ( ) throws Exception { HSSFWorkbook wb = openSample ( _STR ) ; HSSFSheet s = wb . getSheetAt ( _NUM ) ; HSSFRow r = s . createRow ( _NUM ) ; HSSFCell c = r . createCell ( _NUM ) ; c . setCellValue ( _NUM _NUM ) ; writeOutAndReadBack ( wb ) . close ( ) ; wb . close ( ) ; } 
2425	public void testCopyToOutputFiles ( ) throws Exception { SimpleSink . SimpleWriteOperation < Void > writeOp = buildWriteOperation ( ) ; List < String > inputFilenames = Arrays . asList ( _STR ) ; List < KV < FileResult < Void > , ResourceId > > resultsToFinalFilenames = Lists . newArrayList ( ) ; List < ResourceId > expectedOutputPaths = Lists . newArrayList ( ) ; for ( int i = _NUM ; i < inputFilenames . size ( ) ; i + + ) { Generate output paths . expectedOutputPaths . add ( getBaseOutputDirectory ( ) . resolve ( expectedOutputFilenames . get ( i ) , StandardResolveOptions . RESOLVE _ FILE ) ) ; Generate and write to input paths . File inputTmpFile = tmpFolder . newFile ( inputFilenames . get ( i ) ) ; List < String > lines = Collections . singletonList ( inputContents . get ( i ) ) ; writeFile ( lines , inputTmpFile ) ; ResourceId finalFilename = writeOp . getSink ( ) . getDynamicDestinations ( ) . getFilenamePolicy ( null ) . unwindowedFilename ( i , inputFilenames . size ( ) , CompressionType . UNCOMPRESSED ) ; resultsToFinalFilenames . add ( KV . of ( new FileResult < > ( LocalResources . fromFile ( inputTmpFile , false ) , UNKNOWN _ SHARDNUM , GlobalWindow . INSTANCE , PaneInfo . ON _ TIME _ AND _ ONLY _ FIRING , null ) , finalFilename ) ) ; } Copy input files to output files . writeOp . moveToOutputFiles ( resultsToFinalFilenames ) ; Assert that the contents were copied . for ( int i = _NUM ; i < expectedOutputPaths . size ( ) ; i + + ) { assertFileContains ( Collections . singletonList ( inputContents . get ( i ) ) , expectedOutputPaths . get ( i ) ) ; } } 
2426	public void beginAtomicEdit ( ) { undoManager . beginInternalAtomicEdit ( ) ; } 
2427	public StoreFileWriter build ( ) throws IOException { if ( ( dir = = null ? _NUM : _NUM ) + ( filePath = = null ? _NUM : _NUM ) ! = _NUM ) { throw new IllegalArgumentException ( _STR ) ; } if ( dir = = null ) { dir = filePath . getParent ( ) ; } if ( ! fs . exists ( dir ) ) { Handle permission for non - HDFS filesystem properly See HBASE - _NUM _NUM _NUM _NUM _NUM HRegionFileSystem . mkdirs ( fs , conf , dir ) ; } set block storage policy for temp path String policyName = this . conf . get ( ColumnFamilyDescriptorBuilder . STORAGE _ POLICY ) ; if ( null = = policyName ) { policyName = this . conf . get ( HStore . BLOCK _ STORAGE _ POLICY _ KEY ) ; } FSUtils . setStoragePolicy ( this . fs , dir , policyName ) ; if ( filePath = = null ) { filePath = getUniqueFile ( fs , dir ) ; if ( ! BloomFilterFactory . isGeneralBloomEnabled ( conf ) ) { bloomType = BloomType . NONE ; } } if ( comparator = = null ) { comparator = CellComparator . getInstance ( ) ; } return new StoreFileWriter ( fs , filePath , conf , cacheConf , comparator , bloomType , maxKeyCount , favoredNodes , fileContext , shouldDropCacheBehind ) ; } 
2428	public void testFullRestoreRemote ( ) throws Exception { LOG . info ( _STR ) ; TableName [ ] tableset = new TableName [ ] { table _NUM } ; TableName [ ] tablemap = new TableName [ ] { table _NUM _ restore } ; getBackupAdmin ( ) . restore ( BackupUtils . createRestoreRequest ( BACKUP _ REMOTE _ ROOT _ DIR , backupId , false , tableset , tablemap , false ) ) ; HBaseAdmin hba = TEST _ UTIL . getHBaseAdmin ( ) ; assertTrue ( hba . tableExists ( table _NUM _ restore ) ) ; TEST _ UTIL . deleteTable ( table _NUM _ restore ) ; hba . close ( ) ; } 
2429	public boolean addAll ( int location , Collection < ? extends E > collection ) { if ( location < _NUM | | location > size ) { throw new IndexOutOfBoundsException ( _STR + size ) ; } Object [ ] dumparray = toObjectArray ( collection ) ; int growSize = dumparray . length ; collection . size ( ) earlier ? RI behaviour ? if ( growSize = = _NUM ) { return false ; } if ( location = = _NUM ) { growAtFront ( growSize ) ; firstIndex - = growSize ; } else if ( location = = size ) { if ( firstIndex + size > array . length - growSize ) { growAtEnd ( growSize ) ; } } else { must be case : ( _NUM < location & & location < size ) if ( array . length - size < growSize ) { growForInsert ( location , growSize ) ; } else if ( firstIndex + size > array . length - growSize | | ( firstIndex > _NUM & & location < size / _NUM ) ) { int newFirst = firstIndex - growSize ; if ( newFirst < _NUM ) { int index = location + firstIndex ; System . arraycopy ( array , index , array , index - newFirst , size - location ) ; newFirst = _NUM ; } System . arraycopy ( array , firstIndex , array , newFirst , location ) ; firstIndex = newFirst ; } else { int index = location + firstIndex ; System . arraycopy ( array , index , array , index + growSize , size - location ) ; } } System . arraycopy ( dumparray , _NUM , this . array , location + firstIndex , growSize ) ; size + = growSize ; modCount + + ; return true ; } 
2430	protected int internalCountProperties ( CmsDbContext dbc , CmsPropertyDefinition metadef , CmsUUID projectId ) throws CmsDataAccessException { ResultSet res = null ; PreparedStatement stmt = null ; Connection conn = null ; int returnValue ; try { create statement conn = m _ sqlManager . getConnection ( dbc ) ; stmt = m _ sqlManager . getPreparedStatement ( conn , projectId , _STR ) ; stmt . setString ( _NUM , metadef . getId ( ) . toString ( ) ) ; res = stmt . executeQuery ( ) ; if ( res . next ( ) ) { returnValue = res . getInt ( _NUM ) ; while ( res . next ( ) ) { do nothing only move through all rows because of mssql odbc driver } } else { throw new CmsDbConsistencyException ( Messages . get ( ) . container ( Messages . ERR _ NO _ PROPERTIES _ FOR _ PROPERTYDEF _ _NUM , metadef . getName ( ) ) ) ; } } catch ( SQLException e ) { throw new CmsDbSqlException ( Messages . get ( ) . container ( Messages . ERR _ GENERIC _ SQL _ _NUM , CmsDbSqlException . getErrorQuery ( stmt ) ) , e ) ; } finally { m _ sqlManager . closeAll ( dbc , conn , stmt , res ) ; } return returnValue ; } 
2431	public String getInstanceName ( ) { ExEmbed ee = getExEmbed ( ) ; return ( ee = = null ) ? null : ee . getMenuName ( ) ; } 
2432	private void updateExistingRow ( @ NonNull final SQLiteDatabase database , final long id , boolean bumpCount ) { String stringId = String . valueOf ( id ) ; begin the transaction database . beginTransaction ( ) ; get the cursor of this content inside the transaction final Cursor cursor = database . query ( SongPlayCountColumns . NAME , null , WHERE _ ID _ EQUALS , new String [ ] { stringId } , null , null , null ) ; if we have a result if ( cursor ! = null & & cursor . moveToFirst ( ) ) { figure how many weeks since we last updated int lastUpdatedIndex = cursor . getColumnIndex ( SongPlayCountColumns . LAST _ UPDATED _ WEEK _ INDEX ) ; int lastUpdatedWeek = cursor . getInt ( lastUpdatedIndex ) ; int weekDiff = mNumberOfWeeksSinceEpoch - lastUpdatedWeek ; if it ' s more than the number of weeks we track , delete it and create a new entry if ( Math . abs ( weekDiff ) > = NUM _ WEEKS ) { this entry needs to be dropped since it is too outdated deleteEntry ( database , stringId ) ; if ( bumpCount ) { createNewPlayedEntry ( database , id ) ; } } else if ( weekDiff ! = _NUM ) { else , shift the weeks int [ ] playCounts = new int [ NUM _ WEEKS ] ; if ( weekDiff > _NUM ) { time is shifted forwards for ( int i = _NUM ; i < NUM _ WEEKS - weekDiff ; i + + ) { playCounts [ i + weekDiff ] = cursor . getInt ( getColumnIndexForWeek ( i ) ) ; } } else if ( weekDiff < _NUM ) { NUM _ WEEKS + ( - _NUM ) we set the new week i = old week i - ( - _NUM ) or i + _NUM for ( int i = _NUM ; i < NUM _ WEEKS + weekDiff ; i + + ) { playCounts [ i ] = cursor . getInt ( getColumnIndexForWeek ( i - weekDiff ) ) ; } } bump the count if ( bumpCount ) { playCounts [ _NUM ] + + ; } float score = calculateScore ( playCounts ) ; if the score is non - existant , then delete it if ( score < . _NUM _NUM f ) { deleteEntry ( database , stringId ) ; } else { create the content values ContentValues values = new ContentValues ( NUM _ WEEKS + _NUM ) ; values . put ( SongPlayCountColumns . LAST _ UPDATED _ WEEK _ INDEX , mNumberOfWeeksSinceEpoch ) ; values . put ( SongPlayCountColumns . PLAY _ COUNT _ SCORE , score ) ; for ( int i = _NUM ; i < NUM _ WEEKS ; i + + ) { values . put ( getColumnNameForWeek ( i ) , playCounts [ i ] ) ; } update the entry database . update ( SongPlayCountColumns . NAME , values , WHERE _ ID _ EQUALS , new String [ ] { stringId } ) ; } } else if ( bumpCount ) { else no shifting , just update the scores ContentValues values = new ContentValues ( _NUM ) ; increase the score by a single score amount int scoreIndex = cursor . getColumnIndex ( SongPlayCountColumns . PLAY _ COUNT _ SCORE ) ; float score = cursor . getFloat ( scoreIndex ) + getScoreMultiplierForWeek ( _NUM ) ; values . put ( SongPlayCountColumns . PLAY _ COUNT _ SCORE , score ) ; increase the play count by _NUM values . put ( getColumnNameForWeek ( _NUM ) , cursor . getInt ( getColumnIndexForWeek ( _NUM ) ) + _NUM ) ; update the entry database . update ( SongPlayCountColumns . NAME , values , WHERE _ ID _ EQUALS , new String [ ] { stringId } ) ; } cursor . close ( ) ; } else if ( bumpCount ) { if we have no existing results , create a new one createNewPlayedEntry ( database , id ) ; } database . setTransactionSuccessful ( ) ; database . endTransaction ( ) ; } 
2433	public void sendVisualVoicemailSms ( String number , int port , String text , PendingIntent sentIntent ) { sendVisualVoicemailSmsForSubscriber ( mSubId , number , port , text , sentIntent ) ; } 
2434	private void scanHot ( ) { if ( handHot = = handTest ) { scanTest ( ) ; } if ( handHot . status = = Status . HOT ) { if ( handHot . marked ) { handHot . marked = false ; } else { handHot . status = Status . COLD ; sizeCold + + ; sizeHot - - ; } } Move the hand forward handHot = handHot . next ; } 
2435	public int numDeletedDocs ( SegmentInfo info ) throws IOException { ensureOpen ( false ) ; SegmentReader reader = readerPool . getIfExists ( info ) ; try { if ( reader ! = null ) { return reader . numDeletedDocs ( ) ; } else { return info . getDelCount ( ) ; } } finally { if ( reader ! = null ) { readerPool . release ( reader ) ; } } } 
2436	public List < GenericValue > getOrders ( String facilityId , Timestamp filterDate , Delegator delegator ) throws GenericEntityException { List < EntityCondition > allConditions = new LinkedList < EntityCondition > ( ) ; if ( facilityId ! = null ) { allConditions . add ( EntityCondition . makeCondition ( _STR ) . maxRows ( viewSize * ( viewIndex + _NUM ) ) . cursorScrollInsensitive ( ) . queryIterator ( ) ; get subset corresponding to pagination state List < GenericValue > orders = iterator . getPartialList ( viewSize * viewIndex , viewSize ) ; orderListSize = iterator . getResultsSizeAfterPartialList ( ) ; iterator . close ( ) ; return orders ; } 
2437	public Builder setDeleteBlock ( alluxio . proto . journal . Block . DeleteBlockEntry . Builder builderForValue ) { if ( deleteBlockBuilder _ = = null ) { deleteBlock _ = builderForValue . build ( ) ; onChanged ( ) ; } else { deleteBlockBuilder _ . setMessage ( builderForValue . build ( ) ) ; } bitField _NUM _ | = _NUM x _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM ; return this ; } 
2438	public void getRectSize ( Rect outSize ) { synchronized ( this ) { updateDisplayInfoLocked ( ) ; mDisplayInfo . getAppMetrics ( mTempMetrics , getDisplayAdjustments ( ) ) ; outSize . set ( _NUM , _NUM , mTempMetrics . widthPixels , mTempMetrics . heightPixels ) ; } } 
2439	public int read ( ) throws IOException { if ( bufOff > = maxBuf ) { if ( nextChunk ( ) < _NUM ) { return - _NUM ; } } return buf [ bufOff + + ] & _NUM xff ; } 
2440	public List < CmsResource > addResourcesToFolder ( CmsObject cms , String resourcename , CmsResourceFilter filter ) throws CmsException { String path = resourcename ; if ( ! path . endsWith ( _STR ) ; ret . add ( wrap . getResource ( ) ) ; return ret ; } } } } catch ( CmsVfsResourceNotFoundException ex ) { return null ; } } return null ; } 
2441	public String toJson ( ) throws IOException { StringWriter writer = new StringWriter ( ) ; try ( JsonGenerator generator = jsonFactory . createJsonGenerator ( writer ) . setCodec ( objectMapper ) ) { toJsonUtf _NUM ( generator ) ; } return writer . toString ( ) ; } 
2442	public String getStatus ( ) throws IOException { if ( FTPReply . isPositiveCompletion ( stat ( ) ) ) { return getReplyString ( ) ; } return null ; } 
2443	public static void parse ( SimpleXMLDocHandler doc , InputStream in ) throws IOException { byte [ ] b _NUM = new byte [ _NUM ] ; int count = in . read ( b _NUM ) ; if ( count ! = _NUM ) throw new IOException ( MessageLocalization . getComposedMessage ( _STR ) ; } if ( decl ! = null ) { decl = getDeclaredEncoding ( decl ) ; if ( decl ! = null ) encoding = decl ; } parse ( doc , new InputStreamReader ( in , IanaEncodings . getJavaEncoding ( encoding ) ) ) ; } 
2444	public static FrameObject rddStringIJVToFrameObject ( RDD < String > rdd , FrameMetadata frameMetadata ) { ClassTag < String > tag = scala . reflect . ClassTag $ . MODULE $ . apply ( String . class ) ; JavaRDD < String > javaRDD = JavaRDD . fromRDD ( rdd , tag ) ; return javaRDDStringIJVToFrameObject ( javaRDD , frameMetadata ) ; } 
2445	protected PdfPRow adjustCellsInRow ( int start , int end ) { PdfPRow row = new PdfPRow ( getRow ( start ) ) ; row . initExtraHeights ( ) ; PdfPCell cell ; PdfPCell [ ] cells = row . getCells ( ) ; for ( int i = _NUM ; i < cells . length ; i + + ) { cell = cells [ i ] ; if ( cell = = null | | cell . getRowspan ( ) = = _NUM ) continue ; int stop = Math . min ( end , start + cell . getRowspan ( ) ) ; float extra = _NUM ; for ( int k = start + _NUM ; k < stop ; k + + ) { extra + = getRowHeight ( k ) ; } row . setExtraHeight ( i , extra ) ; } return row ; } 
2446	public static void insertStyle ( HashMap h ) { String style = ( String ) h . get ( _STR , ss ) ; } } } 
2447	public boolean isDirectory ( Path f ) throws IOException { try { return getFileStatus ( f ) . isDirectory ( ) ; } catch ( FileNotFoundException e ) { f does not exist return false ; } } 
2448	public org . w _NUM c . dom . Node readNode ( ) throws IOException { int tag = read ( ) ; switch ( tag ) { case ' N ' : return null ; case ' S ' : case ' s ' : case ' X ' : case ' x ' : _ isLastChunk = tag = = ' S ' | | tag = = ' X ' ; _ chunkLength = ( read ( ) < < _NUM ) + read ( ) ; throw error ( _STR , tag ) ; } } 
2449	public boolean verifyMessageSignature ( String message , PublicKey publicKey ) { extract the type and signature parameters final Map < String , String > parsed = parseJSON ( message ) ; return verifySignature ( parsed , publicKey ) ; } 
2450	public boolean appendOneColumnVisibleItems ( ) { return appendVisibleItems ( mReversedFlow ? Integer . MAX _ VALUE : Integer . MIN _ VALUE , true ) ; } 
2451	public void reset ( ) { if ( DEBUG ) Log . d ( TAG , _STR ) ; } 
2452	public String getTitle ( ) { return getAttribute ( ATTR _ TITLE ) ; } 
2453	public static String getFileTitle ( String path ) { extract file name after last slash int lastSlash = path . lastIndexOf ( ' / ' ) ; if ( lastSlash > = _NUM ) { lastSlash + + ; if ( lastSlash < path . length ( ) ) { path = path . substring ( lastSlash ) ; } } truncate the file extension ( if any ) int lastDot = path . lastIndexOf ( ' . ' ) ; if ( lastDot > _NUM ) { path = path . substring ( _NUM , lastDot ) ; } return path ; } 
2454	public void addAll ( SolutionModifierHandler solutionModifier ) { List < SortCondition > lst = solutionModifier . query . getOrderBy ( ) ; if ( lst ! = null ) { for ( SortCondition sc : lst ) { query . addOrderBy ( sc ) ; } } query . getGroupBy ( ) . addAll ( solutionModifier . query . getGroupBy ( ) ) ; query . getHavingExprs ( ) . addAll ( solutionModifier . query . getHavingExprs ( ) ) ; query . setLimit ( solutionModifier . query . getLimit ( ) ) ; query . setOffset ( solutionModifier . query . getOffset ( ) ) ; } 
2455	private Dot checkForNewHit ( float x , float y ) { final int rowHit = getRowHit ( y ) ; if ( rowHit < _NUM ) { return null ; } final int columnHit = getColumnHit ( x ) ; if ( columnHit < _NUM ) { return null ; } if ( mPatternDrawLookup [ rowHit ] [ columnHit ] ) { return null ; } return Dot . of ( rowHit , columnHit ) ; } 
2456	public DFSInputStream . ReadStatistics getReadStatistics ( ) { return getDFSInputStream ( ) . getReadStatistics ( ) ; } 
2457	public void testFSLeakInObtainSystemTokensForUser ( ) throws Exception { Credentials credentials = new Credentials ( ) ; String user = _STR ; int oldCounter = MyFS . getInstanceCounter ( ) ; delegationTokenRenewer . obtainSystemTokensForUser ( user , credentials ) ; delegationTokenRenewer . obtainSystemTokensForUser ( user , credentials ) ; delegationTokenRenewer . obtainSystemTokensForUser ( user , credentials ) ; Assert . assertEquals ( oldCounter , MyFS . getInstanceCounter ( ) ) ; } 
2458	public void setZoomLevel ( int zoom ) { if ( zoom < = getMaxZoomLevel ( ) & & zoom > = getMinZoomLevel ( ) ) { _ zoom = zoom ; _ needTiles = true ; super . repaint ( ) ; } else { System . out . println ( _STR ) ; } } 
2459	private void releaseReservation ( int nBytes ) { assertOpen ( ) ; releaseBytes ( nBytes ) ; if ( DEBUG ) { historicalLog . recordEvent ( _STR , nBytes ) ; } } 
2460	public Range getDataRange ( ValueAxis axis ) { if ( this . dataset = = null ) { return null ; } Range result = null ; if ( axis = = getDomainAxis ( ) ) { result = DatasetUtilities . findDomainBounds ( this . dataset ) ; } else if ( axis = = getRangeAxis ( ) ) { result = DatasetUtilities . findRangeBounds ( this . dataset ) ; } return result ; } 
2461	protected static String LexicalError ( boolean EOFSeen , int lexState , int errorLine , int errorColumn , String errorAfter , char curChar ) { return ( _STR ) ; } 
2462	public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( _STR ) ; return sb . toString ( ) ; } 
2463	public String getStoragePolicyName ( Path path ) { try { Object blockStoragePolicySpi = ReflectionUtils . invokeMethod ( this . fs , _STR , e ) ; } return getStoragePolicyForOldHDFSVersion ( path ) ; } } 
2464	private void importToVfs ( File fsFile , String resName , String folder ) throws CmsException { try { get the content of the FS file byte [ ] content = CmsFileUtil . readFile ( fsFile ) ; create the file String filename = translate ( fsFile . getName ( ) ) ; m _ report . print ( org . opencms . report . Messages . get ( ) . container ( org . opencms . report . Messages . RPT _ SUCCESSION _ _NUM , String . valueOf ( m _ count + + ) ) , I _ CmsReport . FORMAT _ NOTE ) ; if ( fsFile . isFile ( ) ) { m _ report . print ( Messages . get ( ) . container ( Messages . RPT _ IMPORT _ FILE _ _NUM ) , I _ CmsReport . FORMAT _ NOTE ) ; } else { m _ report . print ( Messages . get ( ) . container ( Messages . RPT _ IMPORT _ FOLDER _ _NUM ) , I _ CmsReport . FORMAT _ NOTE ) ; } m _ report . print ( org . opencms . report . Messages . get ( ) . container ( org . opencms . report . Messages . RPT _ ARGUMENT _ _NUM , fsFile . getAbsolutePath ( ) . replace ( ' \ \ ' , ' / ' ) ) ) ; m _ report . print ( Messages . get ( ) . container ( Messages . RPT _ FROM _ FS _ TO _ _NUM ) , I _ CmsReport . FORMAT _ NOTE ) ; get the file type of the FS file int resType = OpenCms . getResourceManager ( ) . getDefaultTypeForName ( resName ) . getTypeId ( ) ; CmsResource newFile = m _ cms . createResource ( translate ( folder ) + filename , resType , content , new ArrayList ( ) ) ; m _ report . print ( org . opencms . report . Messages . get ( ) . container ( org . opencms . report . Messages . RPT _ ARGUMENT _ _NUM , m _ cms . getSitePath ( newFile ) ) ) ; m _ report . print ( org . opencms . report . Messages . get ( ) . container ( org . opencms . report . Messages . RPT _ DOTS _ _NUM ) ) ; now check if there is some external method to be called which should modify the imported resource in the VFS Iterator i = m _ synchronizeModifications . iterator ( ) ; while ( i . hasNext ( ) ) { try { ( ( I _ CmsSynchronizeModification ) i . next ( ) ) . modifyVfs ( m _ cms , newFile , fsFile ) ; } catch ( CmsSynchronizeException e ) { break ; } } we have to read the new resource again , to get the correct timestamp m _ cms . setDateLastModified ( m _ cms . getSitePath ( newFile ) , fsFile . lastModified ( ) , false ) ; CmsResource newRes = m _ cms . readResource ( m _ cms . getSitePath ( newFile ) ) ; add resource to synchronization list CmsSynchronizeList syncList = new CmsSynchronizeList ( resName , translate ( resName ) , newRes . getDateLastModified ( ) , fsFile . lastModified ( ) ) ; m _ newSyncList . put ( translate ( resName ) , syncList ) ; m _ report . println ( org . opencms . report . Messages . get ( ) . container ( org . opencms . report . Messages . RPT _ OK _ _NUM ) , I _ CmsReport . FORMAT _ OK ) ; } catch ( IOException e ) { throw new CmsSynchronizeException ( Messages . get ( ) . container ( Messages . ERR _ READING _ FILE _ _NUM , fsFile . getName ( ) ) , e ) ; } } 
2465	public long returnAvailableVolumeSize ( String volName , String userName , String password , String serverIp ) throws ServerException { long availableSize = _NUM ; NaElement xi = new NaElement ( _STR , ioe ) ; } finally { if ( s ! = null ) s . close ( ) ; } } 
2466	public DataBuffer getIndicesOf ( int i ) { int from = underlyingRank ( ) * i ; not included int to = from + underlyingRank ( ) ; int [ ] arr = new int [ rank ] ; iterator over underlying indices int j = _NUM ; iterator over hiddenIdx int k = _NUM ; for ( int dim = _NUM ; dim < rank ; dim + + ) { if ( k < hiddenDimensions ( ) . length & & hiddenDimensions ( ) [ k ] = = j ) { arr [ dim ] = _NUM ; k + + ; } else { arr [ dim ] = indices . getInt ( j ) ; j + + ; } } return Nd _NUM j . getDataBufferFactory ( ) . createInt ( arr ) ; } 
2467	public static void copy ( Configuration conf , String confKey , Properties props , String propsKey , boolean required ) throws SwiftConfigurationException { TODO : replace . version compatibility issue conf . getTrimmed fails with NoSuchMethodError String val = conf . get ( confKey ) ; if ( val ! = null ) { val = val . trim ( ) ; } if ( required & & val = = null ) { throw new SwiftConfigurationException ( _STR + confKey ) ; } set ( props , propsKey , val ) ; } 
2468	private int writeDictionary ( final OutputStream out , final int codepage ) throws IOException { final byte [ ] padding = new byte [ _NUM ] ; Map < Long , String > dic = getDictionary ( ) ; LittleEndian . putUInt ( dic . size ( ) , out ) ; int length = LittleEndianConsts . INT _ SIZE ; for ( Map . Entry < Long , String > ls : dic . entrySet ( ) ) { LittleEndian . putUInt ( ls . getKey ( ) , out ) ; length + = LittleEndianConsts . INT _ SIZE ; String value = ls . getValue ( ) + _STR ; LittleEndian . putUInt ( value . length ( ) , out ) ; length + = LittleEndianConsts . INT _ SIZE ; byte [ ] bytes = CodePageUtil . getBytesInCodePage ( value , codepage ) ; out . write ( bytes ) ; length + = bytes . length ; if ( codepage = = CodePageUtil . CP _ UNICODE ) { int pad = ( _NUM - ( length & _NUM x _NUM ) ) & _NUM x _NUM ; out . write ( padding , _NUM , pad ) ; length + = pad ; } } int pad = ( _NUM - ( length & _NUM x _NUM ) ) & _NUM x _NUM ; out . write ( padding , _NUM , pad ) ; length + = pad ; return length ; } 
2469	public void onSelectionAction ( int selectionStart , int selectionEnd , @ SelectionEvent . ActionType int action , @ Nullable TextClassification classification ) { if ( isSelectionStarted ( ) ) { mAllowReset = false ; mLogger . logSelectionAction ( selectionStart , selectionEnd , action , classification ) ; } } 
2470	public Rectangle _NUM D . Double getTextBounds ( ) { double txtPinX = _ parent . getTxtPinX ( ) ; double txtPinY = _ parent . getTxtPinY ( ) ; double txtLocPinX = _ parent . getTxtLocPinX ( ) ; double txtLocPinY = _ parent . getTxtLocPinY ( ) ; double txtWidth = _ parent . getTxtWidth ( ) ; double txtHeight = _ parent . getTxtHeight ( ) ; double x = txtPinX - txtLocPinX ; double y = txtPinY - txtLocPinY ; return new Rectangle _NUM D . Double ( x , y , txtWidth , txtHeight ) ; } 
2471	protected Object createObject ( COSBase kid ) { COSDictionary kidDic = null ; if ( kid instanceof COSDictionary ) { kidDic = ( COSDictionary ) kid ; } else if ( kid instanceof COSObject ) { COSBase base = ( ( COSObject ) kid ) . getObject ( ) ; if ( base instanceof COSDictionary ) { kidDic = ( COSDictionary ) base ; } } if ( kidDic ! = null ) { return createObjectFromDic ( kidDic ) ; } else if ( kid instanceof COSInteger ) { An integer marked - content identifier denoting a marked - content sequence COSInteger mcid = ( COSInteger ) kid ; return mcid . intValue ( ) ; } return null ; } 
2472	public static void addDataResultToIntent ( RemoteInput remoteInput , Intent intent , Map < String , Uri > results ) { Intent clipDataIntent = getClipDataIntentFromIntent ( intent ) ; if ( clipDataIntent = = null ) { First time we ' ve added a result . clipDataIntent = new Intent ( ) ; } for ( Map . Entry < String , Uri > entry : results . entrySet ( ) ) { String mimeType = entry . getKey ( ) ; Uri uri = entry . getValue ( ) ; if ( mimeType = = null ) { continue ; } Bundle resultsBundle = clipDataIntent . getBundleExtra ( getExtraResultsKeyForData ( mimeType ) ) ; if ( resultsBundle = = null ) { resultsBundle = new Bundle ( ) ; } resultsBundle . putString ( remoteInput . getResultKey ( ) , uri . toString ( ) ) ; clipDataIntent . putExtra ( getExtraResultsKeyForData ( mimeType ) , resultsBundle ) ; } intent . setClipData ( ClipData . newIntent ( RESULTS _ CLIP _ LABEL , clipDataIntent ) ) ; } 
2473	public DescribeVpnGatewaysRequest withFilters ( Filter . . . filters ) { if ( getFilters ( ) = = null ) setFilters ( new java . util . ArrayList < Filter > ( filters . length ) ) ; for ( Filter value : filters ) { getFilters ( ) . add ( value ) ; } return this ; } 
2474	private void sendCardsToPlayer ( final Player player , final List < WhiteCard > cards ) { final Map < ReturnableData , Object > data = getEventMap ( ) ; data . put ( LongPollResponse . EVENT , LongPollEvent . HAND _ DEAL . toString ( ) ) ; data . put ( LongPollResponse . HAND , getWhiteCardData ( cards ) ) ; final QueuedMessage qm = new QueuedMessage ( MessageType . GAME _ EVENT , data ) ; player . getUser ( ) . enqueueMessage ( qm ) ; } 
2475	public void testCompactNonPhoenixTable ( ) throws Exception { try ( Connection conn = getConnection ( ) ) { create a vanilla HBase table ( non - Phoenix ) String randomTable = generateUniqueName ( ) ; TableName hbaseTN = TableName . valueOf ( randomTable ) ; byte [ ] famBytes = Bytes . toBytes ( _STR ) , value ) ; hTable . put ( put ) ; hTable . flushCommits ( ) ; major compaction shouldn ' t cause a timeout or RS abort List < HRegion > regions = getUtility ( ) . getHBaseCluster ( ) . getRegions ( hbaseTN ) ; HRegion hRegion = regions . get ( _NUM ) ; hRegion . flush ( true ) ; HStore store = ( HStore ) hRegion . getStore ( famBytes ) ; store . triggerMajorCompaction ( ) ; store . compactRecentForTestingAssumingDefaultPolicy ( _NUM ) ; we should be able to compact syscat itself as well regions = getUtility ( ) . getHBaseCluster ( ) . getRegions ( TableName . valueOf ( PhoenixDatabaseMetaData . SYSTEM _ CATALOG _ NAME ) ) ; hRegion = regions . get ( _NUM ) ; hRegion . flush ( true ) ; store = ( HStore ) hRegion . getStore ( QueryConstants . DEFAULT _ COLUMN _ FAMILY _ BYTES ) ; store . triggerMajorCompaction ( ) ; store . compactRecentForTestingAssumingDefaultPolicy ( _NUM ) ; } } 
2476	protected void init ( ) throws JspException { initialize OpenCms access objects m _ controller = CmsFlexController . getController ( pageContext . getRequest ( ) ) ; m _ cms = m _ controller . getCmsObject ( ) ; try { get the resource name from the selected container m _ element = OpenCms . getADEManager ( ) . getCurrentElement ( pageContext . getRequest ( ) ) ; m _ element . initResource ( m _ cms ) ; if ( m _ locale = = null ) { no locale set , use locale from users request context m _ locale = m _ cms . getRequestContext ( ) . getLocale ( ) ; } load content and store it CmsJspContentAccessBean bean ; if ( m _ element . isInMemoryOnly ( ) & & ( m _ element . getResource ( ) instanceof CmsFile ) ) { I _ CmsXmlDocument xmlContent = CmsXmlContentFactory . unmarshal ( m _ cms , ( CmsFile ) m _ element . getResource ( ) ) ; bean = new CmsJspContentAccessBean ( m _ cms , m _ locale , xmlContent ) ; } else { bean = new CmsJspContentAccessBean ( m _ cms , m _ locale , m _ element . getResource ( ) ) ; } storeAttribute ( getVar ( ) , bean ) ; if ( m _ value ! = null ) { if the optional _STR parameter has been set , store the value map of the content in the page context scope storeAttribute ( getVal ( ) , bean . getValue ( ) ) ; } } catch ( CmsException e ) { m _ controller . setThrowable ( e , m _ cms . getRequestContext ( ) . getUri ( ) ) ; throw new JspException ( e ) ; } } 
2477	public void setSeparatorsVisible ( boolean visible ) { this . separatorsVisible = visible ; fireChangeEvent ( ) ; } 
2478	static HeapQuickSelectSketch initNewHeapInstance ( final int lgNomLongs , final long seed , final float p , final ResizeFactor rf , final boolean unionGadget ) { Choose family , preambleLongs final Family family ; final int preambleLongs ; if ( unionGadget ) { preambleLongs = Family . UNION . getMinPreLongs ( ) ; family = Family . UNION ; } else { preambleLongs = Family . QUICKSELECT . getMinPreLongs ( ) ; family = Family . QUICKSELECT ; } final HeapQuickSelectSketch hqss = new HeapQuickSelectSketch ( lgNomLongs , seed , p , rf , preambleLongs , family ) ; final int lgArrLongs = Util . startingSubMultiple ( lgNomLongs + _NUM , rf , MIN _ LG _ ARR _ LONGS ) ; hqss . lgArrLongs _ = lgArrLongs ; hqss . hashTableThreshold _ = setHashTableThreshold ( lgNomLongs , lgArrLongs ) ; hqss . curCount _ = _NUM ; hqss . thetaLong _ = ( long ) ( p * MAX _ THETA _ LONG _ AS _ DOUBLE ) ; other flags : bigEndian = readOnly = compact = ordered = false ; hqss . empty _ = true ; hqss . cache _ = new long [ _NUM < < lgArrLongs ] ; return hqss ; } 
2479	 @ GET @ Consumes ( MediaType . WILDCARD ) @ Produces ( MediaType . APPLICATION _ JSON ) @ Path ( _STR ) final String id ) { ensure we ' re running with a configurable authorizer if ( ! AuthorizerCapabilityDetection . isManagedAuthorizer ( authorizer ) ) { throw new IllegalStateException ( AccessPolicyDAO . MSG _ NON _ MANAGED _ AUTHORIZER ) ; } if ( isReplicateRequest ( ) ) { return replicate ( HttpMethod . GET ) ; } authorize access serviceFacade . authorizeAccess ( lookup - > { final Authorizable tenants = lookup . getTenant ( ) ; tenants . authorize ( authorizer , RequestAction . READ , NiFiUserUtils . getNiFiUser ( ) ) ; } ) ; get the user group final UserGroupEntity entity = serviceFacade . getUserGroup ( id ) ; populateRemainingUserGroupEntityContent ( entity ) ; return generateOkResponse ( entity ) . build ( ) ; } 
2480	public void before ( ) throws Exception { mTestDirPath = mFolder . newFolder ( ) . getAbsolutePath ( ) ; Sets up tier with one storage dir under mTestDirPath with _NUM _NUM _NUM bytes capacity . TieredBlockStoreTestUtils . setupConfWithSingleTier ( null , TEST _ TIER _ ORDINAL , TEST _ TIER _ ALIAS , new String [ ] { mTestDirPath } , TEST _ TIER _ CAPACITY _ BYTES , _STR ) ; StorageTier tier = StorageTier . newStorageTier ( TEST _ TIER _ ALIAS ) ; StorageDir dir = tier . getDir ( _NUM ) ; mTempBlockMeta = new TempBlockMeta ( TEST _ SESSION _ ID , TEST _ BLOCK _ ID , TEST _ BLOCK _ SIZE , dir ) ; } 
2481	public void setAngleGridlinePaint ( Paint paint ) { this . angleGridlinePaint = paint ; fireChangeEvent ( ) ; } 
2482	private void prepareAsync ( Collection < StreamRequest > requests , Collection < StreamSummary > summaries ) { for ( StreamRequest request : requests ) always flush on stream request addTransferRanges ( request . keyspace , request . ranges , request . columnFamilies , true ) ; for ( StreamSummary summary : summaries ) prepareReceiving ( summary ) ; PrepareSynAckMessage prepareSynAck = new PrepareSynAckMessage ( ) ; if ( ! peer . equals ( FBUtilities . getBroadcastAddressAndPort ( ) ) ) for ( StreamTransferTask task : transfers . values ( ) ) prepareSynAck . summaries . add ( task . getSummary ( ) ) ; messageSender . sendMessage ( prepareSynAck ) ; streamResult . handleSessionPrepared ( this ) ; maybeCompleted ( ) ; } 
2483	public void testTwoOfThreeNodesDecommissioned ( ) throws Exception { addNodes ( nodes ) ; for ( int i = _NUM ; i < NUM _ TEST _ ITERS ; i + + ) { doTestTwoOfThreeNodesDecommissioned ( i ) ; } } 
2484	public static OfbizUrlBuilder from ( WebappInfo webAppInfo , Delegator delegator ) throws WebAppConfigurationException , IOException , SAXException , GenericEntityException { WebSiteProperties webSiteProps = null ; ControllerConfig config = null ; String servletPath = null ; if ( webAppInfo ! = null ) { Assert . notNull ( _STR , webSiteId ) . cache ( ) . queryOne ( ) ; if ( webSiteValue ! = null ) { webSiteProps = WebSiteProperties . from ( webSiteValue ) ; } } config = ConfigXMLReader . getControllerConfig ( webAppInfo ) ; servletPath = WebAppUtil . getControlServletPath ( webAppInfo ) ; } if ( webSiteProps = = null ) { webSiteProps = WebSiteProperties . defaults ( delegator ) ; } return new OfbizUrlBuilder ( config , webSiteProps , servletPath ) ; } 
2485	public boolean verifyClientEvidenceMessage ( BigInteger clientM _NUM ) throws CryptoException { Verify pre - requirements if ( this . A = = null | | this . B = = null | | this . S = = null ) { throw new CryptoException ( _STR ) ; } Compute the own client evidence message ' M _NUM ' BigInteger computedM _NUM = SRP _NUM Util . calculateM _NUM ( digest , N , A , B , S ) ; if ( computedM _NUM . equals ( clientM _NUM ) ) { this . M _NUM = clientM _NUM ; return true ; } return false ; } 
2486	private CalciteAssert . AssertQuery wikiApprox ( String sql ) { return approxQuery ( WIKI , sql ) ; } 
2487	public boolean isDatanodeUp ( ) { for ( BPOfferService bp : blockPoolManager . getAllNamenodeThreads ( ) ) { if ( bp . isAlive ( ) ) { return true ; } } return false ; } 
2488	public void validatePolicyWithInvalidPolicyUpdate ( ) throws Exception { Policy policy = createPolicy ( ) ; policy . setPolicyUpdate ( new UpdateParameter ( ) ) ; assertFalse ( policy . validate ( ) ) ; } 
2489	public List < JSONObject > getArticlesRandomly ( final int fetchSize ) throws ServiceException { try { final List < JSONObject > ret = articleRepository . getRandomly ( fetchSize ) ; removeUnusedProperties ( ret ) ; return ret ; } catch ( final RepositoryException e ) { LOGGER . log ( Level . ERROR , _STR , e ) ; throw new ServiceException ( e ) ; } } 
2490	public void setClass ( final Class < ? > clazz ) { if ( sampleLists = = null ) { sampleLists = sketch _ . getSamplesAsArrays ( clazz ) ; } } 
2491	public void runListClassesTest ( int depth , int NS , int NI , boolean withProps ) { createTest ( depth , NS , NI , withProps ) ; long t = list ( null , RDF . type . asNode ( ) , RDFS . Class . asNode ( ) , false ) ; System . out . println ( _STR ) ; } 
2492	public void overwrite ( File aFile , long position ) throws IOException { if ( aFile . length ( ) > _NUM L & & position < length ( ) ) overwriteInternal ( new Range ( position , aFile , true ) ) ; } 
2493	public Object clone ( ) throws CloneNotSupportedException { final HashNMap map = ( HashNMap ) super . clone ( ) ; map . table = new HashMap ( ) ; final Iterator iterator = keys ( ) ; while ( iterator . hasNext ( ) ) { final Object key = iterator . next ( ) ; final List list = ( List ) map . table . get ( key ) ; if ( list ! = null ) { map . table . put ( key , ObjectUtilities . clone ( list ) ) ; } } return map ; } 
2494	public DomainSocket accept ( ) throws IOException { refCount . reference ( ) ; boolean exc = true ; try { DomainSocket ret = new DomainSocket ( path , accept _NUM ( fd ) ) ; exc = false ; return ret ; } finally { unreference ( exc ) ; } } 
2495	public boolean awaitJoined ( long timeout , TimeUnit timeUnit ) throws InterruptedException { joinedCondition . await ( timeout , timeUnit ) ; return joinedCondition . isJoined ( ) ; } 
2496	void updateScrollPosition ( int offsetX , int offsetY ) { int verticalContentLength = mRecyclerView . computeVerticalScrollRange ( ) ; int verticalVisibleLength = mRecyclerViewHeight ; mNeedVerticalScrollbar = verticalContentLength - verticalVisibleLength > _NUM & & mRecyclerViewHeight > = mScrollbarMinimumRange ; int horizontalContentLength = mRecyclerView . computeHorizontalScrollRange ( ) ; int horizontalVisibleLength = mRecyclerViewWidth ; mNeedHorizontalScrollbar = horizontalContentLength - horizontalVisibleLength > _NUM & & mRecyclerViewWidth > = mScrollbarMinimumRange ; if ( ! mNeedVerticalScrollbar & & ! mNeedHorizontalScrollbar ) { if ( mState ! = STATE _ HIDDEN ) { setState ( STATE _ HIDDEN ) ; } return ; } if ( mNeedVerticalScrollbar ) { float middleScreenPos = offsetY + verticalVisibleLength / _NUM . _NUM f ; mVerticalThumbCenterY = ( int ) ( ( verticalVisibleLength * middleScreenPos ) / verticalContentLength ) ; mVerticalThumbHeight = Math . min ( verticalVisibleLength , ( verticalVisibleLength * verticalVisibleLength ) / verticalContentLength ) ; } if ( mNeedHorizontalScrollbar ) { float middleScreenPos = offsetX + horizontalVisibleLength / _NUM . _NUM f ; mHorizontalThumbCenterX = ( int ) ( ( horizontalVisibleLength * middleScreenPos ) / horizontalContentLength ) ; mHorizontalThumbWidth = Math . min ( horizontalVisibleLength , ( horizontalVisibleLength * horizontalVisibleLength ) / horizontalContentLength ) ; } if ( mState = = STATE _ HIDDEN | | mState = = STATE _ VISIBLE ) { setState ( STATE _ VISIBLE ) ; } } 
2497	private void freePage ( ) { final int p = usedPages . nextFree ( _NUM ) ; usedPages . set ( p ) ; read ( p ) ; + + used ; + + page ; } 
2498	private static void updateStyles ( List < HSLFTextParagraph > paragraphs ) { final String rawText = toInternalString ( getRawText ( paragraphs ) ) ; TextHeaderAtom headerAtom = paragraphs . get ( _NUM ) . _ headerAtom ; StyleTextPropAtom styleAtom = findStyleAtomPresent ( headerAtom , rawText . length ( ) ) ; Update the text length for its Paragraph and Character stylings * reset the length , to the new string ' s length * add on + _NUM if the last block styleAtom . clearStyles ( ) ; TextPropCollection lastPTPC = null , lastRTPC = null , ptpc = null , rtpc = null ; for ( HSLFTextParagraph para : paragraphs ) { ptpc = para . getParagraphStyle ( ) ; ptpc . updateTextSize ( _NUM ) ; if ( ! ptpc . equals ( lastPTPC ) ) { lastPTPC = styleAtom . addParagraphTextPropCollection ( _NUM ) ; lastPTPC . copy ( ptpc ) ; } for ( HSLFTextRun tr : para . getTextRuns ( ) ) { rtpc = tr . getCharacterStyle ( ) ; rtpc . updateTextSize ( _NUM ) ; if ( ! rtpc . equals ( lastRTPC ) ) { lastRTPC = styleAtom . addCharacterTextPropCollection ( _NUM ) ; lastRTPC . copy ( rtpc ) ; } int len = tr . getLength ( ) ; ptpc . updateTextSize ( ptpc . getCharactersCovered ( ) + len ) ; rtpc . updateTextSize ( len ) ; lastPTPC . updateTextSize ( lastPTPC . getCharactersCovered ( ) + len ) ; lastRTPC . updateTextSize ( lastRTPC . getCharactersCovered ( ) + len ) ; } } if ( lastPTPC = = null | | lastRTPC = = null | | ptpc = = null | | rtpc = = null ) { NOSONAR throw new HSLFException ( _STR ) ; } ptpc . updateTextSize ( ptpc . getCharactersCovered ( ) + _NUM ) ; rtpc . updateTextSize ( rtpc . getCharactersCovered ( ) + _NUM ) ; lastPTPC . updateTextSize ( lastPTPC . getCharactersCovered ( ) + _NUM ) ; lastRTPC . updateTextSize ( lastRTPC . getCharactersCovered ( ) + _NUM ) ; for ( Record r : paragraphs . get ( _NUM ) . getRecords ( ) ) { if ( r instanceof TextSpecInfoAtom ) { ( ( TextSpecInfoAtom ) r ) . setParentSize ( rawText . length ( ) + _NUM ) ; break ; } } } 
2499	public void set ( String string ) { if ( string . length ( ) > _NUM xffff / _NUM ) { maybe too long LOG . warn ( _STR ) ; if ( grow buffer bytes = = null | | length > bytes . length ) bytes = new byte [ length ] ; try { avoid sync ' d allocations DataOutputBuffer obuf = OBUF _ FACTORY . get ( ) ; obuf . reset ( ) ; writeChars ( obuf , string , _NUM , string . length ( ) ) ; System . arraycopy ( obuf . getData ( ) , _NUM , bytes , _NUM , length ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } 
2500	public String getValue ( ArgDecl argDecl ) { Arg arg = getArg ( argDecl ) ; if ( arg = = null ) return null ; if ( arg . hasValue ( ) ) return arg . getValue ( ) ; return null ; } 
2501	public float floatValue ( ) { return toFloat ( mValue ) ; } 
2502	protected E pollProducer ( Object producer ) { synchronized ( lock ) { ProducerList < E > tList = this . producerMap . get ( producer ) ; if ( tList ! = null & & ! tList . list . isEmpty ( ) ) { E element = tList . list . removeFirst ( ) ; this . size - - ; if ( tList . list . isEmpty ( ) ) { this . producerLists . remove ( tList ) ; this . producerMap . remove ( tList . producer ) ; we need to adjust the current thread pointer in case it pointed to this thread list , which is now removed adjustCurrentProducerPointer ( ) ; } lock . notifyAll ( ) ; assert element ! = null ; round - robin part alone and just return the work return element ; } } return null ; } 
2503	private void testTC _NUM ( boolean appendToNewBlock ) throws Exception { final short repl = _NUM ; final Path p = new Path ( _STR . Append a new block worth of data . Close file . final int len _NUM = ( int ) BLOCK _ SIZE ; { FSDataOutputStream out = appendToNewBlock ? fs . append ( p , EnumSet . of ( CreateFlag . APPEND , CreateFlag . NEW _ BLOCK ) , _NUM _NUM _NUM _NUM , null ) : fs . append ( p ) ; AppendTestUtil . write ( out , len _NUM , len _NUM ) ; out . close ( ) ; } d . Reopen file and read two blocks worth of data . AppendTestUtil . check ( fs , p , len _NUM + len _NUM ) ; } 
2504	public void testSmallBATConstructor ( ) throws IOException { need to create an array of raw blocks containing the SBAT , and a small document block list String [ ] sbat _ data = { _STR ) ; } catch ( IOException ignored ) { expected during successful test } } } } 
2505	public void skipOptionalCall ( ) throws IOException { int tag = read ( ) ; if ( tag = = ' c ' ) { read ( ) ; read ( ) ; } else _ peek = tag ; } 
2506	public static String getLastXpathElement ( String path ) { int pos = path . lastIndexOf ( ' / ' ) ; if ( pos > = _NUM ) { path = path . substring ( pos + _NUM ) ; } return CmsXmlUtils . removeXpathIndex ( path ) ; } 
2507	protected Collection < String > getModifiedParents ( ModeledAuthenticatedUser user , String identifier , ModelType model ) throws GuacamoleException { Get old parent identifier String oldParentIdentifier = null ; if ( identifier ! = null ) { ModelType current = retrieveObject ( user , identifier ) . getModel ( ) ; oldParentIdentifier = current . getParentIdentifier ( ) ; } Get new parent identifier String parentIdentifier = null ; if ( model ! = null ) { parentIdentifier = model . getParentIdentifier ( ) ; If both parents have the same identifier , nothing has changed if ( parentIdentifier ! = null & & parentIdentifier . equals ( oldParentIdentifier ) ) return Collections . < String > emptyList ( ) ; } Return collection of all non - root parents involved Collection < String > parents = new ArrayList < String > ( _NUM ) ; if ( oldParentIdentifier ! = null ) parents . add ( oldParentIdentifier ) ; if ( parentIdentifier ! = null ) parents . add ( parentIdentifier ) ; return parents ; } 
2508	public void changeProperty ( Path propFilePath , String key , String value ) throws IOException { Files . createDirectories ( dirPath . resolve ( propFilePath ) . getParent ( ) ) ; writePropertyToFile ( propFilePath , key , value ) ; } 
2509	public static void writeFile ( byte [ ] [ ] buffer , String fileToBeSaved ) throws TikaException { FileOutputStream output = null ; if ( buffer ! = null & & fileToBeSaved ! = null & & ! ChmCommons . isEmpty ( fileToBeSaved ) ) { try { output = new FileOutputStream ( fileToBeSaved ) ; for ( byte [ ] bufferEntry : buffer ) { output . write ( bufferEntry ) ; } } catch ( FileNotFoundException e ) { throw new TikaException ( e . getMessage ( ) ) ; } catch ( IOException e ) { LOG . warn ( _STR , e ) ; } } } } 
2510	 < T > void verifyDenied ( User user , Class < T > exception , TableDDLPermissionsIT . AccessTestAction . . . actions ) throws Exception { for ( TableDDLPermissionsIT . AccessTestAction action : actions ) { try { user . runAs ( action ) ; fail ( _STR ) ; } } 
2511	private boolean pinCamera ( int userHandle ) { ApplicationInfo cameraInfo = getCameraInfo ( userHandle ) ; if ( cameraInfo = = null ) { return false ; } unpin after checking that the camera intent has resolved this prevents us from thrashing when switching users with FBE enabled , because the intent won ' t resolve until the unlock unpinCameraApp ( ) ; pin APK String camAPK = cameraInfo . sourceDir ; PinnedFile pf = pinFile ( camAPK , _NUM , _NUM , MAX _ CAMERA _ PIN _ SIZE ) ; if ( pf = = null ) { Slog . e ( TAG , _STR + pf . mFilename ) ; } } } return true ; } 
2512	protected static List < JsonAggregation > computeDruidJsonAgg ( List < AggregateCall > aggCalls , List < String > aggNames , @ Nullable Project project , DruidQuery druidQuery ) { final List < JsonAggregation > aggregations = new ArrayList < > ( ) ; for ( Pair < AggregateCall , String > agg : Pair . zip ( aggCalls , aggNames ) ) { final String fieldName ; final String expression ; final AggregateCall aggCall = agg . left ; final RexNode filterNode ; Type check First final RelDataType type = aggCall . getType ( ) ; final SqlTypeName sqlTypeName = type . getSqlTypeName ( ) ; final boolean isNotAcceptedType ; if ( SqlTypeFamily . APPROXIMATE _ NUMERIC . getTypeNames ( ) . contains ( sqlTypeName ) | | SqlTypeFamily . INTEGER . getTypeNames ( ) . contains ( sqlTypeName ) ) { isNotAcceptedType = false ; } else if ( SqlTypeFamily . EXACT _ NUMERIC . getTypeNames ( ) . contains ( sqlTypeName ) & & ( type . getScale ( ) = = _NUM | | druidQuery . getConnectionConfig ( ) . approximateDecimal ( ) ) ) { Decimal , If scale is zero or we allow approximating decimal , we can proceed isNotAcceptedType = false ; } else { isNotAcceptedType = true ; } if ( isNotAcceptedType ) { return null ; } Extract filters if ( project ! = null & & aggCall . hasFilter ( ) ) { filterNode = project . getProjects ( ) . get ( aggCall . filterArg ) ; } else { filterNode = null ; } if ( aggCall . getArgList ( ) . size ( ) = = _NUM ) { fieldName = null ; expression = null ; } else { int index = Iterables . getOnlyElement ( aggCall . getArgList ( ) ) ; if ( project = = null ) { fieldName = druidQuery . table . getRowType ( ) . getFieldNames ( ) . get ( index ) ; expression = null ; } else { final RexNode rexNode = project . getProjects ( ) . get ( index ) ; final RelDataType inputRowType = project . getInput ( ) . getRowType ( ) ; if ( rexNode . isA ( SqlKind . INPUT _ REF ) ) { expression = null ; fieldName = extractColumnName ( rexNode , inputRowType , druidQuery ) ; } else { expression = DruidExpressions . toDruidExpression ( rexNode , inputRowType , druidQuery ) ; if ( Strings . isNullOrEmpty ( expression ) ) { return null ; } fieldName = null ; } } One should be not null and the other should be null . assert expression = = null ^ fieldName = = null ; } final JsonAggregation jsonAggregation = getJsonAggregation ( agg . right , agg . left , filterNode , fieldName , expression , druidQuery ) ; if ( jsonAggregation = = null ) { return null ; } aggregations . add ( jsonAggregation ) ; } return aggregations ; } 
2513	public void removeRemoteInput ( NotificationData . Entry entry , Object token ) { Preconditions . checkNotNull ( entry ) ; pruneWeakThenRemoveAndContains ( null , entry , token ) ; apply ( entry ) ; } 
2514	public void flingCapturedView ( int minLeft , int minTop , int maxLeft , int maxTop ) { if ( ! mReleaseInProgress ) { throw new IllegalStateException ( _STR ) ; } mScroller . fling ( mCapturedView . getLeft ( ) , mCapturedView . getTop ( ) , ( int ) VelocityTrackerCompat . getXVelocity ( mVelocityTracker , mActivePointerId ) , ( int ) VelocityTrackerCompat . getYVelocity ( mVelocityTracker , mActivePointerId ) , minLeft , maxLeft , minTop , maxTop ) ; setDragState ( STATE _ SETTLING ) ; } 
2515	public byte [ ] findObjectsByPrefix ( SwiftObjectPath path , final Header . . . requestHeaders ) throws IOException { preRemoteCommand ( _STR + method . getURI ( ) ) ; } return method . getResponseBody ( ) ; } @ Override protected int [ ] getAllowedStatusCodes ( ) { return new int [ ] { SC _ OK , SC _ NOT _ FOUND } ; } @ Override protected void setup ( GetMethod method ) throws SwiftInternalStateException { setHeaders ( method , requestHeaders ) ; } } ) ; } 
2516	public DataValue getDataForRule ( Scenario scenario , Column phxMetaColumn ) throws Exception { TODO Make a Set of Rules that have already been applied so that so we don ' t generate for every value List < Scenario > scenarios = parser . getScenarios ( ) ; DataValue value = null ; if ( scenarios . contains ( scenario ) ) { logger . debug ( _STR + phxMetaColumn . getType ( ) ) ; } } return value ; } 
2517	public void parseFromLocalFileData ( byte [ ] data , int offset , int length ) throws ZipException { long givenChecksum = ZipLong . getValue ( data , offset ) ; byte [ ] tmp = new byte [ length - WORD ] ; System . arraycopy ( data , offset + WORD , tmp , _NUM , length - WORD ) ; crc . reset ( ) ; crc . update ( tmp ) ; long realChecksum = crc . getValue ( ) ; if ( givenChecksum ! = realChecksum ) { throw new ZipException ( _STR ; } else { System . arraycopy ( tmp , _NUM _NUM , linkArray , _NUM , linkArray . length ) ; Uses default charset - see class Javadoc link = new String ( linkArray ) ; } CheckStyle : MagicNumber ON setDirectory ( ( newMode & DIR _ FLAG ) ! = _NUM ) ; setMode ( newMode ) ; } 
2518	public void onConfigurationChanged ( Configuration newConfig ) { Reload drawables that can change with configuration mThemeImage = getThemeUpIndicator ( ) ; mDrawerImage = mActivity . getResources ( ) . getDrawable ( mDrawerImageResource ) ; syncState ( ) ; } 
2519	public void testConnect ( ) throws Exception { Class . forName ( _STR ) ; connection . close ( ) ; } 
2520	public static < T > boolean isSorted ( final T [ ] array , final Comparator < T > comparator ) { if ( comparator = = null ) { throw new IllegalArgumentException ( _STR ) ; } if ( array = = null | | array . length < _NUM ) { return true ; } T previous = array [ _NUM ] ; final int n = array . length ; for ( int i = _NUM ; i < n ; i + + ) { final T current = array [ i ] ; if ( comparator . compare ( previous , current ) > _NUM ) { return false ; } previous = current ; } return true ; } 
2521	public void moveTextWithLeading ( float x , float y ) { state . xTLM + = x ; state . yTLM + = y ; state . leading = - y ; content . append ( x ) . append ( ' ' ) . append ( y ) . append ( _STR ) . append _ i ( separator ) ; } 
2522	public void unpairAll ( BluetoothAdapter adapter ) { Set < BluetoothDevice > devices = adapter . getBondedDevices ( ) ; for ( BluetoothDevice device : devices ) { unpair ( adapter , device ) ; } } 
2523	public boolean getObjectProtect ( ) { return getProtectionBlock ( ) . isObjectProtected ( ) ; } 
2524	public void uncompressTags ( InputStream src , byte [ ] dest , int offset , int length ) throws IOException { int endOffset = offset + length ; while ( offset < endOffset ) { byte status = ( byte ) src . read ( ) ; if ( status = = Dictionary . NOT _ IN _ DICTIONARY ) { int tagLen = StreamUtils . readRawVarint _NUM _NUM ( src ) ; offset = Bytes . putAsShort ( dest , offset , tagLen ) ; IOUtils . readFully ( src , dest , offset , tagLen ) ; tagDict . addEntry ( dest , offset , tagLen ) ; offset + = tagLen ; } else { short dictIdx = StreamUtils . toShort ( status , ( byte ) src . read ( ) ) ; byte [ ] entry = tagDict . getEntry ( dictIdx ) ; if ( entry = = null ) { throw new IOException ( _STR + dictIdx ) ; } offset = Bytes . putAsShort ( dest , offset , entry . length ) ; System . arraycopy ( entry , _NUM , dest , offset , entry . length ) ; offset + = entry . length ; } } } 
2525	private void processGeneralOptions ( Configuration conf , CommandLine line ) throws IOException { if ( line . hasOption ( _STR ) ; } } 
2526	private void preemptiveSync ( final ProtobufLogWriter nextWriter ) { long startTimeNanos = System . nanoTime ( ) ; try { nextWriter . sync ( useHsync ) ; postSync ( System . nanoTime ( ) - startTimeNanos , _NUM ) ; } catch ( IOException e ) { optimization failed , no need to abort here . LOG . warn ( _STR , e ) ; } } 
2527	private static void dumpSetting ( @ NonNull SettingsState settings , @ NonNull ProtoOutputStream proto , String settingName , long fieldId ) { SettingsState . Setting setting = settings . getSettingLocked ( settingName ) ; long settingsToken = proto . start ( fieldId ) ; proto . write ( SettingProto . ID , setting . getId ( ) ) ; proto . write ( SettingProto . NAME , settingName ) ; if ( setting . getPackageName ( ) ! = null ) { proto . write ( SettingProto . PKG , setting . getPackageName ( ) ) ; } proto . write ( SettingProto . VALUE , setting . getValue ( ) ) ; if ( setting . getDefaultValue ( ) ! = null ) { proto . write ( SettingProto . DEFAULT _ VALUE , setting . getDefaultValue ( ) ) ; proto . write ( SettingProto . DEFAULT _ FROM _ SYSTEM , setting . isDefaultFromSystem ( ) ) ; } proto . end ( settingsToken ) ; } 
2528	public final void writeSerializable ( Serializable s ) { if ( s = = null ) { writeString ( null ) ; return ; } String name = s . getClass ( ) . getName ( ) ; writeString ( name ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; try { ObjectOutputStream oos = new ObjectOutputStream ( baos ) ; oos . writeObject ( s ) ; oos . close ( ) ; writeByteArray ( baos . toByteArray ( ) ) ; } catch ( IOException ioe ) { throw new RuntimeException ( _STR , ioe ) ; } } 
2529	public void removeReference ( final PortAndAssignment pna ) { if ( references . remove ( pna ) = = null ) { LOG . warn ( _STR , pna , blobDescription ) ; } touch ( ) ; } 
2530	public byte [ ] asByteArray ( ) throws IOException { return IOs . readAsByteArray ( is ) ; } 
2531	public double getProbability ( double data , double given ) { return getEstimator ( given ) . getProbability ( data ) ; } 
2532	public static byte [ ] writeToByteArrayWithSize ( Writable writableObject , byte [ ] buffer , boolean unsafe ) { ExtendedDataOutput extendedDataOutput ; if ( unsafe ) { extendedDataOutput = new UnsafeByteArrayOutputStream ( buffer ) ; } else { extendedDataOutput = new ExtendedByteArrayDataOutput ( buffer ) ; } try { extendedDataOutput . writeInt ( - _NUM ) ; writableObject . write ( extendedDataOutput ) ; extendedDataOutput . writeInt ( _NUM , extendedDataOutput . getPos ( ) ) ; } catch ( IOException e ) { throw new IllegalStateException ( _STR , e ) ; } return extendedDataOutput . getByteArray ( ) ; } 
2533	protected void populateDatasets ( ) throws IOException { this . datasets = this . datasetFinder . findDatasets ( ) ; sortHiveDatasets ( datasets ) ; } 
2534	private boolean checkItemPlacement ( LongArrayMap < GridOccupancy > occupied , ItemInfo item , ArrayList < Long > workspaceScreens ) { LauncherAppState app = LauncherAppState . getInstance ( ) ; InvariantDeviceProfile profile = app . getInvariantDeviceProfile ( ) ; long containerIndex = item . screenId ; if ( item . container = = LauncherSettings . Favorites . CONTAINER _ HOTSEAT ) { Return early if we detect that an item is under the hotseat button if ( ! FeatureFlags . NO _ ALL _ APPS _ ICON & & profile . isAllAppsButtonRank ( ( int ) item . screenId ) ) { Log . e ( TAG , _STR ) ; return false ; } } 
2535	public static List < PathElement > parseDotNotationRHS ( String dotNotation ) { String fixedNotation = fixLeadingBracketSugar ( dotNotation ) ; List < String > pathStrs = parseDotNotation ( new LinkedList < String > ( ) , stringIterator ( fixedNotation ) , dotNotation ) ; return parseList ( pathStrs , dotNotation ) ; } 
2536	private List < Integer > calculateColumnsMax ( ) { List < Integer > width = new ArrayList < > ( ) ; for ( int i = _NUM ; i < title . size ( ) ; i + + ) { width . add ( title . getCell ( i ) . getLength ( ) ) ; } for ( Row row : rows ) { for ( int i = _NUM ; i < row . size ( ) ; i + + ) { width . set ( i , Math . max ( width . get ( i ) , row . getCell ( i ) . getLength ( ) ) ) ; } } return width ; } 
2537	public static void execHttpPut ( String url , HttpEntity entity , HttpClient httpClient , HttpContext httpContext ) { String requestURI = determineRequestURI ( url ) ; HttpPut httpput = new HttpPut ( requestURI ) ; httpput . setEntity ( entity ) ; exec ( url , httpput , null , nullHandler , httpClient , httpContext ) ; } 
2538	public void testGetBindAddress ( ) throws Exception { for ( ServiceType service : ServiceType . values ( ) ) { getBindAddress ( service ) ; } } 
2539	public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( _STR ) ; return sb . toString ( ) ; } 
2540	protected final double toDouble ( final Item item ) throws QueryException { if ( checkNoEmpty ( item , AtomType . DBL ) . type . isNumberOrUntyped ( ) ) return item . dbl ( info ) ; throw numberError ( this , item ) ; } 
2541	private void createCombo ( final StringList sl ) { if ( sl = = null | | sl . isEmpty ( ) ) { popup . setVisible ( false ) ; return ; } if ( completionsChanged ( sl ) ) { completions . setItems ( sl . toArray ( ) ) ; completions . setSelectedIndex ( - _NUM ) ; popup = new GUIInputPopup ( completions ) ; } final int w = getFontMetrics ( getFont ( ) ) . stringWidth ( pre ) ; popup . show ( this , Math . min ( getWidth ( ) , w ) , getHeight ( ) ) ; } 
2542	public void testReadWriteTokenValueBytes ( ) { ArrayPtg ptg = create ( ENCODED _ PTG _ DATA , ENCODED _ CONSTANT _ DATA ) ; assertEquals ( _NUM , ptg . getColumnCount ( ) ) ; assertEquals ( _NUM , ptg . getRowCount ( ) ) ; Object [ ] [ ] values = ptg . getTokenArrayValues ( ) ; assertEquals ( _NUM , values . length ) ; assertEquals ( Boolean . TRUE , values [ _NUM ] [ _NUM ] ) ; assertEquals ( _STR ) ; } assertArrayEquals ( ENCODED _ CONSTANT _ DATA , outBuf ) ; } 
2543	static void inplaceModPow _NUM ( TBigInteger x , int n ) { PRE : ( x > _NUM ) and ( n > = _NUM ) int fd = n > > _NUM ; int leadingZeros ; if ( ( x . numberLength < fd ) | | ( x . bitLength ( ) < = n ) ) { return ; } leadingZeros = _NUM _NUM - ( n & _NUM _NUM ) ; x . numberLength = fd + _NUM ; x . digits [ fd ] & = ( leadingZeros < _NUM _NUM ) ? ( - _NUM > > > leadingZeros ) : _NUM ; x . cutOffLeadingZeroes ( ) ; } 
2544	String findJavaType ( SchemaType sType ) { while ( sType . getFullJavaName ( ) = = null ) sType = sType . getBaseType ( ) ; return sType . getFullJavaName ( ) ; } 
2545	public int getLineBounds ( int line , Rect bounds ) { if ( bounds ! = null ) { ? ? ? bounds . left = _NUM ; bounds . top = getLineTop ( line ) ; ? ? ? bounds . right = mWidth ; bounds . bottom = getLineTop ( line + _NUM ) ; } return getLineBaseline ( line ) ; } 
2546	public void zipit ( String outString , String name ) throws Exception { File saveFile ; ZipEntry ze ; if ( m _ zipOut = = null ) { saveFile = new File ( m _ destination , name + _STR ) ; DataOutputStream dout = new DataOutputStream ( new GZIPOutputStream ( new FileOutputStream ( saveFile ) ) ) ; dout . writeBytes ( outString ) ; dout . close ( ) ; } else { ze = new ZipEntry ( name ) ; m _ zs . putNextEntry ( ze ) ; m _ zipOut . writeBytes ( outString ) ; m _ zs . closeEntry ( ) ; } } 
2547	is got from https : String wrap ( String s ) { StringBuilder buffer = new StringBuilder ( ) ; String delim = _STR , true ) ) ; } return buffer . toString ( ) ; } 
2548	public CameraDeviceImpl . StateCallbackKK getDeviceStateCallback ( ) { final CameraCaptureSession session = this ; final Object interfaceLock = mDeviceImpl . mInterfaceLock ; return new CameraDeviceImpl . StateCallbackKK ( ) { private boolean mBusy = false ; private boolean mActive = false ; @ Override public void onOpened ( CameraDevice camera ) { throw new AssertionError ( _STR ) ; mStateCallback . onSurfacePrepared ( session , surface ) ; } } ; } 
2549	 @ POST @ Consumes ( MediaType . APPLICATION _ JSON ) @ Produces ( MediaType . APPLICATION _ JSON ) @ Path ( _STR ) ; } if ( isReplicateRequest ( ) ) { return replicate ( HttpMethod . POST , requestCreateTemplateRequestEntity ) ; } return withWriteLock ( serviceFacade , requestCreateTemplateRequestEntity , lookup - > { authorizeSnippetUsage ( lookup , groupId , requestCreateTemplateRequestEntity . getSnippetId ( ) , true ) ; } , ( ) - > serviceFacade . verifyCanAddTemplate ( groupId , requestCreateTemplateRequestEntity . getName ( ) ) , createTemplateRequestEntity - > { create the template and generate the json final TemplateDTO template = serviceFacade . createTemplate ( createTemplateRequestEntity . getName ( ) , createTemplateRequestEntity . getDescription ( ) , createTemplateRequestEntity . getSnippetId ( ) , groupId , getIdGenerationSeed ( ) ) ; templateResource . populateRemainingTemplateContent ( template ) ; build the response entity final TemplateEntity entity = new TemplateEntity ( ) ; entity . setTemplate ( template ) ; build the response return generateCreatedResponse ( URI . create ( template . getUri ( ) ) , entity ) . build ( ) ; } ) ; } 
2550	public static Marshaller marshaller ( Class < ? > clazz ) { Marshaller m = createMarshallerForClass ( clazz ) ; setPropertySafely ( m , JAXB _ FORMATTED _ OUTPUT , true ) ; setPropertySafely ( m , JAXB _ ENCODING , StandardCharsets . UTF _ _NUM . toString ( ) ) ; return m ; } 
2551	public LocaleList getLocales ( ) { fixUpLocaleList ( ) ; return mLocaleList ; } 
2552	public boolean commit ( ) throws Exception { try { if ( checkDataQuality ( this . convertedSchema ) ) { Commit data if all quality checkers pass . Again , not to catch the exception it may throw so the exception gets propagated to the caller of this method . this . logger . info ( String . format ( _STR , this . index , this . taskId ) , t ) ; this . forkState . set ( ForkState . FAILED ) ; Throwables . propagate ( t ) ; return false ; } } 
2553	public void toFilesRename _ AllowOverwrite _ SingleFile _ OutputFileExists ( ) throws IOException { set up File sourceFile = new File ( _STR ) ; File fileThatExists = makeRenamedFile ( originalFile , rename ) ; copy the image to a temporary file . TestUtils . copyFile ( sourceFile , originalFile ) ; TestUtils . copyFile ( sourceFile , fileThatExists ) ; given when Thumbnails . of ( originalFile ) . size ( _NUM _NUM _NUM , _NUM _NUM _NUM ) . allowOverwrite ( true ) . toFiles ( rename ) ; then assertTrue ( fileThatExists . exists ( ) ) ; assertFalse ( sourceFile . length ( ) = = fileThatExists . length ( ) ) ; clean up originalFile . delete ( ) ; fileThatExists . delete ( ) ; } 
2554	public void acceptInstance ( InstanceEvent e ) { to do ! if ( m _ filterThread ! = null ) { String messg = _STR ) ; } ex . printStackTrace ( ) ; } } } 
2555	public SampleSubsetSummary estimateSubsetSum ( final Predicate < T > predicate ) { if ( itemsSeen _ = = _NUM ) { return new SampleSubsetSummary ( _NUM . _NUM , _NUM . _NUM , _NUM . _NUM , _NUM . _NUM ) ; } final long numSamples = getNumSamples ( ) ; final double samplingRate = numSamples / ( double ) itemsSeen _ ; assert samplingRate > = _NUM . _NUM ; assert samplingRate < = _NUM . _NUM ; int trueCount = _NUM ; for ( int i = _NUM ; i < numSamples ; + + i ) { if ( predicate . test ( data _ . get ( i ) ) ) { + + trueCount ; } } if in exact mode , we can return an exact answer if ( itemsSeen _ < = reservoirSize _ ) { return new SampleSubsetSummary ( trueCount , trueCount , trueCount , numSamples ) ; } final double lbTrueFraction = pseudoHypergeometricLBonP ( numSamples , trueCount , samplingRate ) ; final double estimatedTrueFraction = ( _NUM . _NUM * trueCount ) / numSamples ; final double ubTrueFraction = pseudoHypergeometricUBonP ( numSamples , trueCount , samplingRate ) ; return new SampleSubsetSummary ( itemsSeen _ * lbTrueFraction , itemsSeen _ * estimatedTrueFraction , itemsSeen _ * ubTrueFraction , itemsSeen _ ) ; } 
2556	public List < LanguageResult > detectAll ( String text ) { reset ( ) ; addText ( text ) ; return detectAll ( ) ; } 
2557	public void setFacingDirection ( BlockFace face ) { byte data = ( byte ) ( getData ( ) & _NUM x _NUM ) ; BlockFace attach = getAttachedFace ( ) ; if ( attach = = BlockFace . DOWN ) { switch ( face ) { case SOUTH : case NORTH : data | = _NUM x _NUM ; break ; case EAST : case WEST : data | = _NUM x _NUM ; break ; } } else if ( attach = = BlockFace . UP ) { switch ( face ) { case SOUTH : case NORTH : data | = _NUM x _NUM ; break ; case EAST : case WEST : data | = _NUM x _NUM ; break ; } } else { switch ( face ) { case EAST : data | = _NUM x _NUM ; break ; case WEST : data | = _NUM x _NUM ; break ; case SOUTH : data | = _NUM x _NUM ; break ; case NORTH : data | = _NUM x _NUM ; break ; } } setData ( data ) ; } 
2558	public static Future < ? > setFlattredStatus ( final List < Flattr > flattrList ) { Log . d ( TAG , _STR ) ; clear flattr status in db clearAllFlattrStatus ( ) ; submit list with flattred things having normalized URLs to db return dbExec . submit ( ( ) - > { PodDBAdapter adapter = PodDBAdapter . getInstance ( ) ; adapter . open ( ) ; for ( Flattr flattr : flattrList ) { adapter . setItemFlattrStatus ( formatURIForQuery ( flattr . getThing ( ) . getUrl ( ) ) , new FlattrStatus ( flattr . getCreated ( ) . getTime ( ) ) ) ; } adapter . close ( ) ; } ) ; } 
2559	public void propertyChange ( PropertyChangeEvent evt ) { updateText ( ) ; } 
2560	protected void internalUpdateUserInfo ( CmsDbContext dbc , CmsUUID userId , String key , Object value ) throws CmsDataAccessException { try { Query q = m _ sqlManager . createQuery ( dbc , C _ USERDATA _ UPDATE _ _NUM ) ; write data to database q . setParameter ( _NUM , CmsDataTypeUtil . dataSerialize ( value ) ) ; q . setParameter ( _NUM , value . getClass ( ) . getName ( ) ) ; q . setParameter ( _NUM , userId . toString ( ) ) ; q . setParameter ( _NUM , key ) ; q . executeUpdate ( ) ; } catch ( PersistenceException e ) { throw new CmsDbSqlException ( Messages . get ( ) . container ( Messages . ERR _ GENERIC _ SQL _ _NUM , C _ USERDATA _ UPDATE _ _NUM ) , e ) ; } catch ( IOException e ) { throw new CmsDbIoException ( Messages . get ( ) . container ( Messages . ERR _ SERIALIZING _ USER _ DATA _ _NUM , userId ) , e ) ; } } 
2561	synchronized void checkAndUpdateNamespaceRegionCount ( TableName name , int incr ) throws IOException { String namespace = name . getNamespaceAsString ( ) ; NamespaceDescriptor nspdesc = getNamespaceDescriptor ( namespace ) ; if ( nspdesc ! = null ) { NamespaceTableAndRegionInfo currentStatus = getState ( namespace ) ; int regionCountOfTable = currentStatus . getRegionCountOfTable ( name ) ; if ( ( currentStatus . getRegionCount ( ) - regionCountOfTable + incr ) > TableNamespaceManager . getMaxRegions ( nspdesc ) ) { throw new QuotaExceededException ( _STR + TableNamespaceManager . getMaxRegions ( nspdesc ) ) ; } currentStatus . removeTable ( name ) ; currentStatus . addTable ( name , incr ) ; } } 
2562	public Menu getMenu ( ) { ensureMenu ( ) ; return mMenuView . getMenu ( ) ; } 
2563	public void rebuild ( ) throws Exception { Preconditions . checkState ( state . get ( ) = = State . STARTED , _STR ) ; ensurePath ( ) ; clear ( ) ; List < String > children = client . getChildren ( ) . forPath ( path ) ; for ( String child : children ) { String fullPath = ZKPaths . makePath ( path , child ) ; internalRebuildNode ( fullPath ) ; if ( rebuildTestExchanger ! = null ) { rebuildTestExchanger . exchange ( new Object ( ) ) ; } } this is necessary so that any updates that occurred while rebuilding are taken offerOperation ( new RefreshOperation ( this , RefreshMode . FORCE _ GET _ DATA _ AND _ STAT ) ) ; } 
2564	public static boolean isUrl ( String s ) { if ( isEmpty ( s ) ) return defaultEmptyOK ; if ( s . indexOf ( " : ! = - _NUM ) return true ; return false ; } 
2565	public String getStyleClassName ( ) { if ( isInsideProject ( ) & & isEditable ( ) ) { if ( m _ resource . getState ( ) . isChanged ( ) ) { return _STR ; } 
2566	public Future < Void > requestShutdown ( ) { Future < Boolean > requestedShutdownFuture = startGracefulShutdown ( ) ; return new Future < Void > ( ) { @ Override public boolean cancel ( boolean mayInterruptIfRunning ) { return requestedShutdownFuture . cancel ( mayInterruptIfRunning ) ; } @ Override public boolean isCancelled ( ) { return requestedShutdownFuture . isCancelled ( ) ; } @ Override public boolean isDone ( ) { return requestedShutdownFuture . isDone ( ) ; } @ Override public Void get ( ) throws InterruptedException , ExecutionException { requestedShutdownFuture . get ( ) ; return null ; } @ Override public Void get ( long timeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { requestedShutdownFuture . get ( timeout , unit ) ; return null ; } } ; } 
2567	public static boolean isAlphabetic ( String s ) { if ( isEmpty ( s ) ) return defaultEmptyOK ; When we do , return false ; if we don ' t , return true . for ( int i = _NUM ; i < s . length ( ) ; i + + ) { Check that current character is letter . char c = s . charAt ( i ) ; if ( ! isLetter ( c ) ) return false ; } All characters are letters . return true ; } 
2568	public boolean createNicEnv ( Network network , NicProfile nic , DeployDestination dest , ReservationContext context ) { String tenantNetworkUuid = _ sspUuidDao . findUuidByNetwork ( network ) ; if ( tenantNetworkUuid = = null ) { s _ logger . debug ( _STR + nic . toString ( ) ) ; return false ; } 
2569	private static Iterator < Pair < Integer , Record > > writePackedDataBlocks ( Iterator < Record > records , final BPlusTree bpt ) { if ( debug ) { divider ( ) ; System . out . println ( _STR ) ; iter _NUM = summarizeDataBlocks ( iter _NUM , bpt . getRecordsMgr ( ) . getRecordBufferPageMgr ( ) ) ; iter _NUM = printDataBlocks ( iter _NUM , bpt . getRecordsMgr ( ) . getRecordBufferPageMgr ( ) ) ; } return iter _NUM ; } 
2570	public List < INDArray > feedForward ( INDArray input , INDArray featuresMask , INDArray labelsMask ) { setLayerMaskArrays ( featuresMask , labelsMask ) ; List < INDArray > list = feedForward ( input ) ; clearLayerMaskArrays ( ) ; return list ; } 
2571	public String [ ] getIsimPcscf ( ) { try { IPhoneSubInfo info = getSubscriberInfo ( ) ; if ( info = = null ) return null ; get the Isim Pcscf based on subId return info . getIsimPcscf ( getSubId ( ) ) ; } catch ( RemoteException ex ) { return null ; } catch ( NullPointerException ex ) { This could happen before phone restarts due to crashing return null ; } } 
2572	protected boolean contentLengthHeaderMatchesActualLength ( final HttpCacheEntry entry ) { final Header h = entry . getFirstHeader ( HttpHeaders . CONTENT _ LENGTH ) ; if ( h ! = null ) { try { final long responseLen = Long . parseLong ( h . getValue ( ) ) ; final Resource resource = entry . getResource ( ) ; if ( resource = = null ) { return false ; } final long resourceLen = resource . length ( ) ; return responseLen = = resourceLen ; } catch ( final NumberFormatException ex ) { return false ; } } return true ; } 
2573	public static boolean isHAEnabled ( Configuration conf , String nsId ) { Map < String , Map < String , InetSocketAddress > > addresses = DFSUtil . getHaNnRpcAddresses ( conf ) ; if ( addresses = = null ) return false ; Map < String , InetSocketAddress > nnMap = addresses . get ( nsId ) ; return nnMap ! = null & & nnMap . size ( ) > _NUM ; } 
2574	public Map < String , Appender > asMap ( ) { final Map < String , Appender > result = new HashMap < > ( ) ; for ( final AppenderControl appenderControl : appenderArray . get ( ) ) { result . put ( appenderControl . getAppenderName ( ) , appenderControl . getAppender ( ) ) ; } return result ; } 
2575	public GenericValue previous ( ) { try { if ( resultSet . previous ( ) ) { return currentGenericValue ( ) ; } else { return null ; } } catch ( SQLException e ) { if ( ! closed ) { try { this . close ( ) ; } catch ( GenericEntityException e _NUM ) { Debug . logError ( e _NUM , _STR , e ) ; } } 
2576	private static void eval ( String string , String bindingStr , boolean expected ) { Binding binding = binding ( bindingStr ) ; Expr expr = ExprUtils . parse ( string ) ; NodeValue nv = expr . eval ( binding , FunctionEnvBase . createTest ( ) ) ; boolean b = XSDFuncOp . booleanEffectiveValue ( nv ) ; assertEquals ( string , expected , b ) ; } 
2577	public void test _NUM ( ) throws IOException { TreeMap < Key , Value > tm = new TreeMap < > ( ) ; newKeyValue ( tm , _STR , _NUM ) , EMPTY _ COL _ FAMS , false ) ; assertFalse ( it . hasTop ( ) ) ; } 
2578	 @ GET @ Path ( _STR , String . valueOf ( minutes ) ) ; return model ; } 
2579	public void testRandomSampling ( ) { logger . info ( _STR } ) ) ) ; AssociativeArray nh = generateNh ( ) ; boolean withReplacement = true ; double expResult = Descriptives . sum ( nh . toFlatDataCollection ( ) ) ; TransposeDataCollection sampledIds = StratifiedSampling . randomSampling ( strataIdList , nh , withReplacement ) ; double result = _NUM ; for ( Object stata : sampledIds . keySet ( ) ) { result + = sampledIds . get ( stata ) . size ( ) ; } assertEquals ( expResult , result , Constants . DOUBLE _ ACCURACY _ HIGH ) ; } 
2580	public Object getComponentState ( ) { if ( getColumns ( ) = = _NUM ) { return getValue ( ) ; } Object [ ] o = new Object [ getColumns ( ) ] ; int olen = o . length ; for ( int iter = _NUM ; iter < olen ; iter + + ) { o [ iter ] = getValue ( iter ) ; } return o ; } 
2581	public static String getOppositeMainStem ( Long pipelineId ) { return getOppositePipeline ( pipelineId ) + _STR + ArbitrateConstants . NODE _ MAINSTEM ; } 
2582	public void showWelcomeAd ( ) { if ( ! UIManager . getInstance ( ) . wasThemeInstalled ( ) ) { if ( Display . getInstance ( ) . hasNativeTheme ( ) ) { Display . getInstance ( ) . installNativeTheme ( ) ; } } ConnectionRequest r = createAdRequest ( ) ; r . setPriority ( ConnectionRequest . PRIORITY _ HIGH ) ; r . setTimeout ( timeout ) ; InfiniteProgress ip = new InfiniteProgress ( ) ; Dialog ipDialog = ip . showInifiniteBlocking ( ) ; NetworkManager . getInstance ( ) . addToQueueAndWait ( r ) ; if ( failed ( ) ) { ipDialog . dispose ( ) ; if ( ! allowWithoutNetwork ) { ipDialog . dispose ( ) ; Dialog . show ( _STR , null ) ; Display . getInstance ( ) . exitApplication ( ) ; } else { return ; } } Component c = getPendingAd ( ) ; if ( c ! = null ) { Form adForm = new AdForm ( c ) ; adForm . setTransitionInAnimator ( CommonTransitions . createEmpty ( ) ) ; adForm . setTransitionOutAnimator ( CommonTransitions . createEmpty ( ) ) ; adForm . show ( ) ; } } 
2583	public double [ ] getColumn ( int index ) { double [ ] newColumn = new double [ this . numRows ( ) ] ; for ( int i = _NUM ; i < newColumn . length ; i + + ) newColumn [ i ] = getElement ( i , index ) ; return newColumn ; } 
2584	public void setIfUndef ( Symbol property , Object value ) { Object x = context . get ( property ) ; if ( x = = null ) put ( property , value ) ; } 
2585	public String globalInfo ( ) { return _STR + getTechnicalInformation ( ) . toString ( ) ; } 
2586	public Map < String , Double > extract ( final String text ) { ID = > Kwd Map < Integer , String > ID _NUM word = new HashMap < > ( ) ; ID = > counts / scores Map < Integer , Double > ID _NUM occurrences = new HashMap < > ( ) ; word position = > ID maintain the order of insertation Map < Integer , Integer > position _NUM ID = new LinkedHashMap < > ( ) ; int numberOfWordsInDoc = buildInternalArrays ( text , ID _NUM word , ID _NUM occurrences , position _NUM ID ) ; int maxCombinations = parameters . getMaxCombinations ( ) ; Map < String , Double > keywordsMap = new HashMap < > ( ) ; move the _STR ) ; } if ( sb . length ( ) > _NUM ) { String key = sb . toString ( ) . trim ( ) ; double score = entry _NUM . getValue ( ) ; keywordsMap . put ( key , keywordsMap . getOrDefault ( key , _NUM . _NUM ) + score ) ; } } } remove any word that has score less than the min occurrence double minScore = parameters . getMinWordOccurrence ( ) ; Iterator < Map . Entry < String , Double > > it = keywordsMap . entrySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { Map . Entry < String , Double > entry = it . next ( ) ; if ( entry . getValue ( ) < minScore ) { it . remove ( ) ; } } return keywordsMap ; } 
2587	protected String parseToken ( final String pattern , final int [ ] indexRef ) { final StringBuilder buf = new StringBuilder ( ) ; int i = indexRef [ _NUM ] ; final int length = pattern . length ( ) ; char c = pattern . charAt ( i ) ; if ( c > = ' A ' & & c < = ' Z ' | | c > = ' a ' & & c < = ' z ' ) { Scan a run of the same character , which indicates a time pattern . buf . append ( c ) ; while ( i + _NUM < length ) { final char peek = pattern . charAt ( i + _NUM ) ; if ( peek = = c ) { buf . append ( c ) ; i + + ; } else { break ; } } } else { This will identify token as text . buf . append ( ' \ ' ' ) ; boolean inLiteral = false ; for ( ; i < length ; i + + ) { c = pattern . charAt ( i ) ; if ( c = = ' \ ' ' ) { if ( i + _NUM < length & & pattern . charAt ( i + _NUM ) = = ' \ ' ' ) { ' ' is treated as escaped ' i + + ; buf . append ( c ) ; } else { inLiteral = ! inLiteral ; } } else if ( ! inLiteral & & ( c > = ' A ' & & c < = ' Z ' | | c > = ' a ' & & c < = ' z ' ) ) { i - - ; break ; } else { buf . append ( c ) ; } } } indexRef [ _NUM ] = i ; return buf . toString ( ) ; } 
2588	public boolean readPage ( ) throws IOException { if ( ! pageReader . hasPage ( ) | | totalValuesReadAndReadyToReadInPage ( ) = = pageReader . currentPageCount ) { readRecords ( pageReader . valuesReadyToRead ) ; if ( pageReader . hasPage ( ) ) { totalValuesRead + = pageReader . currentPageCount ; } if ( ! pageReader . next ( ) ) { hitRowGroupEnd ( ) ; return true ; } postPageRead ( ) ; } return false ; } 
2589	public Byte remove ( Object key ) { double k ; if ( key ! = null ) { if ( key instanceof Double ) { k = unwrapKey ( key ) ; } else { return null ; } } else { k = _ map . getNoEntryKey ( ) ; } byte v = _ map . remove ( k ) ; check here . if ( v = = _ map . getNoEntryValue ( ) ) { return null ; } else { return wrapValue ( v ) ; } } 
2590	public void testInvalidValue ( @ InvalidMvccEntityGenerator . IllegalFields final MvccEntity mvccEntity , @ InvalidEntityGenerator . IllegalFields final Entity entity , @ InvalidIdGenerator . IllegalFields final Id invalidValueId ) throws Exception { testStage ( mvccEntity , entity , invalidValueId ) ; } 
2591	public void setMaxSize ( long maxSize ) { if the new maxSize is < = _NUM , clear keyLRUList if ( maxSize < = _NUM ) { keyLRUList . clear ( ) ; } else if ( maxSize > _NUM & & this . maxSize < = _NUM ) { if the new maxSize > _NUM and the old is < = _NUM , fill in LRU list - order will be meaningless for now Iterator keys = cacheLineTable . keySet ( ) . iterator ( ) ; while ( keys . hasNext ( ) ) { keyLRUList . add ( keys . next ( ) ) ; } } cache . if ( maxSize > _NUM & & cacheLineTable . size ( ) > maxSize ) { while ( cacheLineTable . size ( ) > maxSize ) { Object lastKey = keyLRUList . getLast ( ) ; removeObject ( lastKey ) ; } } this . maxSize = maxSize ; } 
2592	private static String readWholeFileAsUTF _NUM ( Reader r ) throws IOException { final int WHOLE _ FILE _ BUFFER _ SIZE = _NUM _NUM * _NUM _NUM _NUM _NUM ; try ( StringWriter sw = new StringWriter ( WHOLE _ FILE _ BUFFER _ SIZE ) ) { char [ ] buff = new char [ WHOLE _ FILE _ BUFFER _ SIZE ] ; for ( ; ; ) { int l = r . read ( buff ) ; if ( l < _NUM ) break ; sw . write ( buff , _NUM , l ) ; } return sw . toString ( ) ; } } 
2593	public static XmlAnyURI parse ( org . apache . xmlbeans . xml . stream . XMLInputStream xis , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , org . apache . xmlbeans . xml . stream . XMLStreamException { return ( XmlAnyURI ) XmlBeans . getContextTypeLoader ( ) . parse ( xis , type , options ) ; } 
2594	 @ SuppressWarnings ( _STR , readCount . get ( ) , TOTAL _ OPERATIONS , writeCount . get ( ) , TOTAL _ OPERATIONS , runTime ) ) ; return runTime ; } 
2595	public I _ CmsReport getReport ( ) { return m _ publishJob . getPublishReport ( ) ; } 
2596	public void testAuditLoggerWithIP ( ) throws Exception { Configuration conf = new Configuration ( ) ; start the IPC server Server server = new RPC . Builder ( conf ) . setProtocol ( TestProtocol . class ) . setInstance ( new MyTestRPCServer ( ) ) . setBindAddress ( _STR ) . setPort ( _NUM ) . build ( ) ; server . start ( ) ; InetSocketAddress addr = NetUtils . getConnectAddress ( server ) ; Make a client connection and test the audit log TestProtocol proxy = ( TestProtocol ) RPC . getProxy ( TestProtocol . class , TestProtocol . versionID , addr , conf ) ; Start the testcase proxy . ping ( ) ; server . stop ( ) ; } 
2597	private void scanJar ( JarURLConnection conn , boolean ignore ) throws JasperException { JarFile jarFile = null ; String resourcePath = conn . getJarFileURL ( ) . toString ( ) ; try { if ( redeployMode ) { conn . setUseCaches ( false ) ; } jarFile = conn . getJarFile ( ) ; Enumeration entries = jarFile . entries ( ) ; while ( entries . hasMoreElements ( ) ) { JarEntry entry = ( JarEntry ) entries . nextElement ( ) ; String name = entry . getName ( ) ; if ( ! name . startsWith ( _STR ) ) continue ; InputStream stream = jarFile . getInputStream ( entry ) ; try { String uri = getUriFromTld ( resourcePath , stream ) ; present in the map if ( uri ! = null & & mappings . get ( uri ) = = null ) { mappings . put ( uri , new String [ ] { resourcePath , name } ) ; } } finally { if ( stream ! = null ) { try { stream . close ( ) ; } catch ( Throwable t ) { do nothing } } } } } catch ( Exception ex ) { if ( ! redeployMode ) { if not in redeploy mode , close the jar in case of an error if ( jarFile ! = null ) { try { jarFile . close ( ) ; } catch ( Throwable t ) { ignore } } } if ( ! ignore ) { throw new JasperException ( ex ) ; } } finally { if ( redeployMode ) { if in redeploy mode , always close the jar if ( jarFile ! = null ) { try { jarFile . close ( ) ; } catch ( Throwable t ) { ignore } } } } } 
2598	public void testRoundAmPm ( ) throws Exception { final int calendarField = Calendar . AM _ PM ; Date roundedUpDate , roundedDownDate , lastRoundedDownDate ; Date minDate , maxDate ; AM roundedUpDate = dateTimeParser . parse ( _STR ) ; roundToJanuaryFirst ( minDate , maxDate , calendarField ) ; } 
2599	public String [ ] queryField ( UUID templateTypeId , String queryField ) { List < String > queryFieldsList = new ArrayList < String > ( ) ; queryFieldsList . add ( queryField ) ; Map < String , String > whereFieldsMap = new HashMap < String , String > ( ) ; whereFieldsMap . put ( _STR , e ) ; } finally { DbPoolConnection . getInstance ( ) . closeAll ( rs , stat , conn ) ; } return result . toArray ( new String [ result . size ( ) ] ) ; } 
2600	public static String stringifyException ( Throwable e ) { StringWriter stm = new StringWriter ( ) ; PrintWriter wrt = new PrintWriter ( stm ) ; e . printStackTrace ( wrt ) ; wrt . close ( ) ; return stm . toString ( ) ; } 
2601	public void writeStrMultiLine ( AWriter w , String s ) { quote _NUM ( w ) ; EscapeStr . stringEsc ( w , s , quoteChar , false , charSpace ) ; quote _NUM ( w ) ; } 
2602	public synchronized void restartNameNode ( int nnIndex , boolean waitActive , String . . . args ) throws IOException { String nameserviceId = nameNodes [ nnIndex ] . nameserviceId ; String nnId = nameNodes [ nnIndex ] . nnId ; StartupOption startOpt = nameNodes [ nnIndex ] . startOpt ; Configuration conf = nameNodes [ nnIndex ] . conf ; shutdownNameNode ( nnIndex ) ; if ( args . length ! = _NUM ) { startOpt = null ; } else { args = createArgs ( startOpt ) ; } NameNode nn = NameNode . createNameNode ( args , conf ) ; nameNodes [ nnIndex ] = new NameNodeInfo ( nn , nameserviceId , nnId , startOpt , conf ) ; if ( waitActive ) { waitClusterUp ( ) ; LOG . info ( _STR ) ; waitActive ( ) ; } } 
2603	public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( _STR ) ; return sb . toString ( ) ; } 
2604	public void onAnimationEnd ( Animator animation ) { if ( mRule = = Dependency . AFTER ) { startIfReady ( animation ) ; } } 
2605	public void test _ rename _ file ( ) throws Exception { startCrawler ( ) ; We should have one doc first countTestHelper ( new SearchRequest ( getCrawlerName ( ) ) , _NUM L , currentTestResourceDir ) ; We rename the file logger . info ( _STR ) ) ) , _NUM L , currentTestResourceDir ) ; } 
2606	public void failNextJpeg ( ) { final ReentrantLock lock = this . mLock ; lock . lock ( ) ; try { CaptureHolder h _NUM = mJpegCaptureQueue . peek ( ) ; CaptureHolder h _NUM = mJpegProduceQueue . peek ( ) ; Find the request with the lowest frame number . CaptureHolder h = ( h _NUM = = null ) ? h _NUM : ( ( h _NUM = = null ) ? h _NUM : ( ( h _NUM . compareTo ( h _NUM ) < = _NUM ) ? h _NUM : h _NUM ) ) ; if ( h ! = null ) { mJpegCaptureQueue . remove ( h ) ; mJpegProduceQueue . remove ( h ) ; mActiveRequests . remove ( h ) ; h . setJpegFailed ( ) ; } } finally { lock . unlock ( ) ; } } 
2607	public void load ( SolrQueryRequest req , SolrQueryResponse rsp , ContentStream stream ) throws IOException { errHeader = _STR + vals . length , vals , line ) ; } addDoc ( line , vals ) ; } } finally { if ( reader ! = null ) { IOUtils . closeQuietly ( reader ) ; } } } 
2608	public int getCurrentContentInsetStart ( ) { return getNavigationIcon ( ) ! = null ? Math . max ( getContentInsetStart ( ) , Math . max ( mContentInsetStartWithNavigation , _NUM ) ) : getContentInsetStart ( ) ; } 
2609	public void testMockInvokerInvoke _ failmock ( ) { URL url = URL . valueOf ( _STR ) ; ret = cluster . invoke ( invocation ) ; Assert . assertEquals ( null , ret . getValue ( ) ) ; } 
2610	public void testCachingCachesNegativeEntries ( ) throws Throwable { StaticMapping staticMapping = newInstance ( ) ; CachedDNSToSwitchMapping cachedMap = new CachedDNSToSwitchMapping ( staticMapping ) ; assertMapSize ( cachedMap , _NUM ) ; assertMapSize ( staticMapping , _NUM ) ; List < String > resolved = cachedMap . resolve ( createQueryList ( ) ) ; and verify the cache is no longer empty while the static map is assertMapSize ( staticMapping , _NUM ) ; assertMapSize ( cachedMap , _NUM ) ; } 
2611	public void readExternal ( ObjectInput is ) throws IOException { DataInput dis = is ; if ( is instanceof ObjectInputStream ) { fast deserialize of dense / sparse blocks ObjectInputStream ois = ( ObjectInputStream ) is ; dis = new FastBufferedDataInputStream ( ois ) ; } readHeaderAndPayload ( dis ) ; } 
2612	public Response getList ( ) { try { LOG . debug ( _STR , allSavedQueries ) ; return Response . ok ( object ) . build ( ) ; } catch ( WebApplicationException ex ) { throw ex ; } catch ( Exception ex ) { throw new ServiceFormattedException ( ex . getMessage ( ) , ex ) ; } } 
2613	public boolean next ( ) throws IOException { Stopwatch timer = Stopwatch . createUnstarted ( ) ; currentPageCount = - _NUM ; valuesRead = _NUM ; valuesReadyToRead = _NUM ; TODO - the metatdata for total size appears to be incorrect for impala generated files , need to find cause and submit a bug report long totalValueCount = parentColumnReader . columnChunkMetaData . getValueCount ( ) ; if ( parentColumnReader . totalValuesRead > = totalValueCount ) { return false ; } clearBuffers ( ) ; nextInternal ( ) ; if ( pageData = = null | | pageHeader = = null ) { TODO : Is this an error condition or a normal condition ? ? return false ; } timer . start ( ) ; currentPageCount = pageHeader . data _ page _ header . num _ values ; final Encoding rlEncoding = METADATA _ CONVERTER . getEncoding ( pageHeader . data _ page _ header . repetition _ level _ encoding ) ; final Encoding dlEncoding = METADATA _ CONVERTER . getEncoding ( pageHeader . data _ page _ header . definition _ level _ encoding ) ; final Encoding valueEncoding = METADATA _ CONVERTER . getEncoding ( pageHeader . data _ page _ header . encoding ) ; byteLength = pageHeader . uncompressed _ page _ size ; final ByteBuffer pageDataBuffer = pageData . nioBuffer ( _NUM , pageData . capacity ( ) ) ; readPosInBytes = _NUM ; if ( parentColumnReader . getColumnDescriptor ( ) . getMaxRepetitionLevel ( ) > _NUM ) { repetitionLevels = rlEncoding . getValuesReader ( parentColumnReader . columnDescriptor , ValuesType . REPETITION _ LEVEL ) ; repetitionLevels . initFromPage ( currentPageCount , pageDataBuffer , ( int ) readPosInBytes ) ; we know that the first value will be a _NUM , at the end of each list of repeated values we will hit another _NUM indicating a new record , although we don ' t know the length until we hit it ( and this is a one way stream of integers ) so we read the first zero here to simplify the reading processes , and start reading the first value the same as all of the rest . Effectively we are ' reading ' the non - existent value in front of the first allowing direct access to the first list of repetition levels readPosInBytes = repetitionLevels . getNextOffset ( ) ; repetitionLevels . readInteger ( ) ; } if ( parentColumnReader . columnDescriptor . getMaxDefinitionLevel ( ) ! = _NUM ) { parentColumnReader . currDefLevel = - _NUM ; definitionLevels = dlEncoding . getValuesReader ( parentColumnReader . columnDescriptor , ValuesType . DEFINITION _ LEVEL ) ; definitionLevels . initFromPage ( currentPageCount , pageDataBuffer , ( int ) readPosInBytes ) ; readPosInBytes = definitionLevels . getNextOffset ( ) ; if ( ! valueEncoding . usesDictionary ( ) ) { valueReader = valueEncoding . getValuesReader ( parentColumnReader . columnDescriptor , ValuesType . VALUES ) ; valueReader . initFromPage ( currentPageCount , pageDataBuffer , ( int ) readPosInBytes ) ; } } if ( parentColumnReader . columnDescriptor . getType ( ) = = PrimitiveType . PrimitiveTypeName . BOOLEAN ) { valueReader = valueEncoding . getValuesReader ( parentColumnReader . columnDescriptor , ValuesType . VALUES ) ; valueReader . initFromPage ( currentPageCount , pageDataBuffer , ( int ) readPosInBytes ) ; } if ( valueEncoding . usesDictionary ( ) ) { initialize two of the dictionary readers , one is for determining the lengths of each value , the second is for actually copying the values out into the vectors dictionaryLengthDeterminingReader = new DictionaryValuesReader ( dictionary ) ; dictionaryLengthDeterminingReader . initFromPage ( currentPageCount , pageDataBuffer , ( int ) readPosInBytes ) ; dictionaryValueReader = new DictionaryValuesReader ( dictionary ) ; dictionaryValueReader . initFromPage ( currentPageCount , pageDataBuffer , ( int ) readPosInBytes ) ; parentColumnReader . usingDictionary = true ; } else { parentColumnReader . usingDictionary = false ; } readPosInBytes is used for actually reading the values after we determine how many will fit in the vector readyToReadPosInBytes serves a similar purpose for the vector types where we must count up the values that will fit one record at a time , such as for variable length data . Both operations must start in the same location after the definition and repetition level data which is stored alongside the page data itself readyToReadPosInBytes = readPosInBytes ; long timeDecode = timer . elapsed ( TimeUnit . NANOSECONDS ) ; stats . numDataPagesDecoded . incrementAndGet ( ) ; stats . timeDataPageDecode . addAndGet ( timeDecode ) ; return true ; } 
2614	void onStartHelper ( ) { prevSessionDurationStartTime _ = System . nanoTime ( ) ; connectionQueue _ . beginSession ( ) ; } 
2615	public static Logger getLogger ( final Class clazz ) { Delegate the actual manufacturing of the logger to the logger repository . return getLoggerRepository ( ) . getLogger ( clazz . getName ( ) ) ; } 
2616	public void dumpSizes ( ) throws SQLException , BlockStoreException { maybeConnect ( ) ; Statement s = conn . get ( ) . createStatement ( ) ; long size = _NUM ; long totalSize = _NUM ; int count = _NUM ; ResultSet rs = s . executeQuery ( getSelectSettingsDumpSQL ( ) ) ; while ( rs . next ( ) ) { size + = rs . getString ( _NUM ) . length ( ) ; size + = rs . getBytes ( _NUM ) . length ; count + + ; } rs . close ( ) ; System . out . printf ( Locale . US , _STR + totalSize ) ; s . close ( ) ; } 
2617	private void setComponentConstraintsImpl ( Component comp , Object constr , boolean noCheck ) { Container parent = comp . getParent ( ) ; if ( noCheck = = false & & scrConstrMap . containsKey ( comp ) = = false ) { throw new IllegalArgumentException ( _STR + constr . getClass ( ) . toString ( ) ) ; } dirty = true ; } 
2618	private void captureHierarchy ( View view , boolean start ) { if ( view = = null ) { return ; } int id = view . getId ( ) ; if ( mTargetIdExcludes ! = null & & mTargetIdExcludes . contains ( id ) ) { return ; } if ( mTargetExcludes ! = null & & mTargetExcludes . contains ( view ) ) { return ; } if ( mTargetTypeExcludes ! = null & & view ! = null ) { int numTypes = mTargetTypeExcludes . size ( ) ; for ( int i = _NUM ; i < numTypes ; + + i ) { if ( mTargetTypeExcludes . get ( i ) . isInstance ( view ) ) { return ; } } } if ( view . getParent ( ) instanceof ViewGroup ) { TransitionValues values = new TransitionValues ( ) ; values . view = view ; if ( start ) { captureStartValues ( values ) ; } else { captureEndValues ( values ) ; } values . targetedTransitions . add ( this ) ; capturePropagationValues ( values ) ; if ( start ) { addViewValues ( mStartValues , view , values ) ; } else { addViewValues ( mEndValues , view , values ) ; } } if ( view instanceof ViewGroup ) { Don ' t traverse child hierarchy if there are any child - excludes on this view if ( mTargetIdChildExcludes ! = null & & mTargetIdChildExcludes . contains ( id ) ) { return ; } if ( mTargetChildExcludes ! = null & & mTargetChildExcludes . contains ( view ) ) { return ; } if ( mTargetTypeChildExcludes ! = null ) { int numTypes = mTargetTypeChildExcludes . size ( ) ; for ( int i = _NUM ; i < numTypes ; + + i ) { if ( mTargetTypeChildExcludes . get ( i ) . isInstance ( view ) ) { return ; } } } ViewGroup parent = ( ViewGroup ) view ; for ( int i = _NUM ; i < parent . getChildCount ( ) ; + + i ) { captureHierarchy ( parent . getChildAt ( i ) , start ) ; } } } 
2619	public String getAmbariProperty ( String key ) { return ambariConfiguration . getProperty ( key ) ; } 
2620	public void test ( ) throws Exception { File [ ] files = new File ( _STR + file , e ) ; } } } 
2621	public long getFailedAverageElapsed ( ) { long failed = getFailed ( ) ; if ( failed = = _NUM ) { return _NUM ; } return getFailedElapsed ( ) / failed ; } 
2622	public static NarCloseable withComponentNarLoader ( final Class componentClass , final String componentIdentifier ) { final ClassLoader current = Thread . currentThread ( ) . getContextClassLoader ( ) ; ClassLoader componentClassLoader = ExtensionManager . getInstanceClassLoader ( componentIdentifier ) ; if ( componentClassLoader = = null ) { componentClassLoader = componentClass . getClassLoader ( ) ; } Thread . currentThread ( ) . setContextClassLoader ( componentClassLoader ) ; return new NarCloseable ( current ) ; } 
2623	public void installTitleView ( LayoutInflater inflater , ViewGroup parent , Bundle savedInstanceState ) { View titleLayoutRoot = onInflateTitleView ( inflater , parent , savedInstanceState ) ; if ( titleLayoutRoot ! = null ) { parent . addView ( titleLayoutRoot ) ; setTitleView ( titleLayoutRoot . findViewById ( R . id . browse _ title _ group ) ) ; } else { setTitleView ( null ) ; } } 
2624	private void setHeaderStatusReleaseToLoad ( ) { if ( currentHeaderStatus ! = HEADER _ STATUS _ RELEASE _ TO _ LOAD ) { headerImage . setVisibility ( View . VISIBLE ) ; headerImage . clearAnimation ( ) ; headerImage . startAnimation ( flipAnimation ) ; headerProgressBar . setVisibility ( View . GONE ) ; headerText . setText ( headerReleaseText ) ; currentHeaderStatus = HEADER _ STATUS _ RELEASE _ TO _ LOAD ; } } 
2625	protected boolean recursivelyFindSelectedItems ( UUID itemId ) { boolean passesFilter = passesFilter ( itemId ) ; for ( UUID childId : getChildren ( itemId ) ) { passesFilter | = recursivelyFindSelectedItems ( childId ) ; } if ( passesFilter ) { filteredItemsIds . add ( itemId ) ; } return passesFilter ; } 
2626	public String saveSingleShip ( HttpServletRequest request , HttpServletResponse response , Model model , ShippingInfoForm shippingForm , BindingResult result ) throws PricingException , ServiceException { Order cart = CartState . getCart ( ) ; if ( shippingForm . shouldUseBillingAddress ( ) ) { copyBillingAddressToShippingAddress ( cart , shippingForm ) ; } addressService . populateAddressISOCountrySub ( shippingForm . getAddress ( ) ) ; shippingInfoFormValidator . validate ( shippingForm , result ) ; if ( result . hasErrors ( ) ) { return getCheckoutView ( ) ; } if ( ( shippingForm . getAddress ( ) . getPhonePrimary ( ) ! = null ) & & ( StringUtils . isEmpty ( shippingForm . getAddress ( ) . getPhonePrimary ( ) . getPhoneNumber ( ) ) ) ) { shippingForm . getAddress ( ) . setPhonePrimary ( null ) ; } if ( ( shippingForm . getAddress ( ) . getPhoneSecondary ( ) ! = null ) & & ( StringUtils . isEmpty ( shippingForm . getAddress ( ) . getPhoneSecondary ( ) . getPhoneNumber ( ) ) ) ) { shippingForm . getAddress ( ) . setPhoneSecondary ( null ) ; } if ( ( shippingForm . getAddress ( ) . getPhoneFax ( ) ! = null ) & & ( StringUtils . isEmpty ( shippingForm . getAddress ( ) . getPhoneFax ( ) . getPhoneNumber ( ) ) ) ) { shippingForm . getAddress ( ) . setPhoneFax ( null ) ; } Customer customer = CustomerState . getCustomer ( ) ; if ( ! customer . isAnonymous ( ) & & shippingForm . isSaveAsDefault ( ) ) { Address address = addressService . saveAddress ( shippingForm . getAddress ( ) ) ; CustomerAddress customerAddress = customerAddressService . create ( ) ; customerAddress . setAddress ( address ) ; customerAddress . setAddressName ( shippingForm . getAddressName ( ) ) ; customerAddress . setCustomer ( customer ) ; customerAddress = customerAddressService . saveCustomerAddress ( customerAddress ) ; customerAddressService . makeCustomerAddressDefault ( customerAddress . getId ( ) , customer . getId ( ) ) ; } FulfillmentGroup shippableFulfillmentGroup = fulfillmentGroupService . getFirstShippableFulfillmentGroup ( cart ) ; if ( shippableFulfillmentGroup ! = null ) { shippableFulfillmentGroup . setAddress ( shippingForm . getAddress ( ) ) ; shippableFulfillmentGroup . setPersonalMessage ( shippingForm . getPersonalMessage ( ) ) ; shippableFulfillmentGroup . setDeliveryInstruction ( shippingForm . getDeliveryMessage ( ) ) ; FulfillmentOption fulfillmentOption = fulfillmentOptionService . readFulfillmentOptionById ( shippingForm . getFulfillmentOptionId ( ) ) ; shippableFulfillmentGroup . setFulfillmentOption ( fulfillmentOption ) ; cart = orderService . save ( cart , true ) ; } Add module specific logic checkoutControllerExtensionManager . getProxy ( ) . performAdditionalShippingAction ( ) ; if ( isAjaxRequest ( request ) ) { Add module specific model variables checkoutControllerExtensionManager . getProxy ( ) . addAdditionalModelVariables ( model ) ; return getCheckoutView ( ) ; } else { return getCheckoutPageRedirect ( ) ; } } 
2627	public void testPersistence ( ) throws Throwable { CmsObject cms = getCmsObject ( ) ; echo ( _STR ) ; assertEquals ( ou _NUM . getId ( ) , ou _NUM Folder . getStructureId ( ) ) ; assertEquals ( ou _NUM . getFlags ( ) , ou _NUM Folder . getFlags ( ) & ~ CmsResource . FLAG _ INTERNAL ) ; assertTrue ( ou _NUM Folder . getState ( ) . isUnchanged ( ) ) ; assertTrue ( ou _NUM Folder . isInternal ( ) ) ; assertEquals ( ou _NUM . getDescription ( ) , cms . readPropertyObject ( ou _NUM Folder , CmsPropertyDefinition . PROPERTY _ DESCRIPTION , false ) . getValue ( ) ) ; assertOrgUnitResources ( cms , ou _NUM ) ; } 
2628	public void reenableAutoCompaction ( boolean check _ for _ compaction ) { _ autoCompactTemporaryDisable = false ; if ( check _ for _ compaction & & _ autoCompactRemovesRemaining < = _NUM & & _ autoCompactionFactor ! = _NUM ) { Do the compact NOTE : this will cause the next compaction interval to be calculated compact ( ) ; } } 
2629	private boolean intersectVisibleToUser ( Rect localRect ) { Missing or empty bounds mean this view is not visible . if ( ( localRect = = null ) | | localRect . isEmpty ( ) ) { return false ; } Attached to invisible window means this view is not visible . if ( mView . getWindowVisibility ( ) ! = View . VISIBLE ) { return false ; } An invisible predecessor means that this view is not visible . ViewParent viewParent = mView . getParent ( ) ; while ( viewParent instanceof View ) { final View view = ( View ) viewParent ; if ( ( view . getAlpha ( ) < = _NUM ) | | ( view . getVisibility ( ) ! = View . VISIBLE ) ) { return false ; } viewParent = view . getParent ( ) ; } A null parent implies the view is not visible . if ( viewParent = = null ) { return false ; } If no portion of the parent is visible , this view is not visible . if ( mTempVisibleRect = = null ) { mTempVisibleRect = new Rect ( ) ; } final Rect tempVisibleRect = mTempVisibleRect ; if ( ! mView . getLocalVisibleRect ( tempVisibleRect ) ) { return false ; } Check if the view intersects the visible portion of the parent . return localRect . intersect ( tempVisibleRect ) ; } 
2630	protected ResourcesAndRelated getResourcesWithoutPermissions ( Set < CmsResource > exclude ) { Set < CmsUUID > projectIds = new HashSet < CmsUUID > ( ) ; try { for ( CmsProject project : OpenCms . getOrgUnitManager ( ) . getAllManageableProjects ( m _ cms , _STR , true ) ) { projectIds . add ( project . getUuid ( ) ) ; } } catch ( CmsException e ) { should never happen LOG . error ( e . getLocalizedMessage ( ) , e ) ; } ResourcesAndRelated result = new ResourcesAndRelated ( ) ; for ( CmsResource resource : getPublishResources ( ) . getResources ( ) ) { skip already blocking resources if ( exclude . contains ( resource ) ) { continue ; } try { if ( ! projectIds . contains ( resource . getProjectLastModified ( ) ) & & ! m _ cms . hasPermissions ( resource , CmsPermissionSet . ACCESS _ DIRECT _ PUBLISH ) ) { result . getResources ( ) . add ( resource ) ; } } catch ( Exception e ) { error reading the permissions , should usually never happen if ( LOG . isErrorEnabled ( ) ) { LOG . error ( e . getLocalizedMessage ( ) , e ) ; } } } for ( CmsResource resource : getPublishResources ( ) . getRelatedResources ( ) ) { skip already blocking resources if ( exclude . contains ( resource ) ) { continue ; } try { if ( ! m _ cms . hasPermissions ( resource , CmsPermissionSet . ACCESS _ DIRECT _ PUBLISH ) ) { result . getRelatedResources ( ) . add ( resource ) ; } } catch ( Exception e ) { error reading the resource list , should usually never happen if ( LOG . isErrorEnabled ( ) ) { LOG . error ( e . getLocalizedMessage ( ) , e ) ; } } } return result ; } 
2631	public static boolean isCompleted ( Lineage lineage , FileSystemMasterView fileSystemMasterView ) throws FileDoesNotExistException , AccessControlException , UnavailableException { for ( long outputFile : lineage . getOutputFiles ( ) ) { FileInfo fileInfo = fileSystemMasterView . getFileInfo ( outputFile ) ; if ( ! fileInfo . isCompleted ( ) ) { return false ; } } return true ; } 
2632	public List < ? extends COSBase > toList ( ) { List < COSBase > retList = new ArrayList < > ( size ( ) ) ; for ( int i = _NUM ; i < size ( ) ; i + + ) { retList . add ( get ( i ) ) ; } return retList ; } 
2633	public static MarkerPatternSelector createSelector ( final PatternMatch [ ] properties , final String defaultPattern , final boolean alwaysWriteExceptions , final boolean noConsoleNoAnsi , final Configuration configuration ) { final Builder builder = newBuilder ( ) ; builder . setProperties ( properties ) ; builder . setDefaultPattern ( defaultPattern ) ; builder . setAlwaysWriteExceptions ( alwaysWriteExceptions ) ; builder . setNoConsoleNoAnsi ( noConsoleNoAnsi ) ; builder . setConfiguration ( configuration ) ; return builder . build ( ) ; } 
2634	public void testPageBreakClones ( ) throws IOException { Workbook b = _ testDataProvider . createWorkbook ( ) ; Sheet s = b . createSheet ( _STR , clone . isRowBroken ( _NUM ) ) ; b . close ( ) ; } 
2635	public void setYindex ( int y ) { if the attribs change if ( y ! = m _ yIndex ) { cancelShapes ( ) ; } m _ yIndex = y ; m _ plot _NUM D . setYindex ( y ) ; if ( m _ showAttBars ) { m _ attrib . setY ( y ) ; } this . repaint ( ) ; } 
2636	private void stopVirtualDisplay ( ) { if ( mStopVDRunnable = = null ) { mStopVDRunnable = new Runnable ( ) { @ Override public void run ( ) { if ( shouldRunVirtualDisplay ( ) ) { Log . i ( TAG , _STR ) ; synchronized ( mVdLock ) { updateDisplayId ( INVALID _ DISPLAY ) ; clean up and release the surface first . setSurfaceLocked ( null ) ; if ( mVirtualDisplay ! = null ) { mVirtualDisplay . release ( ) ; mVirtualDisplay = null ; } stopImageReader ( ) ; } } } } ; } mHandler . removeCallbacks ( mStopVDRunnable ) ; mHandler . postDelayed ( mStopVDRunnable , STOP _ VIRTUAL _ DISPLAY _ DELAY _ MILLIS ) ; } 
2637	private void setMaxRetries ( String maxRetries ) { Long lMaxRetries ; try { lMaxRetries = Long . parseLong ( maxRetries ) ; } catch ( NumberFormatException e ) { No response or not parsable , expire immediately Log . w ( TAG , _STR ; lMaxRetries = _NUM l ; } mMaxRetries = lMaxRetries ; mPreferences . putString ( PREF _ MAX _ RETRIES , maxRetries ) ; } 
2638	public static String unbackQuoteChars ( String string ) { int index ; StringBuffer newStringBuffer ; replace each of the following characters with the backquoted version String [ ] charsFind = { _STR ; } else { newStringBuffer . append ( str . substring ( _NUM , pos [ index ] ) ) ; newStringBuffer . append ( charsReplace [ index ] ) ; str = str . substring ( pos [ index ] + charsFind [ index ] . length ( ) ) ; } } return newStringBuffer . toString ( ) ; } 
2639	public static byte [ ] encodeBytesToBytes ( byte [ ] source , int off , int len , int options ) throws java . io . IOException { if ( source = = null ) { throw new NullPointerException ( _STR ) ; return outBuff ; } } end else : don ' t compress } 
2640	public < InputT , OutputT > ComposedCombineFnWithContext < DataT > with ( SimpleFunction < DataT , InputT > extractInputFn , CombineFnWithContext < InputT , ? , OutputT > combineFn , TupleTag < OutputT > outputTag ) { checkUniqueness ( outputTags , outputTag ) ; List < CombineFnWithContext < Object , Object , Object > > fnsWithContext = Lists . newArrayList ( ) ; for ( CombineFn < Object , Object , Object > fn : combineFns ) { fnsWithContext . add ( CombineFnUtil . toFnWithContext ( fn ) ) ; } return new ComposedCombineFnWithContext < > ( ImmutableList . < SerializableFunction < DataT , ? > > builder ( ) . addAll ( extractInputFns ) . add ( extractInputFn ) . build ( ) , ImmutableList . < CombineFnWithContext < ? , ? , ? > > builder ( ) . addAll ( fnsWithContext ) . add ( combineFn ) . build ( ) , ImmutableList . < TupleTag < ? > > builder ( ) . addAll ( outputTags ) . add ( outputTag ) . build ( ) ) ; } 
2641	public final void synpred _NUM _NUM _NUM _ JPA _NUM _ fragment ( ) throws RecognitionException { JPA _NUM . g : _NUM _NUM _NUM : _NUM : ( input _ parameter ) JPA _NUM . g : _NUM _NUM _NUM : _NUM : input _ parameter { pushFollow ( FOLLOW _ input _ parameter _ in _ synpred _NUM _NUM _NUM _ JPA _NUM _NUM _NUM _NUM _NUM ) ; input _ parameter ( ) ; state . _ fsp - - ; if ( state . failed ) return ; } } 
2642	private String parseLinkTitle ( ) { String title = match ( LINK _ TITLE ) ; if ( title ! = null ) { chop off quotes from title and unescape : return Escaping . unescapeString ( title . substring ( _NUM , title . length ( ) - _NUM ) ) ; } else { return null ; } } 
2643	static void generateData ( FileSystem fs , Path dirPath ) throws IOException { FSDataOutputStream out = fs . create ( new Path ( dirPath , _STR ) ) ; } out . close ( ) ; } 
2644	public void doWork ( ) throws DrillException { int currentRow = _NUM ; this . current = batches . get ( _NUM ) ; setupSaveFirstValue ( current , internal ) ; outputCount = current . getRecordCount ( ) ; while ( currentRow < outputCount ) { if ( ! isPartitionDone ( ) ) { we have a pending partition we need to handle from a previous call to doWork ( ) assert currentRow = = _NUM : _STR , remainingRows ) ; if ( ! requireFullPartition ) { we didn ' t compute the whole partition length in the previous partition , we need to update the length now updatePartitionSize ( currentRow ) ; } } else { newPartition ( current , currentRow ) ; } currentRow = processPartition ( currentRow ) ; if ( isPartitionDone ( ) ) { reset ( ) ; } } } 
2645	public static String formatTimeDiff ( long finishTime , long startTime ) { long timeDiff = finishTime - startTime ; return formatTime ( timeDiff ) ; } 
2646	public boolean execute ( char value ) { if ( remove ( value ) ) changed = true ; return true ; } 
2647	byte dirTypeForward ( ) { lastChar = text . charAt ( charIndex ) ; if ( Character . isHighSurrogate ( lastChar ) ) { int codePoint = Character . codePointAt ( text , charIndex ) ; charIndex + = Character . charCount ( codePoint ) ; return getDirectionality ( codePoint ) ; } charIndex + + ; byte dirType = getCachedDirectionality ( lastChar ) ; if ( isHtml ) { Process tags and entities . if ( lastChar = = ' < ' ) { dirType = skipTagForward ( ) ; } else if ( lastChar = = ' & ' ) { dirType = skipEntityForward ( ) ; } } return dirType ; } 
2648	private Map < String , Object > translateAnd ( RexNode node _NUM ) { eqMap . clear ( ) ; multimap . clear ( ) ; for ( RexNode node : RelOptUtil . conjunctions ( node _NUM ) ) { translateMatch _NUM ( node ) ; } Map < String , Object > map = builder . map ( ) ; for ( Map . Entry < String , RexLiteral > entry : eqMap . entrySet ( ) ) { multimap . removeAll ( entry . getKey ( ) ) ; map . put ( entry . getKey ( ) , literalValue ( entry . getValue ( ) ) ) ; } for ( Map . Entry < String , Collection < Pair < String , RexLiteral > > > entry : multimap . asMap ( ) . entrySet ( ) ) { Map < String , Object > map _NUM = builder . map ( ) ; for ( Pair < String , RexLiteral > s : entry . getValue ( ) ) { addPredicate ( map _NUM , s . left , literalValue ( s . right ) ) ; } map . put ( entry . getKey ( ) , map _NUM ) ; } return map ; } 
2649	public String getString ( String key ) { return ( String ) get ( key ) ; } 
2650	private void animatePropertyBy ( int constantName , float startValue , float byValue ) { First , cancel any existing animations on this property if ( mAnimatorMap . size ( ) > _NUM ) { Animator animatorToCancel = null ; Set < Animator > animatorSet = mAnimatorMap . keySet ( ) ; for ( Animator runningAnim : animatorSet ) { PropertyBundle bundle = mAnimatorMap . get ( runningAnim ) ; if ( bundle . cancel ( constantName ) ) { there can only ever be one such animation running . if ( bundle . mPropertyMask = = NONE ) { the animation is no longer changing anything - cancel it animatorToCancel = runningAnim ; break ; } } } if ( animatorToCancel ! = null ) { animatorToCancel . cancel ( ) ; } } NameValuesHolder nameValuePair = new NameValuesHolder ( constantName , startValue , byValue ) ; mPendingAnimations . add ( nameValuePair ) ; mView . removeCallbacks ( mAnimationStarter ) ; mView . postOnAnimation ( mAnimationStarter ) ; } 
2651	public Edge < I , E > createEdge ( ) { if ( isEdgeValueNullWritable ( ) ) { return ( Edge < I , E > ) EdgeFactory . create ( createVertexId ( ) ) ; } else { return EdgeFactory . create ( createVertexId ( ) , createEdgeValue ( ) ) ; } } 
2652	public Filter parseFilterString ( byte [ ] filterStringAsByteArray ) throws CharacterCodingException { stack for the operators and parenthesis Stack < ByteBuffer > operatorStack = new Stack < > ( ) ; stack for the filter objects Stack < Filter > filterStack = new Stack < > ( ) ; Filter filter = null ; for ( int i = _NUM ; i < filterStringAsByteArray . length ; i + + ) { if ( filterStringAsByteArray [ i ] = = ParseConstants . LPAREN ) { LPAREN found operatorStack . push ( ParseConstants . LPAREN _ BUFFER ) ; } else if ( filterStringAsByteArray [ i ] = = ParseConstants . WHITESPACE | | filterStringAsByteArray [ i ] = = ParseConstants . TAB ) { WHITESPACE or TAB found continue ; } else if ( checkForOr ( filterStringAsByteArray , i ) ) { OR found i + = ParseConstants . OR _ ARRAY . length - _NUM ; reduce ( operatorStack , filterStack , ParseConstants . OR _ BUFFER ) ; operatorStack . push ( ParseConstants . OR _ BUFFER ) ; } else if ( checkForAnd ( filterStringAsByteArray , i ) ) { AND found i + = ParseConstants . AND _ ARRAY . length - _NUM ; reduce ( operatorStack , filterStack , ParseConstants . AND _ BUFFER ) ; operatorStack . push ( ParseConstants . AND _ BUFFER ) ; } else if ( checkForSkip ( filterStringAsByteArray , i ) ) { SKIP found i + = ParseConstants . SKIP _ ARRAY . length - _NUM ; reduce ( operatorStack , filterStack , ParseConstants . SKIP _ BUFFER ) ; operatorStack . push ( ParseConstants . SKIP _ BUFFER ) ; } else if ( checkForWhile ( filterStringAsByteArray , i ) ) { WHILE found i + = ParseConstants . WHILE _ ARRAY . length - _NUM ; reduce ( operatorStack , filterStack , ParseConstants . WHILE _ BUFFER ) ; operatorStack . push ( ParseConstants . WHILE _ BUFFER ) ; } else if ( filterStringAsByteArray [ i ] = = ParseConstants . RPAREN ) { RPAREN found if ( operatorStack . empty ( ) ) { throw new IllegalArgumentException ( _STR ) ; } return filter ; } 
2653	public void doPost ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { doGet ( request , response ) ; } 
2654	public static final Intent getPieChartIntent ( Context context , CategorySeries dataset , DefaultRenderer renderer , String activityTitle ) { checkParameters ( dataset , renderer ) ; Intent intent = new Intent ( context , GraphicalActivity . class ) ; PieChart chart = new PieChart ( dataset , renderer ) ; intent . putExtra ( CHART , chart ) ; intent . putExtra ( TITLE , activityTitle ) ; return intent ; } 
2655	public void process ( VirtualMachineProfile vmProfile , DeploymentPlan plan , ExcludeList avoid ) throws AffinityConflictException { VirtualMachine vm = vmProfile . getVirtualMachine ( ) ; List < AffinityGroupVMMapVO > vmGroupMappings = _ affinityGroupVMMapDao . findByVmIdType ( vm . getId ( ) , getType ( ) ) ; DataCenter dc = _ dcDao . findById ( vm . getDataCenterId ( ) ) ; List < DedicatedResourceVO > resourceList = new ArrayList < DedicatedResourceVO > ( ) ; if ( vmGroupMappings ! = null & & ! vmGroupMappings . isEmpty ( ) ) { for ( AffinityGroupVMMapVO vmGroupMapping : vmGroupMappings ) { if ( vmGroupMapping ! = null ) { if ( s _ logger . isDebugEnabled ( ) ) { s _ logger . debug ( _STR + avoid . getHostsToAvoid ( ) ) ; } } } } 
2656	private PCollection < Event > sourceEventsFromSynthetic ( Pipeline p ) { if ( isStreaming ( ) ) { NexmarkUtils . console ( _STR , NexmarkUtils . batchEventsSource ( configuration ) ) ; } } 
2657	public synchronized void recoverRunningTopology ( final LocalAssignment currentAssignment , final int port , final BlobChangingCallback cb ) throws IOException { final PortAndAssignment pna = new PortAndAssignment ( port , currentAssignment ) ; final String topologyId = pna . getToplogyId ( ) ; LocallyCachedBlob topoJar = getTopoJar ( topologyId ) ; topoJar . addReference ( pna , cb ) ; LocallyCachedBlob topoCode = getTopoCode ( topologyId ) ; topoCode . addReference ( pna , cb ) ; LocallyCachedBlob topoConf = getTopoConf ( topologyId ) ; topoConf . addReference ( pna , cb ) ; CompletableFuture < Void > localResource = blobPending . get ( topologyId ) ; if ( localResource = = null ) { localResource = ALL _ DONE _ FUTURE ; blobPending . put ( topologyId , localResource ) ; } try { addReferencesToBlobs ( pna , cb ) ; } catch ( KeyNotFoundException | AuthorizationException e ) { LOG . error ( _STR , topologyId , localResource ) ; } 
2658	public void init ( XMLStreamReader xsr , boolean startWithCurrentEvent , SchemaType contentType , SchemaTypeLoader stl , XmlOptions options , Collection errorListener ) { _ packTextXmlStreamReader . init ( xsr ) ; setParent ( xsr ) ; setParent ( _ packTextXmlStreamReader ) ; _ contentType = contentType ; _ stl = stl ; _ options = options ; _ errorListener = errorListener ; _ elemEvent . setXMLStreamReader ( xsr ) ; _ attEvent . setXMLStreamReader ( xsr ) ; _ simpleEvent . setXMLStreamReader ( xsr ) ; _ elemEvent . setXMLStreamReader ( _ packTextXmlStreamReader ) ; _ attEvent . setXMLStreamReader ( _ packTextXmlStreamReader ) ; _ simpleEvent . setXMLStreamReader ( _ packTextXmlStreamReader ) ; _ validator = null ; _ state = STATE _ FIRSTEVENT ; if ( _ attNamesList ! = null ) { _ attNamesList . clear ( ) ; _ attValuesList . clear ( ) ; } _ xsiType = null ; _ depth = _NUM ; if ( startWithCurrentEvent ) { int evType = getEventType ( ) ; validate _ event ( evType ) ; } } 
2659	public void commitNowNoEffect ( ) throws Throwable { final FragmentManager fm = mActivityRule . getActivity ( ) . getSupportFragmentManager ( ) ; fm . beginTransaction ( ) . remove ( mBeginningFragment ) . setReorderingAllowed ( true ) . commit ( ) ; FragmentTestUtil . waitForExecution ( mActivityRule ) ; FragmentTestUtil . setContentView ( mActivityRule , R . layout . double _ container ) ; final TransitionFragment fragment _NUM = new PostponedFragment _NUM ( ) ; final TransitionFragment fragment _NUM = new PostponedFragment _NUM ( ) ; fm . beginTransaction ( ) . add ( R . id . fragmentContainer _NUM , fragment _NUM ) . add ( R . id . fragmentContainer _NUM , fragment _NUM ) . setReorderingAllowed ( true ) . commit ( ) ; FragmentTestUtil . waitForExecution ( mActivityRule ) ; fragment _NUM . startPostponedEnterTransition ( ) ; fragment _NUM . startPostponedEnterTransition ( ) ; fragment _NUM . waitForTransition ( ) ; fragment _NUM . waitForTransition ( ) ; clearTargets ( fragment _NUM ) ; clearTargets ( fragment _NUM ) ; final View startBlue _NUM = fragment _NUM . getView ( ) . findViewById ( R . id . blueSquare ) ; final View startBlue _NUM = fragment _NUM . getView ( ) . findViewById ( R . id . blueSquare ) ; final TransitionFragment fragment _NUM = new PostponedFragment _NUM ( ) ; final StrictFragment strictFragment _NUM = new StrictFragment ( ) ; fm . beginTransaction ( ) . addSharedElement ( startBlue _NUM , _STR ) . setReorderingAllowed ( true ) . commitNow ( ) ; } } ) ; FragmentTestUtil . waitForExecution ( mActivityRule ) ; assertPostponedTransition ( fragment _NUM , fragment _NUM , null ) ; assertPostponedTransition ( fragment _NUM , fragment _NUM , null ) ; start the postponed transition fragment _NUM . startPostponedEnterTransition ( ) ; make sure only one ran assertForwardTransition ( fragment _NUM , fragment _NUM ) ; assertPostponedTransition ( fragment _NUM , fragment _NUM , null ) ; start the postponed transition fragment _NUM . startPostponedEnterTransition ( ) ; make sure it ran assertForwardTransition ( fragment _NUM , fragment _NUM ) ; } 
2660	public static String getQualifiedTableName ( String schemaName , String tableName ) { if ( schemaName ! = null ) { return String . format ( _STR , normalizeIdentifier ( schemaName ) , normalizeIdentifier ( tableName ) ) ; } else { return normalizeIdentifier ( tableName ) ; } } 
2661	public void initConfiguration ( ) throws IOException { setAlluxioWorkDirectory ( ) ; setHostname ( ) ; for ( Entry < PropertyKey , String > entry : ConfigurationTestUtils . testConfigurationDefaults ( mHostname , mWorkDirectory ) . entrySet ( ) ) { Configuration . set ( entry . getKey ( ) , entry . getValue ( ) ) ; } Configuration . set ( PropertyKey . TEST _ MODE , true ) ; Configuration . set ( PropertyKey . MASTER _ RPC _ PORT , _NUM ) ; Configuration . set ( PropertyKey . MASTER _ WEB _ PORT , _NUM ) ; Configuration . set ( PropertyKey . PROXY _ WEB _ PORT , _NUM ) ; Configuration . set ( PropertyKey . WORKER _ RPC _ PORT , _NUM ) ; Configuration . set ( PropertyKey . WORKER _ DATA _ PORT , _NUM ) ; Configuration . set ( PropertyKey . WORKER _ WEB _ PORT , _NUM ) ; } 
2662	public void dispatchDrawableHotspotChanged ( float x , float y ) { final int count = mChildrenCount ; if ( count = = _NUM ) { return ; } final View [ ] children = mChildren ; for ( int i = _NUM ; i < count ; i + + ) { final View child = children [ i ] ; Children that are clickable on their own should not receive hotspots when their parent view does . final boolean nonActionable = ! child . isClickable ( ) & & ! child . isLongClickable ( ) ; final boolean duplicatesState = ( child . mViewFlags & DUPLICATE _ PARENT _ STATE ) ! = _NUM ; if ( nonActionable | | duplicatesState ) { final float [ ] point = getTempPoint ( ) ; point [ _NUM ] = x ; point [ _NUM ] = y ; transformPointToViewLocal ( point , child ) ; child . drawableHotspotChanged ( point [ _NUM ] , point [ _NUM ] ) ; } } } 
2663	public PutObjectResult uploadFrom ( final byte [ ] buffer , RequestMetricCollector requestMetricCollector ) { final ObjectMetadata objectMetadata = new ObjectMetadata ( ) ; objectMetadata . setContentLength ( buffer . length ) ; final PutObjectRequest req = new PutObjectRequest ( getBucketName ( ) , getKey ( ) , new ByteArrayInputStream ( buffer ) , objectMetadata ) . withRequestMetricCollector ( requestMetricCollector ) ; return getAmazonS _NUM Client ( ) . putObject ( req ) ; } 
2664	private char handleCSSComment ( ExtInputStreamReader r ) throws IOException { char c = r . readCharFromReader ( ) ; if ( c = = ' * ' ) { char lastC = ' \ _NUM ' ; while ( ( c ! = ' / ' ) | | ( lastC ! = ' * ' ) ) { lastC = c ; c = r . readCharFromReader ( ) ; } c = r . readCharFromReader ( ) ; while ( ( ( byte ) c ) ! = - _NUM & & isWhiteSpace ( c ) ) { skip white spaces c = r . readCharFromReader ( ) ; } } else { r . unreadChar ( c ) ; return ' / ' ; } return c ; } 
2665	private boolean validateParameters ( ) { boolean allOk = true ; StringBuffer validationErrors = new StringBuffer ( _NUM _NUM ) ; CmsMessages messages = Messages . get ( ) . getBundle ( getLocale ( ) ) ; check resource parameter presence if ( CmsStringUtil . isEmptyOrWhitespaceOnly ( getParamResource ( ) ) | | ! getCms ( ) . existsResource ( getParamResource ( ) ) ) { allOk = false ; validationErrors . append ( messages . key ( Messages . GUI _ PROP _ CHANGE _ VALIDATE _ VFS _ RESOURCE _ _NUM ) ) . append ( _STR ) ; } } check new property value if ( CmsStringUtil . isEmptyOrWhitespaceOnly ( getParamNewValue ( ) ) ) { if no new value was given , set it to the delete value setParamNewValue ( CmsProperty . DELETE _ VALUE ) ; } setErrorMessage ( validationErrors . toString ( ) ) ; setValidationErrors ( ! allOk ) ; return allOk ; } 
2666	public void validate ( TimeStampRequest request ) throws TSPException { TimeStampToken tok = this . getTimeStampToken ( ) ; if ( tok ! = null ) { TimeStampTokenInfo tstInfo = tok . getTimeStampInfo ( ) ; if ( request . getNonce ( ) ! = null & & ! request . getNonce ( ) . equals ( tstInfo . getNonce ( ) ) ) { throw new TSPValidationException ( _STR ) ; } } 
2667	private void populateServices ( ) throws AmbariException { for ( ServiceDirectory serviceDir : stackDirectory . getServiceDirectories ( ) ) { populateService ( serviceDir ) ; } } 
2668	 @ edu . umd . cs . findbugs . annotations . SuppressWarnings ( value = _STR + ( maxOffset - ptr . getOffset ( ) ) ) . build ( ) . buildException ( ) ) ; } ptr . set ( ptr . get ( ) , ptr . getOffset ( ) , length ) ; return ptr . getLength ( ) > _NUM ; } return false ; } 
2669	public int setUpBoundaryPanel ( ) throws Exception { OK code . int returner = _NUM ; int tempSamples = m _ numberOfSamplesFromEachRegion ; try { tempSamples = Integer . parseInt ( m _ regionSamplesText . getText ( ) . trim ( ) ) ; } catch ( Exception ex ) { m _ regionSamplesText . setText ( _STR + tempSamples ) ; } m _ kernelBandwidth = tempSamples ; m _ dataGenerator . setKernelBandwidth ( tempSamples ) ; if ( m _ kernelBandwidth < _NUM ) returner = _NUM ; if ( m _ kernelBandwidth > = m _ trainingInstances . numInstances ( ) ) returner = _NUM ; m _ trainingInstances . setClassIndex ( m _ classAttBox . getSelectedIndex ( ) ) ; m _ boundaryPanel . setClassifier ( m _ classifier ) ; m _ boundaryPanel . setTrainingData ( m _ trainingInstances ) ; m _ boundaryPanel . setXAttribute ( m _ xIndex ) ; m _ boundaryPanel . setYAttribute ( m _ yIndex ) ; m _ boundaryPanel . setPlotTrainingData ( m _ plotTrainingData . isSelected ( ) ) ; return returner ; } 
2670	public void post ( String jsonBody , Integer expectedResponseCode ) throws IOException { HttpURLConnection conn = getUrlConnection ( ) ; try { send post request with json body for the topology if ( ! NetworkUtils . sendHttpPostRequest ( conn , NetworkUtils . JSON _ TYPE , jsonBody . getBytes ( ) ) ) { throw new IOException ( _STR + conn . getResponseCode ( ) ) ; } } finally { conn . disconnect ( ) ; } } 
2671	public static com . google . api . client . util . BackOff toGcpBackOff ( final BackOff backOff ) { return new com . google . api . client . util . BackOff ( ) { @ Override public void reset ( ) throws IOException { backOff . reset ( ) ; } @ Override public long nextBackOffMillis ( ) throws IOException { return backOff . nextBackOffMillis ( ) ; } } ; } 
2672	public int addChildAfter ( Record newChild , Record after ) { Decide where we ' re going to put it int loc = findChildLocation ( after ) ; if ( loc = = - _NUM ) { throw new IllegalArgumentException ( _STR ) ; } Add one place after the supplied record addChildAt ( newChild , loc + _NUM ) ; return loc + _NUM ; } 
2673	public String getName ( ) { return decode ( encodedName ) ; } 
2674	public final void setOnHold ( ) { checkImmutable ( ) ; setState ( STATE _ HOLDING ) ; } 
2675	public CmsDetailPageInfo getMainDetailPage ( String type ) { List < CmsDetailPageInfo > detailPages = getDetailPagesForType ( type ) ; if ( ( detailPages = = null ) | | detailPages . isEmpty ( ) ) { return null ; } return detailPages . get ( _NUM ) ; } 
2676	copyvoid mutate ( ) { flip a bit do { int iBit ; do { iBit = m _ random . nextInt ( m _ nNodes * m _ nNodes ) ; } while ( isSquare ( iBit ) ) ; m _ bits [ iBit ] = ! m _ bits [ iBit ] ; } while ( hasCycles ( ) ) ; calcGlobalScore ( ) ; } 
2677	public static final String convertToString ( byte [ ] bytes , String encoding ) { if ( bytes = = null ) return PdfObject . NOTHING ; if ( encoding = = null | | encoding . length ( ) = = _NUM ) { char [ ] c = new char [ bytes . length ] ; for ( int k = _NUM ; k < bytes . length ; + + k ) c [ k ] = ( char ) ( bytes [ k ] & _NUM xff ) ; return new String ( c ) ; } ExtraEncoding extra = ( ExtraEncoding ) extraEncodings . get ( encoding . toLowerCase ( ) ) ; if ( extra ! = null ) { String text = extra . byteToChar ( bytes , encoding ) ; if ( text ! = null ) return text ; } char [ ] ch = null ; if ( encoding . equals ( BaseFont . WINANSI ) ) ch = winansiByteToChar ; else if ( encoding . equals ( PdfObject . TEXT _ PDFDOCENCODING ) ) ch = pdfEncodingByteToChar ; if ( ch ! = null ) { int len = bytes . length ; char [ ] c = new char [ len ] ; for ( int k = _NUM ; k < len ; + + k ) { c [ k ] = ch [ bytes [ k ] & _NUM xff ] ; } return new String ( c ) ; } try { return new String ( bytes , encoding ) ; } catch ( UnsupportedEncodingException e ) { throw new ExceptionConverter ( e ) ; } } 
2678	public final int getMainItemCount ( ) { return hasFilter ( ) ? getItemCount ( ) : getItemCount ( ) - mScrollableHeaders . size ( ) - mScrollableFooters . size ( ) ; } 
2679	void notifyIdle ( ) { No package has changed : we are just triggering because the device is idle and there * might * be work to do . final boolean packageChanged = false ; mPackageTracker . triggerUpdateIfNeeded ( packageChanged ) ; } 
2680	public void setRangeZeroBaselinePaint ( Paint paint ) { if ( paint = = null ) { throw new IllegalArgumentException ( _STR ) ; } this . rangeZeroBaselinePaint = paint ; fireChangeEvent ( ) ; } 
2681	public void setPermission ( String name , boolean value ) { permissions . put ( name . toLowerCase ( ) , value ) ; permissible . recalculatePermissions ( ) ; } 
2682	boolean forAllWindows ( ToBooleanFunction < WindowState > callback , boolean traverseTopToBottom ) { if ( traverseTopToBottom ) { for ( int i = mChildren . size ( ) - _NUM ; i > = _NUM ; - - i ) { if ( mChildren . get ( i ) . forAllWindows ( callback , traverseTopToBottom ) ) { return true ; } } } else { final int count = mChildren . size ( ) ; for ( int i = _NUM ; i < count ; i + + ) { if ( mChildren . get ( i ) . forAllWindows ( callback , traverseTopToBottom ) ) { return true ; } } } return false ; } 
2683	public void sequencerFailoverBackpointerCheck ( ) throws Exception { getManagementTestLayout ( ) ; UUID streamA = UUID . nameUUIDFromBytes ( _STR . getBytes ( ) ) ; final long streamA _ backpointerRecovered = _NUM L ; final long streamB _ backpointerRecovered = _NUM L ; final long streamA _ backpointerFinal = _NUM L ; final long streamB _ backpointerFinal = _NUM L ; getTokenWriteAndAssertBackPointer ( streamA , Address . NON _ EXIST ) ; getTokenWriteAndAssertBackPointer ( streamB , Address . NON _ EXIST ) ; getTokenWriteAndAssertBackPointer ( streamA , _NUM L ) ; getTokenWriteAndAssertBackPointer ( streamB , _NUM L ) ; induceSequencerFailureAndWait ( ) ; getTokenWriteAndAssertBackPointer ( streamA , streamA _ backpointerRecovered ) ; getTokenWriteAndAssertBackPointer ( streamC , Address . NON _ EXIST ) ; getTokenWriteAndAssertBackPointer ( streamA , streamA _ backpointerFinal ) ; getTokenWriteAndAssertBackPointer ( streamB , streamB _ backpointerRecovered ) ; getTokenWriteAndAssertBackPointer ( streamB , streamB _ backpointerFinal ) ; } 
2684	public static void load ( DatasetGraphTDB dataset , InputStream input , boolean showProgress ) { TDBLoader loader = new TDBLoader ( ) ; loader . setShowProgress ( showProgress ) ; TODO Lang version loader . loadDataset ( dataset , input ) ; } 
2685	protected void initBrowseItemChangeListener ( ) { CollectionDatasource browseDs = getTable ( ) . getDatasource ( ) ; Datasource editDs = getFieldGroup ( ) . getDatasource ( ) ; browseDs . addItemChangeListener ( e - > { if ( e . getItem ( ) ! = null ) { Entity reloadedItem = getDsContext ( ) . getDataSupplier ( ) . reload ( e . getDs ( ) . getItem ( ) , editDs . getView ( ) ) ; editDs . setItem ( reloadedItem ) ; } } ) ; } 
2686	public void add ( int idx , Record record ) { if ( idx ! = numSlot ) { checkBounds ( idx , numSlot ) ; Changes count . shiftUp ( idx ) ; } else { if ( numSlot > = maxSlot ) throw new BufferException ( format ( _STR , idx , maxSlot ) ) ; numSlot + + ; } _ set ( idx , record ) ; } 
2687	public UserInfo createRestrictedProfile ( String name ) { try { UserHandle parentUserHandle = Process . myUserHandle ( ) ; UserInfo user = mService . createRestrictedProfile ( name , parentUserHandle . getIdentifier ( ) ) ; if ( user ! = null ) { AccountManager . get ( mContext ) . addSharedAccountsFromParentUser ( parentUserHandle , UserHandle . of ( user . id ) ) ; } return user ; } catch ( RemoteException re ) { throw re . rethrowFromSystemServer ( ) ; } } 
2688	public void write ( DataOutput out ) throws IOException { String aclString = getAclString ( ) ; Text . writeString ( out , aclString ) ; } 
2689	public IndexEntry add ( final byte [ ] key , final int count , final long offset ) { final int hash = hash ( key ) ; rwl . writeLock ( ) . lock ( ) ; try { purge ( ) ; final int i = indexFor ( hash , buckets . length ) ; BucketEntry current = buckets [ i ] , prev = current ; while ( current ! = null ) { final BucketEntry next = current . next ; final IndexEntry entry = current . get ( ) ; if ( entry = = null ) { delete ( i , current , prev , next ) ; } else if ( current . hash = = hash & & eq ( entry . key , key ) ) { update ( entry , count , offset ) ; return entry ; } prev = current ; current = next ; } final IndexEntry entry = new IndexEntry ( key , count , offset ) ; add ( i , hash , entry ) ; return entry ; } finally { rwl . writeLock ( ) . unlock ( ) ; } } 
2690	public String getSystemLockInfo ( boolean forExplorer ) { if ( getLock ( ) . getSystemLock ( ) . isPublish ( ) ) { if ( ! forExplorer ) { return getMessages ( ) . key ( Messages . GUI _ PUBLISH _ TOOLTIP _ _NUM ) ; } else { should have length = = _NUM return _STR ; } 
2691	public void getNull ( ) throws IOException { goTo ( NULL ) ; } 
2692	public void seriesChanged ( SeriesChangeEvent event ) { if ( this . propagateEvents ) { updateXPoints ( ) ; fireDatasetChanged ( ) ; } } 
2693	public RelBuilder aggregate ( GroupKey groupKey , Iterable < AggCall > aggCalls ) { final Registrar registrar = new Registrar ( ) ; registrar . extraNodes . addAll ( fields ( ) ) ; registrar . names . addAll ( peek ( ) . getRowType ( ) . getFieldNames ( ) ) ; final GroupKeyImpl groupKey _ = ( GroupKeyImpl ) groupKey ; final ImmutableBitSet groupSet = ImmutableBitSet . of ( registrar . registerExpressions ( groupKey _ . nodes ) ) ; label : if ( Iterables . isEmpty ( aggCalls ) & & ! groupKey _ . indicator ) { final RelMetadataQuery mq = peek ( ) . getCluster ( ) . getMetadataQuery ( ) ; if ( groupSet . isEmpty ( ) ) { final Double minRowCount = mq . getMinRowCount ( peek ( ) ) ; if ( minRowCount = = null | | minRowCount < _NUM D ) { empty . break label ; } } if ( registrar . extraNodes . size ( ) = = fields ( ) . size ( ) ) { final Boolean unique = mq . areColumnsUnique ( peek ( ) , groupSet ) ; if ( unique ! = null & & unique ) { Rel is already unique . return project ( fields ( groupSet . asList ( ) ) ) ; } } final Double maxRowCount = mq . getMaxRowCount ( peek ( ) ) ; if ( maxRowCount ! = null & & maxRowCount < = _NUM D ) { If there is at most one row , rel is already unique . return this ; } } final ImmutableList < ImmutableBitSet > groupSets ; if ( groupKey _ . nodeLists ! = null ) { final int sizeBefore = registrar . extraNodes . size ( ) ; final SortedSet < ImmutableBitSet > groupSetSet = new TreeSet < > ( ImmutableBitSet . ORDERING ) ; for ( ImmutableList < RexNode > nodeList : groupKey _ . nodeLists ) { final ImmutableBitSet groupSet _NUM = ImmutableBitSet . of ( registrar . registerExpressions ( nodeList ) ) ; if ( ! groupSet . contains ( groupSet _NUM ) ) { throw new IllegalArgumentException ( _STR ) ; } aggregateCall = AggregateCall . create ( aggCall _NUM . aggFunction , aggCall _NUM . distinct , aggCall _NUM . approximate , args , filterArg , groupSet . cardinality ( ) , r , null , aggCall _NUM . alias ) ; } else { aggregateCall = ( ( AggCallImpl _NUM ) aggCall ) . aggregateCall ; } aggregateCalls . add ( aggregateCall ) ; } assert ImmutableBitSet . ORDERING . isStrictlyOrdered ( groupSets ) : groupSets ; for ( ImmutableBitSet set : groupSets ) { assert groupSet . contains ( set ) ; } RelNode aggregate = aggregateFactory . createAggregate ( r , groupKey _ . indicator , groupSet , groupSets , aggregateCalls ) ; build field list final ImmutableList . Builder < Field > fields = ImmutableList . builder ( ) ; final List < RelDataTypeField > aggregateFields = aggregate . getRowType ( ) . getFieldList ( ) ; int i = _NUM ; first , group fields for ( Integer groupField : groupSet . asList ( ) ) { RexNode node = registrar . extraNodes . get ( groupField ) ; final SqlKind kind = node . getKind ( ) ; switch ( kind ) { case INPUT _ REF : fields . add ( frame . fields . get ( ( ( RexInputRef ) node ) . getIndex ( ) ) ) ; break ; default : String name = aggregateFields . get ( i ) . getName ( ) ; RelDataTypeField fieldType = new RelDataTypeFieldImpl ( name , i , node . getType ( ) ) ; fields . add ( new Field ( ImmutableSet . < String > of ( ) , fieldType ) ) ; break ; } i + + ; } second , indicator fields ( copy from aggregate rel type ) if ( groupKey _ . indicator ) { for ( int j = _NUM ; j < groupSet . cardinality ( ) ; + + j ) { final RelDataTypeField field = aggregateFields . get ( i ) ; final RelDataTypeField fieldType = new RelDataTypeFieldImpl ( field . getName ( ) , i , field . getType ( ) ) ; fields . add ( new Field ( ImmutableSet . < String > of ( ) , fieldType ) ) ; i + + ; } } third , aggregate fields . retain ` i ' as field index for ( int j = _NUM ; j < aggregateCalls . size ( ) ; + + j ) { final AggregateCall call = aggregateCalls . get ( j ) ; final RelDataTypeField fieldType = new RelDataTypeFieldImpl ( aggregateFields . get ( i + j ) . getName ( ) , i + j , call . getType ( ) ) ; fields . add ( new Field ( ImmutableSet . < String > of ( ) , fieldType ) ) ; } stack . push ( new Frame ( aggregate , fields . build ( ) ) ) ; return this ; } 
2694	public Builder clearError ( ) { if ( errorBuilder _ = = null ) { error _ = org . bitcoin . paymentchannel . Protos . Error . getDefaultInstance ( ) ; onChanged ( ) ; } else { errorBuilder _ . clear ( ) ; } bitField _NUM _ = ( bitField _NUM _ & ~ _NUM x _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM ) ; return this ; } 
2695	private void freezeAndPointToNewState ( String previousWord , int i ) throws IOException { State state = tempStates . get ( i - _NUM ) ; char previousWordChar = previousWord . charAt ( i - _NUM ) ; int output = state . findArc ( previousWordChar ) . getOutput ( ) ; state . arcs . remove ( state . findArc ( previousWordChar ) ) ; Arc arcToFrozenState = state . setArc ( previousWordChar , output , findEquivalentState ( tempStates . get ( i ) ) ) ; compiler . compileState ( arcToFrozenState . getDestination ( ) ) ; } 
2696	public void setBucketLogging ( SetBucketLoggingRequest setBucketLoggingRequest ) throws OSSException , ClientException { assertParameterNotNull ( setBucketLoggingRequest , _STR ) ; ensureBucketNameValid ( bucketName ) ; Map < String , String > params = new HashMap < String , String > ( ) ; params . put ( SUBRESOURCE _ LOGGING , null ) ; RequestMessage request = new OSSRequestMessageBuilder ( getInnerClient ( ) ) . setEndpoint ( getEndpoint ( ) ) . setMethod ( HttpMethod . PUT ) . setBucket ( bucketName ) . setParameters ( params ) . setInputStreamWithLength ( setBucketLoggingRequestMarshaller . marshall ( setBucketLoggingRequest ) ) . setOriginalRequest ( setBucketLoggingRequest ) . build ( ) ; doOperation ( request , emptyResponseParser , bucketName , null ) ; } 
2697	Checks to see if any coins are controlled by rotating keys and if so , spends them . @ GuardedBy ( _STR ) ; keyChainGroup . createAndActivateNewHDChain ( ) ; } saveNow ( ) ; } Because transactions are size limited , we might not be able to re - key the entire wallet in one go . So loop around here until we no longer produce transactions with the max number of inputs . That means we ' re fully done , at least for now ( we may still get more transactions later and this method will be reinvoked ) . Transaction tx ; do { tx = rekeyOneBatch ( keyRotationTimestamp , aesKey , results , sign ) ; if ( tx ! = null ) results . add ( tx ) ; } while ( tx ! = null & & tx . getInputs ( ) . size ( ) = = KeyTimeCoinSelector . MAX _ SIMULTANEOUS _ INPUTS ) ; return results ; } 
2698	public IntegerPolynomial mult ( IntegerPolynomial poly _NUM ) { int N = coeffs . length ; if ( poly _NUM . coeffs . length ! = N ) { throw new IllegalArgumentException ( _STR ) ; } IntegerPolynomial c = multRecursive ( poly _NUM ) ; if ( c . coeffs . length > N ) { for ( int k = N ; k < c . coeffs . length ; k + + ) { c . coeffs [ k - N ] + = c . coeffs [ k ] ; } c . coeffs = Arrays . copyOf ( c . coeffs , N ) ; } return c ; } 
2699	public static X _NUM _NUM _NUM Certificate [ ] readCertificates ( Parcel in ) { int length = in . readInt ( ) ; if ( length = = _NUM ) { return null ; } X _NUM _NUM _NUM Certificate [ ] certs = new X _NUM _NUM _NUM Certificate [ length ] ; for ( int i = _NUM ; i < length ; i + + ) { certs [ i ] = readCertificate ( in ) ; } return certs ; } 
2700	public int delete ( Uri uri , String selection , String [ ] selectionArgs ) { final int uriType = uriMatcher . match ( uri ) ; int rowsDeleted = _NUM ; ensureDatabaseOpen ( ) ; switch ( uriType ) { case TRANSFERS : rowsDeleted = database . delete ( TransferTable . TABLE _ TRANSFER , selection , selectionArgs ) ; break ; case TRANSFER _ ID : final String id = uri . getLastPathSegment ( ) ; if ( TextUtils . isEmpty ( selection ) ) { rowsDeleted = database . delete ( TransferTable . TABLE _ TRANSFER , TransferTable . COLUMN _ ID + _STR + uri ) ; } return rowsDeleted ; } 
2701	public Builder clearDataTableColRefForCoveredColumns ( ) { if ( dataTableColRefForCoveredColumnsBuilder _ = = null ) { dataTableColRefForCoveredColumns _ = java . util . Collections . emptyList ( ) ; bitField _NUM _ = ( bitField _NUM _ & ~ _NUM x _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM ) ; onChanged ( ) ; } else { dataTableColRefForCoveredColumnsBuilder _ . clear ( ) ; } return this ; } 
2702	public void setUri ( String uri ) { clear ( ) ; this . uri = uri ; } 
2703	public static FieldIdentifier forInternalString ( String text ) { whatever case the text has . return forQuoted ( text ) ; } 
2704	 @ GuardedBy ( _STR + paths . get ( i ) ) ; } Append shared libraries with split dependencies for this split . String path = paths . get ( i ) ; if ( options . getSplitName ( ) ! = null ) { what we are looking for . if ( ! options . getSplitName ( ) . equals ( new File ( path ) . getName ( ) ) ) { continue ; } } String profileName = ArtManager . getProfileName ( i = = _NUM ? null : pkg . splitNames [ i - _NUM ] ) ; String dexMetadataPath = null ; if ( options . isDexoptInstallWithDexMetadata ( ) ) { File dexMetadataFile = DexMetadataHelper . findDexMetadataForFile ( new File ( path ) ) ; dexMetadataPath = dexMetadataFile = = null ? null : dexMetadataFile . getAbsolutePath ( ) ; } final boolean isUsedByOtherApps = options . isDexoptAsSharedLibrary ( ) | | packageUseInfo . isUsedByOtherApps ( path ) ; final String compilerFilter = getRealCompilerFilter ( pkg . applicationInfo , options . getCompilerFilter ( ) , isUsedByOtherApps ) ; final boolean profileUpdated = options . isCheckForProfileUpdates ( ) & & isProfileUpdated ( pkg , sharedGid , profileName , compilerFilter ) ; Get the dexopt flags after getRealCompilerFilter to make sure we get the correct flags . final int dexoptFlags = getDexFlags ( pkg , compilerFilter , options ) ; for ( String dexCodeIsa : dexCodeInstructionSets ) { int newResult = dexOptPath ( pkg , path , dexCodeIsa , compilerFilter , profileUpdated , classLoaderContexts [ i ] , dexoptFlags , sharedGid , packageStats , options . isDowngrade ( ) , profileName , dexMetadataPath , options . getCompilationReason ( ) ) ; - SKIPPED when all paths are up to date if ( ( result ! = DEX _ OPT _ FAILED ) & & ( newResult ! = DEX _ OPT _ SKIPPED ) ) { result = newResult ; } } } return result ; } 
2705	private Iterable < LoadingCache < Object , Object > > caches ( ) { lots of different ways to configure a LoadingCache CacheBuilderFactory factory = cacheFactory ( ) ; return Iterables . transform ( factory . buildAllPermutations ( ) , new Function < Caffeine < Object , Object > , LoadingCache < Object , Object > > ( ) { @ Override public LoadingCache < Object , Object > apply ( Caffeine < Object , Object > builder ) { return CaffeinatedGuava . build ( builder , identityLoader ( ) ) ; } } ) ; } 
2706	void init ( ) { if ( mEvaluator = = null ) { We already handle int and float automatically , but not their Object equivalents mEvaluator = ( mValueType = = Integer . class ) ? sIntEvaluator : ( mValueType = = Float . class ) ? sFloatEvaluator : null ; } if ( mEvaluator ! = null ) { KeyframeSet knows how to evaluate the common types - only give it a custom evaluator if one has been set on this class mKeyframeSet . setEvaluator ( mEvaluator ) ; } } 
2707	public int getTaskCount ( ) { return mStackTaskList . size ( ) ; } 
2708	public void setSelectedPosition ( final int position , final ViewHolderTask task ) { if ( task ! = null ) { RecyclerView . ViewHolder vh = findViewHolderForPosition ( position ) ; if ( vh = = null | | hasPendingAdapterUpdates ( ) ) { addOnChildViewHolderSelectedListener ( new OnChildViewHolderSelectedListener ( ) { @ Override public void onChildViewHolderSelectedAndPositioned ( RecyclerView parent , RecyclerView . ViewHolder child , int selectedPosition , int subposition ) { if ( selectedPosition = = position ) { removeOnChildViewHolderSelectedListener ( this ) ; task . run ( child ) ; } } } ) ; } else { task . run ( vh ) ; } } setSelectedPosition ( position ) ; } 
2709	public Set < String > getGroups ( String user ) throws IOException { synchronized ( this ) { rotateIfNeeded ( ) ; if ( cachedGroups . containsKey ( user ) ) { return cachedGroups . get ( user ) ; } } Set < String > groups = getUnixGroups ( user ) ; if ( ! groups . isEmpty ( ) ) { synchronized ( this ) { cachedGroups . put ( user , groups ) ; } } return groups ; } 
2710	void setDataSetChangedAfterLayout ( ) { if ( mDataSetHasChangedAfterLayout ) { return ; } mDataSetHasChangedAfterLayout = true ; final int childCount = mChildHelper . getUnfilteredChildCount ( ) ; for ( int i = _NUM ; i < childCount ; i + + ) { final ViewHolder holder = getChildViewHolderInt ( mChildHelper . getUnfilteredChildAt ( i ) ) ; if ( holder ! = null & & ! holder . shouldIgnore ( ) ) { holder . addFlags ( ViewHolder . FLAG _ ADAPTER _ POSITION _ UNKNOWN ) ; } } mRecycler . setAdapterPositionsAsUnknown ( ) ; immediately mark all views as invalid , so prefetched views can be differentiated from views bound to previous data set - both in children , and cache markKnownViewsInvalid ( ) ; } 
2711	public AggIterOutcome outputCurrentBatch ( ) { when incoming was an empty batch , just finish up if ( schema = = null ) { logger . trace ( _STR ) ; cleanup my internal state since there is nothing more to return this . cleanup ( ) ; } } return AggIterOutcome . AGG _ OK ; } 
2712	public boolean isCphsVoiceMessageClear ( ) { _NUM x _NUM _NUM means _STR return isCphsVoiceMessageIndicatorAddress ( ) & & ( origBytes [ OFFSET _ ADDRESS _ VALUE ] & _NUM xff ) = = _NUM x _NUM _NUM ; } 
2713	public void onInitializeAccessibilityNodeInfo ( View host , AccessibilityNodeInfo info ) { host . onInitializeAccessibilityNodeInfoInternal ( info ) ; } 
2714	public void testTaggedNamesOverridden ( ) throws Exception { DataflowPipelineOptions options = buildPipelineOptions ( ) ; DataflowRunner runner = DataflowRunner . fromOptions ( options ) ; options . setStreaming ( false ) ; DataflowPipelineTranslator translator = DataflowPipelineTranslator . fromOptions ( options ) ; Pipeline pipeline = Pipeline . create ( options ) ; TupleTag < Integer > tag _NUM = new TupleTag < Integer > ( _STR , stepName , i ) ) ) ; } } 
2715	public ECFieldElement sqrt ( ) { int [ ] x _NUM = this . x ; if ( Nat _NUM _NUM _NUM . isZero ( x _NUM ) | | Nat _NUM _NUM _NUM . isOne ( x _NUM ) ) { return this ; } int [ ] x _NUM = Nat _NUM _NUM _NUM . create ( ) ; SecP _NUM _NUM _NUM K _NUM Field . square ( x _NUM , x _NUM ) ; SecP _NUM _NUM _NUM K _NUM Field . multiply ( x _NUM , x _NUM , x _NUM ) ; int [ ] x _NUM = Nat _NUM _NUM _NUM . create ( ) ; SecP _NUM _NUM _NUM K _NUM Field . square ( x _NUM , x _NUM ) ; SecP _NUM _NUM _NUM K _NUM Field . multiply ( x _NUM , x _NUM , x _NUM ) ; int [ ] x _NUM = Nat _NUM _NUM _NUM . create ( ) ; SecP _NUM _NUM _NUM K _NUM Field . squareN ( x _NUM , _NUM , x _NUM ) ; SecP _NUM _NUM _NUM K _NUM Field . multiply ( x _NUM , x _NUM , x _NUM ) ; int [ ] x _NUM = x _NUM ; SecP _NUM _NUM _NUM K _NUM Field . squareN ( x _NUM , _NUM , x _NUM ) ; SecP _NUM _NUM _NUM K _NUM Field . multiply ( x _NUM , x _NUM , x _NUM ) ; int [ ] x _NUM _NUM = x _NUM ; SecP _NUM _NUM _NUM K _NUM Field . squareN ( x _NUM , _NUM , x _NUM _NUM ) ; SecP _NUM _NUM _NUM K _NUM Field . multiply ( x _NUM _NUM , x _NUM , x _NUM _NUM ) ; int [ ] x _NUM _NUM = x _NUM ; SecP _NUM _NUM _NUM K _NUM Field . squareN ( x _NUM _NUM , _NUM , x _NUM _NUM ) ; SecP _NUM _NUM _NUM K _NUM Field . multiply ( x _NUM _NUM , x _NUM , x _NUM _NUM ) ; int [ ] x _NUM _NUM = Nat _NUM _NUM _NUM . create ( ) ; SecP _NUM _NUM _NUM K _NUM Field . squareN ( x _NUM _NUM , _NUM _NUM , x _NUM _NUM ) ; SecP _NUM _NUM _NUM K _NUM Field . multiply ( x _NUM _NUM , x _NUM _NUM , x _NUM _NUM ) ; int [ ] x _NUM _NUM = x _NUM _NUM ; SecP _NUM _NUM _NUM K _NUM Field . squareN ( x _NUM _NUM , _NUM _NUM , x _NUM _NUM ) ; SecP _NUM _NUM _NUM K _NUM Field . multiply ( x _NUM _NUM , x _NUM _NUM , x _NUM _NUM ) ; int [ ] x _NUM _NUM _NUM = x _NUM _NUM ; SecP _NUM _NUM _NUM K _NUM Field . squareN ( x _NUM _NUM , _NUM _NUM , x _NUM _NUM _NUM ) ; SecP _NUM _NUM _NUM K _NUM Field . multiply ( x _NUM _NUM _NUM , x _NUM _NUM , x _NUM _NUM _NUM ) ; int [ ] x _NUM _NUM _NUM = x _NUM _NUM ; SecP _NUM _NUM _NUM K _NUM Field . squareN ( x _NUM _NUM _NUM , _NUM _NUM , x _NUM _NUM _NUM ) ; SecP _NUM _NUM _NUM K _NUM Field . multiply ( x _NUM _NUM _NUM , x _NUM _NUM , x _NUM _NUM _NUM ) ; int [ ] t _NUM = x _NUM _NUM _NUM ; SecP _NUM _NUM _NUM K _NUM Field . squareN ( t _NUM , _NUM _NUM , t _NUM ) ; SecP _NUM _NUM _NUM K _NUM Field . multiply ( t _NUM , x _NUM _NUM , t _NUM ) ; SecP _NUM _NUM _NUM K _NUM Field . squareN ( t _NUM , _NUM , t _NUM ) ; SecP _NUM _NUM _NUM K _NUM Field . multiply ( t _NUM , x _NUM , t _NUM ) ; SecP _NUM _NUM _NUM K _NUM Field . squareN ( t _NUM , _NUM , t _NUM ) ; SecP _NUM _NUM _NUM K _NUM Field . multiply ( t _NUM , x _NUM , t _NUM ) ; SecP _NUM _NUM _NUM K _NUM Field . square ( t _NUM , t _NUM ) ; int [ ] t _NUM = x _NUM ; SecP _NUM _NUM _NUM K _NUM Field . square ( t _NUM , t _NUM ) ; return Nat _NUM _NUM _NUM . eq ( x _NUM , t _NUM ) ? new SecP _NUM _NUM _NUM K _NUM FieldElement ( t _NUM ) : null ; } 
2716	public boolean isDrawerVisible ( int drawerGravity ) { final View drawerView = findDrawerWithGravity ( drawerGravity ) ; if ( drawerView ! = null ) { return isDrawerVisible ( drawerView ) ; } return false ; } 
2717	public void setScreenWidthInCentimeter ( double cm ) { double dotsPerCm = Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) . getWidth ( ) / cm ; getTransformer ( ) . setScreenResolution ( ( int ) ( dotsPerCm * _NUM . _NUM _NUM ) ) ; viewChanged ( MapViewEvent . Type . ZOOM ) ; } 
2718	public double getDouble ( String key ) throws JSONException { Object o = get ( key ) ; try { return o instanceof Number ? ( ( Number ) o ) . doubleValue ( ) : Double . valueOf ( ( String ) o ) . doubleValue ( ) ; } catch ( Exception e ) { throw new JSONException ( _STR ) ; } } 
2719	public static String [ ] split ( String toSplit , String delimiter ) { if ( ! hasLength ( toSplit ) | | ! hasLength ( delimiter ) ) { return null ; } int offset = toSplit . indexOf ( delimiter ) ; if ( offset < _NUM ) { return null ; } String beforeDelimiter = toSplit . substring ( _NUM , offset ) ; String afterDelimiter = toSplit . substring ( offset + delimiter . length ( ) ) ; return new String [ ] { beforeDelimiter , afterDelimiter } ; } 
2720	public static void addFactory ( UpdateEngineFactory f ) { get ( ) . add ( f ) ; } 
2721	public void testConcurrentWrites ( ) throws IOException , InterruptedException { getClusterBuilder ( ) . setRamDiskReplicaCapacity ( _NUM ) . build ( ) ; final String METHOD _ NAME = GenericTestUtils . getMethodName ( ) ; final int SEED = _NUM xFADED ; final int NUM _ WRITERS = _NUM ; final int NUM _ WRITER _ PATHS = _NUM ; Path [ ] [ ] paths = new Path [ NUM _ WRITERS ] [ NUM _ WRITER _ PATHS ] ; for ( int i = _NUM ; i < NUM _ WRITERS ; i + + ) { paths [ i ] = new Path [ NUM _ WRITER _ PATHS ] ; for ( int j = _NUM ; j < NUM _ WRITER _ PATHS ; j + + ) { paths [ i ] [ j ] = new Path ( _STR ) ; } } final CountDownLatch latch = new CountDownLatch ( NUM _ WRITERS ) ; final AtomicBoolean testFailed = new AtomicBoolean ( false ) ; ExecutorService executor = Executors . newFixedThreadPool ( THREADPOOL _ SIZE ) ; for ( int i = _NUM ; i < NUM _ WRITERS ; i + + ) { Runnable writer = new WriterRunnable ( i , paths [ i ] , SEED , latch , testFailed ) ; executor . execute ( writer ) ; } Thread . sleep ( _NUM * LAZY _ WRITER _ INTERVAL _ SEC * _NUM _NUM _NUM _NUM ) ; triggerBlockReport ( ) ; Stop executor from adding new tasks to finish existing threads in queue latch . await ( ) ; assertThat ( testFailed . get ( ) , is ( false ) ) ; } 
2722	public CreateNetworkInterfaceRequest withGroups ( String . . . groups ) { if ( getGroups ( ) = = null ) setGroups ( new java . util . ArrayList < String > ( groups . length ) ) ; for ( String value : groups ) { getGroups ( ) . add ( value ) ; } return this ; } 
2723	public void testTransactionAndCheckpointMetrics ( ) throws Exception { long lastCkptTime = MetricsAsserts . getLongGauge ( _STR , _NUM L , getMetrics ( NS _ METRICS ) ) ; } 
2724	private void unlinkHeaderFrom ( T item , @ Nullable Object payload ) { if ( hasHeader ( item ) ) { ISectionable sectionable = ( ISectionable ) item ; IHeader header = sectionable . getHeader ( ) ; log . v ( _STR , header , sectionable ) ; sectionable . setHeader ( null ) ; Notify items if ( payload ! = null ) { if ( ! header . isHidden ( ) ) notifyItemChanged ( getGlobalPositionOf ( header ) , payload ) ; if ( ! item . isHidden ( ) ) notifyItemChanged ( getGlobalPositionOf ( item ) , payload ) ; } } } 
2725	public final boolean handlesWebUris ( boolean onlyWebSchemes ) { Require ACTION _ VIEW , CATEGORY _ BROWSEABLE , and at least one scheme if ( ! hasAction ( Intent . ACTION _ VIEW ) | | ! hasCategory ( Intent . CATEGORY _ BROWSABLE ) | | mDataSchemes = = null | | mDataSchemes . size ( ) = = _NUM ) { return false ; } Now allow only the schemes _STR final int N = mDataSchemes . size ( ) ; for ( int i = _NUM ; i < N ; i + + ) { final String scheme = mDataSchemes . get ( i ) ; final boolean isWebScheme = SCHEME _ HTTP . equals ( scheme ) | | SCHEME _ HTTPS . equals ( scheme ) ; if ( onlyWebSchemes ) { we know it ' s a failure . if ( ! isWebScheme ) { return false ; } } else { filter matches what we ' re looking for . if ( isWebScheme ) { return true ; } } } _NUM ) ! onlyWebSchemes and no http / https schemes were found , i . e . failure . return onlyWebSchemes ; } 
2726	public void onTrace ( @ NonNull View targetView , @ NonNull BaseCell cell , int type ) { if ( optimizedMode ) { defaultTrace ( targetView , cell , type ) ; } else { if ( mOnExposureMethods . isEmpty ( ) | | mOnTraceMethods . isEmpty ( ) ) { Method [ ] methods = this . getClass ( ) . getMethods ( ) ; findTraceMethods ( methods ) ; findExposureMethods ( methods ) ; } List < Class < ? > > classes = lookupCellTypes ( targetView . getClass ( ) ) ; for ( Class clz : classes ) { if ( clz . equals ( View . class ) ) { continue ; } if ( mOnTraceMethods . containsKey ( clz ) ) { OnTraceMethod onTraceMethod = mOnTraceMethods . get ( clz ) ; try { if ( onTraceMethod . paramLength = = _NUM ) { onTraceMethod . method . invoke ( this , targetView , cell , type ) ; return ; } } catch ( Exception e ) { LogUtils . e ( TAG , _STR + Log . getStackTraceString ( e ) , e ) ; } } } defaultTrace ( targetView , cell , type ) ; } } 
2727	public static byte [ ] pbkdf _NUM _NUM _NUM ( String . . . args ) { byte [ ] salt = new byte [ _NUM _NUM _NUM ] ; Bytes . random ( salt ) ; StringBuilder sb = new StringBuilder ( ) ; for ( String s : args ) { sb . append ( s ) ; } PBEKeySpec spec = new PBEKeySpec ( sb . toString ( ) . toCharArray ( ) , salt , _NUM _NUM _NUM _NUM _NUM , _NUM _NUM _NUM ) ; try { return SecretKeyFactory . getInstance ( _STR ) . generateSecret ( spec ) . getEncoded ( ) ; } catch ( NoSuchAlgorithmException e ) { throw new RuntimeException ( e ) ; } catch ( InvalidKeySpecException e ) { throw new RuntimeException ( e ) ; } } 
2728	public boolean compressToJpeg ( Rect rectangle , int quality , OutputStream stream ) { Rect wholeImage = new Rect ( _NUM , _NUM , mWidth , mHeight ) ; if ( ! wholeImage . contains ( rectangle ) ) { wholeImage . set ( rectangle ) ; } if ( quality < _NUM | | quality > _NUM _NUM _NUM ) { throw new IllegalArgumentException ( _STR ) ; } adjustRectangle ( rectangle ) ; int [ ] offsets = calculateOffsets ( rectangle . left , rectangle . top ) ; boolean res = SaveJpegFreeOutMT ( mData , mFormat , rectangle . width ( ) , rectangle . height ( ) , offsets , mStrides , quality , stream , new byte [ WORKING _ COMPRESS _ STORAGE _ MT ] ) ; return res ; } 
2729	public Integer getMnemonic ( final String key ) { final String name = getString ( key ) ; return createMnemonic ( name ) ; } 
2730	public ProcessorNode createProcessorAdvice ( ProceedingJoinPoint proceedingJoinPoint ) throws Throwable { update the processor state ProcessorNode processor = ( ProcessorNode ) proceedingJoinPoint . proceed ( ) ; if no exceptions were thrown , add the processor action . . . final Action action = generateAuditRecord ( processor , Operation . Add ) ; save the actions if ( action ! = null ) { saveAction ( action , logger ) ; } return processor ; } 
2731	private void registerCameraLaunchGesture ( Resources resources ) { if ( mCameraLaunchRegistered ) { return ; } mCameraGestureOnTimeMs = SystemClock . elapsedRealtime ( ) ; mCameraGestureLastEventTime = mCameraGestureOnTimeMs ; SensorManager sensorManager = ( SensorManager ) mContext . getSystemService ( Context . SENSOR _ SERVICE ) ; int cameraLaunchGestureId = resources . getInteger ( com . android . internal . R . integer . config _ cameraLaunchGestureSensorType ) ; if ( cameraLaunchGestureId ! = - _NUM ) { mCameraLaunchRegistered = false ; String sensorName = resources . getString ( com . android . internal . R . string . config _ cameraLaunchGestureSensorStringType ) ; mCameraLaunchSensor = sensorManager . getDefaultSensor ( cameraLaunchGestureId , true ) ; makes the code more robust . if ( mCameraLaunchSensor ! = null ) { if ( sensorName . equals ( mCameraLaunchSensor . getStringType ( ) ) ) { mCameraLaunchRegistered = sensorManager . registerListener ( mGestureListener , mCameraLaunchSensor , _NUM ) ; } else { String message = String . format ( _STR ) ; } } 
2732	public void setRadiusGridlinePaint ( Paint paint ) { this . radiusGridlinePaint = paint ; fireChangeEvent ( ) ; } 
2733	private void stopDrag ( MotionEvent ev ) { mTouchMode = TOUCH _ MODE _ IDLE ; Up and not canceled , also checks the switch has not been disabled during the drag boolean commitChange = ev . getAction ( ) = = MotionEvent . ACTION _ UP & & isEnabled ( ) ; cancelSuperTouch ( ev ) ; if ( commitChange ) { boolean newState ; mVelocityTracker . computeCurrentVelocity ( _NUM _NUM _NUM _NUM ) ; float xvel = mVelocityTracker . getXVelocity ( ) ; if ( Math . abs ( xvel ) > mMinFlingVelocity ) { newState = state = = STATE _ PHOTO _ ACTIVE ? xvel > _NUM : xvel < _NUM ; } else { newState = getTargetCheckedState ( ) ; } if ( newState ) { Change state of switch if ( state = = STATE _ PHOTO _ ACTIVE ) { setState ( STATE _ VIDEO _ ACTIVE ) ; } else { setState ( STATE _ PHOTO _ ACTIVE ) ; } if _STR , notify onChecked listener . if ( onShutterCheckedListener ! = null ) { onShutterCheckedListener . onShutterChecked ( state ) ; } } else { else notify onClick listener if it wasn ' t longClick . if ( onShutterClickListener ! = null & & ! mThumbMoved & & System . currentTimeMillis ( ) - mTouchTimeStart < INTERVAL _ TO _ SHOOT _ ON _ SHUTTER _ RELEASE ) { onShutterClickListener . onShutterClick ( ) ; } setThumbPositionDefault ( ) ; invalidate ( ) ; } } } 
2734	public Writable call ( Writable param , InetSocketAddress addr , Class < ? > protocol , UserGroupInformation ticket , int rpcTimeout , int serviceClass , Configuration conf ) throws IOException { ConnectionId remoteId = ConnectionId . getConnectionId ( addr , protocol , ticket , rpcTimeout , conf ) ; return call ( RPC . RpcKind . RPC _ BUILTIN , param , remoteId , serviceClass ) ; } 
2735	public Set < byte [ ] > getFamiliesKeys ( ) { return delegatee . getColumnFamilyNames ( ) ; } 
2736	public void repositionPlaceholder ( int x , int y , Orientation orientation ) { int widgetCount = getWidgetCount ( ) ; for ( int index = _NUM ; index < widgetCount ; index + + ) { CmsTreeItem item = getItem ( index ) ; Element itemElement = item . getElement ( ) ; boolean over = false ; switch ( orientation ) { case HORIZONTAL : over = CmsDomUtil . checkPositionInside ( itemElement , x , - _NUM ) ; break ; case VERTICAL : over = CmsDomUtil . checkPositionInside ( itemElement , - _NUM , y ) ; break ; case ALL : default : over = CmsDomUtil . checkPositionInside ( itemElement , x , y ) ; } if ( over ) { m _ placeholderIndex = item . repositionPlaceholder ( x , y , m _ placeholder , orientation ) ; return ; } if ( isDNDTakeAll ( ) & & ( index = = widgetCount - _NUM ) ) { last item of the list , no matching item was found and take - all is enabled check if cursor position is above or below int relativeTop = CmsDomUtil . getRelativeY ( y , getElement ( ) ) ; int elementHeight = getElement ( ) . getOffsetHeight ( ) ; if ( relativeTop < = _NUM ) { if ( isRootDropEnabled ( ) ) { getElement ( ) . insertBefore ( m _ placeholder , getItem ( _NUM ) . getElement ( ) ) ; setPlaceholderPath ( _STR ) ; m _ placeholderIndex = widgetCount ; } } } } } } 
2737	public void setSelectedTabIndicatorHeight ( int height ) { mTabStrip . setSelectedIndicatorHeight ( height ) ; } 
2738	public CmsPrepareEditResponse prepareEdit ( CmsUUID currentPageId , String pathWithMacros ) throws CmsRpcException { try { CmsObject cms = getCmsObject ( ) ; CmsResource currentPage = cms . readResource ( currentPageId ) ; String path = prepareFileNameForEditor ( cms , currentPage , pathWithMacros ) ; CmsResource resource = cms . readResource ( path ) ; ensureLock ( resource ) ; CmsPrepareEditResponse result = new CmsPrepareEditResponse ( ) ; result . setRootPath ( resource . getRootPath ( ) ) ; result . setSitePath ( cms . getSitePath ( resource ) ) ; result . setStructureId ( resource . getStructureId ( ) ) ; return result ; } catch ( CmsException e ) { error ( e ) ; } return null ; } 
2739	public boolean verifySignature ( byte [ ] message , BigInteger r , BigInteger s ) { ECDomainParameters ec = key . getParameters ( ) ; BigInteger n = ec . getN ( ) ; BigInteger e = calculateE ( n , message ) ; r in the range [ _NUM , n - _NUM ] if ( r . compareTo ( ONE ) < _NUM | | r . compareTo ( n ) > = _NUM ) { return false ; } s in the range [ _NUM , n - _NUM ] if ( s . compareTo ( ONE ) < _NUM | | s . compareTo ( n ) > = _NUM ) { return false ; } BigInteger c = s . modInverse ( n ) ; BigInteger u _NUM = e . multiply ( c ) . mod ( n ) ; BigInteger u _NUM = r . multiply ( c ) . mod ( n ) ; ECPoint G = ec . getG ( ) ; ECPoint Q = ( ( ECPublicKeyParameters ) key ) . getQ ( ) ; ECPoint point = ECAlgorithms . sumOfTwoMultiplies ( G , u _NUM , Q , u _NUM ) ; components must be bogus . if ( point . isInfinity ( ) ) { return false ; } ECCurve curve = point . getCurve ( ) ; if ( curve ! = null ) { BigInteger cofactor = curve . getCofactor ( ) ; if ( cofactor ! = null & & cofactor . compareTo ( EIGHT ) < = _NUM ) { ECFieldElement D = getDenominator ( curve . getCoordinateSystem ( ) , point ) ; if ( D ! = null & & ! D . isZero ( ) ) { ECFieldElement X = point . getXCoord ( ) ; while ( curve . isValidFieldElement ( r ) ) { ECFieldElement R = curve . fromBigInteger ( r ) . multiply ( D ) ; if ( R . equals ( X ) ) { return true ; } r = r . add ( n ) ; } return false ; } } } BigInteger v = point . normalize ( ) . getAffineXCoord ( ) . toBigInteger ( ) . mod ( n ) ; return v . equals ( r ) ; } 
2740	public static Map < String , Object > storeIncomingEmail ( DispatchContext dctx , Map < String , ? extends Object > context ) { Delegator delegator = dctx . getDelegator ( ) ; LocalDispatcher dispatcher = dctx . getDispatcher ( ) ; MimeMessageWrapper wrapper = ( MimeMessageWrapper ) context . get ( _STR ) ) ; return results ; } catch ( MessagingException e ) { Debug . logError ( e , module ) ; return ServiceUtil . returnError ( e . getMessage ( ) ) ; } catch ( GenericServiceException e ) { Debug . logError ( e , module ) ; return ServiceUtil . returnError ( e . getMessage ( ) ) ; } catch ( Exception e ) { Debug . logError ( e , module ) ; return ServiceUtil . returnError ( e . getMessage ( ) ) ; } } 
2741	public static String appendParameters ( String uri , Map < String , Object > parameters ) throws URISyntaxException { add additional parameters to the resource uri if ( ! parameters . isEmpty ( ) ) { String query = URISupport . createQueryString ( parameters ) ; URI u = new URI ( uri ) ; u = URISupport . createURIWithQuery ( u , query ) ; parameters . clear ( ) ; return u . toString ( ) ; } else { return uri ; } } 
2742	public List < HiveQueryId > getHiveQueryIdsForUser ( String username ) { JSONObject entities = delegate . hiveQueryIdsForUser ( username ) ; return parseHqidJsonFromATS ( entities ) ; } 
2743	public void onReceiveStatus ( List < CmsPublishResource > brokenResources ) { if ( brokenResources . isEmpty ( ) ) { hide ( ) ; } else { m _ brokenLinksPanel . setEntries ( brokenResources ) ; setPanel ( PANEL _ BROKEN _ LINKS ) ; } } 
2744	public String key ( String key , Object arg _NUM ) { if ( hasConfigValue ( key ) ) { return getConfigValue ( key , new Object [ ] { arg _NUM } ) ; } return m _ messages . key ( key , arg _NUM ) ; } 
2745	public void addConditionItem ( MatchMode matchMode , String name , String value ) { checkMatchModes ( matchMode , name ) ; _ conds . add ( new ConditionItem ( matchMode , name , value ) ) ; } 
2746	private void calculateItemPositions ( ) { Create an arc that starts from startAngle and ends at endAngle in an area that is as large as _NUM * radius ^ _NUM Point center = getActionViewCenter ( ) ; RectF area = new RectF ( center . x - radius , center . y - radius , center . x + radius , center . y + radius ) ; Path orbit = new Path ( ) ; orbit . addArc ( area , startAngle , endAngle - startAngle ) ; PathMeasure measure = new PathMeasure ( orbit , false ) ; Prevent overlapping when it is a full circle int divisor ; if ( Math . abs ( endAngle - startAngle ) > = _NUM _NUM _NUM | | subActionItems . size ( ) < = _NUM ) { divisor = subActionItems . size ( ) ; } else { divisor = subActionItems . size ( ) - _NUM ; } Measure this path , in order to find points that have the same distance between each other for ( int i = _NUM ; i < subActionItems . size ( ) ; i + + ) { float [ ] coords = new float [ ] { _NUM f , _NUM f } ; measure . getPosTan ( ( i ) * measure . getLength ( ) / divisor , coords , null ) ; get the x and y values of these points and set them to each of sub action items . subActionItems . get ( i ) . x = ( int ) coords [ _NUM ] - subActionItems . get ( i ) . width / _NUM ; subActionItems . get ( i ) . y = ( int ) coords [ _NUM ] - subActionItems . get ( i ) . height / _NUM ; } } 
2747	public Pair < VirtualDisk , String > getDiskDevice ( String vmdkDatastorePath , boolean matchExactly ) throws Exception { List < VirtualDevice > devices = _ context . getVimClient ( ) . getDynamicProperty ( _ mor , _STR + deviceNumbering ) ; return new Pair < VirtualDisk , String > ( ( VirtualDisk ) device , deviceNumbering ) ; } } diskBackingInfo = diskBackingInfo . getParent ( ) ; } while ( diskBackingInfo ! = null ) ; } } } } return null ; } 
2748	public void moveItem ( int from , int to ) { if ( mDropListener ! = null ) { final int count = getInputAdapter ( ) . getCount ( ) ; if ( from > = _NUM & & from < count & & to > = _NUM & & to < count ) { mDropListener . drop ( from , to ) ; } } } 
2749	public void testMarkReset ( ) throws IOException { List < String > expected = multiLineFileInit ( file , Charsets . UTF _ _NUM ) ; int MAX _ LEN = _NUM _NUM _NUM ; PositionTracker tracker = new DurablePositionTracker ( meta , file . getPath ( ) ) ; ResettableInputStream in = new ResettableFileInputStream ( file , tracker ) ; String result _NUM = readLine ( in , MAX _ LEN ) ; assertEquals ( expected . get ( _NUM ) , result _NUM ) ; in . reset ( ) ; String result _NUM a = readLine ( in , MAX _ LEN ) ; assertEquals ( expected . get ( _NUM ) , result _NUM a ) ; in . mark ( ) ; String result _NUM = readLine ( in , MAX _ LEN ) ; assertEquals ( expected . get ( _NUM ) , result _NUM ) ; in . reset ( ) ; String result _NUM a = readLine ( in , MAX _ LEN ) ; assertEquals ( expected . get ( _NUM ) , result _NUM a ) ; in . mark ( ) ; in . close ( ) ; } 
2750	public void writeDataPage ( int valueCount , int uncompressedPageSize , BytesInput bytes , Encoding rlEncoding , Encoding dlEncoding , Encoding valuesEncoding ) throws IOException { state = state . write ( ) ; long beforeHeader = out . getPos ( ) ; LOG . debug ( _STR , out . getPos ( ) , compressedPageSize ) ; bytes . writeAllTo ( out ) ; encodingStatsBuilder . addDataEncoding ( valuesEncoding ) ; currentEncodings . add ( rlEncoding ) ; currentEncodings . add ( dlEncoding ) ; currentEncodings . add ( valuesEncoding ) ; } 
2751	private void updateTextAreaCaret ( boolean visible ) { Caret caret = textArea . getCaret ( ) ; if ( caret instanceof ConfigurableCaret ) { Always true by default ConfigurableCaret cc = ( ConfigurableCaret ) caret ; if ( visible ) { prevCaretAlwaysVisible = cc . isAlwaysVisible ( ) ; cc . setAlwaysVisible ( true ) ; } else { cc . setAlwaysVisible ( prevCaretAlwaysVisible ) ; } } } 
2752	public synchronized MetadataEditor putLong ( int key , long value ) throws IllegalArgumentException { super . putLong ( key , value ) ; if ( mMetadataBuilder ! = null ) { MediaMetadata supports all the same fields as MetadataEditor String metadataKey = MediaMetadata . getKeyFromMetadataEditorKey ( key ) ; But just in case , don ' t add things we don ' t understand if ( metadataKey ! = null ) { mMetadataBuilder . putLong ( metadataKey , value ) ; } } return this ; } 
2753	public Iterator < Long > resultsPerWindow ( ) { return new Iterator < Long > ( ) { @ Override public boolean hasNext ( ) { while ( true ) { if ( ! pendingCounts . isEmpty ( ) ) { return true ; } if ( isDone ) { if ( currentCount > _NUM ) { pendingCounts . add ( currentCount ) ; currentCount = _NUM ; currentWindow = BoundedWindow . TIMESTAMP _ MAX _ VALUE . getMillis ( ) ; return true ; } else { return false ; } } run ( ) ; } } @ Override public Long next ( ) { Long result = pendingCounts . get ( _NUM ) ; pendingCounts . remove ( _NUM ) ; return result ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } 
2754	public List < String > reloadSeeds ( ) { logger . trace ( _STR , seeds ) ; return getSeeds ( ) ; } 
2755	private void prepareNextRow ( ) { while ( currentPage . isEmpty ( ) ) { Grab the current state now to get a consistent view in this iteration . FetchingState fetchingState = this . fetchState ; NextPage nextPage = nextPages . poll ( ) ; if ( nextPage ! = null ) { if ( nextPage . metadata ! = null ) { this . metadata = nextPage . metadata ; } currentPage = nextPage . data ; continue ; } if ( fetchingState = = null ) return ; wait on it . try { session . checkNotInEventLoop ( ) ; Uninterruptibles . getUninterruptibly ( fetchMoreResults ( ) ) ; } catch ( ExecutionException e ) { throw DriverThrowables . propagateCause ( e ) ; } } } 
2756	public void setMeasuredDimension ( Rect childrenBounds , int wSpec , int hSpec ) { int usedWidth = childrenBounds . width ( ) + getPaddingLeft ( ) + getPaddingRight ( ) ; int usedHeight = childrenBounds . height ( ) + getPaddingTop ( ) + getPaddingBottom ( ) ; int width = chooseSize ( wSpec , usedWidth , getMinimumWidth ( ) ) ; int height = chooseSize ( hSpec , usedHeight , getMinimumHeight ( ) ) ; setMeasuredDimension ( width , height ) ; } 
2757	private static Type getCast ( final QNm name , final long arity , final InputInfo info ) throws QueryException { final byte [ ] ln = name . local ( ) ; Type type = ListType . find ( name ) ; if ( type = = null ) type = AtomType . find ( name , false ) ; no constructor function found , or abstract type specified if ( type ! = null & & type ! = AtomType . NOT & & type ! = AtomType . AAT ) { if ( arity = = _NUM ) return type ; throw FUNCTYPES _ X _ X _ X . get ( info , name . string ( ) , arguments ( arity ) , _NUM ) ; } include similar function name in error message final Levenshtein ls = new Levenshtein ( ) ; for ( final AtomType tp : AtomType . VALUES ) { if ( tp . parent = = null ) continue ; final byte [ ] u = tp . name . uri ( ) ; if ( eq ( u , XS _ URI ) & & tp ! = AtomType . NOT & & tp ! = AtomType . AAT & & ls . similar ( lc ( ln ) , lc ( tp . string ( ) ) ) ) throw FUNCSIMILAR _ X _ X . get ( info , name . prefixId ( ) , tp . toString ( ) ) ; } no similar name : constructor function found , or abstract type specified throw WHICHFUNC _ X . get ( info , name . prefixId ( ) ) ; } 
2758	public List < JSONObject > getMostTagCategory ( final int fetchSize ) { final Query query = new Query ( ) . addSort ( Category . CATEGORY _ ORDER , SortDirection . ASCENDING ) . addSort ( Category . CATEGORY _ TAG _ CNT , SortDirection . DESCENDING ) . addSort ( Keys . OBJECT _ ID , SortDirection . DESCENDING ) . setPageSize ( fetchSize ) . setPageCount ( _NUM ) ; try { final List < JSONObject > ret = CollectionUtils . jsonArrayToList ( categoryRepository . get ( query ) . optJSONArray ( Keys . RESULTS ) ) ; for ( final JSONObject category : ret ) { final List < JSONObject > tags = getTags ( category . optString ( Keys . OBJECT _ ID ) ) ; category . put ( Category . CATEGORY _ T _ TAGS , ( Object ) tags ) ; } return ret ; } catch ( final Exception e ) { LOGGER . log ( Level . ERROR , _STR , e ) ; return Collections . emptyList ( ) ; } } 
2759	public static < T > double reduceBy ( final float [ ] array , T object ) { if ( object . getClass ( ) . isAnonymousClass ( ) ) { return reduceByR ( array , object ) ; } try { ConstantCallSite callSite = Invoker . invokeReducerLongIntReturnLongMethodHandle ( object ) ; MethodHandle methodHandle = callSite . dynamicInvoker ( ) ; try { double sum = _NUM ; for ( float v : array ) { sum = ( double ) methodHandle . invokeExact ( sum , v ) ; } return sum ; } catch ( Throwable throwable ) { return handle ( Long . class , throwable , _STR ) ; } } catch ( Exception ex ) { return reduceByR ( array , object ) ; } } 
2760	public final void open ( String uId ) throws Exception { this . id = uId ; ResourceId tempDirectory = getWriteOperation ( ) . tempDirectory . get ( ) ; outputFile = tempDirectory . resolve ( id , StandardResolveOptions . RESOLVE _ FILE ) ; verifyNotNull ( outputFile , _STR , this . id , outputFile ) ; } 
2761	public void putBundle ( @ Nullable String key , @ Nullable Bundle value ) { unparcel ( ) ; mMap . put ( key , value ) ; } 
2762	public CTMarker getTo ( ) { return getCell _NUM ( ) ; } 
2763	private < T > ContainerBuilder factory ( final Key < T > key , InternalFactory < ? extends T > factory , Scope scope ) { ensureNotCreated ( ) ; checkKey ( key ) ; final InternalFactory < ? extends T > scopedFactory = scope . scopeFactory ( key . getType ( ) , key . getName ( ) , factory ) ; factories . put ( key , scopedFactory ) ; InternalFactory < T > callableFactory = createCallableFactory ( key , scopedFactory ) ; if ( EarlyInitializable . class . isAssignableFrom ( factory . type ( ) ) ) { earlyInitializableFactories . add ( callableFactory ) ; } else if ( scope = = Scope . SINGLETON ) { singletonFactories . add ( callableFactory ) ; } return this ; } 
2764	public void setHistoryMaxSize ( int historyMaxSize ) { synchronized ( mInstanceLock ) { if ( mHistoryMaxSize = = historyMaxSize ) { return ; } mHistoryMaxSize = historyMaxSize ; pruneExcessiveHistoricalRecordsIfNeeded ( ) ; if ( sortActivitiesIfNeeded ( ) ) { notifyChanged ( ) ; } } } 
2765	protected static String LexicalError ( boolean EOFSeen , int lexState , int errorLine , int errorColumn , String errorAfter , char curChar ) { return ( _STR ) ; } 
2766	public void setWorkingDirectory ( Path newDir ) { workingDir = makeAbsolute ( newDir ) ; } 
2767	public V get ( Object key ) { short k ; if ( key ! = null ) { if ( key instanceof Short ) { k = unwrapKey ( ( Short ) key ) ; } else { return null ; } } else { k = _ map . getNoEntryKey ( ) ; } return _ map . get ( k ) ; } 
2768	public ArrayList < BackupImage > getAllDependentListByTable ( TableName table ) { ArrayList < BackupImage > tableImageList = new ArrayList < > ( ) ; ArrayList < BackupImage > imageList = getRestoreDependentList ( false ) ; for ( BackupImage image : imageList ) { if ( image . hasTable ( table ) ) { tableImageList . add ( image ) ; } } return tableImageList ; } 
2769	private SortedSet < Address > getDefaultServers ( ) throws IOException { SortedSet < Address > defaultServers = Sets . newTreeSet ( ) ; for ( ServerName serverName : getOnlineRS ( ) ) { Address server = Address . fromParts ( serverName . getHostname ( ) , serverName . getPort ( ) ) ; boolean found = false ; for ( RSGroupInfo rsgi : listRSGroups ( ) ) { if ( ! RSGroupInfo . DEFAULT _ GROUP . equals ( rsgi . getName ( ) ) & & rsgi . containsServer ( server ) ) { found = true ; break ; } } if ( ! found ) { defaultServers . add ( server ) ; } } return defaultServers ; } 
2770	public int getLastRow ( ) { return buildCellReference ( ) . getRow ( ) ; } 
2771	public List readProjectResources ( CmsDbContext dbc , CmsProject project ) throws CmsDataAccessException { PreparedStatement stmt = null ; Connection conn = null ; ResultSet res = null ; List result = new ArrayList ( ) ; try { conn = m _ sqlManager . getConnection ( dbc ) ; stmt = m _ sqlManager . getPreparedStatement ( conn , _STR ) ) ; } } catch ( SQLException e ) { throw new CmsDbSqlException ( Messages . get ( ) . container ( Messages . ERR _ GENERIC _ SQL _ _NUM , CmsDbSqlException . getErrorQuery ( stmt ) ) , e ) ; } finally { m _ sqlManager . closeAll ( dbc , conn , stmt , res ) ; } return result ; } 
2772	public void setTarget ( String target ) { this . target = target ; calculateLength ( ) ; } 
2773	public void testFilterClauseNotFactoredOut _NUM ( ) { String sql = _STR ; sql ( sql ) . queryContains ( druidChecker ( expectedQuery ) ) ; } 
2774	public void remove ( ) { if ( _ _ readOnly ) { throw new UnsupportedOperationException ( ) ; } force _ position _ sync ( ) ; if ( _ _ current = = null | | _ _ pos = = null ) { throw new NoSuchElementException ( ) ; } if ( _ _ pos . on _ system _ value ( ) ) { throw new UnsupportedOperationException ( ) ; } int idx = _ _ pos . _ _ user _ index ; assert ( idx > = _NUM ) ; IonValueLite concrete = _ _ current ; int concrete _ idx = concrete . _ elementid ( ) ; assert ( concrete _ idx = = idx ) ; here we remove the member from the container ' s list of elements remove _ child ( idx ) ; patch _ elements _ helper ( concrete _ idx ) ; when we remove the current value we remove its associated system values and this may change the index adjustment _ _ pos . _ _ index _ adjustment - = _ _ pos . _ _ local _ value _ count ; if ( _ _ pos . _ _ user _ index < get _ child _ count ( ) - _NUM ) { _ _ pos . load _ updated _ position ( ) ; _ _ pos . _ _ local _ index = - _NUM ; } _ _ current = null ; } 
2775	public Collection < Range < Token > > ranges ( ) { return merkleTrees . keySet ( ) ; } 
2776	public void putAll ( Map < ? extends Long , ? extends Short > map ) { Iterator < ? extends Entry < ? extends Long , ? extends Short > > it = map . entrySet ( ) . iterator ( ) ; for ( int i = map . size ( ) ; i - - > _NUM ; ) { Entry < ? extends Long , ? extends Short > e = it . next ( ) ; this . put ( e . getKey ( ) , e . getValue ( ) ) ; } } 
2777	 @ GET @ Path ( _STR , databases ) ; return Response . ok ( response ) . build ( ) ; } 
2778	public void write ( Binary value , int repetitionLevel , int definitionLevel ) { if ( DEBUG ) log ( value , repetitionLevel , definitionLevel ) ; repetitionLevel ( repetitionLevel ) ; definitionLevel ( definitionLevel ) ; dataColumn . writeBytes ( value ) ; statistics . updateStats ( value ) ; + + valueCount ; } 
2779	public void goBack ( ) { checkThread ( ) ; mProvider . goBack ( ) ; } 
2780	public Intent execute ( Context context ) { String [ ] titles = new String [ ] { _STR ) ; return intent ; } 
2781	public void setMinimumWidth ( int minWidth ) { mMinWidth = minWidth ; requestLayout ( ) ; } 
2782	public String getStartPointEndingStyle ( ) { String retval = PDAnnotationLine . LE _ NONE ; COSArray array = ( COSArray ) annot . getDictionaryObject ( COSName . LE ) ; if ( array ! = null ) { retval = array . getName ( _NUM ) ; } return retval ; } 
2783	public String getNotes ( ) { return getText ( false , true , false , false ) ; } 
2784	public String getPlainText ( Element element ) { FormattingVisitor formatter = new FormattingVisitor ( ) ; NodeTraversor traversor = new NodeTraversor ( formatter ) ; walk the DOM , and call . head ( ) and . tail ( ) for each node traversor . traverse ( element ) ; return formatter . toString ( ) ; } 
2785	public void setFocusColumn ( int col ) { checkWidget ( ) ; GridColumn column = getColumn ( col ) ; if ( column = = null | | column . getGrid ( ) ! = this ) { SWT . error ( SWT . ERROR _ INVALID _ ARGUMENT ) ; return ; } focusColumn = column ; } 
2786	public void postSign ( final DOMSignContext xmlSignContext , final String signatureValue ) throws MarshalException { LOG . log ( POILogger . DEBUG , _STR ) ; } signatureNode . setTextContent ( signatureValue ) ; for ( SignatureFacet signatureFacet : signatureConfig . getSignatureFacets ( ) ) { signatureFacet . postSign ( document ) ; } writeDocument ( document ) ; } 
2787	public Typeface loadFont ( Resources wrapper , TypedValue value , int id ) { if ( value . string = = null ) { throw new NotFoundException ( _STR + file , e ) ; } finally { Trace . traceEnd ( Trace . TRACE _ TAG _ RESOURCES ) ; } return null ; } 
2788	public ItemStack toItemStack ( int amount ) { return new ItemStack ( Material . POTION , amount , toDamageValue ( ) ) ; } 
2789	public void removeOntClass ( Resource ontClass ) { removeRDFType ( ontClass ) ; } 
2790	protected void setDerived ( int index ) { AttributeStats as = m _ AttributeStats [ index ] ; long percent = Math . round ( _NUM _NUM _NUM . _NUM * as . missingCount / as . totalCount ) ; m _ MissingLab . setText ( _STR + as . distinctCount ) ; setTable ( as , index ) ; } 
2791	public static Allocation createTyped ( RenderScript rs , Type type , MipmapControl mips , int usage ) { try { Trace . traceBegin ( RenderScript . TRACE _ TAG , _STR ) ; } return new Allocation ( id , rs , type , false , usage , mips ) ; } finally { Trace . traceEnd ( RenderScript . TRACE _ TAG ) ; } } 
2792	public static ServerDHParams parse ( InputStream input ) throws IOException { BigInteger p = TlsDHUtils . readDHParameter ( input ) ; BigInteger g = TlsDHUtils . readDHParameter ( input ) ; BigInteger Ys = TlsDHUtils . readDHParameter ( input ) ; return new ServerDHParams ( TlsDHUtils . validateDHPublicKey ( new DHPublicKeyParameters ( Ys , new DHParameters ( p , g ) ) ) ) ; } 
2793	private void clearNodesForWindowLocked ( int windowId ) { if ( DEBUG ) { Log . i ( LOG _ TAG , _STR ) ; } LongSparseArray < AccessibilityNodeInfo > nodes = mNodeCache . get ( windowId ) ; if ( nodes = = null ) { return ; } Recycle the nodes before clearing the cache . final int nodeCount = nodes . size ( ) ; for ( int i = nodeCount - _NUM ; i > = _NUM ; i - - ) { AccessibilityNodeInfo info = nodes . valueAt ( i ) ; nodes . removeAt ( i ) ; info . recycle ( ) ; } mNodeCache . remove ( windowId ) ; } 
2794	ASN _NUM Primitive toDERObject ( ) { if ( isSorted ) { ASN _NUM Set derSet = new DERSet ( ) ; derSet . set = this . set ; return derSet ; } else { Vector v = new Vector ( ) ; for ( int i = _NUM ; i ! = set . size ( ) ; i + + ) { v . addElement ( set . elementAt ( i ) ) ; } ASN _NUM Set derSet = new DERSet ( ) ; derSet . set = v ; derSet . sort ( ) ; return derSet ; } } 
2795	public void hideDown ( ) { if ( noHideDown ) return ; if ( currentSashInfo = = null ) currentSashInfo = new SashInfo ( null ) ; downHideClicked ( currentSashInfo ) ; } 
2796	private static Runnable handleSystemServerProcess ( ZygoteConnection . Arguments parsedArgs ) { set umask to _NUM _NUM _NUM _NUM so new files and directories will default to owner - only permissions . Os . umask ( S _ IRWXG | S _ IRWXO ) ; if ( parsedArgs . niceName ! = null ) { Process . setArgV _NUM ( parsedArgs . niceName ) ; } final String systemServerClasspath = Os . getenv ( _STR ) ; } else { ClassLoader cl = null ; if ( systemServerClasspath ! = null ) { cl = createPathClassLoader ( systemServerClasspath , parsedArgs . targetSdkVersion ) ; Thread . currentThread ( ) . setContextClassLoader ( cl ) ; } return ZygoteInit . zygoteInit ( parsedArgs . targetSdkVersion , parsedArgs . remainingArgs , cl ) ; } } 
2797	public boolean removeAll ( IntArray array ) { int size = this . size ; int startSize = size ; int [ ] items = this . items ; for ( int i = _NUM , n = array . size ; i < n ; i + + ) { int item = array . get ( i ) ; for ( int ii = _NUM ; ii < size ; ii + + ) { if ( item = = items [ ii ] ) { removeIndex ( ii ) ; size - - ; break ; } } } return size ! = startSize ; } 
2798	 @ SuppressWarnings ( _STR , value , type . getName ( ) ) ) ; } 
2799	public static XmlENTITIES parse ( java . lang . String s ) throws org . apache . xmlbeans . XmlException { return ( XmlENTITIES ) XmlBeans . getContextTypeLoader ( ) . parse ( s , type , null ) ; } 
2800	public void onDismiss ( DialogInterface dialog ) { mShowingRemoveDialog = false ; } } ) . create ( ) . show ( ) ; } 
2801	public static void verifyJpegKeys ( Image image , CaptureResult captureResult , Size expectedSize , Size expectedThumbnailSize , ExifTestData expectedExifData , StaticMetadata staticInfo , CameraErrorCollector collector ) throws Exception { basicValidateJpegImage ( image , expectedSize ) ; byte [ ] jpegBuffer = getDataFromImage ( image ) ; Have to dump into a file to be able to use ExifInterface String jpegFilename = DEBUG _ FILE _ NAME _ BASE + _STR , expectedExifData . thumbnailQuality , captureResult . get ( CaptureResult . JPEG _ THUMBNAIL _ QUALITY ) ) ; Validate other exif tags for all non - legacy devices if ( ! staticInfo . isHardwareLevelLegacy ( ) ) { verifyJpegExifExtraTags ( exif , expectedSize , captureResult , staticInfo , collector ) ; } } 
2802	public double getUpperBound ( final int numStdDev ) { return ( isEstimationMode ( ) ) ? upperBound ( getRetainedEntries ( true ) , getThetaLong ( ) , numStdDev , isEmpty ( ) ) : getRetainedEntries ( true ) ; } 
2803	public TvInputInfo build ( ) { ComponentName componentName = new ComponentName ( mResolveInfo . serviceInfo . packageName , mResolveInfo . serviceInfo . name ) ; String id ; int type ; boolean isHardwareInput = false ; boolean isConnectedToHdmiSwitch = false ; if ( mHdmiDeviceInfo ! = null ) { id = generateInputId ( componentName , mHdmiDeviceInfo ) ; type = TYPE _ HDMI ; isHardwareInput = true ; isConnectedToHdmiSwitch = ( mHdmiDeviceInfo . getPhysicalAddress ( ) & _NUM x _NUM FFF ) ! = _NUM ; } else if ( mTvInputHardwareInfo ! = null ) { id = generateInputId ( componentName , mTvInputHardwareInfo ) ; type = sHardwareTypeToTvInputType . get ( mTvInputHardwareInfo . getType ( ) , TYPE _ TUNER ) ; isHardwareInput = true ; } else { id = generateInputId ( componentName ) ; type = TYPE _ TUNER ; } parseServiceMetadata ( type ) ; return new TvInputInfo ( mResolveInfo , id , type , isHardwareInput , mLabel , mLabelResId , mIcon , mIconStandby , mIconDisconnected , mSetupActivity , mCanRecord = = null ? false : mCanRecord , mTunerCount = = null ? _NUM : mTunerCount , mHdmiDeviceInfo , isConnectedToHdmiSwitch , mParentId , mExtras ) ; } 
2804	public void putAll ( PersistableBundle bundle ) { unparcel ( ) ; bundle . unparcel ( ) ; mMap . putAll ( bundle . mMap ) ; } 
2805	public boolean isNetworkRoaming ( int subId ) { final int phoneId = getPhoneId ( subId ) ; if ( phoneId < _NUM ) { What else can we do ? return false ; } return TelephonyManager . getDefault ( ) . isNetworkRoaming ( subId ) ; } 
2806	public Collection < ArbitraryAttributeModel > getArbitraryAttributes ( ) { return arbitraryAttributes . toModelCollection ( ) ; } 
2807	public void makeWithOneArgConstructorWithScaleOneArg ( ) { BufferedImage img = makeTestImage _NUM _NUM _NUM x _NUM _NUM _NUM ( ) ; new ScaledThumbnailMaker ( _NUM . _NUM ) . scale ( _NUM . _NUM ) . make ( img ) ; } 
2808	public String toString ( ) { String result ; int i ; result = _STR ; result + = m _ Elements . get ( i ) ; } return result ; } 
2809	public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( _STR ) ; return sb . toString ( ) ; } 
2810	public void setPageMargin ( int marginPixels ) { final int oldMargin = mPageMargin ; mPageMargin = marginPixels ; final int width = getWidth ( ) ; recomputeScrollPosition ( width , width , marginPixels , oldMargin ) ; requestLayout ( ) ; } 
2811	boolean truncate ( String src , long newLength , String clientName , String clientMachine , long mtime ) throws IOException , UnresolvedLinkException { requireEffectiveLayoutVersionForFeature ( Feature . TRUNCATE ) ; final FSDirTruncateOp . TruncateResult r ; try { NameNode . stateChangeLog . debug ( _STR , src ) ; throw e ; } return r . getResult ( ) ; } 
2812	public Aggregator [ ] loadEntry ( ImmutableBytesWritable key ) throws IOException { SpillMap spillMap = spillMaps . get ( getPartition ( key ) ) ; byte [ ] data = spillMap . get ( key ) ; if ( data ! = null ) { return getAggregators ( data ) ; } return null ; } 
2813	public void cacheLocation ( final TableName tableName , final ServerName source , final HRegionLocation location ) { assert source ! = null ; byte [ ] startKey = location . getRegion ( ) . getStartKey ( ) ; ConcurrentMap < byte [ ] , RegionLocations > tableLocations = getTableLocations ( tableName ) ; RegionLocations locations = new RegionLocations ( new HRegionLocation [ ] { location } ) ; RegionLocations oldLocations = tableLocations . putIfAbsent ( startKey , locations ) ; boolean isNewCacheEntry = ( oldLocations = = null ) ; if ( isNewCacheEntry ) { if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( _STR + location ) ; } addToCachedServers ( updatedLocations ) ; } } 
2814	public String registerCoder ( Coder < ? > coder ) throws IOException { String existing = coderIds . get ( Equivalence . identity ( ) . wrap ( coder ) ) ; if ( existing ! = null ) { return existing ; } String baseName = NameUtils . approximateSimpleName ( coder ) ; String name = uniqify ( baseName , coderIds . values ( ) ) ; coderIds . put ( Equivalence . identity ( ) . wrap ( coder ) , name ) ; RunnerApi . Coder coderProto = CoderTranslation . toProto ( coder , this ) ; componentsBuilder . putCoders ( name , coderProto ) ; return name ; } 
2815	void removeEncryptionZone ( Long inodeId ) { assert dir . hasWriteLock ( ) ; encryptionZones . remove ( inodeId ) ; } 
2816	private void init ( ) { if ( isStarQuery ) { selectedImplicitColumns . putAll ( allImplicitColumns ) ; } else { for ( SchemaPath column : columns ) { String path = column . getRootSegmentPath ( ) ; if ( isPartitionColumn ( partitionDesignator , path ) ) { selectedPartitionColumns . add ( Integer . parseInt ( path . substring ( partitionDesignator . length ( ) ) ) ) ; } else if ( allImplicitColumns . get ( path ) ! = null ) { selectedImplicitColumns . put ( path , allImplicitColumns . get ( path ) ) ; } else { tableColumns . add ( column ) ; } } } } 
2817	public void recalculatePositionOfItemAt ( int index ) { TODO can be improved final T item = get ( index ) ; removeItemAtIndex ( index , false ) ; int newIndex = add ( item , false ) ; if ( index ! = newIndex ) { mCallback . onMoved ( index , newIndex ) ; } } 
2818	public static org . apache . xmlbeans . xml . stream . XMLInputStream newValidatingXMLInputStream ( org . apache . xmlbeans . xml . stream . XMLInputStream xis ) throws org . apache . xmlbeans . XmlException , org . apache . xmlbeans . xml . stream . XMLStreamException { return XmlBeans . getContextTypeLoader ( ) . newValidatingXMLInputStream ( xis , type , null ) ; } 
2819	public PDFunction getTransferFunction ( ) throws IOException { if ( transferFunction = = null ) { COSBase cosTF = getCOSObject ( ) . getDictionaryObject ( COSName . TR ) ; if ( cosTF ! = null ) { transferFunction = PDFunction . create ( cosTF ) ; } } return transferFunction ; } 
2820	 @ SuppressWarnings ( _STR , hash ) ; GetDataMessage getdata = new GetDataMessage ( params ) ; getdata . addTransaction ( hash ) ; return sendSingleGetData ( getdata ) ; } 
2821	protected RelNode transform ( PlannerType plannerType , PlannerPhase phase , RelNode input , RelTraitSet targetTraits , boolean log ) { final Stopwatch watch = Stopwatch . createStarted ( ) ; final RuleSet rules = config . getRules ( phase ) ; final RelTraitSet toTraits = targetTraits . simplify ( ) ; final RelNode output ; switch ( plannerType ) { case HEP _ BOTTOM _ UP : case HEP : { final HepProgramBuilder hepPgmBldr = new HepProgramBuilder ( ) ; if ( plannerType = = PlannerType . HEP _ BOTTOM _ UP ) { hepPgmBldr . addMatchOrder ( HepMatchOrder . BOTTOM _ UP ) ; } for ( RelOptRule rule : rules ) { hepPgmBldr . addRuleInstance ( rule ) ; } Set noDAG = true to avoid caching problems which lead to incorrect Drill work . final HepPlanner planner = new HepPlanner ( hepPgmBldr . build ( ) , context . getPlannerSettings ( ) , true , null , RelOptCostImpl . FACTORY ) ; JaninoRelMetadataProvider relMetadataProvider = JaninoRelMetadataProvider . of ( DrillDefaultRelMetadataProvider . INSTANCE ) ; RelMetadataQuery . THREAD _ PROVIDERS . set ( relMetadataProvider ) ; Modify RelMetaProvider for every RelNode in the SQL operator Rel tree . input . accept ( new MetaDataProviderModifier ( relMetadataProvider ) ) ; planner . setRoot ( input ) ; if ( ! input . getTraitSet ( ) . equals ( targetTraits ) ) { planner . changeTraits ( input , toTraits ) ; } output = planner . findBestExp ( ) ; break ; } case VOLCANO : default : { as weird as it seems , the cluster ' s only planner is the volcano planner . final RelOptPlanner planner = input . getCluster ( ) . getPlanner ( ) ; final Program program = Programs . of ( rules ) ; Preconditions . checkArgument ( planner instanceof VolcanoPlanner , _STR , planner . getClass ( ) . getName ( ) ) ; output = program . run ( planner , input , toTraits , ImmutableList . < RelOptMaterialization > of ( ) , ImmutableList . < RelOptLattice > of ( ) ) ; break ; } } if ( log ) { log ( plannerType , phase , output , logger , watch ) ; } return output ; } 
2822	public EventBatch poll ( ) throws IOException , MissingEventsException { TraceScope scope = Trace . startSpan ( _STR , lastReadTxid ) ; return null ; } } if ( it . hasNext ( ) ) { newly seen edit log ops actually got converted to events return it . next ( ) ; } else { return null ; } } finally { scope . close ( ) ; } } 
2823	public void copyCommandTemplateToTemplateTest ( ) throws ConfigurationException { con = prepare ( ) ; con . setMethodResponse ( _STR + linux . getRemoteDir ( ) ; TemplateObjectTO src = template ( templateid , linux . getRepoId ( ) , storeUrl , templatedir ) ; TemplateObjectTO dest = template ( targetid , linux . getRepoId ( ) , linux . getRepoId ( ) , linux . getTemplatesDir ( ) ) ; CopyCommand copy = new CopyCommand ( src , dest , _NUM , true ) ; CopyCmdAnswer ra = ( CopyCmdAnswer ) hypervisor . executeRequest ( copy ) ; TemplateObjectTO vol = ( TemplateObjectTO ) ra . getNewData ( ) ; results . basicStringTest ( vol . getUuid ( ) , targetid ) ; results . basicStringTest ( vol . getPath ( ) , targetid ) ; results . basicBooleanTest ( ra . getResult ( ) ) ; } 
2824	public int getNumberOfExceutions ( ProjectBuildList projectBuildList ) throws InvalidPluginDescriptorException , PluginVersionResolutionException , PluginDescriptorParsingException , NoPluginFoundForPrefixException , MojoNotFoundException , PluginNotFoundException , PluginResolutionException , LifecyclePhaseNotFoundException , LifecycleNotFoundException { int result = _NUM ; for ( ProjectSegment projectBuild : projectBuildList ) { MavenExecutionPlan plan = calculateExecutionPlan ( projectBuild . getSession ( ) , projectBuild . getProject ( ) , projectBuild . getTaskSegment ( ) . getTasks ( ) ) ; result + = plan . size ( ) ; } return result ; } 
2825	ResourceInstance createRequestResource ( String clusterName , String requestId ) { Map < Resource . Type , String > mapIds = new HashMap < > ( ) ; if ( null ! = clusterName ) mapIds . put ( Resource . Type . Cluster , clusterName ) ; mapIds . put ( Resource . Type . Request , requestId ) ; return createResource ( Resource . Type . Request , mapIds ) ; } 
2826	public long getTtl ( ) { return getEndpoint ( ) . getTtl ( ) ; } 
2827	public List < String > getImageUrlList ( ) { if ( cloned = = null ) { cloneAndProcessNode ( ) ; } List < String > imgUrls = new ArrayList < > ( ) ; NodeList < Element > imgs = DomUtil . querySelectorAll ( cloned , _STR ) ; for ( int i = _NUM ; i < imgs . getLength ( ) ; i + + ) { ImageElement ie = ( ImageElement ) imgs . getItem ( i ) ; if ( ! ie . getSrc ( ) . isEmpty ( ) ) { imgUrls . add ( ie . getSrc ( ) ) ; } imgUrls . addAll ( DomUtil . getAllSrcSetUrls ( ie ) ) ; } return imgUrls ; } 
2828	public java . awt . Image createAwtImage ( Color foreground , Color background ) { int f = foreground . getRGB ( ) ; int g = background . getRGB ( ) ; Canvas canvas = new Canvas ( ) ; String bCode = code ; if ( extended ) bCode = getCode _NUM _NUM Ex ( code ) ; if ( generateChecksum ) bCode + = getChecksum ( bCode ) ; int len = bCode . length ( ) + _NUM ; int nn = ( int ) n ; int fullWidth = len * ( _NUM + _NUM * nn ) + ( len - _NUM ) ; byte [ ] bars = getBarsCode _NUM _NUM ( bCode ) ; boolean print = true ; int ptr = _NUM ; int height = ( int ) barHeight ; int [ ] pix = new int [ fullWidth * height ] ; for ( int k = _NUM ; k < bars . length ; + + k ) { int w = ( bars [ k ] = = _NUM ? _NUM : nn ) ; int c = g ; if ( print ) c = f ; print = ! print ; for ( int j = _NUM ; j < w ; + + j ) pix [ ptr + + ] = c ; } for ( int k = fullWidth ; k < pix . length ; k + = fullWidth ) { System . arraycopy ( pix , _NUM , pix , k , fullWidth ) ; } Image img = canvas . createImage ( new MemoryImageSource ( fullWidth , height , pix , _NUM , fullWidth ) ) ; return img ; } 
2829	protected void fireRemove ( CmsPublishJobFinished publishJob ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( Messages . get ( ) . getBundle ( ) . key ( Messages . LOG _ PUBLISH _ JOB _ REMOVE _ _NUM ) ) ; } for ( Iterator < I _ CmsPublishEventListener > it = iterator ( ) ; it . hasNext ( ) ; ) { I _ CmsPublishEventListener listener = it . next ( ) ; try { listener . onRemove ( publishJob ) ; } catch ( Throwable t ) { catch every thing including runtime exceptions if ( LOG . isErrorEnabled ( ) ) { LOG . error ( Messages . get ( ) . getBundle ( ) . key ( Messages . ERR _ PUBLISH _ JOB _ REMOVE _ ERROR _ _NUM , listener . getClass ( ) . getName ( ) ) , t ) ; } if ( publishJob . m _ publishJob . getPublishReport ( ) ! = null ) { publishJob . m _ publishJob . getPublishReport ( ) . println ( t ) ; } } } } 
2830	public final IonTextWriterBuilder withCharsetAscii ( ) { return withCharset ( ASCII ) ; } 
2831	public static IncidentReportArgs parseSetting ( String setting ) throws IllegalArgumentException { if ( setting = = null | | setting . length ( ) = = _NUM ) { return null ; } setting = setting . trim ( ) ; if ( setting . length ( ) = = _NUM | | _STR ) ; } args . addSection ( section ) ; } return args ; } 
2832	public boolean performAccessibilityAction ( Recycler recycler , State state , int action , Bundle args ) { if ( mRecyclerView = = null ) { return false ; } int vScroll = _NUM , hScroll = _NUM ; switch ( action ) { case AccessibilityNodeInfoCompat . ACTION _ SCROLL _ BACKWARD : if ( mRecyclerView . canScrollVertically ( - _NUM ) ) { vScroll = - ( getHeight ( ) - getPaddingTop ( ) - getPaddingBottom ( ) ) ; } if ( mRecyclerView . canScrollHorizontally ( - _NUM ) ) { hScroll = - ( getWidth ( ) - getPaddingLeft ( ) - getPaddingRight ( ) ) ; } break ; case AccessibilityNodeInfoCompat . ACTION _ SCROLL _ FORWARD : if ( mRecyclerView . canScrollVertically ( _NUM ) ) { vScroll = getHeight ( ) - getPaddingTop ( ) - getPaddingBottom ( ) ; } if ( mRecyclerView . canScrollHorizontally ( _NUM ) ) { hScroll = getWidth ( ) - getPaddingLeft ( ) - getPaddingRight ( ) ; } break ; } if ( vScroll = = _NUM & & hScroll = = _NUM ) { return false ; } mRecyclerView . scrollBy ( hScroll , vScroll ) ; return true ; } 
2833	protected void executeLifecycle ( HttpAction action ) { incCounter ( action . dsRef , Requests ) ; incCounter ( action . srvRef , Requests ) ; startRequest ( action ) ; try { validate ( action ) ; } catch ( ActionErrorException ex ) { incCounter ( action . dsRef , RequestsBad ) ; throw ex ; } try { perform ( action ) ; Success incCounter ( action . srvRef , RequestsGood ) ; incCounter ( action . dsRef , RequestsGood ) ; } catch ( ActionErrorException ex ) { incCounter ( action . srvRef , RequestsBad ) ; incCounter ( action . dsRef , RequestsBad ) ; throw ex ; } catch ( QueryCancelledException ex ) { incCounter ( action . srvRef , RequestsBad ) ; incCounter ( action . dsRef , RequestsBad ) ; throw ex ; } finally { finishRequest ( action ) ; } } 
2834	public Object build ( ) { verify ( ) ; first try to use a builder class if one is available try { LOGGER . debug ( _STR , this . clazz , this . node . getName ( ) , ( e instanceof InvocationTargetException ? ( ( InvocationTargetException ) e ) . getCause ( ) : e ) . toString ( ) , e ) ; return null ; } } 
2835	public static void sendRedirect ( HttpServletRequest request , HttpServletResponse response , String target ) throws IOException { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( _STR ) . _ ( ) . _ ( ) . _ ( ) ; writer . close ( ) ; } 
2836	public void addFocusables ( ArrayList < View > views , int direction , int focusableMode ) { final int focusableCount = views . size ( ) ; final int descendantFocusability = getDescendantFocusability ( ) ; if ( descendantFocusability ! = FOCUS _ BLOCK _ DESCENDANTS ) { for ( int i = _NUM ; i < getChildCount ( ) ; i + + ) { final View child = getChildAt ( i ) ; if ( child . getVisibility ( ) = = VISIBLE ) { ItemInfo ii = infoForChild ( child ) ; if ( ii ! = null & & ii . position = = mCurItem ) { child . addFocusables ( views , direction , focusableMode ) ; } } } } among the focusable children would be more interesting . if ( descendantFocusability ! = FOCUS _ AFTER _ DESCENDANTS | | ( focusableCount = = views . size ( ) ) ) { add all views in . So we need to do the same thing View does . if ( ! isFocusable ( ) ) { return ; } if ( ( focusableMode & FOCUSABLES _ TOUCH _ MODE ) = = FOCUSABLES _ TOUCH _ MODE & & isInTouchMode ( ) & & ! isFocusableInTouchMode ( ) ) { return ; } if ( views ! = null ) { views . add ( this ) ; } } } 
2837	protected void setter ( MyHeap heap , double upper _ bound , final int k ) throws Exception { if ( heap . size ( ) > _NUM ) heap . m _ heap [ _NUM ] . index = _NUM ; while ( heap . size ( ) < k ) { heap . put ( upper _ bound ) ; } } 
2838	private Method getPropertyFunction ( Class targetClass , String prefix , Class valueType ) { TODO : faster implementation . . . Method returnVal = null ; String methodName = getMethodName ( prefix , mPropertyName ) ; Class [ ] args = null ; if ( valueType = = null ) { try { returnVal = targetClass . getMethod ( methodName , args ) ; } catch ( NoSuchMethodException e ) { try { returnVal = targetClass . getDeclaredMethod ( methodName , args ) ; returnVal . setAccessible ( true ) ; } catch ( NoSuchMethodException e _NUM ) { Log . e ( _STR + mValueType ) ; } return returnVal ; } 
2839	public String generateToolTip ( XYDataset dataset , int series , int item ) { return generateLabelString ( dataset , series , item ) ; } 
2840	public void clearUserCache ( CmsUser user ) { uncacheUser ( user ) ; flushCache ( CacheType . RESOURCE _ LIST ) ; } 
2841	public ParcelFileDescriptor establishVpn ( VpnConfig config ) { int user = UserHandle . getUserId ( Binder . getCallingUid ( ) ) ; synchronized ( mVpns ) { throwIfLockdownEnabled ( ) ; return mVpns . get ( user ) . establish ( config ) ; } } 
2842	public static < I , O > List < O > map ( @ Nullable List < I > cur , Function < ? super I , ? extends O > f ) { if ( isEmpty ( cur ) ) return Collections . emptyList ( ) ; final ArrayList < O > result = new ArrayList < > ( ) ; for ( int i = _NUM ; i < cur . size ( ) ; i + + ) { result . add ( f . apply ( cur . get ( i ) ) ) ; } return result ; } 
2843	public static final void setLong ( long value , byte [ ] b , int idx ) { int lo = ( int ) ( value & _NUM xFFFFFFFFL ) ; int hi = ( int ) ( value > > > _NUM _NUM ) ; setInt ( hi , b , idx ) ; setInt ( lo , b , idx + _NUM ) ; } 
2844	public static String [ ] toStringArray ( final Object [ ] array , final String valueForNullElements ) { if ( null = = array ) { return null ; } else if ( array . length = = _NUM ) { return EMPTY _ STRING _ ARRAY ; } final String [ ] result = new String [ array . length ] ; for ( int i = _NUM ; i < array . length ; i + + ) { final Object object = array [ i ] ; result [ i ] = ( object = = null ? valueForNullElements : object . toString ( ) ) ; } return result ; } 
2845	public void decrypt ( KeyParameter aesKey ) { This code must be exception safe . checkNotNull ( aesKey ) ; BasicKeyChain newBasic = basic . toDecrypted ( aesKey ) ; List < DeterministicKeyChain > newChains = new ArrayList < > ( chains . size ( ) ) ; for ( DeterministicKeyChain chain : chains ) newChains . add ( chain . toDecrypted ( aesKey ) ) ; this . keyCrypter = null ; basic = newBasic ; chains . clear ( ) ; chains . addAll ( newChains ) ; } 
2846	protected String getParentPath ( String path ) { Root does not have a parent . if ( isRoot ( path ) ) { return null ; } int separatorIndex = path . lastIndexOf ( PATH _ SEPARATOR ) ; if ( separatorIndex < _NUM ) { return null ; } return path . substring ( _NUM , separatorIndex ) ; } 
2847	private static byte [ ] parseIP ( String data ) throws IOException { byte [ ] encoded = parseIPv _NUM ( data ) ; if ( encoded = = null ) { encoded = parseIPv _NUM ( data ) ; } if ( encoded = = null ) { throw new IOException ( _STR ) ; } return encoded ; } 
2848	public void onClick ( View v ) { if ( mExpanded ) { collapseView ( ) ; } else { expandView ( ) ; } } 
2849	public < R > StreamEx < R > flatMapToObj ( IntFunction < ? extends Stream < R > > mapper ) { return new StreamEx < > ( stream ( ) . mapToObj ( mapper ) . flatMap ( Function . identity ( ) ) , context ) ; } 
2850	public boolean onTouchEvent ( MotionEvent ev ) { Short circuit if we have no children boolean hasChildren = ( mSv . getChildCount ( ) > _NUM ) ; if ( ! hasChildren ) { return false ; } Pass through to swipe helper if we are swiping if ( mInterceptedBySwipeHelper & & mSwipeHelper . onTouchEvent ( ev ) ) { return true ; } Update the velocity tracker initVelocityTrackerIfNotExists ( ) ; int action = ev . getAction ( ) ; switch ( action & MotionEvent . ACTION _ MASK ) { case MotionEvent . ACTION _ DOWN : { Save the touch down info mInitialMotionX = mLastMotionX = ( int ) ev . getX ( ) ; mInitialMotionY = mLastMotionY = ( int ) ev . getY ( ) ; mInitialP = mLastP = mSv . mLayoutAlgorithm . screenYToCurveProgress ( mLastMotionY ) ; mActivePointerId = ev . getPointerId ( _NUM ) ; mActiveTaskView = findViewAtPoint ( mLastMotionX , mLastMotionY ) ; Stop the current scroll if it is still flinging mScroller . stopScroller ( ) ; mScroller . stopBoundScrollAnimation ( ) ; Initialize the velocity tracker initOrResetVelocityTracker ( ) ; mVelocityTracker . addMovement ( createMotionEventForStackScroll ( ev ) ) ; Disallow parents from intercepting touch events final ViewParent parent = mSv . getParent ( ) ; if ( parent ! = null ) { parent . requestDisallowInterceptTouchEvent ( true ) ; } break ; } case MotionEvent . ACTION _ POINTER _ DOWN : { final int index = ev . getActionIndex ( ) ; mActivePointerId = ev . getPointerId ( index ) ; mLastMotionX = ( int ) ev . getX ( index ) ; mLastMotionY = ( int ) ev . getY ( index ) ; mLastP = mSv . mLayoutAlgorithm . screenYToCurveProgress ( mLastMotionY ) ; break ; } case MotionEvent . ACTION _ MOVE : { if ( mActivePointerId = = INACTIVE _ POINTER _ ID ) break ; int activePointerIndex = ev . findPointerIndex ( mActivePointerId ) ; int x = ( int ) ev . getX ( activePointerIndex ) ; int y = ( int ) ev . getY ( activePointerIndex ) ; int yTotal = Math . abs ( y - mInitialMotionY ) ; float curP = mSv . mLayoutAlgorithm . screenYToCurveProgress ( y ) ; float deltaP = mLastP - curP ; if ( ! mIsScrolling ) { if ( yTotal > mScrollTouchSlop ) { mIsScrolling = true ; Initialize the velocity tracker initOrResetVelocityTracker ( ) ; mVelocityTracker . addMovement ( createMotionEventForStackScroll ( ev ) ) ; Disallow parents from intercepting touch events final ViewParent parent = mSv . getParent ( ) ; if ( parent ! = null ) { parent . requestDisallowInterceptTouchEvent ( true ) ; } } } if ( mIsScrolling ) { float curStackScroll = mScroller . getStackScroll ( ) ; float overScrollAmount = mScroller . getScrollAmountOutOfBounds ( curStackScroll + deltaP ) ; if ( Float . compare ( overScrollAmount , _NUM f ) ! = _NUM ) { Bound the overscroll to a fixed amount , and inversely scale the y - movement relative to how close we are to the max overscroll float maxOverScroll = mConfig . taskStackOverscrollPct ; deltaP * = ( _NUM f - ( Math . min ( maxOverScroll , overScrollAmount ) / maxOverScroll ) ) ; } mScroller . setStackScroll ( curStackScroll + deltaP ) ; if ( mScroller . isScrollOutOfBounds ( ) ) { mVelocityTracker . clear ( ) ; } else { mVelocityTracker . addMovement ( createMotionEventForStackScroll ( ev ) ) ; } } mLastMotionX = x ; mLastMotionY = y ; mLastP = mSv . mLayoutAlgorithm . screenYToCurveProgress ( mLastMotionY ) ; mTotalPMotion + = Math . abs ( deltaP ) ; break ; } case MotionEvent . ACTION _ UP : { final VelocityTracker velocityTracker = mVelocityTracker ; velocityTracker . computeCurrentVelocity ( _NUM _NUM _NUM _NUM , mMaximumVelocity ) ; int velocity = ( int ) velocityTracker . getYVelocity ( mActivePointerId ) ; if ( mIsScrolling & & ( Math . abs ( velocity ) > mMinimumVelocity ) ) { int overscrollRange = ( int ) ( Math . min ( _NUM f , Math . abs ( ( float ) velocity / mMaximumVelocity ) ) * TaskStackOverscrollRange ) ; Fling scroll mScroller . mScroller . fling ( _NUM , mScroller . progressToScrollRange ( mScroller . getStackScroll ( ) ) , _NUM , velocity , _NUM , _NUM , mScroller . progressToScrollRange ( mSv . mLayoutAlgorithm . mMinScrollP ) , mScroller . progressToScrollRange ( mSv . mLayoutAlgorithm . mMaxScrollP ) , _NUM , overscrollRange ) ; Invalidate to kick off computeScroll mSv . invalidate ( ) ; } else if ( mScroller . isScrollOutOfBounds ( ) ) { Animate the scroll back into bounds mScroller . animateBoundScroll ( ) ; } mActivePointerId = INACTIVE _ POINTER _ ID ; mIsScrolling = false ; mTotalPMotion = _NUM ; recycleVelocityTracker ( ) ; break ; } case MotionEvent . ACTION _ POINTER _ UP : { int pointerIndex = ev . getActionIndex ( ) ; int pointerId = ev . getPointerId ( pointerIndex ) ; if ( pointerId = = mActivePointerId ) { Select a new active pointer id and reset the motion state final int newPointerIndex = ( pointerIndex = = _NUM ) ? _NUM : _NUM ; mActivePointerId = ev . getPointerId ( newPointerIndex ) ; mLastMotionX = ( int ) ev . getX ( newPointerIndex ) ; mLastMotionY = ( int ) ev . getY ( newPointerIndex ) ; mLastP = mSv . mLayoutAlgorithm . screenYToCurveProgress ( mLastMotionY ) ; mVelocityTracker . clear ( ) ; } break ; } case MotionEvent . ACTION _ CANCEL : { if ( mScroller . isScrollOutOfBounds ( ) ) { Animate the scroll back into bounds mScroller . animateBoundScroll ( ) ; } mActivePointerId = INACTIVE _ POINTER _ ID ; mIsScrolling = false ; mTotalPMotion = _NUM ; recycleVelocityTracker ( ) ; break ; } } return true ; } 
2851	public void registerAudioPortUpdateListener ( OnAudioPortUpdateListener l ) { sAudioPortEventHandler . init ( ) ; sAudioPortEventHandler . registerListener ( l ) ; } 
2852	public void adjustChildren ( int widthMeasureSpec , int heightMeasureSpec ) { if ( DEBUG ) { Log . d ( TAG , _STR + info ) ; } if ( info ! = null ) { if ( params instanceof ViewGroup . MarginLayoutParams ) { info . fillMarginLayoutParams ( view , ( ViewGroup . MarginLayoutParams ) params , widthHint , heightHint ) ; } else { info . fillLayoutParams ( params , widthHint , heightHint ) ; } } } } } 
2853	public void testMove _NUM ( ) throws Exception { try { CmsObject cms = rootCms ( ) ; cms . lockResource ( _STR ) ; } finally { restoreFiles ( ) ; } } 
2854	public void assertNotGreaterThan ( Description description , Short actual , short expected ) { assertNotNull ( description , actual ) ; if ( isGreaterThan ( actual , expected ) ) { throw failures . failure ( description , shouldNotBeGreaterThan ( actual , expected ) ) ; } } 
2855	ActivityStack getValidLaunchStackOnDisplay ( int displayId , @ NonNull ActivityRecord r ) { final ActivityDisplay activityDisplay = getActivityDisplayOrCreateLocked ( displayId ) ; if ( activityDisplay = = null ) { throw new IllegalArgumentException ( _STR + displayId ) ; return null ; } 
2856	public void registerAudioRecordingCallback ( @ NonNull AudioRecordingCallback cb , Handler handler ) { if ( cb = = null ) { throw new IllegalArgumentException ( _STR ) ; } } } 
2857	public static Marker getMarker ( final String name , final String parent ) { final Marker parentMarker = MARKERS . get ( parent ) ; if ( parentMarker = = null ) { throw new IllegalArgumentException ( _STR ) ; } return getMarker ( name , parentMarker ) ; } 
2858	private void adjust ( final int nd ) { int n = nd ; mod . set ( n , true ) ; while ( n ! = - _NUM & & n ! = root & & mod . get ( parent ( n ) ) ) { if ( parent ( n ) = = left ( parent ( parent ( n ) ) ) ) { final int y = right ( parent ( parent ( n ) ) ) ; if ( y ! = - _NUM & & mod . get ( y ) ) { mod . set ( parent ( n ) , false ) ; mod . set ( y , false ) ; mod . set ( parent ( parent ( n ) ) , true ) ; n = parent ( parent ( n ) ) ; } else { if ( n = = right ( parent ( n ) ) ) { n = parent ( n ) ; rotateLeft ( n ) ; } mod . set ( parent ( n ) , false ) ; mod . set ( parent ( parent ( n ) ) , true ) ; if ( parent ( parent ( n ) ) ! = - _NUM ) rotateRight ( parent ( parent ( n ) ) ) ; } } else { final int y = left ( parent ( parent ( n ) ) ) ; if ( y ! = - _NUM & & mod . get ( y ) ) { mod . set ( parent ( n ) , false ) ; mod . set ( y , false ) ; mod . set ( parent ( parent ( n ) ) , true ) ; n = parent ( parent ( n ) ) ; } else { if ( n = = left ( parent ( n ) ) ) { n = parent ( n ) ; rotateRight ( n ) ; } mod . set ( parent ( n ) , false ) ; mod . set ( parent ( parent ( n ) ) , true ) ; if ( parent ( parent ( n ) ) ! = - _NUM ) rotateLeft ( parent ( parent ( n ) ) ) ; } } } mod . set ( root , false ) ; } 
2859	public boolean writeObject ( String name , Object o ) { name = fixFileName ( name ) ; cache . put ( name , o ) ; DataOutputStream d = null ; try { d = new DataOutputStream ( createOutputStream ( name ) ) ; Util . writeObject ( o , d ) ; d . close ( ) ; return true ; } catch ( Exception err ) { Log . e ( err ) ; if ( Log . isCrashBound ( ) ) { Log . sendLog ( ) ; } Util . getImplementation ( ) . deleteStorageFile ( name ) ; Util . getImplementation ( ) . cleanup ( d ) ; return false ; } } 
2860	private CalciteCatalogReader createCatalogReader ( ) { final SchemaPlus rootSchema = rootSchema ( defaultSchema ) ; final Context context = config . getContext ( ) ; final CalciteConnectionConfig connectionConfig ; if ( context ! = null ) { connectionConfig = context . unwrap ( CalciteConnectionConfig . class ) ; } else { Properties properties = new Properties ( ) ; properties . setProperty ( CalciteConnectionProperty . CASE _ SENSITIVE . camelName ( ) , String . valueOf ( parserConfig . caseSensitive ( ) ) ) ; connectionConfig = new CalciteConnectionConfigImpl ( properties ) ; } return new CalciteCatalogReader ( CalciteSchema . from ( rootSchema ) , CalciteSchema . from ( defaultSchema ) . path ( null ) , typeFactory , connectionConfig ) ; } 
2861	public void setZoom ( TouchImageView img ) { PointF center = img . getScrollPosition ( ) ; setZoom ( img . getCurrentZoom ( ) , center . x , center . y , img . getScaleType ( ) ) ; } 
2862	Map < String , T > getMap ( ) throws Exception { if ( indexInSubtaskGroup = = _NUM ) { return getMapFromBroadcastState ( ) ; } else { Map < String , T > result = ( Map < String , T > ) stateForNonZeroOperator . get ( name ) ; maybe restore from BroadcastState of Operator - _NUM if ( result = = null ) { result = getMapFromBroadcastState ( ) ; if ( result ! = null ) { stateForNonZeroOperator . put ( name , result ) ; we don ' t need it anymore , must clear it . flinkStateBackend . getUnionListState ( flinkStateDescriptor ) . clear ( ) ; } } return result ; } } 
2863	public GetTemplateResponse getTemplate ( final String templateName ) throws RestClientException { final String getTempalteInternalUrl = getFormattedUrl ( versionedTemplatesControllerUrl , GET _ TEMPALTE _ URL _ FORMAT , templateName ) ; log ( Level . FINE , _STR ) ; return executor . get ( getTempalteInternalUrl , new TypeReference < Response < GetTemplateResponse > > ( ) { } ) ; } 
2864	private void enqueueAgentCommands ( Cluster cluster , String clusterName , Collection < String > hosts ) { if ( null = = clusterName ) { LOG . warn ( _STR , ae ) ; } TODO implement alert execution commands logic m _ actionQueue . enqueue ( hostName , command ) ; } } finally { m _ actionQueueLock . unlock ( ) ; } } 
2865	public boolean revokeRuntimePermission ( String packageName , String permission , UserHandle userHandle ) { synchronized ( mLock ) { throwIfNotConnectedLocked ( ) ; } try { if ( DEBUG ) { Log . i ( LOG _ TAG , _STR , re ) ; } return false ; } 
2866	private void resolveShouldLayoutReverse ( ) { A = = B is the same result , but we rather keep it readable if ( mOrientation = = VERTICAL | | ! isLayoutRTL ( ) ) { mShouldReverseLayout = mReverseLayout ; } else { mShouldReverseLayout = ! mReverseLayout ; } } 
2867	public static List < String > getFiles ( String zipFileName , String fileExt ) { if ( zipFileName . endsWith ( _STR + Constants . TAR _ GZ ) ) return getFilesFromTGZ ( zipFileName , fileExt ) ; return null ; } 
2868	private IonStruct makeIonRepresentation ( ValueFactory factory ) { IonStruct ionRep = factory . newEmptyStruct ( ) ; ionRep . addTypeAnnotation ( ION _ SYMBOL _ TABLE ) ; SymbolTable [ ] importedTables = getImportedTablesNoCopy ( ) ; if ( importedTables . length > _NUM ) { IonList importsList = factory . newEmptyList ( ) ; for ( int i = _NUM ; i < importedTables . length ; i + + ) { SymbolTable importedTable = importedTables [ i ] ; IonStruct importStruct = factory . newEmptyStruct ( ) ; importStruct . add ( NAME , factory . newString ( importedTable . getName ( ) ) ) ; importStruct . add ( VERSION , factory . newInt ( importedTable . getVersion ( ) ) ) ; importStruct . add ( MAX _ ID , factory . newInt ( importedTable . getMaxId ( ) ) ) ; importsList . add ( importStruct ) ; } ionRep . add ( IMPORTS , importsList ) ; } if ( mySymbolsCount > _NUM ) { int sid = myFirstLocalSid ; for ( int offset = _NUM ; offset < mySymbolsCount ; offset + + , sid + + ) { String symbolName = mySymbolNames [ offset ] ; recordLocalSymbolInIonRep ( ionRep , symbolName , sid ) ; } } return ionRep ; } 
2869	public void setRGBColorStroke ( int red , int green , int blue ) { checkNoColor ( ) ; super . setRGBColorStroke ( red , green , blue ) ; } 
2870	public boolean isEnforcedTrackedChangesProtection ( ) { return settings . isEnforcedWith ( STDocProtect . TRACKED _ CHANGES ) ; } 
2871	public void testMemStore ( ) throws Exception { HTableDescriptor htd = hbu . createTableDescriptor ( name . getMethodName ( ) , _NUM , _NUM _NUM _NUM _NUM , _NUM , KeepDeletedCells . FALSE ) ; HRegion region = hbu . createLocalHRegion ( htd , null , null ) ; _NUM s in the past long ts = EnvironmentEdgeManager . currentTime ( ) - _NUM _NUM _NUM _NUM ; try { _NUM nd version Put p = new Put ( T _NUM , ts - _NUM ) ; p . addColumn ( c _NUM , c _NUM , T _NUM ) ; region . put ( p ) ; _NUM rd version p = new Put ( T _NUM , ts - _NUM ) ; p . addColumn ( c _NUM , c _NUM , T _NUM ) ; region . put ( p ) ; _NUM th version p = new Put ( T _NUM , ts ) ; p . addColumn ( c _NUM , c _NUM , T _NUM ) ; region . put ( p ) ; now flush / compact region . flush ( true ) ; region . compact ( true ) ; now put the first version ( backdated ) p = new Put ( T _NUM , ts - _NUM ) ; p . addColumn ( c _NUM , c _NUM , T _NUM ) ; region . put ( p ) ; now the latest change is in the memstore , but it is not the latest version Result r = region . get ( new Get ( T _NUM ) ) ; checkResult ( r , c _NUM , T _NUM ) ; Get g = new Get ( T _NUM ) ; g . setMaxVersions ( ) ; this ' ll use ScanWildcardColumnTracker r = region . get ( g ) ; checkResult ( r , c _NUM , T _NUM , T _NUM ) ; g = new Get ( T _NUM ) ; g . setMaxVersions ( ) ; g . addColumn ( c _NUM , c _NUM ) ; this ' ll use ExplicitColumnTracker r = region . get ( g ) ; checkResult ( r , c _NUM , T _NUM , T _NUM ) ; p = new Put ( T _NUM , ts + _NUM ) ; p . addColumn ( c _NUM , c _NUM , T _NUM ) ; region . put ( p ) ; now the latest version is in the memstore g = new Get ( T _NUM ) ; g . setMaxVersions ( ) ; this ' ll use ScanWildcardColumnTracker r = region . get ( g ) ; checkResult ( r , c _NUM , T _NUM , T _NUM ) ; g = new Get ( T _NUM ) ; g . setMaxVersions ( ) ; g . addColumn ( c _NUM , c _NUM ) ; this ' ll use ExplicitColumnTracker r = region . get ( g ) ; checkResult ( r , c _NUM , T _NUM , T _NUM ) ; } finally { HBaseTestingUtility . closeRegionAndWAL ( region ) ; } } 
2872	private void buildACL ( String [ ] userGroupStrings ) { users = new HashSet < String > ( ) ; groups = new HashSet < String > ( ) ; for ( String aclPart : userGroupStrings ) { if ( aclPart ! = null & & isWildCardACLValue ( aclPart ) ) { allAllowed = true ; break ; } } if ( ! allAllowed ) { if ( userGroupStrings . length > = _NUM & & userGroupStrings [ _NUM ] ! = null ) { users = StringUtils . getTrimmedStringCollection ( userGroupStrings [ _NUM ] ) ; } if ( userGroupStrings . length = = _NUM & & userGroupStrings [ _NUM ] ! = null ) { groups = StringUtils . getTrimmedStringCollection ( userGroupStrings [ _NUM ] ) ; groupsMapping . cacheGroupsAdd ( new LinkedList < String > ( groups ) ) ; } } } 
2873	public void testGet _ FromMemStoreAndFiles ( ) throws IOException { init ( this . name . getMethodName ( ) ) ; Put data in memstore this . store . add ( new KeyValue ( row , family , qf _NUM , _NUM , ( byte [ ] ) null ) , null ) ; this . store . add ( new KeyValue ( row , family , qf _NUM , _NUM , ( byte [ ] ) null ) , null ) ; flush flush ( _NUM ) ; Add more data this . store . add ( new KeyValue ( row , family , qf _NUM , _NUM , ( byte [ ] ) null ) , null ) ; this . store . add ( new KeyValue ( row , family , qf _NUM , _NUM , ( byte [ ] ) null ) , null ) ; flush flush ( _NUM ) ; Add more data this . store . add ( new KeyValue ( row , family , qf _NUM , _NUM , ( byte [ ] ) null ) , null ) ; this . store . add ( new KeyValue ( row , family , qf _NUM , _NUM , ( byte [ ] ) null ) , null ) ; Get result = HBaseTestingUtility . getFromStoreFile ( store , get . getRow ( ) , qualifiers ) ; Need to sort the result since multiple files Collections . sort ( result , CellComparatorImpl . COMPARATOR ) ; Compare assertCheck ( ) ; } 
2874	public void dismiss ( ) { mPopup . dismiss ( ) ; removePromptView ( ) ; mPopup . setContentView ( null ) ; mDropDownList = null ; mHandler . removeCallbacks ( mResizePopupRunnable ) ; } 
2875	public void testCreateSqlStringValue ( ) throws ProcessException , SQLException , JsonGenerationException , JsonMappingException , IOException , InitializationException { final TestRunner putSqlRunner = TestRunners . newTestRunner ( PutSQL . class ) ; final AtomicInteger id = new AtomicInteger ( _NUM _NUM ) ; putSqlRunner . addControllerService ( _STR ) . getBytes ( ) ; putSqlRunner . enqueue ( data , attributes ) ; putSqlRunner . run ( ) ; failed = putSqlRunner . getFlowFilesForRelationship ( PutSQL . REL _ FAILURE ) ; putSqlRunner . assertTransferCount ( PutSQL . REL _ SUCCESS , _NUM ) ; putSqlRunner . assertTransferCount ( PutSQL . REL _ FAILURE , _NUM ) ; putSqlRunner . clearTransferState ( ) ; break ; default : break ; } } } } 
2876	public final V remove ( K key ) { if ( key = = null ) { throw new NullPointerException ( _STR ) ; } V previous ; synchronized ( this ) { previous = map . remove ( key ) ; if ( previous ! = null ) { size - = safeSizeOf ( key , previous ) ; } } if ( previous ! = null ) { entryRemoved ( false , key , previous , null ) ; } return previous ; } 
2877	public < T > T createAccessor ( Class < T > klass ) { return getAccessor ( klass ) ; } 
2878	private String getActualChecksum ( ) { if ( actualChecksum = = null ) { Load output data List < String > outputs ; try { outputs = shardedFile . readFilesWithRetries ( Sleeper . DEFAULT , BACK _ OFF _ FACTORY . backoff ( ) ) ; } catch ( Exception e ) { throw new RuntimeException ( String . format ( _STR , actualChecksum ) ; } return actualChecksum ; } 
2879	public boolean contains ( TriplePattern pattern ) { ClosableIterator < Triple > it = find ( pattern ) ; boolean result = it . hasNext ( ) ; it . close ( ) ; return result ; } 
2880	public void addWarning ( I _ CmsXmlContentValue value , String message ) { m _ hasWarnings = true ; Locale locale = value . getLocale ( ) ; Map < String , String > localeWarnings = getLocalIssueMap ( m _ warnings , locale ) ; localeWarnings . put ( value . getPath ( ) , message ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( Messages . get ( ) . getBundle ( ) . key ( Messages . LOG _ XMLCONTENT _ VALIDATION _ WARN _ _NUM , value . getPath ( ) , message ) ) ; } } 
2881	public boolean addGpsDateTimeStampTag ( long timestamp ) { ExifTag t = buildTag ( TAG _ GPS _ DATE _ STAMP , mGPSDateStampFormat . format ( timestamp ) ) ; if ( t = = null ) { return false ; } setTag ( t ) ; mGPSTimeStampCalendar . setTimeInMillis ( timestamp ) ; t = buildTag ( TAG _ GPS _ TIME _ STAMP , new Rational [ ] { new Rational ( mGPSTimeStampCalendar . get ( Calendar . HOUR _ OF _ DAY ) , _NUM ) , new Rational ( mGPSTimeStampCalendar . get ( Calendar . MINUTE ) , _NUM ) , new Rational ( mGPSTimeStampCalendar . get ( Calendar . SECOND ) , _NUM ) } ) ; if ( t = = null ) { return false ; } setTag ( t ) ; return true ; } 
2882	public void undoChanges ( CmsObject cms , CmsSecurityManager securityManager , CmsResource resource , CmsResource . CmsResourceUndoMode mode ) throws CmsException { boolean recursive = mode . isRecursive ( ) ; if ( mode = = CmsResource . UNDO _ MOVE _ CONTENT ) { undo move only ? String originalPath = securityManager . resourceOriginalPath ( cms . getRequestContext ( ) , resource ) ; if ( originalPath . equals ( resource . getRootPath ( ) ) ) { resource not moved recursive = false ; } } List < CmsResource > resources = null ; if ( recursive ) { recursive ? collect all resources in the folder ( including deleted ones ) resources = securityManager . readChildResources ( cms . getRequestContext ( ) , resource , CmsResourceFilter . ALL , true , true ) ; } handle the folder itself , undo move op super . undoChanges ( cms , securityManager , resource , mode ) ; the folder may have been moved back to its original position CmsResource undoneResource _NUM = securityManager . readResource ( cms . getRequestContext ( ) , resource . getStructureId ( ) , CmsResourceFilter . ALL ) ; boolean isMoved = ! undoneResource _NUM . getRootPath ( ) . equals ( resource . getRootPath ( ) ) ; if ( recursive & & ( resources ! = null ) ) { now walk through all sub - resources in the folder , and undo first for ( int i = _NUM ; i < resources . size ( ) ; i + + ) { CmsResource childResource = resources . get ( i ) ; I _ CmsResourceType type = getResourceType ( childResource ) ; if ( isMoved ) { securityManager . lockResource ( cms . getRequestContext ( ) , childResource , CmsLockType . EXCLUSIVE ) ; } if ( childResource . isFolder ( ) ) { recurse into this method for subfolders type . undoChanges ( cms , securityManager , childResource , mode ) ; } else if ( ! childResource . getState ( ) . isNew ( ) ) { undo changes for changed files securityManager . undoChanges ( cms . getRequestContext ( ) , childResource , mode ) ; } else { undo move for new files ? move with the folder if ( mode . isUndoMove ( ) ) { String newPath = cms . getRequestContext ( ) . removeSiteRoot ( securityManager . readResource ( cms . getRequestContext ( ) , resource . getStructureId ( ) , CmsResourceFilter . ALL ) . getRootPath ( ) + childResource . getName ( ) ) ; type . moveResource ( cms , securityManager , childResource , newPath ) ; } } } now iterate again all sub - resources in the folder , and actualize the relations for ( int i = _NUM ; i < resources . size ( ) ; i + + ) { CmsResource childResource = resources . get ( i ) ; updateRelationForUndo ( cms , securityManager , childResource ) ; } } } 
2883	public Path suffix ( String suffix ) { return new Path ( getParent ( ) , getName ( ) + suffix ) ; } 
2884	public void testDoesNotCheckDirectories ( ) throws Exception { Stoppable stop = new StoppableImplementation ( ) ; Configuration conf = UTIL . getConfiguration ( ) ; Path testDir = UTIL . getDataTestDir ( ) ; FileSystem fs = UTIL . getTestFileSystem ( ) ; String confKey = _STR , fs . exists ( file ) ) ; FileStatus fStat = fs . getFileStatus ( parent ) ; chore . chore ( ) ; make sure we never checked the directory Mockito . verify ( spy , Mockito . never ( ) ) . isFileDeletable ( fStat ) ; Mockito . reset ( spy ) ; } 
2885	public void setView ( Node view , boolean generateBoundingBox ) { EntityView entityView = view instanceof EntityView ? ( EntityView ) view : new EntityView ( view ) ; this . view . getNodes ( ) . setAll ( entityView . getNodes ( ) ) ; if ( showBBox ( ) ) { this . view . addNode ( debugBBox ) ; } if ( generateBoundingBox ) { generateBBox ( ) ; } } 
2886	public static SegmentReader get ( boolean readOnly , Directory dir , SegmentInfo si , int readBufferSize , boolean doOpenStores , int termInfosIndexDivisor ) throws CorruptIndexException , IOException { SegmentReader instance = readOnly ? new ReadOnlySegmentReader ( ) : new SegmentReader ( ) ; instance . readOnly = readOnly ; instance . si = si ; instance . readBufferSize = readBufferSize ; boolean success = false ; try { instance . core = new SegmentCoreReaders ( instance , dir , si , readBufferSize , termInfosIndexDivisor ) ; if ( doOpenStores ) { instance . core . openDocStores ( si ) ; } instance . loadDeletedDocs ( ) ; instance . openNorms ( instance . core . cfsDir , readBufferSize ) ; success = true ; } finally { wait for a GC to do so . if ( ! success ) { instance . doClose ( ) ; } } return instance ; } 
2887	public boolean isEmpty ( ) { return size ( ) = = _NUM ; } 
2888	public static void setRotationLock ( Context context , final boolean enabled ) { Settings . System . putIntForUser ( context . getContentResolver ( ) , Settings . System . HIDE _ ROTATION _ LOCK _ TOGGLE _ FOR _ ACCESSIBILITY , _NUM , UserHandle . USER _ CURRENT ) ; final int rotation = areAllRotationsAllowed ( context ) ? CURRENT _ ROTATION : NATURAL _ ROTATION ; setRotationLock ( enabled , rotation ) ; } 
2889	public void loadDataStart ( ) { monitor . startDataPhase ( ) ; loadPrepare ( ) ; } 
2890	default Double getDouble ( CharSequence fieldName ) { Value value = get ( fieldName ) ; return value ! = null & & value . isDouble ( ) ? value . asDouble ( ) : null ; } 
2891	public boolean isPermutation ( ) { if ( projects . size ( ) ! = inputRowType . getFieldList ( ) . size ( ) ) { return false ; } for ( int i = _NUM ; i < projects . size ( ) ; + + i ) { if ( getSourceField ( i ) < _NUM ) { return false ; } } return true ; } 
2892	public static RDD < String > frameObjectToRDDStringIJV ( FrameObject frameObject ) { NOTE : The following works when called from Java but does not currently work when called from Spark Shell ( when you call collect ( ) on the RDD < String > ) . JavaRDD < String > javaRDD = jsc . parallelize ( list ) ; RDD < String > rdd = JavaRDD . toRDD ( javaRDD ) ; Therefore , we call parallelize ( ) on the SparkContext rather than the JavaSparkContext to produce the RDD < String > for Scala . List < String > list = frameObjectToListStringIJV ( frameObject ) ; ClassTag < String > tag = scala . reflect . ClassTag $ . MODULE $ . apply ( String . class ) ; return sc ( ) . parallelize ( JavaConversions . asScalaBuffer ( list ) , sc ( ) . defaultParallelism ( ) , tag ) ; } 
2893	public void getBytesWrittenWithDifferentUnderStorageType ( ) throws IOException { for ( WriteType type : WriteType . values ( ) ) { OutStreamOptions options = OutStreamOptions . defaults ( ) . setBlockSizeBytes ( BLOCK _ LENGTH ) . setWriteType ( type ) . setUfsPath ( FILE _ NAME . getPath ( ) ) ; mTestStream = createTestStream ( FILE _ NAME , options ) ; mTestStream . write ( BufferUtils . getIncreasingByteArray ( ( int ) BLOCK _ LENGTH ) ) ; mTestStream . flush ( ) ; Assert . assertEquals ( BLOCK _ LENGTH , mTestStream . getBytesWritten ( ) ) ; } } 
2894	public Object parseNextToken ( ) throws IOException { Object retval ; skipSpaces ( ) ; int nextByte = seqSource . peek ( ) ; if ( ( ( byte ) nextByte ) = = - _NUM ) { return null ; } char c = ( char ) nextByte ; switch ( c ) { case ' < ' : { pull off first left bracket int leftBracket = seqSource . read ( ) ; check for second left bracket c = ( char ) seqSource . peek ( ) ; put back first bracket seqSource . unread ( leftBracket ) ; if ( c = = ' < ' ) { retval = parseCOSDictionary ( ) ; } else { retval = parseCOSString ( ) ; } break ; } case ' [ ' : { array retval = parseCOSArray ( ) ; break ; } case ' ( ' : string retval = parseCOSString ( ) ; break ; case ' / ' : name retval = parseCOSName ( ) ; break ; case ' n ' : { null String nullString = readString ( ) ; if ( nullString . equals ( _STR ) ; save the image data to the operator , so that it can be accessed later ( ( Operator ) retval ) . setImageData ( imageData . toByteArray ( ) ) ; break ; } case ' ] ' : { some ' ] ' around without its previous ' [ ' this means a PDF is somewhat corrupt but we will continue to parse . seqSource . read ( ) ; must be a better solution than null . . . retval = COSNull . NULL ; break ; } default : { we must be an operator String operator = readOperator ( ) ; if ( operator . trim ( ) . length ( ) = = _NUM ) { we have a corrupt stream , stop reading here retval = null ; } else { retval = Operator . getOperator ( operator ) ; } } } return retval ; } 
2895	public Response getWorkerInfoList ( ) { return RestUtils . call ( new RestUtils . RestCallable < List < WorkerInfo > > ( ) { @ Override public List < WorkerInfo > call ( ) throws Exception { return mBlockMaster . getWorkerInfoList ( ) ; } } ) ; } 
2896	public void handleRollover ( File rolloverFile ) { addFileInReadyList ( rolloverFile ) ; } 
2897	public void testNodeAppsStateInvalidDefault ( ) throws JSONException , Exception { WebResource r = resource ( ) ; Application app = new MockApp ( _NUM ) ; nmContext . getApplications ( ) . put ( app . getAppId ( ) , app ) ; addAppContainers ( app ) ; Application app _NUM = new MockApp ( _STR ) ; verifyStateInvalidException ( message , type , classname ) ; } } 
2898	public Session readSession ( Serializable sessionId ) throws UnknownSessionException { Session s = getCachedSession ( sessionId ) ; if ( s = = null ) { s = super . readSession ( sessionId ) ; } return s ; } 
2899	public synchronized void startChapterLoader ( @ NonNull final Playable media ) { if ( isChapterLoaderActive ( ) ) { cancelChapterLoader ( ) ; } Runnable chapterLoader = ( ) - > { Log . d ( TAG , _STR ) ; } ; chapterLoaderFuture = schedExecutor . submit ( chapterLoader ) ; } 
2900	public static < T > Collector < T , ? , Optional < T > > onlyOne ( ) { return new CancellableCollectorImpl < T , Box < Optional < T > > , Optional < T > > ( Box : : new , ( box , t ) - > box . a = box . a = = null ? Optional . of ( t ) : Optional . empty ( ) , ( box _NUM , box _NUM ) - > box _NUM . a = = null ? box _NUM : box _NUM . a = = null ? box _NUM : new Box < > ( Optional . empty ( ) ) , box - > box . a = = null ? Optional . empty ( ) : box . a , box - > box . a ! = null & & ! box . a . isPresent ( ) , UNORDERED _ CHARACTERISTICS ) ; } 
2901	public static SqlLiteral unchain ( SqlNode node ) { if ( node instanceof SqlLiteral ) { return ( SqlLiteral ) node ; } else if ( SqlUtil . isLiteralChain ( node ) ) { return SqlLiteralChainOperator . concatenateOperands ( ( SqlCall ) node ) ; } else if ( node instanceof SqlIntervalQualifier ) { final SqlIntervalQualifier q = ( SqlIntervalQualifier ) node ; return new SqlLiteral ( new SqlIntervalLiteral . IntervalValue ( q , _NUM , q . toString ( ) ) , q . typeName ( ) , q . pos ) ; } else { throw new AssertionError ( _STR + node ) ; } } 
2902	public static Node createIRIorBNode ( String iri ) { Is it a bNode label ? i . e . < _ : xyz > if ( isBNodeIRI ( iri ) ) { String s = iri . substring ( bNodeLabelStart . length ( ) ) ; Node n = NodeFactory . createBlankNode ( s ) ; return n ; } return NodeFactory . createURI ( iri ) ; } 
2903	public static File getConfigurationFile ( String fileName ) { return new File ( getInstance ( ) . getStateLocation ( ) . toFile ( ) , fileName ) ; } 
2904	public int getState ( ) { synchronized ( this ) { updateDisplayInfoLocked ( ) ; return mIsValid ? mDisplayInfo . state : STATE _ UNKNOWN ; } } 
2905	public void writeString ( byte [ ] string ) { try { uncompData . write ( string ) ; } catch ( IOException e ) { throw new ExceptionConverter ( e ) ; } } 
2906	public void validateCertCredentialWithoutClientCertChain ( ) throws Exception { Credential cred = createCredentialWithCertificateCredential ( ) ; cred . setClientCertificateChain ( null ) ; assertFalse ( cred . validate ( ) ) ; } 
2907	public InstanceNetworkInterface withPrivateIpAddresses ( InstancePrivateIpAddress . . . privateIpAddresses ) { if ( getPrivateIpAddresses ( ) = = null ) setPrivateIpAddresses ( new java . util . ArrayList < InstancePrivateIpAddress > ( privateIpAddresses . length ) ) ; for ( InstancePrivateIpAddress value : privateIpAddresses ) { getPrivateIpAddresses ( ) . add ( value ) ; } return this ; } 
2908	public IntervalSqlType combine ( RelDataTypeFactoryImpl typeFactory , IntervalSqlType that ) { assert this . typeName . isYearMonth ( ) = = that . typeName . isYearMonth ( ) ; boolean nullable = isNullable | | that . isNullable ; TimeUnit thisStart = Preconditions . checkNotNull ( typeName . getStartUnit ( ) ) ; TimeUnit thisEnd = typeName . getEndUnit ( ) ; final TimeUnit thatStart = Preconditions . checkNotNull ( that . typeName . getStartUnit ( ) ) ; final TimeUnit thatEnd = that . typeName . getEndUnit ( ) ; int secondPrec = this . intervalQualifier . getStartPrecisionPreservingDefault ( ) ; final int fracPrec = SqlIntervalQualifier . combineFractionalSecondPrecisionPreservingDefault ( typeSystem , this . intervalQualifier , that . intervalQualifier ) ; if ( thisStart . ordinal ( ) > thatStart . ordinal ( ) ) { thisEnd = thisStart ; thisStart = thatStart ; secondPrec = that . intervalQualifier . getStartPrecisionPreservingDefault ( ) ; } else if ( thisStart . ordinal ( ) = = thatStart . ordinal ( ) ) { secondPrec = SqlIntervalQualifier . combineStartPrecisionPreservingDefault ( typeFactory . getTypeSystem ( ) , this . intervalQualifier , that . intervalQualifier ) ; } else if ( null = = thisEnd | | thisEnd . ordinal ( ) < thatStart . ordinal ( ) ) { thisEnd = thatStart ; } if ( null ! = thatEnd ) { if ( null = = thisEnd | | thisEnd . ordinal ( ) < thatEnd . ordinal ( ) ) { thisEnd = thatEnd ; } } RelDataType intervalType = typeFactory . createSqlIntervalType ( new SqlIntervalQualifier ( thisStart , secondPrec , thisEnd , fracPrec , SqlParserPos . ZERO ) ) ; intervalType = typeFactory . createTypeWithNullability ( intervalType , nullable ) ; return ( IntervalSqlType ) intervalType ; } 
2909	private boolean needToShowSelectedDaysRange ( ) { if ( getCalendarOrientation ( ) = = OrientationHelper . HORIZONTAL & & getSelectionType ( ) = = SelectionType . RANGE ) { if ( selectionManager instanceof RangeSelectionManager ) { if ( ( ( RangeSelectionManager ) selectionManager ) . getDays ( ) ! = null ) { return true ; } } } return false ; } 
2910	public CmsLinkBean getLinkBean ( ) { String link = m _ textbox . getText ( ) ; if ( CmsStringUtil . isEmptyOrWhitespaceOnly ( link ) ) { return null ; } return new CmsLinkBean ( m _ textbox . getText ( ) , m _ internal ) ; } 
2911	public void testProcessMsg _NUM ( ) { byte [ ] pdu = createPDU ( _NUM ) ; int headerLen = pdu . length - ( mGsmHeader . length + mUserDataHeader . length + mMessageBody . length ) ; int pduType = _NUM ; int tranId = _NUM ; String originalPackageName = mPackageName ; String originalClassName = mClassName ; try { mClassName = _STR ; set up data IWapPushManager iwapman = getInterface ( ) ; iwapman . addPackage ( Integer . toString ( mAppIdValue ) , Integer . toString ( mContentTypeValue ) , mPackageName , mClassName , WapPushManagerParams . APP _ TYPE _ ACTIVITY , false , false ) ; assertFalse ( ( iwapman . processMessage ( Integer . toString ( mAppIdValue ) , Integer . toString ( mContentTypeValue ) , createIntent ( pduType , tranId ) ) & WapPushManagerParams . MESSAGE _ HANDLED ) = = WapPushManagerParams . MESSAGE _ HANDLED ) ; clean up data iwapman . deletePackage ( Integer . toString ( mAppIdValue ) , Integer . toString ( mContentTypeValue ) , mPackageName , mClassName ) ; set up data iwapman . addPackage ( Integer . toString ( mAppIdValue ) , Integer . toString ( mContentTypeValue ) , mPackageName , mClassName , WapPushManagerParams . APP _ TYPE _ SERVICE , false , false ) ; assertFalse ( ( iwapman . processMessage ( Integer . toString ( mAppIdValue ) , Integer . toString ( mContentTypeValue ) , createIntent ( pduType , tranId ) ) & WapPushManagerParams . MESSAGE _ HANDLED ) = = WapPushManagerParams . MESSAGE _ HANDLED ) ; clean up data iwapman . deletePackage ( Integer . toString ( mAppIdValue ) , Integer . toString ( mContentTypeValue ) , mPackageName , mClassName ) ; } catch ( RemoteException e ) { assertTrue ( false ) ; } mPackageName = originalPackageName ; mClassName = originalClassName ; } 
2912	public void print ( Appendable out ) throws IOException { we have to make a copy to preserve the _STR contract on Timestamp and we don ' t want someone reading the calendar member while we ' ve shifted it around . Timestamp adjusted = this ; Adjust UTC time back to local time if ( this . _ offset ! = null & & this . _ offset . intValue ( ) ! = _NUM ) { adjusted = make _ localtime ( ) ; } print ( out , adjusted ) ; } 
2913	protected Paint lookupSectionPaint ( Comparable key , boolean autoPopulate ) { is there an override ? Paint result = getSectionPaint ( ) ; if ( result ! = null ) { return result ; } if not , check if there is a paint defined for the specified key result = this . sectionPaintMap . getPaint ( key ) ; if ( result ! = null ) { return result ; } nothing defined - do we autoPopulate ? if ( autoPopulate ) { DrawingSupplier ds = getDrawingSupplier ( ) ; if ( ds ! = null ) { result = ds . getNextPaint ( ) ; this . sectionPaintMap . put ( key , result ) ; } else { result = this . baseSectionPaint ; } } else { result = this . baseSectionPaint ; } return result ; } 
2914	public void testCreatedServerIsNotAlive ( ) throws Throwable { HttpServer server = createTestServer ( ) ; assertNotLive ( server ) ; } 
2915	public static boolean extendLeft ( Spannable text , Layout layout ) { int end = getSelectionEnd ( text ) ; int to = layout . getOffsetToLeftOf ( end ) ; if ( to ! = end ) { extendSelection ( text , to ) ; return true ; } return true ; } 
2916	public void parsingProcStatAndCpuFile ( ) throws IOException { Write fake / proc / cpuinfo file . long numProcessors = _NUM ; long cpuFrequencyKHz = _NUM _NUM _NUM _NUM _NUM _NUM _NUM ; String fileContent = _STR ; } File tempFile = new File ( FAKE _ CPUFILE ) ; tempFile . deleteOnExit ( ) ; FileWriter fWriter = new FileWriter ( FAKE _ CPUFILE ) ; fWriter . write ( fileContent ) ; fWriter . close ( ) ; assertEquals ( plugin . getNumProcessors ( ) , numProcessors ) ; assertEquals ( plugin . getCpuFrequency ( ) , cpuFrequencyKHz ) ; Write fake / proc / stat file . long uTime = _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM ; long nTime = _NUM _NUM _NUM _NUM _NUM _NUM ; long sTime = _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM ; tempFile = new File ( FAKE _ STATFILE ) ; tempFile . deleteOnExit ( ) ; updateStatFile ( uTime , nTime , sTime ) ; assertEquals ( plugin . getCumulativeCpuTime ( ) , FAKE _ JIFFY _ LENGTH * ( uTime + nTime + sTime ) ) ; assertEquals ( plugin . getCpuUsage ( ) , ( float ) ( CpuTimeTracker . UNAVAILABLE ) , _NUM . _NUM ) ; Advance the time and sample again to test the CPU usage calculation uTime + = _NUM _NUM _NUM L ; plugin . advanceTime ( _NUM _NUM _NUM L ) ; updateStatFile ( uTime , nTime , sTime ) ; assertEquals ( plugin . getCumulativeCpuTime ( ) , FAKE _ JIFFY _ LENGTH * ( uTime + nTime + sTime ) ) ; assertEquals ( plugin . getCpuUsage ( ) , _NUM . _NUM _NUM F , _NUM . _NUM ) ; Advance the time and sample again . This time , we call getCpuUsage ( ) only . uTime + = _NUM _NUM _NUM L ; plugin . advanceTime ( _NUM _NUM _NUM L ) ; updateStatFile ( uTime , nTime , sTime ) ; assertEquals ( plugin . getCpuUsage ( ) , _NUM _NUM F , _NUM . _NUM ) ; Advance very short period of time ( one jiffy length ) . In this case , CPU usage should not be updated . uTime + = _NUM L ; plugin . advanceTime ( _NUM L ) ; updateStatFile ( uTime , nTime , sTime ) ; assertEquals ( plugin . getCumulativeCpuTime ( ) , FAKE _ JIFFY _ LENGTH * ( uTime + nTime + sTime ) ) ; CPU usage is not updated . assertEquals ( plugin . getCpuUsage ( ) , _NUM _NUM F , _NUM . _NUM ) ; } 
2917	public double [ ] scanLeft ( DoubleBinaryOperator accumulator ) { Spliterator . OfDouble spliterator = spliterator ( ) ; double size = spliterator . getExactSizeIfKnown ( ) ; DoubleBuffer buf = new DoubleBuffer ( size > = _NUM & & size < = Integer . MAX _ VALUE ? ( int ) size : INITIAL _ SIZE ) ; delegate ( spliterator ) . forEachOrdered ( i - > buf . add ( buf . size = = _NUM ? i : accumulator . applyAsDouble ( buf . data [ buf . size - _NUM ] , i ) ) ) ; return buf . toArray ( ) ; } 
2918	public Number getX ( int series , int item ) { XIntervalSeries s = ( XIntervalSeries ) this . data . get ( series ) ; XIntervalDataItem di = ( XIntervalDataItem ) s . getDataItem ( item ) ; return di . getX ( ) ; } 
2919	public static < E > boolean all ( List < ? extends E > list , Predicate _NUM < E > predicate ) { for ( E e : list ) { if ( ! predicate . apply ( e ) ) { return false ; } } return true ; } 
2920	private void handleSaslConnectionFailure ( final int currRetries , final int maxRetries , final Exception ex , final UserGroupInformation user ) throws IOException , InterruptedException { closeSocket ( ) ; user . doAs ( new PrivilegedExceptionAction < Object > ( ) { @ Override public Object run ( ) throws IOException , InterruptedException { if ( shouldAuthenticateOverKrb ( ) ) { if ( currRetries < maxRetries ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( _STR ; LOG . error ( HBaseMarkers . FATAL , msg , ex ) ; throw new RuntimeException ( msg , ex ) ; } throw new IOException ( ex ) ; } } ) ; } 
2921	public void onCharacteristicWriteRequest ( String address , int transId , int offset , int length , boolean isPrep , boolean needRsp , int handle , byte [ ] value ) { if ( VDBG ) Log . d ( TAG , _STR , ex ) ; } } 
2922	public boolean isRegionCached ( TableName tableName , final byte [ ] row ) { RegionLocations location = getCachedLocation ( tableName , row ) ; return location ! = null ; } 
2923	public void getPixels ( @ ColorInt int [ ] pixels , int offset , int stride , int x , int y , int width , int height ) { checkRecycled ( _STR ) ; if ( width = = _NUM | | height = = _NUM ) { nothing to do return ; } checkPixelsAccess ( x , y , width , height , offset , stride , pixels ) ; nativeGetPixels ( mNativePtr , pixels , offset , stride , x , y , width , height ) ; } 
2924	public CmsHistoryProject readProject ( CmsDbContext dbc , int publishTag ) throws CmsDataAccessException { CmsHistoryProject project = null ; try { Query q = m _ sqlManager . createQuery ( dbc , C _ PROJECTS _ HISTORY _ READ ) ; q . setParameter ( _NUM , Integer . valueOf ( publishTag ) ) ; try { CmsDAOHistoryProjects hp = ( CmsDAOHistoryProjects ) q . getSingleResult ( ) ; List < String > projectresources = readProjectResources ( dbc , publishTag ) ; project = internalCreateProject ( hp , projectresources ) ; } catch ( NoResultException e ) { throw new CmsDbEntryNotFoundException ( Messages . get ( ) . container ( Messages . ERR _ NO _ HISTORY _ PROJECT _ WITH _ TAG _ ID _ _NUM , new Integer ( publishTag ) ) ) ; } } catch ( PersistenceException e ) { throw new CmsDataAccessException ( Messages . get ( ) . container ( Messages . ERR _ JPA _ PERSITENCE , e ) , e ) ; } return project ; } 
2925	public String buildUrl ( String action , String namespace , String method , Map < String , Object > params , String scheme , String type , String portletMode , String windowState , boolean includeContext , boolean encodeResult ) { StringBuilder resultingAction = new StringBuilder ( ) ; PortletRequest request = PortletActionContext . getRequest ( ) ; LOG . debug ( _STR ) ; } return result ; } 
2926	long getSnapshotSizeFromResult ( Result r ) throws InvalidProtocolBufferException { we should be non - null . If we can ' t advance to the first cell , same as _STR . if ( ! r . isEmpty ( ) & & r . advance ( ) ) { return QuotaTableUtil . parseSnapshotSize ( r . current ( ) ) ; } return _NUM L ; } 
2927	void performCleanUp ( @ Nullable Runnable task ) { evictionLock . lock ( ) ; try { maintenance ( task ) ; } finally { evictionLock . unlock ( ) ; } } 
2928	public void testCorrelationExistsAndFilterThetaRex ( ) { final String sql = _STR ; sql ( sql ) . decorrelate ( true ) . ok ( ) ; } 
2929	public static Set < ObjectName > ensureOnly ( String . . . expectedNames ) throws IOException , InterruptedException { LOG . info ( _STR + bean . toString ( ) ) ; } Assert . assertEquals ( _NUM , beans . size ( ) ) ; return beans ; } 
2930	protected void runAnimators ( ) { if ( DBG ) { Log . d ( LOG _ TAG , _STR + anim ) ; } if ( runningAnimators . containsKey ( anim ) ) { start ( ) ; runAnimator ( anim , runningAnimators ) ; } } mAnimators . clear ( ) ; end ( ) ; } 
2931	public void stopSystemLockTaskMode ( ) throws RemoteException { if ( mStackSupervisor . getLockTaskModeState ( ) = = ActivityManager . LOCK _ TASK _ MODE _ PINNED ) { stopLockTaskMode ( ) ; } else { mStackSupervisor . showLockTaskToast ( ) ; } } 
2932	protected char getCharPerKeyCode ( int pressCount , int keyCode , boolean longClick ) { initInputModes ( ) ; String input = inputMode ; the upper case mode or the lower case mode . . . if ( longClick ) { input = getLongClickInputMode ( ) ; } else { if ( firstUppercaseInputMode . contains ( input ) ) { input = pickLowerOrUpper ( input ) ; } } Hashtable mode = ( Hashtable ) inputModes . get ( input ) ; if ( mode ! = null ) { String s = ( String ) mode . get ( new Integer ( keyCode ) ) ; if ( s ! = null ) { pressCount = pressCount % s . length ( ) ; return s . charAt ( pressCount ) ; } } return _NUM ; } 
2933	protected BlobStore getBlobStore ( String predicate ) throws IllegalArgumentException { if ( blobStores ! = null & & ! blobStores . isEmpty ( ) ) { First try using name and then fallback to the provider or api . if ( isNameSupportedByContext ( ) ) { for ( BlobStore blobStore : blobStores ) { if ( blobStore . getContext ( ) . unwrap ( ) . getName ( ) . equals ( predicate ) ) { return blobStore ; } } } for ( BlobStore blobStore : blobStores ) { if ( blobStore . getContext ( ) . unwrap ( ) . getId ( ) . equals ( predicate ) ) { return blobStore ; } } throw new IllegalArgumentException ( String . format ( _STR ) ; } } 
2934	public String getSuppressedStackTrace ( final String suffix ) { final ThrowableProxy [ ] suppressed = this . getSuppressedProxies ( ) ; if ( suppressed = = null | | suppressed . length = = _NUM ) { return Strings . EMPTY ; } final StringBuilder sb = new StringBuilder ( _STR ) . append ( EOL ) ; for ( final ThrowableProxy proxy : suppressed ) { sb . append ( proxy . getExtendedStackTraceAsString ( suffix ) ) ; } return sb . toString ( ) ; } 
2935	public String toUnicode ( int code ) throws IOException { if the font dictionary containsName a ToUnicode CMap , use that CMap if ( toUnicodeCMap ! = null ) { if ( toUnicodeCMap . getName ( ) ! = null & & toUnicodeCMap . getName ( ) . startsWith ( _STR ) & & dict . getDictionaryObject ( COSName . TO _ UNICODE ) instanceof COSName ) { PDFBOX - _NUM _NUM _NUM _NUM : do this only if the / ToUnicode entry is a name return new String ( new char [ ] { ( char ) code } ) ; } else { proceed as normal return toUnicodeCMap . toUnicode ( code ) ; } } this behaviour can be overridden is subclasses , but this method * must * return null here return null ; } 
2936	public List < Style > listImageStyle ( String bucketName , GenericRequest genericRequest ) throws OSSException , ClientException { assertParameterNotNull ( bucketName , _STR ) ; ensureBucketNameValid ( bucketName ) ; Map < String , String > params = new HashMap < String , String > ( ) ; ; params . put ( SUBRESOURCE _ STYLE , null ) ; RequestMessage request = new OSSRequestMessageBuilder ( getInnerClient ( ) ) . setEndpoint ( getEndpoint ( ) ) . setMethod ( HttpMethod . GET ) . setBucket ( bucketName ) . setParameters ( params ) . setOriginalRequest ( genericRequest ) . build ( ) ; return doOperation ( request , listImageStyleResponseParser , bucketName , null , true ) ; } 
2937	public void actionPerformed ( ActionEvent e ) { Don ' t do anything if they are selecting text . Caret c = textArea . getCaret ( ) ; if ( c . getDot ( ) ! = c . getMark ( ) ) { return ; } RSyntaxDocument doc = ( RSyntaxDocument ) textArea . getDocument ( ) ; OccurrenceMarker occurrenceMarker = doc . getOccurrenceMarker ( ) ; boolean occurrencesChanged = false ; if ( occurrenceMarker ! = null ) { doc . readLock ( ) ; try { Token t = occurrenceMarker . getTokenToMark ( textArea ) ; if ( t ! = null & & occurrenceMarker . isValidType ( textArea , t ) & & ! RSyntaxUtilities . isNonWordChar ( t ) ) { clear ( ) ; RSyntaxTextAreaHighlighter h = ( RSyntaxTextAreaHighlighter ) textArea . getHighlighter ( ) ; occurrenceMarker . markOccurrences ( doc , t , h , p ) ; textArea . repaint ( ) ; TODO : Do a textArea . repaint ( ) instead of repainting each marker as it ' s added if count is huge occurrencesChanged = true ; } } finally { doc . readUnlock ( ) ; time = System . currentTimeMillis ( ) - time ; System . out . println ( _STR ) ; } } if ( occurrencesChanged ) { textArea . fireMarkedOccurrencesChanged ( ) ; } } 
2938	public static Boolean getBoolean ( final LdapEntry ctx , final String attribute , final Boolean nullValue ) { final String v = getString ( ctx , attribute , nullValue . toString ( ) ) ; if ( v ! = null ) { return v . equalsIgnoreCase ( Boolean . TRUE . toString ( ) ) ; } return nullValue ; } 
2939	public void setStemmer ( String name ) { Class < ? > snowballClass ; Class [ ] argClasses ; initStemmers ( ) ; if ( m _ Stemmers . contains ( name ) ) { try { snowballClass = Class . forName ( getStemmerClassname ( name ) ) ; m _ Stemmer = snowballClass . newInstance ( ) ; methods argClasses = new Class [ _NUM ] ; m _ StemMethod = snowballClass . getMethod ( _STR ) ; m _ Stemmer = null ; } } 
2940	public void clearIndex ( ) throws IOException { synchronized ( modifyCurrentIndexLock ) { ensureOpen ( ) ; final Directory dir = this . spellIndex ; final IndexWriter writer = new IndexWriter ( dir , new IndexWriterConfig ( Version . LUCENE _ CURRENT , new WhitespaceAnalyzer ( Version . LUCENE _ CURRENT ) ) . setOpenMode ( OpenMode . CREATE ) ) ; writer . close ( ) ; swapSearcher ( dir ) ; } } 
2941	public void decrypt ( COSBase obj , long objNum , long genNum ) throws IOException { if ( ! objects . contains ( obj ) ) { objects . add ( obj ) ; if ( obj instanceof COSString ) { decryptString ( ( COSString ) obj , objNum , genNum ) ; } else if ( obj instanceof COSStream ) { decryptStream ( ( COSStream ) obj , objNum , genNum ) ; } else if ( obj instanceof COSDictionary ) { decryptDictionary ( ( COSDictionary ) obj , objNum , genNum ) ; } else if ( obj instanceof COSArray ) { decryptArray ( ( COSArray ) obj , objNum , genNum ) ; } } } 
2942	public void applyAll ( long index ) { enqueueBatch ( index ) ; } 
2943	private boolean wsConsumeWs ( final String string _NUM , final String string _NUM , final QueryError expr ) throws QueryException { final int p _NUM = pos ; if ( ! wsConsumeWs ( string _NUM ) ) return false ; final int p _NUM = pos ; alter = expr ; alterPos = p _NUM ; final boolean ok = wsConsume ( string _NUM ) ; pos = ok ? p _NUM : p _NUM ; return ok ; } 
2944	public boolean onTouchDrawMode ( MotionEvent event ) { get location of touch float eventX = event . getX ( ) ; float eventY = event . getY ( ) ; if ( eventX < _NUM ) { eventX = _NUM ; } if ( eventY < _NUM ) { eventY = _NUM ; } if ( eventX > getWidth ( ) ) { eventX = getWidth ( ) ; } if ( eventY > getHeight ( ) ) { eventY = getHeight ( ) ; } based on the users action , start drawing switch ( event . getAction ( ) ) { case MotionEvent . ACTION _ DOWN : create new path and paint currentPath = new CPath ( ) ; currentPaint = new Paint ( ) ; currentPaint . setAntiAlias ( true ) ; currentPaint . setColor ( mColor ) ; currentPaint . setStyle ( mStyle ) ; currentPaint . setStrokeJoin ( Paint . Join . ROUND ) ; currentPaint . setStrokeWidth ( mSize ) ; currentPath . setPaint ( currentPaint ) ; currentPath . moveTo ( eventX , eventY ) ; capture touched locations lastTouchX = eventX ; lastTouchY = eventY ; mDrawableList . add ( currentPath ) ; mUndoList . clear ( ) ; getParent ( ) . requestDisallowInterceptTouchEvent ( true ) ; break ; case MotionEvent . ACTION _ CANCEL : getParent ( ) . requestDisallowInterceptTouchEvent ( false ) ; break ; case MotionEvent . ACTION _ MOVE : float dx = Math . abs ( eventX - lastTouchX ) ; float dy = Math . abs ( eventY - lastTouchY ) ; if ( dx > = TOUCH _ TOLERANCE | | dy > = TOUCH _ TOLERANCE ) { currentPath . quadTo ( lastTouchX , lastTouchY , ( eventX + lastTouchX ) / _NUM , ( eventY + lastTouchY ) / _NUM ) ; lastTouchX = eventX ; lastTouchY = eventY ; } int historySize = event . getHistorySize ( ) ; for ( int i = _NUM ; i < historySize ; i + + ) { float historicalX = event . getHistoricalX ( i ) ; float historicalY = event . getHistoricalY ( i ) ; currentPath . lineTo ( historicalX , historicalY ) ; } After replaying history , connect the line to the touch point . currentPath . lineTo ( eventX , eventY ) ; dirtyRect . left = Math . min ( currentPath . getXcoords ( ) , dirtyRect . left ) ; dirtyRect . right = Math . max ( currentPath . getXcoords ( ) + currentPath . getWidth ( ) , dirtyRect . right ) ; dirtyRect . top = Math . min ( currentPath . getYcoords ( ) , dirtyRect . top ) ; dirtyRect . bottom = Math . max ( currentPath . getYcoords ( ) + currentPath . getHeight ( ) , dirtyRect . bottom ) ; After replaying history , connect the line to the touch point . cleanDirtyRegion ( eventX , eventY ) ; break ; case MotionEvent . ACTION _ UP : currentPath . lineTo ( eventX , eventY ) ; getParent ( ) . requestDisallowInterceptTouchEvent ( false ) ; break ; default : return false ; } Include some padding to ensure nothing is clipped invalidate ( ) ; ( int ) ( dirtyRect . left - _NUM _NUM ) , ( int ) ( dirtyRect . top - _NUM _NUM ) , ( int ) ( dirtyRect . right + _NUM _NUM ) , ( int ) ( dirtyRect . bottom + _NUM _NUM ) ) ; register most recent touch locations lastTouchX = eventX ; lastTouchY = eventY ; return true ; } 
2945	public void draw ( Graphics _NUM D g _NUM , Rectangle _NUM D area , Point _NUM D anchor , PlotState parentState , PlotRenderingInfo info ) { if the plot area is too small , just return . . . boolean b _NUM = ( area . getWidth ( ) < = MINIMUM _ WIDTH _ TO _ DRAW ) ; boolean b _NUM = ( area . getHeight ( ) < = MINIMUM _ HEIGHT _ TO _ DRAW ) ; if ( b _NUM | | b _NUM ) { return ; } record the plot area . . . if ( info ! = null ) { info . setPlotArea ( area ) ; } adjust the drawing area for plot insets ( if any ) . . . RectangleInsets insets = getInsets ( ) ; insets . trim ( area ) ; AxisSpace space = new AxisSpace ( ) ; space = this . domainAxis . reserveSpace ( g _NUM , this , area , RectangleEdge . BOTTOM , space ) ; space = this . rangeAxis . reserveSpace ( g _NUM , this , area , RectangleEdge . LEFT , space ) ; Rectangle _NUM D estimatedDataArea = space . shrink ( area , null ) ; AxisSpace space _NUM = new AxisSpace ( ) ; space _NUM = this . colorBar . reserveSpace ( g _NUM , this , area , estimatedDataArea , this . colorBarLocation , space _NUM ) ; Rectangle _NUM D adjustedPlotArea = space _NUM . shrink ( area , null ) ; Rectangle _NUM D dataArea = space . shrink ( adjustedPlotArea , null ) ; Rectangle _NUM D colorBarArea = space _NUM . reserved ( area , this . colorBarLocation ) ; additional dataArea modifications if ( getDataAreaRatio ( ) ! = _NUM . _NUM ) { check whether modification is double ratio = getDataAreaRatio ( ) ; Rectangle _NUM D tmpDataArea = ( Rectangle _NUM D ) dataArea . clone ( ) ; double h = tmpDataArea . getHeight ( ) ; double w = tmpDataArea . getWidth ( ) ; if ( ratio > _NUM ) { ratio represents pixels if ( w * ratio < = h ) { h = ratio * w ; } else { w = h / ratio ; } } else { ratio represents axis units ratio * = - _NUM . _NUM ; double xLength = getDomainAxis ( ) . getRange ( ) . getLength ( ) ; double yLength = getRangeAxis ( ) . getRange ( ) . getLength ( ) ; double unitRatio = yLength / xLength ; ratio = unitRatio * ratio ; if ( w * ratio < = h ) { h = ratio * w ; } else { w = h / ratio ; } } dataArea . setRect ( tmpDataArea . getX ( ) + tmpDataArea . getWidth ( ) / _NUM - w / _NUM , tmpDataArea . getY ( ) , w , h ) ; } if ( info ! = null ) { info . setDataArea ( dataArea ) ; } CrosshairState crosshairState = new CrosshairState ( ) ; crosshairState . setCrosshairDistance ( Double . POSITIVE _ INFINITY ) ; draw the plot background . . . drawBackground ( g _NUM , dataArea ) ; double cursor = dataArea . getMaxY ( ) ; if ( this . domainAxis ! = null ) { this . domainAxis . draw ( g _NUM , cursor , adjustedPlotArea , dataArea , RectangleEdge . BOTTOM , info ) ; } if ( this . rangeAxis ! = null ) { cursor = dataArea . getMinX ( ) ; this . rangeAxis . draw ( g _NUM , cursor , adjustedPlotArea , dataArea , RectangleEdge . LEFT , info ) ; } if ( this . colorBar ! = null ) { cursor = _NUM . _NUM ; cursor = this . colorBar . draw ( g _NUM , cursor , adjustedPlotArea , dataArea , colorBarArea , this . colorBarLocation ) ; } Shape originalClip = g _NUM . getClip ( ) ; Composite originalComposite = g _NUM . getComposite ( ) ; g _NUM . clip ( dataArea ) ; g _NUM . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC _ OVER , getForegroundAlpha ( ) ) ) ; render ( g _NUM , dataArea , info , crosshairState ) ; if ( this . domainMarkers ! = null ) { Iterator iterator = this . domainMarkers . iterator ( ) ; while ( iterator . hasNext ( ) ) { Marker marker = ( Marker ) iterator . next ( ) ; drawDomainMarker ( g _NUM , this , getDomainAxis ( ) , marker , dataArea ) ; } } if ( this . rangeMarkers ! = null ) { Iterator iterator = this . rangeMarkers . iterator ( ) ; while ( iterator . hasNext ( ) ) { Marker marker = ( Marker ) iterator . next ( ) ; drawRangeMarker ( g _NUM , this , getRangeAxis ( ) , marker , dataArea ) ; } } TO DO : these annotations only work with XYPlot , see if it is possible to make ContourPlot a subclass of XYPlot ( DG ) ; draw the annotations . . . if ( this . annotations ! = null ) { Iterator iterator = this . annotations . iterator ( ) ; while ( iterator . hasNext ( ) ) { Annotation annotation = ( Annotation ) iterator . next ( ) ; if ( annotation instanceof XYAnnotation ) { XYAnnotation xya = ( XYAnnotation ) annotation ; get the annotation to draw itself . . . xya . draw ( g _NUM , this , dataArea , getDomainAxis ( ) , getRangeAxis ( ) ) ; } } } g _NUM . setClip ( originalClip ) ; g _NUM . setComposite ( originalComposite ) ; drawOutline ( g _NUM , dataArea ) ; } 
2946	public void setup ( ) throws Exception { this . admin = TEST _ UTIL . getAdmin ( ) ; long tid = System . currentTimeMillis ( ) ; tableName = TableName . valueOf ( name . getMethodName ( ) + tid ) ; emptySnapshot = Bytes . toBytes ( _STR + tid ) ; createTableAndSnapshots ( ) ; } 
2947	public Vector < String > find ( ) { Vector < String > list ; int i ; Class cls ; Object obj ; CapabilitiesHandler handler ; boolean fits ; Capabilities caps ; m _ Matches = new Vector < String > ( ) ; m _ Misses = new Vector < String > ( ) ; list = ClassDiscovery . find ( m _ Superclass , ( String [ ] ) m _ Packages . toArray ( new String [ m _ Packages . size ( ) ] ) ) ; for ( i = _NUM ; i < list . size ( ) ; i + + ) { try { cls = Class . forName ( ( String ) list . get ( i ) ) ; obj = cls . newInstance ( ) ; exclude itself if ( cls = = this . getClass ( ) ) continue ; really a CapabilitiesHandler ? if ( ! ( obj instanceof CapabilitiesHandler ) ) continue ; check capabilities enumeration handler = ( CapabilitiesHandler ) obj ; caps = handler . getCapabilities ( ) ; fits = true ; for ( Capability cap : Capability . values ( ) ) { if ( m _ Capabilities . handles ( cap ) ) { if ( ! ( caps . handles ( cap ) ) ) { fits = false ; break ; } } } if ( ! fits ) { m _ Misses . add ( list . get ( i ) ) ; continue ; } check _STR list for ( Capability cap : Capability . values ( ) ) { if ( m _ NotCapabilities . handles ( cap ) ) { if ( ( caps . handles ( cap ) ) ) { fits = false ; break ; } } } if ( ! fits ) { m _ Misses . add ( list . get ( i ) ) ; continue ; } other stuff if ( caps . getMinimumNumberInstances ( ) > m _ Capabilities . getMinimumNumberInstances ( ) ) { m _ Misses . add ( list . get ( i ) ) ; continue ; } matches all criteria ! m _ Matches . add ( list . get ( i ) ) ; } catch ( Exception e ) { ignore } } return m _ Matches ; } 
2948	private void testRemoveTemporaryFiles ( int numFiles , ResourceId tempDirectory ) throws Exception { String prefix = _STR , outputFile ) , outputFile . exists ( ) , is ( true ) ) ; } } 
2949	static void printAggregation ( String name , String format , Aggregation [ ] aggregationArray ) { if ( aggregationArray . length > _NUM & & aggregationArray [ _NUM ] . getKeyData ( ) . size ( ) > _NUM ) { int aggregationDataSize = aggregationArray [ _NUM ] . getKeyData ( ) . get ( _NUM ) . getElements ( ) . length + aggregationArray . length ; List < Object [ ] > aggregationData = new ArrayList < > ( ) ; Iterate through all keys in the first Aggregation and build up an array of aggregationData for ( AggregationKey aggKey : aggregationArray [ _NUM ] . getKeyData ( ) ) { int aggDataIndex = _NUM ; Object [ ] currAggregationData = new Object [ aggregationDataSize ] ; Add the key to the from of the current aggregation Data for ( Object obj : aggKey . getElements ( ) ) { currAggregationData [ aggDataIndex ] = obj ; aggDataIndex + + ; } for ( Aggregation agg : aggregationArray ) { currAggregationData [ aggDataIndex ] = agg . getValueForKey ( aggKey ) ; aggDataIndex + + ; } aggregationData . add ( currAggregationData ) ; } getCurrent ( ) . send ( new GridDataCommand ( name , aggregationData , format ) ) ; } } 
2950	public CmsFolder readAncestor ( CmsRequestContext context , CmsResource resource , CmsResourceFilter filter ) throws CmsException { get the full folder path of the resource to start from String path = CmsResource . getFolderPath ( resource . getRootPath ( ) ) ; do { check if the current folder matches the given filter if ( existsResource ( context , path , filter ) ) { folder matches , return it return readFolder ( context , path , filter ) ; } else { folder does not match filter criteria , go up one folder path = CmsResource . getParentFolder ( path ) ; } if ( CmsStringUtil . isEmpty ( path ) | | ! path . startsWith ( context . getSiteRoot ( ) ) ) { site root or root folder reached and no matching folder found return null ; } } while ( true ) ; } 
2951	public double getOpenValue ( int series , int item ) { OHLCSeries s = ( OHLCSeries ) this . data . get ( series ) ; OHLCItem di = ( OHLCItem ) s . getDataItem ( item ) ; return di . getOpenValue ( ) ; } 
2952	public synchronized void acceptRecovery ( RequestInfo reqInfo , SegmentStateProto segment , URL fromUrl ) throws IOException { checkFormatted ( ) ; checkRequest ( reqInfo ) ; abortCurSegment ( ) ; long segmentTxId = segment . getStartTxId ( ) ; Basic sanity checks that the segment is well - formed and contains at least one transaction . Preconditions . checkArgument ( segment . getEndTxId ( ) > _NUM & & segment . getEndTxId ( ) > = segmentTxId , _STR + TextFormat . shortDebugString ( newData ) ) ; } 
2953	private void commit ( long transactionID , short type ) throws IOException { Preconditions . checkState ( open , _STR ) ; } boolean error = true ; try { try { LogFile . Writer logFileWriter = logFiles . get ( logFileIndex ) ; If multiple transactions are committing at the same time , this ensures that the number of actual fsyncs is small and a number of them are grouped together into one . logFileWriter . commit ( buffer ) ; logFileWriter . sync ( ) ; error = false ; } catch ( LogFileRetryableIOException e ) { if ( ! open ) { throw e ; } roll ( logFileIndex , buffer ) ; LogFile . Writer logFileWriter = logFiles . get ( logFileIndex ) ; logFileWriter . commit ( buffer ) ; logFileWriter . sync ( ) ; error = false ; } } finally { if ( error & & open ) { roll ( logFileIndex ) ; } } } 
2954	public MessageMonitor < ? super QueryMessage < ? , ? > > registerQueryBus ( String name ) { return registerDefaultHandlerMessageMonitor ( name ) ; } 
2955	public String generate ( ) throws Exception { if ( getDir ( ) . length ( ) = = _NUM ) return generateJavadoc ( ) ; else return updateJavadoc ( ) ; } 
2956	public boolean offerFirst ( E e ) { addFirst ( e ) ; return true ; } 
2957	private static void uaSumEqNe ( MatrixBlock in , MatrixBlock out , double [ ] bv , BinaryOperator bOp ) { int agg _NUM = sumEqNe ( _NUM . _NUM , bv , bOp ) ; int m = in . rlen ; for ( int i = _NUM ; i < m ; i + + ) { double ai = in . quickGetValue ( i , _NUM ) ; int cnt = ( ai = = _NUM ) ? agg _NUM : sumEqNe ( ai , bv , bOp ) ; cnt + = ( int ) out . quickGetValue ( _NUM , _NUM ) ; out . quickSetValue ( _NUM , _NUM , cnt ) ; } } 
2958	public final Token getToken ( int index ) { Token t = token ; for ( int i = _NUM ; i < index ; i + + ) { if ( t . next ! = null ) t = t . next ; else t = t . next = token _ source . getNextToken ( ) ; } return t ; } 
2959	protected void sendMessage ( ) { * * * * * * * * * * * * * * * * * * * * * * * * * * * parse link * * * * * * * * * * * * * * * * * * * boolean hasLink = false ; String textMessage = etMessage . getText ( ) . toString ( ) ; String checkForLink = Tools . checkForLink ( textMessage ) ; if ( checkForLink ! = null ) { hasLink = true ; set hasLink to true when attributes implements on api } final Message message = new Message ( ) ; message . fillMessageForSend ( activeUser , etMessage . getText ( ) . toString ( ) , Const . MessageType . TYPE _ TEXT , null , null ) ; if ( hasLink ) { btnSend . setVisibility ( View . INVISIBLE ) ; pbAboveSend . setVisibility ( View . VISIBLE ) ; new ParseUrlLinkMetadata ( checkForLink , new ParseUrlLinkMetadata . OnUrlParsed ( ) { @ Override public void onUrlParsed ( ParsedUrlData data ) { btnSend . setVisibility ( View . VISIBLE ) ; pbAboveSend . setVisibility ( View . GONE ) ; etMessage . setText ( _STR ) ; if ( SocketManager . getInstance ( ) . isSocketConnect ( ) ) { JSONObject emitMessage = EmitJsonCreator . createEmitSendMessage ( message ) ; SocketManager . getInstance ( ) . emitMessage ( Const . EmitKeyWord . SEND _ MESSAGE , emitMessage ) ; } else { unSentMessageList . add ( message ) ; } onMessageSent ( message ) ; } } 
2960	public static DrillHiveMetaStoreClient createClientWithAuthz ( final DrillHiveMetaStoreClient processUserMetaStoreClient , final HiveConf hiveConf , final String userName ) throws MetaException { try { boolean delegationTokenGenerated = false ; UGI credentials to use for RPC communication with Hive MetaStore server final UserGroupInformation ugiForRpc ; if ( ! hiveConf . getBoolVar ( ConfVars . HIVE _ SERVER _NUM _ ENABLE _ DOAS ) ) { If the user impersonation is disabled in Hive storage plugin ( not Drill impersonation ) , use the process user UGI credentials . ugiForRpc = ImpersonationUtil . getProcessUserUGI ( ) ; } else { ugiForRpc = ImpersonationUtil . createProxyUgi ( userName ) ; if ( hiveConf . getBoolVar ( ConfVars . METASTORE _ USE _ THRIFT _ SASL ) ) { When SASL is enabled for proxy user create a delegation token . Currently HiveMetaStoreClient can create client transport for proxy users only when the authentication mechanims is DIGEST ( through use of delegation tokens ) . String delegationToken = processUserMetaStoreClient . getDelegationToken ( userName , userName ) ; try { Utils . setTokenStr ( ugiForRpc , delegationToken , HiveClientWithAuthzWithCaching . DRILL _NUM HMS _ TOKEN ) ; } catch ( IOException e ) { throw new DrillRuntimeException ( _STR , e ) ; } } 
2961	public void setChoiceValues ( Context context , @ ArrayRes int stringArrayResId ) { mChoiceValues = context . getResources ( ) . getStringArray ( stringArrayResId ) ; } 
2962	private void updateStatus ( ) { final ToastBarComponent c = getToastBarComponent ( ) ; if ( c ! = null ) { try { if ( updatingStatus ) { pendingUpdateStatus = true ; return ; } updatingStatus = true ; if ( c . currentlyShowing ! = null & & ! statuses . contains ( c . currentlyShowing ) ) { c . currentlyShowing = null ; } if ( c . currentlyShowing = = null | | statuses . isEmpty ( ) ) { if ( ! statuses . isEmpty ( ) ) { c . currentlyShowing = statuses . get ( statuses . size ( ) - _NUM ) ; } else { setVisible ( false ) ; return ; } } Status s = c . currentlyShowing ; Label l = new Label ( s . getMessage ( ) ! = null ? s . getMessage ( ) : _STR ) ; c . leadButton . getListeners ( ) . clear ( ) ; c . leadButton . addActionListener ( s . getListener ( ) ) ; c . leadButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent evt ) { if ( c . currentlyShowing ! = null & & ! c . currentlyShowing . showProgressIndicator ) { c . currentlyShowing . clear ( ) ; } ToastBar . this . setVisible ( false ) ; } } ) ; c . progressLabel . setVisible ( s . isShowProgressIndicator ( ) ) ; if ( c . progressLabel . isVisible ( ) ) { if ( ! c . contains ( c . progressLabel ) ) { c . addComponent ( BorderLayout . EAST , c . progressLabel ) ; } Image anim = c . progressLabel . getAnimation ( ) ; if ( anim ! = null & & anim . getWidth ( ) > _NUM ) { c . progressLabel . setWidth ( anim . getWidth ( ) ) ; } if ( anim ! = null & & anim . getHeight ( ) > _NUM ) { c . progressLabel . setHeight ( anim . getHeight ( ) ) ; } } else { if ( c . contains ( c . progressLabel ) ) { c . removeComponent ( c . progressLabel ) ; } } c . progressBar . setVisible ( s . getProgress ( ) > = - _NUM ) ; if ( s . getProgress ( ) > = - _NUM ) { if ( ! c . contains ( c . progressBar ) ) { c . addComponent ( BorderLayout . SOUTH , c . progressBar ) ; } if ( s . getProgress ( ) < _NUM ) { c . progressBar . setInfinite ( true ) ; } else { c . progressBar . setInfinite ( false ) ; c . progressBar . setProgress ( s . getProgress ( ) ) ; } } else { c . removeComponent ( c . progressBar ) ; } c . icon . setVisible ( s . getIcon ( ) ! = null ) ; if ( s . getIcon ( ) ! = null & & c . icon . getIcon ( ) ! = s . getIcon ( ) ) { c . icon . setIcon ( s . getIcon ( ) ) ; } if ( s . getIcon ( ) = = null & & c . contains ( c . icon ) ) { c . removeComponent ( c . icon ) ; } else if ( s . getIcon ( ) ! = null & & ! c . contains ( c . icon ) ) { c . addComponent ( BorderLayout . WEST , c . icon ) ; } String oldText = c . label . getText ( ) ; if ( ! oldText . equals ( l . getText ( ) ) ) { if ( s . getUiid ( ) ! = null ) { c . setUIID ( s . getUiid ( ) ) ; } else if ( defaultUIID ! = null ) { c . setUIID ( defaultUIID ) ; } if ( c . isVisible ( ) ) { TextArea newLabel = new TextArea ( ) ; newLabel . setColumns ( l . getText ( ) . length ( ) + _NUM ) ; newLabel . setRows ( l . getText ( ) . length ( ) + _NUM ) ; newLabel . setFocusable ( false ) ; newLabel . setEditable ( false ) ; newLabel . getAllStyles ( ) . setFgColor ( _NUM xffffff ) ; if ( s . getMessageUIID ( ) ! = null ) { newLabel . setUIID ( s . getMessageUIID ( ) ) ; } else if ( defaultMessageUIID ! = null ) { newLabel . setUIID ( defaultMessageUIID ) ; } else { newLabel . setUIID ( c . label . getUIID ( ) ) ; } if ( s . getUiid ( ) ! = null ) { c . setUIID ( s . getUiid ( ) ) ; } else if ( defaultUIID ! = null ) { c . setUIID ( defaultUIID ) ; } newLabel . setWidth ( c . label . getWidth ( ) ) ; newLabel . setText ( l . getText ( ) ) ; Dimension oldTextAreaSize = UIManager . getInstance ( ) . getLookAndFeel ( ) . getTextAreaSize ( c . label , true ) ; Dimension newTexAreaSize = UIManager . getInstance ( ) . getLookAndFeel ( ) . getTextAreaSize ( newLabel , true ) ; https : if ( c . label . getParent ( ) ! = null ) { c . label . getParent ( ) . replaceAndWait ( c . label , newLabel , CommonTransitions . createCover ( CommonTransitions . SLIDE _ VERTICAL , true , _NUM _NUM _NUM ) ) ; c . label = newLabel ; if ( oldTextAreaSize . getHeight ( ) ! = newTexAreaSize . getHeight ( ) ) { c . label . setPreferredH ( newTexAreaSize . getHeight ( ) ) ; c . getParent ( ) . animateHierarchyAndWait ( _NUM _NUM _NUM ) ; } } } else { if ( s . getMessageUIID ( ) ! = null ) { c . label . setUIID ( s . getMessageUIID ( ) ) ; } else if ( defaultMessageUIID ! = null ) { c . label . setUIID ( defaultMessageUIID ) ; } if ( s . getUiid ( ) ! = null ) { c . setUIID ( s . getUiid ( ) ) ; } else if ( defaultUIID ! = null ) { c . setUIID ( defaultUIID ) ; } c . label . setText ( l . getText ( ) ) ; c . label . setColumns ( l . getText ( ) . length ( ) + _NUM ) ; c . label . setRows ( l . getText ( ) . length ( ) + _NUM ) ; c . label . setPreferredW ( c . getWidth ( ) ) ; c . revalidate ( ) ; } } else { c . revalidate ( ) ; } } finally { updatingStatus = false ; if ( pendingUpdateStatus ) { pendingUpdateStatus = false ; Display . getInstance ( ) . callSerially ( new Runnable ( ) { public void run ( ) { updateStatus ( ) ; } } ) ; } } } } 
2963	 @ Deprecateddefault < R , Q > CompletableFuture < R > send ( String queryName , Q query , Class < R > responseType ) { return query ( queryName , query , responseType ) ; } 
2964	private NexmarkPerf currentPerf ( long startMsSinceEpoch , long now , PipelineResult result , List < NexmarkPerf . ProgressSnapshot > snapshots , Monitor < ? > eventMonitor , Monitor < ? > resultMonitor ) { NexmarkPerf perf = new NexmarkPerf ( ) ; long numEvents = getCounterMetric ( result , eventMonitor . name , eventMonitor . prefix + _STR , DistributionType . MAX , - _NUM ) ) ; long effectiveEnd = - _NUM ; if ( eventEnd > = _NUM & & resultEnd > = _NUM ) { It is possible for events to be generated after the last result was emitted . ( Eg Query _NUM , which only yields results for a small prefix of the event stream . ) So use the max of last event and last result times . effectiveEnd = Math . max ( eventEnd , resultEnd ) ; } else if ( resultEnd > = _NUM ) { effectiveEnd = resultEnd ; } else if ( eventEnd > = _NUM ) { During startup we may have no result yet , but we would still like to track how long the pipeline has been running . effectiveEnd = eventEnd ; } if ( effectiveEnd > = _NUM & & eventStart > = _NUM & & effectiveEnd > = eventStart ) { perf . runtimeSec = ( effectiveEnd - eventStart ) / _NUM _NUM _NUM _NUM . _NUM ; } if ( numEvents > = _NUM ) { perf . numEvents = numEvents ; } if ( numEvents > = _NUM & & perf . runtimeSec > _NUM . _NUM ) { For streaming we may later replace this with a ' steady - state ' value calculated from the progress snapshots . perf . eventsPerSec = numEvents / perf . runtimeSec ; } if ( numEventBytes > = _NUM & & perf . runtimeSec > _NUM . _NUM ) { perf . eventBytesPerSec = numEventBytes / perf . runtimeSec ; } if ( numResults > = _NUM ) { perf . numResults = numResults ; } if ( numResults > = _NUM & & perf . runtimeSec > _NUM . _NUM ) { perf . resultsPerSec = numResults / perf . runtimeSec ; } if ( numResultBytes > = _NUM & & perf . runtimeSec > _NUM . _NUM ) { perf . resultBytesPerSec = numResultBytes / perf . runtimeSec ; } if ( eventStart > = _NUM ) { perf . startupDelaySec = ( eventStart - startMsSinceEpoch ) / _NUM _NUM _NUM _NUM . _NUM ; } if ( resultStart > = _NUM & & eventStart > = _NUM & & resultStart > = eventStart ) { perf . processingDelaySec = ( resultStart - eventStart ) / _NUM _NUM _NUM _NUM . _NUM ; } if ( timestampStart > = _NUM & & timestampEnd > = _NUM & & perf . runtimeSec > _NUM . _NUM ) { double eventRuntimeSec = ( timestampEnd - timestampStart ) / _NUM _NUM _NUM _NUM . _NUM ; perf . timeDilation = eventRuntimeSec / perf . runtimeSec ; } if ( resultEnd > = _NUM ) { Fill in the shutdown delay assuming the job has now finished . perf . shutdownDelaySec = ( now - resultEnd ) / _NUM _NUM _NUM _NUM . _NUM ; } As soon as available , try to capture cumulative cost at this point too . NexmarkPerf . ProgressSnapshot snapshot = new NexmarkPerf . ProgressSnapshot ( ) ; snapshot . secSinceStart = ( now - startMsSinceEpoch ) / _NUM _NUM _NUM _NUM . _NUM ; snapshot . runtimeSec = perf . runtimeSec ; snapshot . numEvents = numEvents ; snapshot . numResults = numResults ; snapshots . add ( snapshot ) ; captureSteadyState ( perf , snapshots ) ; return perf ; } 
2965	public Enumerable < Row > enumerable ( final QueryType queryType , final String request , final List < String > fieldNames , final ExecutorService service ) throws IOException { return new AbstractEnumerable < Row > ( ) { public Enumerator < Row > enumerator ( ) { final BlockingQueueEnumerator < Row > enumerator = new BlockingQueueEnumerator < > ( ) ; final RunnableQueueSink sink = new RunnableQueueSink ( ) { public void send ( Row row ) throws InterruptedException { enumerator . queue . put ( row ) ; } public void end ( ) { enumerator . done . set ( true ) ; } @ SuppressWarnings ( _STR ) public void setSourceEnumerable ( Enumerable < Row > enumerable ) throws InterruptedException { for ( Row row : enumerable ) { send ( row ) ; } end ( ) ; } public void run ( ) { try { final Page page = new Page ( ) ; final List < ColumnMetaData . Rep > fieldTypes = Collections . nCopies ( fieldNames . size ( ) , null ) ; request ( queryType , request , this , fieldNames , fieldTypes , page ) ; enumerator . done . set ( true ) ; } catch ( Throwable e ) { enumerator . throwableHolder . set ( e ) ; enumerator . done . set ( true ) ; } } } ; service . execute ( sink ) ; return enumerator ; } } ; } 
2966	private boolean needEnter ( ) { return ( threshold ! = _NUM & & blockSafe < blockThreshold ) | | ( datanodeThreshold ! = _NUM & & getNumLiveDataNodes ( ) < datanodeThreshold ) | | ( ! nameNodeHasResourcesAvailable ( ) ) ; } 
2967	private static void cleanupGarbageLeases ( List < Shard > shards , List < KinesisClientLease > trackedLeases , IKinesisProxy kinesisProxy , ILeaseManager < KinesisClientLease > leaseManager ) throws KinesisClientLibIOException , DependencyException , InvalidStateException , ProvisionedThroughputException { Set < String > kinesisShards = new HashSet < > ( ) ; for ( Shard shard : shards ) { kinesisShards . add ( shard . getShardId ( ) ) ; } Check if there are leases for non - existent shards List < KinesisClientLease > garbageLeases = new ArrayList < > ( ) ; for ( KinesisClientLease lease : trackedLeases ) { if ( isCandidateForCleanup ( lease , kinesisShards ) ) { garbageLeases . add ( lease ) ; } } if ( ! garbageLeases . isEmpty ( ) ) { LOG . info ( _STR ) ; leaseManager . deleteLease ( lease ) ; } } } } 
2968	public int readVInt ( ) throws IOException { byte b = readByte ( ) ; int i = b & _NUM x _NUM F ; if ( ( b & _NUM x _NUM _NUM ) = = _NUM ) return i ; b = readByte ( ) ; i | = ( b & _NUM x _NUM F ) < < _NUM ; if ( ( b & _NUM x _NUM _NUM ) = = _NUM ) return i ; b = readByte ( ) ; i | = ( b & _NUM x _NUM F ) < < _NUM _NUM ; if ( ( b & _NUM x _NUM _NUM ) = = _NUM ) return i ; b = readByte ( ) ; i | = ( b & _NUM x _NUM F ) < < _NUM _NUM ; if ( ( b & _NUM x _NUM _NUM ) = = _NUM ) return i ; b = readByte ( ) ; assert ( b & _NUM x _NUM _NUM ) = = _NUM ; return i | ( ( b & _NUM x _NUM F ) < < _NUM _NUM ) ; } 
2969	protected void constraintNotMet ( BalancerProblem cause ) { if ( ! stuck ) { stuck = true ; stuckNotificationTime = System . currentTimeMillis ( ) ; } else { if ( ( System . currentTimeMillis ( ) - stuckNotificationTime ) > TIME _ BETWEEN _ BALANCER _ WARNINGS ) { cause . run ( ) ; stuckNotificationTime = System . currentTimeMillis ( ) ; } } } 
2970	private static Map < String , CellStyle > createStyles ( Workbook wb ) { Map < String , CellStyle > styles = new HashMap < > ( ) ; DataFormat df = wb . createDataFormat ( ) ; CellStyle style ; Font headerFont = wb . createFont ( ) ; headerFont . setBold ( true ) ; style = createBorderedStyle ( wb ) ; style . setAlignment ( HorizontalAlignment . CENTER ) ; style . setFillForegroundColor ( IndexedColors . LIGHT _ CORNFLOWER _ BLUE . getIndex ( ) ) ; style . setFillPattern ( FillPatternType . SOLID _ FOREGROUND ) ; style . setFont ( headerFont ) ; styles . put ( _STR , style ) ; return styles ; } 
2971	public void assertContainsOnly ( Description description , List < ? > actual , Object [ ] values ) { checkIsNotNullAndNotEmpty ( values ) ; assertNotNull ( description , actual ) ; Set < Object > notExpected = new LinkedHashSet < Object > ( actual ) ; Set < Object > notFound = containsOnly ( notExpected , values ) ; if ( notExpected . isEmpty ( ) & & notFound . isEmpty ( ) ) { return ; } throw failures . failure ( description , shouldContainOnly ( actual , values , notFound , notExpected ) ) ; } 
2972	void saveNamespace ( ) throws AccessControlException , IOException { checkOperation ( OperationCategory . UNCHECKED ) ; checkSuperuserPrivilege ( ) ; Block if a checkpointing is in progress on standby . cpLock ( ) ; readLock ( ) ; try { checkOperation ( OperationCategory . UNCHECKED ) ; if ( ! isInSafeMode ( ) ) { throw new IOException ( _STR ) ; } 
2973	public void testAutoDispatchThrowsExceptionWhenNoMessagesDispatched ( ) { mTestLooper . startAutoDispatch ( ) ; mTestLooper . stopAutoDispatch ( ) ; } 
2974	public void testRePacking ( ) throws Exception { int numContainers = _NUM ; int componentParallelism = _NUM ; Set up the topology and its config org . apache . heron . api . Config topologyConfig = new org . apache . heron . api . Config ( ) ; topologyConfig . put ( org . apache . heron . api . Config . TOPOLOGY _ STMGRS , numContainers ) ; TopologyAPI . Topology topology = getTopology ( componentParallelism , componentParallelism , topologyConfig ) ; int numInstance = TopologyUtils . getTotalInstance ( topology ) ; Two components Assert . assertEquals ( _NUM * componentParallelism , numInstance ) ; Map < String , Integer > componentChanges = new HashMap < > ( ) ; componentChanges . put ( SPOUT _ NAME , - _NUM ) ; componentChanges . put ( BOLT _ NAME , + _NUM ) ; PackingPlan output = getRoundRobinRePackingPlan ( topology , componentChanges ) ; Assert . assertEquals ( numContainers , output . getContainers ( ) . size ( ) ) ; Assert . assertEquals ( ( Integer ) numInstance , output . getInstanceCount ( ) ) ; int spoutCount = _NUM ; int boltCount = _NUM ; for ( PackingPlan . ContainerPlan container : output . getContainers ( ) ) { Assert . assertEquals ( numInstance / numContainers , container . getInstances ( ) . size ( ) ) ; for ( PackingPlan . InstancePlan instancePlan : container . getInstances ( ) ) { if ( SPOUT _ NAME . equals ( instancePlan . getComponentName ( ) ) ) { spoutCount + + ; } else if ( BOLT _ NAME . equals ( instancePlan . getComponentName ( ) ) ) { boltCount + + ; } } } Assert . assertEquals ( componentParallelism - _NUM , spoutCount ) ; Assert . assertEquals ( componentParallelism + _NUM , boltCount ) ; } 
2975	public List < PhoneAccountHandle > getSelfManagedPhoneAccounts ( ) { try { if ( isServiceConnected ( ) ) { return getTelecomService ( ) . getSelfManagedPhoneAccounts ( mContext . getOpPackageName ( ) ) ; } } catch ( RemoteException e ) { Log . e ( TAG , _STR , e ) ; } return new ArrayList < > ( ) ; } 
2976	public String toString ( T instance ) { Preconditions . checkArgument ( instance ! = null , _STR + e ; } } 
2977	public void getMetrics ( MetricsCollector collector , boolean all ) { MetricsRecordBuilder mrb = collector . addRecord ( metricsName ) ; if ( regionSources ! = null ) { for ( MetricsRegionSource regionMetricSource : regionSources ) { if ( regionMetricSource instanceof MetricsRegionSourceImpl ) { ( ( MetricsRegionSourceImpl ) regionMetricSource ) . snapshot ( mrb , all ) ; } } mrb . addGauge ( Interns . info ( NUM _ REGIONS , NUMBER _ OF _ REGIONS _ DESC ) , regionSources . size ( ) ) ; metricsRegistry . snapshot ( mrb , all ) ; } } 
2978	public static Schema schema ( ) { return builder ( ) . build ( ) ; } 
2979	private Drawable loadDrawableInner ( Context context ) { switch ( mType ) { case TYPE _ BITMAP : return new BitmapDrawable ( context . getResources ( ) , getBitmap ( ) ) ; case TYPE _ ADAPTIVE _ BITMAP : return new AdaptiveIconDrawable ( null , new BitmapDrawable ( context . getResources ( ) , getBitmap ( ) ) ) ; case TYPE _ RESOURCE : if ( getResources ( ) = = null ) { figure out where to load resources from String resPackage = getResPackage ( ) ; if ( TextUtils . isEmpty ( resPackage ) ) { if none is specified , try the given context resPackage = context . getPackageName ( ) ; } if ( _STR + uri , e ) ; } } if ( is ! = null ) { return new BitmapDrawable ( context . getResources ( ) , BitmapFactory . decodeStream ( is ) ) ; } break ; } return null ; } 
2980	public static boolean visitInterfaces ( Class aClass , ClassVisitor visitor ) { List < Class > classesVisited = new LinkedList < > ( ) ; return visitUniqueInterfaces ( aClass , visitor , classesVisited ) ; } 
2981	public DescribeNetworkAclsResult withNetworkAcls ( NetworkAcl . . . networkAcls ) { if ( getNetworkAcls ( ) = = null ) setNetworkAcls ( new java . util . ArrayList < NetworkAcl > ( networkAcls . length ) ) ; for ( NetworkAcl value : networkAcls ) { getNetworkAcls ( ) . add ( value ) ; } return this ; } 
2982	public AmazonAutoScaling getAmazonAutoScalingClient ( ) { return amazonAutoScalingSupplier . get ( ) ; } 
2983	public XYPlot findSubplot ( PlotRenderingInfo info , Point _NUM D source ) { if ( info = = null ) { throw new IllegalArgumentException ( _STR ) ; } XYPlot result = null ; int subplotIndex = info . getSubplotIndex ( source ) ; if ( subplotIndex > = _NUM ) { result = ( XYPlot ) this . subplots . get ( subplotIndex ) ; } return result ; } 
2984	private static void zipDirectoryInternal ( File inputFile , String directoryName , ZipOutputStream zos ) throws IOException { String entryName = directoryName + inputFile . getName ( ) ; if ( inputFile . isDirectory ( ) ) { entryName + = _STR ; We are hitting a sub - directory . Recursively add children to zip in deterministic , sorted order . File [ ] childFiles = inputFile . listFiles ( ) ; if ( childFiles . length > _NUM ) { Arrays . sort ( childFiles ) ; loop through the directory content , and zip the files for ( File file : childFiles ) { zipDirectoryInternal ( file , entryName , zos ) ; } implementations of unzip . return ; } } Put the zip - entry for this file or empty directory into the zipoutputstream . ZipEntry entry = new ZipEntry ( entryName ) ; entry . setTime ( inputFile . lastModified ( ) ) ; zos . putNextEntry ( entry ) ; Copy file contents into zipoutput stream . if ( inputFile . isFile ( ) ) { Files . asByteSource ( inputFile ) . copyTo ( zos ) ; } } 
2985	public BigTextStyle bigText ( CharSequence cs ) { mBigText = safeCharSequence ( cs ) ; return this ; } 
2986	public static void main ( final String . . . args ) throws Exception { init ( _STR ) . delete ( ) ; Close the connection close ( xqc ) ; } 
2987	 @ SuppressWarnings ( _STR . length ( ) , dynamicPropertyName . length ( ) ) ; Method getMorMethod = dpCls . getDeclaredMethod ( methodName , null ) ; propertyValue = getMorMethod . invoke ( propertyValue , ( Object [ ] ) null ) ; } } } return ( T ) propertyValue ; } 
2988	public Number getStartX ( int series , int item ) { return new Double ( getStartXValue ( series , item ) ) ; } 
2989	public boolean hasTableOrColumnCaseSensitive ( String table , String column ) { boolean result = false ; ResultSet set = null ; try { if ( CmsStringUtil . isNotEmptyOrWhitespaceOnly ( column ) ) { Check if the column is given set = m _ con . getMetaData ( ) . getColumns ( null , null , table , column ) ; if ( set . next ( ) ) { String colname = set . getString ( _STR ) ; if ( tablename . equalsIgnoreCase ( table ) ) { result = true ; } } } } catch ( SQLException e ) { e . printStackTrace ( ) ; result = false ; } finally { try { if ( set ! = null ) { set . close ( ) ; } } catch ( SQLException e ) { e . printStackTrace ( ) ; } } return result ; } 
2990	public void showBaseView ( ) { if ( ( mForwardAnimatorSet ! = null & & mForwardAnimatorSet . isRunning ( ) ) | | ( mAnimationView ! = null & & mAnimationView . isPlaying ( ) ) | | ( mReverseAnimatorSet ! = null & & mReverseAnimatorSet . isRunning ( ) ) ) { return ; } if ( mBaseContainer ! = null ) { mBaseContainer . setVisibility ( VISIBLE ) ; } if ( mAnimationView ! = null ) { mAnimationView . setAnimated ( false ) ; } if ( mContextView ! = null ) { mContextView . setVisibility ( GONE ) ; } } 
2991	public int getCurrentContentInsetEnd ( ) { boolean hasActions = false ; if ( mMenuView ! = null ) { final MenuBuilder mb = mMenuView . peekMenu ( ) ; hasActions = mb ! = null & & mb . hasVisibleItems ( ) ; } return hasActions ? Math . max ( getContentInsetEnd ( ) , Math . max ( mContentInsetEndWithActions , _NUM ) ) : getContentInsetEnd ( ) ; } 
2992	protected String getLogoUrl ( ) throws JSONException { return getSiteBaseUrl ( ) + getSiteLogo ( ) ; } 
2993	private byte [ ] decodeBlock ( byte [ ] in , int inOff , int inLen ) throws InvalidCipherTextException { if ( this . pLen ! = - _NUM ) { return this . decodeBlockOrRandom ( in , inOff , inLen ) ; } byte [ ] block = engine . processBlock ( in , inOff , inLen ) ; boolean incorrectLength = ( useStrictLength & ( block . length ! = engine . getOutputBlockSize ( ) ) ) ; byte [ ] data ; if ( block . length < getOutputBlockSize ( ) ) { data = blockBuffer ; } else { data = block ; } byte type = data [ _NUM ] ; boolean badType ; if ( forPrivateKey ) { badType = ( type ! = _NUM ) ; } else { badType = ( type ! = _NUM ) ; } find and extract the message block . int start = findStart ( type , data ) ; data should start at the next byte start + + ; if ( badType | start < HEADER _ LENGTH ) { Arrays . fill ( data , ( byte ) _NUM ) ; throw new InvalidCipherTextException ( _STR ) ; } byte [ ] result = new byte [ data . length - start ] ; System . arraycopy ( data , start , result , _NUM , result . length ) ; return result ; } 
2994	public int getStringWidth ( String str ) { int width = _NUM ; for ( int i = _NUM ; i < str . length ( ) ; i + + ) { width + = getCharWidth ( str . charAt ( i ) ) ; } return width ; } 
2995	public void testLogout ( ) throws Exception { testLoginSuccess ( ) ; module . logout ( ) ; assertEquals ( _NUM , subject . getPrincipals ( ) . size ( ) ) ; assertEquals ( _NUM , subject . getPrivateCredentials ( ) . size ( ) ) ; } 
2996	public static boolean testVariance ( double stdbar , int n , double H _NUM std , boolean is _ twoTailed , double aLevel ) { if ( n < = _NUM | | H _NUM std < = _NUM ) { throw new IllegalArgumentException ( _STR ) ; } standardize it double chisquare = ( n - _NUM . _NUM ) * stdbar * stdbar / ( H _NUM std * H _NUM std ) ; boolean rejectH _NUM = checkCriticalValue ( chisquare , n , is _ twoTailed , aLevel ) ; return rejectH _NUM ; } 
2997	public static XmlBase _NUM _NUM Binary parse ( java . io . InputStream is , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( XmlBase _NUM _NUM Binary ) XmlBeans . getContextTypeLoader ( ) . parse ( is , type , options ) ; } 
2998	public void getMin ( RpcController controller , AggregateRequest request , RpcCallback < AggregateResponse > done ) { AggregateResponse response = null ; InternalScanner scanner = null ; T min = null ; try { ColumnInterpreter < T , S , P , Q , R > ci = constructColumnInterpreterFromRequest ( request ) ; T temp ; Scan scan = ProtobufUtil . toScan ( request . getScan ( ) ) ; scanner = env . getRegion ( ) . getScanner ( scan ) ; List < Cell > results = new ArrayList < > ( ) ; byte [ ] colFamily = scan . getFamilies ( ) [ _NUM ] ; NavigableSet < byte [ ] > qualifiers = scan . getFamilyMap ( ) . get ( colFamily ) ; byte [ ] qualifier = null ; if ( qualifiers ! = null & & ! qualifiers . isEmpty ( ) ) { qualifier = qualifiers . pollFirst ( ) ; } boolean hasMoreRows = false ; do { hasMoreRows = scanner . next ( results ) ; int listSize = results . size ( ) ; for ( int i = _NUM ; i < listSize ; i + + ) { temp = ci . getValue ( colFamily , qualifier , results . get ( i ) ) ; min = ( min = = null | | ( temp ! = null & & ci . compare ( temp , min ) < _NUM ) ) ? temp : min ; } results . clear ( ) ; } while ( hasMoreRows ) ; if ( min ! = null ) { response = AggregateResponse . newBuilder ( ) . addFirstPart ( ci . getProtoForCellType ( min ) . toByteString ( ) ) . build ( ) ; } } catch ( IOException e ) { CoprocessorRpcUtils . setControllerException ( controller , e ) ; } finally { if ( scanner ! = null ) { try { scanner . close ( ) ; } catch ( IOException ignored ) { } } } log . info ( _STR + min ) ; done . run ( response ) ; } 
2999	public Thumbnail getThumbnailThumbnail ( ) { byte [ ] data = getThumbnail ( ) ; if ( data = = null ) { return null ; } return new Thumbnail ( data ) ; } 
3000	public void saveLockPassword ( String password , String savedPassword , int requestedQuality , int userHandle ) { try { if ( password = = null | | password . length ( ) < MIN _ LOCK _ PASSWORD _ SIZE ) { throw new IllegalArgumentException ( _STR + re ) ; } } 
3001	public static XmlGMonthDay parse ( java . io . Reader r ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( XmlGMonthDay ) XmlBeans . getContextTypeLoader ( ) . parse ( r , type , null ) ; } 
3002	public Matrix refresh ( Matrix newMatrix , View chart , boolean invalidate ) { mMatrixTouch . set ( newMatrix ) ; make sure scale and translation are within their bounds limitTransAndScale ( mMatrixTouch , mContentRect ) ; if ( invalidate ) chart . invalidate ( ) ; newMatrix . set ( mMatrixTouch ) ; return newMatrix ; } 
3003	public static boolean isProxy ( Object object ) { Class < ? > clazz = object . getClass ( ) ; Boolean flag = isProxyCache . get ( clazz ) ; if ( flag ! = null ) { return flag ; } boolean isProxy = isSpringAopProxy ( object ) ; isProxyCache . put ( clazz , isProxy ) ; return isProxy ; } 
3004	public void applyConfiguration ( Configuration configuration ) throws IOException , IllegalStateException { Apply ambient light sensor configuration : setAlsIntegrationTime ( configuration . getAlsIntegrationTime ( ) ) ; setAlsInterruptSwitch ( configuration . getAlsInterruptSwitch ( ) ) ; setAlsInterruptPersistence ( configuration . getAlsInterruptPersistence ( ) ) ; enableAlsInterrupt ( configuration . isAlsInterruptEnabled ( ) ) ; enableAlsPower ( configuration . isAlsPowerEnabled ( ) ) ; Apply proximity sensor configuration : setPsIredDutyCycle ( configuration . getPsIredDutyCycle ( ) ) ; setPsInterruptPersistence ( configuration . getPsInterruptPersistence ( ) ) ; setPsIntegrationTime ( configuration . getPsIntegrationTime ( ) ) ; enablePsPower ( configuration . isPsPowerEnabled ( ) ) ; setPsOutputResolution ( configuration . getPsOutputResolution ( ) ) ; setPsInterruptConfiguration ( configuration . getPsInterruptConfiguration ( ) ) ; setPsMultiPulseNumbers ( configuration . getPsMultiPulseNumbers ( ) ) ; enablePsSmartPersistence ( configuration . isPsSmartPersistenceEnabled ( ) ) ; enablePsActiveForceMode ( configuration . isPsEnableActiveForceModeEnabled ( ) ) ; setPsSunlightImmunity ( configuration . getPsSunlightImmunity ( ) ) ; enablePsCancellationFunction ( configuration . isPsSunlightCancellationEnabled ( ) ) ; setPsSunlightCapability ( configuration . getPsSunlightCapability ( ) ) ; setPsSunlightProtectMode ( configuration . getPsSunlightProtectMode ( ) ) ; setPsLedCurrent ( configuration . getPsLedCurrent ( ) ) ; Update local state : updateLocalAlsConfiguration ( ) ; updateLocalPsConfiguration ( ) ; } 
3005	public boolean isSet ( _ Fields field ) { if ( field = = null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case ARG : return isSetArg ( ) ; } throw new IllegalStateException ( ) ; } 
3006	public static int deleteN ( char [ ] s , int pos , int len , int nChars ) { TODO : speed up , this is silly for ( int i = _NUM ; i < nChars ; i + + ) len = delete ( s , pos , len ) ; return len ; } 
3007	private void exportApplicationFromOrg ( UUID organizationUUID , UUID applicationId , final Map < String , Object > config , final JobExecution jobExecution , S _NUM Export s _NUM Export ) throws Exception { retrieves export entity Export export = getExportEntity ( jobExecution ) ; ApplicationInfo application = managementService . getApplicationInfo ( applicationId ) ; String appFileName = prepareOutputFileName ( application . getName ( ) , null ) ; File ephemeral = collectionExportAndQuery ( applicationId , config , export , jobExecution ) ; fileTransfer ( export , appFileName , ephemeral , config , s _NUM Export ) ; } 
3008	protected boolean doRejectedAttributesRefusePrincipalAccess ( final Map < String , Object > principalAttributes ) { LOGGER . debug ( _STR , rejectedAttributes , principalAttributes ) ; if ( rejectedAttributes . isEmpty ( ) ) { return false ; } return requiredAttributesFoundInMap ( principalAttributes , rejectedAttributes ) ; } 
3009	private void disableAndReportErrorOnJournals ( List < JournalAndStream > badJournals ) { if ( badJournals = = null | | badJournals . isEmpty ( ) ) { nothing to do return ; } for ( JournalAndStream j : badJournals ) { LOG . error ( _STR + j ) ; j . abort ( ) ; j . setDisabled ( true ) ; } } 
3010	public void setBlockHeight ( double height ) { if ( height < = _NUM . _NUM ) { throw new IllegalArgumentException ( _STR ) ; } this . blockHeight = height ; updateOffsets ( ) ; fireChangeEvent ( ) ; } 
3011	public StaticMethod buildStatic ( ) { return build ( ) . asStatic ( ) ; } 
3012	public List < CmsProperty > readProperties ( CmsDbContext dbc , I _ CmsHistoryResource resource ) throws CmsDataAccessException { Map < String , CmsProperty > propertyMap = new HashMap < String , CmsProperty > ( ) ; try { get the latest properties for this sibling int pubTag = - _NUM ; Query q = m _ sqlManager . createQuery ( dbc , C _ PROPERTIES _ HISTORY _ READ _ PUBTAG ) ; q . setParameter ( _NUM , String . valueOf ( resource . getStructureId ( ) ) ) ; q . setParameter ( _NUM , Integer . valueOf ( resource . getPublishTag ( ) ) ) ; try { pubTag = CmsDataTypeUtil . numberToInt ( ( Number ) q . getSingleResult ( ) ) ; } catch ( NoResultException e ) { do nothing } if ( pubTag > _NUM ) { add the siblings props q = m _ sqlManager . createQuery ( dbc , C _ PROPERTIES _ HISTORY _ READALL _ STR ) ; q . setParameter ( _NUM , resource . getStructureId ( ) . toString ( ) ) ; q . setParameter ( _NUM , Integer . valueOf ( pubTag ) ) ; @ SuppressWarnings ( _STR ) List < Object [ ] > res = q . getResultList ( ) ; for ( Object [ ] o : res ) { String propertyKey = ( String ) o [ _NUM ] ; String propertyValue = ( String ) o [ _NUM ] ; int mappingType = CmsDataTypeUtil . numberToInt ( ( Number ) o [ _NUM ] ) ; internalAddToPropMap ( propertyMap , resource , propertyKey , propertyValue , mappingType ) ; } } } catch ( PersistenceException e ) { throw new CmsDataAccessException ( Messages . get ( ) . container ( Messages . ERR _ JPA _ PERSITENCE , e ) , e ) ; } return new ArrayList < CmsProperty > ( propertyMap . values ( ) ) ; } 
3013	private String exportTargetFolder ( ) { String targetFolder = null ; if ( getRequest ( ) . getAttribute ( I _ CmsUploadConstants . ATTR _ CURRENT _ FOLDER ) ! = null ) { targetFolder = ( String ) getRequest ( ) . getAttribute ( I _ CmsUploadConstants . ATTR _ CURRENT _ FOLDER ) ; } if ( CmsStringUtil . isEmptyOrWhitespaceOnly ( targetFolder ) ) { targetFolder = new Dialog ( this ) . computeCurrentFolder ( ) ; } StringBuffer sb = new StringBuffer ( ) ; var targetFolder = ' / demo _ t _NUM / ' ; sb . append ( _STR ) ; wrapScript ( sb ) ; return sb . toString ( ) ; } 
3014	public JSONObject searchKeyword ( final String keyword , final int currentPageNum , final int pageSize ) { final JSONObject ret = new JSONObject ( ) ; ret . put ( Article . ARTICLES , ( Object ) Collections . emptyList ( ) ) ; final JSONObject pagination = new JSONObject ( ) ; ret . put ( Pagination . PAGINATION , pagination ) ; pagination . put ( Pagination . PAGINATION _ PAGE _ COUNT , _NUM ) ; pagination . put ( Pagination . PAGINATION _ PAGE _ NUMS , ( Object ) Collections . emptyList ( ) ) ; try { final Query query = new Query ( ) . setFilter ( CompositeFilterOperator . and ( new PropertyFilter ( Article . ARTICLE _ IS _ PUBLISHED , FilterOperator . EQUAL , true ) , CompositeFilterOperator . or ( new PropertyFilter ( Article . ARTICLE _ TITLE , FilterOperator . LIKE , _STR , e ) ; } return ret ; } 
3015	private void uploadOnClose ( Path keypath ) throws IOException { boolean uploadSuccess = false ; int attempt = _NUM ; while ( ! uploadSuccess ) { try { + + attempt ; bytesUploaded + = uploadFileAttempt ( keypath , attempt ) ; uploadSuccess = true ; } catch ( IOException e ) { LOG . info ( _STR + e , e ) ; if ( attempt > ATTEMPT _ LIMIT ) { throw e ; } } } } 
3016	public void testYARNWebAppContext ( ) throws Exception { setting up the log context System . setProperty ( _STR , getContent ( baseUrl ) . trim ( ) ) ; } finally { app . stop ( ) ; } } 
3017	public static ResourceBundleMapWrapper getResourceBundleMap ( String resource , Locale locale , Map < String , Object > context ) { return new ResourceBundleMapWrapper ( getResourceBundle ( resource , locale ) , context ) ; } 
3018	 @ SuppressWarnings ( _STR , cell . getStringCellValue ( ) ) ; assertEquals ( CellType . BLANK , cell . getCellType ( ) ) ; wb . close ( ) ; } 
3019	private void createControls ( SashForm parent ) { this . panels = Maps . newEnumMap ( PanelName . class ) ; int index = _NUM ; for ( final PanelName s : EnumSet . allOf ( PanelName . class ) ) { final Section section ; switch ( s ) { case CLUSTERS : section = createClustersPart ( parent , getSite ( ) ) ; break ; case DOCUMENTS : section = createDocumentsPart ( parent , getSite ( ) ) ; break ; case ATTRIBUTES : section = createAttributesPart ( parent , getSite ( ) ) ; break ; default : throw new RuntimeException ( _STR + s ) ; } final PanelReference sr = new PanelReference ( section , index + + ) ; panels . put ( s , sr ) ; } this . selectionProvider = new SearchEditorSelectionProvider ( this ) ; this . getSite ( ) . setSelectionProvider ( selectionProvider ) ; final ClusterTree tree = ( ClusterTree ) panels . get ( PanelName . CLUSTERS ) . section . getClient ( ) ; new ClusterTreeSelectionAdapter ( selectionProvider , tree ) ; this . getSearchResult ( ) . getInput ( ) . addAttributeListener ( new AttributeListenerAdapter ( ) { public void valueChanged ( AttributeEvent event ) { setDirty ( true ) ; } } ) ; resources . registerAttributeChangeListener ( this . getSearchResult ( ) . getInput ( ) , autoUpdateListener ) ; resources . registerPropertyChangeListener ( WorkbenchCorePlugin . getDefault ( ) . getPreferenceStore ( ) , autoUpdateListener _NUM ) ; final DocumentList documentList = ( DocumentList ) panels . get ( PanelName . DOCUMENTS ) . section . getClient ( ) ; new DocumentListSelectionAdapter ( selectionProvider , documentList , this ) ; restoreState ( ) ; } 
3020	private void throwIfClosed ( ) throws AlreadyClosedSqlException , ExecutionCanceledSqlException , SQLTimeoutException , SQLException { if ( isClosed ( ) ) { if ( cursor instanceof DrillCursor & & hasPendingCancelationNotification ) { hasPendingCancelationNotification = false ; throw new ExecutionCanceledSqlException ( _STR ) ; } } Implicit check for whether timeout is set if ( elapsedTimer ! = null ) { The timer has already been started by the DrillCursor at this point if ( elapsedTimer . elapsed ( TimeUnit . MILLISECONDS ) > this . queryTimeoutInMilliseconds ) { throw new SqlTimeoutException ( TimeUnit . MILLISECONDS . toSeconds ( this . queryTimeoutInMilliseconds ) ) ; } } } 
3021	public void testRegisterDexModuleNotExists ( ) throws Exception { ApplicationInfo info = getContext ( ) . getApplicationInfo ( ) ; String nonExistentApk = Paths . get ( info . dataDir , _STR , callback . mSuccess ) ; } 
3022	public void testBlocksAddedBeforeStandbyRestart ( ) throws Exception { banner ( _STR ) ; HATestUtil . waitForStandbyToCatchUp ( nn _NUM , nn _NUM ) ; assertSafeMode ( nn _NUM , _NUM , _NUM , _NUM , _NUM ) ; } 
3023	void updateCellWidths ( ) { int oldCellWidth = cellWidth ; cellWidth = getRhsBorderWidth ( ) ; Adjust the amount of space the line numbers take up , if necessary . if ( textArea ! = null ) { Font font = getFont ( ) ; if ( font ! = null ) { FontMetrics fontMetrics = getFontMetrics ( font ) ; int count = _NUM ; int lineCount = textArea . getLineCount ( ) + getLineNumberingStartIndex ( ) - _NUM ; do { lineCount = lineCount / _NUM _NUM ; count + + ; } while ( lineCount > = _NUM _NUM ) ; cellWidth + = fontMetrics . charWidth ( ' _NUM ' ) * ( count + _NUM ) + _NUM ; } } if ( cellWidth ! = oldCellWidth ) { Always true revalidate ( ) ; } } 
3024	public void testRead ( ) throws IOException { final ObjectMapper mapper = mapper ( ) ; JsonRoot root = mapper . readValue ( _STR , column . name ) ; } 
3025	private static WindowTwoRecord createWindowTwo ( ) { WindowTwoRecord retval = new WindowTwoRecord ( ) ; retval . setOptions ( ( short ) _NUM x _NUM b _NUM ) ; retval . setTopRow ( ( short ) _NUM ) ; retval . setLeftCol ( ( short ) _NUM ) ; retval . setHeaderColor ( _NUM x _NUM _NUM ) ; retval . setPageBreakZoom ( ( short ) _NUM ) ; retval . setNormalZoom ( ( short ) _NUM ) ; return retval ; } 
3026	public ILogData read ( long address ) { if ( ! runtime . getParameters ( ) . isCacheDisabled ( ) ) { ILogData data = readCache . get ( address ) ; if ( data = = null | | data . getType ( ) = = DataType . EMPTY ) { throw new RuntimeException ( _STR ) ; } else if ( data . isTrimmed ( ) ) { throw new TrimmedException ( ) ; } return data ; } return fetch ( address ) ; } 
3027	public void test _NUM _NUM _NUM _NUM _NUM ( ) { String record _ _NUM x _NUM _NUM _NUM _NUM = _STR ; byte [ ] data _NUM = HexRead . readFromString ( record _ _NUM x _NUM _NUM _NUM _NUM + record _ _NUM x _NUM _NUM C ) ; RecordInputStream in _NUM = TestcaseRecordInputStream . create ( data _NUM ) ; NameRecord nr _NUM = new NameRecord ( in _NUM ) ; assert _ bug _NUM _NUM _NUM _NUM _NUM ( nr _NUM ) ; byte [ ] data _NUM = nr _NUM . serialize ( ) ; assertEquals ( data _NUM . length , data _NUM . length ) ; RecordInputStream in _NUM = TestcaseRecordInputStream . create ( data _NUM ) ; NameRecord nr _NUM = new NameRecord ( in _NUM ) ; assert _ bug _NUM _NUM _NUM _NUM _NUM ( nr _NUM ) ; } 
3028	 @ edu . umd . cs . findbugs . annotations . SuppressWarnings ( value = _STR + block ) ; } We are reading the next block without block type validation , because it might turn out to be a non - data block . block = reader . readBlock ( block . getOffset ( ) + block . getOnDiskSizeWithHeader ( ) , block . getNextBlockOnDiskSize ( ) , cacheBlocks , pread , isCompaction , true , null , getEffectiveDataBlockEncoding ( ) ) ; if ( block ! = null & & ! block . getBlockType ( ) . isData ( ) ) { Findbugs : NP _ NULL _ ON _ SOME _ PATH Whatever block we read we will be returning it unless it is a datablock . Just in case the blocks are non data blocks reader . returnBlock ( block ) ; } } while ( ! block . getBlockType ( ) . isData ( ) ) ; return block ; } 
3029	public void validateSignatureWithCanonicalization _NUM ( ) { query ( _STR , true ) ; } 
3030	public Increment addColumn ( byte [ ] family , byte [ ] qualifier , long amount ) { if ( family = = null ) { throw new IllegalArgumentException ( _STR ) ; } List < Cell > list = getCellList ( family ) ; KeyValue kv = createPutKeyValue ( family , qualifier , ts , Bytes . toBytes ( amount ) ) ; list . add ( kv ) ; return this ; } 
3031	public int run ( String [ ] args ) throws Exception { Configuration conf = getConf ( ) ; JobClient client = new JobClient ( conf ) ; ClusterStatus cluster = client . getClusterStatus ( ) ; int num _ reduces = ( int ) ( cluster . getMaxReduceTasks ( ) * _NUM . _NUM ) ; String sort _ reduces = conf . get ( REDUCES _ PER _ HOST ) ; if ( sort _ reduces ! = null ) { num _ reduces = cluster . getTaskTrackers ( ) * Integer . parseInt ( sort _ reduces ) ; } Class < ? extends InputFormat > inputFormatClass = SequenceFileInputFormat . class ; Class < ? extends OutputFormat > outputFormatClass = SequenceFileOutputFormat . class ; Class < ? extends WritableComparable > outputKeyClass = BytesWritable . class ; Class < ? extends Writable > outputValueClass = BytesWritable . class ; List < String > otherArgs = new ArrayList < String > ( ) ; InputSampler . Sampler < K , V > sampler = null ; for ( int i = _NUM ; i < args . length ; + + i ) { try { if ( _STR ) ; return ret ; } 
3032	public Character put ( Double key , Character value ) { double k ; char v ; if ( key = = null ) { k = _ map . getNoEntryKey ( ) ; } else { k = unwrapKey ( key ) ; } if ( value = = null ) { v = _ map . getNoEntryValue ( ) ; } else { v = unwrapValue ( value ) ; } char retval = _ map . put ( k , v ) ; if ( retval = = _ map . getNoEntryValue ( ) ) { return null ; } return wrapValue ( retval ) ; } 
3033	public static void closeRegion ( final RpcController controller , final AdminService . BlockingInterface admin , final ServerName server , final byte [ ] regionName ) throws IOException { CloseRegionRequest closeRegionRequest = ProtobufUtil . buildCloseRegionRequest ( server , regionName ) ; try { admin . closeRegion ( controller , closeRegionRequest ) ; } catch ( ServiceException se ) { throw getRemoteException ( se ) ; } } 
3034	public INDArray readDataSet ( String datasetName , String . . . groups ) throws UnsupportedKerasConfigurationException { if ( groups . length = = _NUM ) return readDataSet ( this . file , datasetName ) ; hdf _NUM . Group [ ] groupArray = openGroups ( groups ) ; INDArray a = readDataSet ( groupArray [ groupArray . length - _NUM ] , datasetName ) ; closeGroups ( groupArray ) ; return a ; } 
3035	static List < String > getStackFrameList ( final Throwable t ) { final String stackTrace = getStackTrace ( t ) ; final String linebreak = System . lineSeparator ( ) ; final StringTokenizer frames = new StringTokenizer ( stackTrace , linebreak ) ; final List < String > list = new ArrayList < > ( ) ; boolean traceStarted = false ; while ( frames . hasMoreTokens ( ) ) { final String token = frames . nextToken ( ) ; Determine if the line starts with < whitespace > at final int at = token . indexOf ( _STR ) ; if ( at ! = - _NUM & & token . substring ( _NUM , at ) . trim ( ) . isEmpty ( ) ) { traceStarted = true ; list . add ( token ) ; } else if ( traceStarted ) { break ; } } return list ; } 
3036	public static Field findField ( Class < ? > clazz , String fieldName ) { StringBuilder sb = new StringBuilder ( clazz . getName ( ) ) ; sb . append ( ' # ' ) ; sb . append ( fieldName ) ; String fullFieldName = sb . toString ( ) ; if ( fieldCache . containsKey ( fullFieldName ) ) { Field field = fieldCache . get ( fullFieldName ) ; if ( field = = null ) throw new NoSuchFieldError ( fullFieldName ) ; return field ; } try { Field field = findFieldRecursiveImpl ( clazz , fieldName ) ; field . setAccessible ( true ) ; fieldCache . put ( fullFieldName , field ) ; return field ; } catch ( NoSuchFieldException e ) { fieldCache . put ( fullFieldName , null ) ; throw new NoSuchFieldError ( fullFieldName ) ; } } 
3037	public static BigInteger calculateM _NUM ( Digest digest , BigInteger N , BigInteger A , BigInteger M _NUM , BigInteger S ) { BigInteger M _NUM = hashPaddedTriplet ( digest , N , A , M _NUM , S ) ; return M _NUM ; } 
3038	public Action cleanTomb ( INode inode , INode iParent ) { CNode updatedCnode = iParent . mainNode ( ) . copy ( ) ; updatedCnode . remove ( inode ) ; return iParent . compareAndSet ( iParent . mainNode ( ) , updatedCnode ) ? Action . OK : Action . REPEAT ; } 
3039	private int appendDel ( ) throws IOException { If the cursor is at the most right position ( i . e no more chars after ) if ( cursor = = current . length ( ) ) { int popped = pop ( ) ; if ( popped ! = - _NUM ) { echoDel ( ) ; We do not care about the return value of echoDel , but we will return a value that indcates that a flush is required although it may not to properly carry out the status we should have two things to return _NUM / the popped char _NUM / the boolean indicating if flush is required } return popped ; } else { We are editing the line Shift all the chars after the cursor int popped = pop ( ) ; if ( popped ! = - _NUM ) { We move the cursor to left if ( driver . moveLeft ( ) ) { StringBuilder disp = new StringBuilder ( ) ; disp . append ( current , cursor , current . length ( ) ) ; disp . append ( ' ' ) ; driver . write ( disp ) ; int amount = current . length ( ) - cursor + _NUM ; while ( amount > _NUM ) { driver . moveLeft ( ) ; amount - - ; } } else { throw new UnsupportedOperationException ( _STR ) ; } } return popped ; } } 
3040	private ConcurrentHashMap < String , Host > getHostsByName ( ) { if ( hostsByName = = null ) { safelyLoadClustersAndHosts ( ) ; } return hostsByName ; } 
3041	private int getProfileParent ( ) { UserInfo parent = mInjector . getUserManager ( ) . getProfileParent ( UserHandle . myUserId ( ) ) ; if ( parent = = null ) { Slog . wtf ( TAG , FORWARD _ INTENT _ TO _ PARENT + _STR ) ; return UserHandle . USER _ NULL ; } return parent . id ; } 
3042	public static final String getLowerCaseString ( int index ) { return getString ( index ) ; } 
3043	public boolean isSet ( _ Fields field ) { if ( field = = null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case ARG : return isSetArg ( ) ; } throw new IllegalStateException ( ) ; } 
3044	public static BigDecimal getInvoiceNotApplied ( Delegator delegator , String invoiceId , Boolean actualCurrency ) { return InvoiceWorker . getInvoiceTotal ( delegator , invoiceId , actualCurrency ) . subtract ( getInvoiceApplied ( delegator , invoiceId , UtilDateTime . nowTimestamp ( ) , actualCurrency ) ) ; } 
3045	public synchronized int getStageTimeout ( ) { checkWrappersLoaded ( ) ; if ( stageTimeout = = - _NUM ) { for ( String host : commandsToSend . keySet ( ) ) { int summaryTaskTimeoutForHost = _NUM ; for ( ExecutionCommandWrapper command : commandsToSend . get ( host ) ) { Map < String , String > commandParams = command . getExecutionCommand ( ) . getCommandParams ( ) ; String timeoutKey = ExecutionCommand . KeyNames . COMMAND _ TIMEOUT ; if ( commandParams ! = null & & commandParams . containsKey ( timeoutKey ) ) { String timeoutStr = commandParams . get ( timeoutKey ) ; long commandTimeout = Converting to milliseconds Long . parseLong ( timeoutStr ) * _NUM _NUM _NUM _NUM ; summaryTaskTimeoutForHost + = commandTimeout ; } else { LOG . error ( _STR + command ) ; } } if ( summaryTaskTimeoutForHost > stageTimeout ) { stageTimeout = summaryTaskTimeoutForHost ; } } } return stageTimeout ; } 
3046	protected List < EvaluationConditionalFormatRule > getRules ( Sheet sheet ) { final String sheetName = sheet . getSheetName ( ) ; List < EvaluationConditionalFormatRule > rules = formats . get ( sheetName ) ; if ( rules = = null ) { if ( formats . containsKey ( sheetName ) ) { return Collections . emptyList ( ) ; } final SheetConditionalFormatting scf = sheet . getSheetConditionalFormatting ( ) ; final int count = scf . getNumConditionalFormattings ( ) ; rules = new ArrayList < > ( count ) ; formats . put ( sheetName , rules ) ; for ( int i = _NUM ; i < count ; i + + ) { ConditionalFormatting f = scf . getConditionalFormattingAt ( i ) ; optimization , as this may be expensive for lots of ranges final CellRangeAddress [ ] regions = f . getFormattingRanges ( ) ; for ( int r = _NUM ; r < f . getNumberOfRules ( ) ; r + + ) { ConditionalFormattingRule rule = f . getRule ( r ) ; rules . add ( new EvaluationConditionalFormatRule ( workbookEvaluator , sheet , f , i , rule , r , regions ) ) ; } } need them in formatting and priority order so logic works right Collections . sort ( rules ) ; } return Collections . unmodifiableList ( rules ) ; } 
3047	private void handleElse ( ) throws IOException { boolean enabledStatusBeforeElse = enabled ( ) ; popEnableBit ( ) ; pushEnableBit ( enabled ( ) & & ! enabledStatusBeforeElse ) ; debugPrint ( true , _STR ) ; } 
3048	public static void main ( String [ ] args ) { if ( args . length ! = _NUM ) { System . exit ( - _NUM ) ; } String mem = args [ _NUM ] ; String sector = args [ _NUM ] ; try { getNumSector ( mem , sector ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } 
3049	public final void asString ( final Format format , final StructuredDataId structuredDataId , final StringBuilder sb ) { final boolean full = Format . FULL . equals ( format ) ; if ( full ) { final String myType = getType ( ) ; if ( myType = = null ) { return ; } sb . append ( getType ( ) ) . append ( ' ' ) ; } StructuredDataId sdId = getId ( ) ; if ( sdId ! = null ) { returns sdId if structuredDataId is null sdId = sdId . makeId ( structuredDataId ) ; } else { sdId = structuredDataId ; } if ( sdId = = null | | sdId . getName ( ) = = null ) { return ; } if ( Format . XML . equals ( format ) ) { asXml ( sdId , sb ) ; return ; } sb . append ( ' [ ' ) ; avoids toString if implements StringBuilderFormattable StringBuilders . appendValue ( sb , sdId ) ; sb . append ( ' ' ) ; appendMap ( sb ) ; sb . append ( ' ] ' ) ; if ( full ) { final String msg = getFormat ( ) ; if ( msg ! = null ) { sb . append ( ' ' ) . append ( msg ) ; } } } 
3050	 $ ANTLR start _STR , _NUM _NUM , _NUM , input ) ; throw nvae ; } switch ( alt _NUM _NUM ) { case _NUM : JPA _NUM . g : _NUM _NUM _NUM : _NUM _NUM : path _ expression { pushFollow ( FOLLOW _ path _ expression _ in _ date _ before _ macro _ expression _NUM _NUM _NUM _NUM ) ; path _ expression _NUM _NUM _NUM = path _ expression ( ) ; state . _ fsp - - ; if ( state . failed ) return retval ; if ( state . backtracking = = _NUM ) adaptor . addChild ( root _ _NUM , path _ expression _NUM _NUM _NUM . getTree ( ) ) ; } break ; case _NUM : JPA _NUM . g : _NUM _NUM _NUM : _NUM _NUM : input _ parameter { pushFollow ( FOLLOW _ input _ parameter _ in _ date _ before _ macro _ expression _NUM _NUM _NUM _NUM ) ; input _ parameter _NUM _NUM _NUM = input _ parameter ( ) ; state . _ fsp - - ; if ( state . failed ) return retval ; if ( state . backtracking = = _NUM ) adaptor . addChild ( root _ _NUM , input _ parameter _NUM _NUM _NUM . getTree ( ) ) ; } break ; } JPA _NUM . g : _NUM _NUM _NUM : _NUM _NUM : ( ' , ' ' USER _ TIMEZONE ' ) ? int alt _NUM _NUM = _NUM ; int LA _NUM _NUM _ _NUM = input . LA ( _NUM ) ; if ( ( LA _NUM _NUM _ _NUM = = _NUM _NUM ) ) { alt _NUM _NUM = _NUM ; } switch ( alt _NUM _NUM ) { case _NUM : JPA _NUM . g : _NUM _NUM _NUM : _NUM _NUM : ' , ' ' USER _ TIMEZONE ' { char _ literal _NUM _NUM _NUM = ( Token ) match ( input , _NUM _NUM , FOLLOW _ _NUM _NUM _ in _ date _ before _ macro _ expression _NUM _NUM _NUM _NUM ) ; if ( state . failed ) return retval ; if ( state . backtracking = = _NUM ) { char _ literal _NUM _NUM _NUM _ tree = ( Object ) adaptor . create ( char _ literal _NUM _NUM _NUM ) ; adaptor . addChild ( root _ _NUM , char _ literal _NUM _NUM _NUM _ tree ) ; } string _ literal _NUM _NUM _NUM = ( Token ) match ( input , _NUM _NUM _NUM , FOLLOW _ _NUM _NUM _NUM _ in _ date _ before _ macro _ expression _NUM _NUM _NUM _NUM ) ; if ( state . failed ) return retval ; if ( state . backtracking = = _NUM ) { string _ literal _NUM _NUM _NUM _ tree = ( Object ) adaptor . create ( string _ literal _NUM _NUM _NUM ) ; adaptor . addChild ( root _ _NUM , string _ literal _NUM _NUM _NUM _ tree ) ; } } break ; } char _ literal _NUM _NUM _NUM = ( Token ) match ( input , RPAREN , FOLLOW _ RPAREN _ in _ date _ before _ macro _ expression _NUM _NUM _NUM _NUM ) ; if ( state . failed ) return retval ; if ( state . backtracking = = _NUM ) { char _ literal _NUM _NUM _NUM _ tree = ( Object ) adaptor . create ( char _ literal _NUM _NUM _NUM ) ; adaptor . addChild ( root _ _NUM , char _ literal _NUM _NUM _NUM _ tree ) ; } } retval . stop = input . LT ( - _NUM ) ; if ( state . backtracking = = _NUM ) { retval . tree = ( Object ) adaptor . rulePostProcessing ( root _ _NUM ) ; adaptor . setTokenBoundaries ( retval . tree , retval . start , retval . stop ) ; } } catch ( RecognitionException re ) { reportError ( re ) ; recover ( input , re ) ; retval . tree = ( Object ) adaptor . errorNode ( input , retval . start , input . LT ( - _NUM ) , re ) ; } finally { do for sure before leaving } return retval ; } 
3051	public final void cancel ( boolean force ) { if ( isRunning ( ) ) { canceling ( ) ; if ( mCancellation ! = null ) { try { mCancellation . cancel ( ) ; } catch ( RemoteException re ) { Log . w ( LOG _ TAG , _STR ) ; } mHandler . sendMessageDelayed ( mHandler . obtainMessage ( AsyncCommandHandler . MSG _ FORCE _ CANCEL ) , FORCE _ CANCEL _ TIMEOUT ) ; } return ; } canceled ( ) ; Done . mDoneCallback . onDone ( ) ; } 
3052	public Builder setKeyIdentifier ( byte [ ] keyIdentifier ) { return set ( PARAM _ TYPE _ KEY _ IDENTIFIER , keyIdentifier ) ; } 
3053	public void finish ( ) throws IOException { if ( finished ) { return ; } flush ( ) ; Finish the stream by stating that there are _NUM elements that follow . VarInt . encode ( _NUM , os ) ; if ( ! BUFFER _ POOL . offer ( buffer ) ) { The pool is full , we can ' t store the buffer . We just drop the buffer . } finished = true ; } 
3054	private static void uaRIMLt ( MatrixBlock in , MatrixBlock out , double [ ] bv , int [ ] bvi , BinaryOperator bOp ) { int ind _NUM = uarimaxLt ( _NUM . _NUM , bv , bvi , bOp ) ; int m = in . rlen ; for ( int i = _NUM ; i < m ; i + + ) { double ai = in . quickGetValue ( i , _NUM ) ; int ind = ( ai = = _NUM ) ? ind _NUM : uarimaxLt ( ai , bv , bvi , bOp ) ; out . quickSetValue ( i , _NUM , ind ) ; } } 
3055	public void startFocusGainAnimation ( ) { cancelAnimator ( mButtonFocusLossAnimator ) ; cancelAnimator ( mTextFocusLossAnimator ) ; mTextFocusGainAnimator . start ( ) ; if ( mButtonImageView . getAlpha ( ) < _NUM f ) { If we had faded out the ripple drawable , run our manual focus change animation . See the comment at { @ link # startFocusLossAnimation ( ) } for the reason of manual animator . mButtonFocusGainAnimator . start ( ) ; } } 
3056	private static void validateReturnType ( Class < ? extends PipelineOptions > iface ) { Iterable < Method > interfaceMethods = FluentIterable . from ( ReflectHelpers . getClosureOfMethodsOnInterface ( iface ) ) . filter ( NOT _ SYNTHETIC _ PREDICATE ) . toSortedSet ( MethodComparator . INSTANCE ) ; SortedSetMultimap < Method , Method > methodNameToMethodMap = TreeMultimap . create ( MethodNameComparator . INSTANCE , MethodComparator . INSTANCE ) ; for ( Method method : interfaceMethods ) { methodNameToMethodMap . put ( method , method ) ; } List < MultipleDefinitions > multipleDefinitions = Lists . newArrayList ( ) ; for ( Map . Entry < Method , Collection < Method > > entry : methodNameToMethodMap . asMap ( ) . entrySet ( ) ) { Set < Class < ? > > returnTypes = FluentIterable . from ( entry . getValue ( ) ) . transform ( ReturnTypeFetchingFunction . INSTANCE ) . toSet ( ) ; SortedSet < Method > collidingMethods = FluentIterable . from ( entry . getValue ( ) ) . toSortedSet ( MethodComparator . INSTANCE ) ; if ( returnTypes . size ( ) > _NUM ) { MultipleDefinitions defs = new MultipleDefinitions ( ) ; defs . method = entry . getKey ( ) ; defs . collidingMethods = collidingMethods ; multipleDefinitions . add ( defs ) ; } } throwForMultipleDefinitions ( iface , multipleDefinitions ) ; } 
3057	public int read ( byte [ ] b , int off , int len ) throws IOException { if ( bufOff > = maxBuf ) { if ( nextChunk ( ) < _NUM ) { return - _NUM ; } } int toSupply = Math . min ( len , available ( ) ) ; System . arraycopy ( buf , bufOff , b , off , toSupply ) ; bufOff + = toSupply ; return toSupply ; } 
3058	public static List < ColumnInfo > generateColumnInfo ( Connection conn , String tableName , List < String > columns , boolean strict ) throws SQLException { Map < String , Integer > columnNameToTypeMap = Maps . newLinkedHashMap ( ) ; Set < String > ambiguousColumnNames = new HashSet < String > ( ) ; Map < String , Integer > fullColumnNameToTypeMap = Maps . newLinkedHashMap ( ) ; DatabaseMetaData dbmd = conn . getMetaData ( ) ; int unfoundColumnCount = _NUM ; TODO : escape wildcard characters here because we don ' t want that behavior here String escapedTableName = StringUtil . escapeLike ( tableName ) ; String [ ] schemaAndTable = escapedTableName . split ( _STR ) ; exceptionMessage . append ( col ) ; } throw new SQLException ( exceptionMessage . toString ( ) ) ; } if ( sqlType = = null ) { if ( strict ) { throw new SQLExceptionInfo . Builder ( SQLExceptionCode . COLUMN _ NOT _ FOUND ) . setColumnName ( columnName ) . setTableName ( tableName ) . build ( ) . buildException ( ) ; } unfoundColumnCount + + ; } else { columnInfoList . add ( new ColumnInfo ( columnName , sqlType ) ) ; } } if ( unfoundColumnCount = = columns . size ( ) ) { throw new SQLExceptionInfo . Builder ( SQLExceptionCode . COLUMN _ NOT _ FOUND ) . setColumnName ( Arrays . toString ( columns . toArray ( new String [ _NUM ] ) ) ) . setTableName ( tableName ) . build ( ) . buildException ( ) ; } } return columnInfoList ; } 
3059	private boolean replace ( final ListType type , final INode oldChild , final INode newChild ) { final List < INode > list = getList ( type ) ; final int i = search ( list , oldChild . getLocalNameBytes ( ) ) ; if ( i < _NUM | | list . get ( i ) . getId ( ) ! = oldChild . getId ( ) ) { return false ; } final INode removed = list . set ( i , newChild ) ; Preconditions . checkState ( removed = = oldChild ) ; return true ; } 
3060	public static DefaultFilenamePolicy fromStandardParameters ( ValueProvider < ResourceId > baseFilename , @ Nullable String shardTemplate , @ Nullable String filenameSuffix , boolean windowedWrites ) { Params params = new Params ( ) . withBaseFilename ( baseFilename ) ; if ( shardTemplate ! = null ) { params = params . withShardTemplate ( shardTemplate ) ; } if ( filenameSuffix ! = null ) { params = params . withSuffix ( filenameSuffix ) ; } if ( windowedWrites ) { params = params . withWindowedWrites ( ) ; } return fromParams ( params ) ; } 
3061	public void init ( CmsObject cms , String configFile , Locale locale ) throws CmsException { m _ cms = cms ; m _ locale = cms . getRequestContext ( ) . getLocale ( ) ; if ( configFile ! = null ) { m _ configFile = configFile ; } if ( locale ! = null ) { m _ decorations = new CmsDecorationBundle ( locale ) ; m _ locale = locale ; } if ( m _ configFile ! = null ) { get the configuration file CmsResource res = m _ cms . readResource ( m _ configFile ) ; CmsFile file = m _ cms . readFile ( res ) ; CmsXmlContent configuration = CmsXmlContentFactory . unmarshal ( m _ cms , file ) ; get the uselocale flag if this flag is not set to true , we must build locale independent decoration bundles String uselocale = configuration . getValue ( XPATH _ USELOCALE , m _ configurationLocale ) . getStringValue ( m _ cms ) ; if ( ! uselocale . equals ( _STR , m _ configurationLocale ) ; m _ excludes . add ( excludeValue . toLowerCase ( ) ) ; } } } 
3062	default Traversable < T > dropUntil ( final Predicate < ? super T > p ) { return skipUntil ( p ) ; } 
3063	public final void initialize ( final Subject subject , final CallbackHandler handler , final Map < String , ? > state , final Map < String , ? > options ) { this . assertion = null ; this . callbackHandler = handler ; this . subject = subject ; this . sharedState = ( Map < String , Object > ) state ; this . sharedState = new HashMap < String , Object > ( state ) ; String ticketValidatorClass = null ; for ( final String key : options . keySet ( ) ) { logger . trace ( _STR ) ; this . ticketValidator = createTicketValidator ( ticketValidatorClass , options ) ; } 
3064	public void clientCredentialsFlowWithHeaderAuthorization ( ) throws Exception { get app credentials from / < org > / < app > / credentials end - point ( using admin credentials ) Credentials appCredentials = getAppCredentials ( ) ; String clientId = appCredentials . getClientId ( ) ; String clientSecret = appCredentials . getClientSecret ( ) ; use app credentials to admin user access token Token token = clientSetup . getRestClient ( ) . management ( ) . token ( ) . post ( Token . class , new Token ( _STR , apiResponse . getExpirationDate ( ) ) ; } 
3065	public INDArray put ( int i , INDArray element ) { if ( ! element . isScalar ( ) ) throw new IllegalArgumentException ( _STR ) ; return putScalar ( i , element . getDouble ( _NUM ) ) ; } 
3066	public static URL resolveMandatoryResourceAsUrl ( ClassResolver classResolver , String uri ) throws FileNotFoundException , MalformedURLException { URL url = resolveResourceAsUrl ( classResolver , uri ) ; if ( url = = null ) { String resolvedName = resolveUriPath ( uri ) ; throw new FileNotFoundException ( _STR + uri ) ; } else { return url ; } } 
3067	public void apply ( JFreeChart chart ) { if ( chart = = null ) { throw new IllegalArgumentException ( _STR ) ; } TextTitle title = chart . getTitle ( ) ; if ( title ! = null ) { title . setFont ( this . extraLargeFont ) ; title . setPaint ( this . titlePaint ) ; } int subtitleCount = chart . getSubtitleCount ( ) ; for ( int i = _NUM ; i < subtitleCount ; i + + ) { applyToTitle ( chart . getSubtitle ( i ) ) ; } chart . setBackgroundPaint ( this . chartBackgroundPaint ) ; now process the plot if there is one Plot plot = chart . getPlot ( ) ; if ( plot ! = null ) { applyToPlot ( plot ) ; } } 
3068	public Instance getNextInstance ( Instances structure ) throws IOException { throw new IOException ( _STR ) ; String directoryPath = getDirectory ( ) . getAbsolutePath ( ) ; Attribute classAtt = structure . classAttribute ( ) ; if ( m _ filesByClass = = null ) { m _ filesByClass = new ArrayList < LinkedList < String > > ( ) ; for ( int i = _NUM ; i < classAtt . numValues ( ) ; i + + ) { File classDir = new File ( directoryPath + File . separator + classAtt . value ( i ) ) ; String [ ] files = classDir . list ( ) ; LinkedList < String > classDocs = new LinkedList < String > ( ) ; for ( String cd : files ) { File txt = new File ( directoryPath + File . separator + classAtt . value ( i ) + File . separator + cd ) ; if ( txt . isFile ( ) ) { classDocs . add ( cd ) ; } } m _ filesByClass . add ( classDocs ) ; } } cycle through the classes int count = _NUM ; LinkedList < String > classContents = m _ filesByClass . get ( m _ lastClassDir ) ; boolean found = ( classContents . size ( ) > _NUM ) ; while ( classContents . size ( ) = = _NUM ) { m _ lastClassDir + + ; count + + ; if ( m _ lastClassDir = = structure . classAttribute ( ) . numValues ( ) ) { m _ lastClassDir = _NUM ; } classContents = m _ filesByClass . get ( m _ lastClassDir ) ; if ( classContents . size ( ) > _NUM ) { we have an instance we can create found = true ; break ; } if ( count = = structure . classAttribute ( ) . numValues ( ) ) { must be finished break ; } } if ( found ) { String nextDoc = classContents . poll ( ) ; File txt = new File ( directoryPath + File . separator + classAtt . value ( m _ lastClassDir ) + File . separator + nextDoc ) ; BufferedReader is ; if ( m _ charSet = = null | | m _ charSet . length ( ) = = _NUM ) { is = new BufferedReader ( new InputStreamReader ( new FileInputStream ( txt ) ) ) ; } else { is = new BufferedReader ( new InputStreamReader ( new FileInputStream ( txt ) , m _ charSet ) ) ; } StringBuffer txtStr = new StringBuffer ( ) ; int c ; while ( ( c = is . read ( ) ) ! = - _NUM ) { txtStr . append ( ( char ) c ) ; } double [ ] newInst = null ; if ( m _ OutputFilename ) newInst = new double [ _NUM ] ; else newInst = new double [ _NUM ] ; if ( getRetainStringValues ( ) ) { newInst [ _NUM ] = ( double ) structure . attribute ( _NUM ) . addStringValue ( txtStr . toString ( ) ) ; } else { newInst [ _NUM ] = _NUM ; structure . attribute ( _NUM ) . setStringValue ( txtStr . toString ( ) ) ; } if ( m _ OutputFilename ) { if ( getRetainStringValues ( ) ) { newInst [ _NUM ] = ( double ) structure . attribute ( _NUM ) . addStringValue ( txt . getAbsolutePath ( ) ) ; } else { newInst [ _NUM ] = _NUM ; structure . attribute ( _NUM ) . setStringValue ( txt . getAbsolutePath ( ) ) ; } } newInst [ structure . classIndex ( ) ] = ( double ) m _ lastClassDir ; Instance inst = new DenseInstance ( _NUM . _NUM , newInst ) ; inst . setDataset ( structure ) ; is . close ( ) ; m _ lastClassDir + + ; if ( m _ lastClassDir = = structure . classAttribute ( ) . numValues ( ) ) { m _ lastClassDir = _NUM ; } return inst ; } else { done ! return null ; } } 
3069	public static Wavetable sawh ( int numberOfHarmonics ) { float [ ] content = new float [ numberOfHarmonics ] ; for ( int i = _NUM ; i < numberOfHarmonics ; i + + ) { content [ i ] = ( float ) ( ( - _NUM ) / ( ( i + _NUM ) * Math . PI ) * Math . pow ( - _NUM , i + _NUM ) ) ; } return WavetableGenerator . gen _NUM _NUM ( tableSize , content ) ; } 
3070	protected void BuildGSubrsUsed ( int Font ) { int LBias = _NUM ; int SizeOfNonCIDSubrsUsed = _NUM ; if ( fonts [ Font ] . privateSubrs > = _NUM ) { LBias = CalcBias ( fonts [ Font ] . privateSubrs , Font ) ; SizeOfNonCIDSubrsUsed = lSubrsUsedNonCID . size ( ) ; } For each global subr used for ( int i = _NUM ; i < lGSubrsUsed . size ( ) ; i + + ) { Pop the value + check valid int Subr = ( ( Integer ) lGSubrsUsed . get ( i ) ) . intValue ( ) ; if ( Subr < gsubrOffsets . length - _NUM & & Subr > = _NUM ) { Read the subr and process int Start = gsubrOffsets [ Subr ] ; int End = gsubrOffsets [ Subr + _NUM ] ; if ( fonts [ Font ] . isCID ) ReadASubr ( Start , End , GBias , _NUM , hGSubrsUsed , lGSubrsUsed , null ) ; else { ReadASubr ( Start , End , GBias , LBias , hSubrsUsedNonCID , lSubrsUsedNonCID , fonts [ Font ] . SubrsOffsets ) ; if ( SizeOfNonCIDSubrsUsed < lSubrsUsedNonCID . size ( ) ) { for ( int j = SizeOfNonCIDSubrsUsed ; j < lSubrsUsedNonCID . size ( ) ; j + + ) { Pop the value + check valid int LSubr = ( ( Integer ) lSubrsUsedNonCID . get ( j ) ) . intValue ( ) ; if ( LSubr < fonts [ Font ] . SubrsOffsets . length - _NUM & & LSubr > = _NUM ) { Read the subr and process int LStart = fonts [ Font ] . SubrsOffsets [ LSubr ] ; int LEnd = fonts [ Font ] . SubrsOffsets [ LSubr + _NUM ] ; ReadASubr ( LStart , LEnd , GBias , LBias , hSubrsUsedNonCID , lSubrsUsedNonCID , fonts [ Font ] . SubrsOffsets ) ; } } SizeOfNonCIDSubrsUsed = lSubrsUsedNonCID . size ( ) ; } } } } } 
3071	public void should _ round _ robin _ within _ local _ dc ( ) { given : a _NUM _NUM node _NUM DC cluster . ScassandraCluster sCluster = ScassandraCluster . builder ( ) . withNodes ( _NUM , _NUM ) . build ( ) ; Cluster cluster = builder ( ) . addContactPoints ( sCluster . address ( _NUM , _NUM ) . getAddress ( ) ) . withPort ( sCluster . getBinaryPort ( ) ) . withLoadBalancingPolicy ( DCAwareRoundRobinPolicy . builder ( ) . withLocalDc ( datacenter ( _NUM ) ) . build ( ) ) . build ( ) ; try { sCluster . init ( ) ; Session session = cluster . connect ( ) ; when : a query is executed _NUM _NUM times . queryTracker . query ( session , _NUM _NUM ) ; then : no node in the remote DC should get a request . for ( int i = _NUM ; i < = _NUM ; i + + ) { queryTracker . assertQueried ( sCluster , _NUM , i , _NUM _NUM ) ; queryTracker . assertQueried ( sCluster , _NUM , i , _NUM ) ; } } finally { cluster . close ( ) ; sCluster . stop ( ) ; } } 
3072	public Iterator < Tuple < NodeId > > find ( Tuple < NodeId > pattern ) { if ( tupleLen ! = pattern . len ( ) ) throw new TDBException ( format ( _STR , pattern . len ( ) , tupleLen ) ) ; int numSlots = _NUM ; Canonical form . for ( int i = _NUM ; i < tupleLen ; i + + ) { NodeId x = pattern . get ( i ) ; if ( ! NodeId . isAny ( x ) ) numSlots + + ; if ( NodeId . isDoesNotExist ( x ) ) return Iter . nullIterator ( ) ; } if ( numSlots = = _NUM ) return scanAllIndex . all ( ) ; int indexNumSlots = _NUM ; TupleIndex index = null ; for ( TupleIndex idx : indexes ) { if ( idx ! = null ) { int w = idx . weight ( pattern ) ; if ( w > indexNumSlots ) { indexNumSlots = w ; index = idx ; } } } if ( index = = null ) No index at all . Scan . index = indexes [ _NUM ] ; return index . find ( pattern ) ; } 
3073	public void loadGraph ( GraphNonTxnTDB graph , InputStream in ) { loadGraph $ ( graph , in , showProgress , generateStats ) ; } 
3074	protected CognitoUserSession getCachedSession ( ) { if ( userId = = null ) { throw new CognitoNotAuthorizedException ( _STR ) ; } 
3075	public void testEntrySetToArray ( ) { ConcurrentMap map = map _NUM ( ) ; Set s = map . entrySet ( ) ; Object [ ] ar = s . toArray ( ) ; assertEquals ( _NUM , ar . length ) ; for ( int i = _NUM ; i < _NUM ; + + i ) { assertTrue ( map . containsKey ( ( ( Map . Entry ) ( ar [ i ] ) ) . getKey ( ) ) ) ; assertTrue ( map . containsValue ( ( ( Map . Entry ) ( ar [ i ] ) ) . getValue ( ) ) ) ; } } 
3076	public static XmlObject parse ( XMLStreamReader xsr , XmlOptions options ) throws XmlException { return XmlBeans . getContextTypeLoader ( ) . parse ( xsr , null , options ) ; } 
3077	public static Histogram < String > loadFromUtf _NUM File ( Path path , char delimiter ) throws IOException { List < String > lines = Files . readAllLines ( path , StandardCharsets . UTF _ _NUM ) ; return loadFromLines ( lines , delimiter ) ; } 
3078	public static WALEdit createCompaction ( final RegionInfo hri , final CompactionDescriptor c ) { byte [ ] pbbytes = c . toByteArray ( ) ; KeyValue kv = new KeyValue ( getRowForRegion ( hri ) , METAFAMILY , COMPACTION , EnvironmentEdgeManager . currentTime ( ) , pbbytes ) ; replication scope null so that this won ' t be replicated return new WALEdit ( ) . add ( kv ) ; } 
3079	private void rewind ( ) { setRewindSpeedFactors ( ) method ; if ( mRewindSpeedFactors = = null ) { if ( DEBUG ) { Log . d ( TAG , _STR + mRewindStartPosition ) ; mIsRewindBegin = true ; mRewindStartTime = SystemClock . elapsedRealtime ( ) ; } Toggle the flag to indicate rewind status . mIsRewinding = true ; Pause the player but won ' t update the UI status . mPlayer . pause ( ) ; Update playback state , mIsRewinding will be reset to false inside of it . mMediaSession . setPlaybackState ( createPlaybackStateBuilder ( PlaybackStateCompat . STATE _ REWINDING ) . build ( ) ) ; mRewindSpeedFactorIndex + = _NUM ; if ( mRewindSpeedFactorIndex > mRewindSpeedFactors . length - _NUM ) { mRewindSpeedFactorIndex = mRewindSpeedFactors . length - _NUM ; } } 
3080	void setSelectionInt ( int position , boolean animate ) { if ( position ! = mOldSelectedPosition ) { mBlockLayoutRequests = true ; int delta = position - mSelectedPosition ; setNextSelectedPositionInt ( position ) ; layout ( delta , animate ) ; mBlockLayoutRequests = false ; } } 
3081	private List < Map < WhiteCardData , Object > > getWhiteCardData ( final List < WhiteCard > cards ) { final List < Map < WhiteCardData , Object > > data = new ArrayList < Map < WhiteCardData , Object > > ( cards . size ( ) ) ; for ( final WhiteCard card : cards ) { data . add ( card . getClientData ( ) ) ; } return data ; } 
3082	private void initDropDownStyle ( ) { if ( headerLayout ! = null ) { if ( isDropDownStyle ) { addHeaderView ( headerLayout ) ; } else { removeHeaderView ( headerLayout ) ; } return ; } if ( ! isDropDownStyle ) { return ; } headerReleaseMinDistance = context . getResources ( ) . getDimensionPixelSize ( R . dimen . drop _ down _ list _ header _ release _ min _ distance ) ; flipAnimation = new RotateAnimation ( _NUM , _NUM _NUM _NUM , RotateAnimation . RELATIVE _ TO _ SELF , _NUM . _NUM f , RotateAnimation . RELATIVE _ TO _ SELF , _NUM . _NUM f ) ; flipAnimation . setInterpolator ( new LinearInterpolator ( ) ) ; flipAnimation . setDuration ( _NUM _NUM _NUM ) ; flipAnimation . setFillAfter ( true ) ; reverseFlipAnimation = new RotateAnimation ( - _NUM _NUM _NUM , _NUM , RotateAnimation . RELATIVE _ TO _ SELF , _NUM . _NUM f , RotateAnimation . RELATIVE _ TO _ SELF , _NUM . _NUM f ) ; reverseFlipAnimation . setInterpolator ( new LinearInterpolator ( ) ) ; reverseFlipAnimation . setDuration ( _NUM _NUM _NUM ) ; reverseFlipAnimation . setFillAfter ( true ) ; headerDefaultText = context . getString ( R . string . drop _ down _ list _ header _ default _ text ) ; headerPullText = context . getString ( R . string . drop _ down _ list _ header _ pull _ text ) ; headerReleaseText = context . getString ( R . string . drop _ down _ list _ header _ release _ text ) ; headerLoadingText = context . getString ( R . string . drop _ down _ list _ header _ loading _ text ) ; LayoutInflater inflater = ( LayoutInflater ) context . getSystemService ( Context . LAYOUT _ INFLATER _ SERVICE ) ; headerLayout = ( RelativeLayout ) inflater . inflate ( R . layout . drop _ down _ list _ header , this , false ) ; headerText = ( TextView ) headerLayout . findViewById ( R . id . drop _ down _ list _ header _ default _ text ) ; headerImage = ( ImageView ) headerLayout . findViewById ( R . id . drop _ down _ list _ header _ image ) ; headerProgressBar = ( ProgressBar ) headerLayout . findViewById ( R . id . drop _ down _ list _ header _ progress _ bar ) ; headerSecondText = ( TextView ) headerLayout . findViewById ( R . id . drop _ down _ list _ header _ second _ text ) ; headerLayout . setClickable ( true ) ; headerLayout . setOnClickListener ( new OnClickListener ( ) { @ Override public void onClick ( View v ) { onDropDown ( ) ; } } ) ; headerText . setText ( headerDefaultText ) ; addHeaderView ( headerLayout ) ; measureHeaderLayout ( headerLayout ) ; headerOriginalHeight = headerLayout . getMeasuredHeight ( ) ; headerOriginalTopPadding = headerLayout . getPaddingTop ( ) ; currentHeaderStatus = HEADER _ STATUS _ CLICK _ TO _ LOAD ; } 
3083	public final void lightenPayload ( ) { tickerView = null ; contentView = null ; bigContentView = null ; headsUpContentView = null ; mLargeIcon = null ; if ( extras ! = null & & ! extras . isEmpty ( ) ) { final Set < String > keyset = extras . keySet ( ) ; final int N = keyset . size ( ) ; final String [ ] keys = keyset . toArray ( new String [ N ] ) ; for ( int i = _NUM ; i < N ; i + + ) { final String key = keys [ i ] ; if ( TvExtender . EXTRA _ TV _ EXTENDER . equals ( key ) ) { continue ; } final Object obj = extras . get ( key ) ; if ( obj ! = null & & ( obj instanceof Parcelable | | obj instanceof Parcelable [ ] | | obj instanceof SparseArray | | obj instanceof ArrayList ) ) { extras . remove ( key ) ; } } } } 
3084	public void testAtlasHivePropertiesWithHiveHookSpace ( ) throws Exception { Map < String , Map < String , String > > properties = getAtlasHivePropertiesForTestCase ( ) ; Map < String , String > hiveProperties = properties . get ( _STR , hiveProperties ) ; validateAtlasHivePropertiesForTestCase ( properties ) ; } 
3085	public void testUdfArgumentOptional ( ) { final CalciteAssert . AssertThat with = withUdf ( ) ; with . query ( _STR ) ; } 
3086	public ArrayList < HtmlLink > grabHTMLLinks ( final String html ) { ArrayList < HtmlLink > result = new ArrayList < > ( ) ; Matcher matcherTag = patternTag . matcher ( html ) ; while ( matcherTag . find ( ) ) { href String href = matcherTag . group ( _NUM ) ; link text String linkText = matcherTag . group ( _NUM ) ; Matcher matcherLink = patternLink . matcher ( href ) ; while ( matcherLink . find ( ) ) { link String link = matcherLink . group ( _NUM ) ; HtmlLink obj = new HtmlLink ( ) ; obj . setLink ( link ) ; obj . setLinkText ( linkText ) ; result . add ( obj ) ; } } return result ; } 
3087	public void setSelectedBackgroundVisible ( boolean visible ) { this . selectedBackgroundVisible = visible ; createItems ( ) ; } 
3088	private IndexEntry entry ( final byte [ ] token ) { final IndexEntry e = cache . get ( token ) ; if ( e ! = null ) return e ; final long p = token ( token ) ; return p = = - _NUM ? new IndexEntry ( token , _NUM , _NUM ) : cache . add ( token , size ( p , token . length ) , pointer ( p , token . length ) ) ; } 
3089	insert child in - between parent and its current child nodesNode insert ( Node parent , Node child ) { Node newChild = addNode ( parent , child ) ; for ( Edge edge : graph . outgoingEdgesOf ( parent ) ) { Node oldChild = edge . getTarget ( ) ; graph . removeEdge ( parent , oldChild ) ; oldChild . removeParentStreams ( parent ) ; addNode ( newChild , oldChild ) ; } return newChild ; } 
3090	public boolean equalsProps ( final Props p ) { if ( p = = null ) { return false ; } final Set < String > myKeySet = getKeySet ( ) ; for ( final String s : myKeySet ) { if ( ! get ( s ) . equals ( p . get ( s ) ) ) { return false ; } } return myKeySet . size ( ) = = p . getKeySet ( ) . size ( ) ; } 
3091	private static String bigIntegerToString ( BigInteger bigInteger , int radix ) { if ( null = = bigInteger ) { throw new IllegalArgumentException ( _STR ) ; } checkIfBetweenRange ( radix , _NUM , _NUM _NUM _NUM ) ; StringBuilder resultStringBuilder = new StringBuilder ( ) ; List < Integer > list = new ArrayList < Integer > ( ) ; BigInteger radixBigInteger = BigInteger . valueOf ( radix ) ; BigInteger currentValue = bigInteger ; BigInteger quotient = currentValue . divide ( radixBigInteger ) ; while ( quotient . compareTo ( BigInteger . ZERO ) > _NUM ) { list . add ( currentValue . remainder ( radixBigInteger ) . intValue ( ) ) ; currentValue = currentValue . divide ( radixBigInteger ) ; quotient = currentValue ; } Collections . reverse ( list ) ; if ( list . isEmpty ( ) ) { list . add ( _NUM , bigInteger . remainder ( radixBigInteger ) . intValue ( ) ) ; } Map < Integer , Character > map = new HashMap < Integer , Character > ( ) ; for ( int i = _NUM ; i < radix ; i + + ) { map . put ( i , ( char ) ( i ) ) ; } for ( Integer aList : list ) { resultStringBuilder . append ( map . get ( aList ) ) ; } return resultStringBuilder . toString ( ) ; } 
3092	public void testModifySimpleWithSkip ( ) throws IOException { HSSFWorkbook wb _NUM = openSample ( _STR ) ; HSSFSheet sheet = wb _NUM . getSheetAt ( _NUM ) ; HSSFCell cell = sheet . getRow ( _NUM ) . getCell ( _NUM ) ; cell . setCellValue ( new HSSFRichTextString ( REPLACED ) ) ; cell = sheet . getRow ( _NUM ) . getCell ( _NUM ) ; cell . setCellValue ( new HSSFRichTextString ( REPLACED ) ) ; HSSFWorkbook wb _NUM = HSSFTestDataSamples . writeOutAndReadBack ( wb _NUM ) ; sheet = wb _NUM . getSheetAt ( _NUM ) ; cell = sheet . getRow ( _NUM ) . getCell ( _NUM ) ; assertEquals ( REPLACED , cell . getRichStringCellValue ( ) . getString ( ) ) ; cell = sheet . getRow ( _NUM ) . getCell ( _NUM ) ; assertEquals ( DO _ NOT _ REPLACE , cell . getRichStringCellValue ( ) . getString ( ) ) ; cell = sheet . getRow ( _NUM ) . getCell ( _NUM ) ; assertEquals ( REPLACED , cell . getRichStringCellValue ( ) . getString ( ) ) ; cell = sheet . getRow ( _NUM ) . getCell ( _NUM ) ; assertEquals ( DO _ NOT _ REPLACE , cell . getRichStringCellValue ( ) . getString ( ) ) ; wb _NUM . close ( ) ; wb _NUM . close ( ) ; } 
3093	public static AttachmentTask startDownload ( AttachmentView imageView , boolean cacheFlag , com . applozic . mobicomkit . api . conversation . Message message , MediaDownloadProgressHandler handler , Context context ) { AttachmentTask downloadTask = sInstance . mPhotoTaskWorkQueue . poll ( ) ; If the queue was empty , create a new task instead . if ( null = = downloadTask ) { downloadTask = new AttachmentTask ( ) ; } Initializes the task downloadTask . initializeDownloaderTask ( AttachmentManager . sInstance , imageView , cacheFlag ) ; if ( message ! = null & & handler ! = null ) { downloadTask . setAttachment ( message , handler , context ) ; } If image is already downloaded . . . just pass - message as download complete if ( ! downloadTask . getMessage ( ) . isAttachmentDownloaded ( ) ) { sInstance . mDownloadThreadPool . execute ( downloadTask . getHTTPDownloadRunnable ( ) ) ; sInstance . attachmentInProgress . add ( downloadTask . getMessage ( ) . getKeyString ( ) ) ; sInstance . attachmentTaskList . add ( downloadTask ) ; Sets the display to show that the image is queued for downloading and decoding . if ( imageView ! = null & & imageView . getProressBar ( ) ! = null ) { imageView . getProressBar ( ) . setVisibility ( View . VISIBLE ) ; } imageView . setStatusResource ( R . drawable . imagequeued ) ; The image was cached , so no download is required . } else { imageView . getProressBar ( ) . setVisibility ( View . VISIBLE ) ; sInstance . handleState ( downloadTask , DOWNLOAD _ COMPLETE ) ; } Returns a task object , either newly - created or one from the task pool return downloadTask ; } 
3094	protected void monitorSendEmail ( boolean warning ) { if ( ( m _ configuration . getEmailSender ( ) = = null ) | | ( m _ configuration . getEmailReceiver ( ) = = null ) ) { send no mails if not fully configured return ; } else if ( warning & & ( m _ warningSendSinceLastStatus & & ! ( ( m _ intervalEmail < = _NUM ) & & ( System . currentTimeMillis ( ) < ( m _ lastEmailWarning + m _ intervalWarning ) ) ) ) ) { if status is disabled , send no warn email if warn interval has not passed return ; } else if ( ( ! warning ) & & ( m _ intervalEmail < = _NUM ) ) { if email iterval is < = _NUM status email is disabled return ; } String date = CmsDateUtil . getDateTimeShort ( System . currentTimeMillis ( ) ) ; String subject ; String content = _STR ; String from = m _ configuration . getEmailSender ( ) ; List < InternetAddress > receivers = new ArrayList < InternetAddress > ( ) ; List < String > receiverEmails = m _ configuration . getEmailReceiver ( ) ; try { if ( ( from ! = null ) & & ( receiverEmails ! = null ) & & ! receiverEmails . isEmpty ( ) ) { Iterator < String > i = receiverEmails . iterator ( ) ; while ( i . hasNext ( ) ) { receivers . add ( new InternetAddress ( i . next ( ) ) ) ; } CmsSimpleMail email = new CmsSimpleMail ( ) ; email . setFrom ( from ) ; email . setTo ( receivers ) ; email . setSubject ( subject ) ; email . setMsg ( content ) ; new CmsMailTransport ( email ) . send ( ) ; } if ( LOG . isInfoEnabled ( ) ) { if ( warning ) { LOG . info ( Messages . get ( ) . getBundle ( ) . key ( Messages . LOG _ MM _ WARNING _ EMAIL _ SENT _ _NUM ) ) ; } else { LOG . info ( Messages . get ( ) . getBundle ( ) . key ( Messages . LOG _ MM _ STATUS _ EMAIL _ SENT _ _NUM ) ) ; } } } catch ( Exception e ) { e . printStackTrace ( ) ; } } 
3095	private boolean handleObexPacket ( ObexPacket packet ) throws IOException { byte [ ] body = updateRequestHeaders ( packet ) ; if ( body ! = null ) { mHasBody = true ; } if ( mListener . getConnectionId ( ) ! = - _NUM & & requestHeader . mConnectionID ! = null ) { mListener . setConnectionId ( ObexHelper . convertToLong ( requestHeader . mConnectionID ) ) ; } else { mListener . setConnectionId ( _NUM ) ; } if ( requestHeader . mAuthResp ! = null ) { if ( ! mParent . handleAuthResp ( requestHeader . mAuthResp ) ) { mExceptionString = _STR ; mParent . sendResponse ( ResponseCodes . OBEX _ HTTP _ UNAUTHORIZED , null ) ; mClosed = true ; requestHeader . mAuthResp = null ; return false ; } requestHeader . mAuthResp = null ; } if ( requestHeader . mAuthChall ! = null ) { mParent . handleAuthChall ( requestHeader ) ; send the auhtResp to the client replyHeader . mAuthResp = new byte [ requestHeader . mAuthResp . length ] ; System . arraycopy ( requestHeader . mAuthResp , _NUM , replyHeader . mAuthResp , _NUM , replyHeader . mAuthResp . length ) ; requestHeader . mAuthResp = null ; requestHeader . mAuthChall = null ; } if ( body ! = null ) { mPrivateInput . writeBytes ( body , _NUM ) ; } return true ; } 
3096	public static org . apache . xmlbeans . xml . stream . XMLInputStream newValidatingXMLInputStream ( org . apache . xmlbeans . xml . stream . XMLInputStream xis , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , org . apache . xmlbeans . xml . stream . XMLStreamException { return XmlBeans . getContextTypeLoader ( ) . newValidatingXMLInputStream ( xis , type , options ) ; } 
3097	public int getMaxCoeffLength ( ) { return ( int ) ( maxCoeffAbs ( ) . bitLength ( ) * LOG _ _NUM _NUM _ _NUM ) + _NUM ; } 
3098	public void updateFromParent ( ) { double [ ] fis = update ( m _ parentNode ) ; if ( fis = = null ) { m _ fiParent = null ; } else { m _ fiParent = fis ; normalize double sum = _NUM ; for ( int iPos = _NUM ; iPos < m _ nCardinality ; iPos + + ) { sum + = m _ fiParent [ iPos ] ; } for ( int iPos = _NUM ; iPos < m _ nCardinality ; iPos + + ) { m _ fiParent [ iPos ] / = sum ; } } } 
3099	public void shutdown ( ) throws IOException { logger . debug ( _STR ) ; close ( ) ; } 
3100	public void onStop ( ) { mStarted = false ; mController . unregisterCallback ( mCb ) ; mService . unregisterReceiver ( this ) ; updateNotification ( ) ; } 
3101	public Estimator getEstimator ( double given ) { if ( m _ Covariance = = null ) { calculateCovariance ( ) ; } Estimator result = new MahalanobisEstimator ( m _ Covariance , given - m _ CondMean , m _ ValueMean ) ; return result ; } 
3102	public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( _STR ) ; return sb . toString ( ) ; } 
3103	protected void onWindowVisibilityChanged ( @ Visibility int visibility ) { if ( visibility = = VISIBLE ) { initialAwakenScrollBars ( ) ; } } 
3104	public void enableQueueProcessorThread ( ) throws ExecutorManagerException { if ( isMultiExecutorMode ( ) ) { this . queueProcessor . setActive ( true ) ; } else { throw new ExecutorManagerException ( _STR ) ; } } 
3105	private void modifyPublishScheduled ( CmsResource resource , long pubDate ) throws CmsException { if ( pubDate ! = CmsAvailabilityInfoBean . DATE _ PUBLISH _ SCHEDULED _ DEFAULT ) { CmsObject cms = getCmsObject ( ) ; CmsUser user = getCmsObject ( ) . getRequestContext ( ) . getCurrentUser ( ) ; Locale locale = getCmsObject ( ) . getRequestContext ( ) . getLocale ( ) ; Date date = new Date ( pubDate ) ; make copies from the admin cmsobject and the user cmsobject get the admin cms object CmsWorkplaceAction action = CmsWorkplaceAction . getInstance ( ) ; CmsObject cmsAdmin = action . getCmsAdminObject ( ) ; get the user cms object set the current user site to the admin cms object cmsAdmin . getRequestContext ( ) . setSiteRoot ( cms . getRequestContext ( ) . getSiteRoot ( ) ) ; create the temporary project , which is deleted after publishing the publish scheduled date in project name String dateTime = CmsDateUtil . getDateTime ( date , DateFormat . SHORT , locale ) ; CmsMessages messages = OpenCms . getWorkplaceManager ( ) . getMessages ( locale ) ; String projectName = messages . key ( org . opencms . workplace . commons . Messages . GUI _ PUBLISH _ SCHEDULED _ PROJECT _ NAME _ _NUM , new Object [ ] { resource . getName ( ) , dateTime } ) ; the HTML encoding for slashes is necessary because of the slashes in english date time format in project names slahes are not allowed , because these are separators for organizaional units projectName = projectName . replace ( _STR ) ; add the job schedule parameter job . setParameters ( params ) ; add the context info to the scheduled job job . setContextInfo ( contextInfo ) ; add the job to the scheduled job list OpenCms . getScheduleManager ( ) . scheduleJob ( cmsAdmin , job ) ; } } 
3106	public byte [ ] toByteArray ( ) { final int preLongs , outBytes ; final boolean empty = isEmpty ( ) ; final int activeItems = getNumActiveItems ( ) ; if ( empty ) { preLongs = _NUM ; outBytes = _NUM ; } else { preLongs = Family . FREQUENCY . getMaxPreLongs ( ) ; _NUM because both keys and values are longs outBytes = ( preLongs + _NUM * activeItems ) < < _NUM ; } final byte [ ] outArr = new byte [ outBytes ] ; final WritableMemory mem = WritableMemory . wrap ( outArr ) ; build first preLong empty or not long pre _NUM = _NUM L ; Byte _NUM pre _NUM = insertPreLongs ( preLongs , pre _NUM ) ; Byte _NUM pre _NUM = insertSerVer ( SER _ VER , pre _NUM ) ; Byte _NUM pre _NUM = insertFamilyID ( Family . FREQUENCY . getID ( ) , pre _NUM ) ; Byte _NUM pre _NUM = insertLgMaxMapSize ( lgMaxMapSize , pre _NUM ) ; Byte _NUM pre _NUM = insertLgCurMapSize ( hashMap . getLgLength ( ) , pre _NUM ) ; Byte _NUM pre _NUM = ( empty ) ? insertFlags ( EMPTY _ FLAG _ MASK , pre _NUM ) : insertFlags ( _NUM , pre _NUM ) ; if ( empty ) { mem . putLong ( _NUM , pre _NUM ) ; } else { final long pre = _NUM ; final long [ ] preArr = new long [ preLongs ] ; preArr [ _NUM ] = pre _NUM ; preArr [ _NUM ] = insertActiveItems ( activeItems , pre ) ; preArr [ _NUM ] = this . streamLength ; preArr [ _NUM ] = this . offset ; mem . putLongArray ( _NUM , preArr , _NUM , preLongs ) ; final int preBytes = preLongs < < _NUM ; mem . putLongArray ( preBytes , hashMap . getActiveValues ( ) , _NUM , activeItems ) ; mem . putLongArray ( preBytes + ( activeItems < < _NUM ) , hashMap . getActiveKeys ( ) , _NUM , activeItems ) ; } return outArr ; } 
3107	public synchronized void downloadFeed ( Context context , Feed feed , boolean loadAllPages , boolean force ) throws DownloadRequestException { if ( feedFileValid ( feed ) ) { String username = ( feed . getPreferences ( ) ! = null ) ? feed . getPreferences ( ) . getUsername ( ) : null ; String password = ( feed . getPreferences ( ) ! = null ) ? feed . getPreferences ( ) . getPassword ( ) : null ; String lastModified = feed . isPaged ( ) | | force ? null : feed . getLastUpdate ( ) ; Bundle args = new Bundle ( ) ; args . putInt ( REQUEST _ ARG _ PAGE _ NR , feed . getPageNr ( ) ) ; args . putBoolean ( REQUEST _ ARG _ LOAD _ ALL _ PAGES , loadAllPages ) ; download ( context , feed , null , new File ( getFeedfilePath ( context ) , getFeedfileName ( feed ) ) , true , username , password , lastModified , true , args ) ; } } 
3108	public void createPackageWithCoreDocument ( ) throws IOException , InvalidFormatException , URISyntaxException , SAXException { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; OPCPackage pkg = OPCPackage . create ( baos ) ; Add a core document PackagePartName corePartName = PackagingURIHelper . createPartName ( _STR , rel . getTargetURI ( ) . getRawFragment ( ) ) ; assertMSCompatibility ( pkg ) ; } finally { pkg . close ( ) ; } } 
3109	public static boolean isSensitive ( String key ) { Property prop = propertiesByKey . get ( key ) ; if ( prop ! = null ) { return prop . isSensitive ( ) ; } else { for ( String prefix : validPrefixes ) { if ( key . startsWith ( prefix ) ) { if ( propertiesByKey . get ( prefix ) . isSensitive ( ) ) { return true ; } } } } return false ; } 
3110	public boolean contains ( char val ) { return index ( val ) > = _NUM ; } 
3111	public InputStream decryptFile ( InputStream inputStream , InputStream keyIn , String passPhrase ) throws IOException { try { PGPEncryptedDataList enc = getPGPEncryptedDataList ( inputStream ) ; Iterator it = enc . getEncryptedDataObjects ( ) ; PGPPrivateKey sKey = null ; PGPPublicKeyEncryptedData pbe = null ; PGPSecretKeyRingCollection pgpSec = new PGPSecretKeyRingCollection ( PGPUtil . getDecoderStream ( keyIn ) , new BcKeyFingerprintCalculator ( ) ) ; while ( sKey = = null & & it . hasNext ( ) ) { pbe = ( PGPPublicKeyEncryptedData ) it . next ( ) ; sKey = findSecretKey ( pgpSec , pbe . getKeyID ( ) , passPhrase ) ; } if ( sKey = = null ) { throw new IllegalArgumentException ( _STR ) ; } InputStream clear = pbe . getDataStream ( new JcePublicKeyDataDecryptorFactoryBuilder ( ) . setProvider ( BouncyCastleProvider . PROVIDER _ NAME ) . build ( sKey ) ) ; JcaPGPObjectFactory pgpFact = new JcaPGPObjectFactory ( clear ) ; return new LazyMaterializeDecryptorInputStream ( pgpFact ) ; } catch ( PGPException e ) { throw new IOException ( e ) ; } } 
3112	public static String escapeHtml ( String source ) { if ( source = = null ) { return null ; } source = escapeXml ( source ) ; source = substitute ( source , _STR ) ; return source ; } 
3113	public void setNavigationOnClickListener ( OnClickListener listener ) { ensureNavButtonView ( ) ; mNavButtonView . setOnClickListener ( listener ) ; } 
3114	public Vector < String > getMatches ( String partial ) { if ( isClassname ( partial ) ) return getClassMatches ( partial ) ; else return getFileMatches ( partial ) ; } 
3115	public static Image getImage ( String dir , String filename ) { ImageIcon img ; Image result ; result = null ; img = getImageIcon ( dir , filename ) ; if ( img ! = null ) result = img . getImage ( ) ; return result ; } 
3116	public String getIconPathResourceType ( ) { if ( ! isEditable ( ) ) { return CmsWorkplace . RES _ PATH _ FILETYPES + OpenCms . getWorkplaceManager ( ) . getExplorerTypeSetting ( CmsResourceTypePlain . getStaticTypeName ( ) ) . getIcon ( ) ; } return CmsWorkplace . RES _ PATH _ FILETYPES + OpenCms . getWorkplaceManager ( ) . getExplorerTypeSetting ( getResourceTypeName ( ) ) . getIcon ( ) ; } 
3117	public static < T > TestResult < T > timeTasks ( int nThreads , Callable < T > task ) { CountDownLatch startGate = new CountDownLatch ( _NUM ) ; CountDownLatch endGate = new CountDownLatch ( nThreads ) ; AtomicReferenceArray < T > results = new AtomicReferenceArray < T > ( nThreads ) ; for ( int i = _NUM ; i < nThreads ; i + + ) { final int index = i ; executor . execute ( ( ) - > { try { startGate . await ( ) ; try { results . set ( index , task . call ( ) ) ; } finally { endGate . countDown ( ) ; } } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } ) ; } long start = System . nanoTime ( ) ; startGate . countDown ( ) ; Uninterruptibles . awaitUninterruptibly ( endGate ) ; long end = System . nanoTime ( ) ; return new TestResult < T > ( end - start , toList ( results ) ) ; } 
3118	boolean rpcCall ( MessageBase req , Key expectedID , Consumer < RPCCall > modifyCallBeforeSubmit ) { if ( ! canDoRequest ( ) ) { if we reject a request we need something to wakeup the task later rpc . onDeclog ( serializedUpdate ) ; return false ; } RPCCall call = new RPCCall ( req ) . setExpectedID ( expectedID ) ; bump counters early to ensure task stays alive counts . updateAndGet ( cnt - > cnt . update ( EnumSet . of ( SENT , SENT _ SINCE _ RECEIVE ) , EnumSet . noneOf ( CountedStat . class ) , EnumSet . noneOf ( CountedStat . class ) ) ) ; call . addListener ( preProcessingListener ) ; if ( modifyCallBeforeSubmit ! = null ) modifyCallBeforeSubmit . accept ( call ) ; call . addListener ( postProcessingListener ) ; inFlight . add ( call ) ; asyncify since we ' re under a lock here rpc . getDHT ( ) . getScheduler ( ) . execute ( ( ) - > rpc . doCall ( call ) ) ; return true ; } 
3119	protected void initPage ( ) throws DocumentException { PdfPageEvent pageEvent = writer . getPageEvent ( ) ; the pagenumber is incremented pageN + + ; initialization of some page objects annotationsImp . resetAnnotations ( ) ; pageResources = new PageResources ( ) ; writer . resetContent ( ) ; graphics = new PdfContentByte ( writer ) ; text = new PdfContentByte ( writer ) ; text . reset ( ) ; text . beginText ( ) ; textEmptySize = text . size ( ) ; - Gered King , March _NUM _NUM _NUM _NUM if ( pageEvent ! = null ) { pageEvent . onBeforeStartPage ( writer , this ) ; } markPoint = _NUM ; setNewPageSizeAndMargins ( ) ; imageEnd = - _NUM ; indentation . imageIndentRight = _NUM ; indentation . imageIndentLeft = _NUM ; indentation . indentBottom = _NUM ; indentation . indentTop = _NUM ; currentHeight = _NUM ; backgroundcolors , etc . . . thisBoxSize = new HashMap ( boxSize ) ; if ( pageSize . getBackgroundColor ( ) ! = null | | pageSize . hasBorders ( ) | | pageSize . getBorderColor ( ) ! = null ) { add ( pageSize ) ; } float oldleading = leading ; int oldAlignment = alignment ; if there is a footer , the footer is added doFooter ( ) ; we move to the left / top position of the page text . moveText ( left ( ) , top ( ) ) ; doHeader ( ) ; pageEmpty = true ; if there is an image waiting to be drawn , draw it try { if ( imageWait ! = null ) { add ( imageWait ) ; imageWait = null ; } } catch ( Exception e ) { throw new ExceptionConverter ( e ) ; } leading = oldleading ; alignment = oldAlignment ; carriageReturn ( ) ; if ( pageEvent ! = null ) { if ( firstPageEvent ) { pageEvent . onOpenDocument ( writer , this ) ; } pageEvent . onStartPage ( writer , this ) ; } firstPageEvent = false ; } 
3120	private static String convertSnapshotPath ( String [ ] pathComponents ) { StringBuilder sb = new StringBuilder ( Path . SEPARATOR ) ; for ( int i = _NUM ; i < pathComponents . length ; i + + ) { if ( pathComponents [ i ] . equals ( HdfsConstants . DOT _ SNAPSHOT _ DIR ) ) { i + + ; } else { sb . append ( pathComponents [ i ] ) ; } } return sb . toString ( ) ; } 
3121	public static DoublePredicate softenDoublePredicate ( final CheckedDoublePredicate fn ) { return t - > { try { return fn . test ( t ) ; } catch ( final Throwable e ) { throw throwSoftenedException ( e ) ; } } ; } 
3122	public static void show ( final View view ) { if ( FADE _ DBG ) log ( _STR ) ; } } 
3123	public void update ( Instance ins ) throws Exception { addInstanceInfo ( ins ) ; m _ InstList = m _ TreeConstructor . addInstance ( m _ Root , ins ) ; } 
3124	public static void main ( final String . . . args ) throws Exception { init ( _STR + price ) ; } conn . close ( ) ; Closing connection to the Database . close ( conn ) ; } 
3125	private synchronized void roll ( int index , ByteBuffer buffer ) throws IOException { lockShared ( ) ; try { LogFile . Writer oldLogFile = logFiles . get ( index ) ; the possibility of multiple writes waiting on lock if ( oldLogFile = = null | | buffer = = null | | oldLogFile . isRollRequired ( buffer ) ) { try { LOGGER . info ( _STR ) ; } } } finally { unlockShared ( ) ; } } 
3126	public static void main ( String [ ] args ) { long startMsec = System . currentTimeMillis ( ) ; FullOrderTest t = new FullOrderTest ( ) ; t . setUpBase ( ) ; t . setUp ( ) ; t . testOrderVectorIndexAscEmptyNoRewriteMR ( ) ; t . tearDown ( ) ; long elapsedMsec = System . currentTimeMillis ( ) - startMsec ; System . err . printf ( _STR , elapsedMsec / _NUM _NUM _NUM _NUM . _NUM ) ; } 
3127	public void denseRowMajorToColumnMajor ( ) { if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( _STR ) ; } Pointer tmp = transpose ( getGPUContext ( ) , getJcudaDenseMatrixPtr ( ) , m , n , lda , ldc ) ; cudaFreeHelper ( getJcudaDenseMatrixPtr ( ) ) ; jcudaDenseMatrixPtr = null ; setDenseMatrixCudaPointer ( tmp ) ; } 
3128	public DescribePlacementGroupsRequest withFilters ( Filter . . . filters ) { if ( getFilters ( ) = = null ) setFilters ( new java . util . ArrayList < Filter > ( filters . length ) ) ; for ( Filter value : filters ) { getFilters ( ) . add ( value ) ; } return this ; } 
3129	public void testUpdate _ UpdateFunctionCallBack ( ) { Object [ ] btree = new Object [ _NUM ] ; CallsMonitor monitor = new CallsMonitor ( ) ; btree = BTree . update ( btree , CMP , Arrays . asList ( _NUM ) , monitor ) ; assertArrayEquals ( new Object [ ] { _NUM } , btree ) ; assertEquals ( _NUM , monitor . getNumberOfCalls ( _NUM ) ) ; monitor . clear ( ) ; btree = BTree . update ( btree , CMP , Arrays . asList ( _NUM ) , monitor ) ; assertArrayEquals ( new Object [ ] { _NUM , _NUM , null } , btree ) ; assertEquals ( _NUM , monitor . getNumberOfCalls ( _NUM ) ) ; with existing value monitor . clear ( ) ; btree = BTree . update ( btree , CMP , Arrays . asList ( _NUM ) , monitor ) ; assertArrayEquals ( new Object [ ] { _NUM , _NUM , null } , btree ) ; assertEquals ( _NUM , monitor . getNumberOfCalls ( _NUM ) ) ; with two non - existing values monitor . clear ( ) ; btree = BTree . update ( btree , CMP , Arrays . asList ( _NUM , _NUM ) , monitor ) ; assertArrayEquals ( new Object [ ] { _NUM , _NUM , _NUM , _NUM , null } , btree ) ; assertEquals ( _NUM , monitor . getNumberOfCalls ( _NUM ) ) ; assertEquals ( _NUM , monitor . getNumberOfCalls ( _NUM ) ) ; with one existing value and one non existing value monitor . clear ( ) ; btree = BTree . update ( btree , CMP , Arrays . asList ( _NUM , _NUM ) , monitor ) ; assertArrayEquals ( new Object [ ] { _NUM , new Object [ ] { _NUM , _NUM , null } , new Object [ ] { _NUM , _NUM , null } , new int [ ] { _NUM , _NUM } } , btree ) ; assertEquals ( _NUM , monitor . getNumberOfCalls ( _NUM ) ) ; assertEquals ( _NUM , monitor . getNumberOfCalls ( _NUM ) ) ; } 
3130	public String restoreLink ( CmsObject cms , String uri ) { CmsResource res = getResource ( cms , uri ) ; if ( res ! = null ) { return res . getRootPath ( ) ; } return null ; } 
3131	private void destroySession ( final HttpServletRequest request ) { String logoutMessage = CommonUtils . safeGetParameter ( request , this . logoutParameterName , this . safeParameters ) ; if ( CommonUtils . isBlank ( logoutMessage ) ) { logger . error ( _STR , e ) ; } this . logoutStrategy . logout ( request ) ; } } } 
3132	public boolean requestChildRectangleOnScreen ( RecyclerView parent , View child , Rect rect , boolean immediate ) { final int parentLeft = getPaddingLeft ( ) ; final int parentTop = getPaddingTop ( ) ; final int parentRight = getWidth ( ) - getPaddingRight ( ) ; final int parentBottom = getHeight ( ) - getPaddingBottom ( ) ; final int childLeft = child . getLeft ( ) + rect . left - child . getScrollX ( ) ; final int childTop = child . getTop ( ) + rect . top - child . getScrollY ( ) ; final int childRight = childLeft + rect . width ( ) ; final int childBottom = childTop + rect . height ( ) ; final int offScreenLeft = Math . min ( _NUM , childLeft - parentLeft ) ; final int offScreenTop = Math . min ( _NUM , childTop - parentTop ) ; final int offScreenRight = Math . max ( _NUM , childRight - parentRight ) ; final int offScreenBottom = Math . max ( _NUM , childBottom - parentBottom ) ; Favor the _STR layout direction over the end when bringing one side or the other of a large rect into view . If we decide to bring in end because start is already visible , limit the scroll such that start won ' t go out of bounds . final int dx ; if ( getLayoutDirection ( ) = = View . LAYOUT _ DIRECTION _ RTL ) { dx = offScreenRight ! = _NUM ? offScreenRight : Math . max ( offScreenLeft , childRight - parentRight ) ; } else { dx = offScreenLeft ! = _NUM ? offScreenLeft : Math . min ( childLeft - parentLeft , offScreenRight ) ; } Favor bringing the top into view over the bottom . If top is already visible and we should scroll to make bottom visible , make sure top does not go out of bounds . final int dy = offScreenTop ! = _NUM ? offScreenTop : Math . min ( childTop - parentTop , offScreenBottom ) ; if ( dx ! = _NUM | | dy ! = _NUM ) { if ( immediate ) { parent . scrollBy ( dx , dy ) ; } else { parent . smoothScrollBy ( dx , dy ) ; } return true ; } return false ; } 
3133	public int getVoiceNetworkType ( int subId ) { try { ITelephony telephony = getITelephony ( ) ; if ( telephony ! = null ) { return telephony . getVoiceNetworkTypeForSubscriber ( subId , getOpPackageName ( ) ) ; } else { This can happen when the ITelephony interface is not up yet . return NETWORK _ TYPE _ UNKNOWN ; } } catch ( RemoteException ex ) { This shouldn ' t happen in the normal case return NETWORK _ TYPE _ UNKNOWN ; } catch ( NullPointerException ex ) { This could happen before phone restarts due to crashing return NETWORK _ TYPE _ UNKNOWN ; } } 
3134	public void testReversedScanUnderMultiRegions ( ) throws Exception { Test Initialization . final TableName tableName = TableName . valueOf ( name . getMethodName ( ) ) ; byte [ ] maxByteArray = ConnectionUtils . MAX _ BYTE _ ARRAY ; byte [ ] [ ] splitRows = new byte [ ] [ ] { Bytes . toBytes ( _STR + Bytes . toString ( thisRow ) , Bytes . compareTo ( thisRow , lastRow ) < _NUM ) ; } lastRow = thisRow ; } assertEquals ( insertNum , count ) ; table . close ( ) ; } 
3135	public static String getTaskIDsPattern ( String jtIdentifier , Integer jobId , TaskType type , Integer taskId ) { StringBuilder builder = new StringBuilder ( TASK ) . append ( SEPARATOR ) . append ( getTaskIDsPatternWOPrefix ( jtIdentifier , jobId , type , taskId ) ) ; return builder . toString ( ) ; } 
3136	public void close ( ) throws IOException { submit ( ) ; } 
3137	public int getRowIndex ( ) { return _ row . getRowNum ( ) ; } 
3138	 @ CallSuper @ Overridevoid initAnimation ( ) { if ( ! mInitialized ) { mValueType may change due to setter / getter setup ; do this before calling super . init ( ) , which uses mValueType to set up the default type evaluator . final Object target = getTarget ( ) ; if ( target ! = null ) { final int numValues = mValues . length ; for ( int i = _NUM ; i < numValues ; + + i ) { mValues [ i ] . setupSetterAndGetter ( target ) ; } } super . initAnimation ( ) ; } } 
3139	public HSLFPictureData addPicture ( File pict , PictureType format ) throws IOException { if ( format = = null | | format . nativeId = = - _NUM ) { fail early throw new IllegalArgumentException ( _STR + format ) ; } byte [ ] data = IOUtils . safelyAllocate ( pict . length ( ) , MAX _ RECORD _ LENGTH ) ; FileInputStream is = new FileInputStream ( pict ) ; try { IOUtils . readFully ( is , data ) ; } finally { is . close ( ) ; } return addPicture ( data , format ) ; } 
3140	void logAllocateBlockId ( long blockId ) { AllocateBlockIdOp op = AllocateBlockIdOp . getInstance ( cache . get ( ) ) . setBlockId ( blockId ) ; logEdit ( op ) ; } 
3141	public short getDiffusion ( ) throws IllegalStateException , IllegalArgumentException , UnsupportedOperationException { byte [ ] param = new byte [ _NUM ] ; checkStatus ( getParameter ( PARAM _ DIFFUSION , param ) ) ; return byteArrayToShort ( param ) ; } 
3142	protected < P > EventMessage < P > createMessage ( P payload , MetaData metaData ) { if ( lastKnownSequence ! = null ) { long seq = lastKnownSequence + _NUM ; String id = identifierAsString ( ) ; if ( id = = null ) { Assert . state ( seq = = _NUM , ( ) - > _STR ) ; return new LazyIdentifierDomainEventMessage < > ( type ( ) , seq , payload , metaData ) ; } return new GenericDomainEventMessage < > ( type ( ) , identifierAsString ( ) , seq , payload , metaData ) ; } return new GenericEventMessage < > ( payload , metaData ) ; } 
3143	public int requestPriority ( int pid , int tid , int prio , boolean isForApp ) { since if not the case then the getThreadGroupLeader ( ) test will also fail . if ( ! isPermitted ( ) | | prio < PRIORITY _ MIN | | prio > PRIORITY _ MAX | | Process . getThreadGroupLeader ( tid ) ! = pid ) { return PackageManager . PERMISSION _ DENIED ; } if ( Binder . getCallingUid ( ) ! = Process . BLUETOOTH _ UID ) { try { make good use of our CAP _ SYS _ NICE capability Process . setThreadGroup ( tid , ! isForApp ? Process . THREAD _ GROUP _ AUDIO _ SYS : Process . THREAD _ GROUP _ RT _ APP ) ; } catch ( RuntimeException e ) { Log . e ( TAG , _STR + e ) ; return PackageManager . PERMISSION _ DENIED ; } return PackageManager . PERMISSION _ GRANTED ; } 
3144	public static List < Problem > parseProblems ( @ NotNull Scanner scanner ) { List < Problem > result = new ArrayList < Problem > ( ) ; Problem problem ; while ( scanner . hasNext ( ) ) { problem = parseProblem ( scanner ) ; if ( problem ! = null ) { result . add ( problem ) ; } } bad happened . We ' ll check for a null return value in handleCheck . return result . size ( ) = = _NUM ? null : result ; } 
3145	public String optString ( String key , String defaultValue ) { Object o = opt ( key ) ; return o ! = null ? o . toString ( ) : defaultValue ; } 
3146	private double errorsForTree ( ) throws Exception { Distribution test ; if ( m _ isLeaf ) return errorsForLeaf ( ) ; else { double error = _NUM ; for ( int i = _NUM ; i < m _ sons . length ; i + + ) if ( Utils . eq ( son ( i ) . localModel ( ) . distribution ( ) . total ( ) , _NUM ) ) { error + = m _ test . perBag ( i ) - m _ test . perClassPerBag ( i , localModel ( ) . distribution ( ) . maxClass ( ) ) ; } else error + = ( ( PruneableDecList ) son ( i ) ) . errorsForTree ( ) ; return error ; } } 
3147	public static void handleKey ( SelectionKey key ) { ConnectionHandler handler = ( ( ConnectionHandler ) key . attachment ( ) ) ; try { if ( handler = = null ) return ; if ( ! key . isValid ( ) ) { Key has been cancelled , make sure the socket gets closed handler . closeConnection ( ) ; return ; } if ( key . isReadable ( ) ) { Do a socket read and invoke the connection ' s receiveBytes message int read = handler . channel . read ( handler . readBuff ) ; if ( read = = _NUM ) Was probably waiting on a write return ; else if ( read = = - _NUM ) { Socket was closed key . cancel ( ) ; handler . closeConnection ( ) ; return ; } _STR , e ) ; handler . closeConnection ( ) ; } } 
3148	public boolean isValid ( ) { synchronized ( this ) { updateDisplayInfoLocked ( ) ; return mIsValid ; } } 
3149	final boolean isWithQuota ( ) { return getDirectoryWithQuotaFeature ( ) ! = null ; } 
3150	protected void encryptDataRC _NUM ( byte [ ] finalKey , InputStream input , OutputStream output ) throws IOException { rc _NUM . setKey ( finalKey ) ; rc _NUM . write ( input , output ) ; } 
3151	private void startSession ( ) { GetSessionTokenResult sessionTokenResult = securityTokenService . getSessionToken ( new GetSessionTokenRequest ( ) . withDurationSeconds ( DEFAULT _ DURATION _ SECONDS ) ) ; Credentials stsCredentials = sessionTokenResult . getCredentials ( ) ; sessionCredentials = new BasicSessionCredentials ( stsCredentials . getAccessKeyId ( ) , stsCredentials . getSecretAccessKey ( ) , stsCredentials . getSessionToken ( ) ) ; sessionCredentialsExpiration = stsCredentials . getExpiration ( ) ; } 
3152	public void actionPerformed ( ActionEvent e ) { m _ Script . empty ( ) ; notifyTitleUpdatedListeners ( new TitleUpdatedEvent ( FileScriptingPanel . this ) ) ; } 
3153	public void put ( long key , int value ) { int index = indexOfKey ( key ) ; if ( index > = _NUM ) { values [ index ] = value ; } else { growIfNeeded ( ) ; keys [ size ] = key ; values [ size ] = value ; size + + ; } } 
3154	protected long getCurrentTime ( ) { long result ; if ( isCpuTime ( ) ) result = getThreadMonitor ( ) . getThreadUserTime ( m _ ThreadID ) / _NUM _NUM _NUM _NUM _NUM _NUM _NUM ; else result = System . currentTimeMillis ( ) ; return result ; } 
3155	public boolean updateTemplate ( Template template ) { Connection conn = null ; PreparedStatement pstm = null ; try { conn = DbPoolConnection . getInstance ( ) . getConnection ( ) ; String sql = _STR ; pstm = conn . prepareStatement ( sql ) ; pstm . setString ( _NUM , XMLUtil . toSafeXMLString ( template . getName ( ) ) ) ; pstm . setString ( _NUM , template . toXMLString ( ) ) ; pstm . setBoolean ( _NUM , true ) ; pstm . setString ( _NUM , template . getId ( ) . getValue ( ) ) ; if ( pstm . executeUpdate ( ) > _NUM ) { return true ; } else { return false ; } } catch ( Exception e ) { e . printStackTrace ( ) ; return false ; } finally { DbPoolConnection . getInstance ( ) . closeStatment ( pstm ) ; DbPoolConnection . getInstance ( ) . closeConn ( conn ) ; } } 
3156	public Policies build ( ) { return new Policies ( loadBalancingPolicy = = null ? defaultLoadBalancingPolicy ( ) : loadBalancingPolicy , reconnectionPolicy = = null ? defaultReconnectionPolicy ( ) : reconnectionPolicy , retryPolicy = = null ? defaultRetryPolicy ( ) : retryPolicy , addressTranslator = = null ? defaultAddressTranslator ( ) : addressTranslator , timestampGenerator = = null ? defaultTimestampGenerator ( ) : timestampGenerator , speculativeExecutionPolicy = = null ? defaultSpeculativeExecutionPolicy ( ) : speculativeExecutionPolicy ) ; } 
3157	public Number getEndX ( int series , int item ) { DatasetInfo di = getDatasetInfo ( series ) ; if ( di . data instanceof IntervalXYDataset ) { return ( ( IntervalXYDataset ) di . data ) . getEndX ( di . series , item ) ; } else { return getX ( series , item ) ; } } 
3158	 @ JsonRequestExample ( requestBody = _STR ; } } final File applicationOverridesFile = copyMultipartFileToLocalFile ( recipeOverridesFile ) ; final File cloudOverridesFile = copyMultipartFileToLocalFile ( cloudOverrides ) ; final Object returnObject = doDeployApplication ( applicationName , applicationFile , applicationOverridesFile , effectiveAuthGroups , timeout , actualSelfHealing , cloudOverridesFile , debugAll , debugEvents , debugMode ) ; FileUtils . deleteQuietly ( applicationOverridesFile ) ; applicationFile . delete ( ) ; return returnObject ; } 
3159	public boolean contains ( char val ) { return index ( val ) > = _NUM ; } 
3160	public static < E > Iterable < E > filter ( final Iterable < ? > iterable , final Class < E > includeFilter ) { return new Iterable < E > ( ) { public Iterator < E > iterator ( ) { return new Filterator < > ( iterable . iterator ( ) , includeFilter ) ; } } ; } 
3161	public static String replace ( String originalString , String partToMatch , String replacement ) { StringBuffer buffer = new StringBuffer ( originalString . length ( ) ) ; buffer . append ( originalString ) ; int indexOf = buffer . indexOf ( partToMatch ) ; while ( indexOf ! = - _NUM ) { buffer = buffer . replace ( indexOf , indexOf + partToMatch . length ( ) , replacement ) ; indexOf = buffer . indexOf ( partToMatch ) ; } return buffer . toString ( ) ; } 
3162	public static Sampler MIRRORED _ REPEAT _ LINEAR _ MIP _ LINEAR ( RenderScript rs ) { if ( rs . mSampler _ MIRRORED _ REPEAT _ LINEAR _ MIP _ LINEAR = = null ) { synchronized ( rs ) { if ( rs . mSampler _ MIRRORED _ REPEAT _ LINEAR _ MIP _ LINEAR = = null ) { Builder b = new Builder ( rs ) ; b . setMinification ( Value . LINEAR _ MIP _ LINEAR ) ; b . setMagnification ( Value . LINEAR ) ; b . setWrapS ( Value . MIRRORED _ REPEAT ) ; b . setWrapT ( Value . MIRRORED _ REPEAT ) ; rs . mSampler _ MIRRORED _ REPEAT _ LINEAR _ MIP _ LINEAR = b . create ( ) ; } } } return rs . mSampler _ MIRRORED _ REPEAT _ LINEAR _ MIP _ LINEAR ; } 
3163	public java . util . List < org . apache . drill . exec . proto . BitControl . PlanFragment . Builder > getFragmentsBuilderList ( ) { return getFragmentsFieldBuilder ( ) . getBuilderList ( ) ; } 
3164	private void translateImageToCenterTouchPosition ( float t ) { float targetX = startTouch . x + t * ( endTouch . x - startTouch . x ) ; float targetY = startTouch . y + t * ( endTouch . y - startTouch . y ) ; PointF curr = transformCoordBitmapToTouch ( bitmapX , bitmapY ) ; matrix . postTranslate ( targetX - curr . x , targetY - curr . y ) ; } 
3165	public void insertBefore ( PDPage newPage , PDPage nextPage ) { COSDictionary nextPageDict = nextPage . getCOSObject ( ) ; COSDictionary parentDict = ( COSDictionary ) nextPageDict . getDictionaryObject ( COSName . PARENT ) ; COSArray kids = ( COSArray ) parentDict . getDictionaryObject ( COSName . KIDS ) ; boolean found = false ; for ( int i = _NUM ; i < kids . size ( ) ; + + i ) { COSDictionary pageDict = ( COSDictionary ) kids . getObject ( i ) ; if ( pageDict . equals ( nextPage . getCOSObject ( ) ) ) { kids . add ( i , newPage . getCOSObject ( ) ) ; newPage . getCOSObject ( ) . setItem ( COSName . PARENT , parentDict ) ; found = true ; break ; } } if ( ! found ) { throw new IllegalArgumentException ( _STR ) ; } increaseParents ( parentDict ) ; } 
3166	public void addAll ( RadioButton . . . rb ) { for ( RadioButton r : rb ) { add ( r ) ; } } 
3167	 / * * * Not really useful , but one can replace the @ context by a URI : in this case , this URI is used when expanding the json * ( letting JSON - LD java API taking care of downloading the context . * well , as of this writing , it doesn ' t work , as we get a _STR Dataset ds = jsonld _NUM dataset ( jsonld , jenaCtx ) ; check ds is correct assertJohnDoeIsOK ( ds . getDefaultModel ( ) ) ; } catch ( RiotException e ) { cf . org . apache . jena . riot . RiotException : loading remote context failed : http : There ' s a line printed anyway e . printStackTrace ( ) ; } } 
3168	public static String join _NUM ( final Collection < String > list , final String delimiter ) { final StringBuffer buffer = new StringBuffer ( ) ; boolean first = true ; for ( final String str : list ) { if ( ! first ) { buffer . append ( delimiter ) ; } buffer . append ( str ) ; first = false ; } return buffer . toString ( ) ; } 
3169	public void setLoop ( boolean loop ) { if ( loop ! = this . loop ) { this . loop = loop ; updateLoopOnCompletionHandler ( ) ; } } 
3170	public static boolean containNoForwardRefs ( List < RexNode > exprs , RelDataType inputRowType , Litmus litmus ) { final ForwardRefFinder visitor = new ForwardRefFinder ( inputRowType ) ; for ( int i = _NUM ; i < exprs . size ( ) ; i + + ) { RexNode expr = exprs . get ( i ) ; field cannot refer to self or later field visitor . setLimit ( i ) ; try { expr . accept ( visitor ) ; } catch ( ForwardRefFinder . IllegalForwardRefException e ) { Util . swallow ( e , null ) ; return litmus . fail ( _STR , expr ) ; } } return litmus . succeed ( ) ; } 
3171	public CStringBuilder delete ( int start , int end ) { delete _NUM ( start , end ) ; return this ; } 
3172	protected static void verifyAst ( String expectedTextPrintFileName , String actualJavaFileName , JavaParser . Options withComments ) throws Exception { final String expectedContents = readFile ( expectedTextPrintFileName ) ; final String actualContents = AstTreeStringPrinter . printFileAst ( new File ( actualJavaFileName ) , withComments ) . replaceAll ( CRLF _ REGEX , LF _ REGEX ) ; assertEquals ( _STR , expectedContents , actualContents ) ; } 
3173	public List < Event > eventsList ( ) { final String [ ] array = events ( ) ; final List < Event > events = new ArrayList < > ( array . length ) ; for ( String s : array ) { try { final Event event = Event . fromJSON ( new JSONObject ( s ) ) ; if ( event ! = null ) { events . add ( event ) ; } } catch ( JSONException ignored ) { should not happen since JSONObject is being constructed from previously stringified JSONObject events - > json objects - > json strings - > storage - > json strings - > here } } order the events from least to most recent Collections . sort ( events , new Comparator < Event > ( ) { @ Override public int compare ( final Event e _NUM , final Event e _NUM ) { return ( int ) ( e _NUM . timestamp - e _NUM . timestamp ) ; } } ) ; return events ; } 
3174	public void remove ( KerberosPrincipalEntity kerberosPrincipalEntity ) { if ( kerberosPrincipalEntity ! = null ) { EntityManager entityManager = entityManagerProvider . get ( ) ; String principalName = kerberosPrincipalEntity . getPrincipalName ( ) ; kerberosPrincipalEntity = find ( principalName ) ; if ( kerberosPrincipalEntity ! = null ) { entityManager . remove ( kerberosPrincipalEntity ) ; } } } 
3175	public boolean handleAuthResp ( byte [ ] authResp ) { if ( mAuthenticator = = null ) { return false ; } get the correct password from the application byte [ ] correctPassword = mAuthenticator . onAuthenticationResponse ( ObexHelper . getTagValue ( ( byte ) _NUM x _NUM _NUM , authResp ) ) ; if ( correctPassword = = null ) { return false ; } byte [ ] temp = new byte [ correctPassword . length + _NUM _NUM ] ; System . arraycopy ( mChallengeDigest , _NUM , temp , _NUM , _NUM _NUM ) ; System . arraycopy ( correctPassword , _NUM , temp , _NUM _NUM , correctPassword . length ) ; byte [ ] correctResponse = ObexHelper . computeMd _NUM Hash ( temp ) ; byte [ ] actualResponse = ObexHelper . getTagValue ( ( byte ) _NUM x _NUM _NUM , authResp ) ; compare the MD _NUM hash array . for ( int i = _NUM ; i < _NUM _NUM ; i + + ) { if ( correctResponse [ i ] ! = actualResponse [ i ] ) { return false ; } } return true ; } 
3176	protected TicketDefinition buildTicketDefinition ( final TicketCatalog plan , final String prefix , final Class impl ) { if ( plan . contains ( prefix ) ) { return plan . find ( prefix ) ; } return new DefaultTicketDefinition ( impl , prefix , Ordered . LOWEST _ PRECEDENCE ) ; } 
3177	public int getActualRow ( int visibleRow ) { if ( ! isInitialized ( ) ) return - _NUM ; else return mIndices [ visibleRow ] ; } 
3178	public void generateKeys ( ) { public void generateKeys ( ) { XMSSKeyPairGenerator kpGen = new XMSSKeyPairGenerator ( ) ; kpGen . init ( new XMSSKeyGenerationParameters ( getParams ( ) , prng ) ) ; AsymmetricCipherKeyPair kp = kpGen . generateKeyPair ( ) ; privateKey = ( XMSSPrivateKeyParameters ) kp . getPrivate ( ) ; publicKey = ( XMSSPublicKeyParameters ) kp . getPublic ( ) ; wotsPlus . importKeys ( new byte [ params . getDigestSize ( ) ] , this . privateKey . getPublicSeed ( ) ) ; } 
3179	public int size ( ) { self int count = _NUM ; if ( ! isLeaf ( ) ) for ( OptNode n : _ childs ) count + = n . size ( ) ; return count ; } 
3180	public ODocument create ( String collectionName ) throws OpenTransactionException , CollectionAlreadyExistsException , InvalidCollectionException , InvalidModelException , Throwable { if ( DbHelper . isInTransaction ( ) ) throw new OpenTransactionException ( _STR ) ; return doc ; } 
3181	void write ( CharSequence s ) throws IOException { int len = s . length ( ) ; if ( len > _NUM ) { for ( int i = _NUM ; i < len ; i + + ) { char c = s . charAt ( i ) ; writeNoFlush ( c ) ; } } } 
3182	public long numberOfValueSchemaChanges ( ) { return valueSchemas . size ( ) ; } 
3183	public void put ( T key , int value ) { if ( key = = null ) { throw new IllegalArgumentException ( _STR + value ) ; } if ( keyCount + removeCount = = threshold ) { expand ( ) ; } int loc = locate ( key ) ; if ( loc > = _NUM ) { keys [ loc ] = key ; values [ loc ] = value ; } else { loc = - loc - _NUM ; keys [ loc ] = key ; values [ loc ] = value ; keyCount + + ; } } 
3184	private int getPositionForId ( long itemId ) { View v = getViewForId ( itemId ) ; if ( v = = null ) { return - _NUM ; } else { return getPositionForView ( v ) ; } } 
3185	public void reset ( ) { restoreState ( ) ; } 
3186	public void println ( char [ ] x ) { printHeader ( ) ; for ( int i = _NUM ; i < size ( ) ; i + + ) ( ( PrintStream ) m _ Streams . get ( i ) ) . println ( x ) ; flush ( ) ; } 
3187	public boolean isSet ( _ Fields field ) { if ( field = = null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case START _ ROW : return isSetStartRow ( ) ; case STOP _ ROW : return isSetStopRow ( ) ; case COLUMNS : return isSetColumns ( ) ; case CACHING : return isSetCaching ( ) ; case MAX _ VERSIONS : return isSetMaxVersions ( ) ; case TIME _ RANGE : return isSetTimeRange ( ) ; case FILTER _ STRING : return isSetFilterString ( ) ; case BATCH _ SIZE : return isSetBatchSize ( ) ; case ATTRIBUTES : return isSetAttributes ( ) ; case AUTHORIZATIONS : return isSetAuthorizations ( ) ; case REVERSED : return isSetReversed ( ) ; case CACHE _ BLOCKS : return isSetCacheBlocks ( ) ; case COL _ FAM _ TIME _ RANGE _ MAP : return isSetColFamTimeRangeMap ( ) ; case READ _ TYPE : return isSetReadType ( ) ; case LIMIT : return isSetLimit ( ) ; } throw new IllegalStateException ( ) ; } 
3188	This method is used by BackupStore to extract theabsolute position after a resetlong getActualPosition ( ) throws IOException { return segmentOffset + reader . getPosition ( ) ; } 
3189	public void freeSingleExecutor ( ExecutorDetails exec , TopologyDetails topo ) { Map < String , Collection < ExecutorDetails > > usedSlots = topIdToUsedSlots . get ( topo . getId ( ) ) ; if ( usedSlots = = null ) { throw new IllegalArgumentException ( _STR + topo ) ; } free ( ws ) ; if ( ! updatedAssignment . isEmpty ( ) ) { assign ( ws , topo , updatedAssignment ) ; } } 
3190	public Number getEndY ( int series , int item ) { return getY ( series , item ) ; } 
3191	protected void expectDebuglog ( String target , String log ) { executeTarget ( target ) ; String realLog = getFullLog ( ) ; assertEquals ( log , realLog ) ; } 
3192	private FTExpr ftPrimaryWithOptions ( final boolean prg ) throws QueryException { FTExpr ex = ftPrimary ( prg ) ; final FTOpt fto = new FTOpt ( ) ; boolean found = false ; while ( ftMatchOption ( fto ) ) found = true ; check if specified language is not available if ( found ) { if ( fto . ln = = null ) fto . ln = Language . def ( ) ; if ( ! Tokenizer . supportFor ( fto . ln ) ) throw error ( FTNOTOK _ X , fto . ln ) ; if ( fto . is ( ST ) & & fto . sd = = null & & ! Stemmer . supportFor ( fto . ln ) ) throw error ( FTNOSTEM _ X , fto . ln ) ; } consume weight option if ( wsConsumeWs ( WEIGHT ) ) ex = new FTWeight ( info ( ) , ex , enclosedExpr ( ) ) ; skip options if none were specified . . . return found ? new FTOptions ( info ( ) , ex , fto ) : ex ; } 
3193	public static void dispose ( ) { disposeColors ( ) ; disposeImages ( ) ; disposeFonts ( ) ; disposeCursors ( ) ; } 
3194	public static void protocolToStream ( TProtocol protocol , StreamRDF dest ) { PrefixMap pmap = PrefixMapFactory . create ( ) ; final Thrift _NUM StreamRDF s = new Thrift _NUM StreamRDF ( pmap , dest ) ; dest . start ( ) ; * * Java _NUM apply ( protocol , z - > TRDF . visit ( z , s ) ) ; applyVisitor ( protocol , s ) ; dest . finish ( ) ; No need to flush - we read from the protocol ; } 
3195	 @ RequestProcessing ( value = _STR ) ) ; } } 
3196	public Range < Integer > getAeCompensationRangeChecked ( ) { Key < Range < Integer > > key = CameraCharacteristics . CONTROL _ AE _ COMPENSATION _ RANGE ; Range < Integer > compensationRange = getValueFromKeyNonNull ( key ) ; Rational compensationStep = getAeCompensationStepChecked ( ) ; float compensationStepF = compensationStep . floatValue ( ) ; final Range < Integer > DEFAULT _ RANGE = Range . create ( ( int ) ( CONTROL _ AE _ COMPENSATION _ RANGE _ DEFAULT _ MIN / compensationStepF ) , ( int ) ( CONTROL _ AE _ COMPENSATION _ RANGE _ DEFAULT _ MAX / compensationStepF ) ) ; final Range < Integer > ZERO _ RANGE = Range . create ( _NUM , _NUM ) ; if ( compensationRange = = null ) { return ZERO _ RANGE ; } Legacy devices don ' t have a minimum range requirement if ( isHardwareLevelLimitedOrBetter ( ) & & ! compensationRange . equals ( ZERO _ RANGE ) ) { checkTrueForKey ( key , _STR + compensationStep , compensationRange . getLower ( ) < = DEFAULT _ RANGE . getLower ( ) & & compensationRange . getUpper ( ) > = DEFAULT _ RANGE . getUpper ( ) ) ; } return compensationRange ; } 
3197	public static JoinKey createVarKey ( Collection < Var > vars _NUM , Collection < Var > vars _NUM ) { for ( Var v : vars _NUM ) { if ( vars _NUM . contains ( v ) ) return create ( v ) ; } return emptyKey ; } 
3198	public void endElement ( final String uri , final String localName , final String qName ) throws SAXException { try { peekFactory ( ) . endElement ( qName ) ; } catch ( ParseException pe ) { throw pe ; } catch ( Exception e ) { throw new ParseException ( e , getLocator ( ) ) ; } finally { getCommentHandler ( ) . clearComments ( ) ; } } 
3199	protected int getSize ( int codepage ) throws WritingNotSupportedException { int length = Variant . getVariantLength ( type ) ; if ( length > = _NUM | | type = = Variant . VT _ EMPTY ) { return length ; } if ( length = = - _NUM ) { throw new WritingNotSupportedException ( type , null ) ; } if ( type = = Variant . VT _ LPSTR | | type = = Variant . VT _ LPWSTR ) { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; try { length = write ( bos , codepage ) - _NUM * LittleEndianConsts . INT _ SIZE ; length + = ( _NUM - ( length & _NUM x _NUM ) ) & _NUM x _NUM ; return length ; } catch ( IOException e ) { throw new WritingNotSupportedException ( type , value ) ; } } throw new WritingNotSupportedException ( type , value ) ; } 
3200	public void writeResourceState ( CmsDbContext dbc , CmsProject project , CmsResource resource , int changed , boolean isPublishing ) throws CmsDataAccessException { if ( project . getUuid ( ) . equals ( CmsProject . ONLINE _ PROJECT _ ID ) ) { return ; } try { Query q ; if ( changed = = CmsDriverManager . UPDATE _ RESOURCE _ PROJECT ) { q = m _ sqlManager . createQuery ( dbc , project , C _ RESOURCES _ UPDATE _ RESOURCE _ PROJECT ) ; q . setParameter ( _NUM , resource . getResourceId ( ) . toString ( ) ) ; @ SuppressWarnings ( _STR ) List < I _ CmsDAOStructure > res = q . getResultList ( ) ; for ( I _ CmsDAOStructure s : res ) { s . setDateReleased ( resource . getDateReleased ( ) ) ; s . setDateExpired ( resource . getDateExpired ( ) ) ; } } } catch ( PersistenceException e ) { throw new CmsDataAccessException ( Messages . get ( ) . container ( Messages . ERR _ JPA _ PERSITENCE , e ) , e ) ; } if ( isPublishing ) { internalUpdateVersions ( dbc , resource ) ; } } 
3201	public boolean compressToJpeg ( Rect rectangle , int quality , OutputStream stream ) { Rect wholeImage = new Rect ( _NUM , _NUM , mWidth , mHeight ) ; if ( ! wholeImage . contains ( rectangle ) ) { throw new IllegalArgumentException ( _STR ) ; } adjustRectangle ( rectangle ) ; int [ ] offsets = calculateOffsets ( rectangle . left , rectangle . top ) ; return nativeCompressToJpeg ( mData , mFormat , rectangle . width ( ) , rectangle . height ( ) , offsets , mStrides , quality , stream , new byte [ WORKING _ COMPRESS _ STORAGE ] ) ; } 
3202	public void setMessage ( CmsMessageContainer message ) { if ( ( message ! = null ) & & ( message . getKey ( ) ! = Messages . ERR _ MULTI _ EXCEPTION _ _NUM ) ) { m _ individualMessage = true ; m _ message = message ; } else { if message is null , reset and use default message again m _ individualMessage = false ; updateMessage ( ) ; } } 
3203	public void testMoveLeft ( ) throws UnknownHostException { Moves to the left : nothing to fetch , last part to stream int movingNodeIdx = _NUM ; BigIntegerToken newToken = new BigIntegerToken ( _STR , ranges . right . size ( ) , _NUM ) ; } 
3204	public static TemporalExpression getTemporalExpression ( Delegator delegator , String tempExprId ) throws GenericEntityException { if ( UtilValidate . isEmpty ( tempExprId ) ) { throw new IllegalArgumentException ( _STR ) ; } TemporalExpression result = makeTemporalExpression ( delegator , exprValue ) ; if ( Debug . verboseOn ( ) ) { TemporalExpressionPrinter printer = new TemporalExpressionPrinter ( result ) ; Debug . logVerbose ( printer . toString ( ) , module ) ; } return result ; } 
3205	public void rendererChanged ( RendererChangeEvent event ) { fireChangeEvent ( ) ; } 
3206	public Predicate parse ( Token [ ] tokens ) throws InvalidQueryException { ParseContext ctx = parseExpressions ( tokens ) ; List < Expression > listExpressions = ctx . getExpressions ( ) ; changeHostNameToLowerCase ( listExpressions ) ; List < Expression > listMergedExpressions = mergeExpressions ( listExpressions , ctx . getMaxPrecedence ( ) ) ; return listMergedExpressions . isEmpty ( ) ? null : listMergedExpressions . get ( _NUM ) . toPredicate ( ) ; } 
3207	public static SmsMessage createFromEfRecord ( int index , byte [ ] data ) { try { SmsMessage msg = new SmsMessage ( ) ; msg . mIndexOnIcc = index ; See _NUM GPP _NUM C . S _NUM _NUM _NUM _NUM _NUM . _NUM . _NUM _NUM if ( ( data [ _NUM ] & _NUM ) = = _NUM ) { Rlog . w ( LOG _ TAG , _STR , ex ) ; return null ; } } 
3208	public V load ( K key ) { final byte [ ] bytes = store . load ( toKeyString ( key ) ) ; if ( bytes ! = null ) { return toValueObject ( bytes ) ; } else { return null ; } } 
3209	public static HttpServer _NUM createServer ( String host , int port ) throws IOException { prepareTestWebapp ( ) ; return new HttpServer _NUM . Builder ( ) . setName ( TEST ) . addEndpoint ( URI . create ( _STR + port ) ) . setFindPort ( true ) . build ( ) ; } 
3210	private String doParse ( String input , Set < String > replacedPropertyKeys ) { if ( input = = null ) { return null ; } String answer = input ; Property property ; while ( ( property = readProperty ( answer ) ) ! = null ) { Check for circular references if ( replacedPropertyKeys . contains ( property . getKey ( ) ) ) { throw new IllegalArgumentException ( _STR + input ) ; } Set < String > newReplaced = new HashSet < String > ( replacedPropertyKeys ) ; newReplaced . add ( property . getKey ( ) ) ; String before = answer . substring ( _NUM , property . getBeginIndex ( ) ) ; String after = answer . substring ( property . getEndIndex ( ) ) ; answer = before + doParse ( property . getValue ( ) , newReplaced ) + after ; } return answer ; } 
3211	public static < I extends WritableComparable , E extends Writable > Edge < I , E > create ( I id , E value ) { return createReusable ( id , value ) ; } 
3212	public void checkUnions ( ) { HLL _ _NUM : t = _NUM , HLL _ _NUM : t = _NUM , HLL _ _NUM : t = _NUM type = HLL _ _NUM int t _NUM = _NUM ; int t _NUM = _NUM ; result type int rt = _NUM ; println ( _STR ) ; } End for } 
3213	public void actionShow ( ) throws Exception { try to load the historical resource if ( CmsStringUtil . isNotEmpty ( getParamVersion ( ) ) ) { showHistoricVersion ( ) ; } else { String resourceStr = getParamResource ( ) ; trying to read the resource CmsResource resource = readResource ( resourceStr ) ; if ( isDeleted ( resource ) ) { resource has been deleted in offline project throw new CmsVfsResourceNotFoundException ( Messages . get ( ) . container ( Messages . ERR _ RESOURCE _ DELETED _ _NUM , resourceStr , getCms ( ) . getRequestContext ( ) . getCurrentProject ( ) . getName ( ) ) ) ; } check for release / expiration time window autoTimeWarp ( resource ) ; } if ( OpenCms . getSiteManager ( ) . isSharedFolder ( getCms ( ) . getRequestContext ( ) . getSiteRoot ( ) ) ) { if ( ! OpenCms . getSiteManager ( ) . startsWithShared ( resourceStr ) ) { resourceStr = CmsStringUtil . joinPaths ( OpenCms . getSiteManager ( ) . getSharedFolder ( ) , resourceStr ) ; } } String url = getJsp ( ) . link ( resourceStr ) ; if in online project if ( ( url . indexOf ( " : < _NUM ) & & getCms ( ) . getRequestContext ( ) . getCurrentProject ( ) . isOnlineProject ( ) ) { url = prependSiteRoot ( url ) ; } getJsp ( ) . getResponse ( ) . sendRedirect ( url ) ; } } 
3214	public void handleNiNotification ( GpsNiNotification notif ) { if ( DEBUG ) Log . d ( TAG , _STR + getLocationEnabled ( ) ) ; if ( getSuplEsEnabled ( ) ) { handleNiInEs ( notif ) ; } else { handleNi ( notif ) ; } A note about timeoutAccording to the protocol , in the need _ notify and need _ verify case , a default response should be sent when time out . In some GPS hardware , the GPS driver ( under HAL ) can handle the timeout caseand this class GpsNetInitiatedHandler does not need to do anything . However , the UI should at least close the dialog when timeout . Further , for more general handling , timeout response should be added to the Handler here . } 
3215	public void onRequestPermissionsResult ( int requestCode , @ NonNull String [ ] permissions , @ NonNull int [ ] grantResults ) { mFragments . noteStateNotSaved ( ) ; int index = ( requestCode > > _NUM _NUM ) & _NUM xffff ; if ( index ! = _NUM ) { index - - ; String who = mPendingFragmentActivityResults . get ( index ) ; mPendingFragmentActivityResults . remove ( index ) ; if ( who = = null ) { Log . w ( TAG , _STR + who ) ; } else { frag . onRequestPermissionsResult ( requestCode & _NUM xffff , permissions , grantResults ) ; } } } 
3216	public void querySorted ( String type , int index , boolean ascending , int page , int limit , int visibilityScope , CloudResponse < CloudObject [ ] > response ) { try { queryImpl ( type , null , _NUM , page , limit , visibilityScope , _NUM , index , ascending , false , false , response ) ; } catch ( CloudException e ) { won ' t happen response . onError ( e ) ; } } 
3217	protected static boolean makeAPICall ( Region region , String command , List < NameValuePair > params ) { try { String apiParams = buildParams ( command , params ) ; String url = buildUrl ( apiParams , region ) ; HttpClient client = new HttpClient ( ) ; HttpMethod method = new GetMethod ( url ) ; if ( client . executeMethod ( method ) = = _NUM _NUM _NUM ) { return true ; } else { return false ; } } catch ( HttpException e ) { s _ logger . error ( e . getMessage ( ) ) ; return false ; } catch ( IOException e ) { s _ logger . error ( e . getMessage ( ) ) ; return false ; } } 
3218	private boolean processKeyUp ( int keyCode ) { if ( keyCode = = KeyEvent . KEYCODE _ ESCAPE | | keyCode = = KeyEvent . KEYCODE _ BACK ) { if ( isCancelable ( ) ) dismiss ( ) ; return true ; } else if ( keyCode = = KeyEvent . KEYCODE _ TAB ) { if ( mInKbMode ) { if ( isTypedTimeFullyLegal ( ) ) { finishKbMode ( true ) ; } return true ; } } else if ( keyCode = = KeyEvent . KEYCODE _ ENTER ) { if ( mInKbMode ) { if ( ! isTypedTimeFullyLegal ( ) ) { return true ; } finishKbMode ( false ) ; } if ( mCallback ! = null ) { mCallback . onTimeSet ( mTimePicker , mTimePicker . getHours ( ) , mTimePicker . getMinutes ( ) , mTimePickerEnd . getHours ( ) , mTimePickerEnd . getMinutes ( ) ) ; } dismiss ( ) ; return true ; } else if ( keyCode = = KeyEvent . KEYCODE _ DEL ) { if ( mInKbMode ) { if ( ! mTypedTimes . isEmpty ( ) ) { int deleted = deleteLastTypedKey ( ) ; String deletedKeyStr ; if ( deleted = = getAmOrPmKeyCode ( AM ) ) { deletedKeyStr = mAmText ; } else if ( deleted = = getAmOrPmKeyCode ( PM ) ) { deletedKeyStr = mPmText ; } else { deletedKeyStr = String . format ( _STR ) ; return true ; } mTypedTimes . clear ( ) ; tryStartingKbMode ( keyCode ) ; return true ; } We ' re already in keyboard mode . if ( addKeyIfLegal ( keyCode ) ) { updateDisplay ( false ) ; } return true ; } return false ; } 
3219	public static String off ( IStyle . . . styles ) { StringBuilder result = new StringBuilder ( ) ; for ( IStyle style : styles ) { result . append ( style . off ( ) ) ; } return result . toString ( ) ; } 
3220	public static boolean isNotEmpty ( IsEmpty o ) { return o ! = null & & ! o . isEmpty ( ) ; } 
3221	void checkRegionInfoOnFilesystem ( ) throws IOException { Compose the content of the file so we can compare to length in filesystem . If not same , rewrite it ( it may have been written in the old format using Writables instead of pb ) . The pb version is much shorter - - we write now w / o the toString version - - so checking length only should be sufficient . I don ' t want to read the file every time to check if it pb serialized . byte [ ] content = getRegionInfoFileContent ( regionInfoForFs ) ; when HRegion . openHRegion ( ) is called . try { FileStatus status = fs . getFileStatus ( getRegionDir ( ) ) ; } catch ( FileNotFoundException e ) { LOG . warn ( getRegionDir ( ) + _STR + regionInfo . getTable ( ) ) ; } Write HRI to a file in case we need to recover hbase : meta writeRegionInfoOnFilesystem ( content , true ) ; } 
3222	void notify ( ContentResolver resolver ) { resolver . notifyChange ( createUri ( ) , null , false ) ; mLastNotified = new Date ( ) ; } 
3223	private Extract extract ( ) throws SQLSyntaxErrorException { IntervalPrimary . Unit unit = intervalPrimaryUnit ( ) ; match ( KW _ FROM ) ; Expression date = expression ( ) ; match ( PUNC _ RIGHT _ PAREN ) ; Extract extract = new Extract ( unit , date ) ; extract . setCacheEvalRst ( cacheEvalRst ) ; return extract ; } 
3224	public boolean connect ( BluetoothDevice device ) { if ( DBG ) log ( _STR + Log . getStackTraceString ( new Throwable ( ) ) ) ; return false ; } finally { mServiceLock . readLock ( ) . unlock ( ) ; } } 
3225	public void addUndoPoint ( ) { File tempFile ; ObjectOutputStream oos ; undo support currently on ? if ( ! isUndoEnabled ( ) ) return ; if ( getInstances ( ) ! = null ) { try { temp . filename tempFile = File . createTempFile ( _STR , null ) ; tempFile . deleteOnExit ( ) ; serialize instances oos = new ObjectOutputStream ( new BufferedOutputStream ( new FileOutputStream ( tempFile ) ) ) ; oos . writeObject ( getInstances ( ) ) ; oos . flush ( ) ; oos . close ( ) ; add to undo list m _ UndoList . add ( tempFile ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } 
3226	public void onBeforeUnlockUser ( @ UserIdInt int userId ) { UserInfo userInfo = getUserInfo ( userId ) ; if ( userInfo = = null ) { return ; } final int userSerial = userInfo . serialNumber ; Migrate only if build fingerprints mismatch boolean migrateAppsData = ! Build . FINGERPRINT . equals ( userInfo . lastLoggedInFingerprint ) ; mUserDataPreparer . prepareUserData ( userId , userSerial , StorageManager . FLAG _ STORAGE _ CE ) ; mPm . reconcileAppsData ( userId , StorageManager . FLAG _ STORAGE _ CE , migrateAppsData ) ; } 
3227	private void resizeImageView ( ) { int availableHeight = getAvailableHeight ( ) ; int availableWidth = getMeasuredWidth ( ) ; int dimension = Math . min ( availableHeight , availableWidth ) ; imageView . getLayoutParams ( ) . height = dimension ; imageView . getLayoutParams ( ) . width = dimension ; ( ( LayoutParams ) imageView . getLayoutParams ( ) ) . setMargins ( IMAGE _ MARGINS , IMAGE _ MARGINS , IMAGE _ MARGINS , IMAGE _ MARGINS ) ; imageView . setLayoutParams ( imageView . getLayoutParams ( ) ) ; } 
3228	public void setThumbSize ( int width , int height ) { mThumbHeightInPixel = height ; mThumbWidthInPixel = width ; int heroIndex = getHeroIndex ( ) ; for ( int i = _NUM ; i < getChildCount ( ) ; i + + ) { if ( heroIndex ! = i ) { View child = getChildAt ( i ) ; LinearLayout . LayoutParams lp = ( LinearLayout . LayoutParams ) child . getLayoutParams ( ) ; boolean changed = false ; if ( lp . height ! = height ) { lp . height = height ; changed = true ; } if ( lp . width ! = width ) { lp . width = width ; changed = true ; } if ( changed ) { child . setLayoutParams ( lp ) ; } } } } 
3229	private void scrollAction ( ) { if ( m _ scrollEnabled ) { Direction direction = getScrollDirection ( _NUM _NUM ) ; if ( ( m _ scrollTimer ! = null ) & & ( m _ scrollDirection ! = direction ) ) { clearScrollTimer ( ) ; } if ( ( direction ! = null ) & & ( m _ scrollTimer = = null ) ) { m _ scrollTimer = new CmsScrollTimer ( RootPanel . getBodyElement ( ) , _NUM _NUM , direction ) ; m _ scrollTimer . scheduleRepeating ( _NUM _NUM ) ; } m _ scrollDirection = direction ; } } 
3230	public static boolean containsSofaFramework ( ) { return getSofaFramework ( ) ! = null ; } 
3231	public void drawItem ( Graphics _NUM D g _NUM , XYItemRendererState state , Rectangle _NUM D dataArea , PlotRenderingInfo info , XYPlot plot , ValueAxis domainAxis , ValueAxis rangeAxis , XYDataset dataset , int series , int item , CrosshairState crosshairState , int pass ) { do nothing if item is not visible if ( ! getItemVisible ( series , item ) ) { return ; } RectangleEdge xAxisLocation = plot . getDomainAxisEdge ( ) ; RectangleEdge yAxisLocation = plot . getRangeAxisEdge ( ) ; get the data point . . . double x _NUM = dataset . getXValue ( series , item ) ; double y _NUM = dataset . getYValue ( series , item ) ; double transX _NUM = domainAxis . valueToJava _NUM D ( x _NUM , dataArea , xAxisLocation ) ; double transY _NUM = rangeAxis . valueToJava _NUM D ( y _NUM , dataArea , yAxisLocation ) ; State s = ( State ) state ; update path to reflect latest point if ( ! Double . isNaN ( transX _NUM ) & & ! Double . isNaN ( transY _NUM ) ) { float x = ( float ) transX _NUM ; float y = ( float ) transY _NUM ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { x = ( float ) transY _NUM ; y = ( float ) transX _NUM ; } if ( s . lastPointGood ) { if ( ( Math . abs ( x - s . lastX ) > s . dX ) ) { s . seriesPath . lineTo ( x , y ) ; if ( s . lowY < s . highY ) { s . intervalPath . moveTo ( ( float ) s . lastX , ( float ) s . lowY ) ; s . intervalPath . lineTo ( ( float ) s . lastX , ( float ) s . highY ) ; } s . lastX = x ; s . openY = y ; s . highY = y ; s . lowY = y ; s . closeY = y ; } else { s . highY = Math . max ( s . highY , y ) ; s . lowY = Math . min ( s . lowY , y ) ; s . closeY = y ; } } else { s . seriesPath . moveTo ( x , y ) ; s . lastX = x ; s . openY = y ; s . highY = y ; s . lowY = y ; s . closeY = y ; } s . lastPointGood = true ; } else { s . lastPointGood = false ; } if this is the last item , draw the path . . . if ( item = = s . getLastItemIndex ( ) ) { draw path PathIterator pi = s . seriesPath . getPathIterator ( null ) ; int count = _NUM ; while ( ! pi . isDone ( ) ) { count + + ; pi . next ( ) ; } g _NUM . setStroke ( getItemStroke ( series , item ) ) ; g _NUM . setPaint ( getItemPaint ( series , item ) ) ; g _NUM . draw ( s . seriesPath ) ; g _NUM . draw ( s . intervalPath ) ; } } 
3232	public void asFilesIterable _ AllowOverwrite _ MultipleFiles _ AllOutputFilesExist ( ) throws IOException { set up File sourceFile = new File ( _STR ) ; copy the image to a temporary file . TestUtils . copyFile ( sourceFile , originalFile ) ; TestUtils . copyFile ( sourceFile , fileThatExists _NUM ) ; TestUtils . copyFile ( sourceFile , fileThatExists _NUM ) ; given when List < File > list = Thumbnails . of ( originalFile , originalFile ) . size ( _NUM _NUM _NUM , _NUM _NUM _NUM ) . allowOverwrite ( true ) . asFiles ( Arrays . asList ( fileThatExists _NUM , fileThatExists _NUM ) ) ; then assertTrue ( fileThatExists _NUM . exists ( ) ) ; assertTrue ( fileThatExists _NUM . exists ( ) ) ; assertFalse ( sourceFile . length ( ) = = fileThatExists _NUM . length ( ) ) ; assertFalse ( sourceFile . length ( ) = = fileThatExists _NUM . length ( ) ) ; assertEquals ( Arrays . asList ( fileThatExists _NUM , fileThatExists _NUM ) , list ) ; clean up originalFile . delete ( ) ; fileThatExists _NUM . delete ( ) ; fileThatExists _NUM . delete ( ) ; } 
3233	public void cleanResourceReferences ( String key ) throws YarnException { Collection < SharedCacheResourceReference > refs = getResourceReferences ( key ) ; if ( ! refs . isEmpty ( ) ) { Set < SharedCacheResourceReference > refsToRemove = new HashSet < SharedCacheResourceReference > ( ) ; for ( SharedCacheResourceReference r : refs ) { if ( ! appChecker . isApplicationActive ( r . getAppId ( ) ) ) { application in resource reference is dead , it is safe to remove the reference refsToRemove . add ( r ) ; } } if ( refsToRemove . size ( ) > _NUM ) { removeResourceReferences ( key , refsToRemove , false ) ; } } } 
3234	private SqlNode getAgg ( SqlSelect select ) { final SelectScope selectScope = getRawSelectScope ( select ) ; if ( selectScope ! = null ) { final List < SqlNode > selectList = selectScope . getExpandedSelectList ( ) ; if ( selectList ! = null ) { return aggFinder . findAgg ( selectList ) ; } } return aggFinder . findAgg ( select . getSelectList ( ) ) ; } 
3235	private List < CmsResource > updateContextDates ( CmsDbContext dbc , List < CmsResource > resourceList ) { CmsFlexRequestContextInfo info = dbc . getFlexRequestContextInfo ( ) ; if ( info ! = null ) { for ( int i = _NUM ; i < resourceList . size ( ) ; i + + ) { CmsResource resource = resourceList . get ( i ) ; info . updateFromResource ( resource ) ; } } return resourceList ; } 
3236	public int submitJob ( final Configuration conf , final String qualifiedTableName , final String inputPaths , final Path outputPath , List < TargetTableRef > tablesToBeLoaded , boolean hasLocalIndexes ) throws Exception { Job job = Job . getInstance ( conf , _STR , outputPath ) ; } return _NUM ; } else { return - _NUM ; } } 
3237	public void setLevelThreshold ( ParserNotice . Level level ) { levelThreshold = level ; if ( isDisplayable ( ) ) { refreshMarkers ( ) ; } } 
3238	private void notifyFeatureState ( @ ImsState int state ) { synchronized ( mStatusCallbacks ) { for ( Iterator < IImsFeatureStatusCallback > iter = mStatusCallbacks . iterator ( ) ; iter . hasNext ( ) ; ) { IImsFeatureStatusCallback callback = iter . next ( ) ; try { Log . i ( LOG _ TAG , _STR + e . getMessage ( ) ) ; } } } sendImsServiceIntent ( state ) ; } 
3239	public void wakeUp ( ) throws RemoteException { Tracer . trace ( ) ; if ( getAutomatorBridge ( ) . getInteractionController ( ) . wakeDevice ( ) ) { sync delay to allow the window manager to start accepting input after the device is awakened . SystemClock . sleep ( _NUM _NUM _NUM ) ; } } 
3240	public void install ( ) throws CLIException , InterruptedException , IOException { displayer . printEvent ( _STR ) ; } 
3241	public void stop ( ) throws Exception { for ( DummyZKFCThread thr : thrs ) { if ( thr ! = null ) { thr . interrupt ( ) ; } } if ( ctx ! = null ) { ctx . stop ( ) ; } sharedResource . assertNoViolations ( ) ; } 
3242	private boolean isDelimiter ( ) throws JasperException { if ( ! isSpace ( ) ) { int ch = peekChar ( ) ; Look for a single - char work delimiter : if ( ch = = ' = ' | | ch = = ' > ' | | ch = = ' " ' | | ch = = ' \ ' ' | | ch = = ' / ' ) { return true ; } Look for an end - of - comment or end - of - tag : if ( ch = = ' - ' ) { Mark mark = mark ( ) ; if ( ( ( ch = nextChar ( ) ) = = ' > ' ) | | ( ( ch = = ' - ' ) & & ( nextChar ( ) = = ' > ' ) ) ) { reset ( mark ) ; return true ; } else { reset ( mark ) ; return false ; } } return false ; } else { return true ; } } 
3243	public void update ( final long item , final long count ) { if ( count = = _NUM ) { return ; } if ( count < _NUM ) { throw new SketchesArgumentException ( _STR ) ; } } } } 
3244	public TurkishLetterSequence append ( int index , TurkishLetterSequence sequence ) { if ( index < _NUM | | index > size ) { throw new ArrayIndexOutOfBoundsException ( _STR + size ) ; } dizi capacitysini ayarla int seqSize = sequence . length ( ) ; if ( size + seqSize > letters . length ) { adjustCapacity ( seqSize ) ; } sondan baslayarak this . dizinin index ' ten sonraki kismini dizinin sonuna tasi for ( int i = seqSize + size - _NUM ; i > = seqSize ; i - - ) { letters [ i ] = letters [ i - seqSize ] ; } gelen diziyi kopyala ve boyutu degistir . System . arraycopy ( sequence . letters , _NUM , letters , index , seqSize ) ; size + = sequence . length ( ) ; return this ; } 
3245	public void addEntity ( Entity entity ) { if ( entity . isActive ( ) ) throw new IllegalArgumentException ( _STR ) ; waitingList . add ( entity ) ; entities . add ( entity ) ; add ( entity ) ; } 
3246	private boolean allMonotonic ( ClauseEntry [ ] elts ) { for ( ClauseEntry elt : elts ) { if ( elt instanceof Functor ) { Builtin b = ( ( Functor ) elt ) . getImplementor ( ) ; if ( b ! = null ) { if ( ! b . isMonotonic ( ) ) { return false ; } } else { throw new ReasonerException ( _STR + toShortString ( ) ) ; } } } return true ; } 
3247	public INDArray randn ( char order , int [ ] shape ) { return Nd _NUM j . getRandom ( ) . nextGaussian ( order , shape ) ; } 
3248	public Iterator < Derivation > getDerivation ( Statement statement ) { return getInfGraph ( ) . getDerivation ( statement . asTriple ( ) ) ; } 
3249	public List < ACL > getAcl ( String path , Stat stat ) throws KeeperException , InterruptedException { try ( TraceScope scope = TraceUtil . createTrace ( _STR ) ; break ; default : throw e ; } } retryCounter . sleepUntilNextRetry ( ) ; } } } 
3250	private boolean findTarget ( String searchKey , String searchValue , int searchMode , String line ) { if ( _STR . equals ( searchKey ) ) { if ( searchValue . equals ( getName ( line ) ) ) { return true ; } } else { String getValue = getPropertyValue ( line , searchKey ) ; if ( null = = getValue ) { return false ; } return isMatch ( searchValue , getValue , searchMode ) ; } return false ; } 
3251	public DevicePolicyManager getParentProfileInstance ( @ NonNull ComponentName admin ) { throwIfParentInstance ( _STR ) ; } return new DevicePolicyManager ( mContext , mService , true ) ; } catch ( RemoteException e ) { throw e . rethrowFromSystemServer ( ) ; } } 
3252	public void close ( ) throws IOException { implCreateIfNeeded ( ) ; impl . close ( ) ; } 
3253	private void setAppearanceContent ( PDAnnotationWidget widget , PDAppearanceStream appearanceStream ) throws IOException { first copy any needed resources from the document â€™ s DR dictionary into the stream â€™ s Resources dictionary defaultAppearance . copyNeededResourcesTo ( appearanceStream ) ; to the matching EMC try ( ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ) { ContentStreamWriter writer = new ContentStreamWriter ( output ) ; List < Object > tokens = tokenize ( appearanceStream ) ; int bmcIndex = tokens . indexOf ( BMC ) ; if ( bmcIndex = = - _NUM ) { append to existing stream writer . writeTokens ( tokens ) ; writer . writeTokens ( COSName . TX , BMC ) ; } else { prepend content before BMC writer . writeTokens ( tokens . subList ( _NUM , bmcIndex + _NUM ) ) ; } insert field contents insertGeneratedAppearance ( widget , appearanceStream , output ) ; int emcIndex = tokens . indexOf ( EMC ) ; if ( emcIndex = = - _NUM ) { append EMC writer . writeTokens ( EMC ) ; } else { append contents after EMC writer . writeTokens ( tokens . subList ( emcIndex , tokens . size ( ) ) ) ; } writeToStream ( output . toByteArray ( ) , appearanceStream ) ; } } 
3254	public CmsHistoryProject readProject ( CmsDbContext dbc , CmsUUID projectId ) throws CmsDataAccessException { PreparedStatement stmt = null ; CmsHistoryProject project = null ; ResultSet res = null ; Connection conn = null ; int tmpTag ; try { conn = m _ sqlManager . getConnection ( dbc ) ; stmt = m _ sqlManager . getPreparedStatement ( conn , _STR ) ) ; project = internalCreateProject ( res , null ) ; while ( res . next ( ) ) { do nothing only move through all rows because of mssql odbc driver } } else { throw new CmsDbEntryNotFoundException ( Messages . get ( ) . container ( Messages . ERR _ NO _ HISTORY _ PROJECT _ WITH _ ID _ _NUM , projectId ) ) ; } } catch ( SQLException e ) { throw new CmsDbSqlException ( Messages . get ( ) . container ( Messages . ERR _ GENERIC _ SQL _ _NUM , CmsDbSqlException . getErrorQuery ( stmt ) ) , e ) ; } finally { m _ sqlManager . closeAll ( dbc , conn , stmt , res ) ; } List < String > projectresources = readProjectResources ( dbc , tmpTag ) ; project . setProjectResources ( projectresources ) ; return project ; } 
3255	public < T > Expression stash ( T input , Class < ? super T > clazz ) { Well - known final classes that can be used as literals if ( input = = null | | input instanceof String | | input instanceof Boolean | | input instanceof Byte | | input instanceof Short | | input instanceof Integer | | input instanceof Long | | input instanceof Float | | input instanceof Double ) { return Expressions . constant ( input , clazz ) ; } ParameterExpression cached = stashedParameters . get ( input ) ; if ( cached ! = null ) { return cached ; } _STR ; final ParameterExpression x = Expressions . variable ( clazz , name ) ; map . put ( name , input ) ; stashedParameters . put ( input , x ) ; return x ; } 
3256	public static < T extends MessageOrBuilder > List < T > testData ( T . . . messages ) throws IOException { checkSameBuilderInstance ( messages ) ; List < MessageOrBuilder > input = cloneList ( messages ) ; List < MessageOrBuilder > output = ( List < MessageOrBuilder > ) writeAndRead ( messages ) ; List < Message > outputAsMessages = asMessages ( output ) ; assertEquals ( _STR , asMessages ( input ) , outputAsMessages ) ; return ( List < T > ) outputAsMessages ; } 
3257	public Number getStartY ( int series , int item ) { return new Double ( getStartYValue ( series , item ) ) ; } 
3258	protected double estimatePerformance ( BitSet feature _ set , int num _ atts ) throws Exception { m _ evaluation = new Evaluation ( m _ theInstances ) ; int i ; int [ ] fs = new int [ num _ atts ] ; double [ ] instA = new double [ num _ atts ] ; int classI = m _ theInstances . classIndex ( ) ; int index = _NUM ; for ( i = _NUM ; i < m _ numAttributes ; i + + ) { if ( feature _ set . get ( i ) ) { fs [ index + + ] = i ; } } create new hash table m _ entries = new Hashtable ( ( int ) ( m _ theInstances . numInstances ( ) * _NUM . _NUM ) ) ; insert instances into the hash table for ( i = _NUM ; i < m _ numInstances ; i + + ) { Instance inst = m _ theInstances . instance ( i ) ; for ( int j = _NUM ; j < fs . length ; j + + ) { if ( fs [ j ] = = classI ) { missing for the class instA [ j ] = Double . MAX _ VALUE ; } else if ( inst . isMissing ( fs [ j ] ) ) { instA [ j ] = Double . MAX _ VALUE ; } else { instA [ j ] = inst . value ( fs [ j ] ) ; } } insertIntoTable ( inst , instA ) ; } if ( m _ CVFolds = = _NUM ) { calculate leave one out error for ( i = _NUM ; i < m _ numInstances ; i + + ) { Instance inst = m _ theInstances . instance ( i ) ; for ( int j = _NUM ; j < fs . length ; j + + ) { if ( fs [ j ] = = classI ) { missing for the class instA [ j ] = Double . MAX _ VALUE ; } else if ( inst . isMissing ( fs [ j ] ) ) { instA [ j ] = Double . MAX _ VALUE ; } else { instA [ j ] = inst . value ( fs [ j ] ) ; } } evaluateInstanceLeaveOneOut ( inst , instA ) ; } } else { m _ theInstances . randomize ( m _ rr ) ; m _ theInstances . stratify ( m _ CVFolds ) ; calculate _NUM _NUM fold cross validation error for ( i = _NUM ; i < m _ CVFolds ; i + + ) { Instances insts = m _ theInstances . testCV ( m _ CVFolds , i ) ; evaluateFoldCV ( insts , fs ) ; } } switch ( m _ evaluationMeasure ) { case EVAL _ DEFAULT : if ( m _ classIsNominal ) { return m _ evaluation . pctCorrect ( ) ; } return - m _ evaluation . rootMeanSquaredError ( ) ; case EVAL _ ACCURACY : return m _ evaluation . pctCorrect ( ) ; case EVAL _ RMSE : return - m _ evaluation . rootMeanSquaredError ( ) ; case EVAL _ MAE : return - m _ evaluation . meanAbsoluteError ( ) ; case EVAL _ AUC : double [ ] classPriors = m _ evaluation . getClassPriors ( ) ; Utils . normalize ( classPriors ) ; double weightedAUC = _NUM ; for ( i = _NUM ; i < m _ theInstances . classAttribute ( ) . numValues ( ) ; i + + ) { double tempAUC = m _ evaluation . areaUnderROC ( i ) ; if ( ! Utils . isMissingValue ( tempAUC ) ) { weightedAUC + = ( classPriors [ i ] * tempAUC ) ; } else { System . err . println ( _STR ) ; } } return weightedAUC ; } shouldn ' t get here return _NUM . _NUM ; } 
3259	public void destroy ( ) { if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( _STR + this . toString ( ) ) ; } clearMemory ( ) ; deleteCudaLibraryHandles ( ) ; } 
3260	public void testInsertMultipleAsList ( ) throws SQLException { List < ClientTestModel > entities = new ArrayList < ClientTestModel > ( ) ; for ( int i = _NUM ; i < _NUM ; i + + ) { ClientTestModel model = new ClientTestModel ( ) ; model . setQuantity ( _NUM _NUM + _NUM % _NUM ) ; model . setType ( ( ( Number ) ( _NUM % _NUM ) ) . shortValue ( ) ) ; model . setAddress ( _STR , i ) , entities ) ; assertEquals ( ( i + _NUM ) + j + + * _NUM , getCount ( i ) ) ; By fields same shard entities . get ( _NUM ) . setTableIndex ( i ) ; entities . get ( _NUM ) . setTableIndex ( i ) ; entities . get ( _NUM ) . setTableIndex ( i ) ; res = dao . insert ( new DalHints ( ) , entities ) ; assertEquals ( ( i + _NUM ) + j + + * _NUM , getCount ( i ) ) ; } deleteAllShards ( ) ; By fields not same shard entities . get ( _NUM ) . setTableIndex ( _NUM ) ; entities . get ( _NUM ) . setTableIndex ( _NUM ) ; entities . get ( _NUM ) . setTableIndex ( _NUM ) ; dao . insert ( new DalHints ( ) . continueOnError ( ) , entities ) ; assertEquals ( _NUM , getCount ( _NUM ) ) ; assertEquals ( _NUM , getCount ( _NUM ) ) ; assertEquals ( _NUM , getCount ( _NUM ) ) ; } 
3261	public Element parse ( Reader is ) { buffOffset = _NUM ; buffSize = - _NUM ; eventParser = false ; ROOT is a _STR + roots ) ; } rootElement = rootElement . getChildAt ( _NUM ) ; return rootElement ; } 
3262	public void uninstall ( ) throws CLIException , InterruptedException , IOException , RestClientException { displayer . printEvent ( _STR ) ; } 
3263	public void testEscherDrawing ( ) { HWPFDocument docD = HWPFTestDataSamples . openSampleFile ( docDFile ) ; List < Picture > allPictures = docD . getPicturesTable ( ) . getAllPictures ( ) ; assertEquals ( _NUM , allPictures . size ( ) ) ; Picture pic = allPictures . get ( _NUM ) ; assertNotNull ( pic ) ; byte [ ] picD = readFile ( imgDFile ) ; assertEquals ( picD . length , pic . getContent ( ) . length ) ; assertBytesSame ( picD , pic . getContent ( ) ) ; } 
3264	private static ExecutorService wrapExecutor ( final Executor executor ) { return new AbstractExecutorService ( ) { private volatile boolean isShutdown = false ; private volatile boolean isTerminated = false ; @ Override public void shutdown ( ) { isShutdown = true ; } @ Override public List < Runnable > shutdownNow ( ) { return Lists . newArrayList ( ) ; } @ Override public boolean isShutdown ( ) { return isShutdown ; } @ Override public boolean isTerminated ( ) { return isTerminated ; } @ Override public boolean awaitTermination ( long timeout , TimeUnit unit ) throws InterruptedException { throw new UnsupportedOperationException ( ) ; } @ Override public void execute ( Runnable command ) { try { executor . execute ( command ) ; } finally { isShutdown = true ; isTerminated = true ; } } } ; } 
3265	public static BufferedReader asBufferedUTF _NUM ( InputStream in ) { return new BufferedReader ( asUTF _NUM ( in ) ) ; } 
3266	protected void copyRequestHeaders ( HttpServletRequest servletRequest , HttpRequest proxyRequest , HttpHost host ) { Enumeration headerNames = servletRequest . getHeaderNames ( ) ; while ( headerNames . hasMoreElements ( ) ) { String headerName = ( String ) headerNames . nextElement ( ) ; instead the content - length is effectively set via InputStreamEntity if ( headerName . equalsIgnoreCase ( HttpHeaders . CONTENT _ LENGTH ) ) { continue ; } if ( hopByHopHeaders . containsHeader ( headerName ) ) { continue ; } Enumeration headers = servletRequest . getHeaders ( headerName ) ; while ( headers . hasMoreElements ( ) ) { String headerValue = ( String ) headers . nextElement ( ) ; in case the proxy host is running multiple virtual servers , rewrite the Host header to guarantee we get content from the correct virtual server if ( headerName . equalsIgnoreCase ( HttpHeaders . HOST ) ) { headerValue = host . getHostName ( ) ; if ( host . getPort ( ) ! = - _NUM ) { headerValue + = _STR + host . getPort ( ) ; } } else if ( headerName . equalsIgnoreCase ( SM . COOKIE ) ) { headerValue = getRealCookie ( headerValue ) ; } proxyRequest . addHeader ( headerName , headerValue ) ; } } } 
3267	public static String screenshot ( String fileName ) { return Screenshots . takeScreenShot ( fileName ) ; } 
3268	public void inputContentsAreNotAltered ( ) { given BufferedImage originalImage = new BufferedImage ( _NUM _NUM _NUM , _NUM _NUM _NUM , BufferedImage . TYPE _ INT _ ARGB ) ; BufferedImage copyImage = BufferedImages . copy ( originalImage ) ; ImageFilter filter = new Caption ( _STR , Font . PLAIN , _NUM _NUM ) , Color . black , Positions . BOTTOM _ CENTER , _NUM ) ; when filter . apply ( originalImage ) ; then assertTrue ( BufferedImageComparer . isSame ( originalImage , copyImage ) ) ; } 
3269	protected IonReader reread ( ) throws Exception { byte [ ] bytes = outputByteArray ( ) ; return system ( ) . newReader ( bytes ) ; } 
3270	public void close ( ) throws IOException { if ( closed = = true ) { return ; } try { + + errorCount ; wBlkState . finish ( ) ; blockRegister . register ( getRawSize ( ) , wBlkState . getStartPos ( ) , wBlkState . getCurrentPos ( ) ) ; - - errorCount ; } finally { closed = true ; blkInProgress = false ; } } 
3271	protected void invokeOperation ( MongoDbOperation operation , Exchange exchange ) throws Exception { Processor processor = operations . get ( operation ) ; if ( processor ! = null ) { processor . process ( exchange ) ; } else { throw new CamelMongoDbException ( _STR + operation ) ; } } 
3272	public void setRequestedUri ( String requestedUri ) { checkFrozen ( ) ; m _ requestedUri = requestedUri ; } 
3273	public static < I extends WritableComparable , E extends WritableComparable > boolean equals ( Iterable < Edge < I , E > > e _NUM , Iterable < Edge < I , E > > e _NUM ) { Iterator < Edge < I , E > > i _NUM = e _NUM . iterator ( ) ; Iterator < Edge < I , E > > i _NUM = e _NUM . iterator ( ) ; while ( i _NUM . hasNext ( ) ) { if ( ! i _NUM . hasNext ( ) ) { return false ; } if ( ! EdgeComparator . equal ( i _NUM . next ( ) , i _NUM . next ( ) ) ) { return false ; } } return true ; } 
3274	public double meanRate ( ) { if ( count ( ) = = _NUM ) { return _NUM . _NUM ; } else { final long elapsed = ( clock . getTick ( ) - startTime ) ; return ( count ( ) / ( double ) elapsed ) * NANOS _ PER _ SECOND ; } } 
3275	public ScheduledInstanceRecurrence withOccurrenceDaySet ( Integer . . . occurrenceDaySet ) { if ( getOccurrenceDaySet ( ) = = null ) setOccurrenceDaySet ( new java . util . ArrayList < Integer > ( occurrenceDaySet . length ) ) ; for ( Integer value : occurrenceDaySet ) { getOccurrenceDaySet ( ) . add ( value ) ; } return this ; } 
3276	public InstanceNetworkInterfaceSpecification withPrivateIpAddresses ( PrivateIpAddressSpecification . . . privateIpAddresses ) { if ( getPrivateIpAddresses ( ) = = null ) setPrivateIpAddresses ( new java . util . ArrayList < PrivateIpAddressSpecification > ( privateIpAddresses . length ) ) ; for ( PrivateIpAddressSpecification value : privateIpAddresses ) { getPrivateIpAddresses ( ) . add ( value ) ; } return this ; } 
3277	public void testWeightedMovingAverage ( ) { logger . info ( _STR ) ; FlatDataList flatDataList = generateFlatDataList ( ) ; int N = _NUM ; double expResult = _NUM _NUM . _NUM ; double result = Smoothing . weightedMovingAverage ( flatDataList , N ) ; assertEquals ( expResult , result , Constants . DOUBLE _ ACCURACY _ HIGH ) ; } 
3278	private void notifyAccessibilityEventInternal ( int eventType , AccessibilityEvent event , boolean serviceWantsEvent ) { IAccessibilityServiceClient listener ; synchronized ( mLock ) { listener = mServiceInterface ; the accessibility event was propagating the listener may be null . if ( listener = = null ) { return ; } minimal fuss . if ( event = = null ) { We are throttling events , so we ' ll send the event for this type in mPendingEvents as long as it it ' s null . It can only null due to a race condition : _NUM ) A binder thread calls notifyAccessibilityServiceDelayedLocked which posts a message for dispatching an event and stores the event in mPendingEvents . _NUM ) The message is pulled from the queue by the handler on the service thread and this method is just about to acquire the lock . _NUM ) Another binder thread acquires the lock in notifyAccessibilityEvent _NUM ) notifyAccessibilityEvent recycles the event that this method was about to process , replaces it with a new one , and posts a second message _NUM ) This method grabs the new event , processes it , and removes it from mPendingEvents _NUM ) The second message dispatched in ( _NUM ) arrives , but the event has been remvoved in ( _NUM ) . event = mPendingEvents . get ( eventType ) ; if ( event = = null ) { return ; } mPendingEvents . remove ( eventType ) ; } if ( mSecurityPolicy . canRetrieveWindowContentLocked ( this ) ) { event . setConnectionId ( mId ) ; } else { event . setSource ( ( View ) null ) ; } event . setSealed ( true ) ; } try { listener . onAccessibilityEvent ( event , serviceWantsEvent ) ; if ( DEBUG ) { Slog . i ( LOG _ TAG , _STR + listener , re ) ; } finally { event . recycle ( ) ; } } 
3279	public synchronized void addTrigger ( final Trigger t ) throws TriggerLoaderException { logger . info ( _STR , ex ) ; } } 
3280	private synchronized void onPrintServicesUpdate ( ) { updateEmptyView ( ( DestinationAdapter ) mListView . getAdapter ( ) ) ; invalidateOptionsMenu ( ) ; } 
3281	public static final Intent getBubbleChartIntent ( Context context , XYMultipleSeriesDataset dataset , XYMultipleSeriesRenderer renderer , String activityTitle ) { checkParameters ( dataset , renderer ) ; Intent intent = new Intent ( context , GraphicalActivity . class ) ; XYChart chart = new BubbleChart ( dataset , renderer ) ; intent . putExtra ( CHART , chart ) ; intent . putExtra ( TITLE , activityTitle ) ; return intent ; } 
3282	public void zip ( final IOFile root , final StringList files ) throws IOException { if ( ! ( file instanceof IOFile ) ) throw new FileNotFoundException ( file . path ( ) ) ; curr = _NUM ; try ( ZipOutputStream out = new ZipOutputStream ( new BufferedOutputStream ( new FileOutputStream ( file . path ( ) ) ) ) ) { use simple , fast compression out . setLevel ( _NUM ) ; loop through all files total = files . size ( ) ; final byte [ ] data = new byte [ IO . BLOCKSIZE ] ; for ( final String f : files ) { curr + + ; try ( FileInputStream in = new FileInputStream ( new File ( root . file ( ) , f ) ) ) { final String fl = Prop . WIN ? f . replace ( ' \ \ ' , ' / ' ) : f ; out . putNextEntry ( new ZipEntry ( root . name ( ) + ' / ' + fl ) ) ; for ( int c ; ( c = in . read ( data ) ) ! = - _NUM ; ) out . write ( data , _NUM , c ) ; out . closeEntry ( ) ; } } } } 
3283	public Set < String > findTypes ( String os ) { Map < String , String > pos = parse _ os ( os ) ; for ( String family : osMap . keySet ( ) ) { JsonOsFamilyEntry fam = osMap . get ( family ) ; if ( fam . getDistro ( ) . contains ( pos . get ( OS _ DISTRO ) ) & & fam . getVersions ( ) . contains ( pos . get ( OS _ VERSION ) ) ) { Set < String > data = new HashSet < > ( ) ; for ( String item : fam . getDistro ( ) ) { data . add ( item + pos . get ( OS _ VERSION ) ) ; } return Collections . unmodifiableSet ( data ) ; } } return Collections . emptySet ( ) ; } 
3284	public static WebSiteProperties from ( HttpServletRequest request ) throws GenericEntityException { Assert . notNull ( _STR , webSiteProps ) ; } return webSiteProps ; } 
3285	private void testNewIndex ( ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( _STR , alias . getReadAlias ( ) , alias . getWriteAlias ( ) , VERIFY _ TYPE , tempId ) ; } return true ; } ; doInRetry ( retryOperation ) ; } 
3286	public void setDragScrollStarts ( float upperFrac , float lowerFrac ) { if ( lowerFrac > _NUM . _NUM f ) { mDragDownScrollStartFrac = _NUM . _NUM f ; } else { mDragDownScrollStartFrac = lowerFrac ; } if ( upperFrac > _NUM . _NUM f ) { mDragUpScrollStartFrac = _NUM . _NUM f ; } else { mDragUpScrollStartFrac = upperFrac ; } if ( getHeight ( ) ! = _NUM ) { updateScrollStarts ( ) ; } } 
3287	public void testBadSimpleAppend ( ) throws InterruptedException , LifecycleException , EventDeliveryException , IOException { LOG . debug ( _STR + sink . process ( ) ) ; sink . stop ( ) ; verifyOutputSequenceFiles ( fs , conf , dirPath . toUri ( ) . getPath ( ) , fileName , bodies ) ; } 
3288	public Path qualifiedPath ( String filename ) throws IOException { Path cwd = defaultFS ( ) . makeQualified ( new Path ( _STR ) ) ; return new Path ( filename ) . makeQualified ( defaultFS ( ) . getUri ( ) , cwd ) ; } 
3289	public Long getLong ( int idx ) { return getValue ( idx ) ; } 
3290	public static void writeAll ( OutputStream stream , Object [ ] o ) throws Exception { ObjectOutputStream oos ; int i ; if ( ! ( stream instanceof BufferedOutputStream ) ) stream = new BufferedOutputStream ( stream ) ; oos = new ObjectOutputStream ( stream ) ; for ( i = _NUM ; i < o . length ; i + + ) oos . writeObject ( o [ i ] ) ; oos . flush ( ) ; oos . close ( ) ; } 
3291	public XWPFTableCell getTableCell ( CTTc cell ) { XmlCursor cursor = cell . newCursor ( ) ; cursor . toParent ( ) ; XmlObject o = cursor . getObject ( ) ; if ( ! ( o instanceof CTRow ) ) { cursor . dispose ( ) ; return null ; } CTRow row = ( CTRow ) o ; cursor . toParent ( ) ; o = cursor . getObject ( ) ; cursor . dispose ( ) ; if ( ! ( o instanceof CTTbl ) ) { return null ; } CTTbl tbl = ( CTTbl ) o ; XWPFTable table = getTable ( tbl ) ; if ( table = = null ) { return null ; } XWPFTableRow tableRow = table . getRow ( row ) ; return tableRow . getTableCell ( cell ) ; } 
3292	public static String getCommandNameWithoutGlobalPrefix ( Session session , String key ) { if ( ! isMultiScopeMode ( session ) ) { String globalScope = ( String ) ( session ! = null ? session . get ( _STR ; if ( key . startsWith ( prefix ) ) { so we may want to also check for a isMultiScope mode = = false return key . substring ( prefix . length ( ) ) ; } } } return key ; } 
3293	public EmitState next ( SpoutOutputCollector collector ) { if ( _ waitingToEmit . isEmpty ( ) ) { fill ( ) ; } while ( true ) { MessageAndOffset toEmit = _ waitingToEmit . pollFirst ( ) ; if ( toEmit = = null ) { return EmitState . NO _ EMITTED ; } Iterable < List < Object > > tups ; if ( _ spoutConfig . scheme instanceof MessageMetadataSchemeAsMultiScheme ) { tups = KafkaUtils . generateTuples ( ( MessageMetadataSchemeAsMultiScheme ) _ spoutConfig . scheme , toEmit . message ( ) , _ partition , toEmit . offset ( ) ) ; } else { tups = KafkaUtils . generateTuples ( _ spoutConfig , toEmit . message ( ) , _ partition . topic ) ; } if ( ( tups ! = null ) & & tups . iterator ( ) . hasNext ( ) ) { if ( ! Strings . isNullOrEmpty ( _ spoutConfig . outputStreamId ) ) { for ( List < Object > tup : tups ) { collector . emit ( _ spoutConfig . outputStreamId , tup , new KafkaMessageId ( _ partition , toEmit . offset ( ) ) ) ; } } else { for ( List < Object > tup : tups ) { collector . emit ( tup , new KafkaMessageId ( _ partition , toEmit . offset ( ) ) ) ; } } break ; } else { ack ( toEmit . offset ( ) ) ; } } if ( ! _ waitingToEmit . isEmpty ( ) ) { return EmitState . EMITTED _ MORE _ LEFT ; } else { return EmitState . EMITTED _ END ; } } 
3294	public Object nextToken ( ) throws JSONException { char c ; char q ; StringBuffer sb ; do { c = next ( ) ; } while ( Character . isWhitespace ( c ) ) ; switch ( c ) { case _NUM : throw syntaxError ( _STR ) ; default : } } } } 
3295	private static Row makeDummyRow ( Cell . . . cells ) { Row . Builder builder = BTreeRow . sortedBuilder ( ) ; builder . newRow ( Clustering . EMPTY ) ; for ( Cell cell : cells ) builder . addCell ( cell ) ; return builder . build ( ) ; } 
3296	private boolean evaluateCriteria ( final ProcessSession session , final ProcessContext context , final Criteria criteria , final FlowFile flowfile , final Map < FlowFile , List < Rule > > matchedRules , final Map < String , String > statefulAttributes ) { final ComponentLog logger = getLogger ( ) ; final List < Rule > rules = criteria . getRules ( ) ; consider each rule and hold a copy of the flowfile for each matched rule for ( final Rule rule : rules ) { evaluate the rule if ( evaluateRule ( context , rule , flowfile , statefulAttributes ) ) { final FlowFile flowfileToUse ; determine if we should use the original flow file or clone if ( FlowFilePolicy . USE _ ORIGINAL . equals ( criteria . getFlowFilePolicy ( ) ) | | matchedRules . isEmpty ( ) ) { flowfileToUse = flowfile ; } else { clone the original for this rule flowfileToUse = session . clone ( flowfile ) ; } store the flow file to use when executing this rule List < Rule > rulesForFlowFile = matchedRules . get ( flowfileToUse ) ; if ( rulesForFlowFile = = null ) { rulesForFlowFile = new ArrayList < > ( ) ; matchedRules . put ( flowfileToUse , rulesForFlowFile ) ; } rulesForFlowFile . add ( rule ) ; log if appropriate if ( debugEnabled ) { logger . debug ( this + _STR + flowfileToUse ) ; } } } return ! matchedRules . isEmpty ( ) ; } 
3297	public static boolean isMonthBefore ( Calendar firstCalendar , Calendar secondCalendar ) { if ( firstCalendar = = null ) { return false ; } Calendar firstDay = ( Calendar ) firstCalendar . clone ( ) ; setMidnight ( firstDay ) ; firstDay . set ( Calendar . DAY _ OF _ MONTH , _NUM ) ; Calendar secondDay = ( Calendar ) secondCalendar . clone ( ) ; setMidnight ( secondDay ) ; secondDay . set ( Calendar . DAY _ OF _ MONTH , _NUM ) ; return secondDay . before ( firstDay ) ; } 
3298	public void setScale ( double d ) { d = Math . max ( d , minScale ) ; d = Math . min ( d , maxScale ) ; if ( scale ! = d ) { scale = d ; scaledWidth = ( int ) ( baseWidth * scale ) ; scaledHeight = ( int ) ( baseHeight * scale ) ; updateClip ( ) ; postInvalidate ( ) ; for ( ZoomPanListener listener : zoomPanListeners ) { listener . onScaleChanged ( scale ) ; listener . onZoomPanEvent ( ) ; } } } 
3299	public static Icon createWithContentUri ( Uri uri ) { if ( uri = = null ) { throw new IllegalArgumentException ( _STR ) ; } final Icon rep = new Icon ( TYPE _ URI ) ; rep . mString _NUM = uri . toString ( ) ; return rep ; } 
3300	void verifyIntProperties ( ) throws IllegalStateException { if ( mProperties . size ( ) < _NUM ) { return ; } int last = getIntPropertyValue ( _NUM ) ; for ( int i = _NUM ; i < mProperties . size ( ) ; i + + ) { int v = getIntPropertyValue ( i ) ; if ( v < last ) { throw new IllegalStateException ( String . format ( _STR , i - _NUM , mProperties . get ( i - _NUM ) . getName ( ) , i , mProperties . get ( i ) . getName ( ) ) ) ; } last = v ; } } 
3301	public static void noteSlowCall ( String name ) { BlockGuard . Policy policy = BlockGuard . getThreadPolicy ( ) ; if ( ! ( policy instanceof AndroidBlockGuardPolicy ) ) { StrictMode not enabled . return ; } ( ( AndroidBlockGuardPolicy ) policy ) . onCustomSlowCall ( name ) ; } 
3302	public Set entrySet ( ) { if ( entries = = null ) { entries = new HashSet < > ( ) ; Add servlet context attributes Enumeration enumeration = context . getAttributeNames ( ) ; while ( enumeration . hasMoreElements ( ) ) { final String key = enumeration . nextElement ( ) . toString ( ) ; final Object value = context . getAttribute ( key ) ; entries . add ( new Map . Entry ( ) { public boolean equals ( Object obj ) { if ( ! ( obj instanceof Map . Entry ) ) { return false ; } Map . Entry entry = ( Map . Entry ) obj ; return ( ( key = = null ) ? ( entry . getKey ( ) = = null ) : key . equals ( entry . getKey ( ) ) ) & & ( ( value = = null ) ? ( entry . getValue ( ) = = null ) : value . equals ( entry . getValue ( ) ) ) ; } public int hashCode ( ) { return ( ( key = = null ) ? _NUM : key . hashCode ( ) ) ^ ( ( value = = null ) ? _NUM : value . hashCode ( ) ) ; } public Object getKey ( ) { return key ; } public Object getValue ( ) { return value ; } public Object setValue ( Object obj ) { context . setAttribute ( key , obj ) ; return value ; } } ) ; } Add servlet context init params enumeration = context . getInitParameterNames ( ) ; while ( enumeration . hasMoreElements ( ) ) { final String key = enumeration . nextElement ( ) . toString ( ) ; final Object value = context . getInitParameter ( key ) ; entries . add ( new Map . Entry ( ) { public boolean equals ( Object obj ) { if ( ! ( obj instanceof Map . Entry ) ) { return false ; } Map . Entry entry = ( Map . Entry ) obj ; return ( ( key = = null ) ? ( entry . getKey ( ) = = null ) : key . equals ( entry . getKey ( ) ) ) & & ( ( value = = null ) ? ( entry . getValue ( ) = = null ) : value . equals ( entry . getValue ( ) ) ) ; } public int hashCode ( ) { return ( ( key = = null ) ? _NUM : key . hashCode ( ) ) ^ ( ( value = = null ) ? _NUM : value . hashCode ( ) ) ; } public Object getKey ( ) { return key ; } public Object getValue ( ) { return value ; } public Object setValue ( Object obj ) { context . setAttribute ( key , obj ) ; return value ; } } ) ; } } return entries ; } 
3303	protected void fetchBlockAt ( long offset ) throws IOException { synchronized ( infoLock ) { int targetBlockIdx = locatedBlocks . findBlock ( offset ) ; if ( targetBlockIdx < _NUM ) { block is not cached targetBlockIdx = LocatedBlocks . getInsertIndex ( targetBlockIdx ) ; } fetch blocks final LocatedBlocks newBlocks = dfsClient . getLocatedBlocks ( src , offset ) ; if ( newBlocks = = null ) { throw new IOException ( _STR + offset ) ; } locatedBlocks . insertRange ( targetBlockIdx , newBlocks . getLocatedBlocks ( ) ) ; } } 
3304	boolean process ( final HTTPConnection conn , final RestXqFunction func , final Object ext ) throws Exception { create new XQuery instance final Context ctx = conn . context ; try ( QueryContext qc = qc ( ctx ) ) { final StaticFunc sf = find ( qc , func . function ) ; will only happen if file has been swapped between caching and parsing if ( sf = = null ) throw HTTPCode . NO _ XQUERY . get ( ) ; final RestXqFunction rxf = new RestXqFunction ( sf , qc , this ) ; rxf . parse ( ctx ) ; return new RestXqResponse ( rxf , qc , conn ) . create ( ext ) ; } } 
3305	private Section createClustersPart ( Composite parent , IWorkbenchSite site ) { final PanelName section = PanelName . CLUSTERS ; final Section sec = createSection ( parent ) ; sec . setText ( section . name ) ; final ClusterTree clustersTree = new ClusterTree ( sec , SWT . NONE ) ; resources . add ( clustersTree ) ; this . searchResult . addListener ( new SearchResultListenerAdapter ( ) { public void processingResultUpdated ( ProcessingResult result ) { final List < Cluster > clusters = result . getClusters ( ) ; if ( clusters ! = null & & clusters . size ( ) > _NUM ) { clustersTree . show ( clusters ) ; } else { clustersTree . show ( Collections . < Cluster > emptyList ( ) ) ; } } } ) ; sec . setClient ( clustersTree ) ; Add expand / collapse action to the toolbar . final ToolBarManager toolBarManager = new ToolBarManager ( SWT . FLAT ) ; final ToolBar toolbar = toolBarManager . createControl ( sec ) ; toolBarManager . add ( new ActionDelegateProxy ( new ClusterTreeExpanderAction ( ClusterTreeExpanderAction . CollapseAction . EXPAND , clustersTree , this . getSearchResult ( ) ) , IAction . AS _ PUSH _ BUTTON ) ) ; toolBarManager . add ( new ActionDelegateProxy ( new ClusterTreeExpanderAction ( ClusterTreeExpanderAction . CollapseAction . COLLAPSE , clustersTree , this . getSearchResult ( ) ) , IAction . AS _ PUSH _ BUTTON ) ) ; toolBarManager . update ( true ) ; sec . setTextClient ( toolbar ) ; return sec ; } 
3306	public final int countDataSchemeSpecificParts ( ) { return mDataSchemeSpecificParts ! = null ? mDataSchemeSpecificParts . size ( ) : _NUM ; } 
3307	public Iterator < Collection < Mutation > > generateViewUpdates ( Collection < View > views , UnfilteredRowIterator updates , UnfilteredRowIterator existings , int nowInSec , boolean separateUpdates ) { assert updates . metadata ( ) . id . equals ( baseTableMetadata . id ) ; List < ViewUpdateGenerator > generators = new ArrayList < > ( views . size ( ) ) ; for ( View view : views ) generators . add ( new ViewUpdateGenerator ( view , updates . partitionKey ( ) , nowInSec ) ) ; DeletionTracker existingsDeletion = new DeletionTracker ( existings . partitionLevelDeletion ( ) ) ; DeletionTracker updatesDeletion = new DeletionTracker ( updates . partitionLevelDeletion ( ) ) ; PeekingIterator < Unfiltered > existingsIter = Iterators . peekingIterator ( existings ) ; PeekingIterator < Unfiltered > updatesIter = Iterators . peekingIterator ( updates ) ; while ( existingsIter . hasNext ( ) & & updatesIter . hasNext ( ) ) { Unfiltered existing = existingsIter . peek ( ) ; Unfiltered update = updatesIter . peek ( ) ; Row existingRow ; Row updateRow ; int cmp = baseTableMetadata . get ( ) . comparator . compare ( update , existing ) ; if ( cmp < _NUM ) { We have an update where there was nothing before if ( update . isRangeTombstoneMarker ( ) ) { updatesDeletion . update ( updatesIter . next ( ) ) ; continue ; } updateRow = ( ( Row ) updatesIter . next ( ) ) . withRowDeletion ( updatesDeletion . currentDeletion ( ) ) ; existingRow = emptyRow ( updateRow . clustering ( ) , existingsDeletion . currentDeletion ( ) ) ; } else if ( cmp > _NUM ) { existing , or because we ' ve fetched the existing row due to some partition / range deletion in the updates ) if ( existing . isRangeTombstoneMarker ( ) ) { existingsDeletion . update ( existingsIter . next ( ) ) ; continue ; } existingRow = ( ( Row ) existingsIter . next ( ) ) . withRowDeletion ( existingsDeletion . currentDeletion ( ) ) ; updateRow = emptyRow ( existingRow . clustering ( ) , updatesDeletion . currentDeletion ( ) ) ; so we just handle the case . if ( updateRow = = null ) continue ; } else { We ' re updating a row that had pre - existing data if ( update . isRangeTombstoneMarker ( ) ) { assert existing . isRangeTombstoneMarker ( ) ; updatesDeletion . update ( updatesIter . next ( ) ) ; existingsDeletion . update ( existingsIter . next ( ) ) ; continue ; } assert ! existing . isRangeTombstoneMarker ( ) ; existingRow = ( ( Row ) existingsIter . next ( ) ) . withRowDeletion ( existingsDeletion . currentDeletion ( ) ) ; updateRow = ( ( Row ) updatesIter . next ( ) ) . withRowDeletion ( updatesDeletion . currentDeletion ( ) ) ; } addToViewUpdateGenerators ( existingRow , updateRow , generators , nowInSec ) ; } We only care about more existing rows if the update deletion isn ' t live , i . e . if we had a partition deletion if ( ! updatesDeletion . currentDeletion ( ) . isLive ( ) ) { while ( existingsIter . hasNext ( ) ) { Unfiltered existing = existingsIter . next ( ) ; the new partition deletion if ( existing . isRangeTombstoneMarker ( ) ) continue ; Row existingRow = ( Row ) existing ; addToViewUpdateGenerators ( existingRow , emptyRow ( existingRow . clustering ( ) , updatesDeletion . currentDeletion ( ) ) , generators , nowInSec ) ; } } if ( separateUpdates ) { final Collection < Mutation > firstBuild = buildMutations ( baseTableMetadata . get ( ) , generators ) ; return new Iterator < Collection < Mutation > > ( ) { If the previous values are already empty , this update must be either empty or exclusively appending . In the case we are exclusively appending , we need to drop the build that was passed in and try to build a new first update instead . If there are no other updates , next will be null and the iterator will be empty . Collection < Mutation > next = firstBuild . isEmpty ( ) ? buildNext ( ) : firstBuild ; private Collection < Mutation > buildNext ( ) { while ( updatesIter . hasNext ( ) ) { Unfiltered update = updatesIter . next ( ) ; If it ' s a range tombstone , it removes nothing pre - exisiting , so we can ignore it for view updates if ( update . isRangeTombstoneMarker ( ) ) continue ; Row updateRow = ( Row ) update ; addToViewUpdateGenerators ( emptyRow ( updateRow . clustering ( ) , existingsDeletion . currentDeletion ( ) ) , updateRow , generators , nowInSec ) ; If the updates have been filtered , then we won ' t have any mutations ; we need to make sure that we only return if the mutations are empty . Otherwise , we continue to search for an update which is not filtered Collection < Mutation > mutations = buildMutations ( baseTableMetadata . get ( ) , generators ) ; if ( ! mutations . isEmpty ( ) ) return mutations ; } return null ; } public boolean hasNext ( ) { return next ! = null ; } public Collection < Mutation > next ( ) { Collection < Mutation > mutations = next ; next = buildNext ( ) ; assert ! mutations . isEmpty ( ) : _STR ; return mutations ; } } ; } else { while ( updatesIter . hasNext ( ) ) { Unfiltered update = updatesIter . next ( ) ; If it ' s a range tombstone , it removes nothing pre - exisiting , so we can ignore it for view updates if ( update . isRangeTombstoneMarker ( ) ) continue ; Row updateRow = ( Row ) update ; addToViewUpdateGenerators ( emptyRow ( updateRow . clustering ( ) , existingsDeletion . currentDeletion ( ) ) , updateRow , generators , nowInSec ) ; } return Iterators . singletonIterator ( buildMutations ( baseTableMetadata . get ( ) , generators ) ) ; } } 
3308	public static void mergeWindows ( WindowFn < ? , IntervalWindow > . MergeContext c ) throws Exception { Merge any overlapping windows into a single window . Sort the list of existing windows so we only have to traverse the list once rather than considering all O ( n ^ _NUM ) window pairs . List < IntervalWindow > sortedWindows = new ArrayList < > ( ) ; for ( IntervalWindow window : c . windows ( ) ) { sortedWindows . add ( window ) ; } Collections . sort ( sortedWindows ) ; List < MergeCandidate > merges = new ArrayList < > ( ) ; MergeCandidate current = new MergeCandidate ( ) ; for ( IntervalWindow window : sortedWindows ) { if ( current . intersects ( window ) ) { current . add ( window ) ; } else { merges . add ( current ) ; current = new MergeCandidate ( window ) ; } } merges . add ( current ) ; for ( MergeCandidate merge : merges ) { merge . apply ( c ) ; } } 
3309	public Node getMatchPredicate ( ) { return anyToNull ( pred ) ; } 
3310	public Intent execute ( Context context ) { String [ ] titles = new String [ ] { _STR ) ; } 
3311	public void testSparseWideWritable ( ) throws Exception { Writable [ ] manyWrits = makeRandomWritables ( _NUM _NUM _NUM ) ; TupleWritable sTuple = new TupleWritable ( manyWrits ) ; for ( int i = _NUM ; i < manyWrits . length ; i + + ) { if ( i % _NUM _NUM = = _NUM ) { sTuple . setWritten ( i ) ; } } ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; sTuple . write ( new DataOutputStream ( out ) ) ; ByteArrayInputStream in = new ByteArrayInputStream ( out . toByteArray ( ) ) ; TupleWritable dTuple = new TupleWritable ( ) ; dTuple . readFields ( new DataInputStream ( in ) ) ; assertTrue ( _STR , - _NUM , in . read ( ) ) ; } 
3312	int parseNumber ( String source , int ofs , String name , int min , int max ) throws ParseException { if ( source = = null ) { throwInvalid ( name , ofs ) ; } int v = - _NUM ; try { v = Integer . parseInt ( source ) ; } catch ( NumberFormatException nfe ) { throwInvalid ( name , ofs ) ; } if ( min ! = max ) { validateNumber ( v , ofs , name , min , max ) ; } return v ; } 
3313	public MapContext < K , V > standAloneChildStack ( ) { MapContext < K , V > standAloneChild = MapContext . createMapContext ( this ) ; standAloneChild . push ( ) ; return standAloneChild ; } 
3314	protected void setupPresenter ( Presenter rowPresenter ) { if ( rowPresenter instanceof FullWidthDetailsOverviewRowPresenter ) { setupDetailsOverviewRowPresenter ( ( FullWidthDetailsOverviewRowPresenter ) rowPresenter ) ; } } 
3315	private void doMap ( ELNode . Nodes el ) throws JasperException { Only care about functions in ELNode ' s class Fvisitor extends ELNode . Visitor { ArrayList < ELNode . Function > funcs = new ArrayList < ELNode . Function > ( ) ; HashMap < String , String > keyMap = new HashMap < String , String > ( ) ; public void visit ( ELNode . Function n ) throws JasperException { String key = n . getPrefix ( ) + _STR ) ; Put the current name in the global function map gMap . put ( f . getPrefix ( ) + ' : ' + f . getName ( ) + ' : ' + f . getUri ( ) , decName ) ; } el . setMapName ( decName ) ; } 
3316	private void initialiseTileMap ( Point maxTileDimensions ) { this . tileMap = new LinkedHashMap < > ( ) ; int sampleSize = fullImageSampleSize ; int xTiles = _NUM ; int yTiles = _NUM ; while ( true ) { int sTileWidth = sWidth ( ) / xTiles ; int sTileHeight = sHeight ( ) / yTiles ; int subTileWidth = sTileWidth / sampleSize ; int subTileHeight = sTileHeight / sampleSize ; while ( subTileWidth + xTiles + _NUM > maxTileDimensions . x | | ( subTileWidth > getWidth ( ) * _NUM . _NUM _NUM & & sampleSize < fullImageSampleSize ) ) { xTiles + = _NUM ; sTileWidth = sWidth ( ) / xTiles ; subTileWidth = sTileWidth / sampleSize ; } while ( subTileHeight + yTiles + _NUM > maxTileDimensions . y | | ( subTileHeight > getHeight ( ) * _NUM . _NUM _NUM & & sampleSize < fullImageSampleSize ) ) { yTiles + = _NUM ; sTileHeight = sHeight ( ) / yTiles ; subTileHeight = sTileHeight / sampleSize ; } List < Tile > tileGrid = new ArrayList < > ( xTiles * yTiles ) ; for ( int x = _NUM ; x < xTiles ; x + + ) { for ( int y = _NUM ; y < yTiles ; y + + ) { Tile tile = new Tile ( ) ; tile . sampleSize = sampleSize ; tile . visible = sampleSize = = fullImageSampleSize ; tile . sRect = new Rect ( x * sTileWidth , y * sTileHeight , x = = xTiles - _NUM ? sWidth ( ) : ( x + _NUM ) * sTileWidth , y = = yTiles - _NUM ? sHeight ( ) : ( y + _NUM ) * sTileHeight ) ; tile . vRect = new Rect ( _NUM , _NUM , _NUM , _NUM ) ; tile . fileSRect = new Rect ( tile . sRect ) ; tileGrid . add ( tile ) ; } } tileMap . put ( sampleSize , tileGrid ) ; if ( sampleSize = = _NUM ) { break ; } else { sampleSize / = _NUM ; } } } 
3317	public static synchronized ZooKeeper getClient ( String contextPath , String session , int expireTime ) throws IOException { final String connectionId = concat ( contextPath , session ) ; ZooKeeper zk = zkMap . get ( connectionId ) ; if ( zk = = null ) { if ( LOG . isInfoEnabled ( ) ) { LOG . info ( String . format ( _STR , p . getKey ( ) , p . getValue ( ) ) . getBytes ( ) ) ; } zkMap . put ( connectionId , zk ) ; a session should automatically expire after an amount of time if ( session ! = null ) { zkSessionTimers . put ( connectionId , new SessionTimerTask ( expireTime , session , contextPath , timer ) ) ; } } return zk ; } 
3318	private void clearState ( ) { Make sure regionInfo is empty before starting fixes = _NUM ; regionInfoMap . clear ( ) ; emptyRegionInfoQualifiers . clear ( ) ; tableStates . clear ( ) ; errors . clear ( ) ; tablesInfo . clear ( ) ; orphanHdfsDirs . clear ( ) ; skippedRegions . clear ( ) ; } 
3319	public static Map < String , Object > calculateProductPrice ( DispatchContext dctx , Map < String , ? extends Object > context ) { Delegator delegator = dctx . getDelegator ( ) ; LocalDispatcher dispatcher = dctx . getDispatcher ( ) ; Map < String , Object > result = new HashMap < String , Object > ( ) ; Timestamp nowTimestamp = UtilDateTime . nowTimestamp ( ) ; GenericValue product = ( GenericValue ) context . get ( _STR , currencyUomIdTo ) ; result = convertPriceMap ; } } } } return result ; } 
3320	public static void dumpWindowToFile ( AccessibilityNodeInfo root , int rotation , int width , int height ) { File baseDir = new File ( Environment . getDataDirectory ( ) , _STR ) , rotation , width , height ) ; } 
3321	public static void splitPrint ( String msg ) { for ( String line : msg . split ( _STR ) ) { println ( line ) ; } } 
3322	private AccessibilityNodeInfo getFindAccessibilityNodeInfoResultAndClear ( int interactionId ) { synchronized ( mInstanceLock ) { final boolean success = waitForResultTimedLocked ( interactionId ) ; AccessibilityNodeInfo result = success ? mFindAccessibilityNodeInfoResult : null ; clearResultLocked ( ) ; return result ; } } 
3323	private void doRemoveItem ( int which ) { must set to avoid cancelDrag being called from the DataSetObserver mDragState = REMOVING ; end it if ( mRemoveListener ! = null ) { mRemoveListener . remove ( which ) ; } destroyFloatView ( ) ; adjustOnReorder ( ) ; clearPositions ( ) ; now the drag is done if ( mInTouchEvent ) { mDragState = STOPPED ; } else { mDragState = IDLE ; } } 
3324	public static org . apache . xmlbeans . xml . stream . XMLInputStream newValidatingXMLInputStream ( org . apache . xmlbeans . xml . stream . XMLInputStream xis ) throws org . apache . xmlbeans . XmlException , org . apache . xmlbeans . xml . stream . XMLStreamException { return XmlBeans . getContextTypeLoader ( ) . newValidatingXMLInputStream ( xis , type , null ) ; } 
3325	 @ Override @ android . view . RemotableViewMethod ( asyncImpl = _STR ) ; } } else { super . setVisibility ( visibility ) ; if ( visibility = = VISIBLE | | visibility = = INVISIBLE ) { inflate ( ) ; } } } 
3326	public void performBackup ( ParcelFileDescriptor oldState , BackupDataOutput data , ParcelFileDescriptor newState ) { use the file paths as the keys , too performBackup _ checked ( oldState , data , newState , mFiles , mFiles ) ; } 
3327	public void addNotification ( ExpandableNotificationRow row , int childIndex ) { int newIndex = childIndex < _NUM ? mChildren . size ( ) : childIndex ; mChildren . add ( newIndex , row ) ; addView ( row ) ; row . setUserLocked ( mUserLocked ) ; View divider = inflateDivider ( ) ; addView ( divider ) ; mDividers . add ( newIndex , divider ) ; updateGroupOverflow ( ) ; row . setContentTransformationAmount ( _NUM , false ) ; } 
3328	public static ReleasableInputStream wrap ( InputStream is ) { if ( is instanceof ReleasableInputStream ) { already wrapped return ( ReleasableInputStream ) is ; } if ( is instanceof FileInputStream ) { return ResettableInputStream . newResettableInputStream ( ( FileInputStream ) is ) ; } return new ReleasableInputStream ( is ) ; } 
3329	public ComponentAnimation createAnimateHierarchy ( final int duration ) { return animateHierarchy ( duration , false , _NUM _NUM _NUM , false ) ; } 
3330	public int compareTo ( Object o ) { int result ; int major ; int minor ; int revision ; int [ ] maj = new int [ _NUM ] ; int [ ] min = new int [ _NUM ] ; int [ ] rev = new int [ _NUM ] ; do we have a string ? if ( o instanceof String ) { parseVersion ( ( String ) o , maj , min , rev ) ; major = maj [ _NUM ] ; minor = min [ _NUM ] ; revision = rev [ _NUM ] ; } else { System . out . println ( this . getClass ( ) . getName ( ) + _STR ) ; major = - _NUM ; minor = - _NUM ; revision = - _NUM ; } if ( MAJOR < major ) { result = - _NUM ; } else if ( MAJOR = = major ) { if ( MINOR < minor ) { result = - _NUM ; } else if ( MINOR = = minor ) { if ( REVISION < revision ) { result = - _NUM ; } else if ( REVISION = = revision ) { result = _NUM ; } else { result = _NUM ; } } else { result = _NUM ; } } else { result = _NUM ; } return result ; } 
3331	public R proceed ( final T _NUM param _NUM , final T _NUM param _NUM , final T _NUM param _NUM ) { return fn . apply ( param _NUM , param _NUM , param _NUM ) ; } 
3332	private List < UserGroupInformation > parseUserList ( URI userUri , Configuration conf ) throws IOException { if ( null = = userUri ) { return Collections . emptyList ( ) ; } final Path userloc = new Path ( userUri . toString ( ) ) ; final Text rawUgi = new Text ( ) ; final FileSystem fs = userloc . getFileSystem ( conf ) ; final ArrayList < UserGroupInformation > ugiList = new ArrayList < UserGroupInformation > ( ) ; LineReader in = null ; try { in = new LineReader ( fs . open ( userloc ) ) ; while ( in . readLine ( rawUgi ) > _NUM ) { line is of the form username [ , group ] * if ( rawUgi . toString ( ) . trim ( ) . equals ( _STR , ioe ) ; } if ( ugi ! = null ) { ugiList . add ( ugi ) ; } No need to parse groups , even if they exist . Go to next line } } finally { if ( in ! = null ) { in . close ( ) ; } } return ugiList ; } 
3333	private Expr index ( final CompileContext cc , final Value rt ) throws QueryException { skip optimization if path does not start with document nodes if ( cc . nestedFocus ( ) | | rt ! = null & & rt . type ! = NodeType . DOC ) return this ; cache index access costs IndexInfo index = null ; cheapest predicate and step int indexPred = _NUM , indexStep = _NUM ; check if path can be converted to an index access final Data data = rt ! = null ? rt . data ( ) : null ; final int sl = steps . length ; for ( int s = _NUM ; s < sl ; s + + ) { only accept descendant steps without positional predicates Example for position predicate : child : x [ _NUM ] ! = parent : : x [ _NUM ] final Step step = axisStep ( s ) ; if ( step = = null | | ! step . axis . down | | step . positional ( ) ) break ; final int el = step . exprs . length ; if ( el > _NUM ) { check if path is iterable ( i . e . , will be duplicate - free ) final boolean iter = pathNodes ( data , s ) ! = null ; final IndexDb db = data ! = null ? new IndexStaticDb ( data , iter , info ) : new IndexDynDb ( info , iter , root = = null ? new ContextValue ( info ) : root ) ; choose cheapest index access for ( int e = _NUM ; e < el ; e + + ) { final IndexInfo ii = new IndexInfo ( db , cc . qc , step ) ; if ( ! step . exprs [ e ] . indexAccessible ( ii ) ) continue ; if ( ii . costs . results ( ) = = _NUM ) { no results . . . cc . info ( OPTNORESULTS _ X , ii . step ) ; return Empty . SEQ ; } if ( index = = null | | index . costs . compareTo ( ii . costs ) > _NUM ) { index = ii ; indexPred = e ; indexStep = s ; } } } } skip rewriting if no index access is possible , or if it is too expensive if ( index = = null | | data ! = null & & index . costs . tooExpensive ( data ) ) return this ; rewrite for index access cc . info ( index . optInfo ) ; invert steps that occur before index step and add them as predicate final ExprList newPreds = new ExprList ( ) ; final Test rootTest = InvDocTest . get ( rt ) ; final ExprList invSteps = new ExprList ( ) ; if ( rootTest ! = KindTest . DOC | | data = = null | | ! data . meta . uptodate | | predSteps ( data , indexStep ) ) { for ( int s = indexStep ; s > = _NUM ; s - - ) { final Axis invAxis = axisStep ( s ) . axis . invert ( ) ; if ( s = = _NUM ) { add document test for collections and axes other than ancestors if ( rootTest ! = KindTest . DOC | | invAxis ! = ANC & & invAxis ! = ANCORSELF ) invSteps . add ( Step . get ( info , invAxis , rootTest ) ) ; } else { final Step prevStep = axisStep ( s - _NUM ) ; final Axis newAxis = prevStep . axis = = ATTR ? ATTR : invAxis ; invSteps . add ( Step . get ( info , newAxis , prevStep . test , prevStep . exprs ) ) ; } } } if ( ! invSteps . isEmpty ( ) ) newPreds . add ( get ( info , null , invSteps . finish ( ) ) ) ; add remaining predicates final Expr [ ] preds = index . step . exprs ; final int pl = preds . length ; for ( int p = _NUM ; p < pl ; p + + ) { if ( p ! = indexPred ) newPreds . add ( preds [ p ] ) ; } create resulting expression final ExprList resultSteps = new ExprList ( ) ; final Expr resultRoot ; if ( index . expr instanceof Path ) { final Path path = ( Path ) index . expr ; resultRoot = path . root ; resultSteps . add ( path . steps ) ; } else { resultRoot = index . expr ; } only one hit : update sequence type if ( index . costs . results ( ) = = _NUM ) { final Occ occ = resultRoot instanceof IndexAccess ? Occ . ONE : Occ . ZERO _ ONE ; ( ( ParseExpr ) resultRoot ) . exprType . assign ( occ ) ; } if ( ! newPreds . isEmpty ( ) ) { int ls = resultSteps . size ( ) - _NUM ; final Step step ; if ( ls < _NUM | | ! ( resultSteps . get ( ls ) instanceof Step ) ) { add at least one self axis step step = Step . get ( info , SELF , KindTest . NOD ) ; ls + + ; } else { step = ( Step ) resultSteps . get ( ls ) ; } add remaining predicates to last step resultSteps . set ( ls , step . addPreds ( newPreds . finish ( ) ) ) ; } add remaining steps for ( int s = indexStep + _NUM ; s < sl ; s + + ) resultSteps . add ( steps [ s ] ) ; return resultSteps . isEmpty ( ) ? resultRoot : get ( info , resultRoot , resultSteps . finish ( ) ) ; } 
3334	public AuthenticationResult unwrapTokenBasedSyntheticPassword ( IGateKeeperService gatekeeper , long handle , byte [ ] token , int userId ) throws RemoteException { AuthenticationResult result = new AuthenticationResult ( ) ; byte [ ] secdiscardable = loadSecdiscardable ( handle , userId ) ; int slotId = loadWeaverSlot ( handle , userId ) ; if ( slotId ! = INVALID _ WEAVER _ SLOT ) { if ( ! isWeaverAvailable ( ) ) { Log . e ( TAG , _STR ) ; result . gkResponse = VerifyCredentialResponse . ERROR ; return result ; } secdiscardable = SyntheticPasswordCrypto . decrypt ( response . getPayload ( ) , PERSONALISATION _ WEAVER _ TOKEN , secdiscardable ) ; } byte [ ] applicationId = transformUnderSecdiscardable ( token , secdiscardable ) ; result . authToken = unwrapSyntheticPasswordBlob ( handle , SYNTHETIC _ PASSWORD _ TOKEN _ BASED , applicationId , userId ) ; if ( result . authToken ! = null ) { result . gkResponse = verifyChallenge ( gatekeeper , result . authToken , _NUM L , userId ) ; if ( result . gkResponse = = null ) { The user currently has no password . return OK with null payload so null is propagated to unlockUser ( ) result . gkResponse = VerifyCredentialResponse . OK ; } } else { result . gkResponse = VerifyCredentialResponse . ERROR ; } return result ; } 
3335	public XMLInputStream newXMLInputStream ( XmlOptions options ) { XmlCursor cur = newCursorForce ( ) ; try { return cur . newXMLInputStream ( makeInnerOptions ( options ) ) ; } finally { cur . dispose ( ) ; } } 
3336	public static String [ ] getEntailing ( String verb ) { Synset synset = getCommonSynset ( verb , VERB ) ; if ( synset = = null ) return null ; Synset [ ] entailing = getEntailingSynsets ( synset ) ; if ( entailing = = null ) return null ; return getLemmas ( entailing ) ; } 
3337	public static void info ( final Logger logger , final String pattern , final char argument ) { if ( logger . isInfoEnabled ( ) ) { forcedLog ( logger , Level . INFO , format ( pattern , valueOf ( argument ) ) ) ; } } 
3338	public static String getSecretHash ( String userId , String clientId , String clientSecret ) { Arguments userId and clientId have to be not - null . if ( userId = = null ) { throw new CognitoParameterInvalidException ( _STR ) ; } } 
3339	public void toFilesRename _ AllowOverwrite _ MultipleFiles _ AllOutputFilesExist ( ) throws IOException { set up File sourceFile = new File ( _STR ) ; File fileThatExists _NUM = makeRenamedFile ( originalFile _NUM , rename ) ; File fileThatExists _NUM = makeRenamedFile ( originalFile _NUM , rename ) ; copy the image to a temporary file . TestUtils . copyFile ( sourceFile , originalFile _NUM ) ; TestUtils . copyFile ( sourceFile , originalFile _NUM ) ; TestUtils . copyFile ( sourceFile , fileThatExists _NUM ) ; TestUtils . copyFile ( sourceFile , fileThatExists _NUM ) ; given when Thumbnails . of ( originalFile _NUM , originalFile _NUM ) . size ( _NUM _NUM _NUM , _NUM _NUM _NUM ) . allowOverwrite ( true ) . toFiles ( rename ) ; then assertTrue ( fileThatExists _NUM . exists ( ) ) ; assertTrue ( fileThatExists _NUM . exists ( ) ) ; assertFalse ( sourceFile . length ( ) = = fileThatExists _NUM . length ( ) ) ; assertFalse ( sourceFile . length ( ) = = fileThatExists _NUM . length ( ) ) ; clean up originalFile _NUM . delete ( ) ; originalFile _NUM . delete ( ) ; fileThatExists _NUM . delete ( ) ; fileThatExists _NUM . delete ( ) ; } 
3340	ReplicaInfo resolveDuplicateReplicas ( final ReplicaInfo replica _NUM , final ReplicaInfo replica _NUM , final ReplicaMap volumeMap ) throws IOException { if ( ! deleteDuplicateReplicas ) { Leave both block replicas in place . return replica _NUM ; } final ReplicaInfo replicaToDelete = selectReplicaToDelete ( replica _NUM , replica _NUM ) ; final ReplicaInfo replicaToKeep = ( replicaToDelete ! = replica _NUM ) ? replica _NUM : replica _NUM ; Update volumeMap and delete the replica volumeMap . add ( bpid , replicaToKeep ) ; if ( replicaToDelete ! = null ) { deleteReplica ( replicaToDelete ) ; } return replicaToKeep ; } 
3341	private byte [ ] getAlways ( ImmutableBytesPtr key ) { byte [ ] value = null ; int bucketIndex = getBucketIndex ( key ) ; MappedByteBufferMap byteMap = directory [ bucketIndex ] ; if ( directory [ curMapBufferIndex ] . pageIndex ! = byteMap . pageIndex ) { MappedByteBufferMap curByteMap = directory [ curMapBufferIndex ] ; ensure consistency and flush current memory page to disk curByteMap . flushBuffer ( ) ; byteMap . pageIn ( ) ; curMapBufferIndex = bucketIndex ; } get KV from current queue value = byteMap . getPagedInElement ( key ) ; return value ; } 
3342	public void enableAllClassDependencies ( ) { for ( Capability cap : Capability . values ( ) ) { if ( cap . isClass ( ) ) enableDependency ( cap ) ; } } 
3343	public String buildUserInformation ( ) { StringBuffer result = new StringBuffer ( _NUM _NUM _NUM ) ; CmsUser user = getSettings ( ) . getUser ( ) ; result . append ( _STR ) ; return result . toString ( ) ; } 
3344	public void activateOptions ( ) throws FlumeException { try { final Properties properties = getProperties ( hosts , selector , maxBackoff , getTimeout ( ) ) ; rpcClient = RpcClientFactory . getInstance ( properties ) ; if ( layout ! = null ) { layout . activateOptions ( ) ; } configured = true ; } catch ( Exception e ) { String errormsg = _STR + e . getMessage ( ) ; LogLog . error ( errormsg ) ; if ( getUnsafeMode ( ) ) { return ; } throw new FlumeException ( e ) ; } initializeClientAddress ( ) ; } 
3345	protected void doSetRequestData ( RequestBuilder rb , String data ) { rb . setRequestData ( data ) ; } 
3346	public void setPhotoViewRotation ( float rotationDegree ) { mAttacher . setRotationTo ( rotationDegree ) ; } 
3347	public void setImageState ( int [ ] state , boolean merge ) { mState = state ; mMergeState = merge ; if ( mDrawable ! = null ) { refreshDrawableState ( ) ; resizeFromDrawable ( ) ; } } 
3348	boolean expandGroup ( int groupPos ) { ExpandableListPosition elGroupPos = ExpandableListPosition . obtain ( ExpandableListPosition . GROUP , groupPos , - _NUM , - _NUM ) ; PositionMetadata pm = getFlattenedPos ( elGroupPos ) ; elGroupPos . recycle ( ) ; boolean retValue = expandGroup ( pm ) ; pm . recycle ( ) ; return retValue ; } 
3349	public XWPFParagraph insertNewParagraph ( final XmlCursor cursor ) { if ( ! isCursorInTableCell ( cursor ) ) { return null ; } String uri = CTP . type . getName ( ) . getNamespaceURI ( ) ; String localPart = _STR ; cursor . beginElement ( localPart , uri ) ; cursor . toParent ( ) ; CTP p = ( CTP ) cursor . getObject ( ) ; XWPFParagraph newP = new XWPFParagraph ( p , this ) ; XmlObject o = null ; while ( ! ( o instanceof CTP ) & & ( cursor . toPrevSibling ( ) ) ) { o = cursor . getObject ( ) ; } if ( ( ! ( o instanceof CTP ) ) | | o = = p ) { paragraphs . add ( _NUM , newP ) ; } else { int pos = paragraphs . indexOf ( getParagraph ( ( CTP ) o ) ) + _NUM ; paragraphs . add ( pos , newP ) ; } int i = _NUM ; XmlCursor p _NUM = p . newCursor ( ) ; cursor . toCursor ( p _NUM ) ; p _NUM . dispose ( ) ; while ( cursor . toPrevSibling ( ) ) { o = cursor . getObject ( ) ; if ( o instanceof CTP | | o instanceof CTTbl ) i + + ; } bodyElements . add ( i , newP ) ; p _NUM = p . newCursor ( ) ; cursor . toCursor ( p _NUM ) ; p _NUM . dispose ( ) ; cursor . toEndToken ( ) ; return newP ; } 
3350	public static long readLong ( InputStream stream ) throws IOException , BufferUnderrunException { int ch _NUM = stream . read ( ) ; int ch _NUM = stream . read ( ) ; int ch _NUM = stream . read ( ) ; int ch _NUM = stream . read ( ) ; int ch _NUM = stream . read ( ) ; int ch _NUM = stream . read ( ) ; int ch _NUM = stream . read ( ) ; int ch _NUM = stream . read ( ) ; if ( ( ch _NUM | ch _NUM | ch _NUM | ch _NUM | ch _NUM | ch _NUM | ch _NUM | ch _NUM ) < _NUM ) { throw new BufferUnderrunException ( ) ; } return ( ( long ) ch _NUM < < _NUM _NUM ) + ( ( long ) ch _NUM < < _NUM _NUM ) + ( ( long ) ch _NUM < < _NUM _NUM ) + ( ( long ) ch _NUM < < _NUM _NUM ) + cast to long to preserve bit _NUM _NUM ( ( long ) ch _NUM < < _NUM _NUM ) + ( sign bit for ints ) ( ch _NUM < < _NUM _NUM ) + ( ch _NUM < < _NUM ) + ( ch _NUM < < _NUM ) ; } 
3351	public boolean isDone ( AppliedPTransform < ? , ? , ? > transform ) { the PTransform is done only if watermark is at the max value Instant stepWatermark = watermarkManager . getWatermarks ( transform ) . getOutputWatermark ( ) ; return ! stepWatermark . isBefore ( BoundedWindow . TIMESTAMP _ MAX _ VALUE ) ; } 
3352	public static State configToState ( Config config ) { return new State ( configToProperties ( config ) ) ; } 
3353	public void titleChanged ( TitleChangeEvent event ) { event . setChart ( this ) ; notifyListeners ( event ) ; } 
3354	private void handleConfigurationChanged ( Context context ) { try { reading new orientation _STR , e ) ; } } 
3355	public void setDateCreatedStart ( long createdStart ) { m _ controller . addDateCreatedStart ( createdStart ) ; } 
3356	private void testQueryFirstWithWhereClause ( int shardId , DalHints oldhints ) throws SQLException { DalHints hints ; ClientTestModel model = null ; for ( int i = _NUM ; i < tableMod ; i + + ) { String whereClause = _STR , Types . SMALLINT , shardId ) ; model = dao . queryFirst ( whereClause , parameters , hints ) ; model = assertModel ( model , hints ) ; assertQueryFirstWithWhereClause ( shardId , model , i ) ; } } 
3357	public static Map < String , Path > getTableStoreFilePathMap ( Map < String , Path > resultMap , final FileSystem fs , final Path hbaseRootDir , TableName tableName , final PathFilter sfFilter , ExecutorService executor , final ErrorReporter errors ) throws IOException , InterruptedException { final Map < String , Path > finalResultMap = resultMap = = null ? new ConcurrentHashMap < > ( _NUM _NUM _NUM , _NUM . _NUM _NUM f , _NUM _NUM ) : resultMap ; only include the directory paths to tables Path tableDir = FSUtils . getTableDir ( hbaseRootDir , tableName ) ; Inside a table , there are compaction . dir directories to skip . Otherwise , all else should be regions . final FamilyDirFilter familyFilter = new FamilyDirFilter ( fs ) ; final Vector < Exception > exceptions = new Vector < > ( ) ; try { List < FileStatus > regionDirs = FSUtils . listStatusWithStatusFilter ( fs , tableDir , new RegionDirFilter ( fs ) ) ; if ( regionDirs = = null ) { return finalResultMap ; } final List < Future < ? > > futures = new ArrayList < > ( regionDirs . size ( ) ) ; for ( FileStatus regionDir : regionDirs ) { if ( null ! = errors ) { errors . progress ( ) ; } final Path dd = regionDir . getPath ( ) ; if ( ! exceptions . isEmpty ( ) ) { break ; } Runnable getRegionStoreFileMapCall = new Runnable ( ) { @ Override public void run ( ) { try { HashMap < String , Path > regionStoreFileMap = new HashMap < > ( ) ; List < FileStatus > familyDirs = FSUtils . listStatusWithStatusFilter ( fs , dd , familyFilter ) ; if ( familyDirs = = null ) { if ( ! fs . exists ( dd ) ) { LOG . warn ( _STR + tableName , e ) ; exceptions . add ( e ) ; } finally { if ( ! exceptions . isEmpty ( ) ) { Just throw the first exception as an indication something bad happened Don ' t need to propagate all the exceptions , we already logged them all anyway Throwables . propagateIfInstanceOf ( exceptions . firstElement ( ) , IOException . class ) ; throw Throwables . propagate ( exceptions . firstElement ( ) ) ; } } return finalResultMap ; } 
3358	public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( _STR ) ; return sb . toString ( ) ; } 
3359	public static boolean installApk ( InputStream instream , PackageManager packageManager , RestoreInstallObserver installObserver , RestoreDeleteObserver deleteObserver , HashMap < String , Signature [ ] > manifestSignatures , HashMap < String , RestorePolicy > packagePolicies , FileMetadata info , String installerPackage , BytesReadListener bytesReadListener , File dataDir ) { boolean okay = true ; if ( DEBUG ) { Slog . d ( TAG , _STR ) ; okay = false ; } finally { apkFile . delete ( ) ; } return okay ; } 
3360	public Type _NUM CharString getType _NUM CharString ( String name ) throws IOException { lookup via charset int gid = nameToGID ( name ) ; lookup in CharStrings INDEX return getType _NUM CharString ( gid , name ) ; } 
3361	public PreDiffPlan prepareForDiffing ( ) throws IOException { PreDiffPlan preDiffPlan = generatePreDiffPlan ( ) ; List < TypedRange < JreDeflateParameters > > deltaFriendlyNewFileRecompressionPlan = null ; if ( deltaFriendlyOldFile ! = null ) { Builder . writingDeltaFriendlyFiles ( ) ensures old and new are non - null when called , so a check on either is sufficient . deltaFriendlyNewFileRecompressionPlan = Collections . unmodifiableList ( generateDeltaFriendlyFiles ( preDiffPlan ) ) ; } return new PreDiffPlan ( preDiffPlan . getQualifiedRecommendations ( ) , preDiffPlan . getOldFileUncompressionPlan ( ) , preDiffPlan . getNewFileUncompressionPlan ( ) , deltaFriendlyNewFileRecompressionPlan ) ; } 
3362	public void startThreads ( ) throws IOException { Preconditions . checkState ( ! running ) ; updateCurrentKey ( ) ; synchronized ( this ) { running = true ; tokenRemoverThread = new Daemon ( new ExpiredTokenRemover ( ) ) ; tokenRemoverThread . start ( ) ; } } 
3363	private boolean isNextLineValueLine ( final ReaderHelper reader ) throws IOException { if ( reader . hasNext ( ) = = false ) { return false ; } final String firstLine = reader . next ( ) ; if ( firstLine = = null ) { return false ; } if ( parseKey ( firstLine ) ! = null ) { reader . pushBack ( firstLine ) ; return false ; } reader . pushBack ( firstLine ) ; return true ; } 
3364	public static CommandLine parseArgs ( final GiraphConfiguration giraphConf , final String [ ] args ) throws ClassNotFoundException , ParseException , IOException { verify we have args at all ( can ' t run without them ! ) if ( args . length = = _NUM ) { throw new IllegalArgumentException ( _STR ) GiraphConfigurationValidator < ? , ? , ? , ? , ? > gtv = new GiraphConfigurationValidator ( giraphConf ) ; gtv . validateConfiguration ( ) ; successfully populated / validated GiraphConfiguration , ready to run job return cmd ; } 
3365	boolean isHealthy ( ) { return ( ( missingIds . size ( ) = = _NUM ) & & ( corruptBlocks = = _NUM ) ) ; } 
3366	protected static void verifyJavaAndJavadocAst ( String expectedTextPrintFilename , String actualJavaFilename ) throws Exception { final String expectedContents = readFile ( expectedTextPrintFilename ) ; final String actualContents = AstTreeStringPrinter . printJavaAndJavadocTree ( new File ( actualJavaFilename ) ) . replaceAll ( CRLF _ REGEX , LF _ REGEX ) ; assertEquals ( _STR , expectedContents , actualContents ) ; } 
3367	private void correctPositionByDefaultValue ( int defaultPickedIndex , boolean wrap ) { mCurrDrawFirstItemIndex = defaultPickedIndex - ( mShowCount - _NUM ) / _NUM ; mCurrDrawFirstItemIndex = getIndexByRawIndex ( mCurrDrawFirstItemIndex , getOneRecycleSize ( ) , wrap ) ; if ( mItemHeight = = _NUM ) { mCurrentItemIndexEffect = true ; } else { mCurrDrawGlobalY = mCurrDrawFirstItemIndex * mItemHeight ; mInScrollingPickedOldValue = mCurrDrawFirstItemIndex + mShowCount / _NUM ; mInScrollingPickedOldValue = mInScrollingPickedOldValue % getOneRecycleSize ( ) ; if ( mInScrollingPickedOldValue < _NUM ) { mInScrollingPickedOldValue = mInScrollingPickedOldValue + getOneRecycleSize ( ) ; } mInScrollingPickedNewValue = mInScrollingPickedOldValue ; calculateFirstItemParameterByGlobalY ( ) ; } } 
3368	public Writer write ( Writer writer ) throws JSONException { try { boolean b = false ; int len = length ( ) ; writer . write ( ' [ ' ) ; for ( int i = _NUM ; i < len ; i + = _NUM ) { if ( b ) { writer . write ( ' , ' ) ; } Object v = this . myArrayList . get ( i ) ; if ( v instanceof JSONObject ) { ( ( JSONObject ) v ) . write ( writer ) ; } else if ( v instanceof JSONArray ) { ( ( JSONArray ) v ) . write ( writer ) ; } else { writer . write ( JSONObject . valueToString ( v ) ) ; } b = true ; } writer . write ( ' ] ' ) ; return writer ; } catch ( IOException e ) { throw new JSONException ( e ) ; } } 
3369	public Tag createTagNode ( Page arg _NUM , int arg _NUM , int arg _NUM , Vector arg _NUM ) { try { String tagName = ( ( Attribute ) arg _NUM . get ( _NUM ) ) . getName ( ) . toLowerCase ( ) ; end tags have names like _STR . . . . if ( tagName . charAt ( _NUM ) = = ' / ' ) { tagName = tagName . substring ( _NUM ) ; } Tag result = super . createTagNode ( arg _NUM , arg _NUM , arg _NUM , arg _NUM ) ; if ( ! keepTag ( tagName ) ) { result = new CmsInvisibleTag ( result ) ; } return result ; } catch ( RuntimeException rte ) { if ( LOG . isErrorEnabled ( ) ) { log here , as htmlparser _NUM . _NUM did swallow exceptions from here and threw NPEs from other places LOG . error ( rte ) ; } throw rte ; } } 
3370	public Set < String > keys ( ) { return Configuration . this . keys ( ) ; } @ Override public String getString ( String key ) { return mapper . apply ( key , Configuration . this . getString ( key ) ) ; } @ Override public String toString ( ) { return withMaskedPasswords ( ) . asProperties ( ) . toString ( ) ; } } ; } 
3371	 @ SuppressWarnings ( _STR + this . mBluetoothEventReceiver ) ; } } 
3372	private void doAbort ( ) { try { close ( ) ; } catch ( final IOException e ) { expected from some implementations because the stream is closed LogFactory . getLog ( getClass ( ) ) . debug ( _STR , e ) ; } } 
3373	public void testCustomClaimDialect ( ) throws Exception { TokenIssueOperation issueOperation = new TokenIssueOperation ( ) ; Add Token Provider addTokenProvider ( issueOperation ) ; Add Service addService ( issueOperation ) ; Add STSProperties object addSTSProperties ( issueOperation ) ; Set the ClaimsManager ClaimsManager claimsManager = new ClaimsManager ( ) ; ClaimsHandler claimsHandler = new CustomClaimsHandler ( ) ; ClaimsParser claimsParser = new CustomClaimParser ( ) ; claimsManager . setClaimParsers ( Collections . singletonList ( claimsParser ) ) ; claimsManager . setClaimHandlers ( Collections . singletonList ( claimsHandler ) ) ; issueOperation . setClaimsManager ( claimsManager ) ; Mock up a request RequestSecurityTokenType request = new RequestSecurityTokenType ( ) ; JAXBElement < String > tokenType = new JAXBElement < String > ( QNameConstants . TOKEN _ TYPE , String . class , WSS _NUM JConstants . WSS _ SAML _NUM _ TOKEN _ TYPE ) ; request . getAny ( ) . add ( tokenType ) ; Element secondaryParameters = createCustomSecondaryParameters ( ) ; request . getAny ( ) . add ( secondaryParameters ) ; request . getAny ( ) . add ( createAppliesToElement ( _STR ) ) ; } 
3374	public org . apache . phoenix . coprocessor . generated . PFunctionProtos . PFunctionArg . Builder addArgumentsBuilder ( ) { return getArgumentsFieldBuilder ( ) . addBuilder ( org . apache . phoenix . coprocessor . generated . PFunctionProtos . PFunctionArg . getDefaultInstance ( ) ) ; } 
3375	public void testRandomCompressedTextDataGenerator ( ) throws Exception { int wordSize = _NUM _NUM ; int listSize = _NUM _NUM ; long dataSize = _NUM _NUM * _NUM _NUM _NUM _NUM * _NUM _NUM _NUM _NUM ; Configuration conf = new Configuration ( ) ; CompressionEmulationUtil . setCompressionEmulationEnabled ( conf , true ) ; CompressionEmulationUtil . setInputCompressionEmulationEnabled ( conf , true ) ; configure the RandomTextDataGenerator to generate desired sized data conf . setInt ( RandomTextDataGenerator . GRIDMIX _ DATAGEN _ RANDOMTEXT _ LISTSIZE , listSize ) ; conf . setInt ( RandomTextDataGenerator . GRIDMIX _ DATAGEN _ RANDOMTEXT _ WORDSIZE , wordSize ) ; conf . setLong ( GenerateData . GRIDMIX _ GEN _ BYTES , dataSize ) ; conf . set ( _STR ) ) { size + = word . getBytes ( ) . length ; } line = reader . readLine ( ) ; } } reader . close ( ) ; } assertTrue ( size > = dataSize ) ; assertTrue ( size < = dataSize + maxLineSize ) ; } 
3376	public static byte [ ] getBarsUPCE ( String _ code ) { int [ ] code = new int [ _ code . length ( ) ] ; for ( int k = _NUM ; k < code . length ; + + k ) code [ k ] = _ code . charAt ( k ) - ' _NUM ' ; byte [ ] bars = new byte [ TOTALBARS _ UPCE ] ; boolean flip = ( code [ _NUM ] ! = _NUM ) ; int pb = _NUM ; bars [ pb + + ] = _NUM ; bars [ pb + + ] = _NUM ; bars [ pb + + ] = _NUM ; byte [ ] sequence = PARITYE [ code [ code . length - _NUM ] ] ; for ( int k = _NUM ; k < code . length - _NUM ; + + k ) { int c = code [ k ] ; byte [ ] stripes = BARS [ c ] ; if ( sequence [ k - _NUM ] = = ( flip ? EVEN : ODD ) ) { bars [ pb + + ] = stripes [ _NUM ] ; bars [ pb + + ] = stripes [ _NUM ] ; bars [ pb + + ] = stripes [ _NUM ] ; bars [ pb + + ] = stripes [ _NUM ] ; } else { bars [ pb + + ] = stripes [ _NUM ] ; bars [ pb + + ] = stripes [ _NUM ] ; bars [ pb + + ] = stripes [ _NUM ] ; bars [ pb + + ] = stripes [ _NUM ] ; } } bars [ pb + + ] = _NUM ; bars [ pb + + ] = _NUM ; bars [ pb + + ] = _NUM ; bars [ pb + + ] = _NUM ; bars [ pb + + ] = _NUM ; bars [ pb + + ] = _NUM ; return bars ; } 
3377	public void toFilesRename _ DisallowOverwrite _ MultipleFiles _ AllOutputFilesDoNotExist ( ) throws IOException { set up File sourceFile = new File ( _STR ) ; File fileThatDoesntExist _NUM = makeRenamedFile ( originalFile _NUM , rename ) ; File fileThatDoesntExist _NUM = makeRenamedFile ( originalFile _NUM , rename ) ; copy the image to a temporary file . TestUtils . copyFile ( sourceFile , originalFile _NUM ) ; TestUtils . copyFile ( sourceFile , originalFile _NUM ) ; given when Thumbnails . of ( originalFile _NUM , originalFile _NUM ) . size ( _NUM _NUM _NUM , _NUM _NUM _NUM ) . allowOverwrite ( false ) . toFiles ( rename ) ; then assertTrue ( fileThatDoesntExist _NUM . exists ( ) ) ; assertTrue ( fileThatDoesntExist _NUM . exists ( ) ) ; clean up originalFile _NUM . delete ( ) ; originalFile _NUM . delete ( ) ; fileThatDoesntExist _NUM . delete ( ) ; fileThatDoesntExist _NUM . delete ( ) ; } 
3378	protected boolean isAcceptableParameter ( String name , Object action ) { ParameterNameAware parameterNameAware = ( action instanceof ParameterNameAware ) ? ( ParameterNameAware ) action : null ; return acceptableName ( name ) & & ( parameterNameAware = = null | | parameterNameAware . acceptableParameterName ( name ) ) ; } 
3379	public void testEqual ( ) { ResolutionNode a _NUM n = createResolutionNode ( a _NUM ) ; ResolutionNode a _NUM n = createResolutionNode ( a _NUM ) ; assertResolveConflict ( a _NUM n , a _NUM n , a _NUM n ) ; } 
3380	public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( _STR ) ; return sb . toString ( ) ; } 
3381	public void logRowCountPerLeaf ( Logger logger ) { for ( MerkleTree tree : merkleTrees . values ( ) ) { tree . histogramOfRowCountPerLeaf ( ) . log ( logger ) ; } } 
3382	public void setColor ( String rgbStr ) { CTRPr pr = run . isSetRPr ( ) ? run . getRPr ( ) : run . addNewRPr ( ) ; CTColor color = pr . isSetColor ( ) ? pr . getColor ( ) : pr . addNewColor ( ) ; color . setVal ( rgbStr ) ; } 
3383	public String dump ( ) { StringBuffer sb = new StringBuffer ( ) ; for ( GraphNode n : nodeMap . values ( ) ) { sb . append ( n . dump ( ) ) ; sb . append ( _STR ) ; } return sb . toString ( ) ; } 
3384	public static XmlAnySimpleType parse ( org . apache . xmlbeans . xml . stream . XMLInputStream xis , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , org . apache . xmlbeans . xml . stream . XMLStreamException { return ( XmlAnySimpleType ) XmlBeans . getContextTypeLoader ( ) . parse ( xis , type , options ) ; } 
3385	private void readModuleInfo ( final ReaderHelper reader ) throws IOException { while ( reader . hasNext ( ) ) { final String lastLineRead = reader . next ( ) ; if ( Character . isWhitespace ( lastLineRead . charAt ( _NUM ) ) = = false ) { break if the current character is no whitespace . . . reader . pushBack ( lastLineRead ) ; return ; } final String line = lastLineRead . trim ( ) ; final String key = parseKey ( line ) ; if ( key ! = null ) { parse error : Non data line does not contain a colon final String b = readValue ( reader , parseValue ( line . trim ( ) ) ) ; if ( _STR . equals ( key ) ) { setPatchLevel ( b ) ; } } } } 
3386	public Iter iter ( ) throws QueryException { parse ( ) ; return qc . iter ( ) ; } 
3387	public static SmsMessage [ ] getMessagesFromIntent ( Intent intent ) { Object [ ] messages ; try { messages = ( Object [ ] ) intent . getSerializableExtra ( _STR + subId ) ; int pduCount = messages . length ; SmsMessage [ ] msgs = new SmsMessage [ pduCount ] ; for ( int i = _NUM ; i < pduCount ; i + + ) { byte [ ] pdu = ( byte [ ] ) messages [ i ] ; msgs [ i ] = SmsMessage . createFromPdu ( pdu , format ) ; if ( msgs [ i ] ! = null ) msgs [ i ] . setSubId ( subId ) ; } return msgs ; } 
3388	public void tearDown ( ) throws Exception { coll . close ( ) ; dropDB ( ) ; } 
3389	Visible for testing onlystatic Match searchForMatchBaseCase ( final RandomAccessObject groupArray , final RandomAccessObject oldData , final RandomAccessObject newData , final int newStart , final int oldDataRangeStartA , final int oldDataRangeStartB ) throws IOException { Located the start of a matching range ( no further search required ) or the size of the range has shrunk to one byte ( no further search possible ) . groupArray . seekToIntAligned ( oldDataRangeStartA ) ; final int groupArrayOldDataRangeStartA = groupArray . readInt ( ) ; final int lengthOfMatchA = lengthOfMatch ( oldData , groupArrayOldDataRangeStartA , newData , newStart ) ; groupArray . seekToIntAligned ( oldDataRangeStartB ) ; final int groupArrayOldDataRangeStartB = groupArray . readInt ( ) ; final int lengthOfMatchB = lengthOfMatch ( oldData , groupArrayOldDataRangeStartB , newData , newStart ) ; if ( lengthOfMatchA > lengthOfMatchB ) { return Match . of ( groupArrayOldDataRangeStartA , lengthOfMatchA ) ; } return Match . of ( groupArrayOldDataRangeStartB , lengthOfMatchB ) ; } 
3390	public static SchemaValidationType getSchemaValidationType ( Message message ) { SchemaValidationType validationType = getOverrideSchemaValidationType ( message ) ; if ( validationType = = null ) { validationType = getSchemaValidationTypeFromModel ( message ) ; } if ( validationType = = null ) { Object obj = message . getContextualProperty ( Message . SCHEMA _ VALIDATION _ ENABLED ) ; if ( obj ! = null ) { validationType = getSchemaValidationType ( obj ) ; } } if ( validationType = = null ) { validationType = SchemaValidationType . NONE ; } return validationType ; } 
3391	private void reportGeofenceStatus ( int status , Location location ) { if ( mGeofenceHardwareImpl = = null ) { mGeofenceHardwareImpl = GeofenceHardwareImpl . getInstance ( mContext ) ; } int monitorStatus = GeofenceHardware . MONITOR _ CURRENTLY _ UNAVAILABLE ; if ( status = = GPS _ GEOFENCE _ AVAILABLE ) { monitorStatus = GeofenceHardware . MONITOR _ CURRENTLY _ AVAILABLE ; } mGeofenceHardwareImpl . reportGeofenceMonitorStatus ( GeofenceHardware . MONITORING _ TYPE _ GPS _ HARDWARE , monitorStatus , location , FusedBatchOptions . SourceTechnologies . GNSS ) ; } 
3392	 @ POST @ Path ( REINITIALIZE _ FILE ) @ ReturnType ( _STR ) ; return mLineageMaster . reinitializeFile ( path , blockSizeBytes , ttl , ttlAction ) ; } } ) ; } 
3393	public Object input ( String name , Object defaultValue ) { return textbox ( name , defaultValue . toString ( ) , false ) ; } 
3394	public void closeAllInterceptedStreams ( ) { streams . closeAll ( ) ; } 
3395	public void testSeekBugLocalFS ( ) throws IOException { Configuration conf = new HdfsConfiguration ( ) ; FileSystem fileSys = FileSystem . getLocal ( conf ) ; try { Path file _NUM = new Path ( _STR ) ; writeFile ( fileSys , file _NUM ) ; seekReadFile ( fileSys , file _NUM ) ; cleanupFile ( fileSys , file _NUM ) ; } finally { fileSys . close ( ) ; } } 
3396	public Path getLinkTarget ( final Path f ) throws AccessControlException , FileNotFoundException , UnsupportedFileSystemException , IOException { final Path absF = fixRelativePart ( f ) ; return new FSLinkResolver < Path > ( ) { @ Override public Path next ( final AbstractFileSystem fs , final Path p ) throws IOException , UnresolvedLinkException { FileStatus fi = fs . getFileLinkStatus ( p ) ; return fi . getSymlink ( ) ; } } . resolve ( this , absF ) ; } 
3397	public static EndpointReferenceType convertToNative ( Object exposed ) { if ( EndpointReferenceType . class . isInstance ( exposed ) ) { return ( EndpointReferenceType ) exposed ; } else if ( Names _NUM _NUM _NUM _NUM _NUM _NUM . EPR _ TYPE . isInstance ( exposed ) ) { return convert ( ( org . apache . cxf . ws . addressing . v _NUM _NUM _NUM _NUM _NUM _NUM . EndpointReferenceType ) exposed ) ; } else if ( Names _NUM _NUM _NUM _NUM _NUM _NUM . EPR _ TYPE . isInstance ( exposed ) ) { return convert ( ( org . apache . cxf . ws . addressing . v _NUM _NUM _NUM _NUM _NUM _NUM . EndpointReferenceType ) exposed ) ; } return null ; } 
3398	ServerFactoryBean createServerFactoryBean ( ) throws Exception { Class < ? > cls = null ; if ( getDataFormat ( ) = = DataFormat . POJO ) { ObjectHelper . notNull ( getServiceClass ( ) , CxfConstants . SERVICE _ CLASS ) ; } if ( getWsdlURL ( ) = = null & & getServiceClass ( ) = = null ) { no WSDL and serviceClass specified , set our default serviceClass if ( getDataFormat ( ) . equals ( DataFormat . PAYLOAD ) ) { setServiceClass ( org . apache . camel . component . cxf . DefaultPayloadProviderSEI . class . getName ( ) ) ; } } if ( getServiceClass ( ) ! = null ) { cls = getServiceClass ( ) ; } create server factory bean Shouldn ' t use CxfEndpointUtils . getServerFactoryBean ( cls ) as it is for CxfSoapComponent ServerFactoryBean answer = null ; if ( cls = = null ) { checkName ( portName , _STR ) ; answer = new JaxWsServerFactoryBean ( new WSDLServiceFactoryBean ( ) ) { { doInit = false ; } } ; cls = Provider . class ; } else if ( CxfEndpointUtils . hasWebServiceAnnotation ( cls ) ) { answer = new JaxWsServerFactoryBean ( ) ; } else { answer = new ServerFactoryBean ( ) ; } setup server factory bean setupServerFactoryBean ( answer , cls ) ; return answer ; } 
3399	public void open ( ) { openDrawer ( ) ; invalidate ( ) ; requestLayout ( ) ; sendAccessibilityEvent ( AccessibilityEvent . TYPE _ WINDOW _ STATE _ CHANGED ) ; } 
3400	public boolean contains ( String throwableClassName ) { return getCause ( throwableClassName ) ! = null ; } 
3401	private boolean checkAllBytesParsed ( ) throws IOException { - _NUM means the wal wasn ' t closed cleanly . final long trailerSize = currentTrailerSize ( ) ; FileStatus stat = null ; try { stat = fs . getFileStatus ( this . currentPath ) ; } catch ( IOException exception ) { LOG . warn ( _STR : stat . getLen ( ) ) ) ; } metrics . incrCompletedWAL ( ) ; return true ; } 
3402	private void handleColumnResizerDragging ( int x ) { int newWidth = resizingColumnStartWidth + ( x - resizingStartX ) ; if ( newWidth < MIN _ COLUMN _ HEADER _ WIDTH ) { newWidth = MIN _ COLUMN _ HEADER _ WIDTH ; } Rectangle clientArea = getClientArea ( ) ; if ( columnScrolling ) { int maxWidth = clientArea . width ; if ( rowHeaderVisible ) maxWidth - = rowHeaderWidth ; if ( newWidth > maxWidth ) newWidth = maxWidth ; } if ( newWidth = = columnBeingResized . getWidth ( ) ) { return ; } columnBeingResized . setWidth ( newWidth , false ) ; scrollValuesObsolete = true ; redraw ( clientArea . x , clientArea . y , clientArea . width , clientArea . height , false ) ; } 
3403	void setAppIdleParoled ( boolean paroled ) { synchronized ( mAppIdleLock ) { final long now = System . currentTimeMillis ( ) ; if ( mAppIdleTempParoled ! = paroled ) { mAppIdleTempParoled = paroled ; if ( DEBUG ) Slog . d ( TAG , _STR + mAppIdleTempParoled ) ; if ( paroled ) { postParoleEndTimeout ( ) ; } else { mLastAppIdleParoledTime = now ; postNextParoleTimeout ( now ) ; } postParoleStateChanged ( ) ; } } } 
3404	private boolean processHandlers ( Collection < ? extends Handler > handlers , String target , Request baseRequest , HttpServletRequest request , HttpServletResponse response ) throws IOException , ServletException { for ( Handler handler : handlers ) { handler . handle ( target , baseRequest , request , response ) ; if ( baseRequest . isHandled ( ) ) { return true ; } } return false ; } 
3405	public Iterator < String > getEntityNamesIterator ( ) throws GenericEntityException { Collection < String > collection = getEntityNames ( ) ; if ( collection ! = null ) { return collection . iterator ( ) ; } else { return null ; } } 
3406	public final IonTextWriterBuilder withInitialIvmHandling ( InitialIvmHandling handling ) { IonTextWriterBuilder b = mutable ( ) ; b . setInitialIvmHandling ( handling ) ; return b ; } 
3407	 < T > T callWithJobClassLoader ( Configuration conf , Action < T > action ) { if the job classloader is enabled , we may need it to load the ( custom ) classes ; we make the job classloader available and unset it once it is done ClassLoader currentClassLoader = conf . getClassLoader ( ) ; boolean setJobClassLoader = jobClassLoader ! = null & & currentClassLoader ! = jobClassLoader ; if ( setJobClassLoader ) { MRApps . setClassLoader ( jobClassLoader , conf ) ; } try { return action . call ( conf ) ; } finally { if ( setJobClassLoader ) { restore the original classloader MRApps . setClassLoader ( currentClassLoader , conf ) ; } } } 
3408	public synchronized void updateIconsForPkg ( String packageName , UserHandleCompat user ) { removeIconsForPkg ( packageName , user ) ; try { PackageInfo info = mPackageManager . getPackageInfo ( packageName , PackageManager . GET _ UNINSTALLED _ PACKAGES ) ; long userSerial = mUserManager . getSerialNumberForUser ( user ) ; for ( LauncherActivityInfoCompat app : mLauncherApps . getActivityList ( packageName , user ) ) { addIconToDBAndMemCache ( app , info , userSerial ) ; } } catch ( NameNotFoundException e ) { Log . d ( TAG , _STR , e ) ; return ; } } 
3409	public Instance getAsInstance ( Instances model , Random random ) throws Exception { Instance newInst = null ; if ( m _ Elements ! = null ) { newInst = new DenseInstance ( model . numAttributes ( ) ) ; newInst . setDataset ( model ) ; for ( int i = _NUM , j = _NUM ; i < model . numAttributes ( ) ; i + + ) { if ( model . attribute ( i ) . isNumeric ( ) ) { if ( j > = m _ Elements . length ) throw new Exception ( _STR ) ; newInst . setValue ( i , m _ Elements [ j + + ] ) ; } if ( model . attribute ( i ) . isNominal ( ) ) { int newVal = ( int ) ( random . nextDouble ( ) * ( double ) ( model . attribute ( i ) . numValues ( ) ) ) ; if ( newVal = = ( int ) model . attribute ( i ) . numValues ( ) ) newVal - = _NUM ; newInst . setValue ( i , newVal ) ; } } } return newInst ; } 
3410	synchronized MyCursorHelper getChildrenCursorHelper ( int groupPosition , boolean requestCursor ) { MyCursorHelper cursorHelper = mChildrenCursorHelpers . get ( groupPosition ) ; if ( cursorHelper = = null ) { if ( mGroupCursorHelper . moveTo ( groupPosition ) = = null ) return null ; final Cursor cursor = getChildrenCursor ( mGroupCursorHelper . getCursor ( ) ) ; cursorHelper = new MyCursorHelper ( cursor ) ; mChildrenCursorHelpers . put ( groupPosition , cursorHelper ) ; } return cursorHelper ; } 
3411	protected int poll ( ) throws Exception { must reset for each poll shutdownRunningTask = null ; pendingExchanges = _NUM ; poll data from the database IBatisEndpoint endpoint = getEndpoint ( ) ; LOG . trace ( _STR , endpoint ) ; List < Object > data = endpoint . getProcessingStrategy ( ) . poll ( this , getEndpoint ( ) ) ; create a list of exchange objects with the data Queue < DataHolder > answer = new LinkedList < DataHolder > ( ) ; if ( useIterator ) { for ( Object item : data ) { Exchange exchange = createExchange ( item ) ; DataHolder holder = new DataHolder ( ) ; holder . exchange = exchange ; holder . data = item ; answer . add ( holder ) ; } } else { if ( ! data . isEmpty ( ) | | routeEmptyResultSet ) { Exchange exchange = createExchange ( data ) ; DataHolder holder = new DataHolder ( ) ; holder . exchange = exchange ; holder . data = data ; answer . add ( holder ) ; } } process all the exchanges in this batch return processBatch ( CastUtils . cast ( answer ) ) ; } 
3412	protected void autoAdjust ( int w , int h ) { if ( autoAdjustDialogSize ) { growOrShrinkImpl ( w , h ) ; } } 
3413	public static String [ ] getPathComponents ( String path ) throws InvalidPathException { path = cleanPath ( path ) ; if ( isRoot ( path ) ) { return new String [ ] { _STR } ; } return path . split ( AlluxioURI . SEPARATOR ) ; } 
3414	public static boolean restrictionsChanged ( Bundle oldRestrictions , Bundle newRestrictions , String . . . restrictions ) { if ( restrictions . length = = _NUM ) { return areEqual ( oldRestrictions , newRestrictions ) ; } for ( final String restriction : restrictions ) { if ( oldRestrictions . getBoolean ( restriction , false ) ! = newRestrictions . getBoolean ( restriction , false ) ) { return true ; } } return false ; } 
3415	private void setHeaderStatusClickToLoad ( ) { if ( currentHeaderStatus ! = HEADER _ STATUS _ CLICK _ TO _ LOAD ) { resetHeaderPadding ( ) ; headerImage . clearAnimation ( ) ; headerImage . setVisibility ( View . GONE ) ; headerProgressBar . setVisibility ( View . GONE ) ; headerText . setText ( headerDefaultText ) ; currentHeaderStatus = HEADER _ STATUS _ CLICK _ TO _ LOAD ; } } 
3416	public void testKMeansSeqJob ( ) throws Exception { DistanceMeasure measure = new EuclideanDistanceMeasure ( ) ; List < VectorWritable > points = getPointsWritable ( REFERENCE ) ; Path pointsPath = getTestTempDirPath ( _STR + k + ' ] ' , expect . length , collector . getKeys ( ) . size ( ) ) ; } } 
3417	public PDFormXObject importPageAsForm ( PDDocument sourceDoc , PDPage page ) throws IOException { importOcProperties ( sourceDoc ) ; PDStream newStream = new PDStream ( targetDoc , page . getContents ( ) , COSName . FLATE _ DECODE ) ; PDFormXObject form = new PDFormXObject ( newStream ) ; Copy resources PDResources pageRes = page . getResources ( ) ; PDResources formRes = new PDResources ( ) ; cloner . cloneMerge ( pageRes , formRes ) ; form . setResources ( formRes ) ; Transfer some values from page to form transferDict ( page . getCOSObject ( ) , form . getCOSObject ( ) , PAGE _ TO _ FORM _ FILTER , true ) ; Matrix matrix = form . getMatrix ( ) ; AffineTransform at = matrix . createAffineTransform ( ) ; PDRectangle mediaBox = page . getMediaBox ( ) ; PDRectangle cropBox = page . getCropBox ( ) ; PDRectangle viewBox = ( cropBox ! = null ? cropBox : mediaBox ) ; Handle the / Rotation entry on the page dict int rotation = page . getRotation ( ) ; Transform to FOP ' s user space at . scale ( _NUM / viewBox . getWidth ( ) , _NUM / viewBox . getHeight ( ) ) ; at . translate ( mediaBox . getLowerLeftX ( ) - viewBox . getLowerLeftX ( ) , mediaBox . getLowerLeftY ( ) - viewBox . getLowerLeftY ( ) ) ; switch ( rotation ) { case _NUM _NUM : at . scale ( viewBox . getWidth ( ) / viewBox . getHeight ( ) , viewBox . getHeight ( ) / viewBox . getWidth ( ) ) ; at . translate ( _NUM , viewBox . getWidth ( ) ) ; at . rotate ( - Math . PI / _NUM . _NUM ) ; break ; case _NUM _NUM _NUM : at . translate ( viewBox . getWidth ( ) , viewBox . getHeight ( ) ) ; at . rotate ( - Math . PI ) ; break ; case _NUM _NUM _NUM : at . scale ( viewBox . getWidth ( ) / viewBox . getHeight ( ) , viewBox . getHeight ( ) / viewBox . getWidth ( ) ) ; at . translate ( viewBox . getHeight ( ) , _NUM ) ; at . rotate ( - Math . PI * _NUM . _NUM ) ; break ; default : } Compensate for Crop Boxes not starting at _NUM , _NUM at . translate ( - viewBox . getLowerLeftX ( ) , - viewBox . getLowerLeftY ( ) ) ; if ( ! at . isIdentity ( ) ) { form . setMatrix ( at ) ; } BoundingBox bbox = new BoundingBox ( ) ; bbox . setLowerLeftX ( viewBox . getLowerLeftX ( ) ) ; bbox . setLowerLeftY ( viewBox . getLowerLeftY ( ) ) ; bbox . setUpperRightX ( viewBox . getUpperRightX ( ) ) ; bbox . setUpperRightY ( viewBox . getUpperRightY ( ) ) ; form . setBBox ( new PDRectangle ( bbox ) ) ; return form ; } 
3418	public static String utf _NUM ( byte [ ] bytes ) { return decode ( bytes , UTF _NUM _ CHARSET ) ; } 
3419	public void testNonTriggeredQueryTimeout ( ) throws SQLException { try ( PreparedStatement stmt = connection . prepareStatement ( SYS _ VERSION _ SQL ) ) { stmt . setQueryTimeout ( _NUM _NUM ) ; stmt . executeQuery ( ) ; ResultSet rs = stmt . getResultSet ( ) ; int rowCount = _NUM ; while ( rs . next ( ) ) { rs . getBytes ( _NUM ) ; rowCount + + ; } assertEquals ( _NUM , rowCount ) ; } } 
3420	public void writeAccessControlEntry ( CmsDbContext dbc , CmsResource resource , CmsAccessControlEntry ace ) throws CmsException { write the new ace getUserDriver ( dbc ) . writeAccessControlEntry ( dbc , dbc . currentProject ( ) , ace ) ; log it log ( dbc , new CmsLogEntry ( dbc , resource . getStructureId ( ) , CmsLogEntryType . RESOURCE _ PERMISSIONS , new String [ ] { resource . getRootPath ( ) } ) , false ) ; update the _STR information setDateLastModified ( dbc , resource , resource . getDateLastModified ( ) ) ; clear the cache m _ monitor . clearAccessControlListCache ( ) ; fire a resource modification event Map < String , Object > data = new HashMap < String , Object > ( _NUM ) ; data . put ( I _ CmsEventListener . KEY _ RESOURCE , resource ) ; data . put ( I _ CmsEventListener . KEY _ CHANGE , new Integer ( CHANGED _ ACCESSCONTROL ) ) ; OpenCms . fireCmsEvent ( new CmsEvent ( I _ CmsEventListener . EVENT _ RESOURCE _ MODIFIED , data ) ) ; } 
3421	public static String encode ( String hrp , final byte [ ] values ) { checkArgument ( hrp . length ( ) > = _NUM , _STR ) ; hrp = hrp . toLowerCase ( Locale . ROOT ) ; byte [ ] checksum = createChecksum ( hrp , values ) ; byte [ ] combined = new byte [ values . length + checksum . length ] ; System . arraycopy ( values , _NUM , combined , _NUM , values . length ) ; System . arraycopy ( checksum , _NUM , combined , values . length , checksum . length ) ; StringBuilder sb = new StringBuilder ( hrp . length ( ) + _NUM + combined . length ) ; sb . append ( hrp ) ; sb . append ( ' _NUM ' ) ; for ( byte b : combined ) { sb . append ( CHARSET . charAt ( b ) ) ; } return sb . toString ( ) ; } 
3422	public void testGroupByNull ( ) { CalciteAssert . hr ( ) . query ( _STR ) ; } 
3423	public static String getAudioFolderPath ( ) { File folder = new File ( getFilesFolderPath ( ) , Const . CacheFolder . AUDIO _ FOLDER ) ; if ( ! folder . exists ( ) ) { folder . mkdirs ( ) ; } return folder . getAbsolutePath ( ) ; } 
3424	protected void adopt ( final CmsTreeItem item ) { item . setParentItem ( this ) ; item . setTree ( m _ tree ) ; onChangeChildren ( ) ; if ( ( m _ tree ! = null ) & & m _ tree . isAnimationEnabled ( ) ) { could be null if not yet attached item . getElement ( ) . getStyle ( ) . setOpacity ( _NUM ) ; animate ( new Animation ( ) { @ Override protected void onUpdate ( double progress ) { item . getElement ( ) . getStyle ( ) . setOpacity ( progress ) ; } } ) . run ( ANIMATION _ DURATION ) ; } } 
3425	private boolean isAppIdleFiltered ( String packageName , int appId , int userId , long elapsedRealtime ) { if ( packageName = = null ) return false ; If not enabled at all , of course nobody is ever idle . if ( ! mAppIdleEnabled ) { return false ; } if ( appId < Process . FIRST _ APPLICATION _ UID ) { System uids never go idle . return false ; } if ( packageName . equals ( _STR ) ) { retain this for safety ) . return false ; } if ( mSystemServicesReady ) { try { for controlling who participates vs . doze mode . if ( mDeviceIdleController . isPowerSaveWhitelistExceptIdleApp ( packageName ) ) { return false ; } } catch ( RemoteException re ) { throw re . rethrowFromSystemServer ( ) ; } if ( isActiveDeviceAdmin ( packageName , userId ) ) { return false ; } if ( isActiveNetworkScorer ( packageName ) ) { return false ; } if ( mAppWidgetManager ! = null & & mAppWidgetManager . isBoundWidgetPackage ( packageName , userId ) ) { return false ; } if ( isDeviceProvisioningPackage ( packageName ) ) { return false ; } } if ( ! isAppIdleUnfiltered ( packageName , userId , elapsedRealtime ) ) { return false ; } TODO : Optimize this by fetching the carrier privileged apps ahead of time if ( isCarrierApp ( packageName ) ) { return false ; } return true ; } 
3426	static int lastIndexOf ( final CharSequence cs , final CharSequence searchChar , final int start ) { return cs . toString ( ) . lastIndexOf ( searchChar . toString ( ) , start ) ; if ( cs instanceof String & & searchChar instanceof String ) { TODO : Do we assume searchChar is usually relatively small ; If so then calling toString ( ) on it is better than reverting to the green implementation in the else blockreturn ( ( String ) cs ) . lastIndexOf ( ( String ) searchChar , start ) ; } else { TODO : Implement rather than convert to Stringreturn cs . toString ( ) . lastIndexOf ( searchChar . toString ( ) , start ) ; } } 
3427	public void addAll ( HyperLogLogPlus other ) throws HyperLogLogPlusMergeException { if ( other . sizeof ( ) ! = sizeof ( ) ) { throw new HyperLogLogPlusMergeException ( _STR ) ; } 
3428	Adds a new property to the map . void addProperty ( String key , String value ) { properties . put ( key , value ) ; } 
3429	private static ScriptEngine tryCreateScriptEngine ( String language , ClassLoader classLoader ) { ScriptEngineManager manager = new ScriptEngineManager ( classLoader ) ; ScriptEngine engine = null ; some script names has alias String [ ] names = getScriptNames ( language ) ; for ( String name : names ) { try { engine = manager . getEngineByName ( name ) ; if ( engine ! = null ) { break ; } } catch ( NoClassDefFoundError ex ) { LOG . warn ( _STR , ScriptContext . ENGINE _ SCOPE ) ; } return engine ; } 
3430	public final void usage ( String commandName , StringBuilder out , String indent ) { String description = getCommandDescription ( commandName ) ; JCommander jc = commander . findCommandByAlias ( commandName ) ; if ( description ! = null ) { out . append ( indent ) . append ( description ) ; out . append ( _STR ) ; } jc . getUsageFormatter ( ) . usage ( out , indent ) ; } 
3431	public void onViewCreated ( @ NonNull View view , @ Nullable Bundle savedInstanceState ) { super . onViewCreated ( view , savedInstanceState ) ; ensureList ( ) ; } 
3432	public static XmlLanguage newInstance ( ) { return ( XmlLanguage ) XmlBeans . getContextTypeLoader ( ) . newInstance ( type , null ) ; } 
3433	public boolean get ( final long address , final CqExtUnit cqExtUnit ) { if ( ! isExtAddr ( address ) ) { return false ; } final int mappedFileSize = this . mappedFileSize ; final long realOffset = unDecorate ( address ) ; MappedFile mappedFile = this . mappedFileQueue . findMappedFileByOffset ( realOffset , realOffset = = _NUM ) ; if ( mappedFile = = null ) { return false ; } int pos = ( int ) ( realOffset % mappedFileSize ) ; SelectMappedBufferResult bufferResult = mappedFile . selectMappedBuffer ( pos ) ; if ( bufferResult = = null ) { log . warn ( _STR , realOffset ) ; return false ; } boolean ret = false ; try { ret = cqExtUnit . read ( bufferResult . getByteBuffer ( ) ) ; } finally { bufferResult . release ( ) ; } return ret ; } 
3434	public < T extends UndoOperation > T getLastOperation ( Class < T > clazz , UndoOwner owner , int mergeMode ) { if ( mWorking = = null ) { throw new IllegalStateException ( _STR ) ; } if ( mergeMode ! = MERGE _ MODE _ NONE & & ! mMerged & & ! mWorking . hasData ( ) ) { UndoState state = getTopUndo ( null ) ; UndoOperation < ? > last ; if ( state ! = null & & ( mergeMode = = MERGE _ MODE _ ANY | | ! state . hasMultipleOwners ( ) ) & & state . canMerge ( ) & & ( last = state . getLastOperation ( clazz , owner ) ) ! = null ) { if ( last . allowMerge ( ) ) { mWorking . destroy ( ) ; mWorking = state ; mUndos . remove ( state ) ; mMerged = true ; return ( T ) last ; } } } return mWorking . getLastOperation ( clazz , owner ) ; } 
3435	public void bulkInsertDeleteCorrectness ( ) { for ( int k = _NUM ; k < ITER ; + + k ) { setUp ( ) ; for ( int i = _NUM , n = baseid , id = baseid + _NUM ; i < opcount ; + + i ) { final int pre = RANDOM . nextInt ( n + _NUM ) ; final int c ; can ' t delete if all records have been deleted : if ( RANDOM . nextBoolean ( ) | | n = = _NUM ) { c = RANDOM . nextInt ( BULK ) + _NUM ; insert ( pre , id , c ) ; id + = c ; } else { c = - Math . min ( n - pre , RANDOM . nextInt ( BULK ) + _NUM ) ; if ( c ! = _NUM ) delete ( pre , c ) ; } check ( ) ; n + = c ; } } } 
3436	public Values < V > values ( ) { if ( values _NUM = = null ) { values _NUM = new Values ( this ) ; values _NUM = new Values ( this ) ; } if ( ! values _NUM . valid ) { values _NUM . reset ( ) ; values _NUM . valid = true ; values _NUM . valid = false ; return values _NUM ; } values _NUM . reset ( ) ; values _NUM . valid = true ; values _NUM . valid = false ; return values _NUM ; } 
3437	public AlreadyExistsException copy ( InetSocketAddress address ) { return new AlreadyExistsException ( address , getMessage ( ) , this , keyspace , table ) ; } 
3438	public final Timestamp addMonth ( int amount ) { if ( amount = = _NUM ) return this ; Calendar cal = calendarValue ( ) ; cal . add ( Calendar . MONTH , amount ) ; return new Timestamp ( cal , _ precision , _ fraction , _ offset ) ; } 
3439	public IComplexNDArray putColumn ( int column , INDArray toPut ) { assert toPut . isVector ( ) & & toPut . length ( ) = = rows ( ) : _STR + columns ( ) ; IComplexNDArray r = getColumn ( column ) ; if ( toPut instanceof IComplexNDArray ) { IComplexNDArray putComplex = ( IComplexNDArray ) toPut ; for ( int i = _NUM ; i < r . length ( ) ; i + + ) { IComplexNumber n = putComplex . getComplex ( i ) ; r . putScalar ( i , n ) ; } } else { for ( int i = _NUM ; i < r . length ( ) ; i + + ) r . putScalar ( i , Nd _NUM j . createDouble ( toPut . getDouble ( i ) , _NUM ) ) ; } return this ; } 
3440	public void writeOut ( OutputStream out ) throws IOException { Header out . write ( _ header ) ; Slide ID writeLittleEndian ( slideID , out ) ; Flags short flags = _NUM ; if ( followMasterObjects ) { flags + = _NUM ; } if ( followMasterScheme ) { flags + = _NUM ; } if ( followMasterBackground ) { flags + = _NUM ; } writeLittleEndian ( flags , out ) ; Reserved fields out . write ( reserved ) ; } 
3441	public void noAccidentalRemoval ( ) throws Throwable { final FragmentManager fm = mActivityRule . getActivity ( ) . getSupportFragmentManager ( ) ; fm . beginTransaction ( ) . remove ( mBeginningFragment ) . setReorderingAllowed ( true ) . commit ( ) ; FragmentTestUtil . waitForExecution ( mActivityRule ) ; FragmentTestUtil . setContentView ( mActivityRule , R . layout . double _ container ) ; TransitionFragment fragment _NUM = new PostponedFragment _NUM ( ) ; fm . beginTransaction ( ) . add ( R . id . fragmentContainer _NUM , fragment _NUM ) . setReorderingAllowed ( true ) . commit ( ) ; FragmentTestUtil . waitForExecution ( mActivityRule ) ; fragment _NUM . startPostponedEnterTransition ( ) ; fragment _NUM . waitForTransition ( ) ; clearTargets ( fragment _NUM ) ; TransitionFragment fragment _NUM = new PostponedFragment _NUM ( ) ; Create a postponed transaction that removes a view fm . beginTransaction ( ) . replace ( R . id . fragmentContainer _NUM , fragment _NUM ) . setReorderingAllowed ( true ) . commit ( ) ; FragmentTestUtil . waitForExecution ( mActivityRule ) ; assertPostponedTransition ( fragment _NUM , fragment _NUM , null ) ; TransitionFragment fragment _NUM = new PostponedFragment _NUM ( ) ; Create a transaction that doesn ' t interfere with the previously postponed one fm . beginTransaction ( ) . replace ( R . id . fragmentContainer _NUM , fragment _NUM ) . setReorderingAllowed ( true ) . commit ( ) ; FragmentTestUtil . waitForExecution ( mActivityRule ) ; assertPostponedTransition ( fragment _NUM , fragment _NUM , null ) ; fragment _NUM . startPostponedEnterTransition ( ) ; fragment _NUM . waitForTransition ( ) ; clearTargets ( fragment _NUM ) ; assertPostponedTransition ( fragment _NUM , fragment _NUM , null ) ; } 
3442	public String getAttribute ( String tag ) { ExifAttribute attribute = getExifAttribute ( tag ) ; if ( attribute ! = null ) { if ( ! sTagSetForCompatibility . contains ( tag ) ) { return attribute . getStringValue ( mExifByteOrder ) ; } if ( tag . equals ( TAG _ GPS _ TIMESTAMP ) ) { Convert the rational values to the custom formats for backwards compatibility . if ( attribute . format ! = IFD _ FORMAT _ URATIONAL & & attribute . format ! = IFD _ FORMAT _ SRATIONAL ) { return null ; } Rational [ ] array = ( Rational [ ] ) attribute . getValue ( mExifByteOrder ) ; if ( array . length ! = _NUM ) { return null ; } return String . format ( _STR , ( int ) ( ( float ) array [ _NUM ] . numerator / array [ _NUM ] . denominator ) , ( int ) ( ( float ) array [ _NUM ] . numerator / array [ _NUM ] . denominator ) , ( int ) ( ( float ) array [ _NUM ] . numerator / array [ _NUM ] . denominator ) ) ; } try { return Double . toString ( attribute . getDoubleValue ( mExifByteOrder ) ) ; } catch ( NumberFormatException e ) { return null ; } } return null ; } 
3443	protected void onUp ( Event event ) { m _ clientX = event . getClientX ( ) ; m _ clientY = event . getClientY ( ) ; if ( ( m _ currentTarget = = null ) | | ( m _ currentTarget . getPlaceholderIndex ( ) < _NUM ) ) { cancel ( ) ; } else { drop ( ) ; } } 
3444	public void testMemberCommitCommsFailure ( ) throws Exception { buildCohortMemberPair ( ) ; final TimeoutException oate = new TimeoutException ( _STR , oate ) ; sleep the wake frequency since that is what we promised Thread . sleep ( WAKE _ FREQUENCY ) ; return null ; } } ) . when ( mockMemberComms ) . sendMemberCompleted ( any ( ) , eq ( data ) ) ; run the operation build a new operation Subprocedure subproc = member . createSubprocedure ( op , data ) ; member . submitSubprocedure ( subproc ) ; if the operation doesn ' t die properly , then this will timeout member . closeAndWait ( TIMEOUT ) ; make sure everything ran in order InOrder order = inOrder ( mockMemberComms , spySub ) ; order . verify ( spySub ) . acquireBarrier ( ) ; order . verify ( mockMemberComms ) . sendMemberAcquired ( eq ( spySub ) ) ; order . verify ( spySub ) . insideBarrier ( ) ; order . verify ( mockMemberComms ) . sendMemberCompleted ( eq ( spySub ) , eq ( data ) ) ; error recovery path exercised order . verify ( spySub ) . cancel ( anyString ( ) , any ( ) ) ; order . verify ( spySub ) . cleanup ( any ( ) ) ; } 
3445	private void privateRun ( XmlTest xmlTest ) { boolean parallel = xmlTest . getParallel ( ) . isParallel ( ) ; { parallel int threadCount = parallel ? xmlTest . getThreadCount ( ) : _NUM ; Make sure we create a graph based on the intercepted methods , otherwise an interceptor removing methods would cause the graph never to terminate ( because it would expect termination from methods that never get invoked ) . DynamicGraph < ITestNGMethod > graph = DynamicGraphHelper . createDynamicGraph ( intercept ( m _ allTestMethods ) , getCurrentXmlTest ( ) ) ; if ( parallel ) { if ( graph . getNodeCount ( ) > _NUM ) { GraphThreadPoolExecutor < ITestNGMethod > executor = new GraphThreadPoolExecutor < > ( _STR + graph ) ; } while ( ! freeNodes . isEmpty ( ) ) { List < IWorker < ITestNGMethod > > runnables = createWorkers ( freeNodes ) ; for ( IWorker < ITestNGMethod > r : runnables ) { r . run ( ) ; } graph . setStatus ( freeNodes , Status . FINISHED ) ; freeNodes = graph . getFreeNodes ( ) ; } } } } 
3446	public void appendToString ( final StringBuffer buffer , final String toString ) { if ( toString ! = null ) { final int pos _NUM = toString . indexOf ( contentStart ) + contentStart . length ( ) ; final int pos _NUM = toString . lastIndexOf ( contentEnd ) ; if ( pos _NUM ! = pos _NUM & & pos _NUM > = _NUM & & pos _NUM > = _NUM ) { if ( fieldSeparatorAtStart ) { removeLastFieldSeparator ( buffer ) ; } buffer . append ( toString , pos _NUM , pos _NUM ) ; appendFieldSeparator ( buffer ) ; } } } 
3447	public String getMessage ( ) { String message = super . getMessage ( ) ; if ( message = = null & & cause = = null ) { return null ; } StringBuffer s = new StringBuffer ( ) ; if ( message ! = null ) { s . append ( message ) . append ( ' \ n ' ) ; } if ( cause ! = null ) { s . append ( _STR ) . append ( cause . getMessage ( ) ) ; } return s . toString ( ) ; } 
3448	public synchronized Channel nextChannel ( ) { if ( channelList . isEmpty ( ) ) { throw new IllegalArgumentException ( _STR + address . getHostName ( ) ) ; } + + index ; if ( index > = channelList . size ( ) ) { index = _NUM ; } return channelList . get ( index ) ; } 
3449	private String getOptionsAsCql ( ) { Iterable < Map . Entry < String , String > > filtered = Iterables . filter ( options . entrySet ( ) , new Predicate < Map . Entry < String , String > > ( ) { @ Override public boolean apply ( Map . Entry < String , String > input ) { return ! input . getKey ( ) . equals ( TARGET _ OPTION _ NAME ) & & ! input . getKey ( ) . equals ( CUSTOM _ INDEX _ OPTION _ NAME ) ; } } ) ; if ( Iterables . isEmpty ( filtered ) ) return _STR ) ; return builder . toString ( ) ; } 
3450	public boolean cancelDiscovery ( ) { if ( getState ( ) ! = STATE _ ON ) { return false ; } try { mServiceLock . readLock ( ) . lock ( ) ; if ( mService ! = null ) { return mService . cancelDiscovery ( ) ; } } catch ( RemoteException e ) { Log . e ( TAG , _STR , e ) ; } finally { mServiceLock . readLock ( ) . unlock ( ) ; } return false ; } 
3451	public void updateFBSize ( ) { try { bitmapData . frameBufferSizeChanged ( ) ; } catch ( Throwable e ) { boolean useLBBM = false ; If we ' ve run out of memory , try using another bitmapdata type . if ( e instanceof OutOfMemoryError ) { disposeDrawable ( ) ; If we were using CompactBitmapData , try FullBufferBitmapData . if ( compact = = true ) { compact = false ; try { bitmapData = new FullBufferBitmapData ( rfbconn , this , capacity ) ; } catch ( Throwable e _NUM ) { useLBBM = true ; } } else useLBBM = true ; Failing FullBufferBitmapData or if we weren ' t using CompactBitmapData , try LBBM . if ( useLBBM ) { disposeDrawable ( ) ; useFull = false ; bitmapData = new LargeBitmapData ( rfbconn , this , getWidth ( ) , getHeight ( ) , capacity ) ; } decoder . setBitmapData ( bitmapData ) ; } } handler . post ( drawableSetter ) ; handler . post ( setModes ) ; handler . post ( desktopInfo ) ; bitmapData . syncScroll ( ) ; } 
3452	private int lookupMetadataString ( KeyType type , String s , Map < String , Integer > lookupCache ) throws MetricException { if ( s = = null ) { if ( this . failureMeter ! = null ) { this . failureMeter . mark ( ) ; } throw new MetricException ( _STR + type ) ; } attempt to find it in the string cache , this will update the LRU StringMetadata stringMetadata = readOnlyStringMetadataCache . get ( s ) ; if ( stringMetadata ! = null ) { return stringMetadata . getStringId ( ) ; } attempt to find it in callers cache Integer id = lookupCache . get ( s ) ; if ( id ! = null ) { return id ; } attempt to find the string in the database stringMetadata = rocksDbGetStringMetadata ( type , s ) ; if ( stringMetadata ! = null ) { id = stringMetadata . getStringId ( ) ; add to the callers cache . We can ' t add it to the stringMetadataCache , since that could cause an eviction database write , which we want to only occur from the inserting DB thread . lookupCache . put ( s , id ) ; return id ; } string does not exist return INVALID _ METADATA _ STRING _ ID ; } 
3453	 @ GET @ Path ( _STR , jobId , ex ) ; throw new ServiceFormattedException ( ex . getMessage ( ) , ex ) ; } } 
3454	public void testWritePreserve ( ) throws IOException { Open the workbook , not preserving nodes InputStream is = HSSFTestDataSamples . openSampleFileStream ( xlsA ) ; HSSFWorkbook wb = new HSSFWorkbook ( is , true ) ; is . close ( ) ; Check now it can be opened HSSFWorkbook wb _NUM = HSSFTestDataSamples . writeOutAndReadBack ( wb ) ; wb . close ( ) ; DirectoryNode root = wb _NUM . getDirectory ( ) ; Check that we have the new entries assertTrue ( root . hasEntry ( _STR ) ) ; wb _NUM . close ( ) ; } 
3455	public int read ( ) throws IOException { int ch ; InputStream is = _ is ; if ( is = = null ) return - _NUM ; else { ch = is . read ( ) ; } _ state . next ( ch ) ; return ch ; } 
3456	public void addPatchResources ( Collection < Resource > resources ) { for ( Resource resource : resources ) addPatchResource ( resource ) ; } 
3457	public Bitmap getThumbnailBitmap ( ) { if ( ! mHasThumbnail ) { return null ; } else if ( mThumbnailBytes = = null ) { mThumbnailBytes = getThumbnailBytes ( ) ; } if ( mThumbnailCompression = = DATA _ JPEG | | mThumbnailCompression = = DATA _ JPEG _ COMPRESSED ) { return BitmapFactory . decodeByteArray ( mThumbnailBytes , _NUM , mThumbnailLength ) ; } else if ( mThumbnailCompression = = DATA _ UNCOMPRESSED ) { int [ ] rgbValues = new int [ mThumbnailBytes . length / _NUM ] ; byte alpha = ( byte ) _NUM xff _NUM _NUM _NUM _NUM _NUM _NUM ; for ( int i = _NUM ; i < rgbValues . length ; i + + ) { rgbValues [ i ] = alpha + ( mThumbnailBytes [ _NUM * i ] < < _NUM _NUM ) + ( mThumbnailBytes [ _NUM * i + _NUM ] < < _NUM ) + mThumbnailBytes [ _NUM * i + _NUM ] ; } ExifAttribute imageLengthAttribute = ( ExifAttribute ) mAttributes [ IFD _ TYPE _ THUMBNAIL ] . get ( TAG _ IMAGE _ LENGTH ) ; ExifAttribute imageWidthAttribute = ( ExifAttribute ) mAttributes [ IFD _ TYPE _ THUMBNAIL ] . get ( TAG _ IMAGE _ WIDTH ) ; if ( imageLengthAttribute ! = null & & imageWidthAttribute ! = null ) { int imageLength = imageLengthAttribute . getIntValue ( mExifByteOrder ) ; int imageWidth = imageWidthAttribute . getIntValue ( mExifByteOrder ) ; return Bitmap . createBitmap ( rgbValues , imageWidth , imageLength , Bitmap . Config . ARGB _ _NUM _NUM _NUM _NUM ) ; } } return null ; } 
3458	public Command addMaterialCommandToLeftBar ( String name , char icon , final ActionListener ev ) { Command cmd = Command . create ( name , null , ev ) ; setCommandMaterialIcon ( cmd , icon , _STR ) ; addCommandToLeftBar ( cmd ) ; return cmd ; } 
3459	public boolean isCapturedViewUnder ( int x , int y ) { return isViewUnder ( mCapturedView , x , y ) ; } 
3460	public void setContent ( Widget content ) { if ( m _ content ! = null ) { m _ content . removeFromParent ( ) ; } if ( m _ isFrame ) { m _ contentPanel . setWidget ( content ) ; } else { m _ popup . setMainContent ( content ) ; } m _ content = content ; } 
3461	View findHiddenNonRemovedView ( int position ) { final int count = mHiddenViews . size ( ) ; for ( int i = _NUM ; i < count ; i + + ) { final View view = mHiddenViews . get ( i ) ; RecyclerView . ViewHolder holder = mCallback . getChildViewHolder ( view ) ; if ( holder . getLayoutPosition ( ) = = position & & ! holder . isInvalid ( ) & & ! holder . isRemoved ( ) ) { return view ; } } return null ; } 
3462	public void testFilter ( ) throws IOException { Filter filter = getFilter ( filterTokens ) ; Key k = new Key ( ) ; for ( String s : filterTokens ) { setKey ( k , s ) ; assertTrue ( _STR , filter . membershipTest ( k ) ) ; } } 
3463	public Date parseMath ( String math ) throws ParseException { Calendar cal = Calendar . getInstance ( zone , loc ) ; cal . setTime ( getNow ( ) ) ; if ( _NUM = = math . length ( ) ) { return cal . getTime ( ) ; } String [ ] ops = splitter . split ( math ) ; int pos = _NUM ; while ( pos < ops . length ) { if ( _NUM ! = ops [ pos ] . length ( ) ) { throw new ParseException ( _STR , pos - _NUM ) ; } } return cal . getTime ( ) ; } 
3464	public URI uploadPackage ( ) throws UploaderException { first , check if the topology package exists boolean fileExists = new File ( topologyPackageLocation ) . isFile ( ) ; if ( ! fileExists ) { throw new UploaderException ( String . format ( _STR , source , filePath ) , e ) ; } return getUri ( destTopologyFile ) ; } 
3465	static void modifyItemInDatabase ( Context context , final ItemInfo item , final long container , final long screenId , final int cellX , final int cellY , final int spanX , final int spanY ) { item . container = container ; item . cellX = cellX ; item . cellY = cellY ; item . spanX = spanX ; item . spanY = spanY ; in the hotseat if ( context instanceof Launcher & & screenId < _NUM & & container = = LauncherSettings . Favorites . CONTAINER _ HOTSEAT ) { item . screenId = Launcher . getLauncher ( context ) . getHotseat ( ) . getOrderInHotseat ( cellX , cellY ) ; } else { item . screenId = screenId ; } final ContentValues values = new ContentValues ( ) ; values . put ( LauncherSettings . Favorites . CONTAINER , item . container ) ; values . put ( LauncherSettings . Favorites . CELLX , item . cellX ) ; values . put ( LauncherSettings . Favorites . CELLY , item . cellY ) ; values . put ( LauncherSettings . Favorites . RANK , item . rank ) ; values . put ( LauncherSettings . Favorites . SPANX , item . spanX ) ; values . put ( LauncherSettings . Favorites . SPANY , item . spanY ) ; values . put ( LauncherSettings . Favorites . SCREEN , item . screenId ) ; updateItemInDatabaseHelper ( context , values , item , _STR ) ; } 
3466	public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . resize _ menu _ main ) ; mContext = this ; setUpMenu ( ) ; changeFragment ( new HomeFragment ( ) ) ; } 
3467	void setNextSelectedPositionInt ( int position ) { mNextSelectedPosition = position ; mNextSelectedRowId = getItemIdAtPosition ( position ) ; If we are trying to sync to the selection , update that too if ( mNeedSync & & mSyncMode = = SYNC _ SELECTED _ POSITION & & position > = _NUM ) { mSyncPosition = position ; mSyncRowId = mNextSelectedRowId ; } } 
3468	private SortedMap < String , List < Map < String , String > > > getRepos ( Request request ) { SortedMap < String , List < Map < String , String > > > result = new TreeMap < > ( ) ; Map < String , Object > first = Iterables . getFirst ( request . getBody ( ) . getPropertySets ( ) , null ) ; if ( first ! = null & & first . get ( _STR ) ; result = createResultForOperationSystems ( set ) ; } return result ; } 
3469	void requestPermissionsFromFragment ( Fragment fragment , String [ ] permissions , int requestCode ) { if ( requestCode = = - _NUM ) { ActivityCompat . requestPermissions ( this , permissions , requestCode ) ; return ; } checkForValidRequestCode ( requestCode ) ; try { mRequestedPermissionsFromFragment = true ; int requestIndex = allocateRequestIndex ( fragment ) ; ActivityCompat . requestPermissions ( this , permissions , ( ( requestIndex + _NUM ) < < _NUM _NUM ) + ( requestCode & _NUM xffff ) ) ; } finally { mRequestedPermissionsFromFragment = false ; } } 
3470	protected AffineTransform getParentTransform ( ) { TODO : There ' s probably a better way to do this AffineTransform tr = new AffineTransform ( ) ; Double locX = getLocPinX ( ) ; Double locY = getLocPinY ( ) ; Boolean flipX = getFlipX ( ) ; Boolean flipY = getFlipY ( ) ; Double angle = getAngle ( ) ; tr . translate ( - locX , - locY ) ; tr . translate ( getPinX ( ) , getPinY ( ) ) ; rotate about the origin if ( angle ! = null & & Math . abs ( angle ) > _NUM . _NUM _NUM _NUM ) { tr . rotate ( angle , locX , locY ) ; } if ( flipX ! = null & & flipX ) { tr . scale ( - _NUM , _NUM ) ; tr . translate ( - getWidth ( ) , _NUM ) ; } if ( flipY ! = null & & flipY ) { tr . scale ( _NUM , - _NUM ) ; tr . translate ( _NUM , - getHeight ( ) ) ; } return tr ; } 
3471	public static boolean containsAll ( Bundle original , Bundle updates ) { for ( String key : updates . keySet ( ) ) { Object value _NUM = updates . get ( key ) ; Object value _NUM = original . get ( key ) ; if ( value _NUM = = null ) { if ( value _NUM ! = null ) { return false ; } } else if ( ! value _NUM . equals ( value _NUM ) ) { return false ; } } return true ; } 
3472	private TraceStateImpl getStateImpl ( ) { TraceState state = get ( ) ; if ( state = = null ) return null ; if ( state instanceof ExpiredTraceState ) { ExpiredTraceState expiredTraceState = ( ExpiredTraceState ) state ; state = expiredTraceState . getDelegate ( ) ; } if ( state instanceof TraceStateImpl ) { return ( TraceStateImpl ) state ; } assert false : _STR ; return null ; } 
3473	public static < TSource > int count ( Enumerable < TSource > enumerable , Predicate _NUM < TSource > predicate ) { return ( int ) longCount ( enumerable , predicate ) ; } 
3474	public static boolean cellReferenceIsWithinRange ( String colStr , String rowStr , SpreadsheetVersion ssVersion ) { if ( ! isColumnWithinRange ( colStr , ssVersion ) ) { return false ; } return isRowWithinRange ( rowStr , ssVersion ) ; } 
3475	public String buildCheckContent ( ) { StringBuffer retValue = new StringBuffer ( _NUM _NUM _NUM ) ; retValue . append ( _STR ) ; return retValue . toString ( ) ; } 
3476	public Bid withoutAnnotation ( String annotation ) { if ( hasAnnotation ( annotation ) ) { return new Bid ( auction , bidder , price , dateTime , extra . substring ( annotation . length ( ) + _NUM ) ) ; } else { return this ; } } 
3477	public List readAllAvailableVersions ( CmsDbContext dbc , CmsUUID structureId ) throws CmsDataAccessException { ResultSet res = null ; List result = new ArrayList ( ) ; PreparedStatement stmt = null ; Connection conn = null ; try { conn = m _ sqlManager . getConnection ( dbc ) ; get all direct versions ( where the structure entry has been written ) sorted from the NEWEST to the OLDEST version ( publish tag descendant ) List historyResources = new ArrayList ( ) ; stmt = m _ sqlManager . getPreparedStatement ( conn , _STR ) ; stmt . setString ( _NUM , histRes . getResourceId ( ) . toString ( ) ) ; stmt . setInt ( _NUM , histRes . getPublishTag ( ) ) ; res = stmt . executeQuery ( ) ; int offset = ( histRes . getStructureVersion ( ) > _NUM ? _NUM : _NUM ) ; I _ CmsHistoryResource lastHistRes = histRes ; while ( res . next ( ) ) { I _ CmsHistoryResource newHistRes = internalMergeResource ( histRes , res , offset ) ; if ( newHistRes . getResourceVersion ( ) ! = lastHistRes . getResourceVersion ( ) ) { only add interesting versions if ( offset = = _NUM ) { if ( histRes ! = lastHistRes ) { result . add ( lastHistRes ) ; } } else { result . add ( newHistRes ) ; } } lastHistRes = newHistRes ; } add the last one if there is one if ( ( offset = = _NUM ) & & ( lastHistRes ! = histRes ) ) { result . add ( lastHistRes ) ; } m _ sqlManager . closeAll ( dbc , null , stmt , res ) ; } } } catch ( SQLException e ) { throw new CmsDbSqlException ( Messages . get ( ) . container ( Messages . ERR _ GENERIC _ SQL _ _NUM , CmsDbSqlException . getErrorQuery ( stmt ) ) , e ) ; } finally { m _ sqlManager . closeAll ( dbc , conn , stmt , res ) ; } return result ; } 
3478	private ELNode . Nodes parseEL ( ) { StringBuffer buf = new StringBuffer ( ) ; ELexpr = new ELNode . Nodes ( ) ; while ( hasNext ( ) ) { curToken = nextToken ( ) ; if ( curToken instanceof Char ) { if ( curToken . toChar ( ) = = ' } ' ) { break ; } buf . append ( curToken . toChar ( ) ) ; } else { Output whatever is in buffer if ( buf . length ( ) > _NUM ) { ELexpr . add ( new ELNode . ELText ( buf . toString ( ) ) ) ; } if ( ! parseFunction ( ) ) { ELexpr . add ( new ELNode . ELText ( curToken . toString ( ) ) ) ; } } } if ( buf . length ( ) > _NUM ) { ELexpr . add ( new ELNode . ELText ( buf . toString ( ) ) ) ; } return ELexpr ; } 
3479	private static TupleSummaryData sumUp ( Schema schema , Tuple t ) throws ExecException { TupleSummaryData summaryData = new TupleSummaryData ( ) ; DataBag bag = ( DataBag ) t . get ( _NUM ) ; for ( Tuple tuple : bag ) { summaryData . addTuple ( schema , tuple ) ; } return summaryData ; } 
3480	void unSelect ( ) { if ( mHideOnSelect ) { show ( true ) ; } } 
3481	public boolean evaluate ( ) throws ChecksumVerifierException { final String resourceHash = calculateFileDigest ( ) ; String checksum ; logger . log ( Level . FINE , _STR ) ; return true ; } 
3482	protected void consumeStatement ( ) throws ParsingException { Marker start = tokens . mark ( ) ; tokens . consume ( DdlTokenizer . STATEMENT _ KEY ) ; consumeRemainingStatement ( start ) ; } 
3483	public boolean selectDate ( Date date , boolean smoothScroll ) { validateDate ( date ) ; MonthCellWithMonthIndex monthCellWithMonthIndex = getMonthCellWithIndexByDate ( date ) ; if ( monthCellWithMonthIndex = = null | | ! isDateSelectable ( date ) ) { return false ; } boolean wasSelected = doSelectDate ( date , monthCellWithMonthIndex . cell ) ; if ( wasSelected ) { scrollToSelectedMonth ( monthCellWithMonthIndex . monthIndex , smoothScroll ) ; } return wasSelected ; } 
3484	public void start ( final Configuration config ) { LOGGER . debug ( _STR , getName ( ) , this , config ) ; } 
3485	public static DataBlockEncoder getDataBlockEncoderById ( short encoderId ) { return getEncodingById ( encoderId ) . getEncoder ( ) ; } 
3486	public void addRelationToResource ( CmsDbContext dbc , CmsResource resource , CmsResource target , CmsRelationType type , boolean importCase ) throws CmsException { if ( type . isDefinedInContent ( ) ) { throw new CmsIllegalArgumentException ( Messages . get ( ) . container ( Messages . ERR _ ADD _ RELATION _ IN _ CONTENT _ _NUM , dbc . removeSiteRoot ( resource . getRootPath ( ) ) , dbc . removeSiteRoot ( target . getRootPath ( ) ) , type . getLocalizedName ( dbc . getRequestContext ( ) . getLocale ( ) ) ) ) ; } CmsRelation relation = new CmsRelation ( resource , target , type ) ; getVfsDriver ( dbc ) . createRelation ( dbc , dbc . currentProject ( ) . getUuid ( ) , relation ) ; if ( ! importCase ) { log it log ( dbc , new CmsLogEntry ( dbc , resource . getStructureId ( ) , CmsLogEntryType . RESOURCE _ ADD _ RELATION , new String [ ] { relation . getSourcePath ( ) , relation . getTargetPath ( ) } ) , false ) ; touch the resource setDateLastModified ( dbc , resource , System . currentTimeMillis ( ) ) ; } } 
3487	public Pair < Assertion , WsFederationConfiguration > buildAndVerifyAssertion ( final RequestedSecurityToken reqToken , final Collection < WsFederationConfiguration > config ) { final XMLObject securityToken = getSecurityTokenFromRequestedToken ( reqToken , config ) ; if ( securityToken instanceof Assertion ) { LOGGER . debug ( _STR ) ; } 
3488	public boolean setDataSource ( Uri uri ) { if ( mMediaSourceUri ! = null ? mMediaSourceUri . equals ( uri ) : uri = = null ) { return false ; } mMediaSourceUri = uri ; prepareMediaForPlaying ( ) ; return true ; } 
3489	public Collection < V > values ( ) { if ( valuesCollection = = null ) { valuesCollection = new AbstractCollection < V > ( ) { @ Override public boolean contains ( Object object ) { return containsValue ( object ) ; } @ Override public int size ( ) { return HashMap . this . size ( ) ; } @ Override public void clear ( ) { HashMap . this . clear ( ) ; } @ Override public Iterator < V > iterator ( ) { return new ValueIterator < K , V > ( HashMap . this ) ; } } ; } return valuesCollection ; } 
3490	public int getColorMode ( ) { synchronized ( this ) { updateDisplayInfoLocked ( ) ; return mDisplayInfo . colorMode ; } } 
3491	public void addAsFirstExtraField ( ZipExtraField ze ) { if ( ze instanceof UnparseableExtraFieldData ) { unparseableExtra = ( UnparseableExtraFieldData ) ze ; } else { LinkedHashMap < ZipShort , ZipExtraField > copy = extraFields ; extraFields = new LinkedHashMap < ZipShort , ZipExtraField > ( ) ; extraFields . put ( ze . getHeaderId ( ) , ze ) ; if ( copy ! = null ) { copy . remove ( ze . getHeaderId ( ) ) ; extraFields . putAll ( copy ) ; } } setExtra ( ) ; } 
3492	private void cleanupDanglingBitmapFilesLocked ( @ UserIdInt int userId , @ NonNull ShortcutUser user , @ NonNull String packageName , @ NonNull File path ) { final ArraySet < String > usedFiles = user . getPackageShortcuts ( packageName ) . getUsedBitmapFiles ( ) ; for ( File child : path . listFiles ( ) ) { if ( ! child . isFile ( ) ) { continue ; } final String name = child . getName ( ) ; if ( ! usedFiles . contains ( name ) ) { if ( DEBUG ) { Slog . d ( TAG , _STR + child . getAbsolutePath ( ) ) ; } child . delete ( ) ; } } } 
3493	public void unregisterAsSystemService ( ) throws RemoteException { if ( mWrapper ! = null ) { INotificationManager noMan = getNotificationInterface ( ) ; noMan . unregisterListener ( mWrapper , mCurrentUser ) ; } } 
3494	private boolean isEnabledProfileOf ( UserHandle user , UserHandle listeningUser , String debugMsg ) { if ( user . getIdentifier ( ) = = listeningUser . getIdentifier ( ) ) { if ( DEBUG ) Log . d ( TAG , _STR + debugMsg ) ; } return true ; } } finally { injectRestoreCallingIdentity ( ident ) ; } } 
3495	public static boolean isEqual ( Object a , Object b ) { return a = = null ? b = = null : a . equals ( b ) ; } 
3496	private void updateAllFromHSV ( ) { Update mRGB if ( mRGBenabled | | mYUVenabled ) updateRGBfromHSV ( ) ; Update mYUV if ( mYUVenabled ) updateYUVfromRGB ( ) ; Update mHexStr if ( mRGBenabled ) updateHexFromHSV ( ) ; } 
3497	public Spring setEndValue ( double endValue ) { if ( mEndValue = = endValue & & isAtRest ( ) ) { return this ; } mStartValue = getCurrentValue ( ) ; mEndValue = endValue ; mSpringSystem . activateSpring ( this . getId ( ) ) ; for ( SpringListener listener : mListeners ) { listener . onSpringEndStateChange ( this ) ; } return this ; } 
3498	public void requireTablePermission ( User user , String request , TableName tableName , byte [ ] family , byte [ ] qualifier , Action . . . permissions ) throws IOException { if ( ! authorizationEnabled ) { return ; } AuthResult result = null ; for ( Action permission : permissions ) { if ( authManager . authorize ( user , tableName , null , null , permission ) ) { result = AuthResult . allow ( request , _STR + result . toContextString ( ) ) ; } } 
3499	public static XmlFloat newInstance ( ) { return ( XmlFloat ) XmlBeans . getContextTypeLoader ( ) . newInstance ( type , null ) ; } 
3500	public void wildCardsCS ( ) { setFTFlags ( FTWC | FTCS ) ; run ( TEXT , _STR ) ; } 
3501	public Footer getEvenFooter ( ) { return new XSSFEvenFooter ( getSheetTypeHeaderFooter ( ) ) ; } 
3502	protected void uGenerate ( float [ ] channels ) { if ( inside a grain insideGrain ) { start with an amplitude at maxAmp float amp = maxAmp ; if ( inside the rise timeSinceGrainStart < fadeLength ) { linear fade in amp * = timeSinceGrainStart / fadeLength ; } else if ( inside the decay timeSinceGrainStart > ( grainLength - fadeLength ) ) { linear fade out amp * = ( grainLength - timeSinceGrainStart ) / fadeLength ; } generate the sample for ( int i = _NUM ; i < channels . length ; i + + ) { channels [ i ] = amp * audio . getLastValues ( ) [ i ] ; } increment time timeSinceGrainStart + = timeStep ; if ( just after a grain timeSinceGrainStart > grainLength ) { stop the grain timeSinceGrainStop = _NUM . _NUM f ; insideGrain = false ; set a new spaceLength spaceLengthMin = spaceLenMin . getLastValue ( ) ; spaceLengthMax = spaceLenMax . getLastValue ( ) ; spaceLength = randomBetween ( spaceLengthMin , spaceLengthMax ) ; } } else outside a grain { for ( int i = _NUM ; i < channels . length ; i + + ) { channels [ i ] = minAmp ; } increment time timeSinceGrainStop + = timeStep ; if ( just inside a grain again timeSinceGrainStop > spaceLength ) { start the grain timeSinceGrainStart = _NUM . _NUM f ; insideGrain = true ; set a new grain length grainLengthMin = grainLenMin . getLastValue ( ) ; grainLengthMax = grainLenMax . getLastValue ( ) ; grainLength = randomBetween ( grainLengthMin , grainLengthMax ) ; set a new fade length fadeLengthMin = fadeLenMin . getLastValue ( ) ; fadeLengthMax = fadeLenMax . getLastValue ( ) ; fadeLength = randomBetween ( fadeLengthMin , fadeLengthMax ) ; make sure the fade length is correct checkFadeLength ( ) ; } } } 
3503	public void testSetReadOnlyChild ( ) { IonSequence s = wrapAndParse ( _STR ) ; IonValue v = system ( ) . newNull ( ) ; v . makeReadOnly ( ) ; testSetThrows ( s , _NUM , v , ReadOnlyValueException . class ) ; } 
3504	public alluxio . proto . journal . File . AddMountPointEntry . Builder getAddMountPointBuilder ( ) { bitField _NUM _ | = _NUM x _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM ; onChanged ( ) ; return getAddMountPointFieldBuilder ( ) . getBuilder ( ) ; } 
3505	private String startSetToString ( ) { StringBuffer FString = new StringBuffer ( ) ; boolean didPrint ; if ( m _ starting = = null ) { return getStartSet ( ) ; } for ( int i = _NUM ; i < m _ starting . length ; i + + ) { didPrint = false ; if ( ( m _ hasClass = = false ) | | ( m _ hasClass = = true & & i ! = m _ classIndex ) ) { FString . append ( ( m _ starting [ i ] + _NUM ) ) ; didPrint = true ; } if ( i = = ( m _ starting . length - _NUM ) ) { FString . append ( _STR ) ; } } } return FString . toString ( ) ; } 
3506	private void loadPreferences ( ) { String mapTypePref = getResources ( ) . getString ( R . string . pref _ map _ type _ key ) ; prefs = getSharedPreferences ( AimsicdService . SHARED _ PREFERENCES _ BASENAME , _NUM ) ; if ( prefs . contains ( mapTypePref ) ) { int mapType = Integer . parseInt ( prefs . getString ( mapTypePref , _STR ) ) ; setupMapType ( mapType ) ; } } 
3507	public static String getCompoundLemma ( String word , POS pos ) { do not look up words with special characters other than ' . ' if ( word . matches ( _STR , - _NUM ) . length ; if ( wordTokens ! = lemmaTokens | | wordDots ! = lemmaDots ) return null ; return lemma ; } 
3508	public void optionalEqualityScope _ _NUM _NUM ( ) { String qs = StrUtils . strjoinNL ( _STR ) ; TestOptimizer . check ( qs , ops ) ; } 
3509	public static IndexReader openIfChanged ( IndexReader oldReader , IndexCommit commit ) throws IOException { if ( oldReader . hasNewReopenAPI _NUM ) { final IndexReader newReader = oldReader . doOpenIfChanged ( commit ) ; assert newReader ! = oldReader ; return newReader ; } else { final IndexReader newReader = oldReader . reopen ( commit ) ; if ( newReader = = oldReader ) { return null ; } else { return newReader ; } } } 
3510	protected Object openObject ( ) { if ( m _ FileChooser = = null ) { createFileChooser ( ) ; } int returnVal = m _ FileChooser . showOpenDialog ( this ) ; if ( returnVal = = JFileChooser . APPROVE _ OPTION ) { File selected = m _ FileChooser . getSelectedFile ( ) ; try { ObjectInputStream oi = new ObjectInputStream ( new BufferedInputStream ( new FileInputStream ( selected ) ) ) ; Object obj = oi . readObject ( ) ; oi . close ( ) ; if ( ! m _ ClassType . isAssignableFrom ( obj . getClass ( ) ) ) { throw new Exception ( _STR , JOptionPane . ERROR _ MESSAGE ) ; } } return null ; } 
3511	public static void ctlBeforeClass ( ) { if ( serverScope = = CLASS ) { setPoolingHttpClient ( ) ; allocServer ( ) ; } } 
3512	protected int decryptBlock ( byte [ ] src , int srcIndex , byte [ ] dst , int dstIndex ) { int [ ] result = new int [ _NUM ] ; process the input block batch the units up into _NUM x _NUM _NUM bit chunks and go for it int A = BytesTo _NUM _NUM bits ( src , srcIndex ) ; int B = BytesTo _NUM _NUM bits ( src , srcIndex + _NUM ) ; int C = BytesTo _NUM _NUM bits ( src , srcIndex + _NUM ) ; int D = BytesTo _NUM _NUM bits ( src , srcIndex + _NUM _NUM ) ; CAST _ Decipher ( A , B , C , D , result ) ; now stuff them into the destination block Bits _NUM _NUM ToBytes ( result [ _NUM ] , dst , dstIndex ) ; Bits _NUM _NUM ToBytes ( result [ _NUM ] , dst , dstIndex + _NUM ) ; Bits _NUM _NUM ToBytes ( result [ _NUM ] , dst , dstIndex + _NUM ) ; Bits _NUM _NUM ToBytes ( result [ _NUM ] , dst , dstIndex + _NUM _NUM ) ; return BLOCK _ SIZE ; } 
3513	private View fillUp ( int pos , int nextBottom ) { int end = mListPadding . top ; while ( nextBottom > end & & pos > = _NUM ) { is this the selected item ? makeAndAddView ( pos , getItemBottom ( pos ) , false , false ) ; nextBottom = child . getTop ( ) - mDividerHeight ; pos - - ; nextBottom = getItemBottom ( pos ) ; } mFirstPosition = pos + _NUM ; return null ; } 
3514	public < T > PTransform < PCollection < T > , PCollection < T > > prepareActuals ( ) { return window ( ) ; } 
3515	private void verifyRaLifetime ( TestApfFilter apfFilter , MockIpClientCallback ipClientCallback , ByteBuffer packet , int lifetime ) throws IOException , ErrnoException { Verify new program generated if ApfFilter witnesses RA ipClientCallback . resetApfProgramWait ( ) ; apfFilter . pretendPacketReceived ( packet . array ( ) ) ; byte [ ] program = ipClientCallback . getApfProgram ( ) ; verifyRaLifetime ( program , packet , lifetime ) ; } 
3516	public static String timeToString ( long time , Resolution resolution ) { final Date date = new Date ( round ( time , resolution ) ) ; return TL _ FORMATS . get ( ) [ resolution . formatLen ] . format ( date ) ; } 
3517	public void setTransacted ( boolean consumerTransacted ) { getConfiguration ( ) . setTransacted ( consumerTransacted ) ; } 
3518	public int getRecycledViewCount ( int viewType ) { return getScrapDataForType ( viewType ) . mScrapHeap . size ( ) ; } 
3519	private FTUnit ftUnit ( ) throws QueryException { if ( wsConsumeWs ( WORDS ) ) return FTUnit . WORDS ; if ( wsConsumeWs ( SENTENCES ) ) return FTUnit . SENTENCES ; if ( wsConsumeWs ( PARAGRAPHS ) ) return FTUnit . PARAGRAPHS ; throw error ( INCOMPLETE ) ; } 
3520	public static Throwable getEnhancedStackTrace ( @ NonNull Throwable original ) { Throwable enhanced = original ; RxJavaAssemblyException assembledException = RxJavaAssemblyException . find ( original ) ; if ( assembledException ! = null ) { StackTraceElement [ ] clearStack = parseStackTrace ( assembledException , basePackages ) ; Throwable clearException = new Throwable ( ) ; clearException . setStackTrace ( clearStack ) ; enhanced = setRootCause ( original , clearException ) ; } return enhanced ; } 
3521	public static void generateInputData ( int dataSizePerMap , int numSpillsPerMap , int numMapsPerHost , JobConf masterConf ) throws Exception { JobConf job = new JobConf ( masterConf , ThreadedMapBenchmark . class ) ; job . setJobName ( _STR + cluster . getTaskTrackers ( ) ) ; generates the input for the benchmark JobClient . runJob ( job ) ; } 
3522	public void rmacc ( String resourceName , String principalType , String principalName ) throws CmsException { CmsResource res = readResource ( resourceName , CmsResourceFilter . ALL ) ; if ( CmsUUID . isValidUUID ( principalName ) ) { principal name is in fact a UUID , probably the user was already deleted m _ securityManager . removeAccessControlEntry ( m _ context , res , new CmsUUID ( principalName ) ) ; } else { try { principal name not a UUID , assume this is a normal group or user name I _ CmsPrincipal principal = CmsPrincipal . readPrincipal ( this , principalType , principalName ) ; m _ securityManager . removeAccessControlEntry ( m _ context , res , principal . getId ( ) ) ; } catch ( CmsDbEntryNotFoundException e ) { role case CmsRole role = CmsRole . valueOfRoleName ( principalName ) ; if ( role = = null ) { throw e ; } m _ securityManager . removeAccessControlEntry ( m _ context , res , role . getId ( ) ) ; } } } 
3523	private static void checkConfiguration ( Configuration conf ) throws IOException { final Collection < URI > namespaceDirs = FSNamesystem . getNamespaceDirs ( conf ) ; final Collection < URI > editsDirs = FSNamesystem . getNamespaceEditsDirs ( conf ) ; final Collection < URI > requiredEditsDirs = FSNamesystem . getRequiredNamespaceEditsDirs ( conf ) ; final Collection < URI > sharedEditsDirs = FSNamesystem . getSharedEditsDirs ( conf ) ; for ( URI u : requiredEditsDirs ) { if ( u . toString ( ) . compareTo ( DFSConfigKeys . DFS _ NAMENODE _ EDITS _ DIR _ DEFAULT ) = = _NUM ) { continue ; } sharedEditsDirs . if ( ! editsDirs . contains ( u ) & & ! sharedEditsDirs . contains ( u ) ) { throw new IllegalArgumentException ( _STR ) ; } } 
3524	 @ SuppressWarnings ( _STR ) ; } } 
3525	protected void initializeGraph ( ) { super . initializeGraph ( ) ; mDrawMatrix . setValues ( mDrawMatrixValues ) ; mGraphOverlay . decelerate ( ) ; mSeries = new ArrayList < ValueLineSeries > ( ) ; mLegendList = new ArrayList < LegendModel > ( ) ; mLinePaint = new Paint ( Paint . ANTI _ ALIAS _ FLAG ) ; mLinePaint . setStrokeWidth ( mLineStroke ) ; mLegendPaint = new Paint ( Paint . ANTI _ ALIAS _ FLAG ) ; mLegendPaint . setColor ( mLegendColor ) ; mLegendPaint . setTextSize ( mLegendTextSize ) ; mLegendPaint . setStrokeWidth ( _NUM ) ; mLegendPaint . setStyle ( Paint . Style . FILL ) ; mMaxFontHeight = Utils . calculateMaxTextHeight ( mLegendPaint , null ) ; mIndicatorPaint = new Paint ( Paint . ANTI _ ALIAS _ FLAG ) ; mIndicatorPaint . setColor ( mIndicatorLineColor ) ; mIndicatorPaint . setTextSize ( mIndicatorTextSize ) ; mIndicatorPaint . setStrokeWidth ( mIndicatorWidth ) ; mIndicatorPaint . setStyle ( Paint . Style . FILL ) ; mScaleGestureDetector = new ScaleGestureDetector ( getContext ( ) , mScaleGestureListener ) ; mGestureDetector = new GestureDetector ( getContext ( ) , mGestureListener ) ; mScroller = new Scroller ( getContext ( ) ) ; mRevealAnimator = ValueAnimator . ofFloat ( _NUM , _NUM ) ; mRevealAnimator . addUpdateListener ( new ValueAnimator . AnimatorUpdateListener ( ) { @ Override public void onAnimationUpdate ( ValueAnimator animation ) { mRevealValue = animation . getAnimatedFraction ( ) ; mDrawMatrix . reset ( ) ; mDrawMatrix . setScale ( _NUM , _NUM . f * mRevealValue , _NUM , mGraphHeight - mNegativeOffset ) ; mGraph . invalidate ( ) ; } } ) ; mRevealAnimator . addListener ( new Animator . AnimatorListener ( ) { @ Override public void onAnimationStart ( Animator animation ) { } @ Override public void onAnimationEnd ( Animator animation ) { mStartedAnimation = false ; } @ Override public void onAnimationCancel ( Animator animation ) { } @ Override public void onAnimationRepeat ( Animator animation ) { } } ) ; The scroller doesn ' t have any built - in animation functions - - it just supplies values when we ask it to . So we have to have a way to call it every frame until the fling ends . This code ( ab ) uses a ValueAnimator object to generate a callback on every animation frame . We don ' t use the animated value at all . mScrollAnimator = ValueAnimator . ofFloat ( _NUM , _NUM ) ; mScrollAnimator . addUpdateListener ( new ValueAnimator . AnimatorUpdateListener ( ) { public void onAnimationUpdate ( ValueAnimator valueAnimator ) { tickScrollAnimation ( ) ; invalidateGlobal ( ) ; } } ) ; if ( this . isInEditMode ( ) ) { ValueLineSeries series _NUM = new ValueLineSeries ( ) ; series _NUM . setColor ( _NUM xFF _NUM _NUM CBB _NUM ) ; series _NUM . addPoint ( new ValueLinePoint ( _NUM . _NUM f ) ) ; series _NUM . addPoint ( new ValueLinePoint ( _NUM . _NUM f ) ) ; series _NUM . addPoint ( new ValueLinePoint ( _NUM . _NUM f ) ) ; series _NUM . addPoint ( new ValueLinePoint ( _NUM . _NUM f ) ) ; series _NUM . addPoint ( new ValueLinePoint ( _NUM . _NUM f ) ) ; series _NUM . addPoint ( new ValueLinePoint ( _NUM . _NUM f ) ) ; series _NUM . addPoint ( new ValueLinePoint ( _NUM . _NUM f ) ) ; series _NUM . addPoint ( new ValueLinePoint ( _NUM . _NUM f ) ) ; series _NUM . addPoint ( new ValueLinePoint ( _NUM . _NUM f ) ) ; series _NUM . addPoint ( new ValueLinePoint ( _NUM . _NUM f ) ) ; series _NUM . addPoint ( new ValueLinePoint ( _NUM . _NUM f ) ) ; series _NUM . addPoint ( new ValueLinePoint ( _NUM . _NUM f ) ) ; series _NUM . addPoint ( new ValueLinePoint ( _NUM . _NUM f ) ) ; series _NUM . addPoint ( new ValueLinePoint ( _NUM . _NUM f ) ) ; series _NUM . addPoint ( new ValueLinePoint ( _NUM . _NUM f ) ) ; series _NUM . addPoint ( new ValueLinePoint ( _NUM . _NUM f ) ) ; series _NUM . addPoint ( new ValueLinePoint ( _NUM . _NUM f ) ) ; series _NUM . addPoint ( new ValueLinePoint ( _NUM . _NUM f ) ) ; addSeries ( series _NUM ) ; } } 
3526	void onDropChild ( View child ) { if ( child ! = null ) { LayoutParams lp = ( LayoutParams ) child . getLayoutParams ( ) ; lp . dropped = true ; child . requestLayout ( ) ; markCellsAsOccupiedForView ( child ) ; } } 
3527	private void warning ( Object request ) { if ( requestWithWarning ) { if ( warningcount . get ( ) % _NUM _NUM _NUM _NUM = = _NUM ) { logger . warn ( new IllegalStateException ( _STR ) ) ; } warningcount . incrementAndGet ( ) ; } } 
3528	public PDRange getBRange ( ) { COSArray rangeArray = ( COSArray ) dictionary . getDictionaryObject ( COSName . RANGE ) ; if ( rangeArray = = null ) { rangeArray = getDefaultRangeArray ( ) ; } return new PDRange ( rangeArray , _NUM ) ; } 
3529	private NetworkStatsHistory internalGetHistoryForNetwork ( NetworkTemplate template , int flags , int fields , @ NetworkStatsAccess . Level int accessLevel , int callingUid ) { We ' ve been using pure XT stats long enough that we no longer need to splice DEV and XT together . final SubscriptionPlan augmentPlan = resolveSubscriptionPlan ( template , flags ) ; synchronized ( mStatsLock ) { return mXtStatsCached . getHistory ( template , augmentPlan , UID _ ALL , SET _ ALL , TAG _ NONE , fields , Long . MIN _ VALUE , Long . MAX _ VALUE , accessLevel , callingUid ) ; } } 
3530	public void encode ( OutputStream output ) throws IOException { if ( algorithm ! = null ) { algorithm . encode ( output ) ; } TlsUtils . writeOpaque _NUM _NUM ( signature , output ) ; } 
3531	public static void restartServer ( ServerContext serverContext , boolean resetData ) { final Thread previousServerThread = corfuServerThread ; final Map < String , Object > opts = serverContext . getServerConfig ( ) ; final boolean bindToAllInterfaces = serverContext . isBindToAllInterfaces ( ) ; corfuServerThread = new Thread ( ( ) - > { cleanShutdown ( ( NettyServerRouter ) serverContext . getServerRouter ( ) ) ; if ( resetData & & ! ( Boolean ) serverContext . getServerConfig ( ) . get ( _STR ) ; corfuServerThread . start ( ) ; } 
3532	public static ValidationContext getCurrentInstance ( ) { return holder . get ( ) ; } 
3533	public I _ CmsExtractionResult extractContent ( CmsObject cms , CmsResource resource , CmsSearchIndex index ) throws CmsIndexException , CmsException { logContentExtraction ( resource , index ) ; CmsFile file = readFile ( cms , resource ) ; try { return CmsExtractorOpenOffice . getExtractor ( ) . extractText ( file . getContents ( ) ) ; } catch ( Exception e ) { throw new CmsIndexException ( Messages . get ( ) . container ( Messages . ERR _ TEXT _ EXTRACTION _ _NUM , resource . getRootPath ( ) ) , e ) ; } } 
3534	private byte [ ] extractRelevantValues ( Cursor cursor , String [ ] settings ) { if ( ! cursor . moveToFirst ( ) ) { Log . e ( TAG , _STR + value ) ; } } Aggregate the result . byte [ ] result = new byte [ totalSize ] ; int pos = _NUM ; final int keyValuePairCount = backedUpSettingIndex * _NUM ; for ( int i = _NUM ; i < keyValuePairCount ; i + + ) { final byte [ ] value = values [ i ] ; if ( value ! = NULL _ VALUE ) { pos = writeInt ( result , pos , value . length ) ; pos = writeBytes ( result , pos , value ) ; } else { pos = writeInt ( result , pos , NULL _ SIZE ) ; } } return result ; } 
3535	public static SecretKey loadOrGenerateWrappedKey ( File keyFile , KeyPair keyPair ) throws GeneralSecurityException , IOException { final SecretKeyWrapper wrapper = new SecretKeyWrapper ( keyPair ) ; Generate secret key if none exists if ( ! keyFile . exists ( ) ) { final byte [ ] raw = EncryptionHelper . generateRandom ( Constants . ENCRYPTION _ KEY _ LENGTH ) ; final SecretKey key = new SecretKeySpec ( raw , _STR ) ; final byte [ ] wrapped = wrapper . wrap ( key ) ; FileHelper . writeBytesToFile ( keyFile , wrapped ) ; } Even if we just generated the key , always read it back to ensure we can read it successfully . final byte [ ] wrapped = FileHelper . readFileToBytes ( keyFile ) ; return wrapper . unwrap ( wrapped ) ; } 
3536	private void updateRulesForAllAppsUL ( @ RestrictType int type ) { if ( Trace . isTagEnabled ( Trace . TRACE _ TAG _ NETWORK ) ) { Trace . traceBegin ( Trace . TRACE _ TAG _ NETWORK , _STR + type ) ; } } } } finally { Trace . traceEnd ( Trace . TRACE _ TAG _ NETWORK ) ; } } 
3537	public boolean equals ( Range otherRange ) { return compareTo ( otherRange ) = = _NUM ; } 
3538	public < T extends Object > T load ( T keyObject , DynamoDBMapperConfig config ) { @ SuppressWarnings ( _STR ) final Class < T > clazz = ( Class < T > ) keyObject . getClass ( ) ; config = mergeConfig ( config ) ; final ItemConverter converter = getConverter ( config ) ; final String tableName = getTableName ( clazz , keyObject , config ) ; final GetItemRequest rq = new GetItemRequest ( ) . withRequestMetricCollector ( config . getRequestMetricCollector ( ) ) ; final Map < String , AttributeValue > key = getKey ( converter , keyObject , clazz ) ; rq . setKey ( key ) ; rq . setTableName ( tableName ) ; rq . setConsistentRead ( config . getConsistentReads ( ) = = ConsistentReads . CONSISTENT ) ; final GetItemResult item = db . getItem ( applyUserAgent ( rq ) ) ; final Map < String , AttributeValue > itemAttributes = item . getItem ( ) ; if ( itemAttributes = = null ) { return null ; } final T object = privateMarshallIntoObject ( converter , toParameters ( itemAttributes , clazz , tableName , config ) ) ; return object ; } 
3539	public static void localRunnerNotification ( JobConf conf , JobStatus status ) { JobEndStatusInfo notification = createNotification ( conf , status ) ; if ( notification ! = null ) { do { try { int code = httpNotification ( notification . getUri ( ) , notification . getTimeout ( ) ) ; if ( code ! = _NUM _NUM _NUM ) { throw new IOException ( _STR , iex ) ; } } while ( notification . configureForRetry ( ) ) ; } } 
3540	public static HttpResponse execute ( final String url , final String method , final String basicAuthUsername , final String basicAuthPassword , final Map < String , String > parameters , final Map < String , String > headers , final String entity ) { try { final HttpClient client = buildHttpClient ( basicAuthUsername , basicAuthPassword ) ; final URI uri = buildHttpUri ( url , parameters ) ; final HttpUriRequest request ; switch ( method . toLowerCase ( ) ) { case _STR : default : request = new HttpGet ( uri ) ; break ; } headers . forEach ( request : : addHeader ) ; prepareHttpRequest ( request , basicAuthUsername , basicAuthPassword , parameters ) ; return client . execute ( request ) ; } catch ( final Exception e ) { LOGGER . error ( e . getMessage ( ) , e ) ; } return null ; } 
3541	public void setPadding ( float top , float bottom , float left , float right ) { if ( proxyTo ! = null ) { for ( Style s : proxyTo ) { s . setPadding ( top , bottom , left , right ) ; } return ; } if ( top < _NUM | | left < _NUM | | right < _NUM | | bottom < _NUM ) { throw new IllegalArgumentException ( _STR ) ; } if ( padding [ Component . TOP ] ! = top | | padding [ Component . BOTTOM ] ! = bottom | | padding [ Component . LEFT ] ! = left | | padding [ Component . RIGHT ] ! = right ) { padding [ Component . TOP ] = top ; padding [ Component . BOTTOM ] = bottom ; padding [ Component . LEFT ] = left ; padding [ Component . RIGHT ] = right ; modifiedFlag | = PADDING _ MODIFIED ; firePropertyChanged ( PADDING ) ; } } 
3542	public void aggregate ( int i , int j , long v , WorkerAggregatorUsage worker ) { singletonVector . clear ( ) ; singletonVector . set ( j , v ) ; worker . aggregate ( getRowAggregatorName ( i ) , singletonVector ) ; } 
3543	public static double oliverSimilarity ( String text _NUM , String text _NUM ) { preprocessDocument ( text _NUM ) ; preprocessDocument ( text _NUM ) ; String smallerDoc = text _NUM ; String biggerDoc = text _NUM ; if ( text _NUM . length ( ) > text _NUM . length ( ) ) { smallerDoc = text _NUM ; biggerDoc = text _NUM ; } double p = PHPSimilarText . similarityPercentage ( smallerDoc , biggerDoc ) ; p / = _NUM _NUM _NUM . _NUM ; return p ; } 
3544	public void handleRefreshEvent ( final EnvironmentChangeEvent event ) { LOGGER . debug ( _STR , event ) ; rebind ( ) ; } 
3545	public boolean isEmpty ( ) { return size ( ) = = _NUM ; } 
3546	public void addShadow ( ) { startShadow ( ) ; } 
3547	public static String startup ( final List < JVMClusterUtil . MasterThread > masters , final List < JVMClusterUtil . RegionServerThread > regionservers ) throws IOException { Configuration configuration = null ; if ( masters = = null | | masters . isEmpty ( ) ) { return null ; } for ( JVMClusterUtil . MasterThread t : masters ) { configuration = t . getMaster ( ) . getConfiguration ( ) ; t . start ( ) ; } Wait for an active master having an active master before starting the region threads allows then to succeed on their connection to master long startTime = System . currentTimeMillis ( ) ; while ( findActiveMaster ( masters ) = = null ) { try { Thread . sleep ( _NUM _NUM _NUM ) ; } catch ( InterruptedException e ) { throw ( InterruptedIOException ) new InterruptedIOException ( ) . initCause ( e ) ; } int startTimeout = configuration ! = null ? Integer . parseInt ( configuration . get ( _STR + msg ) ; throw new RuntimeException ( msg ) ; } try { Thread . sleep ( _NUM _NUM _NUM ) ; } catch ( InterruptedException e ) { throw ( InterruptedIOException ) new InterruptedIOException ( ) . initCause ( e ) ; } } } 
3548	public Collection < V > values ( ) { if ( valuesCollection = = null ) { valuesCollection = new AbstractCollection < V > ( ) { @ Override public boolean contains ( Object object ) { return containsValue ( object ) ; } @ Override public int size ( ) { return LinkedHashMap . this . size ( ) ; } @ Override public void clear ( ) { LinkedHashMap . this . clear ( ) ; } @ Override public Iterator < V > iterator ( ) { return new ValueIterator < K , V > ( LinkedHashMap . this ) ; } } ; } return valuesCollection ; } 
3549	public void makeLeadNodeFor ( Set < GraphNode > members ) { Accumulate all successors Set < GraphNode > newSucc = new HashSet < > ( ) ; Set < GraphNode > newSuccClosed = new HashSet < > ( ) ; for ( GraphNode n : members ) { newSucc . addAll ( n . succ ) ; newSuccClosed . addAll ( n . succClosed ) ; } newSucc . removeAll ( members ) ; newSuccClosed . removeAll ( members ) ; succ = newSucc ; succClosed = newSuccClosed ; Rewrite all direct successors to have us as predecessor for ( GraphNode n : succ ) { n . pred . removeAll ( members ) ; n . pred . add ( this ) ; } Find all predecessor nodes and relink link them to point to us Set < GraphNode > done = new HashSet < > ( ) ; Set < GraphNode > newAliases = new HashSet < > ( ) ; for ( GraphNode member : members ) { addSiblings ( newAliases , member ) ; } becomeLeaderOf ( newAliases ) ; for ( GraphNode n : members ) { if ( n ! = this ) { pred . addAll ( n . pred ) ; n . relocateAllRefTo ( this , done ) ; n . becomeSubordinateOf ( this ) ; } } pred . removeAll ( members ) ; } 
3550	public void decRef ( ) throws IOException { ensureOpen ( ) ; final int rc = refCount . getAndDecrement ( ) ; if ( rc = = _NUM ) { boolean success = false ; try { commit ( ) ; doClose ( ) ; success = true ; } finally { if ( ! success ) { Put reference back on failure refCount . incrementAndGet ( ) ; } } readerFinished ( ) ; } else if ( rc < = _NUM ) { throw new IllegalStateException ( _STR ) ; } } 
3551	public ByteBuffer getInputBuffer ( int index ) { ByteBuffer newBuffer = getBuffer ( true , index ) ; synchronized ( mBufferLock ) { invalidateByteBuffer ( mCachedInputBuffers , index ) ; mDequeuedInputBuffers . put ( index , newBuffer ) ; } return newBuffer ; } 
3552	public ApfGenerator addLoad _NUM Indexed ( Register register , int offset ) { Instruction instruction = new Instruction ( Opcodes . LDBX , register ) ; instruction . setUnsignedImm ( offset ) ; addInstruction ( instruction ) ; return this ; } 
3553	private void step _NUM b ( StringBuilder sb ) { if ( _ R _NUM > = sb . length ( ) ) return ; String s = sb . toString ( ) ; int index = _NUM ; if ( ( s . endsWith ( _STR ) & & ( index = s . length ( ) - _NUM ) > = _ R _NUM ) { if ( _ removedE ) sb . delete ( index , index + _NUM ) ; return ; } } 
3554	private void _ close ( ) { try { storageEngine . close ( ) ; } catch ( Exception ex ) { throw new RuntimeException ( ex ) ; } finally { Ensures that the Dataframe can ' t be used after _ close ( ) is called . data = null ; } } 
3555	protected byte [ ] engineGetEncoded ( ) { DHParameter dhP = new DHParameter ( currentSpec . getP ( ) , currentSpec . getG ( ) , currentSpec . getL ( ) ) ; try { return dhP . getEncoded ( ASN _NUM Encoding . DER ) ; } catch ( IOException e ) { throw new RuntimeException ( _STR ) ; } } 
3556	public void testSquare _ OpenSSLBug ( ) { int COUNT = _NUM _NUM _NUM ; for ( int i = _NUM ; i < COUNT ; + + i ) { ECFieldElement x = generateSquareInput _ OpenSSLBug ( ) ; BigInteger X = x . toBigInteger ( ) ; BigInteger R = X . multiply ( X ) . mod ( Q ) ; ECFieldElement z = x . square ( ) ; BigInteger Z = z . toBigInteger ( ) ; assertEquals ( R , Z ) ; } } 
3557	private Map getCurrentStep ( Phase phase ) { String target = phase . ordinal ( ) < = Phase . match . ordinal ( ) ? Phase . match . name ( ) : Phase . result . name ( ) ; Map lastWithValue = null ; for ( Map stepOrHook : getSteps ( ) ) { if ( stepOrHook . get ( target ) = = null ) { return stepOrHook ; } else { lastWithValue = stepOrHook ; } } return lastWithValue ; } 
3558	public void testChooseTarget _NUM ( ) throws Exception { make data node _NUM to be not qualified to choose updateHeartbeatWithUsage ( dataNodes [ _NUM ] , _NUM * HdfsServerConstants . MIN _ BLOCKS _ FOR _ WRITE * BLOCK _ SIZE , _NUM L , ( HdfsServerConstants . MIN _ BLOCKS _ FOR _ WRITE - _NUM ) * BLOCK _ SIZE , _NUM L , _NUM L , _NUM L , _NUM , no space _NUM ) ; DatanodeStorageInfo [ ] targets ; targets = chooseTarget ( _NUM ) ; assertEquals ( targets . length , _NUM ) ; targets = chooseTarget ( _NUM ) ; assertEquals ( targets . length , _NUM ) ; assertEquals ( storages [ _NUM ] , targets [ _NUM ] ) ; targets = chooseTarget ( _NUM ) ; assertEquals ( targets . length , _NUM ) ; assertEquals ( storages [ _NUM ] , targets [ _NUM ] ) ; assertFalse ( isOnSameRack ( targets [ _NUM ] , targets [ _NUM ] ) ) ; targets = chooseTarget ( _NUM ) ; assertEquals ( targets . length , _NUM ) ; assertEquals ( storages [ _NUM ] , targets [ _NUM ] ) ; assertTrue ( isOnSameRack ( targets [ _NUM ] , targets [ _NUM ] ) ) ; assertFalse ( isOnSameRack ( targets [ _NUM ] , targets [ _NUM ] ) ) ; targets = chooseTarget ( _NUM ) ; assertEquals ( targets . length , _NUM ) ; assertEquals ( storages [ _NUM ] , targets [ _NUM ] ) ; assertTrue ( cluster . isNodeGroupAware ( ) ) ; verifyNoTwoTargetsOnSameNodeGroup ( targets ) ; assertTrue ( isOnSameRack ( targets [ _NUM ] , targets [ _NUM ] ) | | isOnSameRack ( targets [ _NUM ] , targets [ _NUM ] ) ) ; updateHeartbeatWithUsage ( dataNodes [ _NUM ] , _NUM * HdfsServerConstants . MIN _ BLOCKS _ FOR _ WRITE * BLOCK _ SIZE , _NUM L , HdfsServerConstants . MIN _ BLOCKS _ FOR _ WRITE * BLOCK _ SIZE , _NUM L , _NUM L , _NUM L , _NUM , _NUM ) ; } 
3559	 @ SuppressWarnings ( _STR , extensionType . getName ( ) ) ) ; } if ( registerExtension ) { registerServiceClass ( o . getClass ( ) , classNameBundleLookup , bundle , entry . getValue ( ) ) ; } } } classLoaderBundleLookup . put ( bundle . getClassLoader ( ) , bundle ) ; } } 
3560	public static List < Integer > loadCarrierActionList ( Context context , Intent intent ) { CarrierConfigManager carrierConfigManager = ( CarrierConfigManager ) context . getSystemService ( Context . CARRIER _ CONFIG _ SERVICE ) ; return an empty list if no match found List < Integer > actionList = new ArrayList < > ( ) ; if ( carrierConfigManager = = null ) { Rlog . e ( TAG , _STR + arg _NUM ) ; } return actionList ; } 
3561	public FluentInitializer inMode ( SelectionMode mode ) { selectionMode = mode ; validateAndUpdate ( ) ; return this ; } 
3562	public static Quad subst ( Quad quad , Binding b , Map < Node , Node > bNodeMap ) { Node g = quad . getGraph ( ) ; Node s = quad . getSubject ( ) ; Node p = quad . getPredicate ( ) ; Node o = quad . getObject ( ) ; Node g _NUM = g ; Node s _NUM = s ; Node p _NUM = p ; Node o _NUM = o ; replace blank nodes . if ( g _NUM . isBlank ( ) | | Var . isBlankNodeVar ( g _NUM ) ) g _NUM = newBlank ( g _NUM , bNodeMap ) ; if ( s _NUM . isBlank ( ) | | Var . isBlankNodeVar ( s _NUM ) ) s _NUM = newBlank ( s _NUM , bNodeMap ) ; if ( p _NUM . isBlank ( ) | | Var . isBlankNodeVar ( p _NUM ) ) p _NUM = newBlank ( p _NUM , bNodeMap ) ; if ( o _NUM . isBlank ( ) | | Var . isBlankNodeVar ( o _NUM ) ) o _NUM = newBlank ( o _NUM , bNodeMap ) ; Quad q = quad ; if ( s _NUM ! = s | | p _NUM ! = p | | o _NUM ! = o | | g _NUM ! = g ) q = new Quad ( g _NUM , s _NUM , p _NUM , o _NUM ) ; Quad q _NUM = Substitute . substitute ( q , b ) ; return q _NUM ; } 
3563	public static void doneUow ( UnitOfWork uow , Exchange exchange ) { unit of work is done try { if ( uow ! = null ) { uow . done ( exchange ) ; } } catch ( Throwable e ) { LOG . warn ( _STR , e ) ; } remove uow from exchange as its done exchange . setUnitOfWork ( null ) ; } 
3564	public boolean isSet ( _ Fields field ) { if ( field = = null ) { throw new java . lang . IllegalArgumentException ( ) ; } switch ( field ) { case SUCCESS : return isSetSuccess ( ) ; case SEC : return isSetSec ( ) ; case TNASE : return isSetTnase ( ) ; } throw new java . lang . IllegalStateException ( ) ; } 
3565	public void addAction ( AccessibilityAction action ) { enforceNotSealed ( ) ; addActionUnchecked ( action ) ; } 
3566	private Object createPhoenixArray ( byte [ ] bytes , int offset , int length , SortOrder sortOrder , PDataType baseDataType , Integer maxLength , PDataType desiredDataType ) { if ( bytes = = null | | length = = _NUM ) { return null ; } Object [ ] elements ; if ( ! baseDataType . isFixedWidth ( ) ) { ByteBuffer buffer = ByteBuffer . wrap ( bytes , offset , length ) ; int initPos = buffer . position ( ) ; buffer . position ( ( buffer . limit ( ) - ( Bytes . SIZEOF _ BYTE + Bytes . SIZEOF _ INT ) ) ) ; int noOfElements = buffer . getInt ( ) ; boolean useShort = true ; int baseSize = Bytes . SIZEOF _ SHORT ; if ( noOfElements < _NUM ) { noOfElements = - noOfElements ; baseSize = Bytes . SIZEOF _ INT ; useShort = false ; } if ( baseDataType = = desiredDataType ) { elements = ( Object [ ] ) java . lang . reflect . Array . newInstance ( baseDataType . getJavaClass ( ) , noOfElements ) ; } else { elements = ( Object [ ] ) java . lang . reflect . Array . newInstance ( desiredDataType . getJavaClass ( ) , noOfElements ) ; } buffer . position ( buffer . limit ( ) - ( Bytes . SIZEOF _ BYTE + ( _NUM * Bytes . SIZEOF _ INT ) ) ) ; int indexOffset = buffer . getInt ( ) ; buffer . position ( initPos ) ; buffer . position ( indexOffset + initPos ) ; ByteBuffer indexArr = ByteBuffer . allocate ( initOffsetArray ( noOfElements , baseSize ) ) ; byte [ ] array = indexArr . array ( ) ; buffer . get ( array ) ; int countOfElementsRead = _NUM ; int i = _NUM ; int currOffset = - _NUM ; int nextOff = - _NUM ; boolean foundNull = false ; if ( noOfElements ! = _NUM ) { while ( countOfElementsRead < = noOfElements ) { if ( countOfElementsRead = = _NUM ) { currOffset = getOffset ( indexArr , countOfElementsRead , useShort , indexOffset ) ; countOfElementsRead + + ; } else { currOffset = nextOff ; } if ( countOfElementsRead = = noOfElements ) { nextOff = indexOffset - _NUM ; } else { nextOff = getOffset ( indexArr , countOfElementsRead + _NUM , useShort , indexOffset ) ; } countOfElementsRead + + ; if ( ( bytes [ currOffset + initPos ] ! = QueryConstants . SEPARATOR _ BYTE & & bytes [ currOffset + initPos ] ! = QueryConstants . DESC _ SEPARATOR _ BYTE ) & & foundNull ) { Found a non null element foundNull = false ; } if ( bytes [ currOffset + initPos ] = = QueryConstants . SEPARATOR _ BYTE | | bytes [ currOffset + initPos ] = = QueryConstants . DESC _ SEPARATOR _ BYTE ) { Null element foundNull = true ; i + + ; continue ; } int elementLength = nextOff - currOffset ; buffer . position ( currOffset + initPos ) ; Subtract the seperator from the element length byte [ ] val = new byte [ elementLength - _NUM ] ; buffer . get ( val ) ; if ( baseDataType = = desiredDataType ) { elements [ i + + ] = baseDataType . toObject ( val , sortOrder ) ; } else { elements [ i + + ] = desiredDataType . toObject ( val , sortOrder , baseDataType ) ; } } } } else { int elemLength = ( maxLength = = null ? baseDataType . getByteSize ( ) : maxLength ) ; int noOfElements = length / elemLength ; if ( baseDataType = = desiredDataType ) { elements = ( Object [ ] ) java . lang . reflect . Array . newInstance ( baseDataType . getJavaClass ( ) , noOfElements ) ; } else { elements = ( Object [ ] ) java . lang . reflect . Array . newInstance ( desiredDataType . getJavaClass ( ) , noOfElements ) ; } ImmutableBytesWritable ptr = new ImmutableBytesWritable ( ) ; for ( int i = _NUM ; i < noOfElements ; i + + ) { ptr . set ( bytes , offset + i * elemLength , elemLength ) ; if ( baseDataType = = desiredDataType ) { elements [ i ] = baseDataType . toObject ( ptr , sortOrder ) ; } else { elements [ i ] = desiredDataType . toObject ( ptr , baseDataType , sortOrder ) ; } } } if ( baseDataType = = desiredDataType ) { return PArrayDataType . instantiatePhoenixArray ( baseDataType , elements ) ; } else { return PArrayDataType . instantiatePhoenixArray ( desiredDataType , elements ) ; } } 
3567	public static Map < String , Object > recalcOrderTax ( DispatchContext ctx , Map < String , ? extends Object > context ) { LocalDispatcher dispatcher = ctx . getDispatcher ( ) ; Delegator delegator = ctx . getDelegator ( ) ; String orderId = ( String ) context . get ( _STR , locale ) ; Debug . logError ( createOrderAdjErrMsg , module ) ; return ServiceUtil . returnError ( createOrderAdjErrMsg ) ; } if ( ServiceUtil . isError ( createOrderAdjResponse ) ) { Debug . logError ( ServiceUtil . getErrorMessage ( createOrderAdjResponse ) , module ) ; return ServiceUtil . returnError ( ServiceUtil . getErrorMessage ( createOrderAdjResponse ) ) ; } } } return ServiceUtil . returnSuccess ( ) ; } 
3568	public void startFlipping ( ) { mStarted = true ; updateRunning ( ) ; } 
3569	public static Enumeration listStemmers ( ) { initStemmers ( ) ; return m _ Stemmers . elements ( ) ; } 
3570	public List < CmsResource > addResourcesToFolder ( CmsObject cms , String resourcename , CmsResourceFilter filter ) throws CmsException { CmsResource xmlPage = findXmlPage ( cms , resourcename ) ; if ( xmlPage ! = null ) { String path = getSubPath ( cms , xmlPage , resourcename ) ; String rootPath = cms . getRequestContext ( ) . removeSiteRoot ( xmlPage . getRootPath ( ) ) ; ArrayList < CmsResource > ret = new ArrayList < CmsResource > ( ) ; CmsFile file = cms . readFile ( xmlPage ) ; CmsXmlPage xml = CmsXmlPageFactory . unmarshal ( cms , file ) ; if ( CmsStringUtil . isEmptyOrWhitespaceOnly ( path ) ) { sub path is empty - > return all existing locales for the resource if ( file . getLength ( ) = = _NUM ) { return ret ; } List < Locale > locales = xml . getLocales ( ) ; Iterator < Locale > iter _NUM = locales . iterator ( ) ; while ( iter _NUM . hasNext ( ) ) { Locale locale = iter _NUM . next ( ) ; ret . add ( getResourceForLocale ( xmlPage , locale ) ) ; } int plainId = OpenCms . getResourceManager ( ) . getResourceType ( CmsResourceTypePlain . getStaticTypeName ( ) ) . getTypeId ( ) ; check temp file table to add virtual file Iterator < String > iter _NUM = getVirtualFiles ( ) . iterator ( ) ; while ( iter _NUM . hasNext ( ) ) { String virtualFileName = iter _NUM . next ( ) ; String virtualFilePath = rootPath + _STR + EXTENSION _ ELEMENT ; content = prepareContent ( content , cms , xmlPage , fullPath ) ; int length = content . length ( ) ; try { length = content . getBytes ( CmsLocaleManager . getResourceEncoding ( cms , xmlPage ) ) . length ; } catch ( UnsupportedEncodingException e ) { this will never happen since UTF - _NUM is always supported } ret . add ( getResourceForElement ( xmlPage , fullPath , length ) ) ; } } return ret ; } return null ; } 
3571	public void testJoinUniqueKeys ( ) { RelNode rel = convertSql ( _STR ) ; final RelMetadataQuery mq = RelMetadataQuery . instance ( ) ; Set < ImmutableBitSet > result = mq . getUniqueKeys ( rel ) ; assertThat ( result . isEmpty ( ) , is ( true ) ) ; assertUniqueConsistent ( rel ) ; } 
3572	public void startQuorum ( ) throws IOException { shutdownAll ( ) ; for ( int i = _NUM ; i < = N + _NUM ; + + i ) { start ( i ) ; } for ( int i = _NUM ; i < = N + _NUM ; + + i ) { Assert . assertTrue ( _STR + getPeer ( i ) . clientPort , ClientBase . CONNECTION _ TIMEOUT ) ) ; } } 
3573	public boolean onInterceptTouchEvent ( RecyclerView rv , MotionEvent ev ) { return handleTouchEvent ( ev ) ; } 
3574	public void performClick ( ) { if ( ! isEnabled ( ) ) { return ; } onClick ( ) ; if ( mOnClickListener ! = null & & mOnClickListener . onPreferenceClick ( this ) ) { return ; } PreferenceManager preferenceManager = getPreferenceManager ( ) ; if ( preferenceManager ! = null ) { PreferenceManager . OnPreferenceTreeClickListener listener = preferenceManager . getOnPreferenceTreeClickListener ( ) ; if ( listener ! = null & & listener . onPreferenceTreeClick ( this ) ) { return ; } } if ( mIntent ! = null ) { Context context = getContext ( ) ; context . startActivity ( mIntent ) ; } } 
3575	public static void unsupported ( String message ) { skip ( message ) ; } 
3576	public void testAutoIncrementedField ( ) { Date currentTime = new Date ( ) ; String serviceName = _STR ; createService ( currentTime , serviceName , clusterName ) ; ClusterServiceEntity clusterServiceEntity = clusterServiceDAO . findByClusterAndServiceNames ( clusterName , serviceName ) ; clusterServiceDAO . remove ( clusterServiceEntity ) ; assertNull ( clusterServiceDAO . findByClusterAndServiceNames ( clusterName , serviceName ) ) ; } 
3577	public RemoteViews clone ( ) { synchronized ( this ) { Preconditions . checkState ( mIsRoot , _STR ) ; Parcel p = Parcel . obtain ( ) ; Do not parcel the Bitmap cache - doing so creates an expensive copy of all bitmaps . Instead pretend we ' re not owning the cache while parceling . mIsRoot = false ; writeToParcel ( p , PARCELABLE _ ELIDE _ DUPLICATES ) ; p . setDataPosition ( _NUM ) ; mIsRoot = true ; RemoteViews rv = new RemoteViews ( p , mBitmapCache . clone ( ) , mApplication , _NUM ) ; rv . mIsRoot = true ; p . recycle ( ) ; return rv ; } } 
3578	public static ServersShuttingDown getServersShuttingDown ( ) { ServersShuttingDown servers = new ServersShuttingDown ( ) ; Add new servers to the list for ( String server : Monitor . getMmi ( ) . serversShuttingDown ) { servers . addServerShuttingDown ( new ServerShuttingDownInformation ( server ) ) ; } return servers ; } 
3579	public void setLegendItemShape ( Shape shape ) { if ( shape = = null ) { throw new IllegalArgumentException ( _STR ) ; } this . legendItemShape = shape ; fireChangeEvent ( ) ; } 
3580	public org . fife . ui . rsyntaxtextarea . Token yylex ( ) throws java . io . IOException { int zzInput ; int zzAction ; cached fields : int zzCurrentPosL ; int zzMarkedPosL ; int zzEndReadL = zzEndRead ; char [ ] zzBufferL = zzBuffer ; char [ ] zzCMapL = ZZ _ CMAP ; int [ ] zzTransL = ZZ _ TRANS ; int [ ] zzRowMapL = ZZ _ ROWMAP ; int [ ] zzAttrL = ZZ _ ATTRIBUTE ; while ( true ) { zzMarkedPosL = zzMarkedPos ; zzAction = - _NUM ; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL ; zzState = zzLexicalState ; zzForAction : { while ( true ) { if ( zzCurrentPosL < zzEndReadL ) zzInput = zzBufferL [ zzCurrentPosL + + ] ; else if ( zzAtEOF ) { zzInput = YYEOF ; break zzForAction ; } else { store back cached positions zzCurrentPos = zzCurrentPosL ; zzMarkedPos = zzMarkedPosL ; boolean eof = zzRefill ( ) ; get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos ; zzMarkedPosL = zzMarkedPos ; zzBufferL = zzBuffer ; zzEndReadL = zzEndRead ; if ( eof ) { zzInput = YYEOF ; break zzForAction ; } else { zzInput = zzBufferL [ zzCurrentPosL + + ] ; } } int zzNext = zzTransL [ zzRowMapL [ zzState ] + zzCMapL [ zzInput ] ] ; if ( zzNext = = - _NUM ) break zzForAction ; zzState = zzNext ; int zzAttributes = zzAttrL [ zzState ] ; if ( ( zzAttributes & _NUM ) = = _NUM ) { zzAction = zzState ; zzMarkedPosL = zzCurrentPosL ; if ( ( zzAttributes & _NUM ) = = _NUM ) break zzForAction ; } } } store back cached position zzMarkedPos = zzMarkedPosL ; switch ( zzAction < _NUM ? zzAction : ZZ _ ACTION [ zzAction ] ) { case _NUM _NUM : { addToken ( Token . RESERVED _ WORD ) ; } case _NUM _NUM : break ; case _NUM : { addToken ( Token . IDENTIFIER ) ; } case _NUM _NUM : break ; case _NUM : { addToken ( Token . COMMENT _ EOL ) ; addNullToken ( ) ; return firstToken ; } case _NUM _NUM : break ; case _NUM : { addToken ( Token . WHITESPACE ) ; } case _NUM _NUM : break ; case _NUM _NUM : { addToken ( start , zzStartRead - _NUM , Token . LITERAL _ STRING _ DOUBLE _ QUOTE ) ; return firstToken ; } case _NUM _NUM : break ; case _NUM _NUM : { addToken ( start , zzStartRead - _NUM , Token . LITERAL _ CHAR ) ; return firstToken ; } case _NUM _NUM : break ; case _NUM _NUM : { } case _NUM _NUM : break ; case _NUM : { addToken ( Token . OPERATOR ) ; } case _NUM _NUM : break ; case _NUM _NUM : { } case _NUM _NUM : break ; case _NUM : { start = zzMarkedPos - _NUM ; yybegin ( STRING ) ; } case _NUM _NUM : break ; case _NUM _NUM : { yybegin ( YYINITIAL ) ; addToken ( start , zzStartRead , Token . LITERAL _ CHAR ) ; } case _NUM _NUM : break ; case _NUM _NUM : { yybegin ( YYINITIAL ) ; addToken ( start , zzStartRead , Token . LITERAL _ STRING _ DOUBLE _ QUOTE ) ; } case _NUM _NUM : break ; case _NUM : { addNullToken ( ) ; return firstToken ; } case _NUM _NUM : break ; case _NUM : { } case _NUM _NUM : break ; case _NUM : { addToken ( Token . SEPARATOR ) ; } case _NUM _NUM : break ; case _NUM : { start = zzMarkedPos - _NUM ; yybegin ( CHAR _ LITERAL ) ; } case _NUM _NUM : break ; default : if ( zzInput = = YYEOF & & zzStartRead = = zzCurrentPos ) { zzAtEOF = true ; switch ( zzLexicalState ) { case STRING : { addToken ( start , zzStartRead - _NUM , Token . LITERAL _ STRING _ DOUBLE _ QUOTE ) ; return firstToken ; } case _NUM _NUM : break ; case CHAR _ LITERAL : { addToken ( start , zzStartRead - _NUM , Token . LITERAL _ CHAR ) ; return firstToken ; } case _NUM _NUM : break ; case YYINITIAL : { addNullToken ( ) ; return firstToken ; } case _NUM _NUM : break ; default : return null ; } } else { zzScanError ( ZZ _ NO _ MATCH ) ; } } } } 
3581	public static HttpServer _NUM createServer ( String webapp , Configuration conf , String [ ] pathSpecs ) throws IOException { return localServerBuilder ( webapp ) . setFindPort ( true ) . setConf ( conf ) . setPathSpec ( pathSpecs ) . build ( ) ; } 
3582	public Connection createConnection ( final String id , final String name , final Connectable source , final Connectable destination , final Collection < String > relationshipNames ) { final StandardConnection . Builder builder = new StandardConnection . Builder ( processScheduler ) ; final List < Relationship > relationships = new ArrayList < > ( ) ; for ( final String relationshipName : requireNonNull ( relationshipNames ) ) { relationships . add ( new Relationship . Builder ( ) . name ( relationshipName ) . build ( ) ) ; } Create and initialize a FlowFileSwapManager for this connection final FlowFileSwapManager swapManager = createSwapManager ( nifiProperties ) ; final EventReporter eventReporter = createEventReporter ( getBulletinRepository ( ) ) ; try ( final NarCloseable narCloseable = NarCloseable . withNarLoader ( ) ) { final SwapManagerInitializationContext initializationContext = new SwapManagerInitializationContext ( ) { @ Override public ResourceClaimManager getResourceClaimManager ( ) { return resourceClaimManager ; } @ Override public FlowFileRepository getFlowFileRepository ( ) { return flowFileRepository ; } @ Override public EventReporter getEventReporter ( ) { return eventReporter ; } } ; swapManager . initialize ( initializationContext ) ; } return builder . id ( requireNonNull ( id ) . intern ( ) ) . name ( name = = null ? null : name . intern ( ) ) . relationships ( relationships ) . source ( requireNonNull ( source ) ) . destination ( destination ) . swapManager ( swapManager ) . queueSwapThreshold ( nifiProperties . getQueueSwapThreshold ( ) ) . eventReporter ( eventReporter ) . resourceClaimManager ( resourceClaimManager ) . flowFileRepository ( flowFileRepository ) . provenanceRepository ( provenanceRepository ) . build ( ) ; } 
3583	public boolean hasBrokenLinks ( ) { return ( getBrokenRelationsList ( ) . getList ( ) . getTotalSize ( ) > _NUM ) ; } 
3584	public boolean startRecognition ( @ RecognitionFlags int recognitionFlags ) { if ( DBG ) Slog . d ( TAG , _STR ) ; } return startRecognitionLocked ( recognitionFlags ) = = STATUS _ OK ; } } 
3585	public Entry getEntryByTouchPoint ( float x , float y ) { Highlight h = getHighlightByTouchPoint ( x , y ) ; if ( h ! = null ) { return mData . getEntryForHighlight ( h ) ; } return null ; } 
3586	public void testGetFileStatusOnDir ( ) throws Exception { Create the directory Path dir = new Path ( _STR , ioe ) ; } } fs . delete ( dir , true ) ; } 
3587	public String toSource ( String className , Instances data ) throws Exception { StringBuffer result ; result = new StringBuffer ( ) ; result . append ( _STR ) ; return result . toString ( ) ; } 
3588	public Value parameter ( final Str key , final Value def ) throws QueryException { try { final String name = key . toJava ( ) ; final HTTPParams params = connection ( ) . params ; final Value query = params . map ( ) . get ( name ) ; final Value form = params . form ( queryContext . context . options ) . get ( name ) ; if ( query = = null & & form = = null ) return def ; if ( query = = null ) return form ; if ( form = = null ) return query ; return ValueBuilder . concat ( query , form , queryContext ) ; } catch ( final IOException ex ) { throw new QueryException ( ex ) ; } } 
3589	 @ Overridevoid finish ( ) throws IOException { this . out . flushCompressBlock ( ) ; long skipPointer = skipListWriter . writeSkip ( out ) ; if ( savefreqpos ! = parent . freqStart ) { LOG . info ( _STR + parent . freqStart ) ; } termInfo . set ( df , parent . freqStart , parent . proxStart , ( int ) ( skipPointer - parent . freqStart ) ) ; TODO : we could do this incrementally UnicodeUtil . UTF _NUM _NUM toUTF _NUM ( parent . currentTerm , parent . currentTermStart , utf _NUM ) ; if ( df > _NUM ) { parent . termsOut . add ( parent . currentTermobj , fieldInfo . number , utf _NUM . result , utf _NUM . length , termInfo ) ; } parent . termsOut . addTm ( parent . currentTermobj , fieldInfo . number ) ; ; lastDocID = _NUM ; df = _NUM ; } 
3590	public void pageBreakFiles ( ) throws IOException { HSSFWorkbook wb _NUM = HSSFTestDataSamples . openSampleWorkbook ( _STR , _NUM , sheet . getColumnBreaks ( ) . length ) ; wb _NUM . close ( ) ; } 
3591	public AccessibilityNodeInfo createAccessibilityNodeInfo ( View host ) { return host . createAccessibilityNodeInfoInternal ( ) ; } 
3592	public void onClose ( String sitePath , boolean isNew ) { if ( m _ dependingElementId ! = null ) { m _ handler . reloadElements ( m _ currentElementId , m _ dependingElementId ) ; m _ dependingElementId = null ; } else { m _ handler . reloadElements ( m _ currentElementId ) ; } m _ handler . addToRecent ( m _ currentElementId ) ; m _ currentElementId = null ; } 
3593	public Rectangle getBoxSize ( int index , String boxName ) { PdfDictionary page = pageRefs . getPageNRelease ( index ) ; PdfArray box = null ; if ( boxName . equals ( _STR ) ) box = ( PdfArray ) getPdfObjectRelease ( page . get ( PdfName . MEDIABOX ) ) ; if ( box = = null ) return null ; return getNormalizedRectangle ( box ) ; } 
3594	public void addExportRuleUri ( String exportUri ) { m _ exportTmpRule . addExportResourcePattern ( exportUri ) ; } 
3595	public void setQuick ( int index , double value ) { invalidateCachedLength ( ) ; values . set ( index , value ) ; } 
3596	public void testClear _ Empty ( ) { Graph graph = producer . newInstance ( ) ; Graph base = copy ( graph ) ; graph . getEventManager ( ) . register ( GL ) ; txnRun ( graph , ( ) - > graph . clear ( ) ) ; txnRun ( graph , ( ) - > assertEmpty ( graph , base ) ) ; GL . assertHasStart ( _STR , graph , GraphEvents . removeAll ) ; GL . clear ( ) ; } 
3597	void reparent ( TaskRecord newTask , int position , String reason ) { final TaskRecord prevTask = task ; if ( prevTask = = newTask ) { throw new IllegalArgumentException ( reason + _STR ) ; } Must reparent first in window manager mWindowContainerController . reparent ( newTask . getWindowContainerController ( ) , position ) ; Remove the activity from the old task and add it to the new task . prevTask . removeActivity ( this , true ) ; newTask . addActivityAtIndex ( position , this ) ; } 
3598	public void attrIndex ( ) { map ( ) . forEach ( ( key , value ) - > { set ( MainOptions . ATTRINCLUDE , key ) ; execute ( new CreateDB ( NAME , FILE ) ) ; check ( _STR , exists ( DBNode . class ) ) ; } ) ; } 
3599	public void initModel ( ) throws Exception { models = new HashSet < Class < ? > > ( ) ; modelClassNames = new HashSet < String > ( ) ; loadModels ( type ) ; } 
3600	public static boolean hasSeconds ( CharSequence inFormat ) { return hasDesignator ( inFormat , SECONDS ) ; } 
3601	public String getHelpText ( I _ CmsWidgetDialog widgetDialog , I _ CmsWidgetParameter param ) { String helpId = getHelpKey ( param ) ; Set < String > helpIdsShown = widgetDialog . getHelpMessageIds ( ) ; if ( helpIdsShown . contains ( helpId ) ) { help hey has already been included in output return _STR ; } } } 
3602	public SupportSQLiteQuery create ( ) { if ( isEmpty ( mGroupBy ) & & ! isEmpty ( mHaving ) ) { throw new IllegalArgumentException ( _STR , mLimit ) ; return new SimpleSQLiteQuery ( query . toString ( ) , mBindArgs ) ; } 
3603	public void putAll ( Map < ? extends Byte , ? extends Long > map ) { Iterator < ? extends Entry < ? extends Byte , ? extends Long > > it = map . entrySet ( ) . iterator ( ) ; for ( int i = map . size ( ) ; i - - > _NUM ; ) { Entry < ? extends Byte , ? extends Long > e = it . next ( ) ; this . put ( e . getKey ( ) , e . getValue ( ) ) ; } } 
3604	public void setTopBorderColor ( XSSFColor color ) { CTBorder ct = getCTBorder ( ) ; if ( color = = null & & ! ct . isSetTop ( ) ) return ; CTBorderPr pr = ct . isSetTop ( ) ? ct . getTop ( ) : ct . addNewTop ( ) ; if ( color ! = null ) pr . setColor ( color . getCTColor ( ) ) ; else pr . unsetColor ( ) ; int idx = _ stylesSource . putBorder ( new XSSFCellBorder ( ct , _ theme , _ stylesSource . getIndexedColors ( ) ) ) ; _ cellXf . setBorderId ( idx ) ; _ cellXf . setApplyBorder ( true ) ; } 
3605	 / * * * Find the most current table info file in the given directory * * Looks within the given directory for any table info files * and takes the ' current ' one - meaning the one with the highest sequence number if present * or no sequence number at all if none exist ( for backward compatibility from before there * were sequence numbers ) . * If there are multiple possible files found * and the we ' re not in read only mode it also deletes the older files . * * @ return The file status of the current table info file or null if it does not exist * @ throws IOException * only visible for FSTableDescriptorMigrationToSubdir , can be removed with thatstatic FileStatus getCurrentTableInfoStatus ( FileSystem fs , Path dir , boolean removeOldFiles ) throws IOException { FileStatus [ ] status = FSUtils . listStatus ( fs , dir , TABLEINFO _ PATHFILTER ) ; if ( status = = null | | status . length < _NUM ) return null ; FileStatus mostCurrent = null ; for ( FileStatus file : status ) { if ( mostCurrent = = null | | TABLEINFO _ FILESTATUS _ COMPARATOR . compare ( file , mostCurrent ) < _NUM ) { mostCurrent = file ; } } if ( removeOldFiles & & status . length > _NUM ) { Clean away old versions for ( FileStatus file : status ) { Path path = file . getPath ( ) ; if ( ! file . equals ( mostCurrent ) ) { if ( ! fs . delete ( file . getPath ( ) , false ) ) { LOG . warn ( _STR + path ) ; } } } } return mostCurrent ; } 
3606	public Builder setSchema ( org . apache . phoenix . coprocessor . generated . PSchemaProtos . PSchema . Builder builderForValue ) { if ( schemaBuilder _ = = null ) { schema _ = builderForValue . build ( ) ; onChanged ( ) ; } else { schemaBuilder _ . setMessage ( builderForValue . build ( ) ) ; } bitField _NUM _ | = _NUM x _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM ; return this ; } 
3607	public void testFullBackupMultipleEmpty ( ) throws Exception { LOG . info ( _STR ) ; List < TableName > tables = Lists . newArrayList ( table _NUM , table _NUM ) ; fullTableBackup ( tables ) ; } 
3608	public float loadFileIntoBuffer ( String filename , MultiChannelBuffer outBuffer ) { final int readBufferSize = _NUM _NUM _NUM _NUM ; float sampleRate = _NUM ; AudioRecordingStream stream = mimp . getAudioRecordingStream ( filename , readBufferSize , false ) ; if ( stream ! = null ) { stream . open ( ) ; stream . play ( ) ; sampleRate = stream . getFormat ( ) . getSampleRate ( ) ; final int channelCount = stream . getFormat ( ) . getChannels ( ) ; for reading the file in , in chunks . MultiChannelBuffer readBuffer = new MultiChannelBuffer ( channelCount , readBufferSize ) ; make sure the out buffer is the correct size and type . outBuffer . setChannelCount ( channelCount ) ; how many samples to read total long totalSampleCount = stream . getSampleFrameLength ( ) ; if ( totalSampleCount = = - _NUM ) { totalSampleCount = AudioUtils . millis _NUM Frames ( stream . getMillisecondLength ( ) , stream . getFormat ( ) ) ; } debug ( _STR + filename ) ; } return sampleRate ; } 
3609	public static void skipFully ( final InputStream input , final long toSkip ) throws IOException { if ( toSkip < _NUM ) { throw new IllegalArgumentException ( _STR + skipped ) ; } } 
3610	static void resetReplayLimit ( ) { replayLimitId = getNextId ( ) ; } 
3611	DictionaryPage readDictionary ( ColumnChunkMetaData meta ) throws IOException { if ( ! meta . getEncodings ( ) . contains ( Encoding . PLAIN _ DICTIONARY ) & & ! meta . getEncodings ( ) . contains ( Encoding . RLE _ DICTIONARY ) ) { return null ; } TODO : this should use getDictionaryPageOffset ( ) but it isn ' t reliable . if ( f . getPos ( ) ! = meta . getStartingPos ( ) ) { f . seek ( meta . getStartingPos ( ) ) ; } PageHeader pageHeader = Util . readPageHeader ( f ) ; if ( ! pageHeader . isSetDictionary _ page _ header ( ) ) { TODO : should this complain ? return null ; } DictionaryPage compressedPage = readCompressedDictionary ( pageHeader , f ) ; BytesInputDecompressor decompressor = options . getCodecFactory ( ) . getDecompressor ( meta . getCodec ( ) ) ; return new DictionaryPage ( decompressor . decompress ( compressedPage . getBytes ( ) , compressedPage . getUncompressedSize ( ) ) , compressedPage . getDictionarySize ( ) , compressedPage . getEncoding ( ) ) ; } 
3612	public static Point getMatchingBracketPosition ( RSyntaxTextArea textArea , Point input ) { if ( input = = null ) { input = new Point ( ) ; } input . setLocation ( - _NUM , - _NUM ) ; try { Actually position just BEFORE caret . int caretPosition = textArea . getCaretPosition ( ) - _NUM ; RSyntaxDocument doc = ( RSyntaxDocument ) textArea . getDocument ( ) ; char bracket = _NUM ; If the caret was at offset _NUM , we can ' t check _STR goForward = false ; bracketMatch = BRACKETS . charAt ( index - _NUM ) ; } if ( goForward ) { int lastLine = map . getElementCount ( ) ; Start just after the found bracket since we ' re sure we ' re not in a comment . start = caretPosition + _NUM ; int numEmbedded = _NUM ; boolean haveTokenList = false ; while ( true ) { doc . getText ( start , end - start , charSegment ) ; int segOffset = charSegment . offset ; for ( int i = segOffset ; i < segOffset + charSegment . count ; i + + ) { char ch = charSegment . array [ i ] ; if ( ch = = bracket ) { if ( ! haveTokenList ) { token = doc . getTokenListForLine ( curLine ) ; haveTokenList = true ; } int offset = start + ( i - segOffset ) ; token = RSyntaxUtilities . getTokenAtOffset ( token , offset ) ; if ( token . getType ( ) = = Token . SEPARATOR & & token . getLanguageIndex ( ) = = languageIndex ) { numEmbedded + + ; } } else if ( ch = = bracketMatch ) { if ( ! haveTokenList ) { token = doc . getTokenListForLine ( curLine ) ; haveTokenList = true ; } int offset = start + ( i - segOffset ) ; token = RSyntaxUtilities . getTokenAtOffset ( token , offset ) ; if ( token . getType ( ) = = Token . SEPARATOR & & token . getLanguageIndex ( ) = = languageIndex ) { if ( numEmbedded = = _NUM ) { if ( textArea . isCodeFoldingEnabled ( ) & & textArea . getFoldManager ( ) . isLineHidden ( curLine ) ) { Match hidden in a fold return input ; } input . setLocation ( caretPosition , offset ) ; return input ; } numEmbedded - - ; } } } haven ' t found the match . if ( + + curLine = = lastLine ) { return input ; } Otherwise , go through the next line . haveTokenList = false ; line = map . getElement ( curLine ) ; start = line . getStartOffset ( ) ; end = line . getEndOffset ( ) ; } End of while ( true ) . } else End of if ( goForward ) . Otherwise , we ' re going backward through the file ( since we found ' } ' , ' ) ' or ' ] ' ) . { goForward = = false End just before the found bracket since we ' re sure we ' re not in a comment . - _NUM ; end = caretPosition ; int numEmbedded = _NUM ; boolean haveTokenList = false ; Token t _NUM ; while ( true ) { doc . getText ( start , end - start , charSegment ) ; int segOffset = charSegment . offset ; int iStart = segOffset + charSegment . count - _NUM ; for ( int i = iStart ; i > = segOffset ; i - - ) { char ch = charSegment . array [ i ] ; if ( ch = = bracket ) { if ( ! haveTokenList ) { token = doc . getTokenListForLine ( curLine ) ; haveTokenList = true ; } int offset = start + ( i - segOffset ) ; t _NUM = RSyntaxUtilities . getTokenAtOffset ( token , offset ) ; if ( t _NUM . getType ( ) = = Token . SEPARATOR & & token . getLanguageIndex ( ) = = languageIndex ) { numEmbedded + + ; } } else if ( ch = = bracketMatch ) { if ( ! haveTokenList ) { token = doc . getTokenListForLine ( curLine ) ; haveTokenList = true ; } int offset = start + ( i - segOffset ) ; t _NUM = RSyntaxUtilities . getTokenAtOffset ( token , offset ) ; if ( t _NUM . getType ( ) = = Token . SEPARATOR & & token . getLanguageIndex ( ) = = languageIndex ) { if ( numEmbedded = = _NUM ) { input . setLocation ( caretPosition , offset ) ; return input ; } numEmbedded - - ; } } } haven ' t found the match . if ( - - curLine = = - _NUM ) { return input ; } Otherwise , get ready for going through the next line . haveTokenList = false ; line = map . getElement ( curLine ) ; start = line . getStartOffset ( ) ; end = line . getEndOffset ( ) ; } End of while ( true ) . } End of else . } catch ( BadLocationException ble ) { Shouldn ' t ever happen . ble . printStackTrace ( ) ; } Something went wrong . . . return input ; } 
3613	final void dispatchOnScrollChanged ( ) { NOTE : because of the use of CopyOnWriteArrayList , we * must * use an iterator to perform the dispatching . The iterator is a safe guard against listeners that could mutate the list by calling the various add / remove methods . This prevents the array from being modified while we iterate it . final CopyOnWriteArray < OnScrollChangedListener > listeners = mOnScrollChangedListeners ; if ( listeners ! = null & & listeners . size ( ) > _NUM ) { CopyOnWriteArray . Access < OnScrollChangedListener > access = listeners . start ( ) ; try { int count = access . size ( ) ; for ( int i = _NUM ; i < count ; i + + ) { access . get ( i ) . onScrollChanged ( ) ; } } finally { listeners . end ( ) ; } } } 
3614	public static void main ( String [ ] args ) { Configuration conf = HBaseConfiguration . create ( ) ; try { Properties zkProperties = ZKConfig . makeZKProps ( conf ) ; writeMyID ( zkProperties ) ; QuorumPeerConfig zkConfig = new QuorumPeerConfig ( ) ; zkConfig . parseProperties ( zkProperties ) ; login the zookeeper server principal ( if using security ) ZKUtil . loginServer ( conf , HConstants . ZK _ SERVER _ KEYTAB _ FILE , HConstants . ZK _ SERVER _ KERBEROS _ PRINCIPAL , zkConfig . getClientPortAddress ( ) . getHostName ( ) ) ; runZKServer ( zkConfig ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; System . exit ( - _NUM ) ; } } 
3615	public java . util . List < org . bitcoin . protocols . payments . Protos . Output . Builder > getOutputsBuilderList ( ) { return getOutputsFieldBuilder ( ) . getBuilderList ( ) ; } 
3616	private String inferMimeType ( ServletRequest request ) { String path = ( ( HttpServletRequest ) request ) . getRequestURI ( ) ; ContextHandler . SContext sContext = ( ContextHandler . SContext ) config . getServletContext ( ) ; MimeTypes mimes = sContext . getContextHandler ( ) . getMimeTypes ( ) ; Buffer mimeBuffer = mimes . getMimeByExtension ( path ) ; return ( mimeBuffer = = null ) ? null : mimeBuffer . toString ( ) ; } 
3617	public Credentials getCredentials ( ) { synchronized ( subject ) { Credentials creds = new Credentials ( getCredentialsInternal ( ) ) ; Iterator < Token < ? > > iter = creds . getAllTokens ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { if ( iter . next ( ) instanceof Token . PrivateToken ) { iter . remove ( ) ; } } return creds ; } } 
3618	public int getShortcutIconResId ( @ NonNull String packageName , @ NonNull String shortcutId , @ NonNull UserHandle user ) { final ShortcutQuery q = new ShortcutQuery ( ) ; q . setPackage ( packageName ) ; q . setShortcutIds ( Arrays . asList ( shortcutId ) ) ; q . setQueryFlags ( ShortcutQuery . FLAG _ GET _ ALL _ KINDS ) ; final List < ShortcutInfo > shortcuts = getShortcuts ( q , user ) ; return shortcuts . size ( ) > _NUM ? shortcuts . get ( _NUM ) . getIconResourceId ( ) : _NUM ; } 
3619	public void readTest _NUM ( ) throws Exception { for ( int k = MIN _ LEN ; k < = MAX _ LEN ; k + = DELTA ) { for ( CreateFileOptions op : getOptionSet ( ) ) { AlluxioURI uri = new AlluxioURI ( sTestPath + _STR + op . hashCode ( ) ) ; FileInStream is = sFileSystem . openFile ( uri , sReadNoCache ) ; byte [ ] ret = new byte [ k ] ; int value = is . read ( ) ; int cnt = _NUM ; while ( value ! = - _NUM ) { Assert . assertTrue ( value > = _NUM ) ; Assert . assertTrue ( value < _NUM _NUM _NUM ) ; ret [ cnt + + ] = ( byte ) value ; value = is . read ( ) ; } Assert . assertEquals ( cnt , k ) ; Assert . assertTrue ( BufferUtils . equalIncreasingByteArray ( k , ret ) ) ; is . close ( ) ; is = sFileSystem . openFile ( uri , sReadCachePromote ) ; ret = new byte [ k ] ; value = is . read ( ) ; cnt = _NUM ; while ( value ! = - _NUM ) { Assert . assertTrue ( value > = _NUM ) ; Assert . assertTrue ( value < _NUM _NUM _NUM ) ; ret [ cnt + + ] = ( byte ) value ; value = is . read ( ) ; } Assert . assertEquals ( cnt , k ) ; Assert . assertTrue ( BufferUtils . equalIncreasingByteArray ( k , ret ) ) ; is . close ( ) ; Assert . assertTrue ( sFileSystem . getStatus ( uri ) . getInAlluxioPercentage ( ) = = _NUM _NUM _NUM ) ; } } } 
3620	public void testDeploymentEvents ( ) throws Exception { Deployment deployment = null ; try { listener . clearEventsReceived ( ) ; deployment = repositoryService . createDeployment ( ) . addClasspathResource ( _STR , ( ( Deployment ) event . getEntity ( ) ) . getCategory ( ) ) ; listener . clearEventsReceived ( ) ; Check delete event when category is updated repositoryService . deleteDeployment ( deployment . getId ( ) , true ) ; assertEquals ( _NUM , listener . getEventsReceived ( ) . size ( ) ) ; assertTrue ( listener . getEventsReceived ( ) . get ( _NUM ) instanceof ActivitiEntityEvent ) ; event = ( ActivitiEntityEvent ) listener . getEventsReceived ( ) . get ( _NUM ) ; assertEquals ( ActivitiEventType . ENTITY _ DELETED , event . getType ( ) ) ; assertEquals ( deployment . getId ( ) , ( ( Deployment ) event . getEntity ( ) ) . getId ( ) ) ; listener . clearEventsReceived ( ) ; } finally { if ( deployment ! = null & & repositoryService . createDeploymentQuery ( ) . deploymentId ( deployment . getId ( ) ) . count ( ) > _NUM ) { repositoryService . deleteDeployment ( deployment . getId ( ) , true ) ; } } } 
3621	private void insertEntry ( final byte [ ] key , final int coupon , final boolean setStateOne ) { final long [ ] hash = MurmurHash _NUM . hash ( key , SEED ) ; int entryIndex = getIndex ( hash [ _NUM ] , tableEntries _ ) ; final int stride = getStride ( hash [ _NUM ] , tableEntries _ ) ; final int loopIndex = entryIndex ; do { if ( couponsArr _ [ entryIndex ] = = _NUM ) { System . arraycopy ( key , _NUM , keysArr _ , entryIndex * keySizeBytes _ , keySizeBytes _ ) ; setCoupon ( entryIndex , ( short ) coupon , setStateOne ) ; return ; } entryIndex = ( entryIndex + stride ) % tableEntries _ ; } while ( entryIndex ! = loopIndex ) ; throw new SketchesArgumentException ( _STR ) ; } 
3622	public Set < Host > getReplicas ( String keyspace , ByteBuffer partitionKey ) { keyspace = handleId ( keyspace ) ; TokenMap current = tokenMap ; if ( current = = null ) { return Collections . emptySet ( ) ; } else { Set < Host > hosts = current . getReplicas ( keyspace , current . factory . hash ( partitionKey ) ) ; return hosts = = null ? Collections . < Host > emptySet ( ) : hosts ; } } 
3623	private boolean hasUserSetupCompleted ( int userHandle ) { if ( ! mHasFeature ) { return true ; } return getUserData ( userHandle ) . mUserSetupComplete ; } 
3624	public final void removeCallbacks ( Runnable r ) { final WeakRunnable runnable = mRunnables . remove ( r ) ; if ( runnable ! = null ) { mExec . removeCallbacks ( runnable ) ; } } 
3625	public int entrySize ( String name ) { name = fixFileName ( name ) ; return Util . getImplementation ( ) . getStorageEntrySize ( name ) ; } 
3626	protected void initSettingsObject ( ) { Object o ; if ( CmsStringUtil . isEmpty ( getParamAction ( ) ) ) { o = new CmsXmlContentRepairSettings ( getCms ( ) ) ; } else { this is not the initial call , get the settings object from session o = getDialogObject ( ) ; } if ( o = = null ) { create a new settings object m _ settings = new CmsXmlContentRepairSettings ( getCms ( ) ) ; } else { reuse settings object stored in session m _ settings = ( CmsXmlContentRepairSettings ) o ; } } 
3627	public void attach ( FrameLayout . LayoutParams layoutParams ) { ( ( ViewGroup ) getActivityContentView ( ) ) . addView ( this , layoutParams ) ; } 
3628	public static Term [ ] getTerms ( String sentence , String [ ] [ ] nes , Dictionary [ ] dicts ) { extract tokens String [ ] tokens = OpenNLP . tokenize ( sentence ) ; tag part of speech String [ ] pos = OpenNLP . tagPos ( tokens ) ; tag phrase chunks String [ ] chunks = OpenNLP . tagChunks ( tokens , pos ) ; mark tokens as not yet assigned to a term boolean [ ] assigned = new boolean [ tokens . length ] ; Arrays . fill ( assigned , false ) ; for each token a term that starts at that token or ' null ' Term [ ] terms = new Term [ tokens . length ] ; normalized terms ( do identify duplicates ) Set < String > termSet = new HashSet < String > ( ) ; construct multi - token terms for ( int length = MAX _ TERM _ LENGTH ; length > _NUM ; length - - ) for ( int id = _NUM ; id < tokens . length - length + _NUM ; id + + ) { one of the tokens is already assigned to a term ? boolean skip = false ; for ( int offset = _NUM ; offset < length ; offset + + ) if ( assigned [ id + offset ] ) { skip = true ; continue ; } if ( skip ) continue ; get phrase spanning the tokens String text = tokens [ id ] ; for ( int offset = _NUM ; offset < length ; offset + + ) text + = _STR ) ) continue ; phrase can be truncated ? if ( ! text . equals ( TruncationFilter . truncate ( text ) ) ) continue ; phrase is in the dictionary ? if ( dict . contains ( text ) ) { construct term terms [ id ] = new Term ( text , Term . COMPOUND ) ; mark tokens as assigned for ( int offset = _NUM ; offset < length ; offset + + ) assigned [ id + offset ] = true ; continue ; } } } construct single - token terms for ( int id = _NUM ; id < tokens . length ; id + + ) { token is part of a multi - token term ? if ( assigned [ id ] ) continue ; token is a duplicate ? if ( ! termSet . add ( StringUtils . normalize ( tokens [ id ] ) ) ) continue ; token does not contain keywords ? if ( KeywordExtractor . getKeywords ( tokens [ id ] ) . length = = _NUM ) continue ; get named entity types and construct term String [ ] neTypes = getNeTypes ( tokens [ id ] , nes ) ; terms [ id ] = new Term ( tokens [ id ] , pos [ id ] , neTypes ) ; } get ordered list of terms List < Term > termsL = new ArrayList < Term > ( ) ; for ( Term term : terms ) if ( term ! = null ) termsL . add ( term ) ; return termsL . toArray ( new Term [ termsL . size ( ) ] ) ; } 
3629	public void release ( ) { if ( mVirtualDisplay = = null ) { throw new IllegalStateException ( _STR ) ; } performRelease ( ) ; } 
3630	public void delNodeValue ( int nTargetNode , String sValue ) throws Exception { update undo stack if ( m _ bNeedsUndoAction ) { addUndoAction ( new DelValueAction ( nTargetNode , sValue ) ) ; } Attribute att = m _ Instances . attribute ( nTargetNode ) ; int nCardinality = att . numValues ( ) ; FastVector values = new FastVector ( nCardinality ) ; int nValue = - _NUM ; for ( int iValue = _NUM ; iValue < nCardinality ; iValue + + ) { if ( att . value ( iValue ) . equals ( sValue ) ) { nValue = iValue ; } else { values . addElement ( att . value ( iValue ) ) ; } } if ( nValue < _NUM ) { could not find value throw new Exception ( _STR ) ; } replaceAtt ( nTargetNode , att . name ( ) , values ) ; update distributions Estimator [ ] distributions = m _ Distributions [ nTargetNode ] ; int nCard = values . size ( ) ; for ( int iParent = _NUM ; iParent < distributions . length ; iParent + + ) { DiscreteEstimatorBayes distribution = new DiscreteEstimatorBayes ( nCard , _NUM ) ; double sum = _NUM ; for ( int iValue = _NUM ; iValue < nCard ; iValue + + ) { sum + = distributions [ iParent ] . getProbability ( iValue ) ; } if ( sum > _NUM ) { for ( int iValue = _NUM ; iValue < nCard ; iValue + + ) { distribution . addValue ( iValue , distributions [ iParent ] . getProbability ( iValue ) / sum ) ; } } else { for ( int iValue = _NUM ; iValue < nCard ; iValue + + ) { distribution . addValue ( iValue , _NUM . _NUM / nCard ) ; } } distributions [ iParent ] = distribution ; } update distributions of all children for ( int iNode = _NUM ; iNode < getNrOfNodes ( ) ; iNode + + ) { if ( m _ ParentSets [ iNode ] . contains ( nTargetNode ) ) { ParentSet parentSet = m _ ParentSets [ iNode ] ; distributions = m _ Distributions [ iNode ] ; Estimator [ ] newDistributions = new Estimator [ distributions . length * nCard / ( nCard + _NUM ) ] ; int iCurrentDist = _NUM ; int nParents = parentSet . getNrOfParents ( ) ; int [ ] values _NUM = new int [ nParents ] ; fill in the values int nParentCard = parentSet . getFreshCardinalityOfParents ( m _ Instances ) * ( nCard + _NUM ) / nCard ; int iTargetNode = _NUM ; while ( parentSet . getParent ( iTargetNode ) ! = nTargetNode ) { iTargetNode + + ; } int [ ] nCards = new int [ nParents ] ; for ( int iParent = _NUM ; iParent < nParents ; iParent + + ) { nCards [ iParent ] = getCardinality ( parentSet . getParent ( iParent ) ) ; } nCards [ iTargetNode ] + + ; for ( int iPos = _NUM ; iPos < nParentCard ; iPos + + ) { if ( values _NUM [ iTargetNode ] ! = nValue ) { newDistributions [ iCurrentDist + + ] = distributions [ iPos ] ; } update values int i = _NUM ; values _NUM [ i ] + + ; while ( i < nParents & & values _NUM [ i ] = = nCards [ i ] ) { values _NUM [ i ] = _NUM ; i + + ; if ( i < nParents ) { values _NUM [ i ] + + ; } } } m _ Distributions [ iNode ] = newDistributions ; } } update evidence if ( getEvidence ( nTargetNode ) > nValue ) { setEvidence ( nTargetNode , getEvidence ( nTargetNode ) - _NUM ) ; } } 
3631	public void sendRedirect ( String location ) throws IOException { Ignore any redirects after the first one if ( isSuspended ( ) & & ( ! location . equals ( m _ bufferRedirect ) ) ) { return ; } if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( Messages . get ( ) . getBundle ( ) . key ( Messages . LOG _ FLEXRESPONSE _ SENDREDIRECT _ _NUM , location ) ) ; } if ( m _ cachingRequired & & ! m _ includeMode ) { m _ bufferRedirect = location ; } if ( ! m _ cachingRequired ) { be called after this is completed and stored in the cache if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( Messages . get ( ) . getBundle ( ) . key ( Messages . LOG _ FLEXRESPONSE _ TOPRESPONSE _ SENDREDIRECT _ _NUM , location ) ) ; } if ( LOG . isWarnEnabled ( ) ) { if ( m _ controller . getResponseStackSize ( ) > _NUM ) { sendRedirect in a stacked response scenario , this may cause issues in some app servers LOG . warn ( Messages . get ( ) . getBundle ( ) . key ( Messages . LOG _ FLEXRESPONSE _ REDIRECTWARNING _ _NUM , m _ controller . getCmsResource ( ) . getRootPath ( ) , m _ controller . getCurrentRequest ( ) . getElementUri ( ) , location ) ) ; } } try { Checking for possible illegal characters ( for example , XSS exploits ) before sending the redirect The constructor is key here . That method will throw an URISyntaxException if the URL format is not according to standards ( e . g . contains illegal characters , like spaces , < or > , etc ) . new URI ( location ) ; } catch ( URISyntaxException e ) { Deliberately NOT passing the original exception , since the URISyntaxException contains the full path , which may include the XSS attempt LOG . error ( Messages . get ( ) . getBundle ( ) . key ( Messages . ERR _ FLEXRESPONSE _ URI _ SYNTAX _ EXCEPTION _ _NUM ) , e ) ; throw new IllegalArgumentException ( _STR ) ; } use top response for redirect HttpServletResponse topRes = m _ controller . getTopResponse ( ) ; add all headers found to make sure cookies can be set before redirect processHeaders ( getHeaders ( ) , topRes ) ; topRes . sendRedirect ( location ) ; } m _ controller . suspendFlexResponse ( ) ; } 
3632	public CmsResource readResource ( String resourcename , CmsResourceFilter filter ) throws CmsException { CmsResource res = null ; iterate through all wrappers and call _STR till one does not return null List < I _ CmsResourceWrapper > wrappers = getWrappers ( ) ; Iterator < I _ CmsResourceWrapper > iter = wrappers . iterator ( ) ; while ( iter . hasNext ( ) ) { I _ CmsResourceWrapper wrapper = iter . next ( ) ; res = wrapper . readResource ( m _ cms , resourcename , filter ) ; if ( res ! = null ) { break ; } } delegate the call to the CmsObject if ( res = = null ) { res = m _ cms . readResource ( resourcename , filter ) ; } correct the length of the content if an UTF - _NUM marker would be added later if ( needUtf _NUM Marker ( res ) ) { CmsWrappedResource wrap = new CmsWrappedResource ( res ) ; wrap . setLength ( res . getLength ( ) + CmsResourceWrapperUtils . UTF _NUM _ MARKER . length ) ; return wrap . getResource ( ) ; } return res ; } 
3633	public void testComputeIfPresent ( ) { ConcurrentMap map = map _NUM ( ) ; map . computeIfPresent ( six , ( x , y ) - > _STR ) ; assertFalse ( map . containsKey ( six ) ) ; } 
3634	public void differentContainers ( ) throws Throwable { final FragmentManager fm = mActivityRule . getActivity ( ) . getSupportFragmentManager ( ) ; fm . beginTransaction ( ) . remove ( mBeginningFragment ) . setReorderingAllowed ( true ) . commit ( ) ; FragmentTestUtil . waitForExecution ( mActivityRule ) ; FragmentTestUtil . setContentView ( mActivityRule , R . layout . double _ container ) ; TransitionFragment fragment _NUM = new PostponedFragment _NUM ( ) ; TransitionFragment fragment _NUM = new PostponedFragment _NUM ( ) ; fm . beginTransaction ( ) . add ( R . id . fragmentContainer _NUM , fragment _NUM ) . add ( R . id . fragmentContainer _NUM , fragment _NUM ) . setReorderingAllowed ( true ) . commit ( ) ; FragmentTestUtil . waitForExecution ( mActivityRule ) ; fragment _NUM . startPostponedEnterTransition ( ) ; fragment _NUM . startPostponedEnterTransition ( ) ; fragment _NUM . waitForTransition ( ) ; fragment _NUM . waitForTransition ( ) ; clearTargets ( fragment _NUM ) ; clearTargets ( fragment _NUM ) ; final View startBlue _NUM = fragment _NUM . getView ( ) . findViewById ( R . id . blueSquare ) ; final View startBlue _NUM = fragment _NUM . getView ( ) . findViewById ( R . id . blueSquare ) ; final TransitionFragment fragment _NUM = new PostponedFragment _NUM ( ) ; fm . beginTransaction ( ) . addSharedElement ( startBlue _NUM , _STR ) . replace ( R . id . fragmentContainer _NUM , fragment _NUM ) . addToBackStack ( null ) . setReorderingAllowed ( true ) . commit ( ) ; FragmentTestUtil . waitForExecution ( mActivityRule ) ; assertPostponedTransition ( fragment _NUM , fragment _NUM , null ) ; assertPostponedTransition ( fragment _NUM , fragment _NUM , null ) ; start the postponed transition fragment _NUM . startPostponedEnterTransition ( ) ; make sure only one ran assertForwardTransition ( fragment _NUM , fragment _NUM ) ; assertPostponedTransition ( fragment _NUM , fragment _NUM , null ) ; start the postponed transition fragment _NUM . startPostponedEnterTransition ( ) ; make sure it ran assertForwardTransition ( fragment _NUM , fragment _NUM ) ; Pop back to fragment _NUM - - should be postponed FragmentTestUtil . popBackStackImmediate ( mActivityRule ) ; assertPostponedTransition ( fragment _NUM , fragment _NUM , null ) ; Pop back to fragment _NUM - - also should be postponed FragmentTestUtil . popBackStackImmediate ( mActivityRule ) ; assertPostponedTransition ( fragment _NUM , fragment _NUM , null ) ; assertPostponedTransition ( fragment _NUM , fragment _NUM , null ) ; start the postponed transition fragment _NUM . startPostponedEnterTransition ( ) ; make sure it ran assertBackTransition ( fragment _NUM , fragment _NUM ) ; but not the postponed one assertPostponedTransition ( fragment _NUM , fragment _NUM , null ) ; start the postponed transition fragment _NUM . startPostponedEnterTransition ( ) ; make sure it ran assertBackTransition ( fragment _NUM , fragment _NUM ) ; } 
3635	public void clearOnScrollListeners ( ) { if ( mScrollListeners ! = null ) { mScrollListeners . clear ( ) ; } } 
3636	public void setVersionInfo ( String info ) { checkProfile ( getProfile ( ) . VERSION _ INFO ( ) , _STR ) ; removeAll ( getProfile ( ) . VERSION _ INFO ( ) ) ; addVersionInfo ( info ) ; } 
3637	public int countJobsForUid ( int uid ) { int total = _NUM ; ArraySet < JobStatus > jobs = mJobs . get ( uid ) ; if ( jobs ! = null ) { for ( int i = jobs . size ( ) - _NUM ; i > = _NUM ; i - - ) { JobStatus job = jobs . valueAt ( i ) ; if ( job . getUid ( ) = = job . getSourceUid ( ) ) { total + + ; } } } return total ; } 
3638	public void add ( int idx , Record record ) { if ( idx ! = numSlot ) { checkBounds ( idx , numSlot ) ; Changes count . shiftUp ( idx ) ; } else { if ( numSlot > = maxSlot ) throw new BufferException ( format ( _STR , idx , maxSlot ) ) ; numSlot + + ; } _ set ( idx , record ) ; } 
3639	public boolean saveToPath ( String title , String pathOnSD ) { Bitmap b = getChartBitmap ( ) ; OutputStream stream ; try { stream = new FileOutputStream ( Environment . getExternalStorageDirectory ( ) . getPath ( ) + pathOnSD + _STR ) ; b . compress ( CompressFormat . PNG , _NUM _NUM , stream ) ; stream . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return false ; } return true ; } 
3640	public String toRequestParam ( ) { StringBuffer result = new StringBuffer ( _NUM _NUM _NUM ) ; result . append ( ' ? ' ) ; result . append ( PARAM _ SCALE ) ; result . append ( ' = ' ) ; result . append ( toString ( ) ) ; return result . toString ( ) ; } 
3641	public Media createMedia ( InputStream stream , String mimeType , Runnable onCompletion ) throws IOException { MMAPIPlayer player = MMAPIPlayer . createPlayer ( stream , mimeType , onCompletion ) ; if ( mimeType . indexOf ( _STR ) > - _NUM ) { VideoMainScreen video = new VideoMainScreen ( player , this ) ; return video ; } return player ; } 
3642	protected void removeEmptyMappings ( CmsObject cms , CmsXmlContent content ) throws CmsException { List < CmsResource > siblings = null ; CmsObject rootCms = null ; Iterator < Map . Entry < String , List < String > > > allMappings = m _ elementMappings . entrySet ( ) . iterator ( ) ; while ( allMappings . hasNext ( ) ) { Map . Entry < String , List < String > > e = allMappings . next ( ) ; String path = e . getKey ( ) ; List < String > mappings = e . getValue ( ) ; if ( mappings = = null ) { nothing to do if we have no mappings at all continue ; } if ( ( siblings = = null ) | | ( rootCms = = null ) ) { create OpenCms user context initialized with _STR , which has to be treated in a special way rootCms . rmacc ( filename , CmsAccessControlEntry . PRINCIPAL _ ALL _ OTHERS _ NAME , CmsAccessControlEntry . PRINCIPAL _ ALL _ OTHERS _ ID . toString ( ) ) ; } else { this is a group or user principal I _ CmsPrincipal principal = CmsPrincipal . readPrincipal ( rootCms , ace . getPrincipal ( ) ) ; if ( principal . isGroup ( ) ) { rootCms . rmacc ( filename , I _ CmsPrincipal . PRINCIPAL _ GROUP , principal . getName ( ) ) ; } else if ( principal . isUser ( ) ) { rootCms . rmacc ( filename , I _ CmsPrincipal . PRINCIPAL _ USER , principal . getName ( ) ) ; } } } } } } } } 
3643	private boolean addEndpoints ( MutableCapacityGraph < Vertex , Integer > capacityGraph , RangeVertex rangeVertex , boolean localDCCheck ) { boolean sourceFound = false ; for ( InetAddressAndPort endpoint : rangesWithSources . get ( rangeVertex . getRange ( ) ) ) { if ( passFilters ( endpoint , localDCCheck ) ) { sourceFound = true ; if we pass filters , it means that we don ' t filter away localhost and we can count it as a source : if ( endpoint . equals ( FBUtilities . getBroadcastAddressAndPort ( ) ) ) but don ' t add localhost to the graph to avoid streaming locally continue ; final Vertex endpointVertex = new EndpointVertex ( endpoint ) ; capacityGraph . insertVertex ( rangeVertex ) ; capacityGraph . insertVertex ( endpointVertex ) ; capacityGraph . addEdge ( rangeVertex , endpointVertex , Integer . MAX _ VALUE ) ; } } return sourceFound ; } 
3644	public void setTextAppearance ( Context context , int resid ) { ensureViewsSetUp ( ) ; if ( mTextView ! = null ) { mTextView . setTextAppearance ( context , resid ) ; } } 
3645	private void cancelAnimation ( ) { if ( mCurrentAnimation ! = null ) { mCurrentAnimation . setDuration ( _NUM ) ; mCurrentAnimation . cancel ( ) ; mCurrentAnimation = null ; } } 
3646	public boolean flush ( TupleWritable value ) throws IOException { while ( hasNext ( ) ) { value . clearWritten ( ) ; if ( next ( value ) & & combine ( kids , value ) ) { return true ; } } return false ; } 
3647	public final void readException ( int code , String msg ) { switch ( code ) { case EX _ PARCELABLE : if ( readInt ( ) > _NUM ) { SneakyThrow . sneakyThrow ( ( Exception ) readParcelable ( Parcelable . class . getClassLoader ( ) ) ) ; } else { throw new RuntimeException ( msg + _STR + msg ) ; } 
3648	protected Instance convertInstance ( Instance currentInstance ) { Instance newInstance ; double [ ] vals = new double [ getOutputFormat ( ) . numAttributes ( ) ] ; int classIndex = ( m _ ntob = = null ) ? getInputFormat ( ) . classIndex ( ) : m _ ntob . getOutputFormat ( ) . classIndex ( ) ; for ( int i = _NUM ; i < m _ k ; i + + ) { vals [ i ] = computeRandomProjection ( i , classIndex , currentInstance ) ; } if ( classIndex ! = - _NUM ) { vals [ m _ k ] = currentInstance . value ( classIndex ) ; } newInstance = new DenseInstance ( currentInstance . weight ( ) , vals ) ; newInstance . setDataset ( getOutputFormat ( ) ) ; return newInstance ; } 
3649	public static ActionMapping getDefaultActionForMode ( ) { return ( ActionMapping ) getContext ( ) . get ( DEFAULT _ ACTION _ FOR _ MODE ) ; } 
3650	public void testNamespaceCommands ( ) throws Exception { final Configuration conf = new HdfsConfiguration ( ) ; Make it relinquish locks . When run serially , the result should be identical . conf . setInt ( DFSConfigKeys . DFS _ CONTENT _ SUMMARY _ LIMIT _ KEY , _NUM ) ; final MiniDFSCluster cluster = new MiniDFSCluster . Builder ( conf ) . numDataNodes ( _NUM ) . build ( ) ; final DistributedFileSystem dfs = cluster . getFileSystem ( ) ; try { _NUM : create directory / nqdir _NUM / qdir _NUM / qdir _NUM _NUM / nqdir _NUM _NUM assertTrue ( dfs . mkdirs ( new Path ( _STR ) , quotaDir _NUM ) ) ; c = dfs . getContentSummary ( quotaDir _NUM ) ; assertEquals ( c . getDirectoryCount ( ) , _NUM ) ; assertEquals ( c . getQuota ( ) , _NUM ) ; c = dfs . getContentSummary ( quotaDir _NUM ) ; assertEquals ( c . getDirectoryCount ( ) , _NUM ) ; assertEquals ( c . getQuota ( ) , _NUM ) ; assertEquals ( _NUM _NUM , cluster . getNamesystem ( ) . getFSDirectory ( ) . getYieldCount ( ) ) ; } finally { cluster . shutdown ( ) ; } } 
3651	public void applicationWithAppCredentials ( ) throws Exception { retrieve the credentials Credentials appCredentials = getAppCredentials ( ) ; retrieve the app using only the org credentials ApiResponse apiResponse = this . app ( ) . getTarget ( false ) . queryParam ( _STR , appCredentials . getClientSecret ( ) ) . request ( ) . get ( ApiResponse . class ) ; assert that a valid response is returned without error assertNotNull ( apiResponse ) ; assertNull ( apiResponse . getError ( ) ) ; } 
3652	public final Element TriplesBlock ( ElementTriplesBlock acc ) throws ParseException { if ( acc = = null ) acc = new ElementTriplesBlock ( ) ; TriplesSameSubject ( acc ) ; switch ( ( jj _ ntk = = - _NUM ) ? jj _ ntk ( ) : jj _ ntk ) { case DOT : jj _ consume _ token ( DOT ) ; switch ( ( jj _ ntk = = - _NUM ) ? jj _ ntk ( ) : jj _ ntk ) { case IRIref : case PNAME _ NS : case PNAME _ LN : case BLANK _ NODE _ LABEL : case VAR _NUM : case VAR _NUM : case TRUE : case FALSE : case INTEGER : case DECIMAL : case DOUBLE : case INTEGER _ POSITIVE : case DECIMAL _ POSITIVE : case DOUBLE _ POSITIVE : case INTEGER _ NEGATIVE : case DECIMAL _ NEGATIVE : case DOUBLE _ NEGATIVE : case STRING _ LITERAL _NUM : case STRING _ LITERAL _NUM : case STRING _ LITERAL _ LONG _NUM : case STRING _ LITERAL _ LONG _NUM : case LPAREN : case NIL : case LBRACKET : case ANON : TriplesBlock ( acc ) ; break ; default : jj _ la _NUM [ _NUM _NUM ] = jj _ gen ; ; } break ; default : jj _ la _NUM [ _NUM _NUM ] = jj _ gen ; ; } { if ( true ) return acc ; } throw new Error ( _STR ) ; } 
3653	public static < T > Future < Object > forEachFuture ( Publisher < ? extends T > source , Consumer < ? super T > onNext , final Consumer < ? super Throwable > onError , final Action onComplete , Scheduler scheduler ) { SequentialDisposable d = new SequentialDisposable ( ) ; final FutureCompletable < Object > f = new FutureCompletable < Object > ( d ) ; LambdaSubscriber < T > ls = new LambdaSubscriber < T > ( onNext , new Consumer < Throwable > ( ) { @ Override public void accept ( Throwable e ) throws Exception { try { onError . accept ( e ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; f . completeExceptionally ( new CompositeException ( e , ex ) ) ; return ; } f . completeExceptionally ( e ) ; } } , new Action ( ) { @ Override public void run ( ) throws Exception { try { onComplete . run ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; f . completeExceptionally ( ex ) ; return ; } f . complete ( null ) ; } } , new Consumer < Subscription > ( ) { @ Override public void accept ( Subscription s ) throws Exception { s . request ( Long . MAX _ VALUE ) ; } } ) ; d . lazySet ( ls ) ; Flowable . fromPublisher ( source ) . subscribeOn ( scheduler ) . subscribe ( ls ) ; return f ; } 
3654	private void testErr ( String qsAgg , DatasetGraph ds , Syntax syntax ) { Query query = buildGroupBy ( qsAgg , syntax ) ; try ( QueryExecution qExec = QueryExecutionFactory . create ( query , DatasetFactory . wrap ( ds ) ) ) { ResultSet rs = qExec . execSelect ( ) ; assertTrue ( rs . getResultVars ( ) . contains ( _STR ) ) ) ; } } 
3655	private void gossip ( ) { List < Node > nodes = clusterService . getNodes ( ) . stream ( ) . filter ( node - > ! localNodeId . equals ( node . id ( ) ) ) . filter ( node - > node . getState ( ) = = Node . State . ACTIVE ) . collect ( Collectors . toList ( ) ) ; if ( ! nodes . isEmpty ( ) ) { Collections . shuffle ( nodes ) ; Node node = nodes . get ( _NUM ) ; updateNode ( node ) ; } } 
3656	public void unlockCanvasAndPost ( Canvas canvas ) { if ( ! mDestroyed & & mCanvas ! = null & & canvas = = mCanvas ) { canvas . restoreToCount ( mSaveCount ) ; mSaveCount = _NUM ; nUnlockCanvasAndPost ( mNativeObject , mCanvas ) ; } } 
3657	public void registerService ( ServiceInstance < T > service ) throws Exception { Entry < T > newEntry = new Entry < T > ( service ) ; Entry < T > oldEntry = services . putIfAbsent ( service . getId ( ) , newEntry ) ; Entry < T > useEntry = ( oldEntry ! = null ) ? oldEntry : newEntry ; synchronized ( useEntry ) { if ( i . e . is new useEntry = = newEntry ) { useEntry . cache = makeNodeCache ( service ) ; } internalRegisterService ( service ) ; } } 
3658	public void multi ( Iterable < Op > ops , MultiCallback cb , Object ctx ) { List < OpResult > results = validatePath ( ops ) ; if ( results . size ( ) > _NUM ) { cb . processResult ( KeeperException . Code . BADARGUMENTS . intValue ( ) , null , ctx , results ) ; return ; } multiInternal ( generateMultiTransaction ( ops ) , cb , ctx ) ; } 
3659	public void deletePublishHistoryEntry ( CmsDbContext dbc , CmsUUID publishHistoryId , CmsPublishedResource publishedResource ) throws CmsDataAccessException { try { Query q = m _ sqlManager . createQuery ( dbc , C _ RESOURCES _ DELETE _ PUBLISH _ HISTORY _ ENTRY ) ; q . setParameter ( _NUM , publishHistoryId . toString ( ) ) ; q . setParameter ( _NUM , Integer . valueOf ( publishedResource . getPublishTag ( ) ) ) ; q . setParameter ( _NUM , publishedResource . getStructureId ( ) . toString ( ) ) ; q . setParameter ( _NUM , publishedResource . getRootPath ( ) ) ; @ SuppressWarnings ( _STR ) List < CmsDAOPublishHistory > res = q . getResultList ( ) ; for ( CmsDAOPublishHistory ph : res ) { m _ sqlManager . remove ( dbc , ph ) ; } } catch ( PersistenceException e ) { throw new CmsDataAccessException ( Messages . get ( ) . container ( Messages . ERR _ JPA _ PERSITENCE , e ) , e ) ; } } 
3660	public static Class < ? > forName ( final String className ) { List < ClassLoader > allClassLoaders = Lists . newArrayList ( ) ; ClassLoader contextClassLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; if ( contextClassLoader ! = null ) { allClassLoaders . add ( contextClassLoader ) ; } allClassLoaders . addAll ( classLoaders ) ; for ( ClassLoader classLoader : allClassLoaders ) { if ( null = = classLoader ) { continue ; } try { return classLoader . loadClass ( className ) ; } catch ( ClassNotFoundException ex ) { With additional class loaders , it is legitimate to ignore ClassNotFoundException if ( classLoaders . isEmpty ( ) ) { logClassNotFoundError ( className , ex ) ; } } } if ( Boolean . parseBoolean ( System . getProperty ( SKIP _ CALLER _ CLS _ LOADER ) ) ) { return null ; } try { return Class . forName ( className ) ; } catch ( ClassNotFoundException cnfe ) { logClassNotFoundError ( className , cnfe ) ; return null ; } } 
3661	protected void startSync ( List < Range < Token > > differences ) { InetAddressAndPort local = FBUtilities . getBroadcastAddressAndPort ( ) ; We can take anyone of the node as source or destination , however if one is localhost , we put at source to avoid a forwarding InetAddressAndPort dst = r _NUM . endpoint . equals ( local ) ? r _NUM . endpoint : r _NUM . endpoint ; InetAddressAndPort preferred = SystemKeyspace . getPreferredIP ( dst ) ; String message = String . format ( _STR , previewKind . logPrefix ( desc . sessionId ) , message ) ; Tracing . traceRepair ( message ) ; createStreamPlan ( dst , preferred , differences ) . execute ( ) ; } 
3662	public void addKeyValue ( String key , Object value ) { keys . add ( key ) ; resources . setThemeProperty ( themeName , key , value ) ; theme . put ( key , value ) ; Collections . sort ( keys ) ; int row = keys . indexOf ( key ) ; fireTableRowsInserted ( row , row ) ; refreshTheme ( ) ; } 
3663	protected synchronized void addApplication ( ApplicationId applicationId , String queueName , String user , boolean isAppRecovering ) { if ( queueName = = null | | queueName . isEmpty ( ) ) { String message = _STR ) ; } } else { rmContext . getDispatcher ( ) . getEventHandler ( ) . handle ( new RMAppEvent ( applicationId , RMAppEventType . APP _ ACCEPTED ) ) ; } } 
3664	public Builder setError ( org . bitcoin . paymentchannel . Protos . Error . Builder builderForValue ) { if ( errorBuilder _ = = null ) { error _ = builderForValue . build ( ) ; onChanged ( ) ; } else { errorBuilder _ . setMessage ( builderForValue . build ( ) ) ; } bitField _NUM _ | = _NUM x _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM ; return this ; } 
3665	public boolean getNotes ( ) { return getCellComment ( ) = = PrintCellComments . AS _ DISPLAYED ; } 
3666	public synchronized void reportBadSink ( SinkPeer sinkPeer ) { ServerName serverName = sinkPeer . getServerName ( ) ; int badReportCount = ( badReportCounts . containsKey ( serverName ) ? badReportCounts . get ( serverName ) : _NUM ) + _NUM ; badReportCounts . put ( serverName , badReportCount ) ; if ( badReportCount > badSinkThreshold ) { this . sinks . remove ( serverName ) ; if ( sinks . isEmpty ( ) ) { chooseSinks ( ) ; } } } 
3667	public void scrollComponentToVisible ( Component c ) { initFocused ( ) ; Container parent = c . getParent ( ) ; while ( parent ! = null ) { if ( parent . isScrollable ( ) ) { if ( parent = = this ) { special case for Form if ( getContentPane ( ) . isScrollable ( ) ) { getContentPane ( ) . scrollComponentToVisible ( c ) ; } } else { parent . scrollComponentToVisible ( c ) ; } return ; } parent = parent . getParent ( ) ; } } 
3668	private long bfSearchForXRef ( long xrefOffset ) throws IOException { long newOffset = - _NUM ; long newOffsetTable ; long newOffsetStream ; initialize bfSearchXRefTablesOffsets - > not null bfSearchForXRefTables ( ) ; initialize bfSearchXRefStreamsOffsets - > not null bfSearchForXRefStreams ( ) ; TODO to be optimized , this won ' t work in every case newOffsetTable = searchNearestValue ( bfSearchXRefTablesOffsets , xrefOffset ) ; TODO to be optimized , this won ' t work in every case newOffsetStream = searchNearestValue ( bfSearchXRefStreamsOffsets , xrefOffset ) ; choose the nearest value if ( newOffsetTable > - _NUM & & newOffsetStream > - _NUM ) { long differenceTable = xrefOffset - newOffsetTable ; long differenceStream = xrefOffset - newOffsetStream ; if ( Math . abs ( differenceTable ) > Math . abs ( differenceStream ) ) { newOffset = newOffsetStream ; bfSearchXRefStreamsOffsets . remove ( newOffsetStream ) ; } else { newOffset = newOffsetTable ; bfSearchXRefTablesOffsets . remove ( newOffsetTable ) ; } } else if ( newOffsetTable > - _NUM ) { newOffset = newOffsetTable ; bfSearchXRefTablesOffsets . remove ( newOffsetTable ) ; } else if ( newOffsetStream > - _NUM ) { newOffset = newOffsetStream ; bfSearchXRefStreamsOffsets . remove ( newOffsetStream ) ; } return newOffset ; } 
3669	public void addRecords ( List < Record > records ) { recordChannel . newRecords ( records ) ; } 
3670	private void checkAllSame ( VifDriver vifDriver ) throws ConfigurationException { for ( TrafficType trafficType : TrafficType . values ( ) ) { assertions . put ( trafficType , vifDriver ) ; } checkAssertions ( ) ; } 
3671	private List < CmsResultItemBean > buildSearchResultList ( List < CmsGallerySearchResult > searchResult , CmsGallerySearchResult presetResult ) { ArrayList < CmsResultItemBean > list = new ArrayList < CmsResultItemBean > ( ) ; if ( ( searchResult = = null ) | | ( searchResult . size ( ) = = _NUM ) ) { return list ; } CmsObject cms = getCmsObject ( ) ; for ( CmsGallerySearchResult sResult : searchResult ) { try { Locale wpLocale = getWorkplaceLocale ( ) ; CmsResultItemBean bean = new CmsResultItemBean ( ) ; if ( sResult = = presetResult ) { bean . setPreset ( true ) ; } bean . setReleasedAndNotExpired ( sResult . isReleaseAndNotExpired ( cms ) ) ; String path = sResult . getPath ( ) ; path = cms . getRequestContext ( ) . removeSiteRoot ( path ) ; resource path as id bean . setPath ( path ) ; title bean . setTitle ( CmsStringUtil . isEmptyOrWhitespaceOnly ( sResult . getTitle ( ) ) ? CmsResource . getName ( sResult . getPath ( ) ) : sResult . getTitle ( ) ) ; resource type bean . setType ( sResult . getResourceType ( ) ) ; structured id bean . setClientId ( sResult . getStructureId ( ) ) ; set nice resource type name as subtitle I _ CmsResourceType type = OpenCms . getResourceManager ( ) . getResourceType ( sResult . getResourceType ( ) ) ; String resourceTypeDisplayName = CmsWorkplaceMessages . getResourceTypeName ( wpLocale , type . getTypeName ( ) ) ; String description = sResult . getDescription ( ) ; if ( CmsStringUtil . isNotEmptyOrWhitespaceOnly ( description ) ) { bean . setDescription ( description ) ; bean . addAdditionalInfo ( Messages . get ( ) . getBundle ( getWorkplaceLocale ( ) ) . key ( Messages . GUI _ RESULT _ LABEL _ DESCRIPTION _ _NUM ) , description ) ; } else { bean . setDescription ( resourceTypeDisplayName ) ; } if ( ! type . getTypeName ( ) . equals ( CmsResourceTypeImage . getStaticTypeName ( ) ) ) { bean . addAdditionalInfo ( Messages . get ( ) . getBundle ( getWorkplaceLocale ( ) ) . key ( Messages . GUI _ RESULT _ LABEL _ RESOURCE _ TYPE _ _NUM ) , resourceTypeDisplayName ) ; } if ( CmsStringUtil . isNotEmptyOrWhitespaceOnly ( sResult . getExcerpt ( ) ) ) { bean . addAdditionalInfo ( Messages . get ( ) . getBundle ( getWorkplaceLocale ( ) ) . key ( Messages . GUI _ RESULT _ LABEL _ EXCERPT _ _NUM ) , sResult . getExcerpt ( ) , CmsListInfoBean . CSS _ CLASS _ MULTI _ LINE ) ; } if ( type instanceof CmsResourceTypeImage ) { CmsProperty imageDimensionProp = cms . readPropertyObject ( path , CmsPropertyDefinition . PROPERTY _ IMAGE _ SIZE , false ) ; if ( ! imageDimensionProp . isNullProperty ( ) ) { String temp = imageDimensionProp . getValue ( ) ; bean . addAdditionalInfo ( Messages . get ( ) . getBundle ( getWorkplaceLocale ( ) ) . key ( Messages . GUI _ RESULT _ LABEL _ DIMENSION _ _NUM ) , temp . substring ( _NUM ) . replace ( _STR ) ; bean . addAdditionalInfo ( Messages . get ( ) . getBundle ( getWorkplaceLocale ( ) ) . key ( Messages . GUI _ RESULT _ LABEL _ DATE _ CHANGED _ _NUM ) , CmsDateUtil . getDate ( sResult . getDateLastModified ( ) , DateFormat . SHORT , getWorkplaceLocale ( ) ) ) ; if ( ( sResult . getDateExpired ( ) . getTime ( ) ! = CmsResource . DATE _ EXPIRED _ DEFAULT ) & & ! sResult . getDateExpired ( ) . equals ( CmsSearchFieldMapping . getDefaultDateExpired ( ) ) ) { bean . addAdditionalInfo ( Messages . get ( ) . getBundle ( getWorkplaceLocale ( ) ) . key ( Messages . GUI _ RESULT _ LABEL _ DATE _ EXPIRED _ _NUM ) , CmsDateUtil . getDate ( sResult . getDateExpired ( ) , DateFormat . SHORT , getWorkplaceLocale ( ) ) ) ; } bean . setNoEditReson ( new CmsResourceUtil ( cms , cms . readResource ( path , CmsResourceFilter . ONLY _ VISIBLE _ NO _ DELETED ) ) . getNoEditReason ( OpenCms . getWorkplaceManager ( ) . getWorkplaceLocale ( cms ) ) ) ; list . add ( bean ) ; } catch ( Exception e ) { logError ( e ) ; } } return list ; } 
3672	private void reschedulePeriodicSyncH ( SyncOperation syncOperation ) { Ensure that the periodic sync wasn ' t removed . SyncOperation periodicSync = null ; List < SyncOperation > ops = getAllPendingSyncs ( ) ; for ( SyncOperation op : ops ) { if ( op . isPeriodic & & syncOperation . matchesPeriodicOperation ( op ) ) { periodicSync = op ; break ; } } if ( periodicSync = = null ) { return ; } scheduleSyncOperationH ( periodicSync ) ; } 
3673	private void checkKey ( String key ) throws PropertyTypeException { if ( key = = null | | key . length ( ) = = _NUM ) { throw new PropertyTypeException ( _STR ) ; } } 
3674	public void evaluateJavascript ( String script , ValueCallback < String > resultCallback ) { checkThread ( ) ; mProvider . evaluateJavaScript ( script , resultCallback ) ; } 
3675	public static boolean test ( int k , int n , double p , boolean is _ twoTailed , double aLevel ) { if ( k < _NUM | | n < = _NUM | | p < _NUM ) { throw new IllegalArgumentException ( _STR ) ; } double pvalue = scoreToPvalue ( ( double ) k , n , p ) ; boolean rejectH _NUM = false ; double a = aLevel ; if ( is _ twoTailed ) { if to tailed test then split the statistical significance in half a = aLevel / _NUM . _NUM ; } if ( pvalue < = a | | pvalue > = ( _NUM . _NUM - a ) ) { rejectH _NUM = true ; } return rejectH _NUM ; } 
3676	public LongDenseMatrix getMatrix ( int numRows , AggregatorUsage aggUser ) { LongDenseMatrix matrix = new LongDenseMatrix ( numRows , _NUM ) ; for ( int i = _NUM ; i < numRows ; + + i ) { LongDenseVector vec = aggUser . getAggregatedValue ( getRowAggregatorName ( i ) ) ; matrix . addRow ( vec ) ; } return matrix ; } 
3677	private void ensureConsistentState ( ) { boolean stateChanged = loadActivitiesIfNeeded ( ) ; stateChanged | = readHistoricalDataIfNeeded ( ) ; pruneExcessiveHistoricalRecordsIfNeeded ( ) ; if ( stateChanged ) { sortActivitiesIfNeeded ( ) ; notifyChanged ( ) ; } } 
3678	private long getTotalWALSize ( FileSystem fs , List < String > wals , ServerName server ) throws IOException { long size = _NUM ; FileStatus fileStatus ; for ( String wal : wals ) { try { fileStatus = ( new WALLink ( getConf ( ) , server . getServerName ( ) , wal ) ) . getFileStatus ( fs ) ; } catch ( IOException e ) { if ( e instanceof FileNotFoundException ) { numWalsNotFound + + ; LOG . warn ( _STR , e ) ; } continue ; } size + = fileStatus . getLen ( ) ; } totalSizeOfWALs + = size ; return size ; } 
3679	public void writeOut ( OutputStream out ) throws IOException { byte intbuf [ ] = new byte [ LittleEndianConsts . INT _ SIZE ] ; byte shortbuf [ ] = new byte [ LittleEndianConsts . SHORT _ SIZE ] ; @ SuppressWarnings ( _STR ) LittleEndianOutputStream leosOut = new LittleEndianOutputStream ( out ) ; switch ( mode ) { case parsed : { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; LittleEndianOutputStream leos = new LittleEndianOutputStream ( bos ) ; total size , will be determined later . . leos . writeShort ( getFlags _NUM ( ) ) ; leos . write ( getLabel ( ) . getBytes ( ISO _NUM ) ) ; leos . write ( _NUM ) ; leos . write ( getFileName ( ) . getBytes ( ISO _NUM ) ) ; leos . write ( _NUM ) ; leos . writeShort ( getFlags _NUM ( ) ) ; leos . writeShort ( getUnknown _NUM ( ) ) ; leos . writeInt ( getCommand ( ) . length ( ) + _NUM ) ; leos . write ( getCommand ( ) . getBytes ( ISO _NUM ) ) ; leos . write ( _NUM ) ; leos . writeInt ( getDataSize ( ) ) ; leos . write ( getDataBuffer ( ) ) ; leos . writeShort ( getFlags _NUM ( ) ) ; satisfy compiler . . . leos . close ( ) ; total size leosOut . writeInt ( bos . size ( ) ) ; bos . writeTo ( out ) ; break ; } case compact : leosOut . writeInt ( getDataSize ( ) + LittleEndianConsts . SHORT _ SIZE ) ; leosOut . writeShort ( getFlags _NUM ( ) ) ; out . write ( getDataBuffer ( ) ) ; break ; default : case unparsed : leosOut . writeInt ( getDataSize ( ) ) ; out . write ( getDataBuffer ( ) ) ; break ; } } 
3680	public String getFormatted ( String key , String expr ) { Map < String , ConversionData > conversionErrors = ActionContext . getContext ( ) . getConversionErrors ( ) ; if ( conversionErrors . containsKey ( expr ) ) { String [ ] vals = ( String [ ] ) conversionErrors . get ( expr ) . getValue ( ) ; return vals [ _NUM ] ; } else { final ValueStack valueStack = ActionContext . getContext ( ) . getValueStack ( ) ; final Object val = valueStack . findValue ( expr ) ; return getText ( key , Arrays . asList ( val ) ) ; } } 
3681	public void handleEdit ( CmsLabel titleLabel , TextBox box ) { CmsClientSitemapEntry editEntry = getSitemapEntry ( ) ; final String newTitle = box . getText ( ) ; box . removeFromParent ( ) ; if ( CmsStringUtil . isEmpty ( newTitle ) ) { titleLabel . setVisible ( true ) ; String dialogTitle = Messages . get ( ) . key ( Messages . GUI _ EDIT _ TITLE _ ERROR _ DIALOG _ TITLE _ _NUM ) ; String dialogText = Messages . get ( ) . key ( Messages . GUI _ TITLE _ CANT _ BE _ EMPTY _ _NUM ) ; CmsAlertDialog alert = new CmsAlertDialog ( dialogTitle , dialogText ) ; alert . center ( ) ; return ; } String oldTitle = editEntry . getTitle ( ) ; if ( ! oldTitle . equals ( newTitle ) ) { CmsPropertyModification propMod = new CmsPropertyModification ( editEntry . getId ( ) , CmsClientProperty . PROPERTY _ NAVTEXT , newTitle , true ) ; final List < CmsPropertyModification > propChanges = new ArrayList < CmsPropertyModification > ( ) ; propChanges . add ( propMod ) ; CmsSitemapController controller = CmsSitemapView . getInstance ( ) . getController ( ) ; if ( editEntry . isNew ( ) & & ! editEntry . isRoot ( ) ) { String urlName = controller . ensureUniqueName ( CmsResource . getParentFolder ( editEntry . getSitePath ( ) ) , newTitle ) ; if ( oldTitle . equals ( editEntry . getPropertyValue ( CmsClientProperty . PROPERTY _ TITLE ) ) ) { CmsPropertyModification titleMod = new CmsPropertyModification ( editEntry . getId ( ) , CmsClientProperty . PROPERTY _ TITLE , newTitle , true ) ; propChanges . add ( titleMod ) ; } controller . editAndChangeName ( editEntry , urlName , propChanges , true , CmsReloadMode . none ) ; } else { controller . edit ( editEntry , propChanges , CmsReloadMode . none ) ; } } titleLabel . setVisible ( true ) ; } 
3682	public void updateNormalTokens ( Multimap < InetAddressAndPort , Token > endpointTokens ) { if ( endpointTokens . isEmpty ( ) ) return ; lock . writeLock ( ) . lock ( ) ; try { boolean shouldSortTokens = false ; for ( InetAddressAndPort endpoint : endpointTokens . keySet ( ) ) { Collection < Token > tokens = endpointTokens . get ( endpoint ) ; assert tokens ! = null & & ! tokens . isEmpty ( ) ; bootstrapTokens . removeValue ( endpoint ) ; tokenToEndpointMap . removeValue ( endpoint ) ; topology . addEndpoint ( endpoint ) ; leavingEndpoints . remove ( endpoint ) ; replacementToOriginal . remove ( endpoint ) ; also removing this endpoint from moving removeFromMoving ( endpoint ) ; for ( Token token : tokens ) { InetAddressAndPort prev = tokenToEndpointMap . put ( token , endpoint ) ; if ( ! endpoint . equals ( prev ) ) { if ( prev ! = null ) logger . warn ( _STR , token , prev , endpoint ) ; shouldSortTokens = true ; } } } if ( shouldSortTokens ) sortedTokens = sortTokens ( ) ; } finally { lock . writeLock ( ) . unlock ( ) ; } } 
3683	public void setDomainAxes ( CategoryAxis [ ] axes ) { for ( int i = _NUM ; i < axes . length ; i + + ) { setDomainAxis ( i , axes [ i ] , false ) ; } fireChangeEvent ( ) ; } 
3684	private void dumpBlockMeta ( Block block , PrintWriter out ) { List < DatanodeDescriptor > containingNodes = new ArrayList < DatanodeDescriptor > ( ) ; List < DatanodeStorageInfo > containingLiveReplicasNodes = new ArrayList < DatanodeStorageInfo > ( ) ; NumberReplicas numReplicas = new NumberReplicas ( ) ; source node returned is not used chooseSourceDatanode ( block , containingNodes , containingLiveReplicasNodes , numReplicas , UnderReplicatedBlocks . LEVEL ) ; not included in the numReplicas . liveReplicas ( ) count assert containingLiveReplicasNodes . size ( ) > = numReplicas . liveReplicas ( ) ; int usableReplicas = numReplicas . liveReplicas ( ) + numReplicas . decommissionedAndDecommissioning ( ) ; if ( block instanceof BlockInfo ) { BlockCollection bc = ( ( BlockInfo ) block ) . getBlockCollection ( ) ; String fileName = ( bc = = null ) ? _STR ) ; } 
3685	public < T extends ViewModel > T get ( @ NonNull String key , @ NonNull Class < T > modelClass ) { ViewModel viewModel = mViewModelStore . get ( key ) ; if ( modelClass . isInstance ( viewModel ) ) { noinspection unchecked return ( T ) viewModel ; } else { noinspection StatementWithEmptyBody if ( viewModel ! = null ) { TODO : log a warning . } } viewModel = mFactory . create ( modelClass ) ; mViewModelStore . put ( key , viewModel ) ; noinspection unchecked return ( T ) viewModel ; } 
3686	public static Model modelAdd ( Model m , String facts ) { StringTokenizer semis = new StringTokenizer ( facts , _STR ) ; while ( semis . hasMoreTokens ( ) ) { StringTokenizer st = new StringTokenizer ( semis . nextToken ( ) ) ; Resource sub = resource ( st . nextToken ( ) ) ; Property pred = property ( st . nextToken ( ) ) ; RDFNode obj = rdfNode ( st . nextToken ( ) ) ; m . add ( sub , pred , obj ) ; } return m ; } 
3687	public void newLineAtOffset ( float tx , float ty ) throws IOException { if ( ! inTextMode ) { throw new IllegalStateException ( _STR ) ; } 
3688	public SearchRequestBuilder getBuilder ( final SearchEdge searchEdge , final SearchTypes searchTypes , final QueryVisitor visitor , final int limit , final int from , final List < SortPredicate > sortPredicates , final Map < String , Class > fieldsWithType ) { Preconditions . checkArgument ( limit < = EntityIndex . MAX _ LIMIT , _STR ) ; SearchRequestBuilder srb = esProvider . getClient ( ) . prepareSearch ( alias . getReadAlias ( ) ) . setTypes ( IndexingUtils . ES _ ENTITY _ TYPE ) . setSearchType ( SearchType . QUERY _ THEN _ FETCH ) ; final Optional < QueryBuilder > queryBuilder = visitor . getQueryBuilder ( ) ; if ( queryBuilder . isPresent ( ) ) { srb . setQuery ( queryBuilder . get ( ) ) ; } srb . setPostFilter ( createFilterBuilder ( searchEdge , visitor , searchTypes ) ) ; srb = srb . setFrom ( from ) . setSize ( limit ) ; if we have a geo field , sort by closest to farthest by default final GeoSortFields geoFields = visitor . getGeoSorts ( ) ; no sort predicates , sort by edge time descending , entity id second if ( sortPredicates . size ( ) = = _NUM ) { applyDefaultSortPredicates ( srb , geoFields ) ; } else { applySortPredicates ( srb , sortPredicates , geoFields , fieldsWithType ) ; } return srb ; } 
3689	public static PMMLModel getPMMLModel ( InputStream stream , Logger log ) throws Exception { DocumentBuilderFactory dbf = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder db = dbf . newDocumentBuilder ( ) ; Document doc = db . parse ( stream ) ; stream . close ( ) ; doc . getDocumentElement ( ) . normalize ( ) ; if ( ! isPMML ( doc ) ) { throw new IllegalArgumentException ( _STR ) ; } Element model = getModelElement ( doc , modelType ) ; Construct mining schema and meta data MiningSchema ms = new MiningSchema ( model , dataDictionary , transDict ) ; System . out . println ( ms ) ; System . exit ( _NUM ) ; Instances miningSchema = getMiningSchemaAsInstances ( model , dataDictionary ) ; PMMLModel theModel = getModelInstance ( doc , modelType , model , dataDictionary , ms ) ; if ( log ! = null ) { theModel . setLog ( log ) ; } return theModel ; } 
3690	public boolean isEmpty ( ) { return size ( ) = = _NUM ; } 
3691	 @ NonNull @ VisibleForTestingfinal List < PackageInfo > getInstalledPackages ( @ UserIdInt int userId ) { final long start = injectElapsedRealtime ( ) ; final long token = injectClearCallingIdentity ( ) ; try { final List < PackageInfo > all = injectGetPackagesWithUninstalled ( userId ) ; all . removeIf ( PACKAGE _ NOT _ INSTALLED ) ; return all ; } catch ( RemoteException e ) { Shouldn ' t happen . Slog . wtf ( TAG , _STR , e ) ; return null ; } finally { injectRestoreCallingIdentity ( token ) ; logDurationStat ( Stats . GET _ INSTALLED _ PACKAGES , start ) ; } } 
3692	protected void animateCancel ( final I _ CmsDraggable draggable , final I _ CmsDNDController controller ) { controller . onAnimationStart ( draggable , null , this ) ; stopDragging ( ) ; Command callback = new Command ( ) { public void execute ( ) { controller . onDragCancel ( draggable , null , CmsDNDHandler . this ) ; draggable . onDragCancel ( ) ; clear ( ) ; } } ; showEndAnimation ( callback , m _ startTop , m _ startLeft ) ; } 
3693	private void recycleViewsFromEnd ( RecyclerView . Recycler recycler , int dt ) { final int childCount = getChildCount ( ) ; if ( dt < _NUM ) { if ( DEBUG ) { Log . d ( TAG , _STR ) ; } return ; } final int limit = mOrientationHelper . getEnd ( ) - dt ; if ( mShouldReverseLayout ) { for ( int i = _NUM ; i < childCount ; i + + ) { View child = getChildAt ( i ) ; if ( mOrientationHelper . getDecoratedStart ( child ) < limit | | mOrientationHelper . getTransformedStartWithDecoration ( child ) < limit ) { stop here recycleChildren ( recycler , _NUM , i ) ; return ; } } } else { for ( int i = childCount - _NUM ; i > = _NUM ; i - - ) { View child = getChildAt ( i ) ; if ( mOrientationHelper . getDecoratedStart ( child ) < limit | | mOrientationHelper . getTransformedStartWithDecoration ( child ) < limit ) { stop here recycleChildren ( recycler , childCount - _NUM , i ) ; return ; } } } } 
3694	private void scheduleJob ( String jobName , long fireTime , UUID jobDataId , UUID jobStatId ) { Assert . notNull ( jobName , _STR ) ; Message message = new Message ( ) ; message . setTimestamp ( fireTime ) ; message . setStringProperty ( JOB _ NAME , jobName ) ; message . setProperty ( JOB _ ID , jobDataId . toString ( ) ) ; message . setProperty ( STATS _ ID , jobStatId . toString ( ) ) ; getQm ( ) . postToQueue ( jobQueueName , message ) ; } 
3695	public void testClusteringEuclideanWithOutlierRemovalMR ( ) throws Exception { List < VectorWritable > points = getPointsWritable ( ) ; Configuration conf = getConfiguration ( ) ; ClusteringTestUtils . writePointsToFile ( points , true , getTestTempFilePath ( _STR , expectedPointsAfterOutlierRemoval , count ) ; } 
3696	public boolean containsValue ( final Object value ) { final Iterator e = this . table . values ( ) . iterator ( ) ; boolean found = false ; while ( e . hasNext ( ) & & ! found ) { final List v = ( List ) e . next ( ) ; found = v . contains ( value ) ; } return found ; } 
3697	public long readSignedVarInt ( int len ) { long value = _NUM ; switch ( len ) { case _NUM : value = _NUM ; break ; case _NUM : value = readSignedByte ( ) ; break ; case _NUM : value = readSignedShort ( ) ; break ; case _NUM : value = ( readSignedByte ( ) < < _NUM _NUM ) | readUnsignedShort ( ) ; break ; case _NUM : value = readSignedInt ( ) ; break ; case _NUM : value = readSignedByte ( ) | readUnsignedInt ( ) ; break ; case _NUM : value = readSignedShort ( ) | readUnsignedInt ( ) ; break ; case _NUM : value = ( readSignedByte ( ) < < _NUM _NUM ) | readUnsignedShort ( ) | readUnsignedInt ( ) ; break ; case _NUM : value = readSignedLong ( ) ; break ; default : throw new RuntimeException ( _STR ) ; } return value ; } 
3698	public void encode ( OutputStream output ) throws IOException { TlsUtils . writeUint _NUM ( mode , output ) ; } 
3699	protected void appendDetail ( final StringBuffer buffer , final String fieldName , final boolean value ) { buffer . append ( value ) ; } 
3700	public void buildClassifier ( Instances data ) throws Exception { can classifier tree handle the data ? getCapabilities ( ) . testWithFail ( data ) ; remove instances with missing class data = new Instances ( data ) ; data . deleteWithMissingClass ( ) ; buildTree ( data , m _ subtreeRaising ) ; if ( m _ collapseTheTree ) { collapse ( ) ; } if ( m _ pruneTheTree ) { prune ( ) ; } if ( m _ cleanup ) { cleanup ( new Instances ( data , _NUM ) ) ; } } 
3701	public boolean hasSubscribers ( ) { return subscribers . get ( ) . length ! = _NUM ; } 
3702	public static < TSource > TSource aggregate ( Enumerable < TSource > source , Function _NUM < TSource , TSource , TSource > func ) { TSource result = null ; try ( Enumerator < TSource > os = source . enumerator ( ) ) { while ( os . moveNext ( ) ) { TSource o = os . current ( ) ; result = func . apply ( result , o ) ; } return result ; } } 
3703	public static PGPPublicKeyRing removePublicKey ( PGPPublicKeyRing pubRing , PGPPublicKey pubKey ) { List keys = new ArrayList ( pubRing . keys ) ; boolean found = false ; for ( int i = _NUM ; i < keys . size ( ) ; i + + ) { PGPPublicKey key = ( PGPPublicKey ) keys . get ( i ) ; if ( key . getKeyID ( ) = = pubKey . getKeyID ( ) ) { found = true ; keys . remove ( i ) ; } } if ( ! found ) { return null ; } return new PGPPublicKeyRing ( keys ) ; } 
3704	private void bfSearchForLastEOFMarker ( ) throws IOException { if ( lastEOFMarker = = null ) { long originOffset = source . getPosition ( ) ; source . seek ( MINIMUM _ SEARCH _ OFFSET ) ; while ( ! source . isEOF ( ) ) { search for EOF marker if ( isString ( EOF _ MARKER ) ) { long tempMarker = source . getPosition ( ) ; source . seek ( tempMarker + _NUM ) ; try { check if the following data is some valid pdf content which most likely indicates that the pdf is linearized , updated or just cut off somewhere in the middle skipSpaces ( ) ; if ( ! isString ( XREF _ TABLE ) ) { readObjectNumber ( ) ; readGenerationNumber ( ) ; } } catch ( IOException exception ) { save the EOF marker as the following data is most likely some garbage LOG . debug ( _STR , exception ) ; lastEOFMarker = tempMarker ; } } source . read ( ) ; } source . seek ( originOffset ) ; no EOF marker found if ( lastEOFMarker = = null ) { lastEOFMarker = Long . MAX _ VALUE ; } } } 
3705	private static int shlosserEstimator ( UncompressedBitmap ubm , int nRows , int sampleSize ) { double q = ( ( double ) sampleSize ) / nRows ; double oneMinusQ = _NUM - q ; int numVals = ubm . getNumValues ( ) ; int [ ] freqCounts = getFreqCounts ( ubm ) ; double numerSum = _NUM , denomSum = _NUM ; int iPlusOne = _NUM ; for ( int i = _NUM ; i < freqCounts . length ; i + + , iPlusOne + + ) { numerSum + = Math . pow ( oneMinusQ , iPlusOne ) * freqCounts [ i ] ; denomSum + = iPlusOne * q * Math . pow ( oneMinusQ , i ) * freqCounts [ i ] ; } int estimate = ( int ) Math . round ( numVals + freqCounts [ _NUM ] * numerSum / denomSum ) ; return estimate < _NUM ? _NUM : estimate ; } 
3706	private long getIdFromKeyIdsLPr ( Set < Long > publicKeyIds ) { for ( int keyMapIndex = _NUM ; keyMapIndex < mKeySetMapping . size ( ) ; keyMapIndex + + ) { ArraySet < Long > value = mKeySetMapping . valueAt ( keyMapIndex ) ; if ( value . equals ( publicKeyIds ) ) { return mKeySetMapping . keyAt ( keyMapIndex ) ; } } return KEYSET _ NOT _ FOUND ; } 
3707	public org . apache . drill . exec . proto . UserProtos . SchemaMetadata . Builder addSchemasBuilder ( ) { return getSchemasFieldBuilder ( ) . addBuilder ( org . apache . drill . exec . proto . UserProtos . SchemaMetadata . getDefaultInstance ( ) ) ; } 
3708	public void beginTransactionNonExclusive ( ) { beginTransaction ( null , false ) ; } 
3709	public void updateOverlayPanel ( ) { Instances newI = createAvailableOverlayList ( ) ; if ( newI = = null ) { m _ useOverlayData . setSelected ( false ) ; m _ useOverlayData . setEnabled ( false ) ; m _ overlaySelector . clearTableModel ( ) ; } else { m _ useOverlayData . setEnabled ( true ) ; if ( m _ useOverlayData . isSelected ( ) ) { if ( m _ overlayHeader = = null | | ! newI . equalHeaders ( m _ overlayHeader ) ) { m _ overlayHeader = newI ; m _ overlaySelector . setInstances ( newI ) ; } } } } 
3710	protected boolean [ ] correctBuildInitialisation ( AttrTypes attrTypes , int classType ) { boolean [ ] result = new boolean [ _NUM ] ; print ( _STR ) ; } } return result ; } 
3711	public static long [ ] hashToLongs ( final double datum , final long seed ) { canonicalize - _NUM . _NUM , _NUM . _NUM final double d = ( datum = = _NUM . _NUM ) ? _NUM . _NUM : datum ; canonicalize all NaN forms final long [ ] data = { Double . doubleToLongBits ( d ) } ; return hash ( data , seed ) ; } 
3712	public static boolean isMatrix ( IntBuffer shapeInfo ) { int rank = Shape . rank ( shapeInfo ) ; if ( rank ! = _NUM ) return false ; return ! isVector ( shapeInfo ) ; } 
3713	public void close ( ) { if ( isOpen ( ) ) { synchronized ( mLock ) { try { mChannel . close ( ) ; } catch ( Exception e ) { Log . e ( TAG , _STR , e ) ; } } } } 
3714	public byte [ ] toByteArray ( final ArrayOfItemsSerDe < T > serDe ) { if ( gadget _ = = null | | gadget _ . getNumSamples ( ) = = _NUM ) { return toByteArray ( serDe , null ) ; } else { return toByteArray ( serDe , gadget _ . getValueAtPosition ( _NUM ) . getClass ( ) ) ; } } 
3715	public boolean sameKey ( final Item item , final InputInfo info ) throws QueryException { return comparable ( item ) & & eq ( item , null , null , info ) ; } 
3716	private void onEdenProtectedHit ( Node node ) { node . moveToTail ( headEdenProtected ) ; } 
3717	public void set ( String name , String value , String source ) { Preconditions . checkArgument ( name ! = null , _STR ; for ( String n : names ) { getOverlay ( ) . setProperty ( n , value ) ; getProps ( ) . setProperty ( n , value ) ; updatingResource . put ( n , new String [ ] { altSource } ) ; } } } 
3718	public void validateUserCredentialWithoutCaCert ( ) throws Exception { Credential cred = createCredentialWithUserCredential ( ) ; cred . setCaCertificate ( null ) ; assertFalse ( cred . validate ( ) ) ; } 
3719	public void release ( ) throws Exception { try ( Connection connection = getConnection ( ) ) { String lockResetIdStatement = statements . getLockResetIdStatement ( uniqueId ) ; try ( PreparedStatement preparedStatement = connection . prepareStatement ( lockResetIdStatement ) ) { This statement will set the ID to _NUM and allow others to steal the lock . . . preparedStatement . executeUpdate ( ) ; } } catch ( SQLException e ) { LOG . log ( Level . SEVERE , _STR , e ) ; } } 
3720	private int getOffsetBeforeAfter ( int runIndex , int runStart , int runLimit , boolean runIsRtl , int offset , boolean after ) { if ( runIndex < _NUM | | offset = = ( after ? mLen : _NUM ) ) { return accurate values . These are a guess . if ( after ) { return TextUtils . getOffsetAfter ( mText , offset + mStart ) - mStart ; } return TextUtils . getOffsetBefore ( mText , offset + mStart ) - mStart ; } TextPaint wp = mWorkPaint ; wp . set ( mPaint ) ; wp . setWordSpacing ( mAddedWidth ) ; int spanStart = runStart ; int spanLimit ; if ( mSpanned = = null ) { spanLimit = runLimit ; } else { int target = after ? offset + _NUM : offset ; int limit = mStart + runLimit ; while ( true ) { spanLimit = mSpanned . nextSpanTransition ( mStart + spanStart , limit , MetricAffectingSpan . class ) - mStart ; if ( spanLimit > = target ) { break ; } spanStart = spanLimit ; } MetricAffectingSpan [ ] spans = mSpanned . getSpans ( mStart + spanStart , mStart + spanLimit , MetricAffectingSpan . class ) ; spans = TextUtils . removeEmptySpans ( spans , mSpanned , MetricAffectingSpan . class ) ; if ( spans . length > _NUM ) { ReplacementSpan replacement = null ; for ( int j = _NUM ; j < spans . length ; j + + ) { MetricAffectingSpan span = spans [ j ] ; if ( span instanceof ReplacementSpan ) { replacement = ( ReplacementSpan ) span ; } else { span . updateMeasureState ( wp ) ; } } if ( replacement ! = null ) { the start or end of this span . return after ? spanLimit : spanStart ; } } } int dir = runIsRtl ? Paint . DIRECTION _ RTL : Paint . DIRECTION _ LTR ; int cursorOpt = after ? Paint . CURSOR _ AFTER : Paint . CURSOR _ BEFORE ; if ( mCharsValid ) { return wp . getTextRunCursor ( mChars , spanStart , spanLimit - spanStart , dir , offset , cursorOpt ) ; } else { return wp . getTextRunCursor ( mText , mStart + spanStart , mStart + spanLimit , dir , mStart + offset , cursorOpt ) - mStart ; } } 
3721	public ModifyInstanceAttributeRequest withGroups ( String . . . groups ) { if ( getGroups ( ) = = null ) setGroups ( new java . util . ArrayList < String > ( groups . length ) ) ; for ( String value : groups ) { getGroups ( ) . add ( value ) ; } return this ; } 
3722	protected void printError ( String id , Span [ ] references , Span [ ] predictions , T referenceSample , T predictedSample , String [ ] sentenceTokens ) { List < Span > falseNegatives = new ArrayList < > ( ) ; List < Span > falsePositives = new ArrayList < > ( ) ; findErrors ( references , predictions , falseNegatives , falsePositives ) ; if ( falsePositives . size ( ) + falseNegatives . size ( ) > _NUM ) { if ( id ! = null ) { printStream . println ( _STR ) ; } printSamples ( referenceSample , predictedSample ) ; printErrors ( falsePositives , falseNegatives , sentenceTokens ) ; } } 
3723	public synchronized void transitiveClosure ( ) { for ( T oj : index ) { Set < T > si = cols . get ( oj ) ; Set < T > sk = rows . get ( oj ) ; if ( si ! = null & & sk ! = null ) { Iterator < T > i = si . iterator ( ) ; while ( i . hasNext ( ) ) { T oi = i . next ( ) ; if ( oi ! = oj ) { Iterator < T > k = sk . iterator ( ) ; while ( k . hasNext ( ) ) { T ok = k . next ( ) ; if ( ok ! = oj ) { set ( oi , ok ) ; } } } } } } } 
3724	public void flip ( int pos _NUM , int pos _NUM ) { if ( pos _NUM < _NUM | | pos _NUM < _NUM | | pos _NUM < pos _NUM ) { throw new IndexOutOfBoundsException ( _STR + pos _NUM ) ; } if ( pos _NUM = = pos _NUM ) { return ; } int len _NUM = ( ( pos _NUM - _NUM ) > > OFFSET ) + _NUM ; if ( len _NUM > bits . length ) { growLength ( len _NUM ) ; } int idx _NUM = pos _NUM > > OFFSET ; int idx _NUM = ( pos _NUM - _NUM ) > > OFFSET ; long factor _NUM = ( ~ _NUM L ) < < ( pos _NUM & RIGHT _ BITS ) ; long factor _NUM = ( ~ _NUM L ) > > > ( ELM _ SIZE - ( pos _NUM & RIGHT _ BITS ) ) ; if ( idx _NUM = = idx _NUM ) { bits [ idx _NUM ] ^ = ( factor _NUM & factor _NUM ) ; } else { bits [ idx _NUM ] ^ = factor _NUM ; bits [ idx _NUM ] ^ = factor _NUM ; for ( int i = idx _NUM + _NUM ; i < idx _NUM ; i + + ) { bits [ i ] ^ = ( ~ _NUM L ) ; } } if ( len _NUM > actualArrayLength ) { actualArrayLength = len _NUM ; } isLengthActual = ! ( ( actualArrayLength > _NUM ) & & ( bits [ actualArrayLength - _NUM ] = = _NUM ) ) ; needClear ( ) ; } 
3725	public Iterator < Element > iterateNonZero ( ) { return new Iterator < Element > ( ) { class NonZeroElement implements Element { int index ; @ Override public double get ( ) { return getQuick ( index ) ; } @ Override public int index ( ) { return index ; } @ Override public void set ( double value ) { invalidateCachedLength ( ) ; setQuick ( index , value ) ; } } private final NonZeroElement element = new NonZeroElement ( ) ; private int index = - _NUM ; private int lookAheadIndex = - _NUM ; @ Override public boolean hasNext ( ) { if ( lookAheadIndex = = index ) { User calls hasNext ( ) after a next ( ) lookAhead ( ) ; } else user called hasNext ( ) repeatedly . return lookAheadIndex < size ( ) ; } private void lookAhead ( ) { lookAheadIndex + + ; while ( lookAheadIndex < size ( ) & & getQuick ( lookAheadIndex ) = = _NUM . _NUM ) { lookAheadIndex + + ; } } @ Override public Element next ( ) { if ( lookAheadIndex = = index ) { If user called next ( ) without checking hasNext ( ) . lookAhead ( ) ; } index = lookAheadIndex ; if ( index > = size ( ) ) { If the end is reached . throw new NoSuchElementException ( ) ; } element . index = index ; return element ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } 
3726	void checkResponse ( RpcResponseHeaderProto header ) throws IOException { if ( header = = null ) { throw new EOFException ( _STR + StringUtils . byteToHexString ( header . getClientId ( ) . toByteArray ( ) ) ) ; } } } } 
3727	protected PackageConfig addPackage ( Element packageElement ) throws ConfigurationException { String packageName = packageElement . getAttribute ( _STR ) ; for ( int i = _NUM ; i < actionList . getLength ( ) ; i + + ) { Element actionElement = ( Element ) actionList . item ( i ) ; addAction ( actionElement , newPackage ) ; } load the default action reference for this package loadDefaultActionRef ( newPackage , packageElement ) ; PackageConfig cfg = newPackage . build ( ) ; configuration . addPackageConfig ( cfg . getName ( ) , cfg ) ; return cfg ; } 
3728	public void setChmodDirectory ( String chmodDirectory ) throws Exception { if ( ObjectHelper . isNotEmpty ( chmodDirectory ) & & chmodPermissionsAreValid ( chmodDirectory ) ) { this . chmodDirectory = chmodDirectory . trim ( ) ; } else { throw new IllegalArgumentException ( _STR ) ; } } 
3729	static byte [ ] ntlm _NUM SessionResponse ( final byte [ ] ntlmHash , final byte [ ] challenge , final byte [ ] clientChallenge ) throws NTLMEngineException { try { final MessageDigest md _NUM = getMD _NUM ( ) ; md _NUM . update ( challenge ) ; md _NUM . update ( clientChallenge ) ; final byte [ ] digest = md _NUM . digest ( ) ; final byte [ ] sessionHash = new byte [ _NUM ] ; System . arraycopy ( digest , _NUM , sessionHash , _NUM , _NUM ) ; return lmResponse ( ntlmHash , sessionHash ) ; } catch ( final Exception e ) { if ( e instanceof NTLMEngineException ) { throw ( NTLMEngineException ) e ; } throw new NTLMEngineException ( e . getMessage ( ) , e ) ; } } 
3730	public PdfIndirectReference getAsIndirectObject ( PdfName key ) { PdfIndirectReference ref = null ; not getDirect this time . PdfObject orig = get ( key ) ; if ( orig ! = null & & orig . isIndirect ( ) ) ref = ( PdfIndirectReference ) orig ; return ref ; } 
3731	public boolean match ( Object obj ) { try { if ( ! ( obj instanceof X _NUM _NUM _NUM CertificatePair ) ) { return false ; } X _NUM _NUM _NUM CertificatePair pair = ( X _NUM _NUM _NUM CertificatePair ) obj ; if ( forwardSelector ! = null & & ! forwardSelector . match ( ( Object ) pair . getForward ( ) ) ) { return false ; } if ( reverseSelector ! = null & & ! reverseSelector . match ( ( Object ) pair . getReverse ( ) ) ) { return false ; } if ( certPair ! = null ) { return certPair . equals ( obj ) ; } return true ; } catch ( Exception e ) { return false ; } } 
3732	public void addBlankLine ( String section ) { if ( hasSection ( section ) ) { getSection ( section ) . addBlankLine ( ) ; } else { throw new NoSuchSectionException ( section ) ; } } 
3733	public void readInteger ( ) throws IOException { if ( tag ! = ASN _NUM Constants . TAG _ INTEGER ) { throw expected ( _STR ) ; } } } 
3734	public String getTid ( VISAFormaPagamento parcelamento , Calendar data , long numeroDeFiliacao ) { String dataNoFormatoJuliano = obterDataNoFormatoJuliano ( data ) ; String numeroDeFiliacaoString = String . valueOf ( numeroDeFiliacao ) ; String numeroDeAfiliacaoDoVisaFormatado = String . valueOf ( numeroDeFiliacaoString ) . substring ( _NUM , numeroDeFiliacaoString . length ( ) - _NUM ) ; String horaFormatadaComOMilesimoDoSegundo = String . format ( _STR + String . valueOf ( data . get ( Calendar . MILLISECOND ) ) . substring ( _NUM , _NUM ) , data ) ; String ultimoDigitoDoAno = getUltimoDigitoDoAno ( data ) ; String tid = numeroDeAfiliacaoDoVisaFormatado + ultimoDigitoDoAno + dataNoFormatoJuliano + horaFormatadaComOMilesimoDoSegundo + parcelamento . getCodigoDePagamento ( ) ; return tid ; } 
3735	public CommitLogSegment . Allocation allocate ( Mutation mutation , int size ) { CommitLogSegment segment = allocatingFrom ( ) ; CommitLogSegment . Allocation alloc ; while ( null = = ( alloc = segment . allocate ( mutation , size ) ) ) { failed to allocate , so move to a new segment with enough room advanceAllocatingFrom ( segment ) ; segment = allocatingFrom ( ) ; } return alloc ; } 
3736	Rect flingToMinimizedState ( float velocityY , Rect movementBounds , Point dragStartPosition ) { cancelAnimations ( ) ; We currently only allow flinging the minimized stack up and down , so just lock the movement bounds to the current stack bounds horizontally movementBounds = new Rect ( mBounds . left , movementBounds . top , mBounds . left , movementBounds . bottom ) ; Rect toBounds = mSnapAlgorithm . findClosestSnapBounds ( movementBounds , mBounds , _NUM , velocityY , dragStartPosition ) ; if ( ! mBounds . equals ( toBounds ) ) { mBoundsAnimator = createAnimationToBounds ( mBounds , toBounds , _NUM , FAST _ OUT _ SLOW _ IN ) ; mFlingAnimationUtils . apply ( mBoundsAnimator , _NUM , distanceBetweenRectOffsets ( mBounds , toBounds ) , velocityY ) ; mBoundsAnimator . start ( ) ; } return toBounds ; } 
3737	public int findFirstCompletelyVisibleItemPosition ( ) { final View child = findOneVisibleChild ( _NUM , getChildCount ( ) , true , false ) ; return child = = null ? NO _ POSITION : getPosition ( child ) ; } 
3738	TODO : Move to DisplayContentboolean updateFocusedWindowLocked ( int mode , boolean updateInputWindows ) { WindowState newFocus = mRoot . computeFocusedWindow ( ) ; if ( mCurrentFocus ! = newFocus ) { Trace . traceBegin ( TRACE _ TAG _ WINDOW _ MANAGER , _STR + Debug . getCallers ( _NUM ) ) ; final WindowState oldFocus = mCurrentFocus ; mCurrentFocus = newFocus ; mLosingFocus . remove ( newFocus ) ; if ( mCurrentFocus ! = null ) { mWinAddedSinceNullFocus . clear ( ) ; mWinRemovedSinceNullFocus . clear ( ) ; } int focusChanged = mPolicy . focusChangedLw ( oldFocus , newFocus ) ; if ( imWindowChanged & & oldFocus ! = mInputMethodWindow ) { Focus of the input method window changed . Perform layout if needed . if ( mode = = UPDATE _ FOCUS _ PLACING _ SURFACES ) { displayContent . performLayout ( true , updateInputWindows ) ; focusChanged & = ~ FINISH _ LAYOUT _ REDO _ LAYOUT ; } else if ( mode = = UPDATE _ FOCUS _ WILL _ PLACE _ SURFACES ) { Client will do the layout , but we need to assign layers for handleNewWindowLocked ( ) below . displayContent . assignWindowLayers ( false ) ; } } if ( ( focusChanged & FINISH _ LAYOUT _ REDO _ LAYOUT ) ! = _NUM ) { The change in focus caused us to need to do a layout . Okay . displayContent . setLayoutNeeded ( ) ; if ( mode = = UPDATE _ FOCUS _ PLACING _ SURFACES ) { displayContent . performLayout ( true , updateInputWindows ) ; } } if ( mode ! = UPDATE _ FOCUS _ WILL _ ASSIGN _ LAYERS ) { If we defer assigning layers , then the caller is responsible for doing this part . mInputMonitor . setInputFocusLw ( mCurrentFocus , updateInputWindows ) ; } displayContent . adjustForImeIfNeeded ( ) ; We may need to schedule some toast windows to be removed . The toasts for an app that does not have input focus are removed within a timeout to prevent apps to redress other apps ' UI . displayContent . scheduleToastWindowsTimeoutIfNeededLocked ( oldFocus , newFocus ) ; Trace . traceEnd ( TRACE _ TAG _ WINDOW _ MANAGER ) ; return true ; } return false ; } 
3739	public void setOnShareTargetSelectedListener ( OnShareTargetSelectedListener listener ) { mOnShareTargetSelectedListener = listener ; setActivityChooserPolicyIfNeeded ( ) ; } 
3740	public boolean add ( E val ) { int index = getIndex ( val ) ; if ( index < _NUM | | index > size ) return false ; int level = randomizeLevel ( ) ; if ( level > head . level ) head = new Node ( null , level , index , null , head ) ; int cur _ pos = - _NUM ; Node cur = head , last = null ; while ( cur ! = null ) { if ( cur . next ! = null & & cur _ pos + cur . length < index ) { cur _ pos + = cur . length ; cur = cur . next ; } else { cur . length + + ; if ( cur . level < = level ) { Node toAdd = new Node ( val , cur . level , _NUM , cur . next , null ) ; toAdd . length = cur . length - ( index - cur _ pos ) ; cur . length = index - cur _ pos ; if ( last ! = null ) last . down = toAdd ; cur . next = toAdd ; last = toAdd ; } cur = cur . down ; } } + + size ; return true ; } 
3741	public boolean startNestedScroll ( @ ScrollAxis int axes , @ NestedScrollType int type ) { if ( hasNestedScrollingParent ( type ) ) { Already in progress return true ; } if ( isNestedScrollingEnabled ( ) ) { ViewParent p = mView . getParent ( ) ; View child = mView ; while ( p ! = null ) { if ( ViewParentCompat . onStartNestedScroll ( p , child , mView , axes , type ) ) { setNestedScrollingParentForType ( type , p ) ; ViewParentCompat . onNestedScrollAccepted ( p , child , mView , axes , type ) ; return true ; } if ( p instanceof View ) { child = ( View ) p ; } p = p . getParent ( ) ; } } return false ; } 
3742	public static void userhomeSmokeTest ( ViewContext context ) { try { UserService userservice = new UserService ( context , getViewConfigs ( context ) ) ; userservice . homeDir ( ) ; } catch ( WebApplicationException ex ) { throw ex ; } catch ( Exception ex ) { throw new ServiceFormattedException ( ex . getMessage ( ) , ex ) ; } } 
3743	public void append ( long key , E value ) { if ( mSize ! = _NUM & & key < = mKeys [ mSize - _NUM ] ) { put ( key , value ) ; return ; } if ( mGarbage & & mSize > = mKeys . length ) { gc ( ) ; } int pos = mSize ; if ( pos > = mKeys . length ) { int n = idealLongArraySize ( pos + _NUM ) ; long [ ] nkeys = new long [ n ] ; Object [ ] nvalues = new Object [ n ] ; Log . e ( _STR + n ) ; System . arraycopy ( mKeys , _NUM , nkeys , _NUM , mKeys . length ) ; System . arraycopy ( mValues , _NUM , nvalues , _NUM , mValues . length ) ; mKeys = nkeys ; mValues = nvalues ; } mKeys [ pos ] = key ; mValues [ pos ] = value ; mSize = pos + _NUM ; } 
3744	public static boolean elementsEqual ( Iterable < ? > iterable _NUM , Iterable < ? > iterable _NUM ) { if ( iterable _NUM instanceof Collection & & iterable _NUM instanceof Collection ) { Collection < ? > collection _NUM = ( Collection < ? > ) iterable _NUM ; Collection < ? > collection _NUM = ( Collection < ? > ) iterable _NUM ; if ( collection _NUM . size ( ) ! = collection _NUM . size ( ) ) { return false ; } } return Iterators . elementsEqual ( iterable _NUM . iterator ( ) , iterable _NUM . iterator ( ) ) ; } 
3745	public static boolean isNotBlank ( final CharSequence cs ) { return ! isBlank ( cs ) ; } 
3746	public boolean isEmpty ( ) { return ( content . toString ( ) . trim ( ) . length ( ) = = _NUM ) & & ( content . toString ( ) . indexOf ( _STR ) = = - _NUM ) & & ( attributes = = null ) ; } 
3747	protected void onReset ( ) { super . onReset ( ) ; Ensure the loader is stopped onStopLoading ( ) ; if needed . if ( mApps ! = null ) { onReleaseResources ( mApps ) ; mApps = null ; } Stop monitoring for changes . if ( mPackageObserver ! = null ) { getContext ( ) . unregisterReceiver ( mPackageObserver ) ; mPackageObserver = null ; } } 
3748	public Number getEndX ( int series , int item ) { if ( this . parent instanceof IntervalXYDataset ) { return ( ( IntervalXYDataset ) this . parent ) . getEndX ( this . map [ series ] , item ) ; } else { return getX ( series , item ) ; } } 
3749	public void exportExcelForBigDataAndZipAndSave ( String [ ] header , String [ ] properties , List < Object > excelList , String sheetTitle , String flag , String filePath , String excelName , String zipName ) { èŽ· å– ç”Ÿ æˆ çš„ Excel é›† åˆ List < HSSFWorkbook > books = exportExcelForBigData ( header , properties , excelList , sheetTitle , flag ) ; å°† ç”Ÿ æˆ çš„ Excel æ‰“ åŒ… å¹¶ ä¿ å­˜ zipExcelAndSave ( books , filePath , zipName , excelName ) ; } 
3750	public void destroyAll ( @ Nullable PendingUi pendingSaveUi , @ Nullable AutoFillUiCallback callback , boolean notifyClient ) { mHandler . post ( ( ) - > destroyAllUiThread ( pendingSaveUi , callback , notifyClient ) ) ; } 
3751	public boolean template ( String element , String elementlist , boolean checkall ) { if ( isNotInitialized ( ) ) { return true ; } try { return CmsJspTagTemplate . templateTagAction ( element , elementlist , checkall , false , getRequest ( ) ) ; } catch ( Throwable t ) { handleException ( t ) ; } return true ; } 
3752	public void prepForPrune ( ) { final int cueCount = mRegionCueBoxes . size ( ) ; for ( int i = _NUM ; i < cueCount ; i + + ) { final CueLayout cueBox = mRegionCueBoxes . get ( i ) ; cueBox . prepForPrune ( ) ; } } 
3753	protected void openPopup ( final A _ CmsContextMenuItem item ) { m _ popup . add ( item . getSubMenu ( ) ) ; m _ popup . addAutoHidePartner ( item . getElement ( ) ) ; m _ popup . setModal ( false ) ; m _ popup . show ( ) ; setSubMenuPosition ( item ) ; if ( m _ isFixed ) { m _ popup . setPositionFixed ( ) ; } } 
3754	public static boolean isClassBytesOk ( final Logger logger , final String logTag , final byte [ ] classBytes ) { final ClassNode classNode = classFromBytes ( classBytes , _NUM ) ; return isClassOk ( logger , logTag , classNode ) ; } 
3755	public DicomMetaData getStreamMetadata ( String formatName , Set < String > nodeNames ) throws IOException { DicomMetaData ret = getStreamMetadata ( ) ; if ( nodeNames ! = null & & nodeNames . contains ( POST _ PIXEL _ DATA ) ) { readPostPixeldata ( ) ; return getStreamMetadata ( ) ; } return ret ; } 
3756	public static XmlNMTOKEN parse ( org . apache . xmlbeans . xml . stream . XMLInputStream xis , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , org . apache . xmlbeans . xml . stream . XMLStreamException { return ( XmlNMTOKEN ) XmlBeans . getContextTypeLoader ( ) . parse ( xis , type , options ) ; } 
3757	public void write ( ClusterWritable clusterWritable ) throws IOException { Map < String , Object > res = new HashMap < > ( ) ; get top terms if ( dictionary ! = null ) { List < Object > topTerms = getTopFeaturesList ( clusterWritable . getValue ( ) . getCenter ( ) , dictionary , numTopFeatures ) ; res . put ( _STR ) ; } 
3758	public void setSpeedTextTypeface ( Typeface typeface ) { speedTextPaint . setTypeface ( typeface ) ; unitTextPaint . setTypeface ( typeface ) ; if ( ! attachedToWindow ) return ; updateBackgroundBitmap ( ) ; invalidate ( ) ; } 
3759	public boolean isBluetoothScoAvailableOffCall ( ) { return getContext ( ) . getResources ( ) . getBoolean ( com . android . internal . R . bool . config _ bluetooth _ sco _ off _ call ) ; } 
3760	public double interClusterDensity ( ) { if ( interClusterDensity ! = null ) { return interClusterDensity ; } double sum = _NUM . _NUM ; int count = _NUM ; Map < Integer , Map < Integer , Double > > distances = interClusterDensities ( ) ; for ( Map < Integer , Double > row : distances . values ( ) ) { for ( Double density : row . values ( ) ) { if ( ! Double . isNaN ( density ) ) { sum + = density ; count + + ; } } } log . debug ( _STR , sum ) ; interClusterDensity = sum / count ; return interClusterDensity ; } 
3761	public int getProfileConnectionState ( int profile ) { if ( getState ( ) ! = STATE _ ON ) { return BluetoothProfile . STATE _ DISCONNECTED ; } try { mServiceLock . readLock ( ) . lock ( ) ; if ( mService ! = null ) { return mService . getProfileConnectionState ( profile ) ; } } catch ( RemoteException e ) { Log . e ( TAG , _STR , e ) ; } finally { mServiceLock . readLock ( ) . unlock ( ) ; } return BluetoothProfile . STATE _ DISCONNECTED ; } 
3762	void removeWidgetLocked ( Widget widget ) { mWidgets . remove ( widget ) ; onWidgetRemovedLocked ( widget ) ; } 
3763	public final char [ ] findNextChar ( boolean inMiddleOfString , boolean wasEscapeChar , int match , int esc ) { try { grow the buffer and read in if needed ensureBuffer ( ) ; int idx = index ; char [ ] _ chars = readBuf ; int length = this . length ; int ch = this . ch ; if ( ! inMiddleOfString ) { foundEscape = false ; if ( ch = = match ) { we can start with a match but we ignore it if we are not in the middle of a string . } else if ( idx < length - _NUM ) { ch = _ chars [ idx ] ; if ( ch = = match ) { idx + + ; } } } if ( idx < length ) { ch = _ chars [ idx ] ; } if ( ch = = ' _STR , readBuf , index , ch ) ; return Exceptions . handle ( char [ ] . class , str , ex ) ; } } 
3764	private void loadData ( ) throws IOException { long startKey = _NUM ; long endKey = _NUM _NUM _NUM _NUM _NUM _NUM ; int minColsPerKey = _NUM ; int maxColsPerKey = _NUM _NUM ; int minColDataSize = _NUM _NUM _NUM ; int maxColDataSize = _NUM _NUM _NUM * _NUM ; int numThreads = _NUM _NUM ; print out the arguments System . out . printf ( _STR ) ; } 
3765	static Map < DatanodeInfo , HdfsBlocksMetadata > queryDatanodesForHdfsBlocksMetadata ( Configuration conf , Map < DatanodeInfo , List < LocatedBlock > > datanodeBlocks , int poolsize , int timeoutMs , boolean connectToDnViaHostname ) throws InvalidBlockTokenException { List < VolumeBlockLocationCallable > callables = createVolumeBlockLocationCallables ( conf , datanodeBlocks , timeoutMs , connectToDnViaHostname , Trace . currentSpan ( ) ) ; Use a thread pool to execute the Callables in parallel List < Future < HdfsBlocksMetadata > > futures = new ArrayList < Future < HdfsBlocksMetadata > > ( ) ; ExecutorService executor = new ScheduledThreadPoolExecutor ( poolsize ) ; try { futures = executor . invokeAll ( callables , timeoutMs , TimeUnit . MILLISECONDS ) ; } catch ( InterruptedException e ) { Swallow the exception here , because we can return partial results } executor . shutdown ( ) ; Map < DatanodeInfo , HdfsBlocksMetadata > metadatas = Maps . newHashMapWithExpectedSize ( datanodeBlocks . size ( ) ) ; Fill in metadatas with results from DN RPCs , where possible for ( int i = _NUM ; i < futures . size ( ) ; i + + ) { VolumeBlockLocationCallable callable = callables . get ( i ) ; DatanodeInfo datanode = callable . getDatanodeInfo ( ) ; Future < HdfsBlocksMetadata > future = futures . get ( i ) ; try { HdfsBlocksMetadata metadata = future . get ( ) ; metadatas . put ( callable . getDatanodeInfo ( ) , metadata ) ; } catch ( CancellationException e ) { LOG . info ( _STR ) ; } } return metadatas ; } 
3766	public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( _STR ) ; return sb . toString ( ) ; } 
3767	public void init ( Properties config , ServletContext servletContext , long tokenValidity ) throws Exception { initSecrets ( generateNewSecret ( ) , null ) ; startScheduler ( tokenValidity , tokenValidity ) ; } 
3768	public Class getTypeForTagName ( final String tagName ) throws ObjectDescriptionException { final PropertyDefinition pdef = getPropertyDefinitionByTagName ( tagName ) ; final PropertyDescriptor pdescr = getPropertyDescriptor ( pdef . getPropertyName ( ) ) ; if ( pdescr = = null ) { throw new ObjectDescriptionException ( _STR + pdef . getPropertyName ( ) ) ; } return pdescr . getPropertyType ( ) ; } 
3769	public void setUp ( ) throws Exception { super . setUp ( ) ; byte [ ] block = SwiftTestUtils . dataset ( SEEK _ FILE _ LEN , _NUM , _NUM _NUM _NUM ) ; delete the test directory testPath = path ( _STR ) ; createFile ( readFile , block ) ; } 
3770	public static void setConnectorInfo ( Class < ? > implementingClass , Configuration conf , String principal , String tokenFile ) throws AccumuloSecurityException { if ( isConnectorInfoSet ( implementingClass , conf ) ) throw new IllegalStateException ( _STR ) ; } conf . setBoolean ( enumToConfKey ( implementingClass , ConnectorInfo . IS _ CONFIGURED ) , true ) ; conf . set ( enumToConfKey ( implementingClass , ConnectorInfo . PRINCIPAL ) , principal ) ; conf . set ( enumToConfKey ( implementingClass , ConnectorInfo . TOKEN ) , TokenSource . FILE . prefix ( ) + tokenFile ) ; } 
3771	public void delete ( T entity , Option . . . options ) { checkNotInEventLoop ( ) ; try { Uninterruptibles . getUninterruptibly ( deleteAsync ( entity , options ) ) ; } catch ( ExecutionException e ) { throw DriverThrowables . propagateCause ( e ) ; } } 
3772	public Collection getAttributeAuthorityRevocationLists ( X _NUM _NUM _NUM CRLStoreSelector selector ) throws StoreException { String [ ] attrs = splitString ( params . getAttributeAuthorityRevocationListAttribute ( ) ) ; String [ ] attrNames = splitString ( params . getLdapAttributeAuthorityRevocationListAttributeName ( ) ) ; String [ ] issuerAttributeNames = splitString ( params . getAttributeAuthorityRevocationListIssuerAttributeName ( ) ) ; List list = cRLIssuerSearch ( selector , attrs , attrNames , issuerAttributeNames ) ; Set resultSet = createCRLs ( list , selector ) ; if ( resultSet . size ( ) = = _NUM ) { X _NUM _NUM _NUM CRLStoreSelector emptySelector = new X _NUM _NUM _NUM CRLStoreSelector ( ) ; list = cRLIssuerSearch ( emptySelector , attrs , attrNames , issuerAttributeNames ) ; resultSet . addAll ( createCRLs ( list , selector ) ) ; } return resultSet ; } 
3773	void maybeUpdateConnectionId ( ) { if ( encryptionOptions ! = null ) { int version = MessagingService . instance ( ) . getVersion ( connectionId . remote ( ) ) ; if ( version < targetVersion ) { targetVersion = version ; int port = MessagingService . instance ( ) . portFor ( connectionId . remote ( ) ) ; connectionId = connectionId . withNewConnectionPort ( port ) ; logger . debug ( _STR , connectionId , version ) ; } } } 
3774	private PageResponse getPageToOffset ( int pageSize , int offset , Set < Resource > resources , Predicate predicate , ResourcePredicateEvaluator evaluator ) { int currentOffset = resources . size ( ) - _NUM ; Resource next = null ; List < Resource > pageResources = new LinkedList < > ( ) ; LinkedList < Resource > filteredResources = getEvaluatedResources ( new ResourceIterable ( resources , predicate , evaluator ) ) ; Iterator < Resource > iterator = filteredResources . descendingIterator ( ) ; if ( offset ! = - _NUM ) { skip till offset while ( currentOffset > offset & & iterator . hasNext ( ) ) { next = iterator . next ( ) ; - - currentOffset ; } } get a page worth of resources for ( int i = _NUM ; i < pageSize & & iterator . hasNext ( ) ; + + i ) { pageResources . add ( _NUM , iterator . next ( ) ) ; - - currentOffset ; } return new PageResponseImpl ( pageResources , currentOffset + _NUM , iterator . hasNext ( ) ? iterator . next ( ) : null , next , filteredResources . size ( ) ) ; } 
3775	public static XmlBoolean parse ( javax . xml . stream . XMLStreamReader xsr ) throws org . apache . xmlbeans . XmlException { return ( XmlBoolean ) XmlBeans . getContextTypeLoader ( ) . parse ( xsr , type , null ) ; } 
3776	public Expression expression ( ) throws SQLSyntaxErrorException { MySQLToken token = lexer . token ( ) ; if ( token = = null ) { token = lexer . nextToken ( ) ; } if ( token = = EOF ) { err ( _STR ) ; } Expression left = logicalOrExpression ( ) ; if ( lexer . token ( ) = = OP _ ASSIGN ) { lexer . nextToken ( ) ; Expression right = expression ( ) ; return new AssignmentExpression ( left , right ) . setCacheEvalRst ( cacheEvalRst ) ; } return left ; } 
3777	private void resolveShouldLayoutReverse ( ) { A = = B is the same result , but we rather keep it readable if ( mOrientation = = VERTICAL | | ! isLayoutRTL ( ) ) { mShouldReverseLayout = mReverseLayout ; } else { mShouldReverseLayout = ! mReverseLayout ; } } 
3778	public void testAuthorizedLogUserAllowClusterLogsUser ( ) { Map < String , Object > stormConf = Utils . readStormConfig ( ) ; Map < String , Object > conf = new HashMap < > ( stormConf ) ; conf . put ( LOGS _ USERS , Collections . singletonList ( _STR ) ) ; verifyStubMethodsAreCalledProperly ( authorizer ) ; } 
3779	public void setParameter ( String expr , Object value ) { setValue ( expr , value , devMode ) ; } 
3780	public static DatasetGraph dynamicDataset ( Collection < Node > defaultGraphs , Collection < Node > namedGraphs , DatasetGraph dsg , boolean defaultUnionGraph ) { Graph dft = new GraphUnionRead ( dsg , defaultGraphs ) ; DatasetGraph dsg _NUM = new DatasetGraphMapLink ( dft ) ; The named graphs . for ( Node gn : namedGraphs ) { Graph g = GraphOps . getGraph ( dsg , gn ) ; if ( g ! = null ) dsg _NUM . addGraph ( gn , g ) ; } if ( dsg . getContext ( ) ! = null ) dsg _NUM . getContext ( ) . putAll ( dsg . getContext ( ) ) ; if ( defaultUnionGraph & & defaultGraphs . size ( ) = = _NUM ) { Create a union graph - there were no defaultGraphs explicitly named . Graph unionGraph = new GraphUnionRead ( dsg , namedGraphs ) ; dsg _NUM . setDefaultGraph ( unionGraph ) ; } read - only , < urn : x - arq : DefaultGraph > and < urn : x - arq : UnionGraph > processing . dsg _NUM = new DynamicDatasetGraph ( dsg _NUM ) ; Record what we ' ve done . c . f . _STR which is used to pass in a DatasetDescription dsg _NUM . getContext ( ) . set ( ARQConstants . symDatasetDefaultGraphs , defaultGraphs ) ; dsg _NUM . getContext ( ) . set ( ARQConstants . symDatasetNamedGraphs , namedGraphs ) ; return dsg _NUM ; } 
3781	protected final void moveToNextIndex ( ) { _NUM opcodes . . . if ( ( _ index = nextIndex ( ) ) < _NUM ) { throw new NoSuchElementException ( ) ; } } 
3782	public List < TabletStats > getOnlineTabletsForTable ( TServerInstance tserver , Table . ID tableId ) throws ThriftSecurityException , TException { return generateFakeTablets ( tserver , tableId ) ; } 
3783	public void write ( KEYOUT key , VALUEOUT value , String baseOutputPath ) throws IOException , InterruptedException { checkBaseOutputPath ( baseOutputPath ) ; if ( jobOutputFormatContext = = null ) { jobOutputFormatContext = new TaskAttemptContextImpl ( context . getConfiguration ( ) , context . getTaskAttemptID ( ) , new WrappedStatusReporter ( context ) ) ; } getRecordWriter ( jobOutputFormatContext , baseOutputPath ) . write ( key , value ) ; } 
3784	public static BucketStat parseGetBucketStat ( InputStream responseBody ) throws ResponseParseException { try { Element root = getXmlRootElement ( responseBody ) ; Long storage = Long . parseLong ( root . getChildText ( _STR + e . getMessage ( ) , e ) ; } catch ( Exception e ) { throw new ResponseParseException ( e . getMessage ( ) , e ) ; } } 
3785	public boolean bodyCall ( Node [ ] args , int length , RuleContext context ) { checkArgs ( length , context ) ; Node arg = getArg ( _NUM , args , context ) ; if ( arg . isLiteral ( ) ) { if ( Functor . isFunctor ( arg ) ) { functors are indeterminate , can represent literals or objects return false ; } else { return true ; } } return false ; } 
3786	private void testReprocessTimestamps ( String cameraId , Size inputSize , int inputFormat , Size reprocessOutputSize , int reprocessOutputFormat ) throws Exception { if ( VERBOSE ) { Log . v ( TAG , _STR , expected , timestamp ) ; } Make sure all input surfaces are released . for ( int i = _NUM ; i < NUM _ REPROCESS _ CAPTURES ; i + + ) { mImageWriterListener . waitForImageReleased ( CAPTURE _ TIMEOUT _ MS ) ; } } finally { closeReprossibleSession ( ) ; closeImageReaders ( ) ; } } 
3787	public static void positionFrameOnScreen ( final Window frame , final double horizontalPercent , final double verticalPercent ) { final Rectangle s = frame . getGraphicsConfiguration ( ) . getBounds ( ) ; final Dimension f = frame . getSize ( ) ; final int w = Math . max ( s . width - f . width , _NUM ) ; final int h = Math . max ( s . height - f . height , _NUM ) ; final int x = ( int ) ( horizontalPercent * w ) + s . x ; final int y = ( int ) ( verticalPercent * h ) + s . y ; frame . setBounds ( x , y , f . width , f . height ) ; } 
3788	public T getOptionalItemByIndex ( int index ) { if ( index = = - _NUM ) { return null ; } return getItemByIndex ( index ) ; } 
3789	public void setAutoPopulateSectionOutlinePaint ( boolean auto ) { this . autoPopulateSectionOutlinePaint = auto ; fireChangeEvent ( ) ; } 
3790	public static Iterator < Object > createIterator ( Object value , String delimiter , boolean allowEmptyValues ) { return createIterable ( value , delimiter , allowEmptyValues , false ) . iterator ( ) ; } 
3791	public Map < String , Map < String , String > > getPropertySearch ( ) { return getReadPropertiesSearch ( ) ; } 
3792	private Resource . Type getRequestType ( Map < String , Object > properties ) throws AmbariException { Set < String > requestFKs = getRequestForeignKeys ( properties ) . keySet ( ) ; for ( TypeRegistration registration : typeRegistrations . values ( ) ) { Collection < String > typeFKs = new HashSet < > ( registration . getForeignKeyInfo ( ) . values ( ) ) ; typeFKs . add ( registration . getFKPropertyName ( ) ) ; if ( requestFKs . equals ( typeFKs ) ) { return registration . getType ( ) ; } } throw new AmbariException ( _STR ) ; } 
3793	public CTMarker getFrom ( ) { return getCell _NUM ( ) ; } 
3794	protected AuroraController getController ( ) throws ClassNotFoundException , InstantiationException , IllegalAccessException { Boolean cliController = config . getBooleanValue ( Key . AURORA _ CONTROLLER _ CLASS ) ; Config localConfig = Config . toLocalMode ( this . config ) ; if ( cliController ) { return new AuroraCLIController ( Runtime . topologyName ( runtime ) , Context . cluster ( localConfig ) , Context . role ( localConfig ) , Context . environ ( localConfig ) , AuroraContext . getHeronAuroraPath ( localConfig ) , Context . verbose ( localConfig ) ) ; } else { return new AuroraHeronShellController ( Runtime . topologyName ( runtime ) , Context . cluster ( localConfig ) , Context . role ( localConfig ) , Context . environ ( localConfig ) , AuroraContext . getHeronAuroraPath ( localConfig ) , Context . verbose ( localConfig ) , localConfig ) ; } } 
3795	public static double toDouble ( Object obj ) { Double result = toDoubleObject ( obj ) ; return result = = null ? _NUM . _NUM : result . doubleValue ( ) ; } 
3796	public int line ( ) { if ( line = = _NUM ) lineCol ( ) ; return line ; } 
3797	public synchronized long getCurrentAverage ( ) { cleanupOldPoints ( ) ; if ( currentPoints . isEmpty ( ) ) { return _NUM ; } long sum = _NUM ; for ( DataPoint current : currentPoints ) { sum + = current . getValue ( ) ; } return sum / currentPoints . size ( ) ; } 
3798	public static byte [ ] getEncryptedSymmetricKey ( SecretKey toBeEncrypted , EncryptionMaterials materials , Provider cryptoProvider ) { Key keyToDoEncryption ; if ( materials . getKeyPair ( ) ! = null ) { Do envelope encryption with public key from key pair keyToDoEncryption = materials . getKeyPair ( ) . getPublic ( ) ; } else { Do envelope encryption with symmetric key keyToDoEncryption = materials . getSymmetricKey ( ) ; } try { Cipher cipher ; byte [ ] toBeEncryptedBytes = toBeEncrypted . getEncoded ( ) ; if ( cryptoProvider ! = null ) { cipher = Cipher . getInstance ( keyToDoEncryption . getAlgorithm ( ) , cryptoProvider ) ; } else { Use cipher = Cipher . getInstance ( keyToDoEncryption . getAlgorithm ( ) ) ; default JCE Provider } cipher . init ( Cipher . ENCRYPT _ MODE , keyToDoEncryption ) ; return cipher . doFinal ( toBeEncryptedBytes ) ; } catch ( Exception e ) { throw new AmazonClientException ( _STR + e . getMessage ( ) , e ) ; } } 
3799	public Iterator < Quad > findQuadsInUnionGraph ( Node s , Node p , Node o ) { return findUnionGraphTriples ( s , p , o ) . map ( t - > new Quad ( Quad . unionGraph , t ) ) . iterator ( ) ; } 
3800	public static File getCacheDirectory ( Context context , boolean preferExternal ) { File appCacheDir = null ; if ( preferExternal & & MEDIA _ MOUNTED . equals ( Environment . getExternalStorageState ( ) ) & & hasExternalStoragePermission ( context ) & & haveFreeSpace ( ) ) { appCacheDir = getExternalCacheDir ( context ) ; } if ( appCacheDir = = null ) { appCacheDir = context . getCacheDir ( ) ; } if ( appCacheDir = = null ) { String cacheDirPath = _STR ; appCacheDir = new File ( cacheDirPath ) ; } return appCacheDir ; } 
3801	public void setScrollY ( int scrollY ) { enforceNotSealed ( ) ; mScrollY = scrollY ; } 
3802	private ReplacingBasicValue getFunctionReturn ( ) { final Frame < BasicValue > nextFrame = list . nextFrame ; final BasicValue basicValue = nextFrame . getStack ( nextFrame . getStackSize ( ) - _NUM ) ; return filterReplacement ( basicValue ) ; } 
3803	public static CharsetEncoder getThreadEncoder ( ) { return threadCharsetEncoder . get ( ) ; } 
3804	public CompletableFuture < ResultSet > submitAsync ( final String gremlin , final String graphOrTraversalSource , final Map < String , Object > parameters ) { final RequestMessage . Builder request = RequestMessage . build ( Tokens . OPS _ EVAL ) . add ( Tokens . ARGS _ GREMLIN , gremlin ) . add ( Tokens . ARGS _ BATCH _ SIZE , cluster . connectionPoolSettings ( ) . resultIterationBatchSize ) ; Optional . ofNullable ( parameters ) . ifPresent ( params - > request . addArg ( Tokens . ARGS _ BINDINGS , parameters ) ) ; if ( graphOrTraversalSource ! = null & & ! graphOrTraversalSource . isEmpty ( ) ) request . addArg ( Tokens . ARGS _ ALIASES , makeDefaultAliasMap ( graphOrTraversalSource ) ) ; return submitAsync ( buildMessage ( request ) . create ( ) ) ; } 
3805	private void assertMutatesEquivalent ( List < Mutation > mutations , InMemoryMap imm _NUM , InMemoryMap imm _NUM ) { int mutationKVPairs = countKVPairs ( mutations ) ; List < MemKey > memKeys _NUM = getArrayOfMemKeys ( imm _NUM ) ; List < MemKey > memKeys _NUM = getArrayOfMemKeys ( imm _NUM ) ; assertEquals ( _STR + dumpInMemoryMap ( imm _NUM , memKeys _NUM ) , mutationKVPairs , getUniqKVCount ( memKeys _NUM ) ) ; } 
3806	public void open ( ) throws IOException , InterpreterException { createRScript ( ) ; zeppelinR . put ( hashCode ( ) , this ) ; CommandLine cmd = CommandLine . parse ( rCmdPath ) ; cmd . addArgument ( _STR ) ; } 
3807	public int getUidAllowingUnknown ( String user ) { checkAndUpdateMaps ( ) ; int uid ; try { uid = getUid ( user ) ; } catch ( IOException e ) { uid = user . hashCode ( ) ; LOG . info ( _STR + uid ) ; } return uid ; } 
3808	public final void setResultExtras ( Bundle extras ) { checkSynchronousHint ( ) ; mPendingResult . mResultExtras = extras ; } 
3809	public CStringBuilder append ( Object obj ) { if ( obj = = null ) { appendNull ( ) ; } else { append _NUM ( obj . toString ( ) ) ; } return this ; } 
3810	protected void checkDelete ( ) throws DeleteDeniedException , AuthenticationRequiredException { if ( ! canDelete ( ) ) { throw new DeleteDeniedException ( SecuredItem . Util . modelPermissionMsg ( modelNode ) ) ; } } 
3811	private static SignatureInfo findSignature ( RandomAccessFile apk ) throws IOException , SignatureNotFoundException { Find the ZIP End of Central Directory ( EoCD ) record . Pair < ByteBuffer , Long > eocdAndOffsetInFile = getEocd ( apk ) ; ByteBuffer eocd = eocdAndOffsetInFile . first ; long eocdOffset = eocdAndOffsetInFile . second ; if ( ZipUtils . isZip _NUM _NUM EndOfCentralDirectoryLocatorPresent ( apk , eocdOffset ) ) { throw new SignatureNotFoundException ( _STR ) ; } Find the APK Signing Block . The block immediately precedes the Central Directory . long centralDirOffset = getCentralDirOffset ( eocd , eocdOffset ) ; Pair < ByteBuffer , Long > apkSigningBlockAndOffsetInFile = findApkSigningBlock ( apk , centralDirOffset ) ; ByteBuffer apkSigningBlock = apkSigningBlockAndOffsetInFile . first ; long apkSigningBlockOffset = apkSigningBlockAndOffsetInFile . second ; Find the APK Signature Scheme v _NUM Block inside the APK Signing Block . ByteBuffer apkSignatureSchemeV _NUM Block = findApkSignatureSchemeV _NUM Block ( apkSigningBlock ) ; return new SignatureInfo ( apkSignatureSchemeV _NUM Block , apkSigningBlockOffset , centralDirOffset , eocdOffset , eocd ) ; } 
3812	public void loadSnapshotSection ( InputStream in ) throws IOException { SnapshotManager sm = fsn . getSnapshotManager ( ) ; SnapshotSection section = SnapshotSection . parseDelimitedFrom ( in ) ; int snum = section . getNumSnapshots ( ) ; sm . setNumSnapshots ( snum ) ; sm . setSnapshotCounter ( section . getSnapshotCounter ( ) ) ; for ( long sdirId : section . getSnapshottableDirList ( ) ) { INodeDirectory dir = fsDir . getInode ( sdirId ) . asDirectory ( ) ; if ( ! dir . isSnapshottable ( ) ) { dir . addSnapshottableFeature ( ) ; } else { dir is root , and admin set root to snapshottable before dir . setSnapshotQuota ( DirectorySnapshottableFeature . SNAPSHOT _ LIMIT ) ; } sm . addSnapshottable ( dir ) ; } loadSnapshots ( in , snum ) ; } 
3813	public void invalidateViews ( ) { mDataChanged = true ; rememberSyncState ( ) ; requestLayout ( ) ; invalidate ( ) ; } 
3814	public void clear ( ) { if ( m _ flexRequestList ! = null ) { m _ flexRequestList . clear ( ) ; } m _ flexRequestList = null ; if ( m _ flexResponseList ! = null ) { m _ flexResponseList . clear ( ) ; } m _ flexResponseList = null ; if ( m _ req ! = null ) { m _ req . removeAttribute ( ATTRIBUTE _ NAME ) ; } m _ req = null ; m _ res = null ; m _ cmsObject = null ; m _ resource = null ; m _ cache = null ; m _ throwable = null ; } 
3815	public synchronized boolean updateLogComment ( UUID dataId , UUID templateId , int dataIndex , String logActionComment ) throws IOException , SQLException { Connection conn = null ; PreparedStatement pstmt = null ; if ( templateId = = null | | dataId = = null ) { return false ; } try { conn = DbPoolConnection . getInstance ( ) . getConnection ( ) ; String logTableName = TableRuleManager . getInstance ( ) . getDataLogTableName ( templateId ) ; pstmt = conn . prepareStatement ( _STR , e ) ; return false ; } finally { DbPoolConnection . getInstance ( ) . closeAll ( pstmt , conn ) ; } } 
3816	public int writeNum ( final int v ) throws IOException { if ( v < _NUM | | v > _NUM x _NUM FFFFFFF ) { write ( _NUM xC _NUM ) ; write ( v > > > _NUM _NUM ) ; write ( v > > > _NUM _NUM ) ; write ( v > > > _NUM ) ; write ( v ) ; return _NUM ; } if ( v > _NUM x _NUM FFF ) { write ( v > > > _NUM _NUM | _NUM x _NUM _NUM ) ; write ( v > > > _NUM _NUM ) ; write ( v > > > _NUM ) ; write ( v ) ; return _NUM ; } if ( v > _NUM x _NUM F ) { write ( v > > > _NUM | _NUM x _NUM _NUM ) ; write ( v ) ; return _NUM ; } write ( v ) ; return _NUM ; } 
3817	public void startBatch ( ) { this . recordStart = characterDataOriginal ; this . fieldOpen = false ; this . batchIndex = _NUM ; this . fieldIndex = - _NUM ; this . collect = true ; loadRepeatedOffsetAddress ( ) ; loadVarCharOffsetAddress ( ) ; loadVarCharDataAddress ( ) ; } 
3818	public UnfilteredRowIterator queryMemtableAndDisk ( ColumnFamilyStore cfs , ReadExecutionController executionController ) { assert executionController ! = null & & executionController . validForReadOn ( cfs ) ; Tracing . trace ( _STR , cfs . name ) ; return queryMemtableAndDiskInternal ( cfs ) ; } 
3819	public int getNumResultsets ( ) { if ( ! m _ ResultsetsValid ) { try { prepareData ( ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; return _NUM ; } } return m _ Resultsets . size ( ) ; } 
3820	private void manageChangeListener ( ) { final boolean needsListener = isAttachedToWindow ( ) & & getVisibility ( ) = = View . VISIBLE ; if ( mHasChangeListener ! = needsListener ) { mHasChangeListener = needsListener ; if ( needsListener ) { mManager . addCaptioningChangeListener ( mCaptioningListener ) ; final CaptionStyle captionStyle = mManager . getUserStyle ( ) ; final float fontSize = mManager . getFontScale ( ) * getHeight ( ) * LINE _ HEIGHT _ RATIO ; setCaptionStyle ( captionStyle , fontSize ) ; } else { mManager . removeCaptioningChangeListener ( mCaptioningListener ) ; } } } 
3821	protected List < FileStatus > listStatus ( JobContext job ) throws IOException { Path [ ] dirs = getInputPaths ( job ) ; if ( dirs . length = = _NUM ) { throw new IOException ( _STR + result . size ( ) ) ; return result ; } 
3822	public void testCreateSCTKeySize ( ) throws Exception { TokenProvider sctTokenProvider = new SCTProvider ( ) ; TokenProviderParameters providerParameters = createProviderParameters ( STSUtils . TOKEN _ TYPE _ SCT _ _NUM _NUM _ _NUM _NUM ) ; assertTrue ( sctTokenProvider . canHandleToken ( STSUtils . TOKEN _ TYPE _ SCT _ _NUM _NUM _ _NUM _NUM ) ) ; TokenProviderResponse providerResponse = sctTokenProvider . createToken ( providerParameters ) ; assertTrue ( providerResponse ! = null ) ; assertTrue ( providerResponse . getToken ( ) ! = null & & providerResponse . getTokenId ( ) ! = null ) ; assertTrue ( _NUM _NUM _NUM L = = providerResponse . getKeySize ( ) ) ; Test a custom KeySize KeyRequirements keyRequirements = providerParameters . getKeyRequirements ( ) ; keyRequirements . setKeySize ( _NUM _NUM _NUM ) ; providerResponse = sctTokenProvider . createToken ( providerParameters ) ; assertTrue ( providerResponse ! = null ) ; assertTrue ( _NUM _NUM _NUM L = = providerResponse . getKeySize ( ) ) ; Test a bad KeySize - it will just use the default keysize keyRequirements . setKeySize ( _NUM _NUM ) ; providerResponse = sctTokenProvider . createToken ( providerParameters ) ; assertTrue ( _NUM _NUM _NUM L = = providerResponse . getKeySize ( ) ) ; } 
3823	public boolean maybeIsEmpty ( ) { if ( isParcelled ( ) ) { return isEmptyParcel ( ) ; } else { return isEmpty ( ) ; } } 
3824	public void doSaveAs ( ) { saveDiagramAs ( ) ; } 
3825	public < B > T body ( final Class < B > type , final Predicate < B > predicate ) { return exchange ( e - > predicate . test ( e . getIn ( ) . getBody ( type ) ) ) ; } 
3826	public synchronized List < FinalizedReplica > getFinalizedBlocksOnPersistentStorage ( String bpid ) { ArrayList < FinalizedReplica > finalized = new ArrayList < FinalizedReplica > ( volumeMap . size ( bpid ) ) ; for ( ReplicaInfo b : volumeMap . replicas ( bpid ) ) { if ( ! b . getVolume ( ) . isTransientStorage ( ) & & b . getState ( ) = = ReplicaState . FINALIZED ) { finalized . add ( new FinalizedReplica ( ( FinalizedReplica ) b ) ) ; } } return finalized ; } 
3827	public static boolean areWorkerTokensEnabledServer ( ThriftServer server , Map < String , Object > conf ) { return server . supportsWorkerTokens ( ) & & willWorkerTokensBeStoredSecurely ( conf ) ; } 
3828	public void setHeight ( int height ) { if ( height < = _NUM ) { m _ containerElement . getStyle ( ) . clearWidth ( ) ; } else { int contentHeight = height ; if ( hasCaption ( ) ) { contentHeight = contentHeight - _NUM _NUM ; } if ( hasButtons ( ) ) { contentHeight = contentHeight - _NUM _NUM ; } contentHeight = contentHeight - m _ contentHeightCorrection ; m _ containerElement . getStyle ( ) . setProperty ( _STR , contentHeight + Unit . PX . toString ( ) ) ; } } 
3829	public void setMarked ( Boolean marked ) { BooleanType tt = ( BooleanType ) instanciateSimple ( MARKED , marked ? BooleanType . TRUE : BooleanType . FALSE ) ; setMarkedProperty ( tt ) ; } 
3830	public static XmlDecimal parse ( javax . xml . stream . XMLStreamReader xsr , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException { return ( XmlDecimal ) XmlBeans . getContextTypeLoader ( ) . parse ( xsr , type , options ) ; } 
3831	public static < K , V extends Number > Map < String , Object > aggPreMergeTopoPageSpout ( Map < String , Object > m , String window , boolean includeSys ) { Map < String , Object > ret = new HashMap < > ( ) ; Map < String , Object > subRet = new HashMap < > ( ) ; putKV ( subRet , NUM _ EXECUTORS , _NUM ) ; putKV ( subRet , NUM _ TASKS , getByKey ( m , NUM _ TASKS ) ) ; no capacity for spout Map < String , Map < String , Map < String , V > > > stat _NUM win _NUM sid _NUM num = getMapByKey ( m , STATS ) ; for ( String key : new String [ ] { EMITTED , TRANSFERRED , FAILED } ) { Map < String , Map < K , V > > stat = windowSetConverter ( stat _NUM win _NUM sid _NUM num . get ( key ) , TO _ STRING ) ; if ( EMITTED . equals ( key ) | | TRANSFERRED . equals ( key ) ) { stat = filterSysStreams ( stat , includeSys ) ; } Map < K , V > winStat = stat . get ( window ) ; long sum = _NUM ; if ( winStat ! = null ) { for ( V v : winStat . values ( ) ) { sum + = v . longValue ( ) ; } } putKV ( subRet , key , sum ) ; } Map < String , Map < String , Double > > win _NUM sid _NUM compLat = windowSetConverter ( getMapByKey ( stat _NUM win _NUM sid _NUM num , COMP _ LATENCIES ) , TO _ STRING ) ; Map < String , Map < String , Long > > win _NUM sid _NUM acked = windowSetConverter ( getMapByKey ( stat _NUM win _NUM sid _NUM num , ACKED ) , TO _ STRING ) ; subRet . putAll ( aggSpoutLatAndCount ( win _NUM sid _NUM compLat . get ( window ) , win _NUM sid _NUM acked . get ( window ) ) ) ; ret . put ( ( String ) getByKey ( m , _STR ) , subRet ) ; return ret ; } 
3832	public String readPasswordFromFile ( String filePath , String defaultPassword ) { if ( StringUtils . isBlank ( filePath ) | | ! fileExistsAndCanBeRead ( filePath ) ) { LOG . debug ( _STR , e ) ; } } } 
3833	public static boolean isSameLength ( final Object [ ] array _NUM , final Object [ ] array _NUM ) { return getLength ( array _NUM ) = = getLength ( array _NUM ) ; } 
3834	private static BigInteger extEuclid ( BigInteger a , BigInteger b , BigInteger u _NUM Out , BigInteger u _NUM Out ) { BigInteger u _NUM = BigInteger . ONE ; BigInteger u _NUM = a ; BigInteger v _NUM = BigInteger . ZERO ; BigInteger v _NUM = b ; while ( v _NUM . sign > _NUM ) { BigInteger [ ] q = u _NUM . divideAndRemainder ( v _NUM ) ; BigInteger tn = u _NUM . subtract ( v _NUM . multiply ( q [ _NUM ] ) ) ; u _NUM = v _NUM ; v _NUM = tn ; u _NUM = v _NUM ; v _NUM = q [ _NUM ] ; } if ( u _NUM Out ! = null ) { u _NUM Out . sign = u _NUM . sign ; u _NUM Out . magnitude = u _NUM . magnitude ; } if ( u _NUM Out ! = null ) { BigInteger res = u _NUM . subtract ( u _NUM . multiply ( a ) ) . divide ( b ) ; u _NUM Out . sign = res . sign ; u _NUM Out . magnitude = res . magnitude ; } return u _NUM ; } 
3835	public Map < String , T > getNames ( ) throws IOException { COSArray namesArray = ( COSArray ) node . getDictionaryObject ( COSName . NAMES ) ; if ( namesArray ! = null ) { Map < String , T > names = new LinkedHashMap < > ( ) ; for ( int i = _NUM ; i < namesArray . size ( ) ; i + = _NUM ) { COSString key = ( COSString ) namesArray . getObject ( i ) ; COSBase cosValue = namesArray . getObject ( i + _NUM ) ; names . put ( key . getString ( ) , convertCOSToPD ( cosValue ) ) ; } return Collections . unmodifiableMap ( names ) ; } else { return null ; } } 
3836	public static IDevice findDevice ( String serial , int timeout ) { WaitForDevice wfd = new WaitForDevice ( serial , timeout ) ; return wfd . get ( ) ; } 
3837	public EvaluationName getName ( String name , int sheetIndex ) { for ( int i = _NUM ; i < _ uBook . getNumberOfNames ( ) ; i + + ) { XSSFName nm = _ uBook . getNameAt ( i ) ; String nameText = nm . getNameName ( ) ; int nameSheetindex = nm . getSheetIndex ( ) ; if ( name . equalsIgnoreCase ( nameText ) & & ( nameSheetindex = = - _NUM | | nameSheetindex = = sheetIndex ) ) { return new Name ( nm , i , this ) ; } } return sheetIndex = = - _NUM ? null : getName ( name , - _NUM ) ; } 
3838	public static Fragment instantiate ( Context context , String fname , @ Nullable Bundle args ) { try { Class < ? > clazz = sClassMap . get ( fname ) ; if ( clazz = = null ) { Class not found in the cache , see if it ' s real , and try to add it clazz = context . getClassLoader ( ) . loadClass ( fname ) ; sClassMap . put ( fname , clazz ) ; } Fragment f = ( Fragment ) clazz . getConstructor ( ) . newInstance ( ) ; if ( args ! = null ) { args . setClassLoader ( f . getClass ( ) . getClassLoader ( ) ) ; f . setArguments ( args ) ; } return f ; } catch ( ClassNotFoundException e ) { throw new InstantiationException ( _STR , e ) ; } } 
3839	public synchronized Object executeTask ( Task t ) throws RemoteException { String taskId = _STR ; taskId + = t . hashCode ( ) ; addTaskToQueue ( t , taskId ) ; return taskId ; return t . execute ( ) ; } 
3840	 @ Deployment ( resources = { _STR ) ; List < ActivitiEvent > processCancelledEvents = listener . filterEvents ( ActivitiEventType . PROCESS _ CANCELLED ) ; assertEquals ( _NUM , processCancelledEvents . size ( ) ) ; ActivitiCancelledEvent cancelledEvent = ( ActivitiCancelledEvent ) processCancelledEvents . get ( _NUM ) ; assertEquals ( ActivitiEventType . PROCESS _ CANCELLED , cancelledEvent . getType ( ) ) ; assertEquals ( processInstance . getId ( ) , cancelledEvent . getProcessInstanceId ( ) ) ; assertEquals ( processInstance . getId ( ) , cancelledEvent . getExecutionId ( ) ) ; listener . clearEventsReceived ( ) ; } 
3841	public float incrementByAmount ( T key , float amount ) { if ( key = = null ) { throw new IllegalArgumentException ( _STR ) ; } if ( keyCount + removeCount = = threshold ) { expand ( ) ; } int l = locate ( key ) ; if ( l < _NUM ) { l = - l - _NUM ; values [ l ] = amount ; keys [ l ] = key ; keyCount + + ; return values [ l ] ; } else { values [ l ] + = amount ; return values [ l ] ; } } 
3842	public void write ( NPOIFSStream stream ) throws IOException { OutputStream os = stream . getOutputStream ( ) ; for ( Property property : _ properties ) { if ( property ! = null ) { property . writeData ( os ) ; } } os . close ( ) ; Update the start position if needed if ( getStartBlock ( ) ! = stream . getStartBlock ( ) ) { setStartBlock ( stream . getStartBlock ( ) ) ; } } 
3843	private void startTransaction ( TxnType txnType , ReadWrite mode ) { get the dataset write lock , if needed . transactionLock . enterCriticalSection ( mode . equals ( ReadWrite . READ ) ) ; transactionType . set ( txnType ) ; transactionMode ( mode ) ; isInTransaction ( true ) ; } 
3844	private Integer findConfigedPorts ( ProtocolConfig protocolConfig , String name , Map < String , String > map ) { Integer portToBind = null ; parse bind port from environment String port = getValueFromConfig ( protocolConfig , Constants . DUBBO _ PORT _ TO _ BIND ) ; portToBind = parsePort ( port ) ; if there ' s no bind port found from environment , keep looking up . if ( portToBind = = null ) { portToBind = protocolConfig . getPort ( ) ; if ( provider ! = null & & ( portToBind = = null | | portToBind = = _NUM ) ) { portToBind = provider . getPort ( ) ; } final int defaultPort = ExtensionLoader . getExtensionLoader ( Protocol . class ) . getExtension ( name ) . getDefaultPort ( ) ; if ( portToBind = = null | | portToBind = = _NUM ) { portToBind = defaultPort ; } if ( portToBind = = null | | portToBind < = _NUM ) { portToBind = getRandomPort ( name ) ; if ( portToBind = = null | | portToBind < _NUM ) { portToBind = getAvailablePort ( defaultPort ) ; putRandomPort ( name , portToBind ) ; } logger . warn ( _STR + name ) ; } } save bind port , used as url ' s key later map . put ( Constants . BIND _ PORT _ KEY , String . valueOf ( portToBind ) ) ; registry port , not used as bind port by default String portToRegistryStr = getValueFromConfig ( protocolConfig , Constants . DUBBO _ PORT _ TO _ REGISTRY ) ; Integer portToRegistry = parsePort ( portToRegistryStr ) ; if ( portToRegistry = = null ) { portToRegistry = portToBind ; } return portToRegistry ; } 
3845	public void exit ( ) { cancel ( ) ; final float radius = lerp ( _NUM , mOuterRadius , mTweenRadius ) ; final float remaining ; if ( mAnimRadius ! = null & & mAnimRadius . isRunning ( ) ) { remaining = mOuterRadius - radius ; } else { remaining = mOuterRadius ; } final int radiusDuration = ( int ) ( _NUM _NUM _NUM _NUM * Math . sqrt ( remaining / ( WAVE _ TOUCH _ UP _ ACCELERATION + WAVE _ TOUCH _ DOWN _ ACCELERATION ) * mDensity ) + _NUM . _NUM ) ; final int opacityDuration = ( int ) ( _NUM _NUM _NUM _NUM * mOpacity / WAVE _ OPACITY _ DECAY _ VELOCITY + _NUM . _NUM f ) ; exitSoftware ( radiusDuration , opacityDuration ) ; } 
3846	private < W extends BoundedWindow > PCollection < ? > applyForSingletonFallback ( PCollection < KV < K , V > > input ) { @ SuppressWarnings ( _STR } ) Coder < Function < WindowedValue < V > , V > > transformCoder = ( Coder ) SerializableCoder . of ( WindowedValueToValue . class ) ; Coder < TransformedMap < K , WindowedValue < V > , V > > finalValueCoder = TransformedMapCoder . of ( transformCoder , MapCoder . of ( inputCoder . getKeyCoder ( ) , FullWindowedValueCoder . of ( inputCoder . getValueCoder ( ) , windowCoder ) ) ) ; return BatchViewAsSingleton . applyForSingleton ( runner , input , new ToMapDoFn < > ( windowCoder ) , finalValueCoder , view ) ; } 
3847	private void ensureCachedScrollSelectorValue ( int selectorIndex ) { SparseArray < String > cache = mSelectorIndexToStringCache ; String scrollSelectorValue = cache . get ( selectorIndex ) ; if ( scrollSelectorValue ! = null ) { return ; } if ( selectorIndex < mMinValue | | selectorIndex > mMaxValue ) { scrollSelectorValue = _STR ; } else { if ( mDisplayedValues ! = null ) { int displayedValueIndex = selectorIndex - mMinValue ; scrollSelectorValue = mDisplayedValues [ displayedValueIndex ] ; } else { scrollSelectorValue = formatNumber ( selectorIndex ) ; } } cache . put ( selectorIndex , scrollSelectorValue ) ; } 
3848	public static List < String > readLines ( final InputStream input , final Charset encoding ) throws IOException { final InputStreamReader reader = new InputStreamReader ( input , Charsets . toCharset ( encoding ) ) ; return readLines ( reader ) ; } 
3849	public final synchronized Slot allocAndRegisterSlot ( ExtendedBlockId blockId ) { int idx = allocatedSlots . nextClearBit ( _NUM ) ; if ( idx > = slots . length ) { throw new RuntimeException ( this + _STR + allocatedSlots + StringUtils . getStackTrace ( Thread . currentThread ( ) ) ) ; } return slot ; } 
3850	public INDArray reconstruct ( INDArray x , int layerNum ) { List < INDArray > forward = feedForward ( x ) ; return forward . get ( layerNum - _NUM ) ; } 
3851	protected void startPreview ( CaptureRequest . Builder request , Size previewSz , CaptureCallback listener ) throws Exception { Update preview size . updatePreviewSurface ( previewSz ) ; if ( VERBOSE ) { Log . v ( TAG , _STR + mPreviewSize . toString ( ) ) ; } configurePreviewOutput ( request ) ; mSession . setRepeatingRequest ( request . build ( ) , listener , mHandler ) ; } 
3852	public void createEmptyDB ( SQLiteDatabase db ) { db . execSQL ( _STR + WorkspaceScreens . TABLE _ NAME ) ; onCreate ( db ) ; } 
3853	private List search ( String [ ] attributeNames , String attributeValue , String [ ] attrs ) throws StoreException { String filter = null ; if ( attributeNames = = null ) { filter = null ; } else { filter = _STR ; if ( filter = = null ) { filter _NUM = filter _NUM ; } List list ; list = getFromCache ( filter _NUM ) ; if ( list ! = null ) { return list ; } DirContext ctx = null ; list = new ArrayList ( ) ; try { ctx = connectLDAP ( ) ; SearchControls constraints = new SearchControls ( ) ; constraints . setSearchScope ( SearchControls . SUBTREE _ SCOPE ) ; constraints . setCountLimit ( _NUM ) ; constraints . setReturningAttributes ( attrs ) ; NamingEnumeration results = ctx . search ( params . getBaseDN ( ) , filter _NUM , constraints ) ; while ( results . hasMoreElements ( ) ) { SearchResult sr = ( SearchResult ) results . next ( ) ; NamingEnumeration enumeration = ( ( Attribute ) ( sr . getAttributes ( ) . getAll ( ) . next ( ) ) ) . getAll ( ) ; while ( enumeration . hasMore ( ) ) { list . add ( enumeration . next ( ) ) ; } } addToCache ( filter _NUM , list ) ; } catch ( NamingException e ) { skip exception , unfortunately if an attribute type is not supported an exception is thrown } finally { try { if ( null ! = ctx ) { ctx . close ( ) ; } } catch ( Exception e ) { } } return list ; } 
3854	private void setAttributes ( Map < String , String > specifiedAttributes ) { Map < String , Map < String , String > > attributes = new HashMap < > ( ) ; Map < String , String > supportsAttributes = new HashMap < > ( ) ; attributes . put ( Supports . KEYWORD , supportsAttributes ) ; for ( Map . Entry < String , String > entry : specifiedAttributes . entrySet ( ) ) { String attributeName = entry . getKey ( ) ; Supports s = Supports . attributeNameValueOf ( attributeName ) ; if ( s ! = null ) { supportsAttributes . put ( s . getPropertyName ( ) , Boolean . valueOf ( entry . getValue ( ) ) . toString ( ) ) ; } else { LOG . warn ( _STR , attributeName , entry . getValue ( ) ) ; } } this . attributes = attributes ; } 
3855	public void scrollTo ( int x , int y ) { if ( mScrollX ! = x | | mScrollY ! = y ) { int oldX = mScrollX ; int oldY = mScrollY ; mScrollX = x ; mScrollY = y ; invalidateParentCaches ( ) ; onScrollChanged ( mScrollX , mScrollY , oldX , oldY ) ; if ( ! awakenScrollBars ( ) ) { postInvalidateOnAnimation ( ) ; } } } 
3856	protected boolean handleScrollBarDragging ( MotionEvent event ) { if ( mScrollCache = = null ) { return false ; } final float x = event . getX ( ) ; final float y = event . getY ( ) ; final int action = event . getAction ( ) ; if ( ( mScrollCache . mScrollBarDraggingState = = ScrollabilityCache . NOT _ DRAGGING & & action ! = MotionEvent . ACTION _ DOWN ) | | ! event . isFromSource ( InputDevice . SOURCE _ MOUSE ) | | ! event . isButtonPressed ( MotionEvent . BUTTON _ PRIMARY ) ) { mScrollCache . mScrollBarDraggingState = ScrollabilityCache . NOT _ DRAGGING ; return false ; } switch ( action ) { case MotionEvent . ACTION _ MOVE : if ( mScrollCache . mScrollBarDraggingState = = ScrollabilityCache . NOT _ DRAGGING ) { return false ; } if ( mScrollCache . mScrollBarDraggingState = = ScrollabilityCache . DRAGGING _ VERTICAL _ SCROLL _ BAR ) { final Rect bounds = mScrollCache . mScrollBarBounds ; getVerticalScrollBarBounds ( bounds , null ) ; final int range = computeVerticalScrollRange ( ) ; final int offset = computeVerticalScrollOffset ( ) ; final int extent = computeVerticalScrollExtent ( ) ; final int thumbLength = ScrollBarUtils . getThumbLength ( bounds . height ( ) , bounds . width ( ) , extent , range ) ; final int thumbOffset = ScrollBarUtils . getThumbOffset ( bounds . height ( ) , thumbLength , extent , range , offset ) ; final float diff = y - mScrollCache . mScrollBarDraggingPos ; final float maxThumbOffset = bounds . height ( ) - thumbLength ; final float newThumbOffset = Math . min ( Math . max ( thumbOffset + diff , _NUM . _NUM f ) , maxThumbOffset ) ; final int height = getHeight ( ) ; if ( Math . round ( newThumbOffset ) ! = thumbOffset & & maxThumbOffset > _NUM & & height > _NUM & & extent > _NUM ) { final int newY = Math . round ( ( range - extent ) / ( ( float ) extent / height ) * ( newThumbOffset / maxThumbOffset ) ) ; if ( newY ! = getScrollY ( ) ) { mScrollCache . mScrollBarDraggingPos = y ; setScrollY ( newY ) ; } } return true ; } if ( mScrollCache . mScrollBarDraggingState = = ScrollabilityCache . DRAGGING _ HORIZONTAL _ SCROLL _ BAR ) { final Rect bounds = mScrollCache . mScrollBarBounds ; getHorizontalScrollBarBounds ( bounds , null ) ; final int range = computeHorizontalScrollRange ( ) ; final int offset = computeHorizontalScrollOffset ( ) ; final int extent = computeHorizontalScrollExtent ( ) ; final int thumbLength = ScrollBarUtils . getThumbLength ( bounds . width ( ) , bounds . height ( ) , extent , range ) ; final int thumbOffset = ScrollBarUtils . getThumbOffset ( bounds . width ( ) , thumbLength , extent , range , offset ) ; final float diff = x - mScrollCache . mScrollBarDraggingPos ; final float maxThumbOffset = bounds . width ( ) - thumbLength ; final float newThumbOffset = Math . min ( Math . max ( thumbOffset + diff , _NUM . _NUM f ) , maxThumbOffset ) ; final int width = getWidth ( ) ; if ( Math . round ( newThumbOffset ) ! = thumbOffset & & maxThumbOffset > _NUM & & width > _NUM & & extent > _NUM ) { final int newX = Math . round ( ( range - extent ) / ( ( float ) extent / width ) * ( newThumbOffset / maxThumbOffset ) ) ; if ( newX ! = getScrollX ( ) ) { mScrollCache . mScrollBarDraggingPos = x ; setScrollX ( newX ) ; } } return true ; } case MotionEvent . ACTION _ DOWN : if ( mScrollCache . state = = ScrollabilityCache . OFF ) { return false ; } if ( isOnVerticalScrollbarThumb ( x , y ) ) { mScrollCache . mScrollBarDraggingState = ScrollabilityCache . DRAGGING _ VERTICAL _ SCROLL _ BAR ; mScrollCache . mScrollBarDraggingPos = y ; return true ; } if ( isOnHorizontalScrollbarThumb ( x , y ) ) { mScrollCache . mScrollBarDraggingState = ScrollabilityCache . DRAGGING _ HORIZONTAL _ SCROLL _ BAR ; mScrollCache . mScrollBarDraggingPos = x ; return true ; } } mScrollCache . mScrollBarDraggingState = ScrollabilityCache . NOT _ DRAGGING ; return false ; } 
3857	public T acquire ( long time , TimeUnit unit ) { If either time or unit are null , the other should also be null . Preconditions . checkState ( ( time < = _NUM ) = = ( unit = = null ) ) ; long endTimeMs = _NUM ; if ( time > _NUM ) { endTimeMs = System . currentTimeMillis ( ) + unit . toMillis ( time ) ; } Try to take a resource without blocking T resource = mResources . poll ( ) ; if ( resource ! = null ) { return resource ; } if ( mCurrentCapacity . getAndIncrement ( ) < mMaxCapacity ) { If the resource pool is empty but capacity is not yet full , create a new resource . return createNewResource ( ) ; } mCurrentCapacity . decrementAndGet ( ) ; Otherwise , try to take a resource from the pool , blocking if none are available . try { mTakeLock . lockInterruptibly ( ) ; try { while ( true ) { resource = mResources . poll ( ) ; if ( resource ! = null ) { return resource ; } if ( time > _NUM ) { long currTimeMs = System . currentTimeMillis ( ) ; if ( currTimeMs > = endTimeMs ) { return null ; } if ( ! mNotEmpty . await ( endTimeMs - currTimeMs , TimeUnit . MILLISECONDS ) ) { return null ; } } else { mNotEmpty . await ( ) ; } } } finally { mTakeLock . unlock ( ) ; } } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } } 
3858	protected void updateTime ( ) { Put _STR in digits that was not entered by passing - _NUM Hide digit by passing - _NUM ( for highest hours digit only ) ; int hours _NUM = - _NUM ; int time = getEnteredTime ( ) ; If the user entered _NUM to _NUM or _NUM _NUM to _NUM _NUM , there is no need for a _NUM th digit ( _NUM _NUM hours mode ) if ( mInputPointer > - _NUM ) { Test to see if the highest digit is _NUM to _NUM for AM / PM or _NUM to _NUM for _NUM _NUM hours mode if ( mInputPointer > = _NUM ) { int digit = mInput [ mInputPointer ] ; if ( ( mIs _NUM _NUM HoursMode & & digit > = _NUM & & digit < = _NUM ) | | ( ! mIs _NUM _NUM HoursMode & & digit > = _NUM & & digit < = _NUM ) ) { hours _NUM = - _NUM ; } } mode if ( mInputPointer > _NUM & & mInputPointer < _NUM & & hours _NUM ! = - _NUM ) { int digits = mInput [ mInputPointer ] * _NUM _NUM + mInput [ mInputPointer - _NUM ] ; if ( ( mIs _NUM _NUM HoursMode & & digits > = _NUM _NUM & & digits < = _NUM _NUM ) | | ( ! mIs _NUM _NUM HoursMode & & digits > = _NUM _NUM & & digits < = _NUM _NUM ) ) { hours _NUM = - _NUM ; } } If we have a digit show it if ( mInputPointer = = _NUM ) { hours _NUM = mInput [ _NUM ] ; } } else { hours _NUM = - _NUM ; } int hours _NUM = ( mInputPointer < _NUM ) ? - _NUM : mInput [ _NUM ] ; int minutes _NUM = ( mInputPointer < _NUM ) ? - _NUM : mInput [ _NUM ] ; int minutes _NUM = ( mInputPointer < _NUM ) ? - _NUM : mInput [ _NUM ] ; mEnteredTime . setTime ( hours _NUM , hours _NUM , minutes _NUM , minutes _NUM ) ; } 
3859	public void add ( byte [ ] regionName , List < Action > actionList ) { List < Action > rsActions = actions . get ( regionName ) ; if ( rsActions = = null ) { rsActions = new ArrayList < > ( actionList . size ( ) ) ; actions . put ( regionName , rsActions ) ; } rsActions . addAll ( actionList ) ; } 
3860	public V get ( Object key ) { if ( key = = null ) { key = NULL _ OBJECT ; } int index = findIndex ( key , elementData ) ; if ( elementData [ index ] = = key ) { Object result = elementData [ index + _NUM ] ; return massageValue ( result ) ; } return null ; } 
3861	public void remove ( int which ) { int cursorPos = mListMapping . get ( which , which ) ; if ( ! mRemovedCursorPositions . contains ( cursorPos ) ) { mRemovedCursorPositions . add ( cursorPos ) ; } int newCount = getCount ( ) ; for ( int i = which ; i < newCount ; + + i ) { mListMapping . put ( i , mListMapping . get ( i + _NUM , i + _NUM ) ) ; } mListMapping . delete ( newCount ) ; cleanMapping ( ) ; notifyDataSetChanged ( ) ; } 
3862	public void onPackageRemovedLocked ( String packageName ) { boolean removedSomething = false ; final int settingCount = mSettings . size ( ) ; for ( int i = settingCount - _NUM ; i > = _NUM ; i - - ) { String name = mSettings . keyAt ( i ) ; Settings defined by us are never dropped . if ( Settings . System . PUBLIC _ SETTINGS . contains ( name ) | | Settings . System . PRIVATE _ SETTINGS . contains ( name ) ) { continue ; } Setting setting = mSettings . valueAt ( i ) ; if ( packageName . equals ( setting . packageName ) ) { mSettings . removeAt ( i ) ; removedSomething = true ; } } if ( removedSomething ) { scheduleWriteIfNeededLocked ( ) ; } } 
3863	public boolean blockUntilConnectedOrTimedOut ( ) throws InterruptedException { Preconditions . checkState ( started . get ( ) , _STR + localIsConnected ) ; return localIsConnected ; } 
3864	public float measureText ( char [ ] text , int index , int count ) { if ( text = = null ) { throw new IllegalArgumentException ( _STR ) ; } if ( ( index | count ) < _NUM | | index + count > text . length ) { throw new ArrayIndexOutOfBoundsException ( ) ; } if ( text . length = = _NUM | | count = = _NUM ) { return _NUM f ; } if ( ! mHasCompatScaling ) { return ( float ) Math . ceil ( nGetTextAdvances ( mNativePaint , mNativeTypeface , text , index , count , index , count , mBidiFlags , null , _NUM ) ) ; } final float oldSize = getTextSize ( ) ; setTextSize ( oldSize * mCompatScaling ) ; float w = nGetTextAdvances ( mNativePaint , mNativeTypeface , text , index , count , index , count , mBidiFlags , null , _NUM ) ; setTextSize ( oldSize ) ; return ( float ) Math . ceil ( w * mInvCompatScaling ) ; } 
3865	public String getColorString ( ) { StringBuffer result = new StringBuffer ( ) ; if ( m _ color = = Simapi . COLOR _ TRANSPARENT ) { result . append ( COLOR _ TRANSPARENT ) ; } else { if ( m _ color . getRed ( ) < _NUM _NUM ) { result . append ( ' _NUM ' ) ; } result . append ( Integer . toString ( m _ color . getRed ( ) , _NUM _NUM ) ) ; if ( m _ color . getGreen ( ) < _NUM _NUM ) { result . append ( ' _NUM ' ) ; } result . append ( Integer . toString ( m _ color . getGreen ( ) , _NUM _NUM ) ) ; if ( m _ color . getBlue ( ) < _NUM _NUM ) { result . append ( ' _NUM ' ) ; } result . append ( Integer . toString ( m _ color . getBlue ( ) , _NUM _NUM ) ) ; } return result . toString ( ) ; } 
3866	public void setClientCertificateAlias ( String alias ) { setFieldValue ( CLIENT _ CERT _ KEY , alias , CLIENT _ CERT _ PREFIX ) ; setFieldValue ( PRIVATE _ KEY _ ID _ KEY , alias , Credentials . USER _ PRIVATE _ KEY ) ; Also , set engine parameters if ( TextUtils . isEmpty ( alias ) ) { setFieldValue ( ENGINE _ KEY , ENGINE _ DISABLE ) ; setFieldValue ( ENGINE _ ID _ KEY , _STR ) ; } else { setFieldValue ( ENGINE _ KEY , ENGINE _ ENABLE ) ; setFieldValue ( ENGINE _ ID _ KEY , ENGINE _ ID _ KEYSTORE ) ; } } 
3867	public void testUdfOverloaded ( ) { final CalciteAssert . AssertThat with = withUdf ( ) ; with . query ( _STR ) ; } 
3868	public float getPan ( ) { return getValue ( PAN ) ; } 
3869	public void writePackedEnum ( long fieldId , int [ ] val ) { assertNotCompacted ( ) ; final int id = checkFieldId ( fieldId , FIELD _ COUNT _ PACKED | FIELD _ TYPE _ ENUM ) ; final int N = val ! = null ? val . length : _NUM ; if ( N > _NUM ) { int size = _NUM ; for ( int i = _NUM ; i < N ; i + + ) { final int v = val [ i ] ; size + = v > = _NUM ? EncodedBuffer . getRawVarint _NUM _NUM Size ( v ) : _NUM _NUM ; } writeKnownLengthHeader ( id , size ) ; for ( int i = _NUM ; i < N ; i + + ) { writeUnsignedVarintFromSignedInt ( val [ i ] ) ; } } } 
3870	public boolean contains ( final Object key ) { return getElement ( ( T ) key ) ! = null ; } 
3871	public void getPicture ( String id , final Component targetList , final int targetOffset , final String targetKey , Dimension toScale , boolean tempStorage ) throws IOException { checkAuthentication ( ) ; FacebookRESTService fb = new FacebookRESTService ( token , id , FacebookRESTService . PICTURE , false ) ; if ( toScale ! = null ) { fb . addArgument ( _STR ) ; } String cacheKey = id ; already has a permanent image if ( tempStorage & & ! Storage . getInstance ( ) . exists ( id ) ) { cacheKey = TEMP _ STORAGE + id ; } ImageDownloadService . createImageToStorage ( fb . requestURL ( ) , targetList , targetOffset , targetKey , cacheKey , toScale , ConnectionRequest . PRIORITY _ LOW ) ; } 
3872	public void testGetCommandAfterDeletion ( ) throws Exception { String alias = _STR ) ; String [ ] args ; int exitCode ; args = getCreateArgs ( alias , credential , providerPath ) ; exitCode = executeCommand ( args ) ; Assert . assertEquals ( exitCode , _NUM ) ; args = getDeleteArgs ( alias , providerPath ) ; exitCode = executeCommand ( args ) ; Assert . assertEquals ( exitCode , _NUM ) ; args = getGetArgs ( alias , providerPath ) ; exitCode = executeCommand ( args ) ; Assert . assertEquals ( exitCode , _NUM ) ; } 
3873	public void sendMessage ( int what , Object obj ) { Message msg = Message . obtain ( ) ; msg . what = what ; msg . obj = obj ; sendMessage ( msg ) ; } 
3874	public static GasStack readFromNBT ( NBTTagCompound nbtTags ) { if ( nbtTags = = null | | nbtTags . hasNoTags ( ) ) { return null ; } GasStack stack = new GasStack ( ) ; stack . read ( nbtTags ) ; if ( stack . getGas ( ) = = null | | stack . amount < = _NUM ) { return null ; } return stack ; } 
3875	protected static Pair < String , String > input ( final String input ) throws IOException { final IO io = IO . get ( input ) ; final boolean file = ! ( io instanceof IOContent ) & & io . exists ( ) & & ! io . isDir ( ) ; return new Pair < > ( file ? io . path ( ) : _STR , file ? io . string ( ) : input ) ; } 
3876	public static Image getJbig _NUM Image ( RandomAccessFileOrArray ra , int page ) { if ( page < _NUM ) throw new IllegalArgumentException ( MessageLocalization . getComposedMessage ( _STR ) ) ; try { JBIG _NUM SegmentReader sr = new JBIG _NUM SegmentReader ( ra ) ; sr . read ( ) ; JBIG _NUM SegmentReader . JBIG _NUM Page p = sr . getPage ( page ) ; Image img = new ImgJBIG _NUM ( p . pageBitmapWidth , p . pageBitmapHeight , p . getData ( true ) , sr . getGlobal ( true ) ) ; return img ; } catch ( Exception e ) { throw new ExceptionConverter ( e ) ; } } 
3877	public static < TSource > Integer average ( Enumerable < TSource > source , NullableIntegerFunction _NUM < TSource > selector ) { return sum ( source , selector ) / count ( source ) ; } 
3878	public String [ ] getStrings ( String name , String . . . defaultValue ) { String valueString = get ( name ) ; if ( valueString = = null ) { return defaultValue ; } else { return StringUtils . getStrings ( valueString ) ; } } 
3879	public String querySvg ( UUID flowId ) { Connection conn = null ; PreparedStatement pstm = null ; ResultSet rs = null ; String svgCode = _STR ; pstm = conn . prepareStatement ( sql ) ; pstm . setString ( _NUM , flowId . getValue ( ) ) ; rs = pstm . executeQuery ( ) ; while ( rs . next ( ) ) { svgCode = rs . getString ( _NUM ) ; break ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { DbPoolConnection . getInstance ( ) . closeAll ( rs , pstm , conn ) ; } return svgCode ; } 
3880	public static void off ( ) { org . apache . htrace . Span span = org . apache . htrace . Trace . currentSpan ( ) ; if ( span ! = null ) { span . stop ( ) ; close ( ) will no - op , but ensure safety if the implementation changes org . apache . htrace . Tracer . getInstance ( ) . continueSpan ( null ) . close ( ) ; } } 
3881	private boolean doAcquireSharedNanos ( long arg , long nanosTimeout ) throws InterruptedException { long lastTime = System . nanoTime ( ) ; final Node node = addWaiter ( Node . SHARED ) ; boolean failed = true ; try { for ( ; ; ) { final Node p = node . predecessor ( ) ; if ( p = = head ) { int r = tryAcquireShared ( arg ) ; if ( r > = _NUM ) { setHeadAndPropagate ( node , r ) ; help GC p . next = null ; failed = false ; return true ; } } if ( nanosTimeout < = _NUM ) return false ; if ( shouldParkAfterFailedAcquire ( p , node ) & & nanosTimeout > spinForTimeoutThreshold ) LockSupport . parkNanos ( this , nanosTimeout ) ; long now = System . nanoTime ( ) ; nanosTimeout - = now - lastTime ; lastTime = now ; if ( Thread . interrupted ( ) ) throw new InterruptedException ( ) ; } } finally { if ( failed ) cancelAcquire ( node ) ; } } 
3882	public void drawOval ( int x , int y , int width , int height ) { setStateToLocal ( ) ; m _ printstream . println ( xTransform ( xScale ( x ) ) + _STR ) ; } 
3883	public LabelledDocument nextDocument ( ) { LabelledDocument document = currentIterator . next ( ) ; for ( String label : document . getLabels ( ) ) { labels . storeLabel ( label ) ; } return document ; } 
3884	void updateTextInputValues ( int localizedHour , int minute , int amOrPm , boolean is _NUM _NUM Hour , boolean hourFormatStartsAtZero ) { final String format = _STR ; mIs _NUM _NUM Hour = is _NUM _NUM Hour ; mHourFormatStartsAtZero = hourFormatStartsAtZero ; mAmPmSpinner . setVisibility ( is _NUM _NUM Hour ? View . INVISIBLE : View . VISIBLE ) ; if ( amOrPm = = AM ) { mAmPmSpinner . setSelection ( _NUM ) ; } else { mAmPmSpinner . setSelection ( _NUM ) ; } mHourEditText . setText ( String . format ( format , localizedHour ) ) ; mMinuteEditText . setText ( String . format ( format , minute ) ) ; if ( mErrorShowing ) { validateInput ( ) ; } } 
3885	public PureeConfiguration build ( ) { if ( gson = = null ) { gson = new Gson ( ) ; } if ( storage = = null ) { storage = new PureeSQLiteStorage ( context ) ; } if ( executor = = null ) { executor = newBackgroundExecutor ( ) ; } return new PureeConfiguration ( context , gson , sourceOutputMap , storage , executor ) ; } 
3886	void hide ( View view ) { final int offset = mCallback . indexOfChild ( view ) ; if ( offset < _NUM ) { throw new IllegalArgumentException ( _STR + this ) ; } } 
3887	public void packRows ( ) { if ( ! contentRepaintEnabled ) { return ; } impl . setRowHeight ( defaultRowHeight ) ; for ( Column column : columnsOrder ) { if ( column . isEditable ( ) ) { impl . setRowHeight ( defaultEditableRowHeight ) ; break ; } } if ( allColumnsAreInline ( ) ) { return ; } int preferredRowHeight = - _NUM ; boolean equalsRowHeight = true ; StopWatch sw = new Slf _NUM JStopWatch ( _STR + id ) ; for ( int r = _NUM ; r < impl . getRowCount ( ) ; r + + ) { int h = getPreferredRowHeight ( r ) ; if ( preferredRowHeight = = - _NUM ) { preferredRowHeight = h ; } else if ( preferredRowHeight ! = h ) { equalsRowHeight = false ; } if ( impl . getRowHeight ( r ) ! = h ) { impl . setRowHeight ( r , h ) ; } } if ( equalsRowHeight & & preferredRowHeight > _NUM ) { impl . setRowHeight ( preferredRowHeight ) ; } sw . stop ( ) ; } 
3888	 @ SuppressWarnings ( _STR ) ; return null ; } } 
3889	public void setPageTransformer ( boolean reverseDrawingOrder , PageTransformer transformer ) { if ( Build . VERSION . SDK _ INT > = _NUM _NUM ) { final boolean hasTransformer = transformer ! = null ; final boolean needsPopulate = hasTransformer ! = ( mPageTransformer ! = null ) ; mPageTransformer = transformer ; setChildrenDrawingOrderEnabledCompat ( hasTransformer ) ; if ( hasTransformer ) { mDrawingOrder = reverseDrawingOrder ? DRAW _ ORDER _ REVERSE : DRAW _ ORDER _ FORWARD ; } else { mDrawingOrder = DRAW _ ORDER _ DEFAULT ; } if ( needsPopulate ) populate ( ) ; } } 
3890	public static EndpointReferenceType getEndpointReference ( URL wsdlUrl , QName serviceName , String portName ) { EndpointReferenceType reference = new EndpointReferenceType ( ) ; reference . setMetadata ( new MetadataType ( ) ) ; setServiceAndPortName ( reference , serviceName , portName ) ; setWSDLLocation ( reference , wsdlUrl . toString ( ) ) ; return reference ; } 
3891	public List < FieldValueGetter > generateGetters ( Class pojoClass ) { ImmutableList . Builder < FieldValueGetter > getters = ImmutableList . builder ( ) ; List < Method > getterMethods = getPublicGetters ( pojoClass ) ; for ( Method getterMethod : getterMethods ) { getters . add ( createFieldGetterInstance ( pojoClass , getterMethod ) ) ; } return getters . build ( ) ; } 
3892	 @ Test ( dependsOnMethods = _STR ) ; } 
3893	public final void set ( T linkable ) { if ( _ lastReturned = = null ) { throw new IllegalStateException ( ) ; } swap ( _ lastReturned , linkable ) ; _ lastReturned = linkable ; } 
3894	public void truncateByMinAddress ( final long minAddress ) { if ( ! isExtAddr ( minAddress ) ) { return ; } log . info ( _STR , file . getFileName ( ) , fileTailOffset , realOffset ) ; if ( file . destroy ( _NUM _NUM _NUM _NUM ) ) { willRemoveFiles . add ( file ) ; } } } this . mappedFileQueue . deleteExpiredFile ( willRemoveFiles ) ; } 
3895	public void enQueue ( int data ) throws NullPointerException , IllegalStateException { if ( size = = CAPACITY ) expand ( ) ; size + + ; queueRep [ rear ] = data ; rear = ( rear + _NUM ) % CAPACITY ; } 
3896	public float getScaleFactor ( ) { if ( mScaleFactor = = - _NUM ) { mScaleFactor = getCurrentSpan ( ) / getPreviousSpan ( ) ; } return mScaleFactor ; } 
3897	private void init ( ) { no need to synchronize this check as it is atomic if ( awtColorSpace ! = null ) { return ; } suggestKCMS ( ) ; synchronized ( this ) { we might have been waiting for another thread , so check again if ( awtColorSpace ! = null ) { return ; } awtColorSpace = ColorSpace . getInstance ( ColorSpace . CS _ sRGB ) ; there is a JVM bug which results in a CMMException which appears to be a race condition caused by lazy initialization of the color transform , so we perform an initial color conversion while we ' re still synchronized , see PDFBOX - _NUM _NUM _NUM _NUM awtColorSpace . toRGB ( new float [ ] { _NUM , _NUM , _NUM , _NUM } ) ; } } 
3898	private Object getPreviousElement ( ) { Object element = null ; while ( currentIndex > = startIndex & & element = = null ) { currentIndex - - ; element = getElement ( ) ; } return element ; } 
3899	protected MessageConsumer createListenerConsumer ( final Session session ) throws JMSException { Destination destination = getDestination ( ) ; if ( destination = = null ) { destination = resolveDestinationName ( session , getDestinationName ( ) ) ; } MessageConsumer consumer = createConsumer ( session , destination ) ; consumer . setMessageListener ( ( MessageListener ) super . getMessageListener ( ) ) ; return consumer ; } 
3900	protected void doGet ( final HttpServletRequest req , final HttpServletResponse resp ) throws ServletException , IOException { doPost ( req , resp ) ; } 
3901	public String toHexString ( final int start , final int length ) { final int roundedStart = ( start / LOG _ BYTES _ PER _ ROW ) * LOG _ BYTES _ PER _ ROW ; final StringBuilder sb = new StringBuilder ( _STR ) ; } } sb . append ( ' \ n ' ) ; } return sb . toString ( ) ; } 
3902	 / See if we can do a requestboolean canDoRequest ( ) { return checkFreeSlot ( ) ! = RequestPermit . NONE _ ALLOWED ; } 
3903	public void fields ( ) { DeleteOptions options = DeleteOptions . defaults ( ) ; boolean recursive = false ; options . setRecursive ( recursive ) ; Assert . assertEquals ( recursive , options . isRecursive ( ) ) ; recursive = true ; options . setRecursive ( recursive ) ; Assert . assertEquals ( recursive , options . isRecursive ( ) ) ; } 
3904	void smoothScrollTo ( int x , int y , int velocity ) { if ( getChildCount ( ) = = _NUM ) { Nothing to do . setScrollingCacheEnabled ( false ) ; return ; } int sx = getScrollX ( ) ; int sy = getScrollY ( ) ; int dx = x - sx ; int dy = y - sy ; if ( dx = = _NUM & & dy = = _NUM ) { completeScroll ( false ) ; populate ( ) ; setScrollState ( SCROLL _ STATE _ IDLE ) ; return ; } setScrollingCacheEnabled ( true ) ; setScrollState ( SCROLL _ STATE _ SETTLING ) ; final int width = getClientWidth ( ) ; final int halfWidth = width / _NUM ; final float distanceRatio = Math . min ( _NUM f , _NUM . _NUM f * Math . abs ( dx ) / width ) ; final float distance = halfWidth + halfWidth * distanceInfluenceForSnapDuration ( distanceRatio ) ; int duration = _NUM ; velocity = Math . abs ( velocity ) ; if ( velocity > _NUM ) { duration = _NUM * Math . round ( _NUM _NUM _NUM _NUM * Math . abs ( distance / velocity ) ) ; } else { final float pageWidth = width * mAdapter . getPageWidth ( mCurItem ) ; final float pageDelta = ( float ) Math . abs ( dx ) / ( pageWidth + mPageMargin ) ; duration = ( int ) ( ( pageDelta + _NUM ) * _NUM _NUM _NUM ) ; } duration = Math . min ( duration , MAX _ SETTLE _ DURATION ) ; mScroller . startScroll ( sx , sy , dx , dy , duration ) ; ViewCompat . postInvalidateOnAnimation ( this ) ; } 
3905	public int readUnsignedShort ( ) { if ( cursor + _NUM > length ) throw new ArrayIndexOutOfBoundsException ( _STR ) ; byte value _NUM = data [ offset + cursor ] ; byte value _NUM = data [ offset + cursor + _NUM ] ; int result = calculateUnsignedShort ( value _NUM , value _NUM ) ; cursor + = _NUM ; return result ; } 
3906	public Peer get ( DatanodeID dnId , boolean isDomain ) { if ( capacity < = _NUM ) { disabled return null ; } return getInternal ( dnId , isDomain ) ; } 
3907	public void copy ( IndexInput in , long byteCount ) throws IOException { while ( byteCount > _NUM ) { int left = blockSize - upto ; if ( left = = _NUM ) { if ( currentBlock ! = null ) { blocks . add ( currentBlock ) ; blockEnd . add ( upto ) ; } currentBlock = new byte [ blockSize ] ; upto = _NUM ; left = blockSize ; } if ( left < byteCount ) { in . readBytes ( currentBlock , upto , left , false ) ; upto = blockSize ; byteCount - = left ; } else { in . readBytes ( currentBlock , upto , ( int ) byteCount , false ) ; upto + = byteCount ; break ; } } } 
3908	public void bootstrapCloudAndWait ( final String securityProfile , final String username , final String password , final String keystorePassword , final boolean performValidation , final long timeout , final TimeUnit timeoutUnit ) throws InstallerException , CLIException , InterruptedException { final long end = System . currentTimeMillis ( ) + timeoutUnit . toMillis ( timeout ) ; createProvisioningDriver ( performValidation ) ; Start the cloud machines ! ! ! final MachineDetails [ ] servers = getOrCreateManagementServers ( timeout , timeoutUnit , keystorePassword , securityProfile ) ; avoid leaks ) . try { log details in FINE if ( logger . isLoggable ( Level . FINE ) ) { for ( final MachineDetails server : servers ) { logServerDetails ( server ) ; } } validateServers ( servers ) ; if ( servers [ _NUM ] . isAgentRunning ( ) ) { logger . fine ( _STR , e ) ; } catch ( final CLIException e ) { stopManagementMachines ( ) ; throw e ; } catch ( final InstallerException e ) { stopManagementMachines ( ) ; throw e ; } catch ( final InterruptedException e ) { stopManagementMachines ( ) ; throw e ; } } 
3909	protected Object convertBinary ( Column column , Field fieldDefn , Object data ) { if ( data = = null ) { data = fieldDefn . schema ( ) . defaultValue ( ) ; } if ( data = = null ) { if ( column . isOptional ( ) ) return null ; data = BYTE _ ZERO ; } if ( data instanceof char [ ] ) { convert to string data = new String ( ( char [ ] ) data ) ; } if ( data instanceof String ) { This was encoded as a hexadecimal string , but we receive it as a normal string . . . data = ( ( String ) data ) . getBytes ( ) ; } if ( data instanceof byte [ ] ) { return convertByteArray ( column , ( byte [ ] ) data ) ; } An unexpected value return unexpectedBinary ( data , fieldDefn ) ; } 
3910	public static void applyPadding ( View view , DynamicProperty property ) { if ( view ! = null ) { switch ( property . type ) { case DIMEN : { int padding = property . getValueInt ( ) ; view . setPadding ( padding , padding , padding , padding ) ; } break ; } } } 
3911	public Schema getSchema ( ) { if ( isNullable ( ) ) { List < Schema > list = new ArrayList < > ( ) ; list . add ( Schema . create ( Schema . Type . NULL ) ) ; list . add ( schema ( ) ) ; return Schema . createUnion ( list ) ; } return schema ( ) ; } 
3912	public void testSaveConfig ( ) { WifiConfiguration config = new WifiConfiguration ( ) ; config . SSID = _STR ) ) { found = true ; } } assertTrue ( found ) ; restore config boolean ret = mWifiManager . removeNetwork ( netId ) ; assertTrue ( ret ) ; mWifiManager . saveConfiguration ( ) ; } 
3913	public String toString ( ) { if ( m _ eigenvalues = = null ) { return _STR + principalComponentsSummary ( ) ; } } 
3914	public static void main ( String [ ] args ) throws Exception { int ret = ToolRunner . run ( new SyncTable ( HBaseConfiguration . create ( ) ) , args ) ; System . exit ( ret ) ; } 
3915	public boolean getBoolean ( String key ) throws JSONException { Object o = get ( key ) ; if ( o . equals ( Boolean . FALSE ) | | ( o instanceof String & & ( ( String ) o ) . equalsIgnoreCase ( _STR ) ; } 
3916	public ServiceEndpointServer startApplication ( ) { return getServiceEndpointServer ( ) . startServerAndWait ( ) ; } 
3917	public static ScriptPatternSelector createSelector ( final AbstractScript script , final PatternMatch [ ] properties , final String defaultPattern , final boolean alwaysWriteExceptions , final boolean noConsoleNoAnsi , final Configuration configuration ) { final Builder builder = newBuilder ( ) ; builder . setScript ( script ) ; builder . setProperties ( properties ) ; builder . setDefaultPattern ( defaultPattern ) ; builder . setAlwaysWriteExceptions ( alwaysWriteExceptions ) ; builder . setNoConsoleNoAnsi ( noConsoleNoAnsi ) ; builder . setConfiguration ( configuration ) ; return builder . build ( ) ; } 
3918	public static < LT _NUM , LT _NUM , PT , R > LazyEither _NUM < LT _NUM , LT _NUM , ReactiveSeq < R > > traverse ( final Iterable < LazyEither _NUM < LT _NUM , LT _NUM , PT > > xors , Function < ? super PT , ? extends R > fn ) { return sequence ( xors ) . map ( l - > l . map ( fn ) ) ; } 
3919	 @ DELETE @ Path ( _STR ) ; response . setApplication ( services . getApplication ( ) ) ; response . setParams ( ui . getQueryParameters ( ) ) ; emf . getEntityManager ( services . getApplicationId ( ) ) . deleteCollectionSettings ( itemName . getPath ( ) . toLowerCase ( ) ) ; return response ; } 
3920	public CharSequence getEntry ( ) { int index = getValueIndex ( ) ; return index > = _NUM & & mEntries ! = null ? mEntries [ index ] : null ; } 
3921	public void setSeriesItemLabelsVisible ( int series , Boolean visible , boolean notify ) { this . itemLabelsVisibleList . setBoolean ( series , visible ) ; if ( notify ) { fireChangeEvent ( ) ; } } 
3922	public void finishGuidedStepFragments ( ) { final FragmentManager fragmentManager = getFragmentManager ( ) ; final int entryCount = fragmentManager . getBackStackEntryCount ( ) ; if ( entryCount > _NUM ) { for ( int i = entryCount - _NUM ; i > = _NUM ; i - - ) { BackStackEntry entry = fragmentManager . getBackStackEntryAt ( i ) ; if ( isStackEntryUiStyleEntrance ( entry . getName ( ) ) ) { GuidedStepFragment top = getCurrentGuidedStepFragment ( fragmentManager ) ; if ( top ! = null ) { top . setUiStyle ( UI _ STYLE _ ENTRANCE ) ; } fragmentManager . popBackStackImmediate ( entry . getId ( ) , FragmentManager . POP _ BACK _ STACK _ INCLUSIVE ) ; return ; } } } ActivityCompat . finishAfterTransition ( getActivity ( ) ) ; } 
3923	public void setGrouping ( GroupingMethod newGrouping ) { if ( newGrouping = = grouping ) { return ; } this . grouping = newGrouping ; refreshUI ( ) ; } 
3924	protected void checkForTokens ( String content , int startOffset , int endOffset ) { while ( startOffset < = endOffset ) { while ( isDelimiter ( content . substring ( startOffset , startOffset + _NUM ) ) ) { if ( startOffset < endOffset ) startOffset + + ; else return ; } if ( isQuoteDelimiter ( content . substring ( startOffset , startOffset + _NUM ) ) ) startOffset = getQuoteToken ( content , startOffset , endOffset ) ; else startOffset = getOtherToken ( content , startOffset , endOffset ) ; } } 
3925	public Map < RegionInfo , ServerName [ ] > placeSecondaryAndTertiaryWithRestrictions ( Map < RegionInfo , ServerName > primaryRSMap ) { Map < ServerName , Set < RegionInfo > > serverToPrimaries = mapRSToPrimaries ( primaryRSMap ) ; Map < RegionInfo , ServerName [ ] > secondaryAndTertiaryMap = new HashMap < > ( ) ; for ( Entry < RegionInfo , ServerName > entry : primaryRSMap . entrySet ( ) ) { Get the target region and its primary region server rack RegionInfo regionInfo = entry . getKey ( ) ; ServerName primaryRS = entry . getValue ( ) ; try { Get the rack for the primary region server String primaryRack = getRackOfServer ( primaryRS ) ; ServerName [ ] favoredNodes = null ; if ( getTotalNumberOfRacks ( ) = = _NUM ) { Single rack case : have to pick the secondary and tertiary from the same rack favoredNodes = singleRackCase ( regionInfo , primaryRS , primaryRack ) ; } else { favoredNodes = multiRackCaseWithRestrictions ( serverToPrimaries , secondaryAndTertiaryMap , primaryRack , primaryRS , regionInfo ) ; } if ( favoredNodes ! = null ) { secondaryAndTertiaryMap . put ( regionInfo , favoredNodes ) ; LOG . debug ( _STR + e , e ) ; continue ; } } return secondaryAndTertiaryMap ; } 
3926	public static Date getNextRunTime ( IntervalType type , String schedule , String timezone , Date startDate ) { MM : HH : DAY String [ ] scheduleParts = schedule . split ( _STR + type . toString ( ) ) ; } try { return scheduleTime . getTime ( ) ; } catch ( IllegalArgumentException ex ) { scheduleTime . setLenient ( true ) ; Date nextScheduledDate = scheduleTime . getTime ( ) ; scheduleTime . setLenient ( false ) ; return nextScheduledDate ; } } 
3927	public NetworkStats queryDetailsForUidTag ( int networkType , String subscriberId , long startTime , long endTime , int uid , int tag ) throws SecurityException { NetworkTemplate template ; template = createTemplate ( networkType , subscriberId ) ; NetworkStats result ; try { result = new NetworkStats ( mContext , template , mFlags , startTime , endTime , mService ) ; result . startHistoryEnumeration ( uid , tag ) ; } catch ( RemoteException e ) { Log . e ( TAG , _STR + tag , e ) ; return null ; } return result ; } 
3928	public MappingStoreOps < I , ? extends Writable > createMappingStoreOps ( ) { if ( getMappingStoreOpsClass ( ) ! = null ) { return ReflectionUtils . newInstance ( getMappingStoreOpsClass ( ) , this ) ; } else { return null ; } } 
3929	public List < ComputeTemplate > addAdditionalTemplates ( final Cloud cloud , final File [ ] templatesFolders ) { List < ComputeTemplate > addedTemplates = new LinkedList < ComputeTemplate > ( ) ; List < ComputeTemplateHolder > additionalTemplates = null ; scan all templates folders and add the templates from each folder to the cloud . for ( File folder : templatesFolders ) { logger . log ( Level . INFO , _STR + e . getMessage ( ) ) ; } } return addedTemplates ; } 
3930	public FrameBlock append ( FrameBlock that , FrameBlock ret , boolean cbind ) { if ( COLUMN APPEND cbind ) { sanity check row dimension mismatch if ( getNumRows ( ) ! = that . getNumRows ( ) ) { throw new DMLRuntimeException ( _STR ) ; } allocate output frame ( incl deep copy schema ) if ( ret = = null ) ret = new FrameBlock ( ) ; ret . _ numRows = _ numRows ; ret . _ schema = _ schema . clone ( ) ; ret . _ colnames = ( _ colnames ! = null ) ? _ colnames . clone ( ) : null ; ret . _ colmeta = new ColumnMetadata [ getNumColumns ( ) ] ; for ( int j = _NUM ; j < _ schema . length ; j + + ) ret . _ colmeta [ j ] = new ColumnMetadata ( _NUM ) ; concatenate data ( deep copy first , append second ) ret . _ coldata = new Array [ getNumColumns ( ) ] ; for ( int j = _NUM ; j < getNumColumns ( ) ; j + + ) ret . _ coldata [ j ] = _ coldata [ j ] . clone ( ) ; Iterator < Object [ ] > iter = that . getObjectRowIterator ( _ schema ) ; while ( iter . hasNext ( ) ) ret . appendRow ( iter . next ( ) ) ; } return ret ; } 
3931	public double evaluationForSingleInstance ( double [ ] dist , Instance instance , boolean storePredictions ) throws Exception { double pred ; if ( m _ ClassIsNominal ) { pred = Utils . maxIndex ( dist ) ; if ( dist [ ( int ) pred ] < = _NUM ) { pred = Utils . missingValue ( ) ; } updateStatsForClassifier ( dist , instance ) ; if ( storePredictions & & ! m _ DiscardPredictions ) { if ( m _ Predictions = = null ) m _ Predictions = new FastVector ( ) ; m _ Predictions . addElement ( new NominalPrediction ( instance . classValue ( ) , dist , instance . weight ( ) ) ) ; } } else { pred = dist [ _NUM ] ; updateStatsForPredictor ( pred , instance ) ; if ( storePredictions & & ! m _ DiscardPredictions ) { if ( m _ Predictions = = null ) m _ Predictions = new FastVector ( ) ; m _ Predictions . addElement ( new NumericPrediction ( instance . classValue ( ) , pred , instance . weight ( ) ) ) ; } } return pred ; } 
3932	public int read ( byte [ ] b , int offset , int size ) throws IOException { return mData . readEntityData ( b , offset , size ) ; } 
3933	private int execCommand ( Session session , String cmd ) throws JSchException , InterruptedException , IOException { LOG . debug ( _STR , exec . getErrStream ( ) , StreamPumper . StreamType . STDERR ) ; errPumper . start ( ) ; outPumper . join ( ) ; errPumper . join ( ) ; return exec . getExitStatus ( ) ; } finally { cleanup ( exec ) ; } } 
3934	public void flushRows ( int remaining ) throws IOException { while ( _ rows . size ( ) > remaining ) { flushOneRow ( ) ; } if ( remaining = = _NUM ) { allFlushed = true ; } } 
3935	void removeBlocks ( BlocksMapUpdateInfo blocks ) { List < BlockInfo > toDeleteList = blocks . getToDeleteList ( ) ; Iterator < BlockInfo > iter = toDeleteList . iterator ( ) ; while ( iter . hasNext ( ) ) { writeLock ( ) ; try { for ( int i = _NUM ; i < BLOCK _ DELETION _ INCREMENT & & iter . hasNext ( ) ; i + + ) { blockManager . removeBlock ( iter . next ( ) ) ; } } finally { writeUnlock ( ) ; } } } 
3936	public DoubleStreamEx intersperse ( int delimiter ) { return new DoubleStreamEx ( stream ( ) . flatMap ( s - > DoubleStreamEx . of ( delimiter , s ) ) . skip ( _NUM ) , context ) ; } 
3937	public boolean isEmpty ( ) { return size ( ) = = _NUM ; } 
3938	public Bln contains ( final ANode node _NUM , final ANode node _NUM ) throws QueryException { final Geometry geo _NUM = checkGeo ( node _NUM ) ; final Geometry geo _NUM = checkGeo ( node _NUM ) ; return Bln . get ( geo _NUM . contains ( geo _NUM ) ) ; } 
3939	final byte [ ] stringToBinary ( final QueryContext qc ) throws QueryException { final byte [ ] in = toToken ( exprs [ _NUM ] , qc ) ; final String enc = toEncoding ( _NUM , CONVERT _ ENCODING _ X , qc ) ; if ( enc = = null | | enc = = Strings . UTF _NUM ) return in ; try { return toBinary ( in , enc ) ; } catch ( final CharacterCodingException ex ) { Util . debug ( ex ) ; throw CONVERT _ BINARY _ X _ X . get ( info , chop ( in , info ) , enc ) ; } } 
3940	public static Router attachRouter ( @ NonNull Activity activity , @ NonNull ViewGroup container , @ Nullable Bundle savedInstanceState ) { ThreadUtils . ensureMainThread ( ) ; LifecycleHandler lifecycleHandler = LifecycleHandler . install ( activity ) ; Router router = lifecycleHandler . getRouter ( container , savedInstanceState ) ; router . rebindIfNeeded ( ) ; return router ; } 
3941	protected String htmlBegin ( ) { StringBuffer html = new StringBuffer ( _NUM _NUM _NUM ) ; help & confirmation text for actions if needed if ( ! isPrintable ( ) & & ( m _ visibleItems ! = null ) & & ! m _ visibleItems . isEmpty ( ) ) { Iterator < CmsListColumnDefinition > cols = getMetadata ( ) . getColumnDefinitions ( ) . iterator ( ) ; while ( cols . hasNext ( ) ) { CmsListColumnDefinition col = cols . next ( ) ; Iterator < I _ CmsListDirectAction > actions = col . getDirectActions ( ) . iterator ( ) ; while ( actions . hasNext ( ) ) { I _ CmsListDirectAction action = actions . next ( ) ; action . setItem ( m _ visibleItems . get ( _NUM ) ) ; html . append ( action . helpTextHtml ( ) ) ; html . append ( action . confirmationTextHtml ( ) ) ; } Iterator < CmsListDefaultAction > defActions = col . getDefaultActions ( ) . iterator ( ) ; while ( defActions . hasNext ( ) ) { I _ CmsListDirectAction action = defActions . next ( ) ; action . setItem ( m _ visibleItems . get ( _NUM ) ) ; html . append ( action . helpTextHtml ( ) ) ; html . append ( action . confirmationTextHtml ( ) ) ; } } } start list code html . append ( _STR ) ; return html . toString ( ) ; } 
3942	protected String determineActionURL ( String action , String namespace , String method , HttpServletRequest req , HttpServletResponse res , Map parameters , String scheme , boolean includeContext , boolean encodeResult , boolean forceAddSchemeHostAndPort , boolean escapeAmp ) { String finalAction = findString ( action ) ; String finalMethod = method ! = null ? findString ( method ) : null ; String finalNamespace = determineNamespace ( namespace , getStack ( ) , req ) ; ActionMapping mapping = new ActionMapping ( finalAction , finalNamespace , finalMethod , parameters ) ; String uri = actionMapper . getUriFromActionMapping ( mapping ) ; return urlHelper . buildUrl ( uri , req , res , parameters , scheme , includeContext , encodeResult , forceAddSchemeHostAndPort , escapeAmp ) ; } 
3943	private boolean delete ( FTPClient client , Path file , boolean recursive ) throws IOException { Path workDir = new Path ( client . printWorkingDirectory ( ) ) ; Path absolute = makeAbsolute ( workDir , file ) ; String pathName = absolute . toUri ( ) . getPath ( ) ; try { FileStatus fileStat = getFileStatus ( client , absolute ) ; if ( fileStat . isFile ( ) ) { return client . deleteFile ( pathName ) ; } } catch ( FileNotFoundException e ) { the file is not there return false ; } FileStatus [ ] dirEntries = listStatus ( client , absolute ) ; if ( dirEntries ! = null & & dirEntries . length > _NUM & & ! ( recursive ) ) { throw new IOException ( _STR ) ; } for ( FileStatus dirEntry : dirEntries ) { delete ( client , new Path ( absolute , dirEntry . getPath ( ) ) , recursive ) ; } return client . removeDirectory ( pathName ) ; } 
3944	private int skipToPreviousListItemOrListStart ( ) { int startLine = line ; int startPosition = position ; while ( true ) { nextToken ( ) ; if any line item comes with its own indentation , adapt to it if ( line < startLine ) { try { int lineOffset = document . getLineOffset ( startLine ) ; int bound = Math . min ( document . getLength ( ) , startPosition + _NUM ) ; int align = scanner . findNonWhitespaceForwardInAnyPartition ( lineOffset , bound ) ; } catch ( BadLocationException e ) { _ log . debug ( EditorMessages . error _ badLocationException , e ) ; ignore and return just the position } return startPosition ; } switch ( token ) { case SQLIndentSymbols . TokenEOF : return _NUM ; } } } 
3945	public void ensureCapacityWords ( int numWords ) { if ( bits . length < numWords ) { bits = ArrayUtil . grow ( bits , numWords ) ; } } 
3946	private void restart ( boolean checkpoint , boolean xattrsEnabled ) throws Exception { NameNode nameNode = cluster . getNameNode ( ) ; if ( checkpoint ) { NameNodeAdapter . enterSafeMode ( nameNode , false ) ; NameNodeAdapter . saveNamespace ( nameNode ) ; } shutdown ( ) ; initCluster ( false , xattrsEnabled ) ; } 
3947	public void toThrift ( ) { MountOptions options = MountOptions . defaults ( ) ; MountTOptions thriftOptions = options . toThrift ( ) ; assertFalse ( thriftOptions . isReadOnly ( ) ) ; options . setReadOnly ( true ) ; options . setShared ( true ) ; thriftOptions = options . toThrift ( ) ; assertTrue ( thriftOptions . isReadOnly ( ) ) ; assertTrue ( thriftOptions . isShared ( ) ) ; } 
3948	public void preparePartitions ( Map < String , Object > config , int totalTasks , int taskIndex , SpoutOutputCollector collector ) throws Exception { this . collector = collector ; if ( stateStore = = null ) { String zkEndpointAddress = eventHubConfig . getZkConnectionString ( ) ; if ( zkEndpointAddress = = null | | zkEndpointAddress . length ( ) = = _NUM ) { use storm ' s zookeeper servers if not specified . @ SuppressWarnings ( _STR + zkPort ) ; } zkEndpointAddress = sb . toString ( ) ; } stateStore = new ZookeeperStateStore ( zkEndpointAddress , Integer . parseInt ( config . get ( Config . STORM _ ZOOKEEPER _ RETRY _ TIMES ) . toString ( ) ) , Integer . parseInt ( config . get ( Config . STORM _ ZOOKEEPER _ RETRY _ INTERVAL ) . toString ( ) ) ) ; } stateStore . open ( ) ; partitionCoordinator = new StaticPartitionCoordinator ( eventHubConfig , taskIndex , totalTasks , stateStore , pmFactory , recvFactory ) ; for ( IPartitionManager partitionManager : partitionCoordinator . getMyPartitionManagers ( ) ) { partitionManager . open ( ) ; } } 
3949	public static NodeTable makeNodeTable ( Location location , String indexNode _NUM Id , int node _NUM NodeIdCacheSize , String indexId _NUM Node , int nodeId _NUM NodeCacheSize , int sizeNodeMissCacheSize ) { StoreParamsBuilder spb = StoreParams . builder ( ) ; spb . indexNode _NUM Id ( indexNode _NUM Id ) . node _NUM NodeIdCacheSize ( node _NUM NodeIdCacheSize ) ; spb . indexId _NUM Node ( indexId _NUM Node ) . nodeId _NUM NodeCacheSize ( nodeId _NUM NodeCacheSize ) ; DatasetBuilderStd dbBuild = DatasetBuilderStd . stdBuilder ( ) ; return makeNodeTable ( location , spb . build ( ) ) ; } 
3950	public static String toHex ( byte value ) { StringBuilder sb = new StringBuilder ( _NUM ) ; writeHex ( sb , value & _NUM xFF , _NUM , _STR ) ; return sb . toString ( ) ; } 
3951	public Functions without ( FunctionName name , List < AbstractType < ? > > argTypes ) { Function fun = find ( name , argTypes ) . orElseThrow ( ( ) - > new IllegalStateException ( String . format ( _STR , name ) ) ) ; return builder ( ) . add ( filter ( this , f - > f ! = fun ) ) . build ( ) ; } 
3952	public void writeProject ( CmsDbContext dbc , int publishTag , long publishDate ) throws CmsDataAccessException { CmsProject currentProject = dbc . currentProject ( ) ; CmsUser currentUser = dbc . currentUser ( ) ; List projectresources = m _ driverManager . getProjectDriver ( dbc ) . readProjectResources ( dbc , currentProject ) ; write historical project to the database Connection conn = null ; PreparedStatement stmt = null ; try { conn = m _ sqlManager . getConnection ( dbc ) ; stmt = m _ sqlManager . getPreparedStatement ( conn , _STR ) ; Iterator i = projectresources . iterator ( ) ; while ( i . hasNext ( ) ) { stmt . setInt ( _NUM , publishTag ) ; stmt . setString ( _NUM , currentProject . getUuid ( ) . toString ( ) ) ; stmt . setString ( _NUM , ( String ) i . next ( ) ) ; stmt . executeUpdate ( ) ; stmt . clearParameters ( ) ; } } catch ( SQLException e ) { throw new CmsDbSqlException ( Messages . get ( ) . container ( Messages . ERR _ GENERIC _ SQL _ _NUM , CmsDbSqlException . getErrorQuery ( stmt ) ) , e ) ; } finally { m _ sqlManager . closeAll ( dbc , conn , stmt , null ) ; } } 
3953	protected void onAmPmClick ( ) { updateFromPicker ( ) ; } 
3954	public void testJettyAdminServer ( ) throws AdminServerException , IOException { JettyAdminServer server = new JettyAdminServer ( ) ; ; try { server . start ( ) ; queryAdminServer ( jettyAdminPort ) ; } finally { server . shutdown ( ) ; } } 
3955	private Stack < Comment > getComments ( ) { Stack < Comment > newComments = new Stack < Comment > ( ) ; List < BasicIssue > issues = getIssues ( ) ; for ( BasicIssue issue : issues ) { Issue fullIssue = client ( ) . getIssueClient ( ) . getIssue ( issue . getKey ( ) , null ) ; for ( Comment comment : fullIssue . getComments ( ) ) { if ( ! commentIds . contains ( comment . getId ( ) ) ) { newComments . push ( comment ) ; commentIds . add ( comment . getId ( ) ) ; } } } return newComments ; } 
3956	public void addRowLabel ( int columnIndex ) { checkColumnIndex ( columnIndex ) ; AreaReference pivotArea = getPivotArea ( ) ; final int lastRowIndex = pivotArea . getLastCell ( ) . getRow ( ) - pivotArea . getFirstCell ( ) . getRow ( ) ; CTPivotFields pivotFields = pivotTableDefinition . getPivotFields ( ) ; CTPivotField pivotField = CTPivotField . Factory . newInstance ( ) ; CTItems items = pivotField . addNewItems ( ) ; pivotField . setAxis ( STAxis . AXIS _ ROW ) ; pivotField . setShowAll ( false ) ; for ( int i = _NUM ; i < = lastRowIndex ; i + + ) { items . addNewItem ( ) . setT ( STItemType . DEFAULT ) ; } items . setCount ( items . sizeOfItemArray ( ) ) ; pivotFields . setPivotFieldArray ( columnIndex , pivotField ) ; CTRowFields rowFields ; if ( pivotTableDefinition . getRowFields ( ) ! = null ) { rowFields = pivotTableDefinition . getRowFields ( ) ; } else { rowFields = pivotTableDefinition . addNewRowFields ( ) ; } rowFields . addNewField ( ) . setX ( columnIndex ) ; rowFields . setCount ( rowFields . sizeOfFieldArray ( ) ) ; } 
3957	public static void setStart ( IteratorSetting is , String start , boolean startInclusive ) { SimpleDateFormat dateParser = initDateParser ( ) ; try { long startTS = dateParser . parse ( start ) . getTime ( ) ; setStart ( is , startTS , startInclusive ) ; } catch ( ParseException e ) { throw new IllegalArgumentException ( _STR + start ) ; } } 
3958	public static ExchangePattern resolveExchangePatternFromUrl ( String url ) throws URISyntaxException { int idx = url . indexOf ( _STR ) ; if ( pattern ! = null ) { return ExchangePattern . asEnum ( pattern ) ; } return null ; } 
3959	protected SnmpVersion getSnmpVersion ( Map < String , String > dispatchProperties ) throws InvalidSnmpConfigurationException { String snmpVersion = getDispatchProperty ( dispatchProperties , SNMP _ VERSION _ PROPERTY ) ; try { return SnmpVersion . valueOf ( snmpVersion ) ; } catch ( IllegalArgumentException ex ) { String errorMessage = String . format ( _STR , snmpVersion , SNMP _ VERSION _ PROPERTY , Arrays . toString ( SnmpVersion . values ( ) ) ) ; throw new InvalidSnmpConfigurationException ( errorMessage ) ; } } 
3960	protected TrimResult trimChildRestore ( RelNode rel , RelNode input , ImmutableBitSet fieldsUsed , Set < RelDataTypeField > extraFields ) { TrimResult trimResult = trimChild ( rel , input , fieldsUsed , extraFields ) ; if ( trimResult . right . isIdentity ( ) ) { return trimResult ; } final RelDataType rowType = input . getRowType ( ) ; List < RelDataTypeField > fieldList = rowType . getFieldList ( ) ; final List < RexNode > exprList = new ArrayList < > ( ) ; final List < String > nameList = rowType . getFieldNames ( ) ; RexBuilder rexBuilder = rel . getCluster ( ) . getRexBuilder ( ) ; assert trimResult . right . getSourceCount ( ) = = fieldList . size ( ) ; for ( int i = _NUM ; i < fieldList . size ( ) ; i + + ) { int source = trimResult . right . getTargetOpt ( i ) ; RelDataTypeField field = fieldList . get ( i ) ; exprList . add ( source < _NUM ? rexBuilder . makeZeroLiteral ( field . getType ( ) ) : rexBuilder . makeInputRef ( field . getType ( ) , source ) ) ; } relBuilder . push ( trimResult . left ) . project ( exprList , nameList ) ; return result ( relBuilder . build ( ) , Mappings . createIdentity ( fieldList . size ( ) ) ) ; } 
3961	public void testUnfinishedBlockRead ( ) throws IOException { create a new file in the root , write data , do no close Path file _NUM = new Path ( _STR ) ; FSDataOutputStream stm = TestFileCreation . createFile ( fileSystem , file _NUM , _NUM ) ; write partial block and sync int partialBlockSize = blockSize / _NUM ; writeFileAndSync ( stm , partialBlockSize ) ; Make sure a client can read it before it is closed checkCanRead ( fileSystem , file _NUM , partialBlockSize ) ; stm . close ( ) ; } 
3962	public void delete ( RegularTimePeriod period ) { int index = getIndex ( period ) ; if ( index > = _NUM ) { this . data . remove ( index ) ; if ( this . data . isEmpty ( ) ) { this . timePeriodClass = null ; } fireSeriesChanged ( ) ; } } 
3963	Item newLong ( final long value ) { key . set ( value ) ; Item result = get ( key ) ; if ( result = = null ) { pool . putByte ( LONG ) . putLong ( value ) ; result = new Item ( index , key ) ; index + = _NUM ; put ( result ) ; } return result ; } 
3964	private void setAttributeAndJournal ( LockedInodePath inodePath , boolean rootRequired , boolean ownerRequired , SetAttributeOptions options , JournalContext journalContext ) throws InvalidPathException , FileDoesNotExistException , AccessControlException { Inode < ? > targetInode = inodePath . getInode ( ) ; long opTimeMs = System . currentTimeMillis ( ) ; if ( options . isRecursive ( ) & & targetInode . isDirectory ( ) ) { try ( InodeLockList lockList = mInodeTree . lockDescendants ( inodePath , InodeTree . LockMode . WRITE ) ) { List < Inode < ? > > inodeChildren = lockList . getInodes ( ) ; for ( Inode < ? > inode : inodeChildren ) { the path to inode for getPath should already be locked . try ( LockedInodePath childPath = mInodeTree . lockFullInodePath ( mInodeTree . getPath ( inode ) , InodeTree . LockMode . READ ) ) { TODO ( gpang ) : a better way to check permissions mPermissionChecker . checkSetAttributePermission ( childPath , rootRequired , ownerRequired ) ; } } TempInodePathForDescendant tempInodePath = new TempInodePathForDescendant ( inodePath ) ; for ( Inode < ? > inode : inodeChildren ) { the path to inode for getPath should already be locked . tempInodePath . setDescendant ( inode , mInodeTree . getPath ( inode ) ) ; List < Inode < ? > > persistedInodes = setAttributeInternal ( tempInodePath , false , opTimeMs , options ) ; journalPersistedInodes ( persistedInodes , journalContext ) ; journalSetAttribute ( tempInodePath , opTimeMs , options , journalContext ) ; } } } List < Inode < ? > > persistedInodes = setAttributeInternal ( inodePath , false , opTimeMs , options ) ; journalPersistedInodes ( persistedInodes , journalContext ) ; journalSetAttribute ( inodePath , opTimeMs , options , journalContext ) ; } 
3965	public void transform ( Message message , DataType from , DataType to ) throws Exception { Exchange exchange = message . getExchange ( ) ; CamelContext context = exchange . getContext ( ) ; Unmarshaling into Java Object if ( ( to = = null | | to . isJavaType ( ) ) & & ( from . equals ( getFrom ( ) ) | | from . getModel ( ) . equals ( getModel ( ) ) ) ) { DataFormat dataFormat = getDataFormat ( exchange ) ; LOG . debug ( _STR ) ; } } 
3966	protected FileConsumer newFileConsumer ( Processor processor , GenericFileOperations < File > operations ) { return new FileConsumer ( this , processor , operations , processStrategy ! = null ? processStrategy : createGenericFileStrategy ( ) ) ; } 
3967	public void testListCommand ( ) throws Exception { String providerPath = getProviderPath ( _STR ) ) ) ; Enumeration enumeration = properties . propertyNames ( ) ; while ( enumeration . hasMoreElements ( ) ) { String alias = ( String ) enumeration . nextElement ( ) ; Assert . assertTrue ( aliases . contains ( alias ) ) ; } } 
3968	public void getTextPath ( String text , int start , int end , float x , float y , Path path ) { if ( ( start | end | ( end - start ) | ( text . length ( ) - end ) ) < _NUM ) { throw new IndexOutOfBoundsException ( ) ; } nGetTextPath ( mNativePaint , mNativeTypeface , mBidiFlags , text , start , end , x , y , path . mutateNI ( ) ) ; } 
3969	public static XmlDuration parse ( java . net . URL u , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( XmlDuration ) XmlBeans . getContextTypeLoader ( ) . parse ( u , type , options ) ; } 
3970	static BooleanExpr createExpr ( XPath xpath , SimpleStreamTokenizer toks ) throws XPathException , IOException { switch ( toks . ttype ) { default : throw new XPathException ( xpath , _STR ) ; tValue = toks . sval ; toks . nextToken ( ) ; return new TextNotEqualsExpr ( tValue ) ; default : return TextExistsExpr . INSTANCE ; } } } 
3971	public void actionMoveElement ( ) throws JspException { set editor values from request try { setEditorValues ( getElementLocale ( ) ) ; } catch ( CmsXmlException e ) { an error occurred while trying to set the values , stop action showErrorPage ( e ) ; return ; } get the necessary parameters to move the element int index = _NUM ; try { index = Integer . parseInt ( getParamElementIndex ( ) ) ; } catch ( Exception e ) { ignore , should not happen } get the value to move I _ CmsXmlContentValue value = m _ content . getValue ( getParamElementName ( ) , getElementLocale ( ) , index ) ; if ( getAction ( ) = = ACTION _ ELEMENT _ MOVE _ DOWN ) { move down the value value . moveDown ( ) ; } else { move up the value value . moveUp ( ) ; } if ( getValidationHandler ( ) . hasWarnings ( getElementLocale ( ) ) ) { there were warnings for the edited content , reset validation handler to avoid display issues resetErrorHandler ( ) ; } try { write the modified content to the temporary file writeContent ( ) ; } catch ( CmsException e ) { an error occurred while trying to save showErrorPage ( e ) ; } } 
3972	BlockInfo listInsert ( BlockInfo head , DatanodeStorageInfo storage ) { int dnIndex = this . findStorageInfo ( storage ) ; assert dnIndex > = _NUM : _STR ; this . setPrevious ( dnIndex , null ) ; this . setNext ( dnIndex , head ) ; if ( head ! = null ) head . setPrevious ( head . findStorageInfo ( storage ) , this ) ; return this ; } 
3973	public static Response getResponse ( final String url ) { return Exceptions . tryIt ( Response . class , new Exceptions . TrialWithReturn < Response > ( ) { @ Override public Response tryIt ( ) throws Exception { URLConnection connection ; final Map < String , String > accept = Maps . map ( _STR ) ; connection = doGet ( url , accept , null , null ) ; return extractResponseObject ( connection ) ; } } ) ; } 
3974	public void chflags ( String resourcename , int flags ) throws CmsException { CmsResource resource = readResource ( resourcename , CmsResourceFilter . IGNORE _ EXPIRATION ) ; getResourceType ( resource ) . chflags ( this , m _ securityManager , resource , flags ) ; } 
3975	public static SocketInputWrapper getInputStream ( Socket socket , long timeout ) throws IOException { InputStream stm = ( socket . getChannel ( ) = = null ) ? socket . getInputStream ( ) : new SocketInputStream ( socket ) ; SocketInputWrapper w = new SocketInputWrapper ( socket , stm ) ; w . setTimeout ( timeout ) ; return w ; } 
3976	public void run ( ) { noinspection ConstantConditions if ( deferEmpty ) { mBoundaryCallback . onZeroItemsLoaded ( ) ; } has been called near to the position if ( deferBegin ) { mBoundaryCallbackBeginDeferred = true ; } if ( deferEnd ) { mBoundaryCallbackEndDeferred = true ; } tryDispatchBoundaryCallbacks ( false ) ; } } ) ; } } 
3977	public boolean isUserAllowedToAccessFile ( String user , String fileName ) { return isUiFilterNotSet ( ) | | isAuthorizedLogUser ( user , fileName ) ; } 
3978	public void shutdownNow ( ) throws Exception { this . server . stop ( ) ; this . server . destroy ( ) ; getFlowRunnerManager ( ) . shutdownNow ( ) ; close ( ) ; } 
3979	public static void fatal ( Throwable t , Object . . . messages ) { _ log ( ) . fatal ( t , messages ) ; } 
3980	 @ Test ( groups = _STR ) ; } finally { cluster . close ( ) ; } } 
3981	public void start ( ) { before ( ) ; } 
3982	public static Typeface createFromResourcesFamilyXml ( @ NonNull Context context , @ NonNull FamilyResourceEntry entry , @ NonNull Resources resources , int id , int style , @ Nullable ResourcesCompat . FontCallback fontCallback , @ Nullable Handler handler , boolean isRequestFromLayoutInflator ) { Typeface typeface ; if ( entry instanceof ProviderResourceEntry ) { ProviderResourceEntry providerEntry = ( ProviderResourceEntry ) entry ; final boolean isBlocking = isRequestFromLayoutInflator ? providerEntry . getFetchStrategy ( ) = = FontResourcesParserCompat . FETCH _ STRATEGY _ BLOCKING : fontCallback = = null ; final int timeout = isRequestFromLayoutInflator ? providerEntry . getTimeout ( ) : FontResourcesParserCompat . INFINITE _ TIMEOUT _ VALUE ; typeface = FontsContractCompat . getFontSync ( context , providerEntry . getRequest ( ) , fontCallback , handler , isBlocking , timeout , style ) ; } else { typeface = sTypefaceCompatImpl . createFromFontFamilyFilesResourceEntry ( context , ( FontFamilyFilesResourceEntry ) entry , resources , style ) ; if ( fontCallback ! = null ) { if ( typeface ! = null ) { fontCallback . callbackSuccessAsync ( typeface , handler ) ; } else { fontCallback . callbackFailAsync ( FontsContractCompat . FontRequestCallback . FAIL _ REASON _ FONT _ LOAD _ ERROR , handler ) ; } } } if ( typeface ! = null ) { sTypefaceCache . put ( createResourceUid ( resources , id , style ) , typeface ) ; } return typeface ; } 
3983	protected DOMStructure getDomStructureForMessageBody ( List < Reference > relevantReferences , List < XMLObject > relevantObjects ) throws Exception { NOPMD List < XMLObject > referencedObjects = getReferencedSameDocumentObjects ( relevantReferences , relevantObjects ) ; if ( referencedObjects . isEmpty ( ) ) { throw new XmlSignatureException ( String . format ( _STR ) ; } XMLStructure structure = structures . get ( _NUM ) ; only dom currently supported DOMStructure domStruc = ( DOMStructure ) structure ; return domStruc ; } 
3984	public Query createNativeQuery ( CmsDbContext dbc , CmsUUID projectId , String queryKey ) { org . opencms . db . jpa . CmsDbContext jpaDbc = ( org . opencms . db . jpa . CmsDbContext ) dbc ; jpaDbc . getEntityManager ( ) . flush ( ) ; String rawSql = readQuery ( projectId , queryKey ) ; return jpaDbc . getEntityManager ( ) . createNativeQuery ( prepareQueryParameters ( rawSql ) . toUpperCase ( ) ) ; } 
3985	public void remove ( Node node ) { if ( node = = null ) return ; if ( node instanceof InnerNode ) { throw new IllegalArgumentException ( _STR + this . toString ( ) ) ; } } finally { netlock . writeLock ( ) . unlock ( ) ; } } 
3986	public boolean equals ( Object other ) { if ( ! ( other instanceof TObjectFloatMap ) ) { return false ; } TObjectFloatMap that = ( TObjectFloatMap ) other ; if ( that . size ( ) ! = this . size ( ) ) { return false ; } try { TObjectFloatIterator iter = this . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; Object key = iter . key ( ) ; float value = iter . value ( ) ; if ( value = = no _ entry _ value ) { if ( ! ( that . get ( key ) = = that . getNoEntryValue ( ) & & that . containsKey ( key ) ) ) { return false ; } } else { if ( value ! = that . get ( key ) ) { return false ; } } } } catch ( ClassCastException ex ) { unused . } return true ; } 
3987	public int getPerPartitionLimit ( QueryOptions options ) { return getLimit ( perPartitionLimit , options ) ; } 
3988	public String getCallingPackage ( ) { try { return ActivityManager . getService ( ) . getCallingPackage ( mToken ) ; } catch ( RemoteException e ) { return null ; } } 
3989	public void testModsCausingHeaderOverlap ( ) throws Exception { IonDatagram dg = values ( _STR , v . get ( _NUM ) ) ; } 
3990	public void setTitleMargin ( int start , int top , int end , int bottom ) { mTitleMarginStart = start ; mTitleMarginTop = top ; mTitleMarginEnd = end ; mTitleMarginBottom = bottom ; requestLayout ( ) ; } 
3991	public void setIgnoreZeroValues ( boolean flag ) { this . ignoreZeroValues = flag ; fireChangeEvent ( ) ; } 
3992	public synchronized void close ( ) throws IOException { if ( mIsClosed ) { return ; } mOutputStream . flush ( ) ; mOutputStream . close ( ) ; LOG . info ( _STR , mTempCheckpoint ) ; mCheckpointManager . update ( mTempCheckpoint ) ; Consider the current log to be complete . completeCurrentLog ( ) ; mIsClosed = true ; } 
3993	public static void writePayload ( final OutputStream out , final HttpRequest request ) throws IOException { if ( request . isMultipart ) { final String boundary = request . boundary ( ) ; for ( final Part part : request . parts ) { write content to cache final ArrayOutput ao = new ArrayOutput ( ) ; writePayload ( part . bodyContents , part . bodyAtts , ao ) ; write boundary preceded by _STR ) . add ( CRLF ) . finish ( ) ) ; } else { writePayload ( request . payload , request . payloadAtts , out ) ; } out . close ( ) ; } 
3994	public Object decode ( PositionedByteRange src , int index ) { assert index > = _NUM ; StructIterator it = iterator ( src . shallowCopy ( ) ) ; for ( ; index > _NUM ; index - - ) { it . skip ( ) ; } return it . next ( ) ; } 
3995	public CharSequence get ( int index ) { return getString ( index ) ; } 
3996	public void reset ( ) throws IOException { if ( reader ! = null & & currentPath ! = null ) { resetReader ( ) ; } } 
3997	public Connection createConnectionAdvice ( ProceedingJoinPoint proceedingJoinPoint ) throws Throwable { perform the underlying operation Connection connection = ( Connection ) proceedingJoinPoint . proceed ( ) ; audit the connection creation final ConnectDetails connectDetails = createConnectDetails ( connection , connection . getRelationships ( ) ) ; final Action action = generateAuditRecordForConnection ( connection , Operation . Connect , connectDetails ) ; save the actions if ( action ! = null ) { saveAction ( action , logger ) ; } return connection ; } 
3998	public boolean isSet ( _ Fields field ) { if ( field = = null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case ARG : return isSetArg ( ) ; } throw new IllegalStateException ( ) ; } 
3999	public KafkaAvroReporter build ( String brokers , String topic , Properties props ) throws IOException { this . brokers = brokers ; this . topic = topic ; create a KafkaAvroReporter with metrics . * and gobblin . kafka . sharedConfig . * keys return new KafkaAvroReporter ( this , KafkaReporter . getKafkaAndMetricsConfigFromProperties ( props ) ) ; } 
4000	public static XmlTime parse ( java . io . File f ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( XmlTime ) XmlBeans . getContextTypeLoader ( ) . parse ( f , type , null ) ; } 
4001	public void testFullRestoreSingleDNECommand ( ) throws Exception { LOG . info ( _STR ) } ; Run restore int ret = ToolRunner . run ( conf _NUM , new RestoreDriver ( ) , args ) ; assertTrue ( ret ! = _NUM ) ; } 
4002	public static String fromBoolean ( Boolean value ) { return Boolean . toString ( value ) ; } 
4003	void checkUp ( ) throws QueryException { final boolean upd = expr . has ( Flag . UPD ) ; if ( upd ) expr . checkUp ( ) ; final InputInfo ii = expr instanceof ParseExpr ? ( ( ParseExpr ) expr ) . info : info ; if ( updating ) { updating function if ( declType ! = null & & ! declType . zero ( ) ) throw UUPFUNCTYPE . get ( info ) ; if ( ! upd & & ! expr . isVacuous ( ) ) throw UPEXPECTF . get ( ii ) ; } else if ( upd ) { uses updates , but is not declared as such throw UPNOT _ X . get ( ii , description ( ) ) ; } } 
4004	public static String formatRfc _NUM _NUM _NUM Date ( Date date ) { return getRfc _NUM _NUM _NUM DateFormat ( ) . format ( date ) ; } 
4005	public static String loadCartFromQuote ( HttpServletRequest request , HttpServletResponse response ) { LocalDispatcher dispatcher = ( LocalDispatcher ) request . getAttribute ( _STR ; } 
4006	public ArrayList < BackupImage > getDependentListByTable ( TableName table ) { ArrayList < BackupImage > tableImageList = new ArrayList < > ( ) ; ArrayList < BackupImage > imageList = getRestoreDependentList ( true ) ; for ( BackupImage image : imageList ) { if ( image . hasTable ( table ) ) { tableImageList . add ( image ) ; if ( image . getType ( ) = = BackupType . FULL ) { break ; } } } Collections . reverse ( tableImageList ) ; return tableImageList ; } 
4007	public void fillLinearGradient ( int startColor , int endColor , int x , int y , int width , int height , boolean horizontal ) { people do that a lot sadly . . . if ( startColor = = endColor ) { setColor ( startColor ) ; fillRect ( x , y , width , height , ( byte ) _NUM xff ) ; return ; } impl . fillLinearGradient ( nativeGraphics , startColor , endColor , x + xTranslate , y + yTranslate , width , height , horizontal ) ; } 
4008	public static Container encloseMiddle ( Component . . . cmps ) { return Container . encloseIn ( new FlowLayout ( Component . LEFT , Component . CENTER ) , cmps ) ; } 
4009	private ColorStateList applyTextAppearance ( Paint p , int resId ) { final TypedArray ta = mContext . obtainStyledAttributes ( null , R . styleable . TextAppearance , _NUM , resId ) ; final String fontFamily = ta . getString ( R . styleable . TextAppearance _ fontFamily ) ; if ( fontFamily ! = null ) { p . setTypeface ( Typeface . create ( fontFamily , _NUM ) ) ; } p . setTextSize ( ta . getDimensionPixelSize ( R . styleable . TextAppearance _ textSize , ( int ) p . getTextSize ( ) ) ) ; final ColorStateList textColor = ta . getColorStateList ( R . styleable . TextAppearance _ textColor ) ; if ( textColor ! = null ) { final int enabledColor = textColor . getColorForState ( ENABLED _ STATE _ SET , _NUM ) ; p . setColor ( enabledColor ) ; } ta . recycle ( ) ; return textColor ; } 
4010	public Object parseValidated ( String str ) { int len = str . length ( ) ; int [ ] date = new int [ TOTAL _ SIZE ] ; int [ ] timeZone = new int [ _NUM ] ; check for preceding ' - ' sign int start = _NUM ; if ( str . charAt ( _NUM ) = = ' - ' ) { start = _NUM ; } int sign = findUTCSign ( str , start , len ) ; if ( sign = = - _NUM ) { date [ CY ] = parseIntYear ( str , len ) ; } else { date [ CY ] = parseIntYear ( str , sign ) ; getTimeZone ( str , date , sign , len , timeZone ) ; } initialize values date [ M ] = MONTH ; date [ D ] = _NUM ; if ( date [ utc ] ! = _NUM & & date [ utc ] ! = ' Z ' ) { AbstractDateTime . normalize ( date , timeZone ) ; } return new XSDDateTime ( date , YEAR _ MASK ) ; } 
4011	public static boolean equalsNormalized ( final String fileName _NUM , final String fileName _NUM ) { return equals ( fileName _NUM , fileName _NUM , true , IOCase . SENSITIVE ) ; } 
4012	public void updateCpuTimeLocked ( boolean updateCpuFreqData ) { if ( mPowerProfile = = null ) { return ; } if ( DEBUG _ ENERGY _ CPU ) { Slog . d ( TAG , _STR ) ; proc . addCpuTimeLocked ( ( int ) mTempTotalCpuUserTimeUs / _NUM _NUM _NUM _NUM , ( int ) mTempTotalCpuSystemTimeUs / _NUM _NUM _NUM _NUM ) ; } } long totalCpuClustersTimeMs = _NUM ; Read the time spent for each cluster at various cpu frequencies . final long [ ] [ ] clusterSpeedTimesMs = new long [ mKernelCpuSpeedReaders . length ] [ ] ; for ( int cluster = _NUM ; cluster < mKernelCpuSpeedReaders . length ; cluster + + ) { clusterSpeedTimesMs [ cluster ] = mKernelCpuSpeedReaders [ cluster ] . readDelta ( ) ; if ( clusterSpeedTimesMs [ cluster ] ! = null ) { for ( int speed = clusterSpeedTimesMs [ cluster ] . length - _NUM ; speed > = _NUM ; - - speed ) { totalCpuClustersTimeMs + = clusterSpeedTimesMs [ cluster ] [ speed ] ; } } } if ( totalCpuClustersTimeMs ! = _NUM ) { We have cpu times per freq aggregated over all uids but we need the times per uid . So , we distribute total time spent by an uid to different cpu freqs based on the amount of time cpu was running at that freq . final int updatedUidsCount = updatedUids . size ( ) ; for ( int i = _NUM ; i < updatedUidsCount ; + + i ) { final Uid u = getUidStatsLocked ( updatedUids . keyAt ( i ) ) ; final long appCpuTimeUs = updatedUids . valueAt ( i ) ; Add the cpu speeds to this UID . final int numClusters = mPowerProfile . getNumCpuClusters ( ) ; if ( u . mCpuClusterSpeedTimesUs = = null | | u . mCpuClusterSpeedTimesUs . length ! = numClusters ) { u . mCpuClusterSpeedTimesUs = new LongSamplingCounter [ numClusters ] [ ] ; } for ( int cluster = _NUM ; cluster < clusterSpeedTimesMs . length ; cluster + + ) { final int speedsInCluster = clusterSpeedTimesMs [ cluster ] . length ; if ( u . mCpuClusterSpeedTimesUs [ cluster ] = = null | | speedsInCluster ! = u . mCpuClusterSpeedTimesUs [ cluster ] . length ) { u . mCpuClusterSpeedTimesUs [ cluster ] = new LongSamplingCounter [ speedsInCluster ] ; } final LongSamplingCounter [ ] cpuSpeeds = u . mCpuClusterSpeedTimesUs [ cluster ] ; for ( int speed = _NUM ; speed < speedsInCluster ; speed + + ) { if ( cpuSpeeds [ speed ] = = null ) { cpuSpeeds [ speed ] = new LongSamplingCounter ( mOnBatteryTimeBase ) ; } cpuSpeeds [ speed ] . addCountLocked ( appCpuTimeUs * clusterSpeedTimesMs [ cluster ] [ speed ] / totalCpuClustersTimeMs ) ; } } } } collection . if ( ArrayUtils . referenceEquals ( mPartialTimers , mLastPartialTimers ) ) { No difference , so each timer is now considered for the next collection . for ( int i = _NUM ; i < numPartialTimers ; i + + ) { mPartialTimers . get ( i ) . mInList = true ; } } else { The lists are different , meaning we added ( or removed a timer ) since the last collection . final int numLastPartialTimers = mLastPartialTimers . size ( ) ; for ( int i = _NUM ; i < numLastPartialTimers ; i + + ) { mLastPartialTimers . get ( i ) . mInList = false ; } mLastPartialTimers . clear ( ) ; Mark the current timers as gone through a collection . for ( int i = _NUM ; i < numPartialTimers ; i + + ) { final StopwatchTimer timer = mPartialTimers . get ( i ) ; timer . mInList = true ; mLastPartialTimers . add ( timer ) ; } } } 
4013	View next ( RecyclerView . Recycler recycler ) { if ( mScrapList ! = null ) { return nextViewFromScrapList ( ) ; } final View view = recycler . getViewForPosition ( mCurrentPosition ) ; mCurrentPosition + = mItemDirection ; return view ; } 
4014	public boolean contains ( Key key ) { return ! beforeStartKey ( key ) & & ! afterEndKey ( key ) ; } 
4015	public void doEventReceived ( Object event ) { log . trace ( _STR , event ) ; use async processor to support async routing engine processor . process ( exchange , new AsyncCallback ( ) { @ Override public void done ( boolean doneSync ) { noop } } ) ; } 
4016	public static XmlByte parse ( java . io . Reader r , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( XmlByte ) XmlBeans . getContextTypeLoader ( ) . parse ( r , type , options ) ; } 
4017	public String getParamElementlanguage ( ) { if ( m _ paramElementlanguage = = null ) { if ( ( m _ editorSessionInfo ! = null ) & & ( m _ editorSessionInfo . getElementLocale ( ) ! = null ) ) { m _ paramElementlanguage = m _ editorSessionInfo . getElementLocale ( ) . toString ( ) ; } } return m _ paramElementlanguage ; } 
4018	static void start ( Config config , AtomicReference < ServerState > serverState , List < StartupCommand > ofbizCommands ) throws StartupException { TODO loaders should be converted to a single loader List < StartupLoader > loaders = new ArrayList < StartupLoader > ( ) ; Thread adminServer = createAdminServer ( config , serverState , loaders ) ; createLogDirectoryIfMissing ( config ) ; createRuntimeShutdownHook ( config , loaders , serverState ) ; loadStartupLoaders ( config , loaders , ofbizCommands , serverState ) ; executeShutdownAfterLoadIfConfigured ( config , loaders , serverState , adminServer ) ; } 
4019	public DescribeSpotFleetRequestsResult withSpotFleetRequestConfigs ( SpotFleetRequestConfig . . . spotFleetRequestConfigs ) { if ( getSpotFleetRequestConfigs ( ) = = null ) setSpotFleetRequestConfigs ( new java . util . ArrayList < SpotFleetRequestConfig > ( spotFleetRequestConfigs . length ) ) ; for ( SpotFleetRequestConfig value : spotFleetRequestConfigs ) { getSpotFleetRequestConfigs ( ) . add ( value ) ; } return this ; } 
4020	public void setTotalWidth ( float totalWidth ) { if ( this . totalWidth = = totalWidth ) return ; this . totalWidth = totalWidth ; totalHeight = _NUM ; calculateWidths ( ) ; calculateHeights ( true ) ; } 
4021	public String getSimOperatorNumeric ( int subId ) { int phoneId = SubscriptionManager . getPhoneId ( subId ) ; return getSimOperatorNumericForPhone ( phoneId ) ; } 
4022	public int getCallState ( ) { try { ITelecomService telecom = getTelecomService ( ) ; if ( telecom ! = null ) { return telecom . getCallState ( ) ; } } catch ( RemoteException e ) { Log . e ( TAG , _STR , e ) ; } return CALL _ STATE _ IDLE ; } 
4023	public void startLegacyVpnPrivileged ( VpnProfile profile , KeyStore keyStore , LinkProperties egress ) { UserManager mgr = UserManager . get ( mContext ) ; UserInfo user = mgr . getUserInfo ( mUserHandle ) ; if ( user . isRestricted ( ) | | mgr . hasUserRestriction ( UserManager . DISALLOW _ CONFIG _ VPN , new UserHandle ( mUserHandle ) ) ) { throw new SecurityException ( _STR ) ) ; } startLegacyVpn ( config , racoon , mtpd ) ; } 
4024	public WriteTimeoutException copy ( InetSocketAddress address ) { return new WriteTimeoutException ( address , getMessage ( ) , this , getConsistencyLevel ( ) , getWriteType ( ) , getReceivedAcknowledgements ( ) , getRequiredAcknowledgements ( ) ) ; } 
4025	void cancelTasks ( ) throws InterruptedException { Collection < Future < Void > > tasks = futures ; LOG . debug ( _STR + name ) ; for ( Future < Void > f : tasks ) { f . cancel ( false ) ; } evict remaining tasks and futures from taskPool . futures . clear ( ) ; while ( taskPool . poll ( ) ! = null ) { } stop ( ) ; } 
4026	public static boolean equal ( final Object o _NUM , final Object o _NUM ) { if ( o _NUM = = o _NUM ) { return true ; } if ( o _NUM ! = null ) { return o _NUM . equals ( o _NUM ) ; } else { return false ; } } 
4027	public void endElement ( final String uri , final String localName , final String qName ) throws SAXException { try { getCurrentHandler ( ) . endElement ( qName ) ; } catch ( XmlReaderException xre ) { throw new ParseException ( xre , getLocator ( ) ) ; } } 
4028	public static PutObjectRequest encryptRequestUsingMetadata ( PutObjectRequest request , EncryptionMaterials materials , Provider cryptoProvider ) { Create instruction EncryptionInstruction instruction = EncryptionUtils . generateInstruction ( materials , cryptoProvider ) ; Encrypt the object data with the instruction PutObjectRequest encryptedObjectRequest = EncryptionUtils . encryptRequestUsingInstruction ( request , instruction ) ; Update the metadata EncryptionUtils . updateMetadataWithEncryptionInstruction ( request , instruction ) ; return encryptedObjectRequest ; } 
4029	public static String getRequestedServerPrefix ( ) { HttpServletRequest request = BroadleafRequestContext . getBroadleafRequestContext ( ) . getRequest ( ) ; String scheme = request . getScheme ( ) ; StringBuilder serverPrefix = new StringBuilder ( scheme ) ; serverPrefix . append ( _STR ) ; serverPrefix . append ( request . getServerPort ( ) ) ; } return serverPrefix . toString ( ) ; } 
4030	public static ActivityOptions makeCustomAnimation ( Context context , int enterResId , int exitResId , Handler handler , OnAnimationStartedListener listener ) { ActivityOptions opts = new ActivityOptions ( ) ; opts . mPackageName = context . getPackageName ( ) ; opts . mAnimationType = ANIM _ CUSTOM ; opts . mCustomEnterResId = enterResId ; opts . mCustomExitResId = exitResId ; opts . setOnAnimationStartedListener ( handler , listener ) ; return opts ; } 
4031	public Conduit selectConduit ( Message message ) { Conduit c = message . get ( Conduit . class ) ; if ( c = = null ) { c = getSelectedConduit ( message ) ; message . put ( Conduit . class , c ) ; } return c ; } 
4032	private void handleSuccessOK ( BlockingSession ss , RouteResultsetNode rrn , boolean autocommit , OkPacket ok ) { if ( decrementCountAndIsZero ( ) ) { if ( isFail . get ( ) ) { notifyFailure ( ss ) ; return ; } try { ServerConnection source = ss . getSource ( ) ; OK _ PACKET ok . packetId = + + packetId ; ok . affectedRows = affectedRows ; if ( insertId > _NUM ) { ok . insertId = insertId ; source . setLastInsertId ( insertId ) ; } if ( source . isAutocommit ( ) ) { if ( ! autocommit ) { å‰ ç«¯ éž äº‹ åŠ¡ æ¨¡ å¼ ï¼Œ åŽ ç«¯ äº‹ åŠ¡ æ¨¡ å¼ ï¼Œ åˆ™ éœ€ è¦ è‡ª åŠ¨ é€’ äº¤ åŽ ç«¯ äº‹ åŠ¡ ã€‚ icExecutor . commit ( ok , ss , ss . getTarget ( ) . size ( ) ) ; } else { ss . release ( ) ; ok . write ( source ) ; } } else { ok . write ( source ) ; } source . recycle ( buffer ) ; } catch ( Exception e ) { LOGGER . warn ( _STR + ss . getSource ( ) , e ) ; } } } 
4033	public static synchronized FontDetails getFontDetails ( Font font ) { figure out which one to use and load it if ( fontMetricsProps = = null ) { try { fontMetricsProps = loadMetrics ( ) ; } catch ( IOException e ) { throw new RuntimeException ( _STR + fontStyle ; } Get the details on this font FontDetails fontDetails = fontDetailsMap . get ( fontName ) ; if ( fontDetails = = null ) { fontDetails = FontDetails . create ( fontName , fontMetricsProps ) ; fontDetailsMap . put ( fontName , fontDetails ) ; } return fontDetails ; } 
4034	public void datasetChanged ( DatasetChangeEvent e ) { updating ) . . . if ( this . autoWidth ) { this . autoIntervalWidth = recalculateInterval ( ) ; } } 
4035	protected MappedProperty < ? > createMappedProperty ( Class < ? > mappedClass , String propertyName , String mappedName , Field field , Method getter , Method setter , Map < Class < ? extends Annotation > , Annotation > annotations ) { return DefaultMappedProperty . create ( mappedClass , propertyName , mappedName , field , getter , setter , annotations ) ; } 
4036	public XWPFDefaultParagraphStyle getDefaultParagraphStyle ( ) { ensureDocDefaults ( ) ; return defaultParaStyle ; } 
4037	public Object getNativeTransform ( ) { if ( dirty ) { initNativeTransform ( ) ; } return nativeTransform ; } 
4038	public Map < String , Object > invoke ( ServiceDispatcher dispatcher , String localName , Map < String , Object > context ) throws GenericServiceException { DispatchContext dctx = dispatcher . getLocalContext ( localName ) ; ModelService model = dctx . getModelService ( getName ( ) ) ; if ( model = = null ) throw new GenericServiceException ( _STR , module ) ; return dispatcher . runSync ( localName , model , thisContext ) ; } else { dispatcher . runAsync ( localName , model , thisContext , false ) ; return new HashMap < String , Object > ( ) ; } } else { return dispatcher . runSync ( localName , model , thisContext ) ; } } 
4039	public void testTasksBlock ( ) throws Exception { ApplicationId appId = ApplicationIdPBImpl . newInstance ( _NUM , _NUM ) ; JobId jobId = new JobIdPBImpl ( ) ; jobId . setId ( _NUM ) ; jobId . setAppId ( appId ) ; TaskId taskId = new TaskIdPBImpl ( ) ; taskId . setId ( _NUM ) ; taskId . setTaskType ( TaskType . MAP ) ; taskId . setJobId ( jobId ) ; Task task = mock ( Task . class ) ; when ( task . getID ( ) ) . thenReturn ( taskId ) ; TaskReport report = mock ( TaskReport . class ) ; when ( report . getProgress ( ) ) . thenReturn ( _NUM . _NUM f ) ; when ( report . getTaskState ( ) ) . thenReturn ( TaskState . SUCCEEDED ) ; when ( report . getStartTime ( ) ) . thenReturn ( _NUM _NUM _NUM _NUM _NUM _NUM L ) ; when ( report . getFinishTime ( ) ) . thenReturn ( _NUM _NUM _NUM _NUM _NUM _NUM L ) ; when ( report . getStatus ( ) ) . thenReturn ( _STR ) ) ; } 
4040	public LongStreamEx skipOrdered ( long n ) { Spliterator . OfLong spliterator = ( isParallel ( ) ? StreamSupport . longStream ( spliterator ( ) , false ) : stream ( ) ) . skip ( n ) . spliterator ( ) ; return delegate ( spliterator ) ; } 
4041	private String decodeFlags ( int flags ) { StringBuffer result = new StringBuffer ( ) ; result . append ( ( flags & FLAG _ GROUP ) ! = _NUM ? _STR ) ; need to check , else blows up on some records - bug _NUM _NUM _NUM _NUM _NUM if ( result . length ( ) > _NUM ) { result . deleteCharAt ( _NUM ) ; } return result . toString ( ) ; } 
4042	public void evictBlocks ( long bytesNeeded ) throws IOException { int iterations = _NUM ; final long cacheCapacity = cacheManager . getCacheCapacity ( ) ; while ( iterations + + < MAX _ BLOCK _ EVICTIONS _ PER _ ITERATION & & ( cacheCapacity - cacheManager . getCacheUsed ( ) ) < bytesNeeded ) { RamDiskReplica replicaState = ramDiskReplicaTracker . getNextCandidateForEviction ( ) ; if ( replicaState = = null ) { break ; } if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( _STR + replicaState ) ; } ReplicaInfo replicaInfo , newReplicaInfo ; File blockFile , metaFile ; long blockFileUsed , metaFileUsed ; final String bpid = replicaState . getBlockPoolId ( ) ; synchronized ( FsDatasetImpl . this ) { replicaInfo = getReplicaInfo ( replicaState . getBlockPoolId ( ) , replicaState . getBlockId ( ) ) ; Preconditions . checkState ( replicaInfo . getVolume ( ) . isTransientStorage ( ) ) ; blockFile = replicaInfo . getBlockFile ( ) ; metaFile = replicaInfo . getMetaFile ( ) ; blockFileUsed = blockFile . length ( ) ; metaFileUsed = metaFile . length ( ) ; ramDiskReplicaTracker . discardReplica ( replicaState . getBlockPoolId ( ) , replicaState . getBlockId ( ) , false ) ; Move the replica from lazyPersist / to finalized / on the target volume BlockPoolSlice bpSlice = replicaState . getLazyPersistVolume ( ) . getBlockPoolSlice ( bpid ) ; File newBlockFile = bpSlice . activateSavedReplica ( replicaInfo , replicaState . getSavedMetaFile ( ) , replicaState . getSavedBlockFile ( ) ) ; newReplicaInfo = new FinalizedReplica ( replicaInfo . getBlockId ( ) , replicaInfo . getBytesOnDisk ( ) , replicaInfo . getGenerationStamp ( ) , replicaState . getLazyPersistVolume ( ) , newBlockFile . getParentFile ( ) ) ; Update the volumeMap entry . volumeMap . add ( bpid , newReplicaInfo ) ; Update metrics datanode . getMetrics ( ) . incrRamDiskBlocksEvicted ( ) ; datanode . getMetrics ( ) . addRamDiskBlocksEvictionWindowMs ( Time . monotonicNow ( ) - replicaState . getCreationTime ( ) ) ; if ( replicaState . getNumReads ( ) = = _NUM ) { datanode . getMetrics ( ) . incrRamDiskBlocksEvictedWithoutRead ( ) ; } Delete the block + meta files from RAM disk and release locked memory . removeOldReplica ( replicaInfo , newReplicaInfo , blockFile , metaFile , blockFileUsed , metaFileUsed , bpid ) ; } } } 
4043	protected Component createStatusBar ( ) { if ( getUIManager ( ) . isThemeConstant ( _STR ) ; return bar ; } } 
4044	protected void applyToXYItemRenderer ( XYItemRenderer renderer ) { if ( renderer = = null ) { throw new IllegalArgumentException ( _STR ) ; } if ( renderer instanceof AbstractRenderer ) { applyToAbstractRenderer ( ( AbstractRenderer ) renderer ) ; } renderer . setBaseItemLabelFont ( this . regularFont ) ; renderer . setBaseItemLabelPaint ( this . itemLabelPaint ) ; if ( renderer instanceof XYBarRenderer ) { XYBarRenderer br = ( XYBarRenderer ) renderer ; br . setBarPainter ( this . xyBarPainter ) ; br . setShadowVisible ( this . shadowVisible ) ; } } 
4045	public void connect ( HttpConsumer consumer ) throws Exception { Make sure that there is a connector for the requested endpoint . JettyHttpEndpoint endpoint = ( JettyHttpEndpoint ) consumer . getEndpoint ( ) ; String connectorKey = getConnectorKey ( endpoint ) ; synchronized ( CONNECTORS ) { ConnectorRef connectorRef = CONNECTORS . get ( connectorKey ) ; if ( connectorRef = = null ) { Server server = createServer ( ) ; Connector connector = getConnector ( server , endpoint ) ; if ( _STR , newHandlers ) ; connectorRef . server . stop ( ) ; addJettyHandlers ( connectorRef . server , endpoint . getHandlers ( ) ) ; connectorRef . server . start ( ) ; } } ref track the connector connectorRef . increment ( ) ; } check the session support if ( endpoint . isSessionSupport ( ) ) { enableSessionSupport ( connectorRef . server , connectorKey ) ; } if ( endpoint . isEnableMultipartFilter ( ) ) { enableMultipartFilter ( endpoint , connectorRef . server , connectorKey ) ; } if ( endpoint . getFilters ( ) ! = null & & endpoint . getFilters ( ) . size ( ) > _NUM ) { setFilters ( endpoint , connectorRef . server , connectorKey ) ; } connectorRef . servlet . connect ( consumer ) ; } } 
4046	public final StatusBarNotification [ ] getSnoozedNotifications ( ) { try { ParceledListSlice < StatusBarNotification > parceledList = getNotificationInterface ( ) . getSnoozedNotificationsFromListener ( mWrapper , TRIM _ FULL ) ; return cleanUpNotificationList ( parceledList ) ; } catch ( android . os . RemoteException ex ) { Log . v ( TAG , _STR , ex ) ; } return null ; } 
4047	 @ Overrideint lookForSelectablePosition ( int position , boolean lookDown ) { final ListAdapter adapter = mAdapter ; if ( adapter = = null | | isInTouchMode ( ) ) { return INVALID _ POSITION ; } final int count = adapter . getCount ( ) ; if ( ! mAreAllItemsSelectable ) { if ( lookDown ) { position = Math . max ( _NUM , position ) ; while ( position < count & & ! adapter . isEnabled ( position ) ) { position + + ; } } else { position = Math . min ( position , count - _NUM ) ; while ( position > = _NUM & & ! adapter . isEnabled ( position ) ) { position - - ; } } } if ( position < _NUM | | position > = count ) { return INVALID _ POSITION ; } return position ; } 
4048	private CmsPublishResource createPublishResource ( CmsResource resource , List < CmsResource > pubList , Set < CmsResource > allPubRes , Set < CmsResource > published , ResourcesAndRelated permissions , ResourcesAndRelated locked ) { List < CmsPublishResource > related = getRelatedResources ( resource , allPubRes , published , permissions , locked ) ; CmsPublishResourceInfo info = getResourceInfo ( resource , published , permissions , locked ) ; CmsPublishResource pubResource = resourceToBean ( resource , info , pubList . contains ( resource ) , related ) ; return pubResource ; } 
4049	public static String ifNotEmpty ( String base , String pre , String post ) { if ( UtilValidate . isNotEmpty ( base ) ) return pre + base + post ; else return _STR ; } 
4050	public S parse ( Reader inputReader ) { S result = null ; try { getLexer ( ) . setInput ( inputReader ) ; initializeLookAheadBuffer ( ) ; result = parse ( ) ; } catch ( LexerException le ) { throw new ParserException ( _STR + le . getCurrentPositionInInputExceptionThrown ( ) , le ) ; } return result ; } 
4051	void relayoutTaskViewsOnNextFrame ( AnimationProps animation ) { mDeferredTaskViewLayoutAnimation = animation ; invalidate ( ) ; } 
4052	public int [ ] predict ( INDArray input ) { INDArray output = output ( input ) ; int [ ] ret = new int [ input . rows ( ) ] ; for ( int i = _NUM ; i < ret . length ; i + + ) ret [ i ] = Nd _NUM j . getBlasWrapper ( ) . iamax ( output . getRow ( i ) ) ; return ret ; } 
4053	public void estimateCPTs ( BayesNet bayesNet ) throws Exception { initCPTs ( bayesNet ) ; Compute counts Enumeration enumInsts = bayesNet . m _ Instances . enumerateInstances ( ) ; while ( enumInsts . hasMoreElements ( ) ) { Instance instance = ( Instance ) enumInsts . nextElement ( ) ; updateClassifier ( bayesNet , instance ) ; } } 
4054	protected final void executeLifecycle ( HttpAction action ) { And also HTTP counter CounterSet csService = action . getDataService ( ) . getCounters ( ) ; CounterSet csOperation = null ; if ( action . getEndpoint ( ) ! = null ) Direct naming GSP does not have an _STR . csOperation = action . getEndpoint ( ) . getCounters ( ) ; incCounter ( csService , Requests ) ; incCounter ( csOperation , Requests ) ; or in execution in perform . try { validate ( action ) ; } catch ( ActionErrorException ex ) { incCounter ( csOperation , RequestsBad ) ; incCounter ( csService , RequestsBad ) ; throw ex ; } try { perform ( action ) ; Success incCounter ( csOperation , RequestsGood ) ; incCounter ( csService , RequestsGood ) ; } catch ( ActionErrorException | QueryCancelledException | RuntimeIOException ex ) { incCounter ( csOperation , RequestsBad ) ; incCounter ( csService , RequestsBad ) ; throw ex ; } } 
4055	public JsonWriter value ( String value ) throws IOException { if ( value = = null ) { return nullValue ( ) ; } beforeValue ( false ) ; string ( value ) ; return this ; } 
4056	public void flush ( ) { for ( int index = _NUM ; index < eventConnectors . size ( ) ; index + + ) { EventConnector eventConnector = null ; try { eventConnector = eventConnectors . get ( index ) ; if ( eventConnector instanceof ClientProxy ) { ServiceProxyUtils . flushServiceProxy ( eventConnector ) ; } else { eventConnector . flush ( ) ; } } catch ( Exception ex ) { logger . debug ( _STR , ex ) ; if ( eventConnector instanceof RemoteTCPClientProxy ) { if ( ! ( ( RemoteTCPClientProxy ) eventConnector ) . connected ( ) ) { eventConnectors . remove ( eventConnector ) ; } } } } } 
4057	public byte [ ] getNTLMv _NUM Hash ( ) throws NTLMEngineException { if ( ntlmv _NUM Hash = = null ) ntlmv _NUM Hash = ntlmv _NUM Hash ( target , user , password ) ; return ntlmv _NUM Hash ; } 
4058	public void processAsMuchUncommittedRequestsAsPossibleTest ( ) throws Exception { final String path = _STR , shouldNotBeProcessed . removeAll ( processedRequests ) ) ; } 
4059	protected String getUserComment ( ) { IfdData ifdData = mIfdDatas [ IfdId . TYPE _ IFD _ _NUM ] ; if ( ifdData = = null ) { return null ; } ExifTag tag = ifdData . getTag ( ExifInterface . getTrueTagKey ( ExifInterface . TAG _ USER _ COMMENT ) ) ; if ( tag = = null ) { return null ; } if ( tag . getComponentCount ( ) < _NUM ) { return null ; } byte [ ] buf = new byte [ tag . getComponentCount ( ) ] ; tag . getBytes ( buf ) ; byte [ ] code = new byte [ _NUM ] ; System . arraycopy ( buf , _NUM , code , _NUM , _NUM ) ; try { if ( Arrays . equals ( code , USER _ COMMENT _ ASCII ) ) { return new String ( buf , _NUM , buf . length - _NUM , _STR ) ; return null ; } } 
4060	public E removeLast ( ) { return removeLastImpl ( ) ; } 
4061	public List < DeterministicKey > freshKeys ( KeyChain . KeyPurpose purpose , int numberOfKeys ) { List < DeterministicKey > keys ; keyChainGroupLock . lock ( ) ; try { maybeUpgradeToHD ( ) ; keys = keyChainGroup . freshKeys ( purpose , numberOfKeys ) ; } finally { keyChainGroupLock . unlock ( ) ; } Do we really need an immediate hard save ? Arguably all this is doing is saving the ' current ' key and that ' s not quite so important , so we could coalesce for more performance . saveNow ( ) ; return keys ; } 
4062	private int parseUTF _NUM Char ( ) throws IOException { int ch = _ offset < _ length ? ( _ buffer [ _ offset + + ] & _NUM xff ) : read ( ) ; if ( ch < _NUM x _NUM _NUM ) return ch ; else if ( ( ch & _NUM xe _NUM ) = = _NUM xc _NUM ) { int ch _NUM = read ( ) ; int v = ( ( ch & _NUM x _NUM f ) < < _NUM ) + ( ch _NUM & _NUM x _NUM f ) ; return v ; } else if ( ( ch & _NUM xf _NUM ) = = _NUM xe _NUM ) { int ch _NUM = read ( ) ; int ch _NUM = read ( ) ; int v = ( ( ch & _NUM x _NUM f ) < < _NUM _NUM ) + ( ( ch _NUM & _NUM x _NUM f ) < < _NUM ) + ( ch _NUM & _NUM x _NUM f ) ; return v ; } else throw error ( _STR + codeName ( ch ) ) ; } 
4063	public void send ( Context context , int code , @ Nullable Intent intent , @ Nullable OnFinished onFinished , @ Nullable Handler handler , @ Nullable String requiredPermission , @ Nullable Bundle options ) throws CanceledException { try { String resolvedType = intent ! = null ? intent . resolveTypeIfNeeded ( context . getContentResolver ( ) ) : null ; int res = ActivityManager . getService ( ) . sendIntentSender ( mTarget , mWhitelistToken , code , intent , resolvedType , onFinished ! = null ? new FinishedDispatcher ( this , onFinished , handler ) : null , requiredPermission , options ) ; if ( res < _NUM ) { throw new CanceledException ( ) ; } } catch ( RemoteException e ) { throw new CanceledException ( e ) ; } } 
4064	public JavaRDD < String > toJavaRDDStringIJV ( ) { return MLContextConversionUtil . frameObjectToJavaRDDStringIJV ( frameObject ) ; } 
4065	private static ReplicaRecoveryInfo callInitReplicaRecovery ( InterDatanodeProtocol datanode , RecoveringBlock rBlock ) throws IOException { try { return datanode . initReplicaRecovery ( rBlock ) ; } catch ( RemoteException re ) { throw re . unwrapRemoteException ( ) ; } } 
4066	public static void close ( Writer writer , FileOutputStream os , String name , Logger log , boolean force ) { if ( writer ! = null & & force ) { flush the writer prior to syncing the FD try { writer . flush ( ) ; } catch ( Exception e ) { if ( log = = null ) { then fallback to use the own Logger log = LOG ; } if ( name ! = null ) { log . warn ( _STR + e . getMessage ( ) , e ) ; } } force ( os , name , log ) ; } close ( writer , name , log ) ; } 
4067	private static Policy readSignerOrThrow ( XmlPullParser parser ) throws IOException , XmlPullParserException { parser . require ( XmlPullParser . START _ TAG , null , _STR ) ; pb . addSignature ( sig ) ; readCert ( parser ) ; } else { skip ( parser ) ; } } return pb . build ( ) ; } 
4068	void addTask ( Task task , int position , boolean showForAllUsers , boolean moveParents ) { final TaskStack currentStack = task . mStack ; This doesn ' t make sense , mStack will already be set equal to _STR + task . mStack . mStackId ) ; } Add child task . task . mStack = this ; addChild ( task , null ) ; Move child to a proper position , as some restriction for position might apply . positionChildAt ( position , task , moveParents , showForAllUsers ) ; } 
4069	public final String [ ] readStringArray ( ) { String [ ] array = null ; int length = readInt ( ) ; if ( length > = _NUM ) { array = new String [ length ] ; for ( int i = _NUM ; i < length ; i + + ) { array [ i ] = readString ( ) ; } } return array ; } 
4070	private URL extractActualUrl ( URL jarUrl ) throws MalformedURLException { String urlFile = jarUrl . getFile ( ) ; int separatorIndex = urlFile . indexOf ( _STR + jarFile ) ; } } else { return jarUrl ; } } 
4071	public void unknownFunction ( ) { try { get ( _STR ) ) ; } } 
4072	public void setTransitionGenerator ( TransitionGenerator transgen ) { mTransGen = transgen ; startNewTransition ( ) ; } 
4073	private void createCredentialsProvider ( final Context context , final ClientConfiguration clientConfiguration ) { Log . d ( LOG _ TAG , _STR ) ; final String region = getCognitoIdentityRegion ( ) ; final Regions cognitoIdentityRegion = Regions . fromName ( region ) ; final AWSRefreshingCognitoIdentityProvider refreshingCredentialsProvider = new AWSRefreshingCognitoIdentityProvider ( null , getCognitoIdentityPoolId ( ) , clientConfiguration , cognitoIdentityRegion ) ; credentialsProviderHolder . setUnderlyingProvider ( new CognitoCachingCredentialsProvider ( context , refreshingCredentialsProvider , cognitoIdentityRegion , clientConfiguration ) ) ; } 
4074	public Reader getConfResourceAsReader ( String name ) { try { URL url = getResource ( name ) ; if ( url = = null ) { LOG . info ( name + _STR + url ) ; } return new InputStreamReader ( url . openStream ( ) , Charsets . UTF _ _NUM ) ; } catch ( Exception e ) { return null ; } } 
4075	public static void main ( String [ ] args ) { try { RemoteExperiment exp = null ; get options from XML ? String xmlOption = Utils . getOption ( _STR ) ; exp . postProcess ( ) ; } } catch ( Exception ex ) { ex . printStackTrace ( ) ; System . err . println ( ex . getMessage ( ) ) ; } } 
4076	public Collection < SourceSequence > getAllUnacknowledgedSequences ( ) { Collection < SourceSequence > seqs = new ArrayList < > ( ) ; for ( SourceSequence seq : map . values ( ) ) { if ( ! seq . allAcknowledged ( ) ) { seqs . add ( seq ) ; } } return seqs ; } 
4077	public final boolean performGlobalAction ( int action ) { final IAccessibilityServiceConnection connection ; synchronized ( mLock ) { throwIfNotConnectedLocked ( ) ; connection = AccessibilityInteractionClient . getInstance ( ) . getConnection ( mConnectionId ) ; } Calling out without a lock held . if ( connection ! = null ) { try { return connection . performGlobalAction ( action ) ; } catch ( RemoteException re ) { Log . w ( LOG _ TAG , _STR , re ) ; } } return false ; } 
4078	protected boolean executeUpdate ( Document document , String xpath , boolean forReal ) { Node node = document . selectSingleNode ( xpath ) ; if ( node = = null ) { int pos = getXPathsToUpdate ( ) . indexOf ( xpath ) ; CmsSetupXmlHelper . setValue ( document , xpath + _STR + I _ CmsXmlConfiguration . A _ TYPE , m _ mimeTypes [ pos ] [ _NUM ] ) ; return true ; } return false ; } 
4079	public static void main ( String [ ] args ) throws IllegalAccessException { List < Field > fields = Arrays . asList ( GiraphConstants . class . getFields ( ) ) ; List < AbstractConfOption > options = new ArrayList < > ( ) ; for ( Field field : fields ) { if ( AbstractConfOption . class . isAssignableFrom ( field . getType ( ) ) ) { AbstractConfOption option = ( AbstractConfOption ) field . get ( null ) ; options . add ( option ) ; } } file in which to write the HTML version of the list of available options if ( args . length = = _NUM ) { String html = allOptionsHTMLString ( options ) ; try { FileWriter fs = new FileWriter ( args [ _NUM ] ) ; BufferedWriter out = new BufferedWriter ( fs ) ; out . write ( html ) ; out . close ( ) ; } catch ( IOException e ) { LOG . error ( _STR + e . getMessage ( ) ) ; } } LOG . info ( allOptionsString ( options ) ) ; } 
4080	public EuiccInfo getEuiccInfo ( ) { if ( ! isEnabled ( ) ) { return null ; } try { return getIEuiccController ( ) . getEuiccInfo ( ) ; } catch ( RemoteException e ) { throw e . rethrowFromSystemServer ( ) ; } } 
4081	public void multiply ( Matrix _NUM f rhs ) { Matrix _NUM f tmp = new Matrix _NUM f ( ) ; tmp . loadMultiply ( this , rhs ) ; load ( tmp ) ; } 
4082	private List < XWPFStyle > getUsedStyleList ( XWPFStyle style , List < XWPFStyle > usedStyleList ) { String basisStyleID = style . getBasisStyleID ( ) ; XWPFStyle basisStyle = getStyle ( basisStyleID ) ; if ( ( basisStyle ! = null ) & & ( ! usedStyleList . contains ( basisStyle ) ) ) { usedStyleList . add ( basisStyle ) ; getUsedStyleList ( basisStyle , usedStyleList ) ; } String linkStyleID = style . getLinkStyleID ( ) ; XWPFStyle linkStyle = getStyle ( linkStyleID ) ; if ( ( linkStyle ! = null ) & & ( ! usedStyleList . contains ( linkStyle ) ) ) { usedStyleList . add ( linkStyle ) ; getUsedStyleList ( linkStyle , usedStyleList ) ; } String nextStyleID = style . getNextStyleID ( ) ; XWPFStyle nextStyle = getStyle ( nextStyleID ) ; if ( ( nextStyle ! = null ) & & ( ! usedStyleList . contains ( nextStyle ) ) ) { usedStyleList . add ( linkStyle ) ; getUsedStyleList ( linkStyle , usedStyleList ) ; } return usedStyleList ; } 
4083	public static byte [ ] encodeBase _NUM _NUM URLSafe ( byte [ ] binaryData ) { return encodeBase _NUM _NUM ( binaryData , false , true ) ; } 
4084	public void dispatchTrackballEvent ( int seq , MotionEvent event , EventCallback callback ) { boolean handled = onTrackballEvent ( event ) ; if ( callback ! = null ) { callback . finishedEvent ( seq , handled ) ; } } 
4085	private void runCommand ( ) throws IOException { ProcessBuilder builder = new ProcessBuilder ( getExecString ( ) ) ; Timer timeOutTimer = null ; ShellTimeoutTimerTask timeoutTimerTask = null ; timedOut = new AtomicBoolean ( false ) ; completed = new AtomicBoolean ( false ) ; if ( environment ! = null ) { builder . environment ( ) . putAll ( this . environment ) ; } if ( dir ! = null ) { builder . directory ( this . dir ) ; } process = builder . start ( ) ; if ( timeOutInterval > _NUM ) { timeOutTimer = new Timer ( ) ; timeoutTimerTask = new ShellTimeoutTimerTask ( this ) ; One time scheduling . timeOutTimer . schedule ( timeoutTimerTask , timeOutInterval ) ; } final BufferedReader errReader = new BufferedReader ( new InputStreamReader ( process . getErrorStream ( ) ) ) ; BufferedReader inReader = new BufferedReader ( new InputStreamReader ( process . getInputStream ( ) ) ) ; final StringBuffer errMsg = new StringBuffer ( ) ; read error and input streams as this would free up the buffers free the error stream buffer Thread errThread = new Thread ( ) { @ Override public void run ( ) { try { String line = errReader . readLine ( ) ; while ( ( line ! = null ) & & ! isInterrupted ( ) ) { errMsg . append ( line ) ; errMsg . append ( System . getProperty ( _STR , ioe ) ; } process . destroy ( ) ; lastTime = Time . currentElapsedTime ( ) ; } } 
4086	TrieEntry < K , V > lowerEntry ( K key ) { Basically : Follow the steps of adding an entry , but instead . . . - If we ever encounter a situation where we found an equal key , we return it ' s previousEntry immediately . - If we hit root ( empty or not ) , return null . - If we have to add a new item , we temporarily add it , find the previousEntry to it , then remove the added item . These steps ensure that the returned value is always just before the key or null ( if there was nothing before it ) . TODO : Cleanup so that we don ' t actually have to add / remove from the tree . ( We do it here because there are other well - defined functions to perform the search . ) int lengthInBits = lengthInBits ( key ) ; if ( lengthInBits = = _NUM ) there can never be anything before root . return null ; TrieEntry < K , V > found = getNearestEntryForKey ( key ) ; if ( compareKeys ( key , found . key ) ) return previousEntry ( found ) ; int bitIndex = bitIndex ( key , found . key ) ; if ( Tries . isValidBitIndex ( bitIndex ) ) { return replaceLower ( key , bitIndex ) ; } else if ( Tries . isNullBitKey ( bitIndex ) ) { return null ; } else if ( Tries . isEqualBitKey ( bitIndex ) ) { return previousEntry ( found ) ; } we should have exited above . throw new IllegalStateException ( _STR + key ) ; } 
4087	public void setMode ( @ Mode int mode ) { log . i ( _STR , LayoutUtils . getModeName ( mode ) ) ; if ( mMode = = SINGLE & & mode = = IDLE ) { clearSelection ( ) ; } this . mMode = mode ; this . mLastItemInActionMode = ( mode ! = MULTI ) ; } 
4088	public void testLargeList ( ) throws Exception { final int thresholdBytes = _NUM _NUM _NUM * _NUM _NUM _NUM _NUM ; final int objectCount = thresholdBytes / measureLargeObject ( ) ; List < LargeObject > list = new ArrayList < LargeObject > ( ) ; for ( int i = _NUM ; i < objectCount ; i + + ) { list . add ( new LargeObject ( i * _NUM , ( i * _NUM ) + _NUM , ( i * _NUM ) + _NUM , ( i * _NUM ) + _NUM , ( i * _NUM ) + _NUM ) ) ; } ParceledListSlice < LargeObject > slice ; Parcel parcel = Parcel . obtain ( ) ; try { parcel . writeParcelable ( new ParceledListSlice < LargeObject > ( list ) , _NUM ) ; parcel . setDataPosition ( _NUM ) ; slice = parcel . readParcelable ( getClass ( ) . getClassLoader ( ) ) ; } finally { parcel . recycle ( ) ; } assertNotNull ( slice ) ; assertNotNull ( slice . getList ( ) ) ; assertEquals ( objectCount , slice . getList ( ) . size ( ) ) ; for ( int i = _NUM ; i < objectCount ; i + + ) { assertEquals ( i * _NUM , slice . getList ( ) . get ( i ) . mFieldA ) ; assertEquals ( ( i * _NUM ) + _NUM , slice . getList ( ) . get ( i ) . mFieldB ) ; assertEquals ( ( i * _NUM ) + _NUM , slice . getList ( ) . get ( i ) . mFieldC ) ; assertEquals ( ( i * _NUM ) + _NUM , slice . getList ( ) . get ( i ) . mFieldD ) ; assertEquals ( ( i * _NUM ) + _NUM , slice . getList ( ) . get ( i ) . mFieldE ) ; } } 
4089	public char readChar ( ) throws java . io . IOException { if ( inBuf > _NUM ) { - - inBuf ; if ( + + bufpos = = bufsize ) bufpos = _NUM ; return buffer [ bufpos ] ; } char c ; if ( + + bufpos = = available ) AdjustBuffSize ( ) ; if ( ( buffer [ bufpos ] = c = ReadByte ( ) ) = = ' \ \ ' ) { UpdateLineColumn ( c ) ; int backSlashCnt = _NUM ; for ( ; ; ) Read all the backslashes { if ( + + bufpos = = available ) AdjustBuffSize ( ) ; try { if ( ( buffer [ bufpos ] = c = ReadByte ( ) ) ! = ' \ \ ' ) { UpdateLineColumn ( c ) ; found a non - backslash char . if ( ( c = = ' u ' ) & & ( ( backSlashCnt & _NUM ) = = _NUM ) ) { if ( - - bufpos < _NUM ) bufpos = bufsize - _NUM ; break ; } backup ( backSlashCnt ) ; return ' \ \ ' ; } } catch ( java . io . IOException e ) { We are returning one backslash so we should only backup ( count - _NUM ) if ( backSlashCnt > _NUM ) backup ( backSlashCnt - _NUM ) ; return ' \ \ ' ; } UpdateLineColumn ( c ) ; backSlashCnt + + ; } Here , we have seen an odd number of backslash ' s followed by a ' u ' try { while ( ( c = ReadByte ( ) ) = = ' u ' ) + + column ; buffer [ bufpos ] = c = ( char ) ( hexval ( c ) < < _NUM _NUM | hexval ( ReadByte ( ) ) < < _NUM | hexval ( ReadByte ( ) ) < < _NUM | hexval ( ReadByte ( ) ) ) ; column + = _NUM ; } catch ( java . io . IOException e ) { throw new Error ( _STR ) ; } if ( backSlashCnt = = _NUM ) return c ; else { backup ( backSlashCnt - _NUM ) ; return ' \ \ ' ; } } else { UpdateLineColumn ( c ) ; return c ; } } 
4090	private Schema getUpdatedSchemaObject ( String sourceColumnName , String alias , String targetColumnName ) { Check for source column and alias Schema obj = this . getMetadataColumnMap ( ) . get ( sourceColumnName . toLowerCase ( ) ) ; if ( obj = = null & & alias ! = null ) { obj = this . getMetadataColumnMap ( ) . get ( alias . toLowerCase ( ) ) ; } if ( obj = = null ) { obj = getCustomColumnSchema ( targetColumnName ) ; } else { String watermarkColumn = this . workUnitState . getProp ( ConfigurationKeys . EXTRACT _ DELTA _ FIELDS _ KEY ) ; String primarykeyColumn = this . workUnitState . getProp ( ConfigurationKeys . EXTRACT _ PRIMARY _ KEY _ FIELDS _ KEY ) ; boolean isMultiColumnWatermark = this . hasMultipleWatermarkColumns ( watermarkColumn ) ; obj . setColumnName ( targetColumnName ) ; boolean isWatermarkColumn = this . isWatermarkColumn ( watermarkColumn , sourceColumnName ) ; if ( isWatermarkColumn ) { this . updateDeltaFieldConfig ( sourceColumnName , targetColumnName ) ; } else if ( alias ! = null ) { Check for alias isWatermarkColumn = this . isWatermarkColumn ( watermarkColumn , alias ) ; this . updateDeltaFieldConfig ( alias , targetColumnName ) ; } watermark . Otherwise add a default watermark column in the end if ( ! isMultiColumnWatermark ) { obj . setWaterMark ( isWatermarkColumn ) ; } columns if ( ( isWatermarkColumn & & ! isMultiColumnWatermark ) | | this . getPrimarykeyIndex ( primarykeyColumn , sourceColumnName ) > _NUM ) { obj . setNullable ( false ) ; } else { obj . setNullable ( true ) ; } set primary key index for all the primary key fields int primarykeyIndex = this . getPrimarykeyIndex ( primarykeyColumn , sourceColumnName ) ; if ( primarykeyIndex > _NUM & & ( ! sourceColumnName . equalsIgnoreCase ( targetColumnName ) ) ) { this . updatePrimaryKeyConfig ( sourceColumnName , targetColumnName ) ; } obj . setPrimaryKey ( primarykeyIndex ) ; } return obj ; } 
4091	public void testSet ( ) { IonDatagram dg = system ( ) . newDatagram ( ) ; dg . add ( ) . newNull ( ) ; dg . set ( _NUM , system ( ) . newBool ( true ) ) ; } 
4092	private void advance ( int length ) throws SAXException { characterCount + = length ; long byteCount = getByteCount ( ) ; if ( characterCount > threshold & & characterCount > byteCount * ratio ) { throw new SecureSAXException ( _STR ) ; } } 
4093	private void postSaveOnWorkerObservers ( ) { for ( WorkerObserver obs : serviceWorker . getWorkerObservers ( ) ) { obs . postSave ( ) ; context . progress ( ) ; } } 
4094	private void executeWithRetry ( Runnable runnable ) { try { runnable . run ( ) ; } catch ( RuntimeTTransportException | RejectedExecutionException te ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( te . getClass ( ) + _STR , e ) ; } } } 
4095	public static boolean isInternationalPhoneNumber ( String s ) { if ( isEmpty ( s ) ) return defaultEmptyOK ; String normalizedPhone = stripCharsInBag ( s , phoneNumberDelimiters ) ; return isPositiveInteger ( normalizedPhone ) ; } 
4096	public void setIcon ( Drawable icon , Drawable endIcon ) { if ( showEndBitmap ) { setIconAnimation ( icon , endIcon ) ; } else { setImageDrawable ( icon ) ; } } 
4097	public final boolean dispatchKeyEvent ( @ NonNull KeyEvent event ) { boolean handled = false ; final int action = event . getAction ( ) ; if ( action ! = KeyEvent . ACTION _ UP ) { final int keyCode = event . getKeyCode ( ) ; switch ( keyCode ) { case KeyEvent . KEYCODE _ DPAD _ LEFT : case KeyEvent . KEYCODE _ DPAD _ UP : case KeyEvent . KEYCODE _ DPAD _ RIGHT : case KeyEvent . KEYCODE _ DPAD _ DOWN : if ( event . hasNoModifiers ( ) ) { final int direction = keyToDirection ( keyCode ) ; final int count = _NUM + event . getRepeatCount ( ) ; for ( int i = _NUM ; i < count ; i + + ) { if ( moveFocus ( direction , null ) ) { handled = true ; } else { break ; } } } break ; case KeyEvent . KEYCODE _ DPAD _ CENTER : case KeyEvent . KEYCODE _ ENTER : if ( event . hasNoModifiers ( ) ) { if ( event . getRepeatCount ( ) = = _NUM ) { clickKeyboardFocusedVirtualView ( ) ; handled = true ; } } break ; case KeyEvent . KEYCODE _ TAB : if ( event . hasNoModifiers ( ) ) { handled = moveFocus ( View . FOCUS _ FORWARD , null ) ; } else if ( event . hasModifiers ( KeyEvent . META _ SHIFT _ ON ) ) { handled = moveFocus ( View . FOCUS _ BACKWARD , null ) ; } break ; } } return handled ; } 
4098	int getExitDir ( ) { The reason for this method name , as opposed to getLastStrongDir ( ) , is that _STR in these method names to avoid confusion . charIndex = length ; int embeddingLevel = _NUM ; int lastNonEmptyEmbeddingLevel = _NUM ; while ( charIndex > _NUM ) { switch ( dirTypeBackward ( ) ) { case Character . DIRECTIONALITY _ LEFT _ TO _ RIGHT : if ( embeddingLevel = = _NUM ) { return DIR _ LTR ; } if ( lastNonEmptyEmbeddingLevel = = _NUM ) { lastNonEmptyEmbeddingLevel = embeddingLevel ; } break ; case Character . DIRECTIONALITY _ LEFT _ TO _ RIGHT _ EMBEDDING : case Character . DIRECTIONALITY _ LEFT _ TO _ RIGHT _ OVERRIDE : if ( lastNonEmptyEmbeddingLevel = = embeddingLevel ) { return DIR _ LTR ; } - - embeddingLevel ; break ; case Character . DIRECTIONALITY _ RIGHT _ TO _ LEFT : case Character . DIRECTIONALITY _ RIGHT _ TO _ LEFT _ ARABIC : if ( embeddingLevel = = _NUM ) { return DIR _ RTL ; } if ( lastNonEmptyEmbeddingLevel = = _NUM ) { lastNonEmptyEmbeddingLevel = embeddingLevel ; } break ; case Character . DIRECTIONALITY _ RIGHT _ TO _ LEFT _ EMBEDDING : case Character . DIRECTIONALITY _ RIGHT _ TO _ LEFT _ OVERRIDE : if ( lastNonEmptyEmbeddingLevel = = embeddingLevel ) { return DIR _ RTL ; } - - embeddingLevel ; break ; case Character . DIRECTIONALITY _ POP _ DIRECTIONAL _ FORMAT : + + embeddingLevel ; break ; case Character . DIRECTIONALITY _ BOUNDARY _ NEUTRAL : break ; default : if ( lastNonEmptyEmbeddingLevel = = _NUM ) { lastNonEmptyEmbeddingLevel = embeddingLevel ; } break ; } } return DIR _ UNKNOWN ; } 
4099	public ArraySet < ? extends Object > readArraySet ( ClassLoader loader ) { final int size = readInt ( ) ; if ( size < _NUM ) { return null ; } ArraySet < Object > result = new ArraySet < > ( size ) ; for ( int i = _NUM ; i < size ; i + + ) { Object value = readValue ( loader ) ; result . append ( value ) ; } return result ; } 
4100	public DeletableItem withAttributes ( Attribute . . . attributes ) { if ( getAttributes ( ) = = null ) setAttributes ( new java . util . ArrayList < Attribute > ( attributes . length ) ) ; for ( Attribute value : attributes ) { getAttributes ( ) . add ( value ) ; } return this ; } 
4101	public int incrementCounter ( CmsDbContext dbc , String name ) throws CmsException { return getVfsDriver ( dbc ) . incrementCounter ( dbc , name ) ; } 
4102	public static QueryIterator nestedLoopJoinBasic ( QueryIterator left , QueryIterator right , ExecutionContext execCxt ) { List < Binding > leftRows = Iter . toList ( left ) ; List < Binding > output = new ArrayList < > ( ) ; for ( ; right . hasNext ( ) ; ) { Binding row _NUM = right . next ( ) ; for ( Binding row _NUM : leftRows ) { Binding r = Algebra . merge ( row _NUM , row _NUM ) ; if ( r ! = null ) output . add ( r ) ; } } return new QueryIterPlainWrapper ( output . iterator ( ) , execCxt ) ; } 
4103	protected final byte [ ] toBytes ( final Item item ) throws QueryException { if ( checkNoEmpty ( item ) . type . isStringOrUntyped ( ) ) return item . string ( info ) ; if ( item instanceof Bin ) return ( ( Bin ) item ) . binary ( info ) ; throw STRBIN _ X _ X . get ( info , item . type , item ) ; } 
4104	public boolean onKeyMultiple ( int keyCode , int count , KeyEvent event ) { return doMovementKey ( keyCode , event , count ) ; } 
4105	public final void storeNoDB ( ) throws IOException { session . store ( _STR ) ) ; } 
4106	public static void purge ( File dataDir , File snapDir , int num ) throws IOException { if ( num < _NUM ) { throw new IllegalArgumentException ( COUNT _ ERR _ MSG ) ; } FileTxnSnapLog txnLog = new FileTxnSnapLog ( dataDir , snapDir ) ; List < File > snaps = txnLog . findNRecentSnapshots ( num ) ; int numSnaps = snaps . size ( ) ; if ( numSnaps > _NUM ) { purgeOlderSnapshots ( txnLog , snaps . get ( numSnaps - _NUM ) ) ; } } 
4107	public void setDocument ( String type , Document document ) { setContentType ( type ) ; m _ PrintPane . setDocument ( document ) ; } 
4108	public static long [ ] removeElement ( final long [ ] array , final long element ) { final int index = indexOf ( array , element ) ; if ( index = = INDEX _ NOT _ FOUND ) { return clone ( array ) ; } return remove ( array , index ) ; } 
4109	 @ Test ( groups = _STR ) ; Token token = factory . fromString ( Long . toString ( _NUM ) ) ; cluster . getMetadata ( ) . newTokenRange ( token , token ) ; } finally { cluster . close ( ) ; } } 
4110	public static void debug ( final Logger logger , final String pattern , final float argument ) { if ( logger . isDebugEnabled ( ) ) { forcedLog ( logger , Level . DEBUG , format ( pattern , valueOf ( argument ) ) ) ; } } 
4111	private void checkVersion ( ) throws IOException { Version loadedVersion = loadVersion ( ) ; LOG . info ( _STR + loadedVersion ; LOG . fatal ( incompatibleMessage ) ; throw new IOException ( incompatibleMessage ) ; } } 
4112	public static void conv _NUM dBackwardData ( MatrixBlock filter , MatrixBlock dout , MatrixBlock outputBlock , ConvolutionParameters params ) { checkInputsConv _NUM dBackwardData ( filter , dout , outputBlock , params ) ; long nnz = execute ( LibMatrixDNNConv _NUM d . getConv _NUM dBackwardDataWorkers ( params ) , params ) ; post - processing : maintain nnz outputBlock . setNonZeros ( nnz ) ; outputBlock . examSparsity ( ) ; } 
4113	public void setHandleBackground ( Drawable drawable ) { setViewBackground ( mHandle , drawable ) ; } 
4114	static void collectMethodsByGroup ( ITestNGMethod [ ] methods , boolean forTests , List < ITestNGMethod > outIncludedMethods , List < ITestNGMethod > outExcludedMethods , RunInfo runInfo , IAnnotationFinder finder , boolean unique ) { for ( ITestNGMethod tm : methods ) { boolean in = false ; Method m = tm . getConstructorOrMethod ( ) . getMethod ( ) ; if ( forTests ) { in = MethodGroupsHelper . includeMethod ( AnnotationHelper . findTest ( finder , m ) , runInfo , tm , forTests , unique , outIncludedMethods ) ; } else @ Configuration method { IConfigurationAnnotation annotation = AnnotationHelper . findConfiguration ( finder , m ) ; if ( annotation . getAlwaysRun ( ) ) { if ( ! unique | | ! MethodGroupsHelper . isMethodAlreadyPresent ( outIncludedMethods , tm ) ) { in = true ; } } else { in = MethodGroupsHelper . includeMethod ( AnnotationHelper . findTest ( finder , tm ) , runInfo , tm , forTests , unique , outIncludedMethods ) ; } } if ( in ) { outIncludedMethods . add ( tm ) ; } else { outExcludedMethods . add ( tm ) ; } } } 
4115	public void captureChildView ( View childView , int activePointerId ) { if ( childView . getParent ( ) ! = mParentView ) { throw new IllegalArgumentException ( _STR ) ; } mCapturedView = childView ; mActivePointerId = activePointerId ; mCallback . onViewCaptured ( childView , activePointerId ) ; setDragState ( STATE _ DRAGGING ) ; } 
4116	protected void handleLogging ( Exception e ) { if ( logCategory ! = null ) { if ( categoryLogger = = null ) { init category logger categoryLogger = LogManager . getLogger ( logCategory ) ; } doLog ( categoryLogger , e ) ; } else { doLog ( LOG , e ) ; } } 
4117	public void testNodeHealing ( ) throws Exception { addServer ( SERVERS . PORT _ _NUM ) ; addServer ( SERVERS . PORT _ _NUM ) ; addServer ( SERVERS . PORT _ _NUM ) ; Layout l = new TestLayoutBuilder ( ) . setEpoch ( _NUM L ) . addLayoutServer ( SERVERS . PORT _ _NUM ) . addLayoutServer ( SERVERS . PORT _ _NUM ) . addLayoutServer ( SERVERS . PORT _ _NUM ) . addSequencer ( SERVERS . PORT _ _NUM ) . buildSegment ( ) . buildStripe ( ) . addLogUnit ( SERVERS . PORT _ _NUM ) . addToSegment ( ) . addToLayout ( ) . build ( ) ; bootstrapAllServers ( l ) ; CorfuRuntime corfuRuntime = getRuntime ( l ) . connect ( ) ; getManagementServer ( SERVERS . PORT _ _NUM ) . shutdown ( ) ; getManagementServer ( SERVERS . PORT _ _NUM ) . shutdown ( ) ; setAggressiveTimeouts ( l , corfuRuntime , getManagementServer ( SERVERS . PORT _ _NUM ) . getManagementAgent ( ) . getCorfuRuntime ( ) ) ; setAggressiveDetectorTimeouts ( SERVERS . PORT _ _NUM ) ; addServerRule ( SERVERS . PORT _ _NUM , new TestRule ( ) . always ( ) . drop ( ) ) ; while ( corfuRuntime . getLayoutView ( ) . getLayout ( ) . getEpoch ( ) = = l . getEpoch ( ) ) { Thread . sleep ( PARAMETERS . TIMEOUT _ VERY _ SHORT . toMillis ( ) ) ; corfuRuntime . invalidateLayout ( ) ; } final long newEpoch = _NUM L ; assertThat ( corfuRuntime . getLayoutView ( ) . getLayout ( ) . getEpoch ( ) ) . isEqualTo ( newEpoch ) ; assertThat ( corfuRuntime . getLayoutView ( ) . getLayout ( ) . getUnresponsiveServers ( ) ) . containsExactly ( SERVERS . ENDPOINT _ _NUM ) ; clearServerRules ( SERVERS . PORT _ _NUM ) ; final long finalEpoch = _NUM L ; while ( corfuRuntime . getLayoutView ( ) . getLayout ( ) . getEpoch ( ) ! = finalEpoch ) { Thread . sleep ( PARAMETERS . TIMEOUT _ VERY _ SHORT . toMillis ( ) ) ; corfuRuntime . invalidateLayout ( ) ; } assertThat ( corfuRuntime . getLayoutView ( ) . getLayout ( ) . getEpoch ( ) ) . isEqualTo ( finalEpoch ) ; assertThat ( corfuRuntime . getLayoutView ( ) . getLayout ( ) . getUnresponsiveServers ( ) ) . isEmpty ( ) ; } 
4118	public static Wallet fromKeys ( NetworkParameters params , List < ECKey > keys ) { for ( ECKey key : keys ) checkArgument ( ! ( key instanceof DeterministicKey ) ) ; KeyChainGroup group = new KeyChainGroup ( params ) ; group . importKeys ( keys ) ; return new Wallet ( params , group ) ; } 
4119	public TaskStackBuilder addNextIntentWithParentStack ( @ NonNull Intent nextIntent ) { ComponentName target = nextIntent . getComponent ( ) ; if ( target = = null ) { target = nextIntent . resolveActivity ( mSourceContext . getPackageManager ( ) ) ; } if ( target ! = null ) { addParentStack ( target ) ; } addNextIntent ( nextIntent ) ; return this ; } 
4120	public void setClusterer ( DensityBasedClusterer newClusterer ) { m _ clusterer = newClusterer ; updateOptions ( ) ; } 
4121	public Builder addContext ( final String name , final double value ) { context . add ( name , value ) ; return this ; } 
4122	public String translate ( String text , String targetLanguage ) throws TikaException , IOException { Translator t = getFirstAvailable ( loader ) ; if ( t ! = null ) { return t . translate ( text , targetLanguage ) ; } throw new TikaException ( _STR ) ; } 
4123	public List < BoundedSource < HCatRecord > > split ( long desiredBundleSizeBytes , PipelineOptions options ) throws Exception { int desiredSplitCount = _NUM ; long estimatedSizeBytes = getEstimatedSizeBytes ( options ) ; if ( desiredBundleSizeBytes > _NUM & & estimatedSizeBytes > _NUM ) { desiredSplitCount = ( int ) Math . ceil ( ( double ) estimatedSizeBytes / desiredBundleSizeBytes ) ; } ReaderContext readerContext = getReaderContext ( desiredSplitCount ) ; process the splits returned by native API this could be different from ' desiredSplitCount ' calculated above LOG . info ( _STR , desiredBundleSizeBytes , estimatedSizeBytes , desiredSplitCount , readerContext . numSplits ( ) ) ; List < BoundedSource < HCatRecord > > res = new ArrayList < > ( ) ; for ( int split = _NUM ; split < readerContext . numSplits ( ) ; split + + ) { res . add ( new BoundedHCatalogSource ( spec . withContext ( readerContext ) . withSplitId ( split ) ) ) ; } return res ; } 
4124	public boolean unlockBlockNoException ( long lockId ) { Lock lock ; LockRecord record ; synchronized ( mSharedMapsLock ) { record = mLockIdToRecordMap . get ( lockId ) ; if ( record = = null ) { return false ; } long sessionId = record . getSessionId ( ) ; lock = record . getLock ( ) ; mLockIdToRecordMap . remove ( lockId ) ; Set < Long > sessionLockIds = mSessionIdToLockIdsMap . get ( sessionId ) ; sessionLockIds . remove ( lockId ) ; if ( sessionLockIds . isEmpty ( ) ) { mSessionIdToLockIdsMap . remove ( sessionId ) ; } } unlock ( lock , record . getBlockId ( ) ) ; return true ; } 
4125	private View findCenterView ( RecyclerView . LayoutManager layoutManager , OrientationHelper helper ) { int childCount = layoutManager . getChildCount ( ) ; if ( childCount = = _NUM ) { return null ; } View closestChild = null ; final int center ; if ( layoutManager . getClipToPadding ( ) ) { center = helper . getStartAfterPadding ( ) + helper . getTotalSpace ( ) / _NUM ; } else { center = helper . getEnd ( ) / _NUM ; } int absClosest = Integer . MAX _ VALUE ; for ( int i = _NUM ; i < childCount ; i + + ) { final View child = layoutManager . getChildAt ( i ) ; int childCenter = helper . getDecoratedStart ( child ) + ( helper . getDecoratedMeasurement ( child ) / _NUM ) ; int absDistance = Math . abs ( childCenter - center ) ; if ( absDistance < absClosest ) { absClosest = absDistance ; closestChild = child ; } } return closestChild ; } 
4126	public int getContentInsetEndWithActions ( ) { return mContentInsetEndWithActions ! = RtlSpacingHelper . UNDEFINED ? mContentInsetEndWithActions : getContentInsetEnd ( ) ; } 
4127	public static GF _NUM Vector syndromeDecode ( GF _NUM Vector syndVec , GF _NUM mField field , PolynomialGF _NUM mSmallM gp , PolynomialGF _NUM mSmallM [ ] sqRootMatrix ) { int n = _NUM < < field . getDegree ( ) ; the error vector GF _NUM Vector errors = new GF _NUM Vector ( n ) ; if the syndrome vector is zero , the error vector is also zero if ( ! syndVec . isZero ( ) ) { convert syndrome vector to polynomial over GF ( _NUM ^ m ) PolynomialGF _NUM mSmallM syndrome = new PolynomialGF _NUM mSmallM ( syndVec . toExtensionFieldVector ( field ) ) ; compute T = syndrome ^ - _NUM mod gp PolynomialGF _NUM mSmallM t = syndrome . modInverse ( gp ) ; compute tau = sqRoot ( T + X ) mod gp PolynomialGF _NUM mSmallM tau = t . addMonomial ( _NUM ) ; tau = tau . modSquareRootMatrix ( sqRootMatrix ) ; compute polynomials a and b satisfying a + b * tau = _NUM mod gp PolynomialGF _NUM mSmallM [ ] ab = tau . modPolynomialToFracton ( gp ) ; compute the polynomial a ^ _NUM + X * b ^ _NUM PolynomialGF _NUM mSmallM a _NUM = ab [ _NUM ] . multiply ( ab [ _NUM ] ) ; PolynomialGF _NUM mSmallM b _NUM = ab [ _NUM ] . multiply ( ab [ _NUM ] ) ; PolynomialGF _NUM mSmallM xb _NUM = b _NUM . multWithMonomial ( _NUM ) ; PolynomialGF _NUM mSmallM a _NUM plusXb _NUM = a _NUM . add ( xb _NUM ) ; normalize a ^ _NUM + X * b ^ _NUM to obtain the error locator polynomial int headCoeff = a _NUM plusXb _NUM . getHeadCoefficient ( ) ; int invHeadCoeff = field . inverse ( headCoeff ) ; PolynomialGF _NUM mSmallM elp = a _NUM plusXb _NUM . multWithElement ( invHeadCoeff ) ; for all elements i of GF ( _NUM ^ m ) for ( int i = _NUM ; i < n ; i + + ) { evaluate the error locator polynomial at i int z = elp . evaluateAt ( i ) ; if polynomial evaluates to zero if ( z = = _NUM ) { set the i - th coefficient of the error vector errors . setBit ( i ) ; } } } return errors ; } 
4128	private ConfigExtractor getTestConfig ( boolean sleep ) throws Exception { ArgumentParser parser = new ArgumentParser ( getTestArgs ( sleep ) ) ; ParsedOutput out = parser . parse ( ) ; assertTrue ( ! out . shouldOutputHelp ( ) ) ; ConfigMerger merge = new ConfigMerger ( ) ; Configuration cfg = merge . getMerged ( out , getBaseConfig ( ) ) ; ConfigExtractor extractor = new ConfigExtractor ( cfg ) ; return extractor ; } 
4129	void recycleViewHolderInternal ( ViewHolder holder ) { if ( holder . isScrap ( ) | | holder . itemView . getParent ( ) ! = null ) { throw new IllegalArgumentException ( _STR + exceptionLabel ( ) ) ; } } even if the holder is not removed , we still call this method so that it is removed from view holder lists . mViewInfoStore . removeViewHolder ( holder ) ; if ( ! cached & & ! recycled & & transientStatePreventsRecycling ) { holder . mOwnerRecyclerView = null ; } } 
4130	protected HttpParameters createParametersForContext ( ) { HttpParameters parentParams = null ; if ( ! ignoreContextParams ) { parentParams = new ActionContext ( getStack ( ) . getContext ( ) ) . getParameters ( ) ; } HttpParameters . Builder builder = HttpParameters . create ( ) ; if ( parentParams ! = null ) { builder = builder . withParent ( parentParams ) ; } if ( parameters ! = null ) { Map < String , String [ ] > params = new HashMap < > ( ) ; for ( Object o : parameters . entrySet ( ) ) { Map . Entry entry = ( Map . Entry ) o ; String key = ( String ) entry . getKey ( ) ; Object val = entry . getValue ( ) ; if ( val . getClass ( ) . isArray ( ) & & String . class = = val . getClass ( ) . getComponentType ( ) ) { params . put ( key , ( String [ ] ) val ) ; } else { params . put ( key , new String [ ] { val . toString ( ) } ) ; } } builder = builder . withExtraParams ( params ) ; } return builder . build ( ) ; } 
4131	public void onDrawShadow ( Canvas canvas ) { final View view = mView . get ( ) ; if ( view ! = null ) { view . draw ( canvas ) ; } else { Log . e ( View . VIEW _ LOG _ TAG , _STR ) ; } } 
4132	public Bitmap getCache ( Object token ) { if ( token = = null ? mLastToken = = null : token . equals ( mLastToken ) ) { if ( DEBUG ) Log . v ( TAG , _STR + mLastBitmap ) ; return mLastBitmap ; } return null ; } 
4133	public void set ( T obj , ViewContext context ) { if ( ! viewSingletonObjects . containsKey ( tClass ) ) { synchronized ( viewSingletonObjects ) { if ( ! viewSingletonObjects . containsKey ( tClass ) ) { viewSingletonObjects . put ( tClass , new ConcurrentHashMap < String , Object > ( ) ) ; } } } String key = getTagName ( context ) ; LOG . info ( _STR , key , obj ) ; Map < String , Object > instances = viewSingletonObjects . get ( tClass ) ; instances . put ( key , obj ) ; } 
4134	public RandomAccess createBuffer ( InputStream input ) throws IOException { ScratchFileBuffer buf = new ScratchFileBuffer ( this ) ; byte [ ] byteBuffer = new byte [ _NUM _NUM _NUM _NUM ] ; int bytesRead = _NUM ; while ( ( bytesRead = input . read ( byteBuffer ) ) > - _NUM ) { buf . write ( byteBuffer , _NUM , bytesRead ) ; } buf . seek ( _NUM ) ; return buf ; } 
4135	protected int insertKey ( short val ) { int hash , index ; hash = HashFunctions . hash ( val ) & _NUM x _NUM fffffff ; index = hash % _ states . length ; byte state = _ states [ index ] ; consumeFreeSlot = false ; if ( state = = FREE ) { consumeFreeSlot = true ; insertKeyAt ( index , val ) ; empty , all done return index ; } if ( state = = FULL & & _ set [ index ] = = val ) { already stored return - index - _NUM ; } already FULL or REMOVED , must probe return insertKeyRehash ( val , index , hash , state ) ; } 
4136	public int getFlags ( ) { if ( Build . VERSION . SDK _ INT > = _NUM _NUM & & ! sForceLegacyBehavior & & mAudioAttributesWrapper ! = null ) { return mAudioAttributesWrapper . unwrap ( ) . getFlags ( ) ; } else { int flags = mFlags ; int legacyStream = getLegacyStreamType ( ) ; if ( legacyStream = = AudioManagerHidden . STREAM _ BLUETOOTH _ SCO ) { flags | = FLAG _ SCO ; } else if ( legacyStream = = AudioManagerHidden . STREAM _ SYSTEM _ ENFORCED ) { flags | = FLAG _ AUDIBILITY _ ENFORCED ; } return flags & FLAG _ ALL _ PUBLIC ; } } 
4137	public CryptoConfiguration withCryptoMode ( CryptoMode cryptoMode ) throws UnsupportedOperationException { this . cryptoMode = cryptoMode ; check ( cryptoMode ) ; return this ; } 
4138	public boolean addAll ( int index , Collection collection ) { list . lock . lock ( ) ; try { checkIndexInclusive ( index , read . size ) ; checkModifications ( ) ; int d = list . size ( ) ; boolean rt = list . addAll ( index + start , collection ) ; read = new SubListReadData ( read . size + list . size ( ) - d , list . getData ( ) ) ; return rt ; } finally { list . lock . unlock ( ) ; } } 
4139	public String getIconPathLock ( ) { CmsLock lock = getLock ( ) ; String iconPath = null ; if ( ! lock . isUnlocked ( ) & & ( m _ request ! = null ) & & isInsideProject ( ) ) { if ( getLock ( ) . isOwnedBy ( m _ request . getCurrentUser ( ) ) & & ( getLockedInProjectId ( ) . equals ( getReferenceProject ( ) . getUuid ( ) ) ) ) { if ( lock . isShared ( ) ) { iconPath = _STR ; } 
4140	public List < Pair < String , ? extends Table > > getTablesByNames ( final List < String > tableNames ) { final List < Pair < String , ? extends Table > > tables = Lists . newArrayList ( ) ; for ( String tableName : tableNames ) { final Table table = getTable ( tableName ) ; if ( table = = null ) { tables as INFO SCHEMA is about showing tables which the use has access to query . continue ; } tables . add ( Pair . of ( tableName , table ) ) ; } return tables ; } 
4141	private static long calculateCryptoContentLength ( Cipher symmetricCipher , PutObjectRequest request , ObjectMetadata metadata ) { long plaintextLength = getUnencryptedContentLength ( request , metadata ) ; If we don ' t know the unencrypted size , then report - _NUM if ( plaintextLength < _NUM ) return - _NUM ; long cipherBlockSize = symmetricCipher . getBlockSize ( ) ; long offset = cipherBlockSize - ( plaintextLength % cipherBlockSize ) ; return plaintextLength + offset ; } 
4142	public boolean onMediaButtonEvent ( Intent mediaButtonEvent ) { MediaSessionImpl impl = mSessionImpl . get ( ) ; if ( impl = = null | | mCallbackHandler = = null ) { return false ; } KeyEvent keyEvent = mediaButtonEvent . getParcelableExtra ( Intent . EXTRA _ KEY _ EVENT ) ; if ( keyEvent = = null | | keyEvent . getAction ( ) ! = KeyEvent . ACTION _ DOWN ) { return false ; } int keyCode = keyEvent . getKeyCode ( ) ; switch ( keyCode ) { case KeyEvent . KEYCODE _ MEDIA _ PLAY _ PAUSE : case KeyEvent . KEYCODE _ HEADSETHOOK : if ( keyEvent . getRepeatCount ( ) > _NUM ) { Consider long - press as a single tap . handleMediaPlayPauseKeySingleTapIfPending ( ) ; } else if ( mMediaPlayPauseKeyPending ) { mCallbackHandler . removeMessages ( CallbackHandler . MSG _ MEDIA _ PLAY _ PAUSE _ KEY _ DOUBLE _ TAP _ TIMEOUT ) ; mMediaPlayPauseKeyPending = false ; PlaybackStateCompat state = impl . getPlaybackState ( ) ; long validActions = state = = null ? _NUM : state . getActions ( ) ; Consider double tap as the next . if ( ( validActions & PlaybackStateCompat . ACTION _ SKIP _ TO _ NEXT ) ! = _NUM ) { onSkipToNext ( ) ; } } else { mMediaPlayPauseKeyPending = true ; mCallbackHandler . sendEmptyMessageDelayed ( CallbackHandler . MSG _ MEDIA _ PLAY _ PAUSE _ KEY _ DOUBLE _ TAP _ TIMEOUT , ViewConfiguration . getDoubleTapTimeout ( ) ) ; } return true ; default : If another key is pressed within double tap timeout , consider the pending pending play / pause as a single tap to handle media keys in order . handleMediaPlayPauseKeySingleTapIfPending ( ) ; break ; } return false ; } 
4143	public Component getTabComponentAt ( int index ) { checkIndex ( index ) ; return contentPane . getComponentAt ( index ) ; } 
4144	public CmsResource createSibling ( String source , String destination , List < CmsProperty > properties ) throws CmsException { CmsResource resource = readResource ( source , CmsResourceFilter . IGNORE _ EXPIRATION ) ; return getResourceType ( resource ) . createSibling ( this , m _ securityManager , resource , destination , properties ) ; } 
4145	public long getPiecesIncluded ( ) { GenericValue product = getProduct ( ) ; if ( product ! = null ) { Long pieces = product . getLong ( _STR ) ; } if ( pieces = = null ) { return _NUM ; } else { return pieces . longValue ( ) ; } } else { non - product item assumed _NUM piece return _NUM ; } } 
4146	protected void finalize ( ) throws Throwable { shutdown ( ) ; } 
4147	public void addContextMenuEntry ( CmsExplorerContextMenuItem item ) { addSubItem ( item , TYPE _ ENTRY ) ; } 
4148	protected void popComponentStack ( ) { getComponentStack ( ) . pop ( ) ; } 
4149	A wrapper to ensure a non - null currentBuffer value on the first call . HintsBuffer currentBuffer ( ) { if ( currentBuffer = = null ) initializeCurrentBuffer ( ) ; return currentBuffer ; } 
4150	public byte [ ] getPageContent ( int pageNum , RandomAccessFileOrArray file ) throws IOException { PdfDictionary page = getPageNRelease ( pageNum ) ; if ( page = = null ) return null ; PdfObject contents = getPdfObjectRelease ( page . get ( PdfName . CONTENTS ) ) ; if ( contents = = null ) return new byte [ _NUM ] ; ByteArrayOutputStream bout = null ; if ( contents . isStream ( ) ) { return getStreamBytes ( ( PRStream ) contents , file ) ; } else if ( contents . isArray ( ) ) { PdfArray array = ( PdfArray ) contents ; bout = new ByteArrayOutputStream ( ) ; for ( int k = _NUM ; k < array . size ( ) ; + + k ) { PdfObject item = getPdfObjectRelease ( array . getPdfObject ( k ) ) ; if ( item = = null | | ! item . isStream ( ) ) continue ; byte [ ] b = getStreamBytes ( ( PRStream ) item , file ) ; bout . write ( b ) ; if ( k ! = array . size ( ) - _NUM ) bout . write ( ' \ n ' ) ; } return bout . toByteArray ( ) ; } else return new byte [ _NUM ] ; } 
4151	public Map < String , String > getResourceValueMap ( ) { if ( ( m _ resourceValueMap = = null ) & & ( m _ resourceValue ! = null ) ) { use lazy initializing of the map m _ resourceValueMap = createMapFromValue ( m _ resourceValue ) ; m _ resourceValueMap = Collections . unmodifiableMap ( m _ resourceValueMap ) ; } return m _ resourceValueMap ; } 
4152	private void lazyEndHead ( boolean isFrameset ) throws SAXException { lazyStartHead ( ) ; if ( ! headEnded ) { headEnded = true ; useFrameset = isFrameset ; startElement ( ) and characters ( ) directly to avoid recursive problems . for ( String name : metadata . names ( ) ) { if ( name . equals ( _STR , EMPTY _ ATTRIBUTES ) ; } } } 
4153	public List < CmsLink > parseLinks ( CmsObject cms , CmsFile file ) { if ( file . getLength ( ) = = _NUM ) { return Collections . emptyList ( ) ; } CmsXmlContent xmlContent ; long requestTime = cms . getRequestContext ( ) . getRequestTime ( ) ; try { prevent the check rules to remove the broken links cms . getRequestContext ( ) . setRequestTime ( CmsResource . DATE _ RELEASED _ EXPIRED _ IGNORE ) ; xmlContent = CmsXmlContentFactory . unmarshal ( cms , file ) ; } catch ( CmsException e ) { if ( LOG . isErrorEnabled ( ) ) { LOG . error ( org . opencms . db . Messages . get ( ) . getBundle ( ) . key ( org . opencms . db . Messages . ERR _ READ _ RESOURCE _ _NUM , cms . getSitePath ( file ) ) , e ) ; } return Collections . emptyList ( ) ; } finally { cms . getRequestContext ( ) . setRequestTime ( requestTime ) ; } Set < CmsLink > links = new HashSet < CmsLink > ( ) ; add XSD link CmsLink xsdLink = getXsdLink ( cms , xmlContent ) ; if ( xsdLink ! = null ) { links . add ( xsdLink ) ; } iterate over all languages List < Locale > locales = xmlContent . getLocales ( ) ; Iterator < Locale > i = locales . iterator ( ) ; while ( i . hasNext ( ) ) { Locale locale = i . next ( ) ; List < I _ CmsXmlContentValue > values = xmlContent . getValues ( locale ) ; iterate over all body elements per language Iterator < I _ CmsXmlContentValue > j = values . iterator ( ) ; while ( j . hasNext ( ) ) { I _ CmsXmlContentValue value = j . next ( ) ; if ( value instanceof CmsXmlHtmlValue ) { CmsXmlHtmlValue htmlValue = ( CmsXmlHtmlValue ) value ; CmsLinkTable linkTable = htmlValue . getLinkTable ( ) ; iterate over all links inside a body element Iterator < CmsLink > k = linkTable . iterator ( ) ; while ( k . hasNext ( ) ) { CmsLink link = k . next ( ) ; external links are omitted if ( link . isInternal ( ) ) { link . checkConsistency ( cms ) ; links . add ( link ) ; } } } else if ( value instanceof CmsXmlVfsFileValue ) { CmsXmlVfsFileValue refValue = ( CmsXmlVfsFileValue ) value ; CmsLink link = refValue . getLink ( cms ) ; if ( link ! = null ) { links . add ( link ) ; } } else if ( value instanceof CmsXmlVarLinkValue ) { CmsXmlVarLinkValue refValue = ( CmsXmlVarLinkValue ) value ; CmsLink link = refValue . getLink ( cms ) ; if ( ( link ! = null ) & & link . isInternal ( ) ) { links . add ( link ) ; } } } } return new ArrayList < CmsLink > ( links ) ; } 
4154	private void registerConfigSignInProviders ( ) { Log . d ( LOG _ TAG , _STR ) ; final IdentityManager identityManager = IdentityManager . getDefaultIdentityManager ( ) ; if ( isConfigurationKeyPresent ( USER _ POOLS ) ) { identityManager . addSignInProvider ( CognitoUserPoolsSignInProvider . class ) ; } if ( isConfigurationKeyPresent ( FACEBOOK ) ) { identityManager . addSignInProvider ( FacebookSignInProvider . class ) ; } if ( isConfigurationKeyPresent ( GOOGLE ) ) { identityManager . addSignInProvider ( GoogleSignInProvider . class ) ; } } 
4155	public static int writeString ( DataOutput out , String s ) throws IOException { ByteBuffer bytes = encode ( s ) ; int length = bytes . limit ( ) ; WritableUtils . writeVInt ( out , length ) ; out . write ( bytes . array ( ) , _NUM , length ) ; return length ; } 
4156	public static Rectangle transformRect ( AffineTransform af , Rectangle src ) { Rectangle dest = new Rectangle ( _NUM , _NUM , _NUM , _NUM ) ; src = absRect ( src ) ; Point p _NUM = new Point ( src . x , src . y ) ; p _NUM = transformPoint ( af , p _NUM ) ; dest . x = p _NUM . x ; dest . y = p _NUM . y ; dest . width = ( int ) ( src . width * af . getScaleX ( ) ) ; dest . height = ( int ) ( src . height * af . getScaleY ( ) ) ; return dest ; } 
4157	public void notifyPermissionResponse ( String packageName , PersistableBundle response ) { if ( packageName = = null ) { throw new NullPointerException ( _STR ) ; } try { if ( mService ! = null ) { mService . notifyPermissionResponse ( packageName , response ) ; } } catch ( RemoteException re ) { throw re . rethrowFromSystemServer ( ) ; } } 
4158	private void decode ( byte [ ] data , int width , int height ) { Size size = activity . getCameraManager ( ) . getPreviewSize ( ) ; è¿™ é‡Œ éœ€ è¦ å°† èŽ· å– çš„ data ç¿» è½¬ ä¸€ ä¸‹ ï¼Œ å›  ä¸º ç›¸ æœº é»˜ è®¤ æ‹¿ çš„ çš„ æ¨ª å± çš„ æ•° æ® byte [ ] rotatedData = new byte [ data . length ] ; for ( int y = _NUM ; y < size . height ; y + + ) { for ( int x = _NUM ; x < size . width ; x + + ) rotatedData [ x * size . height + size . height - y - _NUM ] = data [ x + y * size . width ] ; } å®½ é«˜ ä¹Ÿ è¦ è°ƒ æ•´ int tmp = size . width ; size . width = size . height ; size . height = tmp ; Result rawResult = null ; PlanarYUVLuminanceSource source = buildLuminanceSource ( rotatedData , size . width , size . height ) ; if ( source ! = null ) { BinaryBitmap bitmap = new BinaryBitmap ( new HybridBinarizer ( source ) ) ; try { rawResult = multiFormatReader . decodeWithState ( bitmap ) ; } catch ( ReaderException re ) { continue } finally { multiFormatReader . reset ( ) ; } } Handler handler = activity . getHandler ( ) ; if ( rawResult ! = null ) { Don ' t log the barcode contents for security . if ( handler ! = null ) { Message message = Message . obtain ( handler , R . id . decode _ succeeded , rawResult ) ; Bundle bundle = new Bundle ( ) ; bundleThumbnail ( source , bundle ) ; message . setData ( bundle ) ; message . sendToTarget ( ) ; } } else { if ( handler ! = null ) { Message message = Message . obtain ( handler , R . id . decode _ failed ) ; message . sendToTarget ( ) ; } } } 
4159	protected Stroke lookupSectionOutlineStroke ( Comparable key , boolean autoPopulate ) { is there an override ? Stroke result = getSectionOutlineStroke ( ) ; if ( result ! = null ) { return result ; } if not , check if there is a stroke defined for the specified key result = this . sectionOutlineStrokeMap . getStroke ( key ) ; if ( result ! = null ) { return result ; } nothing defined - do we autoPopulate ? if ( autoPopulate ) { DrawingSupplier ds = getDrawingSupplier ( ) ; if ( ds ! = null ) { result = ds . getNextOutlineStroke ( ) ; this . sectionOutlineStrokeMap . put ( key , result ) ; } else { result = this . baseSectionOutlineStroke ; } } else { result = this . baseSectionOutlineStroke ; } return result ; } 
4160	public HSSFPolygon createPolygon ( HSSFClientAnchor anchor ) { HSSFPolygon shape = new HSSFPolygon ( null , anchor ) ; addShape ( shape ) ; onCreate ( shape ) ; return shape ; } 
4161	public DMLDeleteStatement delete ( ) throws SQLSyntaxErrorException { match ( KW _ DELETE ) ; boolean lowPriority = false ; boolean quick = false ; boolean ignore = false ; loopOpt : for ( ; ; lexer . nextToken ( ) ) { switch ( lexer . token ( ) ) { case KW _ LOW _ PRIORITY : lowPriority = true ; break ; case KW _ IGNORE : ignore = true ; break ; case IDENTIFIER : SpecialIdentifier si = specialIdentifiers . get ( lexer . stringValueUppercase ( ) ) ; if ( SpecialIdentifier . QUICK = = si ) { quick = true ; break ; } default : break loopOpt ; } } List < Identifier > tempList ; TableReferences tempRefs ; Expression tempWhere ; if ( lexer . token ( ) = = KW _ FROM ) { lexer . nextToken ( ) ; Identifier id = identifier ( ) ; tempList = new ArrayList < Identifier > ( _NUM ) ; tempList . add ( id ) ; switch ( lexer . token ( ) ) { case PUNC _ COMMA : tempList = buildIdList ( id ) ; case KW _ USING : lexer . nextToken ( ) ; tempRefs = tableRefs ( ) ; if ( lexer . token ( ) = = KW _ WHERE ) { lexer . nextToken ( ) ; tempWhere = exprParser . expression ( ) ; return new DMLDeleteStatement ( lowPriority , quick , ignore , tempList , tempRefs , tempWhere ) ; } return new DMLDeleteStatement ( lowPriority , quick , ignore , tempList , tempRefs ) ; case KW _ WHERE : case KW _ ORDER : case KW _ LIMIT : break ; default : return new DMLDeleteStatement ( lowPriority , quick , ignore , id ) ; } tempWhere = null ; OrderBy orderBy = null ; Limit limit = null ; if ( lexer . token ( ) = = KW _ WHERE ) { lexer . nextToken ( ) ; tempWhere = exprParser . expression ( ) ; } if ( lexer . token ( ) = = KW _ ORDER ) { orderBy = orderBy ( ) ; } if ( lexer . token ( ) = = KW _ LIMIT ) { limit = limit ( ) ; } return new DMLDeleteStatement ( lowPriority , quick , ignore , id , tempWhere , orderBy , limit ) ; } tempList = idList ( ) ; match ( KW _ FROM ) ; tempRefs = tableRefs ( ) ; if ( lexer . token ( ) = = KW _ WHERE ) { lexer . nextToken ( ) ; tempWhere = exprParser . expression ( ) ; return new DMLDeleteStatement ( lowPriority , quick , ignore , tempList , tempRefs , tempWhere ) ; } return new DMLDeleteStatement ( lowPriority , quick , ignore , tempList , tempRefs ) ; } 
4162	public ByteBuffer merge ( ByteBuffer left , ByteBuffer right ) { boolean leftIsSuperSet = true ; boolean rightIsSuperSet = true ; int globalCount = _NUM ; int localCount = _NUM ; int remoteCount = _NUM ; ContextState leftState = ContextState . wrap ( left ) ; ContextState rightState = ContextState . wrap ( right ) ; while ( leftState . hasRemaining ( ) & & rightState . hasRemaining ( ) ) { int cmp = leftState . compareIdTo ( rightState ) ; if ( cmp = = _NUM ) { Relationship rel = compare ( leftState , rightState ) ; if ( rel = = Relationship . GREATER _ THAN ) rightIsSuperSet = false ; else if ( rel = = Relationship . LESS _ THAN ) leftIsSuperSet = false ; else if ( rel = = Relationship . DISJOINT ) leftIsSuperSet = rightIsSuperSet = false ; if ( leftState . isGlobal ( ) | | rightState . isGlobal ( ) ) globalCount + = _NUM ; else if ( leftState . isLocal ( ) | | rightState . isLocal ( ) ) localCount + = _NUM ; else remoteCount + = _NUM ; leftState . moveToNext ( ) ; rightState . moveToNext ( ) ; } else if ( cmp > _NUM ) { leftIsSuperSet = false ; if ( rightState . isGlobal ( ) ) globalCount + = _NUM ; else if ( rightState . isLocal ( ) ) localCount + = _NUM ; else remoteCount + = _NUM ; rightState . moveToNext ( ) ; } else cmp < _NUM { rightIsSuperSet = false ; if ( leftState . isGlobal ( ) ) globalCount + = _NUM ; else if ( leftState . isLocal ( ) ) localCount + = _NUM ; else remoteCount + = _NUM ; leftState . moveToNext ( ) ; } } if ( leftState . hasRemaining ( ) ) rightIsSuperSet = false ; else if ( rightState . hasRemaining ( ) ) leftIsSuperSet = false ; if one of the contexts is a superset , return it early . if ( leftIsSuperSet ) return left ; else if ( rightIsSuperSet ) return right ; while ( leftState . hasRemaining ( ) ) { if ( leftState . isGlobal ( ) ) globalCount + = _NUM ; else if ( leftState . isLocal ( ) ) localCount + = _NUM ; else remoteCount + = _NUM ; leftState . moveToNext ( ) ; } while ( rightState . hasRemaining ( ) ) { if ( rightState . isGlobal ( ) ) globalCount + = _NUM ; else if ( rightState . isLocal ( ) ) localCount + = _NUM ; else remoteCount + = _NUM ; rightState . moveToNext ( ) ; } leftState . reset ( ) ; rightState . reset ( ) ; return merge ( ContextState . allocate ( globalCount , localCount , remoteCount ) , leftState , rightState ) ; } 
4163	public void testDualClusters ( ) throws Throwable { File testDataCluster _NUM = new File ( testDataPath , CLUSTER _ _NUM ) ; File testDataCluster _NUM = new File ( testDataPath , CLUSTER _ _NUM ) ; Configuration conf = new HdfsConfiguration ( ) ; String c _NUM Path = testDataCluster _NUM . getAbsolutePath ( ) ; conf . set ( MiniDFSCluster . HDFS _ MINIDFS _ BASEDIR , c _NUM Path ) ; MiniDFSCluster cluster _NUM = new MiniDFSCluster . Builder ( conf ) . build ( ) ; MiniDFSCluster cluster _NUM = null ; try { String dataDir _NUM = cluster _NUM . getDataDirectory ( ) ; assertEquals ( new File ( c _NUM Path + _STR + dataDir _NUM , ! dataDir _NUM . equals ( dataDir _NUM ) ) ; } finally { MiniDFSCluster . shutdownCluster ( cluster _NUM ) ; MiniDFSCluster . shutdownCluster ( cluster _NUM ) ; } } 
4164	public void recover ( ) { try { boolean checkpointExists = mUfs . isFile ( mCheckpoint . toString ( ) ) ; boolean backupCheckpointExists = mUfs . isFile ( mBackupCheckpoint . toString ( ) ) ; boolean tempBackupCheckpointExists = mUfs . isFile ( mTempBackupCheckpoint . toString ( ) ) ; Preconditions . checkState ( ! ( checkpointExists & & backupCheckpointExists & & tempBackupCheckpointExists ) , _STR ) ; if ( tempBackupCheckpointExists ) { If mCheckpointPath also exists , step _NUM must have implemented rename as copy + delete , and failed during the delete . UnderFileSystemUtils . deleteFileIfExists ( mUfs , mCheckpoint . toString ( ) ) ; mUfs . renameFile ( mTempBackupCheckpoint . toString ( ) , mCheckpoint . toString ( ) ) ; } if ( backupCheckpointExists ) { We must have crashed after step _NUM if ( checkpointExists ) { We crashed after step _NUM , so we can finish steps _NUM and _NUM . mWriter . deleteCompletedLogs ( ) ; mUfs . deleteFile ( mBackupCheckpoint . toString ( ) ) ; } else { We crashed before step _NUM , so we roll back to the backup checkpoint . mUfs . renameFile ( mBackupCheckpoint . toString ( ) , mCheckpoint . toString ( ) ) ; } } } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } 
4165	public Object getAttribute ( String name ) { HttpSession session = getHttpSession ( ) ; if ( session ! = null ) { return session . getAttribute ( name ) ; } return null ; } 
4166	public void addInodeModeFromJournalWithEmptyOwnership ( ) throws Exception { createPath ( mTree , NESTED _ FILE _ URI , sNestedFileOptions ) ; InodeDirectory root = mTree . getRoot ( ) ; InodeDirectory nested = ( InodeDirectory ) root . getChild ( _STR , child . getGroup ( ) ) ; Assert . assertEquals ( ( short ) _NUM _NUM _NUM _NUM , child . getMode ( ) ) ; } } } } 
4167	public boolean equals ( java . lang . Object obj ) { return obj ! = null & & obj . getClass ( ) = = getClass ( ) & & ( ( Integer ) obj ) . value = = value ; } 
4168	public void trim ( ) { if ( count _ > nomEntries _ ) { updateTheta ( ) ; rebuild ( keys _ . length ) ; } } 
4169	public static List < TraversalStrategy < ? > > sortStrategies ( final List < TraversalStrategy < ? > > strategies ) { final Map < Class < ? extends TraversalStrategy > , Set < Class < ? extends TraversalStrategy > > > dependencyMap = new HashMap < > ( ) ; final Map < Class < ? extends TraversalStrategy > , Set < Class < ? extends TraversalStrategy > > > strategiesByCategory = new HashMap < > ( ) ; final Set < Class < ? extends TraversalStrategy > > strategyClasses = new HashSet < > ( strategies . size ( ) ) ; Initialize data structure strategies . forEach ( s - > { strategyClasses . add ( s . getClass ( ) ) ; MultiMap . put ( strategiesByCategory , s . getTraversalCategory ( ) , s . getClass ( ) ) ; } ) ; Initialize all the dependencies strategies . forEach ( strategy - > { strategy . applyPrior ( ) . forEach ( s - > { if ( strategyClasses . contains ( s ) ) MultiMap . put ( dependencyMap , strategy . getClass ( ) , s ) ; } ) ; strategy . applyPost ( ) . forEach ( s - > { if ( strategyClasses . contains ( s ) ) MultiMap . put ( dependencyMap , s , strategy . getClass ( ) ) ; } ) ; } ) ; Add dependencies by category final List < Class < ? extends TraversalStrategy > > strategiesInPreviousCategories = new ArrayList < > ( ) ; for ( Class < ? extends TraversalStrategy > category : STRATEGY _ CATEGORIES ) { final Set < Class < ? extends TraversalStrategy > > strategiesInThisCategory = MultiMap . get ( strategiesByCategory , category ) ; for ( Class < ? extends TraversalStrategy > strategy : strategiesInThisCategory ) { for ( Class < ? extends TraversalStrategy > previousStrategy : strategiesInPreviousCategories ) { MultiMap . put ( dependencyMap , strategy , previousStrategy ) ; } } strategiesInPreviousCategories . addAll ( strategiesInThisCategory ) ; } Finally sort via t - sort final List < Class < ? extends TraversalStrategy > > unprocessedStrategyClasses = new ArrayList < > ( strategies . stream ( ) . map ( s - > s . getClass ( ) ) . collect ( Collectors . toSet ( ) ) ) ; final List < Class < ? extends TraversalStrategy > > sortedStrategyClasses = new ArrayList < > ( ) ; final Set < Class < ? extends TraversalStrategy > > seenStrategyClasses = new HashSet < > ( ) ; while ( ! unprocessedStrategyClasses . isEmpty ( ) ) { final Class < ? extends TraversalStrategy > strategy = unprocessedStrategyClasses . get ( _NUM ) ; visit ( dependencyMap , sortedStrategyClasses , seenStrategyClasses , unprocessedStrategyClasses , strategy ) ; } final List < TraversalStrategy < ? > > sortedStrategies = new ArrayList < > ( ) ; We now have a list of sorted strategy classes for ( Class < ? extends TraversalStrategy > strategyClass : sortedStrategyClasses ) { for ( TraversalStrategy strategy : strategies ) { if ( strategy . getClass ( ) . equals ( strategyClass ) ) { sortedStrategies . add ( strategy ) ; } } } return sortedStrategies ; } 
4170	public static InetAddress getJustBroadcastAddress ( ) { if ( broadcastInetAddress = = null ) broadcastInetAddress = DatabaseDescriptor . getBroadcastAddress ( ) = = null ? getJustLocalAddress ( ) : DatabaseDescriptor . getBroadcastAddress ( ) ; return broadcastInetAddress ; } 
4171	public void refreshSources ( String peerId ) throws IOException { String terminateMessage = _STR + src . getPeerId ( ) ) ; src . startup ( ) ; List < ReplicationSourceInterface > toStartup = new ArrayList < > ( ) ; synchronized on oldsources to avoid race with NodeFailoverWorker synchronized ( this . oldsources ) { List < String > previousQueueIds = new ArrayList < > ( ) ; for ( ReplicationSourceInterface oldSource : this . oldsources ) { if ( oldSource . getPeerId ( ) . equals ( peerId ) ) { previousQueueIds . add ( oldSource . getQueueId ( ) ) ; oldSource . terminate ( terminateMessage ) ; this . oldsources . remove ( oldSource ) ; } } for ( String queueId : previousQueueIds ) { ReplicationSourceInterface replicationSource = createSource ( queueId , peer ) ; this . oldsources . add ( replicationSource ) ; for ( SortedSet < String > walsByGroup : walsByIdRecoveredQueues . get ( queueId ) . values ( ) ) { walsByGroup . forEach ( wal - > src . enqueueLog ( new Path ( wal ) ) ) ; } toStartup . add ( replicationSource ) ; } } for ( ReplicationSourceInterface replicationSource : toStartup ) { replicationSource . startup ( ) ; } } 
4172	public static String getConnectHost ( ServiceType service ) { if ( Configuration . containsKey ( service . mHostNameKey ) ) { String connectHost = Configuration . get ( service . mHostNameKey ) ; if ( ! connectHost . isEmpty ( ) & & ! connectHost . equals ( WILDCARD _ ADDRESS ) ) { return connectHost ; } } if ( Configuration . containsKey ( service . mBindHostKey ) ) { String bindHost = Configuration . get ( service . mBindHostKey ) ; if ( ! bindHost . isEmpty ( ) & & ! bindHost . equals ( WILDCARD _ ADDRESS ) ) { return bindHost ; } } return getLocalHostName ( ) ; } 
4173	public static void executeNoFail ( Callable < ? > task , boolean logException ) { try { task . call ( ) ; } catch ( Exception e ) { if ( logException ) logger . error ( e . getMessage ( ) , e ) ; } } 
4174	public static void getMyMemoryState ( RunningAppProcessInfo outState ) { try { getService ( ) . getMyMemoryState ( outState ) ; } catch ( RemoteException e ) { throw e . rethrowFromSystemServer ( ) ; } } 
4175	public Builder setTicker ( CharSequence tickerText ) { mN . tickerText = safeCharSequence ( tickerText ) ; return this ; } 
4176	protected final void moveToNextIndex ( ) { _NUM opcodes . . . if ( ( _ index = nextIndex ( ) ) < _NUM ) { throw new NoSuchElementException ( ) ; } } 
4177	public void onApplicationEvent ( final CustomerPersistedEvent event ) { Customer dbCustomer = event . getCustomer ( ) ; if there is an active request , remove the session - based customer if it exists and update CustomerState WebRequest request = BroadleafRequestContext . getBroadleafRequestContext ( ) . getWebRequest ( ) ; if ( request ! = null ) { String customerAttribute = CustomerStateRequestProcessor . getAnonymousCustomerSessionAttributeName ( ) ; String customerIdAttribute = CustomerStateRequestProcessor . getAnonymousCustomerIdSessionAttributeName ( ) ; if ( BLCRequestUtils . isOKtoUseSession ( request ) ) { Customer sessionCustomer = ( Customer ) request . getAttribute ( customerAttribute , WebRequest . SCOPE _ GLOBAL _ SESSION ) ; persisted if ( sessionCustomer ! = null & & sessionCustomer . getId ( ) . equals ( dbCustomer . getId ( ) ) ) { request . removeAttribute ( customerAttribute , WebRequest . SCOPE _ GLOBAL _ SESSION ) ; request . setAttribute ( customerIdAttribute , dbCustomer . getId ( ) , WebRequest . SCOPE _ GLOBAL _ SESSION ) ; } } Update CustomerState if the persisted Customer ID is the same if ( CustomerState . getCustomer ( ) ! = null & & CustomerState . getCustomer ( ) . getId ( ) . equals ( dbCustomer . getId ( ) ) ) { Copy transient fields from the customer that existed in CustomerState , prior to the DB refresh , to the customer that has been saved ( merged ) in the DB . . . . Customer preMergedCustomer = CustomerState . getCustomer ( ) ; resetTransientFields ( preMergedCustomer , dbCustomer ) ; CustomerState . setCustomer ( dbCustomer ) ; } } } 
4178	protected static void editProperties ( final CmsUUID structureId , final I _ CmsContextMenuHandler contextMenuHandler ) { CmsRpcAction < CmsPropertiesBean > action = new CmsRpcAction < CmsPropertiesBean > ( ) { @ Override public void execute ( ) { start ( _NUM , true ) ; CmsCoreProvider . getVfsService ( ) . loadPropertyData ( structureId , this ) ; } @ Override protected void onResponse ( CmsPropertiesBean result ) { CmsSimplePropertyEditorHandler handler = new CmsSimplePropertyEditorHandler ( contextMenuHandler ) ; handler . setPropertiesBean ( result ) ; CmsVfsModePropertyEditor editor = new CmsVfsModePropertyEditor ( result . getPropertyDefinitions ( ) , handler ) ; editor . setShowResourceProperties ( ! handler . isFolder ( ) ) ; stop ( false ) ; editor . start ( ) ; } } ; action . execute ( ) ; } 
4179	public void testRemove _ Node _ Node _ Node ( ) { for ( int i = _NUM ; i < cases . length ; i + = _NUM ) for ( int j = _NUM ; j < _NUM ; j + = _NUM ) { Graph content = producer . newInstance ( ) ; Graph baseContent = copy ( content ) ; graphAddTxn ( content , cases [ i ] [ _NUM ] ) ; Triple remove = triple ( cases [ i ] [ _NUM ] ) ; Graph expected = graphWith ( cases [ i ] [ _NUM ] ) ; Triple [ ] removed = tripleArray ( cases [ i ] [ _NUM ] ) ; content . getEventManager ( ) . register ( GL ) ; GL . clear ( ) ; txnBegin ( content ) ; content . remove ( remove . getSubject ( ) , remove . getPredicate ( ) , remove . getObject ( ) ) ; txnCommit ( content ) ; check for optional delete notifications if ( GL . contains ( _STR , content , GraphEvents . remove ( remove . getSubject ( ) , remove . getPredicate ( ) , remove . getObject ( ) ) ) ; content . getEventManager ( ) . unregister ( GL ) ; Graph finalContent = remove ( copy ( content ) , baseContent ) ; txnBegin ( finalContent ) ; assertIsomorphic ( cases [ i ] [ _NUM ] , expected , finalContent ) ; txnRollback ( finalContent ) ; } } 
4180	private boolean shouldResubmitTransaction ( Set < TableRef > txTableRefs ) throws SQLException { if ( logger . isInfoEnabled ( ) ) logger . info ( _STR ) ) ; If any indexes were added , then the conflict might be due to DDL / DML fence . return allImmutableTables | | addedAnyIndexes ; } 
4181	public void processBlasCall ( String blasOpName ) { String key = _STR ; lastZ = _NUM ; } 
4182	private Table findTable ( String alias ) { List < String > names = null ; if ( tableScope = = null ) { no tables to find return null ; } for ( ScopeChild child : tableScope . children ) { if ( catalogReader . nameMatcher ( ) . matches ( child . name , alias ) ) { names = ( ( SqlIdentifier ) child . namespace . getNode ( ) ) . names ; break ; } } if ( names = = null | | names . size ( ) = = _NUM ) { return null ; } else if ( names . size ( ) = = _NUM ) { return findTable ( catalogReader . getRootSchema ( ) , names . get ( _NUM ) , catalogReader . nameMatcher ( ) . isCaseSensitive ( ) ) ; } CalciteSchema . TableEntry entry = SqlValidatorUtil . getTableEntry ( catalogReader , names ) ; return entry = = null ? null : entry . getTable ( ) ; } 
4183	public float getPercentOfTotal ( float val ) { return val / mData . getYValueSum ( ) * _NUM _NUM _NUM f ; } 
4184	protected void addDefaultApps ( ContextHandlerCollection parent , final String appDir , Configuration conf ) throws IOException { set up the context for _STR ) ; setContextAttributes ( staticContext , conf ) ; defaultContexts . put ( staticContext , true ) ; } 
4185	public void renameSnapshot ( final INodesInPath iip , final String snapshotRoot , final String oldSnapshotName , final String newSnapshotName ) throws IOException { final INodeDirectory srcRoot = getSnapshottableRoot ( iip ) ; srcRoot . renameSnapshot ( snapshotRoot , oldSnapshotName , newSnapshotName ) ; } 
4186	public TBigDecimal scaleByPowerOfTen ( int n ) { long newScale = scale - ( long ) n ; if ( bitLength < _NUM _NUM ) { Taking care when a _NUM is to be scaled if ( smallValue = = _NUM ) { return zeroScaledBy ( newScale ) ; } return valueOf ( smallValue , toIntScale ( newScale ) ) ; } return new TBigDecimal ( getUnscaledValue ( ) , toIntScale ( newScale ) ) ; } 
4187	private Fraction addSub ( final Fraction fraction , final boolean isAdd ) { Validate . isTrue ( fraction ! = null , _STR ) ; } return new Fraction ( w . intValue ( ) , mulPosAndCheck ( denominator / d _NUM , fraction . denominator / d _NUM ) ) ; } 
4188	private SetMultimap < Type , Coder < ? > > getTypeToCoderBindings ( ParameterizedType type , Coder < ? > coder ) { List < Type > typeArguments = Arrays . asList ( type . getActualTypeArguments ( ) ) ; List < ? extends Coder < ? > > coderArguments = coder . getCoderArguments ( ) ; if ( ( coderArguments = = null ) | | ( typeArguments . size ( ) ! = coderArguments . size ( ) ) ) { return ImmutableSetMultimap . of ( ) ; } else { SetMultimap < Type , Coder < ? > > typeToCoder = HashMultimap . create ( ) ; typeToCoder . put ( type , coder ) ; for ( int i = _NUM ; i < typeArguments . size ( ) ; i + + ) { Type typeArgument = typeArguments . get ( i ) ; Coder < ? > coderArgument = coderArguments . get ( i ) ; if ( coderArgument ! = null ) { typeToCoder . putAll ( getTypeToCoderBindings ( typeArgument , coderArgument ) ) ; } } return ImmutableSetMultimap . < Type , Coder < ? > > builder ( ) . putAll ( typeToCoder ) . build ( ) ; } } 
4189	public void startScheduler ( ) throws SchedulerException { for ( JobToAdd add : jobsToAdd ) { doAddJob ( add . getJob ( ) , add . getTrigger ( ) ) ; } jobsToAdd . clear ( ) ; if ( ! getScheduler ( ) . isStarted ( ) ) { if ( getStartDelayedSeconds ( ) > _NUM ) { LOG . info ( _STR + getScheduler ( ) . getSchedulerName ( ) ) ; getScheduler ( ) . start ( ) ; } } } 
4190	public AnimationManager getAnimationManager ( ) { Form f = getComponentForm ( ) ; if ( f = = null ) { return null ; } return f . getAnimationManager ( ) ; } 
4191	public Document toDOMDocument ( InputStream in , Exchange exchange ) throws IOException , SAXException , ParserConfigurationException { DocumentBuilder documentBuilder = getDocumentBuilderFactory ( exchange ) . newDocumentBuilder ( ) ; return documentBuilder . parse ( in ) ; } 
4192	public int show ( FragmentTransaction transaction , String tag ) { mDismissed = false ; mShownByMe = true ; transaction . add ( this , tag ) ; mViewDestroyed = false ; mBackStackId = transaction . commit ( ) ; return mBackStackId ; } 
4193	public org . apache . drill . exec . proto . UserProtos . ColumnMetadata . Builder getColumnsBuilder ( int index ) { return getColumnsFieldBuilder ( ) . getBuilder ( index ) ; } 
4194	protected void initialize ( CmsObject cms ) throws CmsRoleViolationException { checkFrozen ( ) ; check if the user has the required permissions OpenCms . getRoleManager ( ) . checkRole ( cms , CmsRole . DATABASE _ MANAGER ) ; m _ frozen = true ; m _ resources = Collections . unmodifiableList ( m _ resources ) ; } 
4195	private void verifySplitPointScenario ( int splitPointAfter , boolean shouldSplitStripe , float splitRatioToVerify , int . . . sizes ) throws Exception { assertTrue ( sizes . length > _NUM ) ; ArrayList < HStoreFile > sfs = new ArrayList < > ( ) ; for ( int sizeIx = _NUM ; sizeIx < sizes . length ; + + sizeIx ) { byte [ ] startKey = ( sizeIx = = _NUM ) ? OPEN _ KEY : Bytes . toBytes ( sizeIx - _NUM ) ; byte [ ] endKey = ( sizeIx = = sizes . length - _NUM ) ? OPEN _ KEY : Bytes . toBytes ( sizeIx ) ; MockHStoreFile sf = createFile ( sizes [ sizeIx ] , _NUM , startKey , endKey ) ; set split point to the negative index sf . splitPoint = Bytes . toBytes ( - sizeIx ) ; sfs . add ( sf ) ; } Configuration conf = HBaseConfiguration . create ( ) ; if ( splitRatioToVerify ! = _NUM ) { conf . setFloat ( StripeStoreConfig . MAX _ REGION _ SPLIT _ IMBALANCE _ KEY , splitRatioToVerify ) ; } StripeStoreFileManager manager = createManager ( al ( ) , conf ) ; manager . addCompactionResults ( al ( ) , sfs ) ; int result = Bytes . toInt ( manager . getSplitPoint ( ) . get ( ) ) ; Either end key and thus positive index , or _STR of the file and thus negative index . assertEquals ( splitPointAfter * ( shouldSplitStripe ? - _NUM : _NUM ) , result ) ; } 
4196	public void estimateTxSize ( ) { txFeeFromFeeService = feeService . getTxFee ( feeTxSize ) ; Address fundingAddress = btcWalletService . getOrCreateAddressEntry ( AddressEntry . Context . AVAILABLE ) . getAddress ( ) ; Address reservedForTradeAddress = btcWalletService . getOrCreateAddressEntry ( offerId , AddressEntry . Context . RESERVED _ FOR _ TRADE ) . getAddress ( ) ; Address changeAddress = btcWalletService . getOrCreateAddressEntry ( AddressEntry . Context . AVAILABLE ) . getAddress ( ) ; Coin reservedFundsForOffer = getSecurityDeposit ( ) ; if ( ! isBuyOffer ( ) ) reservedFundsForOffer = reservedFundsForOffer . add ( amount . get ( ) ) ; checkNotNull ( user . getAcceptedArbitrators ( ) , _STR , txFeeFromFeeService . toFriendlyString ( ) , feeService . getTxFeePerByte ( ) ) ; } } 
4197	public float getPitch ( ) { return getPitchRad ( ) * MathUtils . radiansToDegrees ; } 
4198	public void confirmPassword ( String password , byte [ ] keySpec , byte [ ] keySalt , byte [ ] verifier , byte [ ] verifierSalt , byte [ ] integritySalt ) { StandardEncryptionVerifier ver = ( StandardEncryptionVerifier ) getEncryptionInfo ( ) . getVerifier ( ) ; ver . setSalt ( verifierSalt ) ; SecretKey secretKey = generateSecretKey ( password , ver , getKeySizeInBytes ( ) ) ; setSecretKey ( secretKey ) ; Cipher cipher = getCipher ( secretKey , null ) ; try { byte [ ] encryptedVerifier = cipher . doFinal ( verifier ) ; MessageDigest hashAlgo = CryptoFunctions . getMessageDigest ( ver . getHashAlgorithm ( ) ) ; byte [ ] calcVerifierHash = hashAlgo . digest ( verifier ) ; _NUM . _NUM . _NUM EncryptionVerifier . . . An array of bytes that contains the encrypted form of the hash of the randomly generated Verifier value . The length of the array MUST be the size of the encryption block size multiplied by the number of blocks needed to encrypt the hash of the Verifier . If the encryption algorithm is RC _NUM , the length MUST be _NUM _NUM bytes . If the encryption algorithm is AES , the length MUST be _NUM _NUM bytes . After decrypting the EncryptedVerifierHash field , only the first VerifierHashSize bytes MUST be used . int encVerHashSize = ver . getCipherAlgorithm ( ) . encryptedVerifierHashLength ; byte [ ] encryptedVerifierHash = cipher . doFinal ( Arrays . copyOf ( calcVerifierHash , encVerHashSize ) ) ; ver . setEncryptedVerifier ( encryptedVerifier ) ; ver . setEncryptedVerifierHash ( encryptedVerifierHash ) ; } catch ( GeneralSecurityException e ) { throw new EncryptedDocumentException ( _STR , e ) ; } } 
4199	public String getWidgetEditor ( CmsRequestContext context , String userAgent ) { step _NUM : check if the user specified a preferred editor for the resource type xmlpage CmsUserSettings settings = new CmsUserSettings ( context . getCurrentUser ( ) ) ; String resourceType = CmsResourceTypeXmlPage . getStaticTypeName ( ) ; String preferredEditorSetting = settings . getPreferredEditor ( resourceType ) ; if ( preferredEditorSetting = = null ) { no preferred editor setting found for this resource type , look for mapped resource type preferred editor Iterator i = m _ editorConfigurations . iterator ( ) ; while ( i . hasNext ( ) ) { CmsWorkplaceEditorConfiguration currentConfig = ( CmsWorkplaceEditorConfiguration ) i . next ( ) ; String mapping = currentConfig . getMappingForResourceType ( resourceType ) ; if ( mapping ! = null ) { preferredEditorSetting = settings . getPreferredEditor ( mapping ) ; } if ( preferredEditorSetting ! = null ) { break ; } } } if ( preferredEditorSetting ! = null ) { CmsWorkplaceEditorConfiguration preferredConf = filterPreferredEditor ( preferredEditorSetting ) ; if ( ( preferredConf ! = null ) & & preferredConf . isWidgetEditor ( ) & & preferredConf . matchesBrowser ( userAgent ) ) { return preferred editor only if it matches the current users browser return preferredConf . getWidgetEditor ( ) ; } } step _NUM : filter editors for the given resoure type SortedMap filteredEditors = filterEditorsForResourceType ( resourceType ) ; step _NUM : check if one of the editors matches the current users browser while ( filteredEditors . size ( ) > _NUM ) { check editor configuration with highest ranking Float key = ( Float ) filteredEditors . lastKey ( ) ; CmsWorkplaceEditorConfiguration conf = ( CmsWorkplaceEditorConfiguration ) filteredEditors . get ( key ) ; if ( conf . isWidgetEditor ( ) & & conf . matchesBrowser ( userAgent ) ) { return conf . getWidgetEditor ( ) ; } filteredEditors . remove ( key ) ; } no valid editor found return null ; } 
4200	public void addConfigNode ( ) { DataNode zookeeperZnode = nodes . get ( procZookeeper ) ; if ( zookeeperZnode ! = null ) { should always be the case zookeeperZnode . addChild ( configChildZookeeper ) ; } else { assert false : _STR ; } } 
4201	public static byte [ ] getClientId ( ) { Call call = CurCall . get ( ) ; return call ! = null ? call . clientId : RpcConstants . DUMMY _ CLIENT _ ID ; } 
4202	public String readMethod ( ) throws IOException { int tag = read ( ) ; if ( tag ! = ' m ' ) throw error ( _STR + codeName ( tag ) ) ; int d _NUM = read ( ) ; int d _NUM = read ( ) ; _ isLastChunk = true ; _ chunkLength = d _NUM * _NUM _NUM _NUM + d _NUM ; _ sbuf . setLength ( _NUM ) ; int ch ; while ( ( ch = parseChar ( ) ) > = _NUM ) _ sbuf . append ( ( char ) ch ) ; _ method = _ sbuf . toString ( ) ; return _ method ; } 
4203	public void startIntentSenderFromFragment ( Fragment fragment , IntentSender intent , int requestCode , @ Nullable Intent fillInIntent , int flagsMask , int flagsValues , int extraFlags , Bundle options ) throws IntentSender . SendIntentException { mStartedIntentSenderFromFragment = true ; try { if ( requestCode = = - _NUM ) { ActivityCompat . startIntentSenderForResult ( this , intent , requestCode , fillInIntent , flagsMask , flagsValues , extraFlags , options ) ; return ; } checkForValidRequestCode ( requestCode ) ; int requestIndex = allocateRequestIndex ( fragment ) ; ActivityCompat . startIntentSenderForResult ( this , intent , ( ( requestIndex + _NUM ) < < _NUM _NUM ) + ( requestCode & _NUM xffff ) , fillInIntent , flagsMask , flagsValues , extraFlags , options ) ; } finally { mStartedIntentSenderFromFragment = false ; } } 
4204	protected GuacamoleTunnel getTunnel ( String tunnelUUID ) throws GuacamoleException { Pull tunnel from map GuacamoleTunnel tunnel = tunnels . get ( tunnelUUID ) ; if ( tunnel = = null ) throw new GuacamoleResourceNotFoundException ( _STR ) ; return tunnel ; } 
4205	public void test _ multi _ destory ( ) { init ( _NUM ) ; DubboAppender . doStart ( ) ; DubboAppender . clear ( ) ; demoServiceInvoker . destroy ( ) ; demoServiceInvoker . destroy ( ) ; Assert . assertEquals ( _STR , _NUM , LogUtil . findMessage ( errorMsg ) ) ; LogUtil . checkNoError ( ) ; DubboAppender . doStop ( ) ; destoy ( ) ; } 
4206	public static XmlIDREF parse ( java . lang . String s , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException { return ( XmlIDREF ) XmlBeans . getContextTypeLoader ( ) . parse ( s , type , options ) ; } 
4207	public boolean canConsume ( char expected ) throws IllegalStateException { if ( ! matches ( expected ) ) return false ; moveToNextToken ( ) ; return true ; } 
4208	public Templates getTemplate ( String key ) { if ( ! isCaching ( ) ) { return null ; } return stylesheets . get ( key ) ; } 
4209	public void add ( int key , int value ) { if ( size = = capacity & & compare ( keys [ _NUM ] , values [ _NUM ] , key , value ) > = _NUM ) { than value , do nothing return ; } int position ; if ( size < capacity ) { If the heap is not full , increase its size and find the position for new element ( up - heap search ) position = size ; size + + ; while ( position > _NUM ) { int parent = ( position - _NUM ) > > _NUM ; if ( compare ( keys [ parent ] , values [ parent ] , key , value ) < _NUM ) { break ; } values [ position ] = values [ parent ] ; keys [ position ] = keys [ parent ] ; position = parent ; } } else { If the heap is full , remove element from the root and find the position for new element ( down - heap search ) position = removeRootAndFindPosition ( key , value ) ; } Fill position with key value pair keys [ position ] = key ; values [ position ] = value ; } 
4210	private View findAccessibilityFocusHost ( boolean searchDescendants ) { if ( isAccessibilityFocusedViewOrHost ( ) ) { return this ; } if ( searchDescendants ) { final ViewRootImpl viewRoot = getViewRootImpl ( ) ; if ( viewRoot ! = null ) { final View focusHost = viewRoot . getAccessibilityFocusedHost ( ) ; if ( focusHost ! = null & & ViewRootImpl . isViewDescendantOf ( focusHost , this ) ) { return focusHost ; } } } return null ; } 
4211	public int read ( byte [ ] b , int offset , int length ) throws IOException { if ( mCodec = = null ) { throw new IllegalStateException ( _STR ) ; } if ( mBufOut > = mBufIn & & ! mSawOutputEOS ) { no data left in buffer , refill it mBufOut = _NUM ; mBufIn = _NUM ; first push as much data into the encoder as possible while ( ! mSawInputEOS ) { int index = mCodec . dequeueInputBuffer ( _NUM ) ; if ( index < _NUM ) { no input buffer currently available break ; } else { int numRead ; for ( numRead = _NUM ; numRead < SAMPLES _ PER _ FRAME * _NUM ; ) { int n = mInputStream . read ( mBuf , numRead , SAMPLES _ PER _ FRAME * _NUM - numRead ) ; if ( n = = - _NUM ) { mSawInputEOS = true ; break ; } numRead + = n ; } ByteBuffer buf = mCodec . getInputBuffer ( index ) ; buf . put ( mBuf , _NUM , numRead ) ; mCodec . queueInputBuffer ( index , _NUM , numRead , _NUM , mSawInputEOS ? MediaCodec . BUFFER _ FLAG _ END _ OF _ STREAM : _NUM ) ; } } now read encoded data from the encoder int index = mCodec . dequeueOutputBuffer ( mInfo , _NUM ) ; if ( index > = _NUM ) { mBufIn = mInfo . size ; ByteBuffer out = mCodec . getOutputBuffer ( index ) ; out . get ( mBuf , _NUM , mBufIn ) ; mCodec . releaseOutputBuffer ( index , false ) ; if ( ( mInfo . flags & MediaCodec . BUFFER _ FLAG _ END _ OF _ STREAM ) ! = _NUM ) { mSawOutputEOS = true ; } } } if ( mBufOut < mBufIn ) { there is data in the buffer if ( length > mBufIn - mBufOut ) { length = mBufIn - mBufOut ; } System . arraycopy ( mBuf , mBufOut , b , offset , length ) ; mBufOut + = length ; return length ; } if ( mSawInputEOS & & mSawOutputEOS ) { no more data available in buffer , codec or input stream return - _NUM ; } caller should try again return _NUM ; } 
4212	Iterable < WindowedValue < AccumT > > combOp ( Iterable < WindowedValue < AccumT > > a _NUM , Iterable < WindowedValue < AccumT > > a _NUM ) { concatenate accumulators . Iterable < WindowedValue < AccumT > > accumulators = Iterables . concat ( a _NUM , a _NUM ) ; if empty , return an empty accumulators iterable . if ( ! accumulators . iterator ( ) . hasNext ( ) ) { return Lists . newArrayList ( ) ; } sort accumulators , no need to explode since inputs were exploded . Iterable < WindowedValue < AccumT > > sortedAccumulators = sortByWindows ( accumulators ) ; @ SuppressWarnings ( _STR ) TimestampCombiner timestampCombiner = windowingStrategy . getTimestampCombiner ( ) ; - - - accumulators iterator , by window order . final Iterator < WindowedValue < AccumT > > iterator = sortedAccumulators . iterator ( ) ; get the first accumulator and assign it to the current window ' s accumulators . WindowedValue < AccumT > currentValue = iterator . next ( ) ; BoundedWindow currentWindow = Iterables . getFirst ( currentValue . getWindows ( ) , null ) ; List < AccumT > currentWindowAccumulators = Lists . newArrayList ( ) ; currentWindowAccumulators . add ( currentValue . getValue ( ) ) ; keep track of the timestamps assigned by the TimestampCombiner , in createCombiner we already merge the timestamps assigned to individual elements , here we will just merge them . List < Instant > windowTimestamps = Lists . newArrayList ( ) ; windowTimestamps . add ( currentValue . getTimestamp ( ) ) ; accumulate the next windows , or output . List < WindowedValue < AccumT > > output = Lists . newArrayList ( ) ; if merging , merge overlapping windows , e . g . Sessions . final boolean merging = ! windowingStrategy . getWindowFn ( ) . isNonMerging ( ) ; while ( iterator . hasNext ( ) ) { WindowedValue < AccumT > nextValue = iterator . next ( ) ; BoundedWindow nextWindow = Iterables . getOnlyElement ( nextValue . getWindows ( ) ) ; boolean mergingAndIntersecting = merging & & isIntersecting ( ( IntervalWindow ) currentWindow , ( IntervalWindow ) nextWindow ) ; if ( mergingAndIntersecting | | nextWindow . equals ( currentWindow ) ) { if ( mergingAndIntersecting ) { merge intersecting windows . currentWindow = merge ( ( IntervalWindow ) currentWindow , ( IntervalWindow ) nextWindow ) ; } add to window accumulators . currentWindowAccumulators . add ( nextValue . getValue ( ) ) ; windowTimestamps . add ( nextValue . getTimestamp ( ) ) ; } else { before moving to the next window , add the current accumulation to the output and initialize the accumulation . merge the timestamps of all accumulators to merge . Instant mergedTimestamp = timestampCombiner . merge ( currentWindow , windowTimestamps ) ; merge accumulators . transforming a KV < K , Iterable < AccumT > > into a KV < K , Iterable < AccumT > > . for the ( possibly merged ) window . Iterable < AccumT > accumsToMerge = Iterables . unmodifiableIterable ( currentWindowAccumulators ) ; WindowedValue < Iterable < AccumT > > preMergeWindowedValue = WindowedValue . of ( accumsToMerge , mergedTimestamp , currentWindow , PaneInfo . NO _ FIRING ) ; applying the actual combiner onto the accumulators . AccumT accumulated = combineFn . mergeAccumulators ( accumsToMerge , ctxtForInput ( preMergeWindowedValue ) ) ; WindowedValue < AccumT > postMergeWindowedValue = preMergeWindowedValue . withValue ( accumulated ) ; emit the accumulated output . output . add ( postMergeWindowedValue ) ; re - init accumulator , window and timestamps . currentWindowAccumulators . clear ( ) ; currentWindowAccumulators . add ( nextValue . getValue ( ) ) ; currentWindow = nextWindow ; windowTimestamps . clear ( ) ; windowTimestamps . add ( nextValue . getTimestamp ( ) ) ; } } merge the last chunk of accumulators . Instant mergedTimestamp = timestampCombiner . merge ( currentWindow , windowTimestamps ) ; Iterable < AccumT > accumsToMerge = Iterables . unmodifiableIterable ( currentWindowAccumulators ) ; WindowedValue < Iterable < AccumT > > preMergeWindowedValue = WindowedValue . of ( accumsToMerge , mergedTimestamp , currentWindow , PaneInfo . NO _ FIRING ) ; AccumT accumulated = combineFn . mergeAccumulators ( accumsToMerge , ctxtForInput ( preMergeWindowedValue ) ) ; WindowedValue < AccumT > postMergeWindowedValue = preMergeWindowedValue . withValue ( accumulated ) ; output . add ( postMergeWindowedValue ) ; return output ; } 
4213	byte [ ] hashed ( byte [ ] val , Integer . . . depths ) { ArrayDeque < Integer > dstack = new ArrayDeque < Integer > ( ) ; ArrayDeque < byte [ ] > hstack = new ArrayDeque < byte [ ] > ( ) ; Iterator < Integer > depthiter = Arrays . asList ( depths ) . iterator ( ) ; if ( depthiter . hasNext ( ) ) { dstack . push ( depthiter . next ( ) ) ; hstack . push ( val ) ; } while ( depthiter . hasNext ( ) ) { Integer depth = depthiter . next ( ) ; byte [ ] hash = val ; while ( depth . equals ( dstack . peek ( ) ) ) { consume the stack hash = Hashable . binaryHash ( hstack . pop ( ) , hash ) ; depth = dstack . pop ( ) - _NUM ; } dstack . push ( depth ) ; hstack . push ( hash ) ; } assert hstack . size ( ) = = _NUM ; return hstack . pop ( ) ; } 
4214	public void setColumnRadius ( int r ) { this . columnRadius = r ; fireChangeEvent ( ) ; } 
4215	public synchronized int getAvailableTransportServices ( ) { updateTransportServiceAvailability ( ) ; return _ availableTransportServices ; } 
4216	public void start ( ) throws Exception { m _ numOfSamplesPerGenerator = ( int ) Math . pow ( m _ samplesBase , m _ trainingData . numAttributes ( ) - _NUM ) ; m _ stopReplotting = true ; if ( m _ trainingData = = null ) { throw new Exception ( _STR ) ; } computeMinMaxAtts ( ) ; startPlotThread ( ) ; } 
4217	public String replace ( final LogEvent event , final String source ) { if ( source = = null ) { return null ; } final StringBuilder buf = new StringBuilder ( source ) ; if ( ! substitute ( event , buf , _NUM , source . length ( ) ) ) { return source ; } return buf . toString ( ) ; } 
4218	public final void setDialing ( ) { checkImmutable ( ) ; setState ( STATE _ DIALING ) ; } 
4219	public static String getTableMetadataAsCQL ( TableMetadata metadata , boolean includeDroppedColumns ) { StringBuilder sb = new StringBuilder ( ) ; if ( ! isCqlCompatible ( metadata ) ) { sb . append ( String . format ( _STR ) ; } return sb . toString ( ) ; } 
4220	public Cipher createCipher ( ) { Cipher cipher = EncryptionUtils . createSymmetricCipher ( symmetricKey , cipherMode , cryptoProvider , initVectorBytes ) ; instance . if ( initVectorBytes = = null ) initVectorBytes = cipher . getIV ( ) ; return cipher ; } 
4221	public String htmlHeader ( CmsHtmlList list ) { StringBuffer html = new StringBuffer ( _NUM _NUM _NUM _NUM ) ; html . append ( _STR ) ; return html . toString ( ) ; } 
4222	public Object getMessage ( ) { if ( message ! = null ) { return message ; } else { return getRenderedMessage ( ) ; } } 
4223	public void testBasicHalfMapFile ( ) throws Exception { final HRegionInfo hri = new HRegionInfo ( TableName . valueOf ( _STR ) ) ; HRegionFileSystem regionFs = HRegionFileSystem . createRegionOnFileSystem ( conf , fs , new Path ( testDir , hri . getTable ( ) . getNameAsString ( ) ) , hri ) ; HFileContext meta = new HFileContextBuilder ( ) . withBlockSize ( _NUM * _NUM _NUM _NUM _NUM ) . build ( ) ; StoreFileWriter writer = new StoreFileWriter . Builder ( conf , cacheConf , this . fs ) . withFilePath ( regionFs . createTempName ( ) ) . withFileContext ( meta ) . build ( ) ; writeStoreFile ( writer ) ; Path sfPath = regionFs . commitStoreFile ( TEST _ FAMILY , writer . getPath ( ) ) ; HStoreFile sf = new HStoreFile ( this . fs , sfPath , conf , cacheConf , BloomType . NONE , true ) ; checkHalfHFile ( regionFs , sf ) ; } 
4224	protected void initializeGraph ( ) { super . initializeGraph ( ) ; Utils . setLayerToSW ( this ) ; mPieData = new ArrayList < PieModel > ( ) ; mTotalValue = _NUM ; mGraphPaint = new Paint ( Paint . ANTI _ ALIAS _ FLAG ) ; mLegendPaint = new Paint ( Paint . ANTI _ ALIAS _ FLAG ) ; mLegendPaint . setTextSize ( mLegendTextSize ) ; mLegendPaint . setColor ( mLegendColor ) ; mLegendPaint . setStyle ( Paint . Style . FILL ) ; mValuePaint = new Paint ( Paint . ANTI _ ALIAS _ FLAG ) ; mValuePaint . setTextSize ( mValueTextSize ) ; mValuePaint . setColor ( mValueTextColor ) ; mValuePaint . setStyle ( Paint . Style . FILL ) ; mGraph . rotateTo ( mPieRotation ) ; mGraph . decelerate ( ) ; mRevealAnimator = ValueAnimator . ofFloat ( _NUM , _NUM ) ; mRevealAnimator . addUpdateListener ( new ValueAnimator . AnimatorUpdateListener ( ) { @ Override public void onAnimationUpdate ( ValueAnimator animation ) { mRevealValue = animation . getAnimatedFraction ( ) ; invalidateGlobal ( ) ; } } ) ; mRevealAnimator . addListener ( new Animator . AnimatorListener ( ) { @ Override public void onAnimationStart ( Animator animation ) { } @ Override public void onAnimationEnd ( Animator animation ) { mStartedAnimation = false ; } @ Override public void onAnimationCancel ( Animator animation ) { } @ Override public void onAnimationRepeat ( Animator animation ) { } } ) ; if ( mUsePieRotation ) { Set up an animator to animate the PieRotation property . This is used to correct the pie ' s orientation after the user lets go of it . mAutoCenterAnimator = ObjectAnimator . ofInt ( PieChart . this , _STR ) ) ) ; } } 
4225	public static final Intent getScatterChartIntent ( Context context , XYMultipleSeriesDataset dataset , XYMultipleSeriesRenderer renderer , String activityTitle ) { checkParameters ( dataset , renderer ) ; Intent intent = new Intent ( context , GraphicalActivity . class ) ; XYChart chart = new ScatterChart ( dataset , renderer ) ; intent . putExtra ( CHART , chart ) ; intent . putExtra ( TITLE , activityTitle ) ; return intent ; } 
4226	public Paint getItemFillPaint ( int row , int column ) { return lookupSeriesFillPaint ( row ) ; } 
4227	public boolean sendFingerprintGesture ( int keyCode ) { final IAccessibilityManager service ; synchronized ( mLock ) { service = getServiceLocked ( ) ; if ( service = = null ) { return false ; } } try { return service . sendFingerprintGesture ( keyCode ) ; } catch ( RemoteException e ) { return false ; } } 
4228	public String generateCsv ( ) { Map objects = getData ( ) ; get the data object from session List groups = ( List ) objects . get ( _STR ) . toString ( ) ) ; res . setContentLength ( buffer . length ( ) ) ; return buffer . toString ( ) ; } 
4229	public Iterable < WindowedValue < T > > explodeWindows ( ) { ImmutableList . Builder < WindowedValue < T > > windowedValues = ImmutableList . builder ( ) ; for ( BoundedWindow w : getWindows ( ) ) { windowedValues . add ( of ( getValue ( ) , getTimestamp ( ) , w , getPane ( ) ) ) ; } return windowedValues . build ( ) ; } 
4230	public static byte [ ] encodeUri ( final byte [ ] token , final boolean iri ) { final TokenBuilder tb = new TokenBuilder ( ) ; for ( final byte b : token ) { if ( letterOrDigit ( b ) | | contains ( iri ? IRIRES : RES , b ) ) tb . addByte ( b ) ; else hex ( tb , b ) ; } return tb . finish ( ) ; } 
4231	public void setSettings ( Properties properties ) { resetSettings ( ) ; final Bean bean = getBean ( ) ; final String [ ] propertyNames = bean . getPropertyNames ( ) ; for ( String propertyName : propertyNames ) { final String value = properties . getProperty ( propertyName ) ; if ( value ! = null ) { bean . set ( propertyName , value ) ; } } } 
4232	public void getCurrentSizeRange ( Point outSmallestSize , Point outLargestSize ) { synchronized ( this ) { updateDisplayInfoLocked ( ) ; outSmallestSize . x = mDisplayInfo . smallestNominalAppWidth ; outSmallestSize . y = mDisplayInfo . smallestNominalAppHeight ; outLargestSize . x = mDisplayInfo . largestNominalAppWidth ; outLargestSize . y = mDisplayInfo . largestNominalAppHeight ; } } 
4233	public void inputContentsAreNotAltered _ WidthHeightPositionCropConstructor ( ) { given BufferedImage originalImage = new BufferedImage ( _NUM _NUM _NUM , _NUM _NUM _NUM , BufferedImage . TYPE _ INT _ ARGB ) ; BufferedImage copyImage = BufferedImages . copy ( originalImage ) ; ImageFilter filter = new Canvas ( _NUM _NUM _NUM , _NUM _NUM _NUM , Positions . CENTER , true ) ; when filter . apply ( originalImage ) ; then assertTrue ( BufferedImageComparer . isSame ( originalImage , copyImage ) ) ; } 
4234	public void mergeSubSitemap ( final CmsUUID entryId ) { CmsRpcAction < CmsSitemapChange > mergeAction = new CmsRpcAction < CmsSitemapChange > ( ) { @ Override public void execute ( ) { start ( _NUM , true ) ; getService ( ) . mergeSubSitemap ( getEntryPoint ( ) , entryId , this ) ; } @ Override protected void onResponse ( CmsSitemapChange result ) { stop ( false ) ; applyChange ( result ) ; } } ; mergeAction . execute ( ) ; } 
4235	public void resolve ( ExtensionModule parentModule , Map < String , StackModule > allStacks , Map < String , ServiceModule > commonServices , Map < String , ExtensionModule > extensions ) throws AmbariException { moduleState = ModuleState . VISITED ; checkExtensionName ( allStacks ) ; String parentVersion = extensionInfo . getParentExtensionVersion ( ) ; mergeServicesWithExplicitParent ( allStacks , commonServices , extensions ) ; merge with parent version of same extension definition if ( parentVersion ! = null ) { mergeExtensionWithParent ( parentVersion , allStacks , commonServices , extensions ) ; } moduleState = ModuleState . RESOLVED ; } 
4236	public static String feedbackTypeToString ( int feedbackType ) { StringBuilder builder = new StringBuilder ( ) ; builder . append ( _STR ) ; return builder . toString ( ) ; } 
4237	public void cancel ( ) { mActivePointerId = INVALID _ POINTER ; clearMotionHistory ( ) ; if ( mVelocityTracker ! = null ) { mVelocityTracker . recycle ( ) ; mVelocityTracker = null ; } } 
4238	public static JSONObject toJSONObject ( String string ) throws JSONException { JSONObject o = new JSONObject ( ) ; XMLTokener x = new XMLTokener ( string ) ; while ( x . more ( ) & & x . skipPast ( _STR ) ) { parse ( x , o , null ) ; } return o ; } 
4239	private final boolean cleanUpApplicationRecordLocked ( ProcessRecord app , boolean restarting , boolean allowRestart , int index , boolean replacingPid ) { if ( index > = _NUM ) { removeLruProcessLocked ( app ) ; ProcessList . remove ( app . pid ) ; } mProcessesToGc . remove ( app ) ; mPendingPssProcesses . remove ( app ) ; Dismiss any open dialogs . if ( app . crashDialog ! = null & & ! app . forceCrashReport ) { app . crashDialog . dismiss ( ) ; app . crashDialog = null ; } if ( app . anrDialog ! = null ) { app . anrDialog . dismiss ( ) ; app . anrDialog = null ; } if ( app . waitDialog ! = null ) { app . waitDialog . dismiss ( ) ; app . waitDialog = null ; } app . crashing = false ; app . notResponding = false ; app . resetPackageList ( mProcessStats ) ; app . unlinkDeathRecipient ( ) ; app . makeInactive ( mProcessStats ) ; app . waitingToKill = null ; app . forcingToImportant = null ; updateProcessForegroundLocked ( app , false , false ) ; app . foregroundActivities = false ; app . hasShownUi = false ; app . treatLikeActivity = false ; app . hasAboveClient = false ; app . hasClientActivities = false ; mServices . killServicesLocked ( app , allowRestart ) ; boolean restart = false ; Remove published content providers . for ( int i = app . pubProviders . size ( ) - _NUM ; i > = _NUM ; i - - ) { ContentProviderRecord cpr = app . pubProviders . valueAt ( i ) ; final boolean always = app . bad | | ! allowRestart ; boolean inLaunching = removeDyingProviderLocked ( app , cpr , always ) ; if ( ( inLaunching | | always ) & & cpr . hasConnectionOrHandle ( ) ) { We left the provider in the launching list , need to restart it . restart = true ; } cpr . provider = null ; cpr . proc = null ; } app . pubProviders . clear ( ) ; Take care of any launching providers waiting for this process . if ( cleanupAppInLaunchingProvidersLocked ( app , false ) ) { restart = true ; } Unregister from connected content providers . if ( ! app . conProviders . isEmpty ( ) ) { for ( int i = app . conProviders . size ( ) - _NUM ; i > = _NUM ; i - - ) { ContentProviderConnection conn = app . conProviders . get ( i ) ; conn . provider . connections . remove ( conn ) ; stopAssociationLocked ( app . uid , app . processName , conn . provider . uid , conn . provider . name ) ; } app . conProviders . clear ( ) ; } the actual situation to identify what is actually going on . if ( false ) { for ( int i = mLaunchingProviders . size ( ) - _NUM ; i > = _NUM ; i - - ) { ContentProviderRecord cpr = mLaunchingProviders . get ( i ) ; if ( cpr . connections . size ( ) < = _NUM & & ! cpr . hasExternalProcessHandles ( ) ) { synchronized ( cpr ) { cpr . launchingApp = null ; cpr . notifyAll ( ) ; } } } } skipCurrentReceiverLocked ( app ) ; Unregister any receivers . for ( int i = app . receivers . size ( ) - _NUM ; i > = _NUM ; i - - ) { removeReceiverLocked ( app . receivers . valueAt ( i ) ) ; } app . receivers . clear ( ) ; If the app is undergoing backup , tell the backup manager about it if ( mBackupTarget ! = null & & app . pid = = mBackupTarget . app . pid ) { if ( DEBUG _ BACKUP | | DEBUG _ CLEANUP ) Slog . d ( TAG _ CLEANUP , _STR , app . processName ) ; return true ; } else if ( app . pid > _NUM & & app . pid ! = MY _ PID ) { Goodbye ! boolean removed ; synchronized ( mPidsSelfLocked ) { mPidsSelfLocked . remove ( app . pid ) ; mHandler . removeMessages ( PROC _ START _ TIMEOUT _ MSG , app ) ; } mBatteryStatsService . noteProcessFinish ( app . processName , app . info . uid ) ; if ( app . isolated ) { mBatteryStatsService . removeIsolatedUid ( app . uid , app . info . uid ) ; } app . setPid ( _NUM ) ; } return false ; } 
4240	private void processChangeCipherSpec ( byte [ ] buf , int off , int len ) throws IOException { for ( int i = _NUM ; i < len ; + + i ) { short message = TlsUtils . readUint _NUM ( buf , off + i ) ; if ( message ! = ChangeCipherSpec . change _ cipher _ spec ) { throw new TlsFatalAlert ( AlertDescription . decode _ error ) ; } if ( this . receivedChangeCipherSpec | | alertQueue . available ( ) > _NUM | | handshakeQueue . available ( ) > _NUM ) { throw new TlsFatalAlert ( AlertDescription . unexpected _ message ) ; } recordStream . receivedReadCipherSpec ( ) ; this . receivedChangeCipherSpec = true ; handleChangeCipherSpecMessage ( ) ; } } 
4241	public < K , V > void produce ( String producerName , Serializer < K > keySerializer , Serializer < V > valueSerializer , Consumer < InteractiveProducer < K , V > > producer ) { Properties props = getProducerProperties ( producerName ) ; KafkaProducer < K , V > kafkaProducer = new KafkaProducer < > ( props , keySerializer , valueSerializer ) ; InteractiveProducer < K , V > interactive = new InteractiveProducer < K , V > ( ) { @ Override public InteractiveProducer < K , V > write ( ProducerRecord < K , V > record ) { kafkaProducer . send ( record ) ; kafkaProducer . flush ( ) ; return this ; } @ Override public void close ( ) { kafkaProducer . close ( ) ; } } ; Thread t = new Thread ( ( ) - > { try { producer . accept ( interactive ) ; } finally { interactive . close ( ) ; } } ) ; t . setName ( producerName + _STR ) ; t . start ( ) ; } 
4242	public RevokeSecurityGroupIngressRequest withIpPermissions ( IpPermission . . . ipPermissions ) { if ( getIpPermissions ( ) = = null ) setIpPermissions ( new java . util . ArrayList < IpPermission > ( ipPermissions . length ) ) ; for ( IpPermission value : ipPermissions ) { getIpPermissions ( ) . add ( value ) ; } return this ; } 
4243	public static Map < String , Object > executeMrp ( DispatchContext ctx , Map < String , ? extends Object > context ) { Debug . logInfo ( _STR , module ) ; return result ; } 
4244	public static Set < Binding < ? > > getBindingsOf ( Injector injector , Class < ? > baseClass ) { Set < Binding < ? > > answer = Sets . newHashSet ( ) ; Set < Entry < Key < ? > , Binding < ? > > > entries = injector . getBindings ( ) . entrySet ( ) ; for ( Entry < Key < ? > , Binding < ? > > entry : entries ) { Key < ? > key = entry . getKey ( ) ; Class < ? > keyType = getKeyType ( key ) ; if ( keyType ! = null & & baseClass . isAssignableFrom ( keyType ) ) { answer . add ( entry . getValue ( ) ) ; } } return answer ; } 
4245	 @ Test ( groups = _STR ) ; } catch ( UnavailableException e ) { assertThat ( e . getConsistencyLevel ( ) ) . isEqualTo ( expectedDowngradedCL ) ; } assertOnUnavailableWasCalled ( _NUM ) ; assertThat ( errors . getRetries ( ) . getCount ( ) ) . isEqualTo ( _NUM ) ; assertThat ( errors . getUnavailables ( ) . getCount ( ) ) . isEqualTo ( _NUM ) ; assertThat ( errors . getRetriesOnUnavailable ( ) . getCount ( ) ) . isEqualTo ( _NUM ) ; assertQueried ( _NUM , _NUM ) ; assertQueried ( _NUM , _NUM ) ; assertQueried ( _NUM , _NUM ) ; } 
4246	public synchronized void clear ( T a , T b ) { innerClear ( rows , a , b ) ; innerClear ( cols , b , a ) ; } 
4247	public void setTickFontStyle ( int style ) { Font f = getTickLabelFont ( ) ; String fName = f . getFontName ( ) ; Font newFont = new Font ( fName , style , f . getSize ( ) ) ; setTickLabelFont ( newFont ) ; } 
4248	public static Tree getHeadWordOrPhrase ( Tree tree ) { TreeHelper . markHeadNode ( tree ) ; Tree headChild = tree . getChild ( tree . getHeadNodeChildIndex ( ) ) ; can return null Tree headChild = tree . getHeadNode ( ) ; if ( ! headChild . isPreterminal ( ) ) return getHeadWordOrPhrase ( headChild ) ; List < Tree > pretermChildren = new ArrayList < Tree > ( ) ; for ( Tree child : tree . getChildren ( ) ) { if ( child . isPreterminal ( ) & & ! child . getLabel ( ) . equals ( _STR , nodes ) ; } return tree . getHeadNode ( ) ; } 
4249	public void writeFixedString ( int length , String str , Charset charset ) { byte [ ] bytes = str . getBytes ( charset ) ; writeBytes ( bytes , _NUM , Math . min ( bytes . length , length ) ) ; for ( int i = bytes . length ; i < length ; i + + ) writeByte ( _NUM ) ; } 
4250	private static void hintMutations ( Collection < ? extends IMutation > mutations ) { for ( IMutation mutation : mutations ) if ( ! ( mutation instanceof CounterMutation ) ) hintMutation ( ( Mutation ) mutation ) ; Tracing . trace ( _STR ) ; } 
4251	public void doTestOutOfSyncAtBeginningOfSegment ( int nodeWithOneTxn ) throws Exception { int nodeWithEmptySegment = ( nodeWithOneTxn + _NUM ) % _NUM ; int nodeMissingSegment = ( nodeWithOneTxn + _NUM ) % _NUM ; writeSegment ( cluster , qjm , _NUM , _NUM , true ) ; waitForAllPendingCalls ( qjm . getLoggerSetForTests ( ) ) ; cluster . getJournalNode ( nodeMissingSegment ) . stopAndJoin ( _NUM ) ; Open segment on _NUM / _NUM nodes EditLogOutputStream stm = qjm . startLogSegment ( _NUM , NameNodeLayoutVersion . CURRENT _ LAYOUT _ VERSION ) ; try { waitForAllPendingCalls ( qjm . getLoggerSetForTests ( ) ) ; Write transactions to only _NUM / _NUM nodes failLoggerAtTxn ( spies . get ( nodeWithEmptySegment ) , _NUM ) ; try { writeTxns ( stm , _NUM , _NUM ) ; fail ( _STR , NNStorage . getFinalizedEditsFileName ( _NUM , _NUM ) ) ; Stop one of the nodes . Since we run this test three times , rotating the roles of the nodes , we ' ll test all the permutations . cluster . getJournalNode ( _NUM ) . stopAndJoin ( _NUM ) ; qjm = createSpyingQJM ( ) ; qjm . recoverUnfinalizedSegments ( ) ; if ( nodeWithOneTxn = = _NUM | | nodeWithOneTxn = = _NUM ) { If the node that had the transaction committed was one of the nodes that responded during recovery , then we should have recovered txid _NUM . checkRecovery ( cluster , _NUM , _NUM ) ; writeSegment ( cluster , qjm , _NUM , _NUM , true ) ; } else { Otherwise , we should have recovered only _NUM - _NUM and should be able to start a segment at _NUM . checkRecovery ( cluster , _NUM , _NUM ) ; writeSegment ( cluster , qjm , _NUM , _NUM , true ) ; } } 
4252	public void setToDegrees ( float toDegrees ) { if ( mState . mToDegrees ! = toDegrees ) { mState . mToDegrees = toDegrees ; invalidateSelf ( ) ; } } 
4253	public static String quote ( String string ) { boolean quote = false ; backquote the following characters if ( ( string . indexOf ( ' \ n ' ) ! = - _NUM ) | | ( string . indexOf ( ' \ r ' ) ! = - _NUM ) | | ( string . indexOf ( ' \ ' ' ) ! = - _NUM ) | | ( string . indexOf ( ' _STR ) ; } return string ; } 
4254	public final void synpred _NUM _NUM _ JPA _NUM _ fragment ( ) throws RecognitionException { JPA _NUM . g : _NUM _NUM _NUM : _NUM : ( aggregate _ expression ) JPA _NUM . g : _NUM _NUM _NUM : _NUM : aggregate _ expression { pushFollow ( FOLLOW _ aggregate _ expression _ in _ synpred _NUM _NUM _ JPA _NUM _NUM _NUM _NUM _NUM ) ; aggregate _ expression ( ) ; state . _ fsp - - ; if ( state . failed ) return ; } } 
4255	public void deletePropertyDefinition ( CmsRequestContext context , String name ) throws CmsException , CmsSecurityException , CmsRoleViolationException { CmsDbContext dbc = m _ dbContextFactory . getDbContext ( context ) ; try { checkOfflineProject ( dbc ) ; checkRole ( dbc , CmsRole . WORKPLACE _ MANAGER . forOrgUnit ( null ) ) ; m _ driverManager . deletePropertyDefinition ( dbc , name ) ; } catch ( Exception e ) { dbc . report ( null , Messages . get ( ) . container ( Messages . ERR _ DELETE _ PROPERTY _ _NUM , name ) , e ) ; } finally { dbc . clear ( ) ; } } 
4256	public void setScreenState ( int state ) { if ( mScreenState ! = state ) { if ( DEBUG ) { Slog . d ( TAG , _STR + state ) ; } mScreenState = state ; mScreenReady = false ; scheduleScreenUpdate ( ) ; } } 
4257	public void testUpgradeFromRel _NUM _NUM _NUM ReservedImage ( ) throws Exception { unpackStorage ( HADOOP _NUM _NUM _NUM _ RESERVED _ IMAGE , HADOOP _ DFS _ DIR _ TXT ) ; MiniDFSCluster cluster = null ; Try it once without setting the upgrade flag to ensure it fails final Configuration conf = new Configuration ( ) ; Try it again with a custom rename string try { FSImageFormat . setRenameReservedPairs ( _STR , found . size ( ) , expected . length ) ; } } finally { if ( cluster ! = null ) { cluster . shutdown ( ) ; } } } 
4258	public void printClassifications ( Classifier classifier , DataSource testset ) throws Exception { int i ; Instances test ; Instance inst ; i = _NUM ; testset . reset ( ) ; test = testset . getStructure ( m _ Header . classIndex ( ) ) ; while ( testset . hasMoreElements ( test ) ) { inst = testset . nextElement ( test ) ; doPrintClassification ( classifier , inst , i ) ; i + + ; } } 
4259	public static int emit ( GasStack stack , TileEntity from , Collection < EnumFacing > sides ) { if ( stack = = null ) { return _NUM ; } List < IGasHandler > availableAcceptors = new ArrayList < > ( ) ; IGasHandler [ ] possibleAcceptors = getConnectedAcceptors ( from , sides ) ; for ( int i = _NUM ; i < possibleAcceptors . length ; i + + ) { IGasHandler handler = possibleAcceptors [ i ] ; if ( handler ! = null & & handler . canReceiveGas ( EnumFacing . getFront ( i ) . getOpposite ( ) , stack . getGas ( ) ) ) { availableAcceptors . add ( handler ) ; } } Collections . shuffle ( availableAcceptors ) ; int toSend = stack . amount ; int prevSending = toSend ; if ( ! availableAcceptors . isEmpty ( ) ) { int divider = availableAcceptors . size ( ) ; int remaining = toSend % divider ; int sending = ( toSend - remaining ) / divider ; for ( IGasHandler acceptor : availableAcceptors ) { int currentSending = sending ; if ( remaining > _NUM ) { currentSending + + ; remaining - - ; } EnumFacing dir = EnumFacing . getFront ( Arrays . asList ( possibleAcceptors ) . indexOf ( acceptor ) ) . getOpposite ( ) ; toSend - = acceptor . receiveGas ( dir , new GasStack ( stack . getGas ( ) , currentSending ) , true ) ; } } return prevSending - toSend ; } 
4260	public void testJoinOnWithParentReference ( ) throws Exception { try ( Transaction tx = cont . persistence ( ) . createTransaction ( ) ) { EntityManager em = cont . entityManager ( ) ; View view = new View ( Group . class ) . addProperty ( _STR , Group . class ) ; query . setView ( view ) ; List < Group > result = query . getResultList ( ) ; tx . commit ( ) ; } } 
4261	private int estimateNextPositionDiffForFling ( RecyclerView . LayoutManager layoutManager , OrientationHelper helper , int velocityX , int velocityY ) { int [ ] distances = calculateScrollDistance ( velocityX , velocityY ) ; float distancePerChild = computeDistancePerChild ( layoutManager , helper ) ; if ( distancePerChild < = _NUM ) { return _NUM ; } int distance = Math . abs ( distances [ _NUM ] ) > Math . abs ( distances [ _NUM ] ) ? distances [ _NUM ] : distances [ _NUM ] ; return ( int ) Math . round ( distance / distancePerChild ) ; } 
4262	public String encode ( final String data , final RegisteredService service ) { try { final PublicKey publicKey = createRegisteredServicePublicKey ( service ) ; final byte [ ] result = encodeInternal ( data , publicKey , service ) ; if ( result ! = null ) { return EncodingUtils . encodeBase _NUM _NUM ( result ) ; } } catch ( final Exception e ) { LOGGER . warn ( e . getMessage ( ) , e ) ; } return null ; } 
4263	public static XmlGDay parse ( java . io . Reader r , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( XmlGDay ) XmlBeans . getContextTypeLoader ( ) . parse ( r , type , options ) ; } 
4264	public Iterator < String > listAltEntries ( ) { return altLocations . keySet ( ) . iterator ( ) ; } 
4265	public static void checkUpgrade ( NNStorage storage ) throws IOException { no previous fs states in any of the directories for ( Iterator < StorageDirectory > it = storage . dirIterator ( false ) ; it . hasNext ( ) ; ) { StorageDirectory sd = it . next ( ) ; if ( sd . getPreviousDir ( ) . exists ( ) ) throw new InconsistentFSStateException ( sd . getRoot ( ) , _STR ) ; } } 
4266	final void destroy ( ) { for ( Call call : mCalls ) { InCallService . VideoCall videoCall = call . getVideoCall ( ) ; if ( videoCall ! = null ) { videoCall . destroy ( ) ; } if ( call . getState ( ) ! = Call . STATE _ DISCONNECTED ) { call . internalSetDisconnected ( ) ; } } } 
4267	public String getTimeString ( ) { return Strings . fromByteArray ( time ) ; } 
4268	public void access ( final Path path , final FsAction mode ) throws AccessControlException , FileNotFoundException , UnsupportedFileSystemException , IOException { final Path absPath = fixRelativePart ( path ) ; new FSLinkResolver < Void > ( ) { @ Override public Void next ( AbstractFileSystem fs , Path p ) throws IOException , UnresolvedLinkException { fs . access ( p , mode ) ; return null ; } } . resolve ( this , absPath ) ; } 
4269	private void letClause ( final LinkedList < Clause > clauses ) throws QueryException { do { final boolean score = wsConsumeWs ( SCORE ) ; final Var var = score ? newVar ( SeqType . DBL _ O ) : newVar ( ) ; wsCheck ( ASSIGN ) ; final Expr ex = check ( single ( ) , NOVARDECL ) ; clauses . add ( new Let ( localVars . add ( var ) , ex , score ) ) ; } while ( wsConsume ( COMMA ) ) ; } 
4270	public double getCurrentDisplacementDistance ( ) { return getDisplacementDistanceForState ( mCurrentState ) ; } 
4271	public void testRemoveSingleGood ( ) { VolcanoPlanner planner = new VolcanoPlanner ( ) ; planner . ambitious = true ; planner . addRelTraitDef ( ConventionTraitDef . INSTANCE ) ; planner . addRule ( new PhysLeafRule ( ) ) ; planner . addRule ( new GoodSingleRule ( ) ) ; planner . addRule ( new GoodRemoveSingleRule ( ) ) ; RelOptCluster cluster = newCluster ( planner ) ; NoneLeafRel leafRel = new NoneLeafRel ( cluster , _STR , resultLeaf . label ) ; } 
4272	public void testCIDFontType _NUM VerticalSubsetProportional ( ) throws IOException { String text = _STR ) . trim ( ) ) ; } 
4273	public void startActivityFromChild ( @ NonNull Activity child , @ RequiresPermission Intent intent , int requestCode , @ Nullable Bundle options ) { options = transferSpringboardActivityOptions ( options ) ; Instrumentation . ActivityResult ar = mInstrumentation . execStartActivity ( this , mMainThread . getApplicationThread ( ) , mToken , child , intent , requestCode , options ) ; if ( ar ! = null ) { mMainThread . sendActivityResult ( mToken , child . mEmbeddedID , requestCode , ar . getResultCode ( ) , ar . getResultData ( ) ) ; } cancelInputsAndStartExitTransition ( options ) ; } 
4274	public void decrypt ( ByteBuffer inBuffer , ByteBuffer outBuffer ) throws IOException { process ( inBuffer , outBuffer ) ; } 
4275	protected < H extends EventHandler > void addVisibleHandler ( Type < H > type , H handler ) { HandlerInformation < H > handlerInformation = new HandlerInformation < > ( type , handler ) ; visibleHandlers . add ( handlerInformation ) ; if ( visible ) { registerVisibleHandler ( handlerInformation ) ; } } 
4276	public StrBuilder append ( final String str ) { if ( str = = null ) { return appendNull ( ) ; } final int strLen = str . length ( ) ; if ( strLen > _NUM ) { final int len = length ( ) ; ensureCapacity ( len + strLen ) ; str . getChars ( _NUM , strLen , buffer , len ) ; size + = strLen ; } return this ; } 
4277	public void testNNClearsCommandsOnFailoverAfterStartup ( ) throws Exception { Make lots of blocks to increase chances of triggering a bug . DFSTestUtil . createFile ( fs , TEST _ FILE _ PATH , _NUM _NUM * SMALL _ BLOCK , ( short ) _NUM , _NUM L ) ; banner ( _STR ) ; FileSystem fs _NUM = cluster . getFileSystem ( _NUM ) ; DFSTestUtil . readFile ( fs _NUM , TEST _ FILE _ PATH ) ; } 
4278	synchronized void openForWrite ( int layoutVersion ) throws IOException { Preconditions . checkState ( state = = State . BETWEEN _ LOG _ SEGMENTS , _STR + state ; } 
4279	public void dump ( final File dumpFile ) throws IOException { dump to bootstrap log file by default final Logger logger = defaultLogger ; final Integer port = getCurrentPort ( logger ) ; if ( port = = null ) { logger . info ( _STR , dumpFile . getAbsolutePath ( ) ) ; } } 
4280	private CTTablePartStyle getTablePartStyle ( TablePartStyle tablePartStyle ) { CTTable ct = table . getCTTable ( ) ; if ( ! ct . isSetTblPr ( ) ) { return null ; } CTTableProperties pr = ct . getTblPr ( ) ; boolean bandRow = ( pr . isSetBandRow ( ) & & pr . getBandRow ( ) ) ; boolean firstRow = ( pr . isSetFirstRow ( ) & & pr . getFirstRow ( ) ) ; boolean lastRow = ( pr . isSetLastRow ( ) & & pr . getLastRow ( ) ) ; boolean bandCol = ( pr . isSetBandCol ( ) & & pr . getBandCol ( ) ) ; boolean firstCol = ( pr . isSetFirstCol ( ) & & pr . getFirstCol ( ) ) ; boolean lastCol = ( pr . isSetLastCol ( ) & & pr . getLastCol ( ) ) ; TablePartStyle tps ; if ( tablePartStyle ! = null ) { tps = tablePartStyle ; } else if ( row = = _NUM & & firstRow ) { tps = TablePartStyle . firstRow ; } else if ( row = = table . getNumberOfRows ( ) - _NUM & & lastRow ) { tps = TablePartStyle . lastRow ; } else if ( col = = _NUM & & firstCol ) { tps = TablePartStyle . firstCol ; } else if ( col = = table . getNumberOfColumns ( ) - _NUM & & lastCol ) { tps = TablePartStyle . lastCol ; } else { tps = TablePartStyle . wholeTbl ; int br = row + ( firstRow ? _NUM : _NUM ) ; int bc = col + ( firstCol ? _NUM : _NUM ) ; if ( bandRow & & ( br & _NUM ) = = _NUM ) { tps = TablePartStyle . band _NUM H ; } else if ( bandCol & & ( bc & _NUM ) = = _NUM ) { tps = TablePartStyle . band _NUM V ; } } XSLFTableStyle tabStyle = table . getTableStyle ( ) ; if ( tabStyle = = null ) { return null ; } CTTablePartStyle part = tabStyle . getTablePartStyle ( tps ) ; return ( part = = null ) ? tabStyle . getTablePartStyle ( TablePartStyle . wholeTbl ) : part ; } 
4281	protected final void applyChange ( ) throws IOException { constructAppearances ( ) ; if we supported JavaScript we would raise a field changed event here } 
4282	protected String overrideClassname ( String classname ) { Enumeration enm ; String result ; Class currentCls ; result = classname ; check overrides enm = m _ ClassnameOverride . keys ( ) ; while ( enm . hasMoreElements ( ) ) { currentCls = ( Class ) enm . nextElement ( ) ; if ( currentCls . getName ( ) . equals ( classname ) ) { result = ( String ) m _ ClassnameOverride . get ( currentCls ) ; break ; } } return result ; } 
4283	public final void testHttpErrors ( ) throws Exception { set up web service ServletHandler handler = new ServletHandler ( ) ; handler . addServletWithMapping ( HttpErrorServlet . class , _STR ) ; _NUM _NUM _NUM - NO CONTENT servlet . setErrorToReturn ( HttpServletResponse . SC _ NO _ CONTENT ) ; this . controller . run ( ) ; this . controller . assertTransferCount ( GetHTTP . REL _ SUCCESS , _NUM ) ; _NUM _NUM _NUM - NOT FOUND servlet . setErrorToReturn ( HttpServletResponse . SC _ NOT _ FOUND ) ; this . controller . run ( ) ; this . controller . assertTransferCount ( GetHTTP . REL _ SUCCESS , _NUM ) ; _NUM _NUM _NUM - INTERNAL SERVER ERROR servlet . setErrorToReturn ( HttpServletResponse . SC _ INTERNAL _ SERVER _ ERROR ) ; this . controller . run ( ) ; this . controller . assertTransferCount ( GetHTTP . REL _ SUCCESS , _NUM ) ; } finally { shutdown web service server . shutdownServer ( ) ; } } 
4284	public Set < Map . Entry < Character , Long > > entrySet ( ) { return new AbstractSet < Map . Entry < Character , Long > > ( ) { public int size ( ) { return _ map . size ( ) ; } public boolean isEmpty ( ) { return TCharLongMapDecorator . this . isEmpty ( ) ; } public boolean contains ( Object o ) { if ( o instanceof Map . Entry ) { Object k = ( ( Map . Entry ) o ) . getKey ( ) ; Object v = ( ( Map . Entry ) o ) . getValue ( ) ; return TCharLongMapDecorator . this . containsKey ( k ) & & TCharLongMapDecorator . this . get ( k ) . equals ( v ) ; } else { return false ; } } public Iterator < Map . Entry < Character , Long > > iterator ( ) { return new Iterator < Map . Entry < Character , Long > > ( ) { private final TCharLongIterator it = _ map . iterator ( ) ; public Map . Entry < Character , Long > next ( ) { it . advance ( ) ; char ik = it . key ( ) ; final Character key = ( ik = = _ map . getNoEntryKey ( ) ) ? null : wrapKey ( ik ) ; long iv = it . value ( ) ; final Long v = ( iv = = _ map . getNoEntryValue ( ) ) ? null : wrapValue ( iv ) ; return new Map . Entry < Character , Long > ( ) { private Long val = v ; public boolean equals ( Object o ) { return o instanceof Map . Entry & & ( ( Map . Entry ) o ) . getKey ( ) . equals ( key ) & & ( ( Map . Entry ) o ) . getValue ( ) . equals ( val ) ; } public Character getKey ( ) { return key ; } public Long getValue ( ) { return val ; } public int hashCode ( ) { return key . hashCode ( ) + val . hashCode ( ) ; } public Long setValue ( Long value ) { val = value ; return put ( key , value ) ; } } ; } public boolean hasNext ( ) { return it . hasNext ( ) ; } public void remove ( ) { it . remove ( ) ; } } ; } public boolean add ( Map . Entry < Character , Long > o ) { throw new UnsupportedOperationException ( ) ; } public boolean remove ( Object o ) { boolean modified = false ; if ( contains ( o ) ) { noinspection unchecked Character key = ( ( Map . Entry < Character , Long > ) o ) . getKey ( ) ; _ map . remove ( unwrapKey ( key ) ) ; modified = true ; } return modified ; } public boolean addAll ( Collection < ? extends Map . Entry < Character , Long > > c ) { throw new UnsupportedOperationException ( ) ; } public void clear ( ) { TCharLongMapDecorator . this . clear ( ) ; } } ; } 
4285	public static boolean isPureLimit ( RelNode rel ) { return isLimit ( rel ) & & ! isOrder ( rel ) ; } 
4286	private final void checkNode ( Record min , Record max ) { if ( count ! = records . size ( ) ) error ( _STR , id , i , this ) ; } } } 
4287	public void onClick ( View v ) { switch ( v . getId ( ) ) { case R . id . tts _ play _ button : Play button . Get the sample text from the TTS engine ; onActivityResult will do the actual speaking speakSampleText ( ) ; break ; case R . id . tts _ reset _ button : Reset button . int speechRateSeekbarProgress = getSeekBarProgressFromValue ( KEY _ DEFAULT _ RATE , TextToSpeech . Engine . DEFAULT _ RATE ) ; mDefaultRatePref . setProgress ( speechRateSeekbarProgress ) ; updateSpeechRate ( speechRateSeekbarProgress ) ; int pitchSeekbarProgress = getSeekBarProgressFromValue ( KEY _ DEFAULT _ PITCH , TextToSpeech . Engine . DEFAULT _ PITCH ) ; mDefaultPitchPref . setProgress ( pitchSeekbarProgress ) ; updateSpeechPitchValue ( pitchSeekbarProgress ) ; break ; default : break ; } } 
4288	protected void center ( boolean horizontal , boolean vertical ) { final Bitmap bitmap = bitmapDisplayed . getBitmap ( ) ; if ( bitmap = = null ) { return ; } Matrix m = getImageViewMatrix ( ) ; RectF rect = new RectF ( _NUM , _NUM , bitmap . getWidth ( ) , bitmap . getHeight ( ) ) ; m . mapRect ( rect ) ; float height = rect . height ( ) ; float width = rect . width ( ) ; float deltaX = _NUM , deltaY = _NUM ; if ( vertical ) { int viewHeight = getHeight ( ) ; if ( height < viewHeight ) { deltaY = ( viewHeight - height ) / _NUM - rect . top ; } else if ( rect . top > _NUM ) { deltaY = - rect . top ; } else if ( rect . bottom < viewHeight ) { deltaY = getHeight ( ) - rect . bottom ; } } if ( horizontal ) { int viewWidth = getWidth ( ) ; if ( width < viewWidth ) { deltaX = ( viewWidth - width ) / _NUM - rect . left ; } else if ( rect . left > _NUM ) { deltaX = - rect . left ; } else if ( rect . right < viewWidth ) { deltaX = viewWidth - rect . right ; } } postTranslate ( deltaX , deltaY ) ; setImageMatrix ( getImageViewMatrix ( ) ) ; } 
4289	private void pauseAutoCycle ( ) { if ( mCycling ) { mCycleTimer . cancel ( ) ; mCycleTask . cancel ( ) ; mCycling = false ; } else { if ( mResumingTimer ! = null & & mResumingTask ! = null ) { recoverCycle ( ) ; } } } 
4290	private TableViewFinder findChildViews _ deprecated ( Region region , byte [ ] tenantId , PTable table , byte [ ] linkTypeBytes ) throws IOException { byte [ ] schemaName = table . getSchemaName ( ) . getBytes ( ) ; byte [ ] tableName = table . getTableName ( ) . getBytes ( ) ; boolean isMultiTenant = table . isMultiTenant ( ) ; Scan scan = new Scan ( ) ; the same tenantId . if ( ! isMultiTenant ) { byte [ ] startRow = ByteUtil . concat ( tenantId , QueryConstants . SEPARATOR _ BYTE _ ARRAY ) ; byte [ ] stopRow = ByteUtil . nextKey ( startRow ) ; scan . setStartRow ( startRow ) ; scan . setStopRow ( stopRow ) ; } SingleColumnValueFilter linkFilter = new SingleColumnValueFilter ( TABLE _ FAMILY _ BYTES , LINK _ TYPE _ BYTES , CompareOp . EQUAL , linkTypeBytes ) ; SingleColumnValueFilter tableTypeFilter = new SingleColumnValueFilter ( TABLE _ FAMILY _ BYTES , TABLE _ TYPE _ BYTES , CompareOp . EQUAL , PTableType . VIEW . getSerializedValue ( ) . getBytes ( ) ) ; tableTypeFilter . setFilterIfMissing ( false ) ; linkFilter . setFilterIfMissing ( true ) ; byte [ ] suffix = ByteUtil . concat ( QueryConstants . SEPARATOR _ BYTE _ ARRAY , SchemaUtil . getPhysicalHBaseTableName ( schemaName , tableName , table . isNamespaceMapped ( ) ) . getBytes ( ) ) ; SuffixFilter rowFilter = new SuffixFilter ( suffix ) ; FilterList filter = new FilterList ( linkFilter , tableTypeFilter , rowFilter ) ; scan . setFilter ( filter ) ; scan . addColumn ( TABLE _ FAMILY _ BYTES , LINK _ TYPE _ BYTES ) ; scan . addColumn ( TABLE _ FAMILY _ BYTES , TABLE _ TYPE _ BYTES ) ; scan . addColumn ( TABLE _ FAMILY _ BYTES , TABLE _ SEQ _ NUM _ BYTES ) ; These deprecated calls work around the issue try ( HTableInterface hTable = ServerUtil . getHTableForCoprocessorScan ( env , region . getTableDesc ( ) . getTableName ( ) . getName ( ) ) ) { boolean allViewsInCurrentRegion = true ; int numOfChildViews = _NUM ; List < ViewInfo > viewInfoList = Lists . newArrayList ( ) ; try ( ResultScanner scanner = hTable . getScanner ( scan ) ) { for ( Result result = scanner . next ( ) ; ( result ! = null ) ; result = scanner . next ( ) ) { numOfChildViews + + ; ImmutableBytesWritable ptr = new ImmutableBytesWritable ( ) ; ResultTuple resultTuple = new ResultTuple ( result ) ; resultTuple . getKey ( ptr ) ; byte [ ] key = ptr . copyBytes ( ) ; if ( checkTableKeyInRegion ( key , region ) ! = null ) { allViewsInCurrentRegion = false ; } byte [ ] [ ] rowKeyMetaData = new byte [ _NUM ] [ ] ; getVarChars ( result . getRow ( ) , _NUM , rowKeyMetaData ) ; byte [ ] viewTenantId = rowKeyMetaData [ PhoenixDatabaseMetaData . TENANT _ ID _ INDEX ] ; byte [ ] viewSchemaName = rowKeyMetaData [ PhoenixDatabaseMetaData . SCHEMA _ NAME _ INDEX ] ; byte [ ] viewName = rowKeyMetaData [ PhoenixDatabaseMetaData . TABLE _ NAME _ INDEX ] ; viewInfoList . add ( new ViewInfo ( viewTenantId , viewSchemaName , viewName ) ) ; } TableViewFinder tableViewFinderResult = new TableViewFinder ( viewInfoList ) ; if ( numOfChildViews > _NUM & & ! allViewsInCurrentRegion ) { tableViewFinderResult . setAllViewsNotInSingleRegion ( ) ; } return tableViewFinderResult ; } } } 
4291	public void testConnectionIdle ( ) throws Exception { final TableName tableName = TableName . valueOf ( name . getMethodName ( ) ) ; TEST _ UTIL . createTable ( tableName , FAM _ NAM ) . close ( ) ; int idleTime = _NUM _NUM _NUM _NUM _NUM ; boolean previousBalance = TEST _ UTIL . getAdmin ( ) . setBalancerRunning ( false , true ) ; Configuration c _NUM = new Configuration ( TEST _ UTIL . getConfiguration ( ) ) ; We want to work on a separate connection . c _NUM . set ( HConstants . HBASE _ CLIENT _ INSTANCE _ ID , String . valueOf ( - _NUM ) ) ; Don ' t retry : retry = test failed c _NUM . setInt ( HConstants . HBASE _ CLIENT _ RETRIES _ NUMBER , _NUM ) ; c _NUM . setInt ( RpcClient . IDLE _ TIME , idleTime ) ; Connection connection = ConnectionFactory . createConnection ( c _NUM ) ; final Table table = connection . getTable ( tableName ) ; Put put = new Put ( ROW ) ; put . addColumn ( FAM _ NAM , ROW , ROW ) ; table . put ( put ) ; ManualEnvironmentEdge mee = new ManualEnvironmentEdge ( ) ; mee . setValue ( System . currentTimeMillis ( ) ) ; EnvironmentEdgeManager . injectEdge ( mee ) ; LOG . info ( _STR ) ; table . close ( ) ; connection . close ( ) ; EnvironmentEdgeManager . reset ( ) ; TEST _ UTIL . getAdmin ( ) . setBalancerRunning ( previousBalance , true ) ; } 
4292	public static File [ ] buildExternalStorageAppCacheDirs ( String packageName ) { throwIfUserRequired ( ) ; return sCurrentUser . buildExternalStorageAppCacheDirs ( packageName ) ; } 
4293	public void setCurrentItemIndex ( int currentItemIndex ) { enforceNotSealed ( ) ; mCurrentItemIndex = currentItemIndex ; } 
4294	void cancelTask ( Identifier parentIdentifier ) { final LoaderTask task ; synchronized ( this ) { task = mTaskList . findTask ( parentIdentifier ) ; } if ( task ! = null ) { task . cancel ( ) ; mTaskList . remove ( task ) ; } } 
4295	private static Optional < Schema > isOfOptionType ( Schema schema ) { Preconditions . checkNotNull ( schema ) ; If not of type UNION , cant be an OPTION if ( ! Schema . Type . UNION . equals ( schema . getType ( ) ) ) { return Optional . < Schema > absent ( ) ; } If has more than two members , can ' t be an OPTION List < Schema > types = schema . getTypes ( ) ; if ( null ! = types & & types . size ( ) = = _NUM ) { Schema first = types . get ( _NUM ) ; Schema second = types . get ( _NUM ) ; One member should be of type NULL and other of type RECORD if ( Schema . Type . NULL . equals ( first . getType ( ) ) & & Schema . Type . RECORD . equals ( second . getType ( ) ) ) { return Optional . of ( second ) ; } else if ( Schema . Type . RECORD . equals ( first . getType ( ) ) & & Schema . Type . NULL . equals ( second . getType ( ) ) ) { return Optional . of ( first ) ; } } return Optional . < Schema > absent ( ) ; } 
4296	public static TripleWritable read ( DataInput input ) throws IOException { TripleWritable t = new TripleWritable ( ) ; t . readFields ( input ) ; return t ; } 
4297	public boolean isSeparateProfileChallengeAllowed ( int userHandle ) { return isManagedProfile ( userHandle ) & & getDevicePolicyManager ( ) . isSeparateProfileChallengeAllowed ( userHandle ) ; } 
4298	public int getTermIndexInterval ( ) { We pass false because this method is called by SegmentMerger while we are in the process of closing ensureOpen ( false ) ; return config . getTermIndexInterval ( ) ; } 
4299	public CmsPropertyDefinition readPropertyDefinition ( CmsDbContext dbc , String name , CmsUUID projectId ) throws CmsDataAccessException { CmsPropertyDefinition propDef = null ; try { Query q = m _ sqlManager . createQuery ( dbc , projectId , C _ PROPERTYDEF _ READ ) ; q . setParameter ( _NUM , name ) ; try { I _ CmsDAOPropertyDef pd = ( I _ CmsDAOPropertyDef ) q . getSingleResult ( ) ; propDef = new CmsPropertyDefinition ( new CmsUUID ( pd . getPropertyDefId ( ) ) , pd . getPropertyDefName ( ) , CmsPropertyDefinition . CmsPropertyType . valueOf ( pd . getPropertyDefType ( ) ) ) ; } catch ( NoResultException e ) { throw new CmsDbEntryNotFoundException ( Messages . get ( ) . container ( Messages . ERR _ NO _ PROPERTYDEF _ WITH _ NAME _ _NUM , name ) ) ; } } catch ( PersistenceException e ) { throw new CmsDataAccessException ( Messages . get ( ) . container ( Messages . ERR _ JPA _ PERSITENCE , e ) , e ) ; } return propDef ; } 
4300	public void addCountryListener ( ICountryListener listener ) throws RemoteException { if ( ! mSystemReady ) { throw new RemoteException ( ) ; } addListener ( listener ) ; } 
4301	boolean restoreSavedSurface ( ) { if ( ! mSurfaceSaved ) { return false ; } We can only restore to the last rotation we were laid out as visible in . if ( mLastVisibleLayoutRotation ! = getDisplayContent ( ) . getRotation ( ) ) { destroySavedSurface ( ) ; return false ; } mSurfaceSaved = false ; if ( mWinAnimator . mSurfaceController ! = null ) { setHasSurface ( true ) ; mWinAnimator . mDrawState = READY _ TO _ SHOW ; mAnimatingWithSavedSurface = true ; requestUpdateWallpaperIfNeeded ( ) ; if ( DEBUG _ APP _ TRANSITIONS | | DEBUG _ ANIM ) { Slog . v ( TAG , _STR + this ) ; } return true ; } 
4302	protected void addContentItems ( List < CmsResultItemBean > list , boolean front ) { if ( front ) { list = Lists . reverse ( list ) ; } for ( CmsResultItemBean resultItem : list ) { addSingleResult ( resultItem , front ) ; } String selectValue = m _ sortSelectBox . getFormValueAsString ( ) ; if ( m _ types . size ( ) = = _NUM ) { getList ( ) . addStyleName ( I _ CmsLayoutBundle . INSTANCE . galleryResultItemCss ( ) . tilingList ( ) ) ; if ( SortParams . valueOf ( selectValue ) = = SortParams . title _ asc ) { m _ sortSelectBox . setItems ( getSortList ( false ) ) ; } } else { getList ( ) . removeStyleName ( I _ CmsLayoutBundle . INSTANCE . galleryResultItemCss ( ) . tilingList ( ) ) ; if ( SortParams . valueOf ( selectValue ) = = SortParams . title _ asc ) { m _ sortSelectBox . setItems ( getSortList ( true ) ) ; } } } 
4303	public byte [ ] getAsByteArray ( String key ) { Object value = mValues . get ( key ) ; if ( value instanceof byte [ ] ) { return ( byte [ ] ) value ; } else { return null ; } } 
4304	public long getAsBytes ( Property property ) { String memString = get ( property ) ; if ( property . getType ( ) = = PropertyType . MEMORY ) { return ConfigurationTypeHelper . getMemoryAsBytes ( memString ) ; } else if ( property . getType ( ) = = PropertyType . BYTES ) { return ConfigurationTypeHelper . getFixedMemoryAsBytes ( memString ) ; } else { throw new IllegalArgumentException ( property . getKey ( ) + _STR ) ; } } 
4305	private StandardRemoteGroupPort addInputPort ( final RemoteProcessGroupPortDescriptor descriptor ) { writeLock . lock ( ) ; try { if ( inputPorts . containsKey ( descriptor . getId ( ) ) ) { throw new IllegalStateException ( _STR ) ; } We need to generate the port ' s UUID deterministically because we need all nodes in a cluster to use the same UUID . However , we want the ID to be unique for each Remote Group Port , so that if we have multiple RPG ' s pointing to the same target , we have unique ID ' s for each of those ports . final StandardRemoteGroupPort port = new StandardRemoteGroupPort ( descriptor . getId ( ) , descriptor . getTargetId ( ) , descriptor . getName ( ) , getProcessGroup ( ) , this , TransferDirection . SEND , ConnectableType . REMOTE _ INPUT _ PORT , sslContext , scheduler , nifiProperties ) ; if ( descriptor . getConcurrentlySchedulableTaskCount ( ) ! = null ) { port . setMaxConcurrentTasks ( descriptor . getConcurrentlySchedulableTaskCount ( ) ) ; } if ( descriptor . getUseCompression ( ) ! = null ) { port . setUseCompression ( descriptor . getUseCompression ( ) ) ; } if ( descriptor . getBatchCount ( ) ! = null & & descriptor . getBatchCount ( ) > _NUM ) { port . setBatchCount ( descriptor . getBatchCount ( ) ) ; } if ( ! StringUtils . isBlank ( descriptor . getBatchSize ( ) ) ) { port . setBatchSize ( descriptor . getBatchSize ( ) ) ; } if ( ! StringUtils . isBlank ( descriptor . getBatchDuration ( ) ) ) { port . setBatchDuration ( descriptor . getBatchDuration ( ) ) ; } port . setVersionedComponentId ( descriptor . getVersionedComponentId ( ) ) ; inputPorts . put ( descriptor . getId ( ) , port ) ; return port ; } finally { writeLock . unlock ( ) ; } } 
4306	public void setSerialParFor ( ) { process parfor nodes if ( _ ntype = = NodeType . PARFOR ) { _ k = _NUM ; _ etype = ExecType . CP ; } process childs if ( ! isLeaf ( ) ) for ( OptNode n : _ childs ) n . setSerialParFor ( ) ; } 
4307	public static Collection < URL > findResources ( final String resource ) { final Collection < UrlResource > urlResources = findUrlResources ( resource ) ; final Collection < URL > resources = new LinkedHashSet < > ( urlResources . size ( ) ) ; for ( final UrlResource urlResource : urlResources ) { resources . add ( urlResource . getUrl ( ) ) ; } return resources ; } 
4308	public final int matchData ( String type , String scheme , Uri data ) { final ArrayList < String > types = mDataTypes ; final ArrayList < String > schemes = mDataSchemes ; int match = MATCH _ CATEGORY _ EMPTY ; if ( types = = null & & schemes = = null ) { return ( ( type = = null & & data = = null ) ? ( MATCH _ CATEGORY _ EMPTY + MATCH _ ADJUSTMENT _ NORMAL ) : NO _ MATCH _ DATA ) ; } if ( schemes ! = null ) { if ( schemes . contains ( scheme ! = null ? scheme : _STR . equals ( scheme ) ) { return NO _ MATCH _ DATA ; } } if ( types ! = null ) { if ( findMimeType ( type ) ) { match = MATCH _ CATEGORY _ TYPE ; } else { return NO _ MATCH _ TYPE ; } } else { an Intent that does not have a MIME type . if ( type ! = null ) { return NO _ MATCH _ TYPE ; } } return match + MATCH _ ADJUSTMENT _ NORMAL ; } 
4309	public String toSummaryString ( String title , boolean printComplexityStatistics ) { StringBuffer text = new StringBuffer ( ) ; if ( printComplexityStatistics & & m _ NoPriors ) { printComplexityStatistics = false ; System . err . println ( _STR ) ; } return text . toString ( ) ; } 
4310	public boolean hasSubClass ( ) { return getSubClass ( ) ! = null ; } 
4311	public void startElement ( final String uri , final String localName , final String qName , final Attributes attributes ) throws SAXException { setOpenComment ( getCommentHandler ( ) . getComments ( ) ) ; this . openComments . push ( getOpenComment ( ) ) ; setCloseComment ( null ) ; try { if ( ! this . isInclude & & qName . equals ( ClassModelTags . OBJECTS _ TAG ) ) { Log . debug ( _STR ) ; } final String parameterClass = attributes . getValue ( ClassModelTags . CLASS _ ATTR ) ; optional final String tagName = attributes . getValue ( ClassModelTags . PROPERTY _ ATTR ) ; handleConstructorDefinition ( tagName , parameterClass ) ; } } catch ( ObjectDescriptionException e ) { throw new SAXException ( e ) ; } finally { getCommentHandler ( ) . clearComments ( ) ; } } 
4312	public void append ( RegionEntryBuffer buffer ) throws IOException { writeThenClose ( buffer ) ; } 
4313	protected void onLayout ( boolean changed , int left , int top , int right , int bottom ) { if ( mTaskStackView . getVisibility ( ) ! = GONE ) { mTaskStackView . layout ( left , top , left + getMeasuredWidth ( ) , top + getMeasuredHeight ( ) ) ; } Layout the empty view if ( mEmptyView . getVisibility ( ) ! = GONE ) { int leftRightInsets = mSystemInsets . left + mSystemInsets . right ; int topBottomInsets = mSystemInsets . top + mSystemInsets . bottom ; int childWidth = mEmptyView . getMeasuredWidth ( ) ; int childHeight = mEmptyView . getMeasuredHeight ( ) ; int childLeft = left + mSystemInsets . left + Math . max ( _NUM , ( right - left - leftRightInsets - childWidth ) ) / _NUM ; int childTop = top + mSystemInsets . top + Math . max ( _NUM , ( bottom - top - topBottomInsets - childHeight ) ) / _NUM ; mEmptyView . layout ( childLeft , childTop , childLeft + childWidth , childTop + childHeight ) ; } Needs to know the screen size since the gradient never scales up or down even when bounds change . mContext . getDisplay ( ) . getRealSize ( mTmpDisplaySize ) ; mBackgroundScrim . setScreenSize ( mTmpDisplaySize . x , mTmpDisplaySize . y ) ; mBackgroundScrim . setBounds ( left , top , right , bottom ) ; mMultiWindowBackgroundScrim . setBounds ( _NUM , _NUM , mTmpDisplaySize . x , mTmpDisplaySize . y ) ; if ( RecentsDebugFlags . Static . EnableStackActionButton ) { Layout the stack action button such that its drawable is start - aligned with the stack , vertically centered in the available space above the stack Rect buttonBounds = getStackActionButtonBoundsFromStackLayout ( ) ; mStackActionButton . layout ( buttonBounds . left , buttonBounds . top , buttonBounds . right , buttonBounds . bottom ) ; } if ( mAwaitingFirstLayout ) { mAwaitingFirstLayout = false ; If launched via dragging from the nav bar , then we should translate the whole view down offscreen RecentsActivityLaunchState launchState = Recents . getConfiguration ( ) . getLaunchState ( ) ; if ( launchState . launchedViaDragGesture ) { setTranslationY ( getMeasuredHeight ( ) ) ; } else { setTranslationY ( _NUM f ) ; } if ( Recents . getConfiguration ( ) . isLowRamDevice & & mEmptyView . getVisibility ( ) = = View . VISIBLE ) { animateEmptyView ( true , null ) ; } } } 
4314	public static XmlNormalizedString parse ( java . io . File f ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( XmlNormalizedString ) XmlBeans . getContextTypeLoader ( ) . parse ( f , type , null ) ; } 
4315	public ResultSetJDBC execSilent ( String sqlString ) { if ( loggingSQLStatements ( ) ) writeLog ( _STR , sqlString ) ; Connection conn = getSqlConnection ( ) ; Statement s = null ; try { s = conn . createStatement ( ) ; boolean r = s . execute ( sqlString ) ; if ( r ) return new ResultSetJDBC ( s , s . getResultSet ( ) ) ; } catch ( SQLException ex ) { } Close if did not return a ResultSetJDBC RS . close ( s ) ; return null ; } 
4316	protected boolean isBinlogAvailable ( ) { String gtidStr = taskContext . source ( ) . gtidSet ( ) ; if ( gtidStr ! = null ) { start at beginning . . . if ( gtidStr . trim ( ) . isEmpty ( ) ) return true ; String availableGtidStr = connectionContext . knownGtidSet ( ) ; if ( availableGtidStr = = null | | availableGtidStr . trim ( ) . isEmpty ( ) ) { Last offsets had GTIDs but the server does not use them . . . logger . info ( _STR , binlogFilename ) ; return found ; } 
4317	public boolean isFile ( Path f ) throws IOException { try { return getFileStatus ( f ) . isFile ( ) ; } catch ( FileNotFoundException e ) { f does not exist return false ; } } 
4318	private boolean handleBadDatanode ( ) { final int badNodeIndex = errorState . getBadNodeIndex ( ) ; if ( badNodeIndex > = _NUM ) { if ( nodes . length < = _NUM ) { lastException . set ( new IOException ( _STR ) ; failed . add ( nodes [ badNodeIndex ] ) ; DatanodeInfo [ ] newnodes = new DatanodeInfo [ nodes . length - _NUM ] ; arraycopy ( nodes , newnodes , badNodeIndex ) ; final StorageType [ ] newStorageTypes = new StorageType [ newnodes . length ] ; arraycopy ( storageTypes , newStorageTypes , badNodeIndex ) ; final String [ ] newStorageIDs = new String [ newnodes . length ] ; arraycopy ( storageIDs , newStorageIDs , badNodeIndex ) ; setPipeline ( newnodes , newStorageTypes , newStorageIDs ) ; errorState . adjustState _NUM RestartingNode ( ) ; lastException . clear ( ) ; } return true ; } 
4319	protected void checkCreateFrontsTriples ( final ExtendedIterator < ? extends FrontsTriple > FrontsTripleIter ) throws AddDeniedException , AuthenticationRequiredException { if ( ! canCreate ( Triple . ANY ) ) { try { while ( FrontsTripleIter . hasNext ( ) ) { checkCreate ( FrontsTripleIter . next ( ) ) ; } } finally { FrontsTripleIter . close ( ) ; } } } 
4320	public void testRegionAssignmentAfterMasterRecoveryDueToZKExpiry ( ) throws Exception { MiniHBaseCluster cluster = TEST _ UTIL . getHBaseCluster ( ) ; cluster . startRegionServer ( ) ; cluster . waitForActiveAndReadyMaster ( _NUM _NUM _NUM _NUM _NUM ) ; HMaster m = cluster . getMaster ( ) ; final ZKWatcher zkw = m . getZooKeeper ( ) ; now the cluster is up . So assign some regions . try ( Admin admin = TEST _ UTIL . getAdmin ( ) ) { byte [ ] [ ] SPLIT _ KEYS = new byte [ ] [ ] { Bytes . toBytes ( _STR , MockLoadBalancer . retainAssignCalled ) ; number of listeners should be same as the value before master aborted wait for new master is initialized cluster . waitForActiveAndReadyMaster ( _NUM _NUM _NUM _NUM _NUM _NUM ) ; final HMaster newMaster = cluster . getMasterThread ( ) . getMaster ( ) ; assertEquals ( expectedNumOfListeners , countPermanentListeners ( newMaster . getZooKeeper ( ) ) ) ; } } 
4321	public void setFilter ( String filter ) { this . conditionsFilter = filter ; filterApplied = false ; filteredItemsIds = new ArrayList < > ( ) ; for ( UUID rootId : getRootItemIds ( ) ) { recursivelyFindSelectedItems ( rootId ) ; } filterApplied = true ; refresh ( Collections . < String , Object > singletonMap ( _STR , descriptorsTree ) ) ; } 
4322	public static long string _NUM long ( String s ) { s = s . trim ( ) ; final int lastpos = s . length ( ) - _NUM ; final char lastchar = s . charAt ( lastpos ) ; if ( Character . isDigit ( lastchar ) ) return Long . parseLong ( s ) ; else { long prefix ; try { prefix = TraditionalBinaryPrefix . valueOf ( lastchar ) . value ; } catch ( IllegalArgumentException e ) { throw new IllegalArgumentException ( _STR ) ; } return num * prefix ; } } 
4323	protected void onRowViewSelected ( ViewHolder vh , boolean selected ) { dispatchItemSelectedListener ( vh , selected ) ; updateHeaderViewVisibility ( vh ) ; updateActivateStatus ( vh , vh . view ) ; } 
4324	private boolean moveTheChildren ( int deltaY , int incrementalDeltaY ) { if ( DBG ) Log . d ( TAG , _STR + count ) ; detachViewsFromParent ( start , count ) ; mRecycleBin . removeSkippedScrap ( ) ; onChildrenDetached ( start , count ) ; } calls to bubble up from the children all the way to the top if ( ! awakenScrollBars ( ) ) { invalidate ( ) ; } offsetChildrenTopAndBottom ( incrementalDeltaY ) ; if ( isDown ) { mFirstPosition + = count ; } final int absIncrementalDeltaY = Math . abs ( incrementalDeltaY ) ; if ( spaceAbove < absIncrementalDeltaY | | spaceBelow < absIncrementalDeltaY ) { fillGap ( isDown ) ; } TODO : touch mode selector handling mBlockLayoutRequests = false ; invokeOnItemScrollListener ( ) ; return false ; } 
4325	public void setDialogTitle ( String singleKey , String multiKey ) { if ( isMultiOperation ( ) ) { generate title with number of selected resources and parent folder parameters String resCount = String . valueOf ( getResourceList ( ) . size ( ) ) ; String currentFolder = CmsResource . getFolderPath ( getSettings ( ) . getExplorerResource ( ) ) ; currentFolder = CmsStringUtil . formatResourceName ( currentFolder , _NUM _NUM ) ; Object [ ] params = new Object [ ] { resCount , currentFolder } ; setParamTitle ( key ( multiKey , params ) ) ; } else { generate title using the resource name as parameter for the key String resourceName = CmsStringUtil . formatResourceName ( getParamResource ( ) , _NUM _NUM ) ; setParamTitle ( key ( singleKey , new Object [ ] { resourceName } ) ) ; } } 
4326	public List < T > getElements ( int elementCount , Progressable progressable ) { ProgressableUtils . awaitSemaphorePermits ( semaphore , elementCount , progressable ) ; Preconditions . checkState ( elements . size ( ) = = elementCount ) ; List < T > ret = new ArrayList < > ( elements ) ; elements . clear ( ) ; return ret ; } 
4327	public UploadPartRequest withProgressListener ( com . amazonaws . services . s _NUM . model . ProgressListener progressListener ) { setProgressListener ( progressListener ) ; return this ; } 
4328	public boolean authenticatedUserHasAuthorizations ( TCredentials credentials , List < ByteBuffer > list ) throws ThriftSecurityException { if ( isSystemUser ( credentials ) ) { system user doesn ' t need record - level authorizations for the tables it reads ( for now ) return list . isEmpty ( ) ; } try { return authorizor . isValidAuthorizations ( credentials . getPrincipal ( ) , list ) ; } catch ( AccumuloSecurityException e ) { throw e . asThriftException ( ) ; } } 
4329	public Long getAsLong ( String key ) { Object value = mValues . get ( key ) ; try { return value ! = null ? ( ( Number ) value ) . longValue ( ) : null ; } catch ( ClassCastException e ) { if ( value instanceof CharSequence ) { try { return Long . valueOf ( value . toString ( ) ) ; } catch ( NumberFormatException e _NUM ) { Log . e ( TAG , _STR + value , e ) ; return null ; } } } 
4330	private void sendReplicationNotification ( InetAddressAndPort remote ) { notify the remote token MessageOut msg = new MessageOut ( MessagingService . Verb . REPLICATION _ FINISHED ) ; IFailureDetector failureDetector = FailureDetector . instance ; if ( logger . isDebugEnabled ( ) ) logger . debug ( _STR , remote ) ; while ( failureDetector . isAlive ( remote ) ) { AsyncOneResponse iar = MessagingService . instance ( ) . sendRR ( msg , remote ) ; try { iar . get ( DatabaseDescriptor . getRpcTimeout ( ) , TimeUnit . MILLISECONDS ) ; done return ; } catch ( TimeoutException e ) { try again } } } 
4331	public < T > AssertThat doWithConnection ( Function < CalciteConnection , T > fn ) throws Exception { try ( Connection connection = connectionFactory . createConnection ( ) ) { T t = fn . apply ( ( CalciteConnection ) connection ) ; Util . discard ( t ) ; return AssertThat . this ; } } 
4332	public static boolean keyLE ( Record record _NUM , Record record _NUM ) { int x = compareByKey ( record _NUM , record _NUM ) ; return x < = _NUM ; } 
4333	public int find ( final int pre ) { sort ( ) ; return Arrays . binarySearch ( sorted , pre ) ; } 
4334	private void dtd ( ) throws IOException { if ( ! prolog ) throw error ( TYPEAFTER ) ; if ( ! s ( ) ) throw error ( ERRDT ) ; parse root element name ( true ) ; s ( ) ; externalID ( true , true ) ; s ( ) ; while ( consume ( ' [ ' ) ) { s ( ) ; while ( markupDecl ( ) ) ; s ( ) ; check ( ' ] ' ) ; s ( ) ; } check ( ' > ' ) ; } 
4335	private static void uaRIMGe ( MatrixBlock in , MatrixBlock out , double [ ] bv , int [ ] bvi , BinaryOperator bOp ) { int ind _NUM = uarimaxGe ( _NUM . _NUM , bv , bvi , bOp ) ; int m = in . rlen ; for ( int i = _NUM ; i < m ; i + + ) { double ai = in . quickGetValue ( i , _NUM ) ; int ind = ( ai = = _NUM ) ? ind _NUM : uarimaxGe ( ai , bv , bvi , bOp ) ; out . quickSetValue ( i , _NUM , ind ) ; } } 
4336	public void setDimAlphaWithoutHeader ( float dimAlpha ) { mDimAlpha = dimAlpha ; mThumbnailView . setDimAlpha ( dimAlpha ) ; } 
4337	public void setSummary ( CharSequence summary ) { super . setSummary ( summary ) ; if ( summary = = null & & mSummary ! = null ) { mSummary = null ; } else if ( summary ! = null & & ! summary . equals ( mSummary ) ) { mSummary = summary . toString ( ) ; } } 
4338	public String getSystemDialerPackage ( ) { try { if ( isServiceConnected ( ) ) { return getTelecomService ( ) . getSystemDialerPackage ( ) ; } } catch ( RemoteException e ) { Log . e ( TAG , _STR , e ) ; } return null ; } 
4339	public static Profile getEffective ( final Profile profile , final Collection < PlaceholderResolver > resolvers , boolean finalSubstitution ) { assertNotNull ( profile , _STR ) ) ; String toSubst = value . substring ( scheme . length ( ) + _NUM ) ; for ( PlaceholderResolver resolver : resolvers ) { if ( scheme . equals ( resolver . getScheme ( ) ) ) { String val = resolver . resolve ( dynamic , pid , key , toSubst ) ; if ( val ! = null ) { return val ; } } } } } return null ; } , finalSubstitution ) ; Force computation while preserving layout ProfileBuilder builder = ProfileBuilder . Factory . createFrom ( profile ) ; for ( String cfg : originals . keySet ( ) ) { TypedProperties original = originals . get ( cfg ) ; TypedProperties original _NUM = originals _NUM . get ( cfg ) ; original _NUM . putAll ( original ) ; builder . addFileConfiguration ( cfg + Profile . PROPERTIES _ SUFFIX , Utils . toBytes ( original _NUM ) ) ; } Compute the new profile return builder . getProfile ( ) ; } 
4340	public void setCurrentPlayTime ( long playTime ) { initAnimation ( ) ; long currentTime = AnimationUtils . currentAnimationTimeMillis ( ) ; if ( mPlayingState ! = RUNNING ) { mSeekTime = playTime ; mPlayingState = SEEKED ; } mStartTime = currentTime - playTime ; animationFrame ( currentTime ) ; } 
4341	public void onDropDownComplete ( CharSequence secondText ) { if ( isDropDownStyle ) { setHeaderSecondText ( secondText ) ; onDropDownComplete ( ) ; } } 
4342	public static boolean deepEquals ( Object [ ] array _NUM , Object [ ] array _NUM ) { if ( array _NUM = = array _NUM ) { return true ; } if ( array _NUM = = null | | array _NUM = = null | | array _NUM . length ! = array _NUM . length ) { return false ; } for ( int i = _NUM ; i < array _NUM . length ; i + + ) { Object e _NUM = array _NUM [ i ] , e _NUM = array _NUM [ i ] ; if ( ! deepEqualsElements ( e _NUM , e _NUM ) ) { return false ; } } return true ; } 
4343	public boolean isIdenticalDnses ( LinkProperties target ) { Collection < InetAddress > targetDnses = target . getDnsServers ( ) ; String targetDomains = target . getDomains ( ) ; if ( mDomains = = null ) { if ( targetDomains ! = null ) return false ; } else { if ( mDomains . equals ( targetDomains ) = = false ) return false ; } return ( mDnses . size ( ) = = targetDnses . size ( ) ) ? mDnses . containsAll ( targetDnses ) : false ; } 
4344	public void update ( String step , MetricsContainerImpl container ) { getContainer ( step ) . update ( container ) ; } 
4345	private static int getRegionServerCount ( final Connection connection ) throws IOException { try ( Admin admin = connection . getAdmin ( ) ) { ClusterMetrics status = admin . getClusterMetrics ( EnumSet . of ( Option . LIVE _ SERVERS ) ) ; Collection < ServerName > servers = status . getLiveServerMetrics ( ) . keySet ( ) ; return servers = = null | | servers . isEmpty ( ) ? _NUM : servers . size ( ) ; } } 
4346	public static DataframeMatrix newInstance ( Dataframe dataset , boolean addConstantColumn , Map < Integer , Integer > recordIdsReference , Map < Object , Integer > featureIdsReference ) { if ( ! featureIdsReference . isEmpty ( ) ) { throw new IllegalArgumentException ( _STR ) ; } setStorageEngine ( dataset ) ; int n = dataset . size ( ) ; int d = dataset . xColumnSize ( ) ; if ( addConstantColumn ) { + + d ; } DataframeMatrix m = new DataframeMatrix ( new MapRealMatrix ( n , d ) , new MapRealVector ( n ) ) ; if ( dataset . isEmpty ( ) ) { return m ; } boolean extractY = ( dataset . getYDataType ( ) = = TypeInference . DataType . NUMERICAL ) ; int featureId = _NUM ; if ( addConstantColumn ) { for ( int row = _NUM ; row < n ; + + row ) { put the constant in evey row m . X . setEntry ( row , featureId , _NUM . _NUM ) ; } featureIdsReference . put ( Dataframe . COLUMN _ NAME _ CONSTANT , featureId ) ; + + featureId ; } int rowId = _NUM ; for ( Map . Entry < Integer , Record > e : dataset . entries ( ) ) { Integer rId = e . getKey ( ) ; Record r = e . getValue ( ) ; if ( recordIdsReference ! = null ) { recordIdsReference . put ( rId , rowId ) ; } if ( extractY ) { m . Y . setEntry ( rowId , TypeInference . toDouble ( r . getY ( ) ) ) ; } for ( Map . Entry < Object , Object > entry : r . getX ( ) . entrySet ( ) ) { Object feature = entry . getKey ( ) ; Integer knownFeatureId = featureIdsReference . get ( feature ) ; if ( knownFeatureId = = null ) { featureIdsReference . put ( feature , featureId ) ; knownFeatureId = featureId ; + + featureId ; } Double value = TypeInference . toDouble ( entry . getValue ( ) ) ; if ( value ! = null ) { m . X . setEntry ( rowId , knownFeatureId , value ) ; } else the X matrix maintains the _NUM . _NUM default value } + + rowId ; } return m ; } 
4347	public static Properties getCamelPropertiesWithPrefix ( String prefix , CamelContext camelContext ) { Properties answer = new Properties ( ) ; Map < String , String > camelProperties = camelContext . getGlobalOptions ( ) ; if ( camelProperties ! = null ) { for ( Map . Entry < String , String > entry : camelProperties . entrySet ( ) ) { String key = entry . getKey ( ) ; if ( key ! = null & & key . startsWith ( prefix ) ) { answer . put ( key . substring ( prefix . length ( ) ) , entry . getValue ( ) ) ; } } } return answer ; } 
4348	private void validateTransformApply ( DataIdentifier output , boolean conditional ) { validate data / metadata ( recode maps ) checkDataType ( _STR , TF _ FN _ PARAM _ SPEC , DataType . SCALAR , ValueType . STRING , conditional ) ; validateTransformSpec ( TF _ FN _ PARAM _ SPEC , conditional ) ; set output dimensions output . setDataType ( DataType . MATRIX ) ; output . setValueType ( ValueType . DOUBLE ) ; output . setDimensions ( - _NUM , - _NUM ) ; } 
4349	public void concurrentFree ( ) throws Exception { ConcurrentCreator concurrentCreator = new ConcurrentCreator ( DEPTH , CONCURRENCY _ DEPTH , ROOT _ PATH , CreateFileOptions . defaults ( ) . setPersisted ( true ) ) ; concurrentCreator . call ( ) ; ConcurrentFreer concurrentFreer = new ConcurrentFreer ( DEPTH , CONCURRENCY _ DEPTH , ROOT _ PATH ) ; concurrentFreer . call ( ) ; } 
4350	private static void maybeSignalProcess ( String pid , int signalNum , String signalName , boolean alwaysSignal ) { forces it so . if ( alwaysSignal | | ProcessTree . isAlive ( pid ) ) { sendSignal ( pid , signalNum , signalName ) ; } } 
4351	public int getMaxZoomLevel ( ) { return _ map . maxZoomLevel ( ) ; } 
4352	public void setMatrixDefault ( ) { if ( getVarParam ( RAND _ BY _ ROW ) = = null ) addVarParam ( RAND _ BY _ ROW , new BooleanIdentifier ( true , this ) ) ; } 
4353	private static boolean hasAnyInterestingChars ( CharSequence text , int textLength ) { final int MAX _ BUF _ LEN = _NUM _NUM _NUM ; final char [ ] buffer = TextUtils . obtain ( MAX _ BUF _ LEN ) ; try { for ( int start = _NUM ; start < textLength ; start + = MAX _ BUF _ LEN ) { final int end = Math . min ( start + MAX _ BUF _ LEN , textLength ) ; No need to worry about getting half codepoints , since we consider surrogate code units _STR as soon we see one . TextUtils . getChars ( text , start , end , buffer , _NUM ) ; final int len = end - start ; for ( int i = _NUM ; i < len ; i + + ) { final char c = buffer [ i ] ; if ( c = = ' \ n ' | | c = = ' \ t ' | | TextUtils . couldAffectRtl ( c ) ) { return true ; } } } return false ; } finally { TextUtils . recycle ( buffer ) ; } } 
4354	public boolean verify ( SignerInformationVerifier verifier ) throws CMSException { has to be validated if present . Time signingTime = getSigningTime ( ) ; if ( verifier . hasAssociatedCertificate ( ) ) { if ( signingTime ! = null ) { X _NUM _NUM _NUM CertificateHolder dcv = verifier . getAssociatedCertificate ( ) ; if ( ! dcv . isValidOn ( signingTime . getDate ( ) ) ) { throw new CMSVerifierCertificateNotValidException ( _STR ) ; } } } return doVerify ( verifier ) ; } 
4355	public void close ( ) throws IOException { closeStream ( ) ; super . close ( ) ; if ( storeFile ! = null ) { storeFile . delete ( ) ; } } 
4356	public void testSingleRowMultipleFamily ( ) throws Exception { final TableName tableName = TableName . valueOf ( name . getMethodName ( ) ) ; byte [ ] [ ] ROWS = makeN ( ROW , _NUM ) ; byte [ ] [ ] FAMILIES = makeNAscii ( FAMILY , _NUM _NUM ) ; byte [ ] [ ] QUALIFIERS = makeN ( QUALIFIER , _NUM _NUM ) ; byte [ ] [ ] VALUES = makeN ( VALUE , _NUM _NUM ) ; Table ht = TEST _ UTIL . createTable ( tableName , FAMILIES ) ; Get get ; Scan scan ; Delete delete ; Put put ; Result result ; Insert one column to one family put = new Put ( ROWS [ _NUM ] ) ; put . addColumn ( FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] , VALUES [ _NUM ] ) ; ht . put ( put ) ; Get the single column getVerifySingleColumn ( ht , ROWS , _NUM , FAMILIES , _NUM , QUALIFIERS , _NUM , VALUES , _NUM ) ; Scan the single column scanVerifySingleColumn ( ht , ROWS , _NUM , FAMILIES , _NUM , QUALIFIERS , _NUM , VALUES , _NUM ) ; Get empty results around inserted column getVerifySingleEmpty ( ht , ROWS , _NUM , FAMILIES , _NUM , QUALIFIERS , _NUM ) ; Scan empty results around inserted column scanVerifySingleEmpty ( ht , ROWS , _NUM , FAMILIES , _NUM , QUALIFIERS , _NUM ) ; Flush memstore and run same tests from storefiles TEST _ UTIL . flush ( ) ; Redo get and scan tests from storefile getVerifySingleColumn ( ht , ROWS , _NUM , FAMILIES , _NUM , QUALIFIERS , _NUM , VALUES , _NUM ) ; scanVerifySingleColumn ( ht , ROWS , _NUM , FAMILIES , _NUM , QUALIFIERS , _NUM , VALUES , _NUM ) ; getVerifySingleEmpty ( ht , ROWS , _NUM , FAMILIES , _NUM , QUALIFIERS , _NUM ) ; scanVerifySingleEmpty ( ht , ROWS , _NUM , FAMILIES , _NUM , QUALIFIERS , _NUM ) ; Now , Test reading from memstore and storefiles at once Insert multiple columns to two other families put = new Put ( ROWS [ _NUM ] ) ; put . addColumn ( FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] , VALUES [ _NUM ] ) ; put . addColumn ( FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] , VALUES [ _NUM ] ) ; put . addColumn ( FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] , VALUES [ _NUM ] ) ; put . addColumn ( FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] , VALUES [ _NUM ] ) ; put . addColumn ( FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] , VALUES [ _NUM ] ) ; put . addColumn ( FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] , VALUES [ _NUM ] ) ; put . addColumn ( FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] , VALUES [ _NUM ] ) ; ht . put ( put ) ; Get multiple columns across multiple families and get empties around it singleRowGetTest ( ht , ROWS , FAMILIES , QUALIFIERS , VALUES ) ; Scan multiple columns across multiple families and scan empties around it singleRowScanTest ( ht , ROWS , FAMILIES , QUALIFIERS , VALUES ) ; Flush the table again TEST _ UTIL . flush ( ) ; Redo tests again singleRowGetTest ( ht , ROWS , FAMILIES , QUALIFIERS , VALUES ) ; singleRowScanTest ( ht , ROWS , FAMILIES , QUALIFIERS , VALUES ) ; Insert more data to memstore put = new Put ( ROWS [ _NUM ] ) ; put . addColumn ( FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] , VALUES [ _NUM ] ) ; put . addColumn ( FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] , VALUES [ _NUM ] ) ; put . addColumn ( FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] , VALUES [ _NUM ] ) ; put . addColumn ( FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] , VALUES [ _NUM ] ) ; ht . put ( put ) ; Delete a storefile column delete = new Delete ( ROWS [ _NUM ] ) ; delete . addColumns ( FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] ) ; ht . delete ( delete ) ; Try to get deleted column get = new Get ( ROWS [ _NUM ] ) ; get . addColumn ( FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] ) ; result = ht . get ( get ) ; assertEmptyResult ( result ) ; Try to scan deleted column scan = new Scan ( ) ; scan . addColumn ( FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] ) ; result = getSingleScanResult ( ht , scan ) ; assertNullResult ( result ) ; Make sure we can still get a column before it and after it get = new Get ( ROWS [ _NUM ] ) ; get . addColumn ( FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] ) ; result = ht . get ( get ) ; assertSingleResult ( result , ROWS [ _NUM ] , FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] , VALUES [ _NUM ] ) ; get = new Get ( ROWS [ _NUM ] ) ; get . addColumn ( FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] ) ; result = ht . get ( get ) ; assertSingleResult ( result , ROWS [ _NUM ] , FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] , VALUES [ _NUM ] ) ; Make sure we can still scan a column before it and after it scan = new Scan ( ) ; scan . addColumn ( FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] ) ; result = getSingleScanResult ( ht , scan ) ; assertSingleResult ( result , ROWS [ _NUM ] , FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] , VALUES [ _NUM ] ) ; scan = new Scan ( ) ; scan . addColumn ( FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] ) ; result = getSingleScanResult ( ht , scan ) ; assertSingleResult ( result , ROWS [ _NUM ] , FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] , VALUES [ _NUM ] ) ; Delete a memstore column delete = new Delete ( ROWS [ _NUM ] ) ; delete . addColumns ( FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] ) ; ht . delete ( delete ) ; Try to get deleted column get = new Get ( ROWS [ _NUM ] ) ; get . addColumn ( FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] ) ; result = ht . get ( get ) ; assertEmptyResult ( result ) ; Try to scan deleted column scan = new Scan ( ) ; scan . addColumn ( FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] ) ; result = getSingleScanResult ( ht , scan ) ; assertNullResult ( result ) ; Make sure we can still get a column before it and after it get = new Get ( ROWS [ _NUM ] ) ; get . addColumn ( FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] ) ; result = ht . get ( get ) ; assertSingleResult ( result , ROWS [ _NUM ] , FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] , VALUES [ _NUM ] ) ; get = new Get ( ROWS [ _NUM ] ) ; get . addColumn ( FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] ) ; result = ht . get ( get ) ; assertSingleResult ( result , ROWS [ _NUM ] , FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] , VALUES [ _NUM ] ) ; Make sure we can still scan a column before it and after it scan = new Scan ( ) ; scan . addColumn ( FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] ) ; result = getSingleScanResult ( ht , scan ) ; assertSingleResult ( result , ROWS [ _NUM ] , FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] , VALUES [ _NUM ] ) ; scan = new Scan ( ) ; scan . addColumn ( FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] ) ; result = getSingleScanResult ( ht , scan ) ; assertSingleResult ( result , ROWS [ _NUM ] , FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] , VALUES [ _NUM ] ) ; Delete joint storefile / memstore family delete = new Delete ( ROWS [ _NUM ] ) ; delete . addFamily ( FAMILIES [ _NUM ] ) ; ht . delete ( delete ) ; Try to get storefile column in deleted family get = new Get ( ROWS [ _NUM ] ) ; get . addColumn ( FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] ) ; result = ht . get ( get ) ; assertEmptyResult ( result ) ; Try to get memstore column in deleted family get = new Get ( ROWS [ _NUM ] ) ; get . addColumn ( FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] ) ; result = ht . get ( get ) ; assertEmptyResult ( result ) ; Try to get deleted family get = new Get ( ROWS [ _NUM ] ) ; get . addFamily ( FAMILIES [ _NUM ] ) ; result = ht . get ( get ) ; assertEmptyResult ( result ) ; Try to scan storefile column in deleted family scan = new Scan ( ) ; scan . addColumn ( FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] ) ; result = getSingleScanResult ( ht , scan ) ; assertNullResult ( result ) ; Try to scan memstore column in deleted family scan = new Scan ( ) ; scan . addColumn ( FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] ) ; result = getSingleScanResult ( ht , scan ) ; assertNullResult ( result ) ; Try to scan deleted family scan = new Scan ( ) ; scan . addFamily ( FAMILIES [ _NUM ] ) ; result = getSingleScanResult ( ht , scan ) ; assertNullResult ( result ) ; Make sure we can still get another family get = new Get ( ROWS [ _NUM ] ) ; get . addColumn ( FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] ) ; result = ht . get ( get ) ; assertSingleResult ( result , ROWS [ _NUM ] , FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] , VALUES [ _NUM ] ) ; get = new Get ( ROWS [ _NUM ] ) ; get . addColumn ( FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] ) ; result = ht . get ( get ) ; assertSingleResult ( result , ROWS [ _NUM ] , FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] , VALUES [ _NUM ] ) ; Make sure we can still scan another family scan = new Scan ( ) ; scan . addColumn ( FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] ) ; result = getSingleScanResult ( ht , scan ) ; assertSingleResult ( result , ROWS [ _NUM ] , FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] , VALUES [ _NUM ] ) ; scan = new Scan ( ) ; scan . addColumn ( FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] ) ; result = getSingleScanResult ( ht , scan ) ; assertSingleResult ( result , ROWS [ _NUM ] , FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] , VALUES [ _NUM ] ) ; Flush everything and rerun delete tests TEST _ UTIL . flush ( ) ; Try to get storefile column in deleted family get = new Get ( ROWS [ _NUM ] ) ; get . addColumn ( FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] ) ; result = ht . get ( get ) ; assertEmptyResult ( result ) ; Try to get memstore column in deleted family get = new Get ( ROWS [ _NUM ] ) ; get . addColumn ( FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] ) ; result = ht . get ( get ) ; assertEmptyResult ( result ) ; Try to get deleted family get = new Get ( ROWS [ _NUM ] ) ; get . addFamily ( FAMILIES [ _NUM ] ) ; result = ht . get ( get ) ; assertEmptyResult ( result ) ; Try to scan storefile column in deleted family scan = new Scan ( ) ; scan . addColumn ( FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] ) ; result = getSingleScanResult ( ht , scan ) ; assertNullResult ( result ) ; Try to scan memstore column in deleted family scan = new Scan ( ) ; scan . addColumn ( FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] ) ; result = getSingleScanResult ( ht , scan ) ; assertNullResult ( result ) ; Try to scan deleted family scan = new Scan ( ) ; scan . addFamily ( FAMILIES [ _NUM ] ) ; result = getSingleScanResult ( ht , scan ) ; assertNullResult ( result ) ; Make sure we can still get another family get = new Get ( ROWS [ _NUM ] ) ; get . addColumn ( FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] ) ; result = ht . get ( get ) ; assertSingleResult ( result , ROWS [ _NUM ] , FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] , VALUES [ _NUM ] ) ; get = new Get ( ROWS [ _NUM ] ) ; get . addColumn ( FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] ) ; result = ht . get ( get ) ; assertSingleResult ( result , ROWS [ _NUM ] , FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] , VALUES [ _NUM ] ) ; Make sure we can still scan another family scan = new Scan ( ) ; scan . addColumn ( FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] ) ; result = getSingleScanResult ( ht , scan ) ; assertSingleResult ( result , ROWS [ _NUM ] , FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] , VALUES [ _NUM ] ) ; scan = new Scan ( ) ; scan . addColumn ( FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] ) ; result = getSingleScanResult ( ht , scan ) ; assertSingleResult ( result , ROWS [ _NUM ] , FAMILIES [ _NUM ] , QUALIFIERS [ _NUM ] , VALUES [ _NUM ] ) ; } 
4357	public boolean canGoForward ( ) { checkThread ( ) ; return mProvider . canGoForward ( ) ; } 
4358	private static void runInteractiveCLI ( ) throws IOException { Logger . getLogger ( _STR ) . setLevel ( Level . FINE ) ; try ( final Terminal terminal = TerminalBuilder . builder ( ) . name ( SHELL _ NAME ) . system ( true ) . nativeSignals ( true ) . signalHandler ( Terminal . SignalHandler . SIG _ IGN ) . build ( ) ; final PrintStream output = new PrintStream ( terminal . output ( ) , true ) ) { printHeader ( BANNER _ FILE , output ) ; final Context context = createContext ( output , true ) ; final Map < String , Command > topLevelCommands = CommandFactory . createTopLevelCommands ( context ) ; final Map < String , CommandGroup > commandGroups = CommandFactory . createCommandGroups ( context ) ; final CommandProcessor commandProcessor = new CommandProcessor ( topLevelCommands , commandGroups , context ) ; final Completer completer = new CLICompleter ( topLevelCommands . values ( ) , commandGroups . values ( ) ) ; final LineReader reader = LineReaderBuilder . builder ( ) . appName ( SHELL _ NAME ) . terminal ( terminal ) . completer ( completer ) . build ( ) ; reader . setOpt ( LineReader . Option . AUTO _ FRESH _ LINE ) ; reader . unsetOpt ( LineReader . Option . INSERT _ TAB ) ; while ( true ) { try { final String line = reader . readLine ( PROMPT ) ; if ( StringUtils . isBlank ( line ) ) { continue ; } final ParsedLine parsedLine = reader . getParsedLine ( ) ; final String [ ] parsedArgs = parsedLine . words ( ) . toArray ( new String [ parsedLine . words ( ) . size ( ) ] ) ; commandProcessor . process ( parsedArgs ) ; } catch ( UserInterruptException e ) { Ignore } catch ( EndOfFileException e ) { return ; } } } } 
4359	public static HRegion createHDFSRegionDir ( Configuration conf , RegionInfo hri , TableDescriptor htd ) throws IOException { Create HRegion Path root = FSUtils . getRootDir ( conf ) ; HRegion region = HRegion . createHRegion ( hri , root , conf , htd , null ) ; Close the new region to flush to disk . Close log file too . region . close ( ) ; return region ; } 
4360	private static Map < String , String > processProperties ( Map < String , String > previousStackProperties , Map < String , String > newStackProperties , Map < String , String > userProperties ) { if ( ( previousStackProperties = = null ) & & ( newStackProperties = = null ) ) { return userProperties ; } else { Map < String , String > updatedProperties = new TreeMap < > ( ) ; if ( userProperties ! = null ) { updatedProperties . putAll ( userProperties ) ; } if ( previousStackProperties = = null ) { previousStackProperties = Collections . emptyMap ( ) ; } if ( newStackProperties = = null ) { newStackProperties = Collections . emptyMap ( ) ; } Find properties to modify and remove for ( Map . Entry < String , String > entry : previousStackProperties . entrySet ( ) ) { String name = entry . getKey ( ) ; if ( newStackProperties . containsKey ( name ) ) { String previousValue = entry . getValue ( ) ; String newValue = newStackProperties . get ( name ) ; String userValue = updatedProperties . get ( name ) ; risky to change it to the new stack default value . if ( ( ( previousValue = = null ) ? ( newValue ! = null ) : ! previousValue . equals ( newValue ) ) & & ( ( previousValue = = null ) ? ( userValue = = null ) : previousValue . equals ( userValue ) ) ) { LOG . debug ( _STR , name ) ; updatedProperties . put ( name , entry . getValue ( ) ) ; } } return updatedProperties ; } } 
4361	private boolean loadNextPage ( ) { try { results = results . getNextPageResults ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } return initCurrentPageIterator ( ) ; } 
4362	public static void main ( final String [ ] args ) throws Exception { File summaryFile = new File ( args [ _NUM ] ) ; NPOIFSFileSystem poifs = new NPOIFSFileSystem ( summaryFile , false ) ; DirectoryEntry dir = poifs . getRoot ( ) ; SummaryInformation si ; try { si = ( SummaryInformation ) PropertySetFactory . create ( dir , SummaryInformation . DEFAULT _ STREAM _ NAME ) ; } catch ( FileNotFoundException ex ) { There is no summary information yet . We have to create a new one si = PropertySetFactory . newSummaryInformation ( ) ; } si . setAuthor ( _STR + value ) ; dsi . setCustomProperties ( customProperties ) ; si . write ( dir , SummaryInformation . DEFAULT _ STREAM _ NAME ) ; dsi . write ( dir , DocumentSummaryInformation . DEFAULT _ STREAM _ NAME ) ; poifs . writeFilesystem ( ) ; poifs . close ( ) ; } 
4363	public float writeSelectedRows ( int colStart , int colEnd , int rowStart , int rowEnd , float xPos , float yPos , PdfContentByte canvas ) { int totalCols = getNumberOfColumns ( ) ; if ( colStart < _NUM ) colStart = _NUM ; else colStart = Math . min ( colStart , totalCols ) ; if ( colEnd < _NUM ) colEnd = totalCols ; else colEnd = Math . min ( colEnd , totalCols ) ; boolean clip = ( colStart ! = _NUM | | colEnd ! = totalCols ) ; if ( clip ) { float w = _NUM ; for ( int k = colStart ; k < colEnd ; + + k ) w + = absoluteWidths [ k ] ; canvas . saveState ( ) ; float lx = ( colStart = = _NUM ) ? _NUM _NUM _NUM _NUM _NUM : _NUM ; float rx = ( colEnd = = totalCols ) ? _NUM _NUM _NUM _NUM _NUM : _NUM ; canvas . rectangle ( xPos - lx , - _NUM _NUM _NUM _NUM _NUM , w + lx + rx , PdfPRow . RIGHT _ LIMIT ) ; canvas . clip ( ) ; canvas . newPath ( ) ; } PdfContentByte [ ] canvases = beginWritingRows ( canvas ) ; float y = writeSelectedRows ( colStart , colEnd , rowStart , rowEnd , xPos , yPos , canvases ) ; endWritingRows ( canvases ) ; if ( clip ) canvas . restoreState ( ) ; return y ; } 
4364	public static void info ( final Logger logger , final String pattern , final long argument ) { if ( logger . isInfoEnabled ( ) ) { forcedLog ( logger , Level . INFO , format ( pattern , valueOf ( argument ) ) ) ; } } 
4365	public void showProperties ( ) { ArffPanel panel ; ListSelectorDialog dialog ; Vector props ; Instances inst ; panel = getCurrentPanel ( ) ; if ( panel = = null ) return ; inst = panel . getInstances ( ) ; if ( inst = = null ) return ; if ( inst . classIndex ( ) < _NUM ) inst . setClassIndex ( inst . numAttributes ( ) - _NUM ) ; get some data props = new Vector ( ) ; props . add ( _STR + inst . numClasses ( ) ) ; dialog = new ListSelectorDialog ( getParentFrame ( ) , new JList ( props ) ) ; dialog . showDialog ( ) ; } 
4366	public View getView ( int position , View convertView , ViewGroup parent ) { View view ; if ( convertView = = null ) { view = mInflater . inflate ( R . layout . list _ item _ icon _ text , parent , false ) ; } else { view = convertView ; } AppEntry item = getItem ( position ) ; ( ( ImageView ) view . findViewById ( R . id . icon ) ) . setImageDrawable ( item . getIcon ( ) ) ; ( ( TextView ) view . findViewById ( R . id . text ) ) . setText ( item . getLabel ( ) ) ; return view ; } 
4367	public Collection < V > values ( ) { return getAllPartitionMaps ( ) . stream ( ) . map ( Map : : values ) . flatMap ( Collection : : stream ) . collect ( Collectors . toList ( ) ) ; } 
4368	public int getPreviewFrameRate ( ) { return getInt ( KEY _ PREVIEW _ FRAME _ RATE ) ; } 
4369	used only by the set operationsstatic final CompactSketch createCompactSketch ( final long [ ] compactCache , final boolean empty , final short seedHash , final int curCount , final long thetaLong , final boolean dstOrdered , final WritableMemory dstMem ) { CompactSketch sketchOut = null ; final int sw = ( dstOrdered ? _NUM : _NUM ) | ( ( dstMem ! = null ) ? _NUM : _NUM ) ; switch ( sw ) { case _NUM : { dst not ordered , dstMem = = null sketchOut = HeapCompactUnorderedSketch . compact ( compactCache , empty , seedHash , curCount , thetaLong ) ; break ; } case _NUM : { dst not ordered , dstMem = = valid sketchOut = DirectCompactUnorderedSketch . compact ( compactCache , empty , seedHash , curCount , thetaLong , dstMem ) ; break ; } case _NUM : { dst ordered , dstMem = = null sketchOut = HeapCompactOrderedSketch . compact ( compactCache , empty , seedHash , curCount , thetaLong ) ; break ; } case _NUM : { dst ordered , dstMem = = valid sketchOut = DirectCompactOrderedSketch . compact ( compactCache , empty , seedHash , curCount , thetaLong , dstMem ) ; break ; } } return sketchOut ; } 
4370	public static < T , R > void checkDoubleOnSubscribeFlowable ( Function < Flowable < T > , ? extends Publisher < R > > transform ) { List < Throwable > errors = trackPluginErrors ( ) ; try { final Boolean [ ] b = { null , null } ; final CountDownLatch cdl = new CountDownLatch ( _NUM ) ; Flowable < T > source = new Flowable < T > ( ) { @ Override protected void subscribeActual ( Subscriber < ? super T > subscriber ) { try { BooleanSubscription d _NUM = new BooleanSubscription ( ) ; subscriber . onSubscribe ( d _NUM ) ; BooleanSubscription d _NUM = new BooleanSubscription ( ) ; subscriber . onSubscribe ( d _NUM ) ; b [ _NUM ] = d _NUM . isCancelled ( ) ; b [ _NUM ] = d _NUM . isCancelled ( ) ; } finally { cdl . countDown ( ) ; } } } ; Publisher < R > out = transform . apply ( source ) ; out . subscribe ( NoOpConsumer . INSTANCE ) ; try { assertTrue ( _STR ) ; } catch ( Throwable ex ) { throw ExceptionHelper . wrapOrThrow ( ex ) ; } finally { RxJavaPlugins . reset ( ) ; } } 
4371	public static String [ ] getCausing ( String verb ) { Synset synset = getCommonSynset ( verb , VERB ) ; if ( synset = = null ) return null ; Synset [ ] causing = getCausingSynsets ( synset ) ; if ( causing = = null ) return null ; return getLemmas ( causing ) ; } 
4372	public boolean optBoolean ( int index , boolean defaultValue ) { try { return getBoolean ( index ) ; } catch ( Exception e ) { return defaultValue ; } } 
4373	final int getIconResourceInternal ( ) { if ( iconResourceId ! = _NUM ) return iconResourceId ; final ComponentInfo ci = getComponentInfo ( ) ; if ( ci ! = null ) { return ci . getIconResource ( ) ; } return _NUM ; } 
4374	public void setColumnOrder ( Object [ ] columnOrder ) { if ( columnOrder = = null | | ! isColumnReorderingAllowed ( ) ) { return ; } final LinkedList < Object > newOrder = new LinkedList < > ( ) ; for ( Object aColumnOrder : columnOrder ) { if ( aColumnOrder ! = null & & visibleColumns . contains ( aColumnOrder ) ) { visibleColumns . remove ( aColumnOrder ) ; newOrder . add ( aColumnOrder ) ; } } for ( final Object columnId : visibleColumns ) { if ( ! newOrder . contains ( columnId ) ) { newOrder . add ( columnId ) ; } } visibleColumns = newOrder ; Assure visual refresh refreshRowCache ( ) ; } 
4375	public boolean groupHasAccess ( String groupName , TableName table , Permission . Action action ) { Global authorization supercedes table level if ( authorizeGroup ( groupName , action ) ) { return true ; } if ( table = = null ) table = AccessControlLists . ACL _ TABLE _ NAME ; Namespace authorization supercedes table level if ( hasAccess ( getNamespacePermissions ( table . getNamespaceAsString ( ) ) . getGroup ( groupName ) , table , action ) ) { return true ; } Check table level return hasAccess ( getTablePermissions ( table ) . getGroup ( groupName ) , table , action ) ; } 
4376	public void clearSnapshot ( long id ) throws UnexpectedStateException { already cleared if ( this . snapshotId = = - _NUM ) return ; if ( this . snapshotId ! = id ) { throw new UnexpectedStateException ( _STR + id ) ; } OK . Passed in snapshot is same as current snapshot . If not - empty , create a new snapshot and let the old one go . Segment oldSnapshot = this . snapshot ; if ( ! this . snapshot . isEmpty ( ) ) { this . snapshot = SegmentFactory . instance ( ) . createImmutableSegment ( this . comparator ) ; } this . snapshotId = NO _ SNAPSHOT _ ID ; oldSnapshot . close ( ) ; } 
4377	public void debug ( Object message , Throwable t ) { log ( DEBUG , message , t ) ; } 
4378	public static int deepHashCode ( Object o ) { if ( o = = null ) { return _NUM ; } Class < ? > clazz = o . getClass ( ) ; if ( clazz . isArray ( ) ) { Class < ? > elementType = clazz . getComponentType ( ) ; if ( elementType . isPrimitive ( ) ) { return primitiveArrayHashCode ( o ) ; } return Arrays . hashCode ( Arrays . stream ( ( Object [ ] ) o ) . mapToInt ( element - > deepHashCode ( element ) ) . toArray ( ) ) ; } if ( o instanceof List < ? > ) { return Arrays . hashCode ( ( ( List < Object > ) o ) . stream ( ) . mapToInt ( element - > deepHashCode ( element ) ) . toArray ( ) ) ; } throwErrorIfUnsupportedType ( o ) ; return o . hashCode ( ) ; } 
4379	public void getInsertedKeys ( ) throws Exception { Initialize a batch of key - value pairs int testKeys = _NUM _NUM _NUM ; byte [ ] [ ] keys = new byte [ testKeys ] [ ] ; byte [ ] [ ] values = new byte [ testKeys ] [ ] ; for ( int i = _NUM ; i < testKeys ; i + + ) { keys [ i ] = String . format ( _STR , i ) . getBytes ( ) ; } LinearProbingIndex index = LinearProbingIndex . createEmptyIndex ( ) ; Insert this batch of key - value pairs for ( int i = _NUM ; i < testKeys ; i + + ) { assertTrue ( index . put ( keys [ i ] , values [ i ] , mPayloadWriter ) ) ; assertEquals ( i + _NUM , index . keyCount ( ) ) ; } mPayloadWriter . close ( ) ; Read all keys back , expect same value as inserted BasePayloadReader payloadReader = new BasePayloadReader ( ByteBuffer . wrap ( mOutStream . toByteArray ( ) ) ) ; for ( int i = _NUM ; i < testKeys ; i + + ) { ByteBuffer value = index . get ( ByteBuffer . wrap ( keys [ i ] ) , payloadReader ) ; assertEquals ( ByteBuffer . wrap ( values [ i ] ) , value ) ; } } 
4380	public ReifiedStatement createReifiedStatement ( String uri , Statement s ) { return ReifiedStatementImpl . create ( model , uri , s ) ; } 
4381	public void setAsActiveCell ( ) throws IOException { Workbook wb = _ testDataProvider . createWorkbook ( ) ; Sheet sheet = wb . createSheet ( ) ; Row row = sheet . createRow ( _NUM ) ; Cell A _NUM = row . createCell ( _NUM ) ; Cell B _NUM = row . createCell ( _NUM ) ; A _NUM . setAsActiveCell ( ) ; assertEquals ( A _NUM . getAddress ( ) , sheet . getActiveCell ( ) ) ; B _NUM . setAsActiveCell ( ) ; assertEquals ( B _NUM . getAddress ( ) , sheet . getActiveCell ( ) ) ; wb . close ( ) ; } 
4382	public boolean projectsIdentity ( final boolean fail ) { final int fieldCount = inputRowType . getFieldCount ( ) ; if ( projects . size ( ) < fieldCount ) { assert ! fail : _STR + i ; return false ; } } return true ; } 
4383	public int numSlices ( ) { return numRows ( ) ; } 
4384	public void writeTag ( final Writer w , final String name , final Properties attributes , final boolean close ) throws IOException { final AttributeList attList = new AttributeList ( ) ; final Enumeration keys = attributes . keys ( ) ; while ( keys . hasMoreElements ( ) ) { final String key = ( String ) keys . nextElement ( ) ; attList . setAttribute ( key , attributes . getProperty ( key ) ) ; } writeTag ( w , name , attList , close ) ; } 
4385	protected List < ServerName > generateDeadServersListToSend ( ) { We ' re getting the message sent since last time , and add them to the list long since = EnvironmentEdgeManager . currentTime ( ) - messagePeriod * _NUM ; for ( Pair < ServerName , Long > dead : getDeadServers ( since ) ) { lastSent . putIfAbsent ( dead . getFirst ( ) , _NUM ) ; } We ' re sending the new deads first . List < Map . Entry < ServerName , Integer > > entries = new ArrayList < > ( ) ; entries . addAll ( lastSent . entrySet ( ) ) ; Collections . sort ( entries , new Comparator < Map . Entry < ServerName , Integer > > ( ) { @ Override public int compare ( Map . Entry < ServerName , Integer > o _NUM , Map . Entry < ServerName , Integer > o _NUM ) { return o _NUM . getValue ( ) . compareTo ( o _NUM . getValue ( ) ) ; } } ) ; With a limit of MAX _ SERVER _ PER _ MESSAGE int max = entries . size ( ) > MAX _ SERVER _ PER _ MESSAGE ? MAX _ SERVER _ PER _ MESSAGE : entries . size ( ) ; List < ServerName > res = new ArrayList < > ( max ) ; for ( int i = _NUM ; i < max ; i + + ) { Map . Entry < ServerName , Integer > toSend = entries . get ( i ) ; if ( toSend . getValue ( ) > = ( NB _ SEND - _NUM ) ) { lastSent . remove ( toSend . getKey ( ) ) ; } else { lastSent . replace ( toSend . getKey ( ) , toSend . getValue ( ) , toSend . getValue ( ) + _NUM ) ; } res . add ( toSend . getKey ( ) ) ; } return res ; } 
4386	public void testToString ( ) { assertEquals ( _STR , set ( ) . toString ( ) ) ; Set full = populatedSet ( _NUM ) ; String s = full . toString ( ) ; for ( int i = _NUM ; i < _NUM ; + + i ) { assertTrue ( s . contains ( String . valueOf ( i ) ) ) ; } } 
4387	private displays if ( activityDisplay . isPrivate ( ) ) { mDisplayAccessUIDs . append ( activityDisplay . mDisplayId , activityDisplay . getPresentUIDs ( ) ) ; } } Store updated lists in DisplayManager . Callers from outside of AM should get them there . mDisplayManagerInternal . setDisplayAccessUIDs ( mDisplayAccessUIDs ) ; } 
4388	public void testOutOfSpace ( ) throws Exception { thrown . expect ( IllegalStateException . class ) ; thrown . expectMessage ( is ( _STR ) ) ; SorterTestUtils . testRandom ( ( ) - > { InMemorySorter . Options options = new InMemorySorter . Options ( ) ; options . setMemoryMB ( _NUM ) ; return InMemorySorter . create ( options ) ; } , _NUM , _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM ) ; } 
4389	public String toString ( int maxCols ) { try { return toJSON ( maxCols ) ; } catch ( IOException ioe ) { return toMap ( maxCols ) . toString ( ) ; } } 
4390	SHOW @ @ SQL WHERE ID = XXXXXXstatic int show _NUM SqlBlankCheck ( String stmt , int offset ) { for ( + + offset ; stmt . length ( ) > offset ; + + offset ) { switch ( stmt . charAt ( offset ) ) { case ' ' : continue ; case ' W ' : case ' w ' : if ( isWhere ( stmt , offset ) ) { return SQL ; } else { return OTHER ; } default : return OTHER ; } } return OTHER ; } 
4391	 @ Nullablefinal Controller findController ( @ NonNull String instanceId ) { if ( this . instanceId . equals ( instanceId ) ) { return this ; } for ( Router router : childRouters ) { Controller matchingChild = router . getControllerWithInstanceId ( instanceId ) ; if ( matchingChild ! = null ) { return matchingChild ; } } return null ; } 
4392	public IComplexNDArray negi ( ) { return ( IComplexNDArray ) Transforms . neg ( this ) ; } 
4393	public static double ssTotal ( double [ ] residuals , double [ ] targetAttribute ) { return ssReg ( residuals , targetAttribute ) + ssError ( residuals , targetAttribute ) ; } 
4394	public void drawSeries ( Canvas canvas , Paint paint , List < Float > points , XYSeriesRenderer seriesRenderer , float yAxisValue , int seriesIndex , int startIndex ) { int seriesNr = mDataset . getSeriesCount ( ) ; int length = points . size ( ) ; paint . setColor ( seriesRenderer . getColor ( ) ) ; paint . setStyle ( Style . FILL ) ; float halfDiffX = getHalfDiffX ( points , length , seriesNr ) ; for ( int i = _NUM ; i < length ; i + = _NUM ) { float x = points . get ( i ) ; float y = points . get ( i + _NUM ) ; if ( mType = = Type . HEAPED & & seriesIndex > _NUM ) { float lastY = mPreviousSeriesPoints . get ( i + _NUM ) ; y = y + ( lastY - yAxisValue ) ; points . set ( i + _NUM , y ) ; drawBar ( canvas , x , lastY , x , y , halfDiffX , seriesNr , seriesIndex , paint ) ; } else { drawBar ( canvas , x , yAxisValue , x , y , halfDiffX , seriesNr , seriesIndex , paint ) ; } } paint . setColor ( seriesRenderer . getColor ( ) ) ; mPreviousSeriesPoints = points ; } 
4395	public boolean lockResource ( CmsObject cms , String resourcename ) throws CmsException { CmsResource res = getResource ( cms , resourcename ) ; if ( res ! = null ) { cms . lockResource ( cms . getRequestContext ( ) . removeSiteRoot ( res . getRootPath ( ) ) ) ; return true ; } return false ; } 
4396	private static int getMinimumRequiredVersion ( NSObject root ) { int minVersion = VERSION _ _NUM _NUM ; if ( root = = null ) { minVersion = VERSION _ _NUM _NUM ; } if ( root instanceof NSDictionary ) { NSDictionary dict = ( NSDictionary ) root ; for ( NSObject o : dict . getHashMap ( ) . values ( ) ) { int v = getMinimumRequiredVersion ( o ) ; if ( v > minVersion ) minVersion = v ; } } else if ( root instanceof NSArray ) { NSArray array = ( NSArray ) root ; for ( NSObject o : array . getArray ( ) ) { int v = getMinimumRequiredVersion ( o ) ; if ( v > minVersion ) minVersion = v ; } } else if ( root instanceof NSSet ) { Sets are only allowed in property lists v _NUM + minVersion = VERSION _ _NUM _NUM ; NSSet set = ( NSSet ) root ; for ( NSObject o : set . allObjects ( ) ) { int v = getMinimumRequiredVersion ( o ) ; if ( v > minVersion ) minVersion = v ; } } return minVersion ; } 
4397	public static void addJarDirToDistributedCache ( Configuration conf , File jarDirectory ) throws IOException { if ( ! jarDirectory . exists ( ) | | ! jarDirectory . isDirectory ( ) ) { throw new IOException ( _STR ) ) { addJarToDistributedCache ( conf , file ) ; } } } 
4398	public static Object getField ( Object owner , String targetClass , String fieldName ) throws SecurityException , NoSuchFieldException , IllegalArgumentException , IllegalAccessException { Class < ? > ownerclass = getTargetclass ( owner , targetClass ) ; Field field = ownerclass . getDeclaredField ( fieldName ) ; if ( ! field . isAccessible ( ) ) { field . setAccessible ( true ) ; } Object property = field . get ( owner ) ; return property ; } 
4399	public boolean containOnlyDigitalGoods ( ) { for ( ShoppingCartItem cartItem : this . cartLines ) { GenericValue product = cartItem . getProduct ( ) ; try { GenericValue productType = product . getRelatedOne ( _STR return false ; } } return true ; } 
4400	public void setReplyToConcurrentConsumers ( int concurrentConsumers ) { getConfiguration ( ) . setReplyToConcurrentConsumers ( concurrentConsumers ) ; } 
4401	public static RelDataType realRowType ( RelOptTable table ) { final RelDataType rowType = table . getRowType ( ) ; final List < ColumnStrategy > strategies = columnStrategies ( table ) ; if ( ! strategies . contains ( ColumnStrategy . VIRTUAL ) ) { return rowType ; } final RelDataTypeFactory . Builder builder = table . getRelOptSchema ( ) . getTypeFactory ( ) . builder ( ) ; for ( RelDataTypeField field : rowType . getFieldList ( ) ) { if ( strategies . get ( field . getIndex ( ) ) ! = ColumnStrategy . VIRTUAL ) { builder . add ( field ) ; } } return builder . build ( ) ; } 
4402	public void testComparableFamily ( ) { makes measured test run time - > _NUM _NUM ms int size = _NUM _NUM _NUM ; ConcurrentMap < BI , Boolean > m = map ( ) ; for ( int i = _NUM ; i < size ; i + + ) { assertTrue ( m . put ( new CI ( i ) , true ) = = null ) ; } for ( int i = _NUM ; i < size ; i + + ) { assertTrue ( m . containsKey ( new CI ( i ) ) ) ; assertTrue ( m . containsKey ( new DI ( i ) ) ) ; } } 
4403	void saveTable ( Path saveTo ) throws IOException { don ' t persist in test mode if ( ! Files . isDirectory ( saveTo . getParent ( ) ) ) return ; ByteBuffer tableBuffer = AnonAllocator . allocate ( _NUM _NUM * _NUM _NUM _NUM _NUM * _NUM _NUM _NUM _NUM ) ; Map < String , Object > tableMap = new TreeMap < > ( ) ; RoutingTable table = routingTableCOW ; Stream < Map < String , Object > > main = table . stream ( ) . map ( RoutingTableEntry : : getBucket ) . flatMap ( b - > b . entriesStream ( ) . map ( KBucketEntry : : toBencoded ) ) ; Stream < Map < String , Object > > replacements = table . stream ( ) . map ( RoutingTableEntry : : getBucket ) . flatMap ( b - > b . replacementsStream ( ) . map ( KBucketEntry : : toBencoded ) ) ; tableMap . put ( _STR ) ; try ( SeekableByteChannel chan = Files . newByteChannel ( tempFile , StandardOpenOption . WRITE ) ) { chan . write ( tableBuffer ) ; chan . close ( ) ; Files . move ( tempFile , saveTo , StandardCopyOption . ATOMIC _ MOVE , StandardCopyOption . REPLACE _ EXISTING ) ; } ; } 
4404	public void suspend ( long pos ) { for ( PlaylistItem item : mPlaylist ) { item . setRemoteItemId ( null ) ; item . setDuration ( _NUM ) ; } PlaylistItem item = getCurrentItem ( ) ; if ( DEBUG ) { log ( _STR + pos ) ; } if ( item ! = null ) { if ( item . getState ( ) = = MediaItemStatus . PLAYBACK _ STATE _ PLAYING | | item . getState ( ) = = MediaItemStatus . PLAYBACK _ STATE _ PAUSED ) { item . setState ( MediaItemStatus . PLAYBACK _ STATE _ PENDING ) ; item . setPosition ( pos ) ; } } } 
4405	public static Object get ( String key ) { if ( mdc ! = null ) { return mdc . get _NUM ( key ) ; } return null ; } 
4406	private Exception safeClose ( AutoCloseable item , Exception ex ) { try { if ( item ! = null ) { item . close ( ) ; } } catch ( Exception e ) { ex = ex = = null ? e : ex ; } return ex ; } 
4407	TransferRecord getTransferById ( int id ) { TransferRecord transfer = null ; Cursor c = null ; try { c = queryTransferById ( id ) ; if ( c . moveToFirst ( ) ) { transfer = new TransferRecord ( id ) ; transfer . updateFromDB ( c ) ; } } finally { if ( c ! = null ) { c . close ( ) ; } } return transfer ; } 
4408	private void doAfterFlush ( ) throws IOException { All ThreadStates should be idle when we are called assert allThreadsIdle ( ) ; threadBindings . clear ( ) ; waitQueue . reset ( ) ; segment = null ; numDocs = _NUM ; nextDocID = _NUM ; bufferIsFull = false ; for ( int i = _NUM ; i < threadStates . length ; i + + ) { threadStates [ i ] . doAfterFlush ( ) ; } } 
4409	public void beginUpdate ( ) { checkIfClosed ( ) ; blockMgr . beginRead ( ) ; } 
4410	private List < ClusterCandidate > createBaseClusters ( SequenceBuilder sb ) { final List < ClusterCandidate > candidates = Lists . newArrayList ( ) ; Walk the internal nodes of the suffix tree . new GeneralizedSuffixTree . Visitor ( sb , minBaseClusterSize ) { protected void visit ( int state , int cardinality , BitSet documents , IntStack path ) { Check minimum base cluster cardinality . assert cardinality > = minBaseClusterSize ; if ( ! checkAcceptablePhrase ( path ) ) { return ; } Calculate _STR , which is the number of non - stopwords . final int effectivePhraseLen = effectivePhraseLength ( path ) ; if ( effectivePhraseLen = = _NUM ) { return ; } final float score = baseClusterScore ( effectivePhraseLen , cardinality ) ; candidates . add ( new ClusterCandidate ( path . toArray ( ) , ( BitSet ) documents . clone ( ) , cardinality , score ) ) ; } } . visit ( ) ; if ( mergeStemEquivalentBaseClusters ) { mergeStemEquivalentBaseClusters ( sb , candidates ) ; } int j = _NUM ; for ( int max = candidates . size ( ) , i = _NUM ; i < max ; i + + ) { ClusterCandidate cc = candidates . get ( i ) ; if ( cc . score > = minBaseClusterScore ) { candidates . set ( j + + , cc ) ; } } candidates . subList ( j , candidates . size ( ) ) . clear ( ) ; Collections . sort ( candidates , new Comparator < ClusterCandidate > ( ) { @ Override public int compare ( ClusterCandidate c _NUM , ClusterCandidate c _NUM ) { return - Float . compare ( c _NUM . score , c _NUM . score ) ; } } ) ; j = _NUM ; ILexicalData lexicalData = context . language . getLexicalData ( ) ; for ( int max = candidates . size ( ) , i = _NUM ; i < max & & j < maxBaseClusters ; i + + ) { ClusterCandidate cc = candidates . get ( i ) ; we only do this for base clusters which are promoted to merging phase . assert cc . phrases . size ( ) = = _NUM ; if ( ! lexicalData . isStopLabel ( buildLabel ( cc . phrases . get ( _NUM ) ) ) ) { candidates . set ( j + + , cc ) ; } } if ( j < candidates . size ( ) ) { candidates . subList ( j , candidates . size ( ) ) . clear ( ) ; assert candidates . size ( ) = = j ; } return candidates ; } 
4411	private void getRegionInfo ( Table table ) throws IOException { Get get = new Get ( ROW _ KEY ) ; get . addColumn ( HConstants . CATALOG _ FAMILY , HConstants . REGIONINFO _ QUALIFIER ) ; Result result = table . get ( get ) ; byte [ ] bytes = result . value ( ) ; validateRegionInfo ( bytes ) ; } 
4412	public void setDrawerContent ( @ Nullable View content ) { if ( setDrawerContentWithoutAdding ( content ) ) { addView ( content ) ; } } 
4413	public static String revertNewLines ( String string ) { int index ; Replace with \ n StringBuffer newStringBuffer = new StringBuffer ( ) ; while ( ( index = string . indexOf ( _STR ; } } newStringBuffer . append ( string ) ; return newStringBuffer . toString ( ) ; } 
4414	public int displaySavedQuery ( List < ? extends SearchResult > data ) { clearResults ( ) ; mSearchResults . addAll ( data ) ; notifyDataSetChanged ( ) ; return mSearchResults . size ( ) ; } 
4415	 @ NonNullLayoutInflater performGetLayoutInflater ( @ Nullable Bundle savedInstanceState ) { LayoutInflater layoutInflater = onGetLayoutInflater ( savedInstanceState ) ; mLayoutInflater = layoutInflater ; return mLayoutInflater ; } 
4416	public static String toSortedString ( final String separator , final Param < ? , ? > . . . parameters ) { Arrays . sort ( parameters , NAME _ CMP ) ; final StringBuilder b = new StringBuilder ( ) ; try { for ( Param < ? , ? > p : parameters ) { if ( p . getValue ( ) ! = null ) { b . append ( separator ) . append ( URLEncoder . encode ( p . getName ( ) , _STR ) ) ; } } } catch ( UnsupportedEncodingException e ) { Sane systems know about UTF - _NUM , so this should never happen . throw new RuntimeException ( e ) ; } return b . toString ( ) ; } 
4417	public int getKeyChainGroupLookaheadSize ( ) { keyChainGroupLock . lock ( ) ; try { return keyChainGroup . getLookaheadSize ( ) ; } finally { keyChainGroupLock . unlock ( ) ; } } 
4418	private boolean showHeaderOf ( int position , T item , boolean init ) { Take the header IHeader header = getHeaderOf ( item ) ; Check header existence if ( header = = null | | getPendingRemovedItem ( item ) ! = null ) return false ; if ( header . isHidden ( ) ) { log . v ( _STR , position , header ) ; header . setHidden ( false ) ; Insert header , but skip notifyItemInserted when init = true ! We are adding headers to the provided list at startup ( no need to notify ) performInsert ( position , Collections . singletonList ( ( T ) header ) , ! init ) ; return true ; } return false ; } 
4419	public final T blockingGet ( ) { BlockingGetSubscriber < T > s = new BlockingGetSubscriber < T > ( ) ; subscribe ( s ) ; return s . blockingGet ( ) ; } 
4420	public void add _ delete _ dataset _ _NUM ( ) { checkNotThere ( dsTest ) ; File f = new File ( fileBase + _STR + opDatasets , e ) ; } catch ( HttpException ex ) { assertEquals ( HttpSC . CONFLICT _ _NUM _NUM _NUM , ex . getResponseCode ( ) ) ; } Check exists . checkExists ( dsTest ) ; deleteDataset ( dsTest ) ; } 
4421	private void bootstrapPrimarySequencerServer ( ) { try { Layout layout = serverContext . getManagementLayout ( ) ; boolean bootstrapResult = getCorfuRuntime ( ) . getLayoutView ( ) . getRuntimeLayout ( layout ) . getPrimarySequencerClient ( ) . bootstrap ( _NUM L , Collections . emptyMap ( ) , layout . getEpoch ( ) ) . get ( ) ; sequencerBootstrappedFuture . complete ( bootstrapResult ) ; If false , the sequencer is already bootstrapped with a higher epoch . if ( ! bootstrapResult ) { log . warn ( _STR , e ) ; } } 
4422	public void lockStructure ( ) { safeGetWorkbookProtection ( ) . setLockStructure ( true ) ; } 
4423	public static void moveItemInDatabase ( Context context , final ItemInfo item , final long container , final long screenId , final int cellX , final int cellY ) { item . container = container ; item . cellX = cellX ; item . cellY = cellY ; in the hotseat if ( context instanceof Launcher & & screenId < _NUM & & container = = LauncherSettings . Favorites . CONTAINER _ HOTSEAT ) { item . screenId = Launcher . getLauncher ( context ) . getHotseat ( ) . getOrderInHotseat ( cellX , cellY ) ; } else { item . screenId = screenId ; } final ContentValues values = new ContentValues ( ) ; values . put ( LauncherSettings . Favorites . CONTAINER , item . container ) ; values . put ( LauncherSettings . Favorites . CELLX , item . cellX ) ; values . put ( LauncherSettings . Favorites . CELLY , item . cellY ) ; values . put ( LauncherSettings . Favorites . RANK , item . rank ) ; values . put ( LauncherSettings . Favorites . SCREEN , item . screenId ) ; updateItemInDatabaseHelper ( context , values , item , _STR ) ; } 
4424	public static boolean isInteruppted ( ) { return Thread . currentThread ( ) . isInterrupted ( ) ; } 
4425	private void checkElement ( PDPageTree pageTree , COSBase base ) { if ( base instanceof COSArray ) { for ( COSBase base _NUM : ( COSArray ) base ) { if ( base _NUM instanceof COSObject ) { base _NUM = ( ( COSObject ) base _NUM ) . getObject ( ) ; } checkElement ( pageTree , base _NUM ) ; } } else if ( base instanceof COSDictionary ) { COSDictionary kdict = ( COSDictionary ) base ; if ( kdict . containsKey ( COSName . PG ) ) { PDStructureElement structureElement = new PDStructureElement ( kdict ) ; checkForPage ( pageTree , structureElement ) ; } if ( kdict . containsKey ( COSName . K ) ) { checkElement ( pageTree , kdict . getDictionaryObject ( COSName . K ) ) ; return ; } if we ' re in a number tree , check / Nums and / Kids if ( kdict . containsKey ( COSName . KIDS ) ) { checkElement ( pageTree , kdict . getDictionaryObject ( COSName . KIDS ) ) ; } else if ( kdict . containsKey ( COSName . NUMS ) ) { checkElement ( pageTree , kdict . getDictionaryObject ( COSName . NUMS ) ) ; } } } 
4426	public void setScrollPosition ( float focusX , float focusY ) { setZoom ( normalizedScale , focusX , focusY ) ; } 
4427	public static CharacteristicSetWritable read ( DataInput input ) throws IOException { CharacteristicSetWritable set = new CharacteristicSetWritable ( ) ; set . readFields ( input ) ; return set ; } 
4428	public static void main ( String [ ] args ) { String filename = null ; String cfsposfile = null ; boolean extract = false ; for ( int i = _NUM ; i < args . length ; + + i ) { if ( args [ i ] . equals ( _STR ) ; } } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; } finally { try { if ( dir ! = null ) dir . close ( ) ; if ( cfr ! = null ) cfr . close ( ) ; } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; } } } 
4429	public static Bitmap getBitmap ( final String imagePath , final int width , final int height ) { final Point size = getSize ( imagePath ) ; int currWidth = size . x ; int currHeight = size . y ; int scale = _NUM ; while ( currWidth > = width | | currHeight > = height ) { currWidth / = _NUM ; currHeight / = _NUM ; scale * = _NUM ; } return getBitmap ( imagePath , scale ) ; } 
4430	protected boolean addElem ( final T element ) { validate element if ( element = = null ) { throw new IllegalArgumentException ( _STR ) ; } find hashCode & index final int hashCode = element . hashCode ( ) ; final int index = getIndex ( hashCode ) ; return false if already present if ( getContainedElem ( index , element , hashCode ) ! = null ) { return false ; } modification + + ; size + + ; update bucket linked list DoubleLinkedElement < T > le = new DoubleLinkedElement < T > ( element , hashCode ) ; le . next = entries [ index ] ; entries [ index ] = le ; insert to the end of the all - element linked list le . after = null ; le . before = tail ; if ( tail ! = null ) { tail . after = le ; } tail = le ; if ( head = = null ) { head = le ; bookmark . next = head ; } Update bookmark , if necessary . if ( bookmark . next = = null ) { bookmark . next = le ; } return true ; } 
4431	public String globalInfo ( ) { return _STR + getTechnicalInformation ( ) . toString ( ) ; } 
4432	public boolean dropArgs ( String s ) { boolean dropped = false ; ArrayList < String > droppedArgs = new ArrayList < String > ( ) ; for ( int i = _NUM ; i < args . length ; i + + ) if ( args [ i ] ! = null & & args [ i ] . contains ( s ) ) { args [ i ] = null ; dropped = true ; droppedArgs . add ( _STR ) ; } if ( droppedArgs . size ( ) > _NUM ) { remember dropped arguments String [ ] missing = new String [ droppedArgs . size ( ) + missingArgs . length ] ; droppedArgs . toArray ( missing ) ; for ( int i = _NUM ; i < missingArgs . length ; i + + ) missing [ droppedArgs . size ( ) + i ] = missingArgs [ i ] ; missingArgs = missing ; set terms in remaining arguments setArgTerms ( argTerms ) ; } return dropped ; } 
4433	public synchronized float get ( ) { Progress node = this ; while ( node . getParent ( ) ! = null ) { find the root node = parent ; } return node . getInternal ( ) ; } 
4434	public void resetBytesReceivedPerSuperstep ( ) { delegate . resetBytesProcessedPerSuperstep ( ) ; } 
4435	private boolean isCurrentlyShowing ( List < MenuItem > menuItems ) { if ( mShowingMenuItems = = null | | menuItems . size ( ) ! = mShowingMenuItems . size ( ) ) { return false ; } final int size = menuItems . size ( ) ; for ( int i = _NUM ; i < size ; i + + ) { final MenuItem menuItem = menuItems . get ( i ) ; final MenuItem showingItem = mShowingMenuItems . get ( i ) ; if ( menuItem . getItemId ( ) ! = showingItem . getItemId ( ) | | ! TextUtils . equals ( menuItem . getTitle ( ) , showingItem . getTitle ( ) ) | | ! Objects . equals ( menuItem . getIcon ( ) , showingItem . getIcon ( ) ) | | menuItem . getGroupId ( ) ! = showingItem . getGroupId ( ) ) { return false ; } } return true ; } 
4436	public synchronized void releaseSlotFor ( LocalAssignment assignment , int port ) throws IOException { PortAndAssignment pna = new PortAndAssignment ( port , assignment ) ; final String topologyId = assignment . get _ topology _ id ( ) ; LOG . debug ( _STR , topologyId , port ) ; String topoJarKey = ConfigUtils . masterStormJarKey ( topologyId ) ; String topoCodeKey = ConfigUtils . masterStormCodeKey ( topologyId ) ; String topoConfKey = ConfigUtils . masterStormConfKey ( topologyId ) ; LocallyCachedBlob topoJar = topologyBlobs . get ( topoJarKey ) ; if ( topoJar ! = null ) { topoJar . removeReference ( pna ) ; } LocallyCachedBlob topoCode = topologyBlobs . get ( topoCodeKey ) ; if ( topoCode ! = null ) { topoCode . removeReference ( pna ) ; } LocallyCachedBlob topoConfBlob = topologyBlobs . get ( topoConfKey ) ; if ( topoConfBlob ! = null ) { topoConfBlob . removeReference ( pna ) ; } for ( LocalResource lr : getLocalResources ( pna ) ) { try { removeBlobReference ( lr . getBlobName ( ) , pna , lr . shouldUncompress ( ) ) ; } catch ( Exception e ) { throw new IOException ( e ) ; } } } 
4437	private int request ( String encoded ) throws IOException { refreshSignature ( ) ; HttpPost httpPost = new HttpPost ( targetURI ) ; httpPost . setHeader ( _STR ) ; StringEntity entity = new StringEntity ( encoded ) ; httpPost . setEntity ( entity ) ; HttpResponse response = httpclient . execute ( httpPost ) ; StatusLine status = response . getStatusLine ( ) ; HttpEntity entity _NUM = response . getEntity ( ) ; do something useful with the response body and ensure it is fully consumed EntityUtils . consume ( entity _NUM ) ; int returnCode = status . getStatusCode ( ) ; if ( returnCode ! = HttpStatus . SC _ CREATED ) { LOG . error ( new IOException ( status . getReasonPhrase ( ) ) . toString ( ) ) ; throw new IOException ( status . getReasonPhrase ( ) ) ; } return returnCode ; } 
4438	private CityResource getResource ( String resourceId , String units , Set < String > propertyIds ) throws IOException { CityResource resource = new CityResource ( ) ; resource . setId ( resourceId ) ; resource . setUnits ( units ) ; if ( isWeatherRequested ( propertyIds ) ) { resource . setWeather ( getWeatherProperty ( resourceId , units ) ) ; } return resource ; } 
4439	protected int insertKey ( double val ) { int hash , index ; hash = HashFunctions . hash ( val ) & _NUM x _NUM fffffff ; index = hash % _ states . length ; byte state = _ states [ index ] ; consumeFreeSlot = false ; if ( state = = FREE ) { consumeFreeSlot = true ; insertKeyAt ( index , val ) ; empty , all done return index ; } if ( state = = FULL & & _ set [ index ] = = val ) { already stored return - index - _NUM ; } already FULL or REMOVED , must probe return insertKeyRehash ( val , index , hash , state ) ; } 
4440	public void plotTrainingData ( ) throws Exception { m _ boundaryPanel . initialize ( ) ; setUpBoundaryPanel ( ) ; computeBounds ( ) ; m _ boundaryPanel . plotTrainingData ( ) ; } 
4441	public void close ( ) throws IOException { flush ( ) ; } 
4442	public String getFormattedMessage ( final String [ ] formats ) { return asString ( getFormat ( formats ) , null ) ; } 
4443	private void runLayoutReconfiguration ( Layout currentLayout , Layout newLayout , final boolean forceSequencerRecovery ) throws OutrankedException { Seals the incremented epoch ( Assumes newLayout epoch = currentLayout epoch + _NUM ) . sealEpoch ( currentLayout ) ; attemptConsensus ( newLayout ) ; TODO : Since sequencer reset is moved after paxos . Make sure the runtime has the latest TODO : layout view and latest client router epoch . ( Use quorum layout fetch . ) TODO : Handle condition if primary sequencer is not marked ready , reset fails . Reconfigure servers if required Primary sequencer would be in a not - ready state if its in recovery mode . reconfigureSequencerServers ( currentLayout , newLayout , forceSequencerRecovery ) ; } 
4444	public void reseed ( byte [ ] additionalInput ) { _NUM . seed _ material = _NUM x _NUM _NUM | | V | | entropy _ input | | additional _ input . _NUM . seed = Hash _ df ( seed _ material , seedlen ) . _NUM . V = seed . _NUM . C = Hash _ df ( ( _NUM x _NUM _NUM | | V ) , seedlen ) . _NUM . reseed _ counter = _NUM . _NUM . Return V , C , and reseed _ counter for the new _ working _ state . Comment : Precede with a byte of all zeros . byte [ ] entropy = getEntropy ( ) ; byte [ ] seedMaterial = Arrays . concatenate ( ONE , _ V , entropy , additionalInput ) ; byte [ ] seed = Utils . hash _ df ( _ digest , seedMaterial , _ seedLength ) ; _ V = seed ; byte [ ] subV = new byte [ _ V . length + _NUM ] ; subV [ _NUM ] = _NUM x _NUM _NUM ; System . arraycopy ( _ V , _NUM , subV , _NUM , _ V . length ) ; _ C = Utils . hash _ df ( _ digest , subV , _ seedLength ) ; _ reseedCounter = _NUM ; } 
4445	public void setClipRaw ( Path path ) { System . out . println ( _STR coordinates . this . tmppath . set ( path ) ; this . tmppath . transform ( getInverseTransform ( ) ) ; canvas . clipPath ( this . tmppath , Region . Op . REPLACE ) ; } else { canvas . clipPath ( path , Region . Op . REPLACE ) ; } } 
4446	public void loadUrl ( String url ) { checkThread ( ) ; mProvider . loadUrl ( url ) ; } 
4447	public Style getMonthViewSelectedStyle ( ) { return mv . getSelectedStyle ( ) ; } 
4448	protected Object convertPoint ( Column column , Field fieldDefn , Object data ) { if ( data = = null ) { data = fieldDefn . schema ( ) . defaultValue ( ) ; } Schema schema = fieldDefn . schema ( ) ; if ( data = = null ) { if ( column . isOptional ( ) ) return null ; return handleUnknownData ( column , fieldDefn , data ) ; } if ( data instanceof PGpoint ) { PGpoint pgPoint = ( PGpoint ) data ; return Point . createValue ( schema , pgPoint . x , pgPoint . y ) ; } if ( data instanceof String ) { String dataString = data . toString ( ) ; try { PGpoint pgPoint = new PGpoint ( dataString ) ; return Point . createValue ( schema , pgPoint . x , pgPoint . y ) ; } catch ( SQLException e ) { logger . warn ( _STR , dataString , column ) ; } } if ( data instanceof PgProto . Point ) { return Point . createValue ( schema , ( ( PgProto . Point ) data ) . getX ( ) , ( ( PgProto . Point ) data ) . getY ( ) ) ; } return handleUnknownData ( column , fieldDefn , data ) ; } 
4449	public < T > T getAndRemoveParameter ( Map < String , Object > parameters , String key , Class < T > type , T defaultValue ) { Object value = parameters . remove ( key ) ; if ( value = = null ) { value = defaultValue ; } if ( value = = null ) { return null ; } return CamelContextHelper . convertTo ( getCamelContext ( ) , type , value ) ; } 
4450	public void setSubtitles ( List subtitles ) { if ( subtitles = = null ) { throw new NullPointerException ( _STR ) ; } setNotify ( false ) ; clearSubtitles ( ) ; Iterator iterator = subtitles . iterator ( ) ; while ( iterator . hasNext ( ) ) { Title t = ( Title ) iterator . next ( ) ; if ( t ! = null ) { addSubtitle ( t ) ; } } this fires a ChartChangeEvent setNotify ( true ) ; } 
4451	HSSFSimpleShape createComboBox ( HSSFAnchor anchor ) { HSSFCombobox shape = new HSSFCombobox ( null , anchor ) ; addShape ( shape ) ; onCreate ( shape ) ; return shape ; } 
4452	Send the block data compressed using the given Huffman treesvoid compress _ block ( short [ ] ltree , short [ ] dtree ) { distance of matched string int dist ; match length or unmatched char ( if dist = = _NUM ) int lc ; running index in l _ buf int lx = _NUM ; the code to send int code ; number of extra bits to send int extra ; if ( last _ lit ! = _NUM ) { do { dist = ( ( pending _ buf [ d _ buf + lx * _NUM ] < < _NUM ) & _NUM xff _NUM _NUM ) | ( pending _ buf [ d _ buf + lx * _NUM + _NUM ] & _NUM xff ) ; lc = ( pending _ buf [ l _ buf + lx ] ) & _NUM xff ; lx + + ; if ( dist = = _NUM ) { send a literal byte send _ code ( lc , ltree ) ; } else { Here , lc is the match length - MIN _ MATCH code = Tree . _ length _ code [ lc ] ; send the length send _ code ( code + LITERALS + _NUM , ltree ) ; code extra = Tree . extra _ lbits [ code ] ; if ( extra ! = _NUM ) { lc - = Tree . base _ length [ code ] ; send the extra length bits send _ bits ( lc , extra ) ; } dist is now the match distance - _NUM dist - - ; code = Tree . d _ code ( dist ) ; send the distance code send _ code ( code , dtree ) ; extra = Tree . extra _ dbits [ code ] ; if ( extra ! = _NUM ) { dist - = Tree . base _ dist [ code ] ; send the extra distance bits send _ bits ( dist , extra ) ; } } literal or match pair ? Check that the overlay between pending _ buf and d _ buf + l _ buf is ok : } while ( lx < last _ lit ) ; } send _ code ( END _ BLOCK , ltree ) ; last _ eob _ len = ltree [ END _ BLOCK * _NUM + _NUM ] ; } 
4453	public static Pair < RegionInfo , ServerName > getRegion ( Connection connection , byte [ ] regionName ) throws IOException { HRegionLocation location = getRegionLocation ( connection , regionName ) ; return location = = null ? null : new Pair < > ( location . getRegionInfo ( ) , location . getServerName ( ) ) ; } 
4454	int getNumberOfBlocksToBeInvalidated ( ) { synchronized ( invalidateBlocks ) { return invalidateBlocks . size ( ) ; } } 
4455	public void format ( Writer w , ResultSet resultSet ) { PrintWriter pw = new PrintWriter ( w ) ; write ( pw , resultSet ) ; pw . flush ( ) ; } 
4456	public double getDomainUpperBound ( boolean includeInterval ) { double result = Double . NaN ; Range r = getDomainBounds ( includeInterval ) ; if ( r ! = null ) { result = r . getUpperBound ( ) ; } return result ; } 
4457	protected void setSlideShow ( HSLFSlideShow ss ) { if ( _ slideShow ! = null ) { throw new HSLFException ( _STR ) ; } _ slideShow = ss ; List < List < HSLFTextParagraph > > trs = getTextParagraphs ( ) ; if ( trs = = null ) { return ; } for ( List < HSLFTextParagraph > ltp : trs ) { HSLFTextParagraph . supplySheet ( ltp , this ) ; HSLFTextParagraph . applyHyperlinks ( ltp ) ; } } 
4458	public Typeface build ( ) { if ( mFd ! = null ) { Builder is created with file descriptor . try ( FileInputStream fis = new FileInputStream ( mFd ) ) { FileChannel channel = fis . getChannel ( ) ; long size = channel . size ( ) ; ByteBuffer buffer = channel . map ( FileChannel . MapMode . READ _ ONLY , _NUM , size ) ; final FontFamily fontFamily = new FontFamily ( ) ; if ( ! fontFamily . addFontFromBuffer ( buffer , mTtcIndex , mAxes , mWeight , mItalic ) ) { fontFamily . abortCreation ( ) ; return resolveFallbackTypeface ( ) ; } if ( ! fontFamily . freeze ( ) ) { return resolveFallbackTypeface ( ) ; } FontFamily [ ] families = { fontFamily } ; return createFromFamiliesWithDefault ( families , mWeight , mItalic ) ; } catch ( IOException e ) { return resolveFallbackTypeface ( ) ; } } else if ( mAssetManager ! = null ) { Builder is created with asset manager . final String key = createAssetUid ( mAssetManager , mPath , mTtcIndex , mAxes , mWeight , mItalic ) ; synchronized ( sLock ) { Typeface typeface = sDynamicTypefaceCache . get ( key ) ; if ( typeface ! = null ) return typeface ; final FontFamily fontFamily = new FontFamily ( ) ; if ( ! fontFamily . addFontFromAssetManager ( mAssetManager , mPath , mTtcIndex , true , mTtcIndex , mWeight , mItalic , mAxes ) ) { fontFamily . abortCreation ( ) ; return resolveFallbackTypeface ( ) ; } if ( ! fontFamily . freeze ( ) ) { return resolveFallbackTypeface ( ) ; } FontFamily [ ] families = { fontFamily } ; typeface = createFromFamiliesWithDefault ( families , mWeight , mItalic ) ; sDynamicTypefaceCache . put ( key , typeface ) ; return typeface ; } } else if ( mPath ! = null ) { Builder is created with file path . final FontFamily fontFamily = new FontFamily ( ) ; if ( ! fontFamily . addFont ( mPath , mTtcIndex , mAxes , mWeight , mItalic ) ) { fontFamily . abortCreation ( ) ; return resolveFallbackTypeface ( ) ; } if ( ! fontFamily . freeze ( ) ) { return resolveFallbackTypeface ( ) ; } FontFamily [ ] families = { fontFamily } ; return createFromFamiliesWithDefault ( families , mWeight , mItalic ) ; } else if ( mFonts ! = null ) { final FontFamily fontFamily = new FontFamily ( ) ; boolean atLeastOneFont = false ; for ( FontsContract . FontInfo font : mFonts ) { final ByteBuffer fontBuffer = mFontBuffers . get ( font . getUri ( ) ) ; if ( fontBuffer = = null ) { skip continue ; } final boolean success = fontFamily . addFontFromBuffer ( fontBuffer , font . getTtcIndex ( ) , font . getAxes ( ) , font . getWeight ( ) , font . isItalic ( ) ? STYLE _ ITALIC : STYLE _ NORMAL ) ; if ( ! success ) { fontFamily . abortCreation ( ) ; return null ; } atLeastOneFont = true ; } if ( ! atLeastOneFont ) { No fonts are avaialble . No need to create new Typeface and returns fallback Typeface instead . fontFamily . abortCreation ( ) ; return null ; } fontFamily . freeze ( ) ; FontFamily [ ] families = { fontFamily } ; return createFromFamiliesWithDefault ( families , mWeight , mItalic ) ; } Must not reach here . throw new IllegalArgumentException ( _STR ) ; } 
4459	public void find ( final Test test , final String . . . packageNames ) { if ( packageNames = = null ) { return ; } for ( final String pkg : packageNames ) { findInPackage ( test , pkg ) ; } } 
4460	public void setParameter ( Property parameter , Object value ) { if ( parameter . equals ( ReasonerVocabulary . PROPderivationLogging ) ) { recordDerivations = Util . convertBooleanPredicateArg ( parameter , value ) ; } else if ( parameter . equals ( ReasonerVocabulary . PROPtraceOn ) ) { traceOn = Util . convertBooleanPredicateArg ( parameter , value ) ; } else { throw new IllegalParameterException ( _STR ) ; } } 
4461	public Builder setPreparedStatementHandle ( org . apache . drill . exec . proto . UserProtos . PreparedStatementHandle . Builder builderForValue ) { if ( preparedStatementHandleBuilder _ = = null ) { preparedStatementHandle _ = builderForValue . build ( ) ; onChanged ( ) ; } else { preparedStatementHandleBuilder _ . setMessage ( builderForValue . build ( ) ) ; } bitField _NUM _ | = _NUM x _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM ; return this ; } 
4462	public boolean isMatrix ( ) { int rank = rank ( ) ; return ( rank = = _NUM & & ( size ( _NUM ) ! = _NUM & & size ( _NUM ) ! = _NUM ) ) ; } 
4463	public Collection getTimePeriods ( ) { Collection result = new java . util . ArrayList ( ) ; for ( int i = _NUM ; i < getItemCount ( ) ; i + + ) { result . add ( getTimePeriod ( i ) ) ; } return result ; } 
4464	public XSSFColor getThemeColor ( int idx ) { Theme color references are NOT positional indices into the color scheme , i . e . these keys are NOT the same as the order in which theme colors appear in theme _NUM . xml . They are keys to a mapped color . CTColorScheme colorScheme = theme . getTheme ( ) . getThemeElements ( ) . getClrScheme ( ) ; CTColor ctColor ; switch ( ThemeElement . byId ( idx ) ) { case LT _NUM : ctColor = colorScheme . getLt _NUM ( ) ; break ; case DK _NUM : ctColor = colorScheme . getDk _NUM ( ) ; break ; case LT _NUM : ctColor = colorScheme . getLt _NUM ( ) ; break ; case DK _NUM : ctColor = colorScheme . getDk _NUM ( ) ; break ; case ACCENT _NUM : ctColor = colorScheme . getAccent _NUM ( ) ; break ; case ACCENT _NUM : ctColor = colorScheme . getAccent _NUM ( ) ; break ; case ACCENT _NUM : ctColor = colorScheme . getAccent _NUM ( ) ; break ; case ACCENT _NUM : ctColor = colorScheme . getAccent _NUM ( ) ; break ; case ACCENT _NUM : ctColor = colorScheme . getAccent _NUM ( ) ; break ; case ACCENT _NUM : ctColor = colorScheme . getAccent _NUM ( ) ; break ; case HLINK : ctColor = colorScheme . getHlink ( ) ; break ; case FOLHLINK : ctColor = colorScheme . getFolHlink ( ) ; break ; default : return null ; } byte [ ] rgb = null ; if ( ctColor . isSetSrgbClr ( ) ) { Color is a regular one rgb = ctColor . getSrgbClr ( ) . getVal ( ) ; } else if ( ctColor . isSetSysClr ( ) ) { Color is a tint of white or black rgb = ctColor . getSysClr ( ) . getLastClr ( ) ; } else { return null ; } return new XSSFColor ( rgb , colorMap ) ; } 
4465	public SendQueue < T > sendQueueWithAutoFlush ( PeriodicScheduler periodicScheduler , int interval , TimeUnit timeUnit ) { final SendQueue < String > sendQueue = queue . sendQueueWithAutoFlush ( periodicScheduler , interval , timeUnit ) ; return createJsonSendQueue ( sendQueue ) ; } 
4466	public TokenRenewerResponse renewToken ( TokenRenewerParameters tokenParameters ) { TokenRenewerResponse response = new TokenRenewerResponse ( ) ; ReceivedToken tokenToRenew = tokenParameters . getToken ( ) ; if ( tokenToRenew = = null | | tokenToRenew . getToken ( ) = = null | | ( tokenToRenew . getState ( ) ! = STATE . EXPIRED & & tokenToRenew . getState ( ) ! = STATE . VALID ) ) { LOG . log ( Level . WARNING , _STR , ex , STSException . REQUEST _ FAILED ) ; } } 
4467	public void testRaceBetweenReplicaRecoveryAndFinalizeBlock ( ) throws Exception { Stop the Mocked DN started in startup ( ) tearDown ( ) ; Configuration conf = new HdfsConfiguration ( ) ; conf . set ( DFSConfigKeys . DFS _ DATANODE _ XCEIVER _ STOP _ TIMEOUT _ MILLIS _ KEY , _STR , recoveryInitResult . get ( ) ) ; dataNode . updateReplicaUnderRecovery ( block . getBlock ( ) , block . getBlock ( ) . getGenerationStamp ( ) + _NUM , block . getBlock ( ) . getBlockId ( ) , block . getBlockSize ( ) ) ; } finally { if ( null ! = cluster ) { cluster . shutdown ( ) ; cluster = null ; } } } 
4468	public boolean contains ( long val ) { return index ( val ) > = _NUM ; } 
4469	public < V extends Comparable < ? super V > > OptionalLong minBy ( LongFunction < V > keyExtractor ) { ObjLongBox < V > result = collect ( ( ) - > new ObjLongBox < > ( null , _NUM ) , ( box , i ) - > { V val = Objects . requireNonNull ( keyExtractor . apply ( i ) ) ; if ( box . a = = null | | box . a . compareTo ( val ) > _NUM ) { box . a = val ; box . b = i ; } } , ( box _NUM , box _NUM ) - > { if ( box _NUM . a ! = null & & ( box _NUM . a = = null | | box _NUM . a . compareTo ( box _NUM . a ) > _NUM ) ) { box _NUM . a = box _NUM . a ; box _NUM . b = box _NUM . b ; } } ) ; return result . a = = null ? OptionalLong . empty ( ) : OptionalLong . of ( result . b ) ; } 
4470	public static String toHex ( long value ) { StringBuilder sb = new StringBuilder ( _NUM _NUM ) ; writeHex ( sb , value , _NUM _NUM , _STR ) ; return sb . toString ( ) ; } 
4471	private void runDismissAnimation ( ) { mDismissAnimation . start ( ) ; } 
4472	private void updateStats ( StatsContext statsContext ) { if ( mRecorder = = null ) { First run ; establish baseline stats resetRecorder ( ) ; recordSample ( statsContext ) ; return ; } recordSample ( statsContext ) ; if ( checkStats ( ) ) { resetRecorder ( ) ; callCallback ( NetworkStatsManager . CALLBACK _ LIMIT _ REACHED ) ; } } 
4473	public String globalInfo ( ) { return _STR + getTechnicalInformation ( ) . toString ( ) ; } 
4474	static void verifyCacheContainsPrefetchedPositions ( RecyclerView view , Integer . . . positions ) { verifyCacheContainsPositions ( view , positions ) ; for ( Integer position : positions ) { assertTrue ( view . mPrefetchRegistry . lastPrefetchIncludedPosition ( position ) ) ; } assertEquals ( positions . length , view . mRecycler . mCachedViews . size ( ) ) ; } 
4475	private Map < String , Object > toMapRepresentationImpl ( String excludeFlag ) { HashMap < String , Object > m = new HashMap < String , Object > ( ) ; for ( PropertyBase p : this ) { if ( p . getClientProperty ( excludeFlag ) ! = null ) { continue ; } if ( p instanceof MapProperty ) { MapProperty pp = ( MapProperty ) p ; m . put ( p . getName ( ) , pp . asExplodedMap ( ) ) ; continue ; } if ( p instanceof ListProperty ) { ListProperty pp = ( ListProperty ) p ; m . put ( p . getName ( ) , pp . asExplodedList ( ) ) ; continue ; } if ( p instanceof Property ) { Property pp = ( Property ) p ; if ( pp . get ( ) ! = null ) { m . put ( p . getName ( ) , pp . get ( ) ) ; } } } return m ; } 
4476	public synchronized void clearAnnotations ( ) { mStringXY . clear ( ) ; } 
4477	Object toRow ( Elements rowElements , int [ ] projection ) { initialize ( ) ; final Object [ ] objects = new Object [ projection . length ] ; for ( int i = _NUM ; i < projection . length ; i + + ) { int field = projection [ i ] ; objects [ i ] = this . fields . get ( field ) . convert ( rowElements ) ; } return objects ; } 
4478	public void deleteLogEntries ( CmsDbContext dbc , CmsLogFilter filter ) throws CmsException { updateLog ( dbc ) ; m _ projectDriver . deleteLog ( dbc , filter ) ; } 
4479	public ImportInstanceRequest withDiskImages ( DiskImage . . . diskImages ) { if ( getDiskImages ( ) = = null ) setDiskImages ( new java . util . ArrayList < DiskImage > ( diskImages . length ) ) ; for ( DiskImage value : diskImages ) { getDiskImages ( ) . add ( value ) ; } return this ; } 
4480	public void setListening ( Object listener , boolean listening ) { if ( listening ) { if ( mListeners . add ( listener ) & & mListeners . size ( ) = = _NUM ) { if ( DEBUG ) Log . d ( TAG , _STR + false ) ; mHandler . obtainMessage ( H . SET _ LISTENING , _NUM , _NUM ) . sendToTarget ( ) ; } } } 
4481	public File createTmpFileForWrite ( String pathStr , long size , Configuration conf ) throws IOException { find an appropriate directory Path path = getLocalPathForWrite ( pathStr , size , conf , true ) ; File dir = new File ( path . getParent ( ) . toUri ( ) . getPath ( ) ) ; String prefix = path . getName ( ) ; create a temp file on this directory File result = File . createTempFile ( prefix , null , dir ) ; result . deleteOnExit ( ) ; return result ; } 
4482	public static String formatDateTime ( Context context , long millis , int flags ) { return formatDateRange ( context , millis , millis , flags ) ; } 
4483	private boolean scrollAndFocus ( int directionY , int top , int bottom , int directionX , int left , int right ) { boolean handled = true ; int height = getHeight ( ) ; int containerTop = getScrollY ( ) ; int containerBottom = containerTop + height ; boolean up = directionY = = View . FOCUS _ UP ; int width = getWidth ( ) ; int containerLeft = getScrollX ( ) ; int containerRight = containerLeft + width ; boolean leftwards = directionX = = View . FOCUS _ UP ; View newFocused = findFocusableViewInBounds ( up , top , bottom , leftwards , left , right ) ; if ( newFocused = = null ) { newFocused = this ; } if ( ( top > = containerTop & & bottom < = containerBottom ) | | ( left > = containerLeft & & right < = containerRight ) ) { handled = false ; } else { int deltaY = up ? ( top - containerTop ) : ( bottom - containerBottom ) ; int deltaX = leftwards ? ( left - containerLeft ) : ( right - containerRight ) ; doScroll ( deltaX , deltaY ) ; } if ( newFocused ! = findFocus ( ) & & newFocused . requestFocus ( directionY ) ) { mTwoDScrollViewMovedFocus = true ; mTwoDScrollViewMovedFocus = false ; } return handled ; } 
4484	public FluentInitializer init ( Date minDate , Date maxDate , Locale locale ) { if ( minDate = = null | | maxDate = = null ) { throw new IllegalArgumentException ( _STR + month ) ; months . add ( month ) ; monthCounter . add ( MONTH , _NUM ) ; } validateAndUpdate ( ) ; return new FluentInitializer ( ) ; } 
4485	public static void verifySnapshot ( final Configuration conf , final FileSystem fs , final SnapshotManifest manifest ) throws IOException { final SnapshotDescription snapshotDesc = manifest . getSnapshotDescription ( ) ; final Path snapshotDir = manifest . getSnapshotDir ( ) ; concurrentVisitReferencedFiles ( conf , fs , manifest , _STR , new StoreFileVisitor ( ) { @ Override public void storeFile ( final RegionInfo regionInfo , final String family , final SnapshotRegionManifest . StoreFile storeFile ) throws IOException { verifyStoreFile ( conf , fs , snapshotDir , snapshotDesc , regionInfo , family , storeFile ) ; } } ) ; } 
4486	public void render ( Class < ? extends SubView > cls ) { int saved = context ( ) . nestLevel ; getInstance ( cls ) . renderPartial ( ) ; if ( context ( ) . nestLevel ! = saved ) { throw new WebAppException ( _STR ) ; } } 
4487	 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - long freeSpaceOS ( final String path , final int os , final boolean kb , final long timeout ) throws IOException { if ( path = = null ) { throw new IllegalArgumentException ( _STR ) ; } } 
4488	public StaticWord _NUM Vec build ( ) { StaticWord _NUM Vec word _NUM Vec = new StaticWord _NUM Vec ( ) ; word _NUM Vec . cachePerDevice = this . cachePerDevice ; word _NUM Vec . storage = this . storage ; word _NUM Vec . vocabCache = this . vocabCache ; word _NUM Vec . init ( ) ; return word _NUM Vec ; } 
4489	public void start ( ) { Preconditions . checkState ( state . compareAndSet ( State . LATENT , State . STARTED ) , _STR ) ; client . getConnectionStateListenable ( ) . addListener ( listener ) ; requeue ( ) ; } 
4490	public void onContentChanged ( ) { if ( mStarted ) { forceLoad ( ) ; } else { This loader has been stopped , so we don ' t want to load new data right now . . . but keep track of it changing to refresh later if we start again . mContentChanged = true ; } } 
4491	private void selectWord ( MouseEvent e ) { if ( selectedWordEvent ! = null & & selectedWordEvent . getX ( ) = = e . getX ( ) & & selectedWordEvent . getY ( ) = = e . getY ( ) ) { We ' ve already the done selection for this . return ; } Action a = null ; RTextArea textArea = getTextArea ( ) ; ActionMap map = textArea . getActionMap ( ) ; if ( map ! = null ) { a = map . get ( RTextAreaEditorKit . selectWordAction ) ; } if ( a = = null ) { if ( selectWord = = null ) { selectWord = new RTextAreaEditorKit . SelectWordAction ( ) ; } a = selectWord ; } a . actionPerformed ( new ActionEvent ( textArea , ActionEvent . ACTION _ PERFORMED , null , e . getWhen ( ) , e . getModifiers ( ) ) ) ; selectedWordEvent = e ; } 
4492	public static boolean isSameLength ( final char [ ] array _NUM , final char [ ] array _NUM ) { return getLength ( array _NUM ) = = getLength ( array _NUM ) ; } 
4493	public V computeIfPresent ( K key , BiFunction < ? super K , ? super V , ? extends V > remappingFunction ) { Objects . requireNonNull ( remappingFunction ) ; V oldValue ; if ( ( oldValue = get ( key ) ) ! = null ) { V newValue = remappingFunction . apply ( key , oldValue ) ; if ( newValue ! = null ) { put ( key , newValue ) ; return newValue ; } else { remove ( key ) ; return null ; } } else { return null ; } } 
4494	private synchronized long trimToFit ( ) throws IOException { Expunge aged items ( including tombstones marking deleted data ) . int ageSeconds = Settings . Global . getInt ( mContentResolver , Settings . Global . DROPBOX _ AGE _ SECONDS , DEFAULT _ AGE _ SECONDS ) ; mMaxFiles = Settings . Global . getInt ( mContentResolver , Settings . Global . DROPBOX _ MAX _ FILES , ( ActivityManager . isLowRamDeviceStatic ( ) ? DEFAULT _ MAX _ FILES _ LOWRAM : DEFAULT _ MAX _ FILES ) ) ; long cutoffMillis = System . currentTimeMillis ( ) - ageSeconds * _NUM _NUM _NUM _NUM ; while ( ! mAllFiles . contents . isEmpty ( ) ) { EntryFile entry = mAllFiles . contents . first ( ) ; if ( entry . timestampMillis > cutoffMillis & & mAllFiles . contents . size ( ) < mMaxFiles ) { break ; } FileList tag = mFilesByTag . get ( entry . tag ) ; if ( tag ! = null & & tag . contents . remove ( entry ) ) tag . blocks - = entry . blocks ; if ( mAllFiles . contents . remove ( entry ) ) mAllFiles . blocks - = entry . blocks ; entry . deleteFile ( mDropBoxDir ) ; } Compute overall quota ( a fraction of available free space ) in blocks . The quota changes dynamically based on the amount of free space ; that way when lots of data is available we can use it , but we ' ll get out of the way if storage starts getting tight . long uptimeMillis = SystemClock . uptimeMillis ( ) ; if ( uptimeMillis > mCachedQuotaUptimeMillis + QUOTA _ RESCAN _ MILLIS ) { int quotaPercent = Settings . Global . getInt ( mContentResolver , Settings . Global . DROPBOX _ QUOTA _ PERCENT , DEFAULT _ QUOTA _ PERCENT ) ; int reservePercent = Settings . Global . getInt ( mContentResolver , Settings . Global . DROPBOX _ RESERVE _ PERCENT , DEFAULT _ RESERVE _ PERCENT ) ; int quotaKb = Settings . Global . getInt ( mContentResolver , Settings . Global . DROPBOX _ QUOTA _ KB , DEFAULT _ QUOTA _ KB ) ; String dirPath = mDropBoxDir . getPath ( ) ; try { mStatFs . restat ( dirPath ) ; } catch ( IllegalArgumentException e ) { restat throws this on error throw new IOException ( _STR , e ) ; } } } } return mCachedQuotaBlocks * mBlockSize ; } 
4495	protected Map < String , String > removeTabSuffixes ( Map < String , String > fieldValues ) { Map < String , String > result = new HashMap < String , String > ( ) ; for ( Map . Entry < String , String > entry : fieldValues . entrySet ( ) ) { String key = entry . getKey ( ) ; String newKey = removeTabSuffix ( key ) ; result . put ( newKey , entry . getValue ( ) ) ; } return result ; } 
4496	public void testSubQueryLimitOne ( ) { final String sql = _STR ; sql ( sql ) . ok ( ) ; } 
4497	private < M extends HttpMethod > int exec ( M method ) throws IOException { final HttpClient client = new HttpClient ( ) ; if ( proxyHost ! = null ) { client . getParams ( ) . setParameter ( ConnRoutePNames . DEFAULT _ PROXY , new HttpHost ( proxyHost , proxyPort ) ) ; } int statusCode = execWithDebugOutput ( method , client ) ; if ( ( statusCode = = HttpStatus . SC _ UNAUTHORIZED | | statusCode = = HttpStatus . SC _ BAD _ REQUEST ) & & method instanceof AuthPostMethod & & ! useKeystoneAuthentication ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( _STR ) ; } statusCode = execWithDebugOutput ( method , client ) ; } return statusCode ; } 
4498	public Builder clearProperties ( ) { if ( propertiesBuilder _ = = null ) { properties _ = org . apache . drill . exec . proto . UserProtos . UserProperties . getDefaultInstance ( ) ; onChanged ( ) ; } else { propertiesBuilder _ . clear ( ) ; } bitField _NUM _ = ( bitField _NUM _ & ~ _NUM x _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM ) ; return this ; } 
4499	public Schedule getSchedule ( final int projectId , final String flowId ) throws ScheduleManagerException { updateLocal ( ) ; return this . scheduleIdentityPairMap . get ( new Pair < > ( projectId , flowId ) ) ; } 
4500	public Leadership run ( Commit < ? extends Run > commit ) { try { String topic = commit . value ( ) . topic ( ) ; Leadership < byte [ ] > oldLeadership = leadership ( topic ) ; Registration registration = new Registration ( commit . value ( ) . id ( ) , commit . session ( ) . sessionId ( ) . id ( ) ) ; elections . compute ( topic , ( k , v ) - > { if ( v = = null ) { return new ElectionState ( registration , termCounter ( topic ) : : incrementAndGet , elections ) ; } else { if ( ! v . isDuplicate ( registration ) ) { return new ElectionState ( v ) . addRegistration ( topic , registration , termCounter ( topic ) : : incrementAndGet ) ; } else { return v ; } } } ) ; Leadership < byte [ ] > newLeadership = leadership ( topic ) ; if ( ! Objects . equal ( oldLeadership , newLeadership ) ) { notifyLeadershipChange ( topic , oldLeadership , newLeadership ) ; } return newLeadership ; } catch ( Exception e ) { getLogger ( ) . error ( _STR , e ) ; throw Throwables . propagate ( e ) ; } } 
4501	public static XmlNegativeInteger parse ( org . w _NUM c . dom . Node node ) throws org . apache . xmlbeans . XmlException { return ( XmlNegativeInteger ) XmlBeans . getContextTypeLoader ( ) . parse ( node , type , null ) ; } 
4502	boolean delete ( String src , boolean recursive , boolean logRetryCache ) throws IOException { waitForLoadingFSImage ( ) ; BlocksMapUpdateInfo toRemovedBlocks = null ; writeLock ( ) ; boolean ret = false ; try { checkOperation ( OperationCategory . WRITE ) ; checkNameNodeSafeMode ( _STR , src ) ; return ret ; } 
4503	public HttpRequest parse ( final ANode request , final Value bodies ) throws QueryException { final HttpRequest hr = new HttpRequest ( ) ; if ( request ! = null ) { for ( final ANode attr : request . attributes ( ) ) { final String key = string ( attr . name ( ) ) ; final Request r = Request . get ( key ) ; if ( r = = null ) throw HC _ REQ _ X . get ( info , _STR + body . qname ( ) ) ; } } } return hr ; } 
4504	To byte array for couponsstatic final byte [ ] toCouponByteArray ( final AbstractCoupons impl , final boolean dstCompact ) { final int srcCouponCount = impl . getCouponCount ( ) ; final int srcLgCouponArrInts = impl . getLgCouponArrInts ( ) ; final int srcCouponArrInts = _NUM < < srcLgCouponArrInts ; final byte [ ] byteArrOut ; final boolean list = impl . getCurMode ( ) = = CurMode . LIST ; prepare switch final int sw = ( impl . isMemory ( ) ? _NUM : _NUM ) | ( impl . isCompact ( ) ? _NUM : _NUM ) | ( dstCompact ? _NUM : _NUM ) ; switch ( sw ) { case _NUM : { Src Memory , Src Compact , Dst Compact final Memory srcMem = impl . getMemory ( ) ; final int bytesOut = impl . getMemDataStart ( ) + ( srcCouponCount < < _NUM ) ; byteArrOut = new byte [ bytesOut ] ; srcMem . getByteArray ( _NUM , byteArrOut , _NUM , bytesOut ) ; break ; } case _NUM : { Src Memory , Src Compact , Dst Updatable final int dataStart = impl . getMemDataStart ( ) ; final int bytesOut = dataStart + ( srcCouponArrInts < < _NUM ) ; byteArrOut = new byte [ bytesOut ] ; final WritableMemory memOut = WritableMemory . wrap ( byteArrOut ) ; final Object memObj = memOut . getArray ( ) ; final long memAdd = memOut . getCumulativeOffset ( _NUM L ) ; copyCommonListAndSet ( impl , memObj , memAdd ) ; insertCompactFlag ( memObj , memAdd , dstCompact ) ; final int [ ] tgtCouponIntArr = new int [ srcCouponArrInts ] ; final PairIterator itr = impl . getIterator ( ) ; while ( itr . nextValid ( ) ) { final int pair = itr . getPair ( ) ; final int idx = find ( tgtCouponIntArr , srcLgCouponArrInts , pair ) ; if ( idx < _NUM ) { found EMPTY insert tgtCouponIntArr [ ~ idx ] = pair ; continue ; } throw new SketchesStateException ( _STR + sw ) ; } return byteArrOut ; } 
4505	public String [ ] getHttpAuthUsernamePassword ( String host , String realm ) { checkThread ( ) ; return mProvider . getHttpAuthUsernamePassword ( host , realm ) ; } 
4506	public static boolean disjoint ( Collection < ? > c _NUM , Collection < ? > c _NUM ) { if ( ( c _NUM instanceof Set ) & & ! ( c _NUM instanceof Set ) | | ( c _NUM . size ( ) ) > c _NUM . size ( ) ) { Collection < ? > tmp = c _NUM ; c _NUM = c _NUM ; c _NUM = tmp ; } Iterator < ? > it = c _NUM . iterator ( ) ; while ( it . hasNext ( ) ) { if ( c _NUM . contains ( it . next ( ) ) ) { return false ; } } return true ; } 
4507	public void save ( ) { if ( ! editing ) return ; FieldGroup fieldGroup = getFieldGroup ( ) ; List < Validatable > components = new ArrayList < > ( ) ; for ( Component component : fieldGroup . getComponents ( ) ) { if ( component instanceof Validatable ) { components . add ( ( Validatable ) component ) ; } } if ( ! validate ( components ) ) { return ; } getDsContext ( ) . commit ( ) ; ListComponent table = getTable ( ) ; CollectionDatasource browseDs = table . getDatasource ( ) ; Entity editedItem = fieldGroup . getDatasource ( ) . getItem ( ) ; if ( creating ) { browseDs . includeItem ( editedItem ) ; } else { browseDs . updateItem ( editedItem ) ; } table . setSelected ( editedItem ) ; releaseLock ( ) ; disableEditControls ( ) ; } 
4508	void nativeFillShape ( Shape shape ) { if ( shape . getClass ( ) = = GeneralPath . class ) { GeneralPath gives us some easy access to the points GeneralPath p = ( GeneralPath ) shape ; int commandsLen = p . getTypesSize ( ) ; int pointsLen = p . getPointsSize ( ) ; byte [ ] commandsArr = getTmpNativeDrawShape _ commands ( commandsLen ) ; float [ ] pointsArr = getTmpNativeDrawShape _ coords ( pointsLen ) ; p . getTypes ( commandsArr ) ; p . getPoints ( pointsArr ) ; nativeInstance . nativeFillShapeMutable ( color , alpha , commandsLen , commandsArr , pointsLen , pointsArr ) ; } else { Log . p ( _STR ) ; } } 
4509	 @ Overridefinal BPTreePage split ( ) { Median record : will go in parent . int ix = params . SplitIndex ; New block . BPTreeNode z = create ( this . parent , isLeaf ) ; Leave the low end untouched and copy , and clear the high end . z becomes the new upper node , not the lower node . ' this ' is the lower block . int maxRec = maxRecords ( ) ; Copy from top of y into z . records . copy ( ix + _NUM , z . records , _NUM , maxRec - ( ix + _NUM ) ) ; Clear copied and median slot records . clear ( ix , maxRec - ix ) ; Reset size records . setSize ( ix ) ; ptrs . copy ( ix + _NUM , z . ptrs , _NUM , params . MaxPtr - ( ix + _NUM ) ) ; ptrs . clear ( ix + _NUM , params . MaxPtr - ( ix + _NUM ) ) ; ptrs . setSize ( ix + _NUM ) ; Set sizes of subnodes Median is ix setCount ( ix ) ; y finished internalCheckNode ( ) ; z . isLeaf = isLeaf ; Number copied into z z . setCount ( maxRec - ( ix + _NUM ) ) ; Caller puts the blocks in split ( int , BTreePage ) z . internalCheckNode ( ) ; return z ; } 
4510	protected boolean matchPattern ( CamelContext camelContext , String uri , String pattern ) { match using the pattern as - is boolean match = EndpointHelper . matchEndpoint ( camelContext , uri , pattern ) ; if ( ! match ) { try { the pattern could be an uri , so we need to normalize it before matching again pattern = URISupport . normalizeUri ( pattern ) ; match = EndpointHelper . matchEndpoint ( camelContext , uri , pattern ) ; } catch ( Exception e ) { ignore } } return match ; } 
4511	public static double calculateNgramMLProbability ( StringList ngram , Iterable < StringList > set ) { StringList ngramMinusOne = getNMinusOneTokenFirst ( ngram ) ; return count ( ngram , set ) / count ( ngramMinusOne , set ) ; } 
4512	public long getHiSyncId ( BluetoothDevice device ) { if ( VDBG ) { log ( _STR + Log . getStackTraceString ( new Throwable ( ) ) ) ; return HI _ SYNC _ ID _ INVALID ; } finally { mServiceLock . readLock ( ) . unlock ( ) ; } } 
4513	public CACertsResponse getCACerts ( ) throws Exception { ESTResponse resp = null ; Exception finalThrowable = null ; CACertsResponse caCertsResponse = null ; URL url = null ; boolean failedBeforeClose = false ; try { url = new URL ( server + CACERTS ) ; ESTClient client = clientProvider . makeClient ( ) ; ESTRequest req = new ESTRequestBuilder ( _STR + url . toString ( ) , finalThrowable , resp . getStatusCode ( ) , null ) ; } return caCertsResponse ; } 
4514	public void requestsToAddAndRemoveContainers ( ) throws Exception { Lock lock = mockLock ( true ) ; SchedulerStateManagerAdaptor mockStateMgr = mockStateManager ( testTopology , this . currentProtoPlan , lock ) ; IScalable mockScheduler = mock ( IScalable . class ) ; HashSet < PackingPlan . ContainerPlan > mockRetrunSet = new HashSet < > ( ) ; mockRetrunSet . add ( new PackingPlan . ContainerPlan ( _NUM , new HashSet < > ( ) , new Resource ( _NUM , ByteAmount . ZERO , ByteAmount . ZERO ) ) ) ; mockRetrunSet . add ( new PackingPlan . ContainerPlan ( _NUM , new HashSet < > ( ) , new Resource ( _NUM , ByteAmount . ZERO , ByteAmount . ZERO ) ) ) ; when ( mockScheduler . addContainers ( any ( ) ) ) . thenReturn ( mockRetrunSet ) ; UpdateTopologyManager spyUpdateManager = spyUpdateManager ( mockStateMgr , mockScheduler , testTopology ) ; PowerMockito . spy ( TMasterUtils . class ) ; PowerMockito . doNothing ( ) . when ( TMasterUtils . class , _STR , eq ( TOPOLOGY _ NAME ) , eq ( TMasterUtils . TMasterCommand . ACTIVATE ) , eq ( mockStateMgr ) , eq ( TopologyAPI . TopologyState . PAUSED ) , eq ( TopologyAPI . TopologyState . RUNNING ) , any ( NetworkUtils . TunnelConfig . class ) ) ; spyUpdateManager . updateTopology ( currentProtoPlan , proposedProtoPlan ) ; verify ( spyUpdateManager ) . deactivateTopology ( eq ( mockStateMgr ) , eq ( testTopology ) , eq ( proposedPacking ) ) ; verify ( spyUpdateManager ) . reactivateTopology ( eq ( mockStateMgr ) , eq ( testTopology ) , eq ( _NUM ) ) ; verify ( mockScheduler ) . addContainers ( expectedContainersToAdd ) ; verify ( mockScheduler ) . removeContainers ( expectedContainersToRemove ) ; verify ( lock ) . tryLock ( any ( Long . class ) , any ( TimeUnit . class ) ) ; verify ( lock ) . unlock ( ) ; PowerMockito . verifyStatic ( times ( _NUM ) ) ; TMasterUtils . transitionTopologyState ( eq ( TOPOLOGY _ NAME ) , eq ( TMasterUtils . TMasterCommand . DEACTIVATE ) , eq ( mockStateMgr ) , eq ( TopologyAPI . TopologyState . RUNNING ) , eq ( TopologyAPI . TopologyState . PAUSED ) , any ( NetworkUtils . TunnelConfig . class ) ) ; PowerMockito . verifyStatic ( times ( _NUM ) ) ; TMasterUtils . transitionTopologyState ( eq ( TOPOLOGY _ NAME ) , eq ( TMasterUtils . TMasterCommand . ACTIVATE ) , eq ( mockStateMgr ) , eq ( TopologyAPI . TopologyState . PAUSED ) , eq ( TopologyAPI . TopologyState . RUNNING ) , any ( NetworkUtils . TunnelConfig . class ) ) ; } 
4515	private void updateMappings ( final JSONObject configJson ) { HashMap < String , String > newProperties = new HashMap < String , String > ( ) ; if ( configJson ! = null ) { Iterator < ? > keys = configJson . keys ( ) ; while ( keys . hasNext ( ) ) { String key = ( String ) keys . next ( ) ; try { String value = configJson . getString ( key ) ; newProperties . put ( key , value ) ; } catch ( JSONException e ) { Do not log property mappings due to potential sensitive information . log . error ( _STR ) ; } } } put all new properties in our map properties . putAll ( newProperties ) ; } 
4516	public CompactSketch < S > getResult ( ) { sketch _ . trim ( ) ; if ( theta _ < sketch _ . theta _ ) { sketch _ . setThetaLong ( theta _ ) ; sketch _ . rebuild ( ) ; } return sketch _ . compact ( ) ; } 
4517	private void startAsset ( final String path , long size , long crc _NUM _NUM ) throws IOException { putNextEntry ( outputStream , path , size , crc _NUM _NUM ) ; } 
4518	public String getFrameTitle ( ) { if ( getCurrentFilename ( ) . equals ( _STR + getCurrentFilename ( ) ; } 
4519	private void parseURI ( StreamRDF destination ) { Source by uri or path . try ( TypedInputStream input = openTypedInputStream ( uri , path ) ) { ReaderRIOT reader ; ContentType ct ; if ( forceLang ! = null ) { @ SuppressWarnings ( _STR + ct . getContentType ( ) ) ; } read ( reader , input , null , baseUri , context , ct , destination ) ; } } 
4520	public final < T extends View > T findViewByPredicateInsideOut ( View start , Predicate < View > predicate ) { View childToSkip = null ; for ( ; ; ) { T view = start . findViewByPredicateTraversal ( predicate , childToSkip ) ; if ( view ! = null | | start = = this ) { return view ; } ViewParent parent = start . getParent ( ) ; if ( parent = = null | | ! ( parent instanceof View ) ) { return null ; } childToSkip = start ; start = ( View ) parent ; } } 
4521	void parameters ( Object . . . objects ) { for ( Object object : objects ) parameter ( object ) ; } 
4522	protected void serviceInit ( Configuration config ) throws Exception { Clone the configuration as we may do modifications to dirs - list Configuration conf = new Configuration ( config ) ; diskHealthCheckInterval = conf . getLong ( YarnConfiguration . NM _ DISK _ HEALTH _ CHECK _ INTERVAL _ MS , YarnConfiguration . DEFAULT _ NM _ DISK _ HEALTH _ CHECK _ INTERVAL _ MS ) ; monitoringTimerTask = new MonitoringTimerTask ( conf ) ; isDiskHealthCheckerEnabled = conf . getBoolean ( YarnConfiguration . NM _ DISK _ HEALTH _ CHECK _ ENABLE , true ) ; minNeededHealthyDisksFactor = conf . getFloat ( YarnConfiguration . NM _ MIN _ HEALTHY _ DISKS _ FRACTION , YarnConfiguration . DEFAULT _ NM _ MIN _ HEALTHY _ DISKS _ FRACTION ) ; lastDisksCheckTime = System . currentTimeMillis ( ) ; super . serviceInit ( conf ) ; FileContext localFs ; try { localFs = FileContext . getLocalFSFileContext ( config ) ; } catch ( IOException e ) { throw new YarnRuntimeException ( _STR , e ) ; } FsPermission perm = new FsPermission ( ( short ) _NUM _NUM _NUM _NUM ) ; boolean createSucceeded = localDirs . createNonExistentDirs ( localFs , perm ) ; createSucceeded & = logDirs . createNonExistentDirs ( localFs , perm ) ; if ( ! createSucceeded ) { updateDirsAfterTest ( ) ; } Check the disk health immediately to weed out bad directories before other init code attempts to use them . checkDirs ( ) ; } 
4523	private static Pair < UUID , Integer > beginAndRepairPaxos ( long queryStartNanoTime , DecoratedKey key , TableMetadata metadata , List < InetAddressAndPort > liveEndpoints , int requiredParticipants , ConsistencyLevel consistencyForPaxos , ConsistencyLevel consistencyForCommit , final boolean isWrite , ClientState state ) throws WriteTimeoutException , WriteFailureException { long timeout = TimeUnit . MILLISECONDS . toNanos ( DatabaseDescriptor . getCasContentionTimeout ( ) ) ; PrepareCallback summary = null ; int contentions = _NUM ; while ( System . nanoTime ( ) - queryStartNanoTime < timeout ) { We want a timestamp that is guaranteed to be unique for that node ( so that the ballot is globally unique ) , but if we ' ve got a prepare rejected already we also want to make sure we pick a timestamp that has a chance to be promised , i . e . one that is greater that the most recently known in progress ( # _NUM _NUM _NUM _NUM ) . Lastly , we don ' t want to use a timestamp that is older than the last one assigned by ClientState or operations may appear out - of - order ( # _NUM _NUM _NUM _NUM ) . long minTimestampMicrosToUse = summary = = null ? Long . MIN _ VALUE : _NUM + UUIDGen . microsTimestamp ( summary . mostRecentInProgressCommit . ballot ) ; long ballotMicros = state . getTimestampForPaxos ( minTimestampMicrosToUse ) ; Note that ballotMicros is not guaranteed to be unique if two proposal are being handled concurrently by the same coordinator . But we still need ballots to be unique for each proposal so we have to use getRandomTimeUUIDFromMicros . UUID ballot = UUIDGen . getRandomTimeUUIDFromMicros ( ballotMicros ) ; prepare Tracing . trace ( _STR ) ; sendCommit ( mostRecent , missingMRC ) ; latter ticket , we can pass CL . ALL to the commit above and remove the ' continue ' . continue ; } return Pair . create ( ballot , contentions ) ; } recordCasContention ( contentions ) ; throw new WriteTimeoutException ( WriteType . CAS , consistencyForPaxos , _NUM , consistencyForPaxos . blockFor ( Keyspace . open ( metadata . keyspace ) ) ) ; } 
4524	public int [ ] getRules ( int layoutDirection ) { resolveLayoutDirection ( layoutDirection ) ; return mRules ; } 
4525	public static String dumpMetrics ( ) throws MalformedObjectNameException , IOException { Guess this size StringWriter sw = new StringWriter ( _NUM _NUM _NUM _NUM * _NUM _NUM _NUM ) ; try ( PrintWriter writer = new PrintWriter ( sw ) ) { JSONBean dumper = new JSONBean ( ) ; try ( JSONBean . Writer jsonBeanWriter = dumper . open ( writer ) ) { MBeanServer mbeanServer = ManagementFactory . getPlatformMBeanServer ( ) ; jsonBeanWriter . write ( mbeanServer , new ObjectName ( _STR ) , null , false ) ; } } sw . close ( ) ; return sw . toString ( ) ; } 
4526	protected synchronized void completedContainer ( RMContainer rmContainer , ContainerStatus containerStatus , RMContainerEventType event ) { if ( rmContainer = = null ) { LOG . info ( _STR + event ) ; } 
4527	protected void writeValidValues ( XMLStreamWriter xmlStreamWriter , PropertyDescriptor property ) throws XMLStreamException { if ( property . getAllowableValues ( ) ! = null & & property . getAllowableValues ( ) . size ( ) > _NUM ) { xmlStreamWriter . writeStartElement ( _STR ) ; } } } 
4528	public void testBindByAddress ( ) throws Exception { String bindAddress = null ; Enumeration < NetworkInterface > intfs = NetworkInterface . getNetworkInterfaces ( ) ; if we have a loopback and it has an address use it while ( intfs . hasMoreElements ( ) ) { NetworkInterface i = intfs . nextElement ( ) ; try { if ( i . isLoopback ( ) ) { Enumeration < InetAddress > addrs = i . getInetAddresses ( ) ; while ( addrs . hasMoreElements ( ) ) { InetAddress a = addrs . nextElement ( ) ; if ( a . isLoopbackAddress ( ) ) { bindAddress = a . getHostAddress ( ) ; break ; } } } } catch ( SocketException se ) { LOG . warn ( _STR , ClientBase . waitForServerDown ( HOSTPORT , CONNECTION _ TIMEOUT ) ) ; } } 
4529	public void setNamespaceMap ( Map < String , String > namespaceMap ) { checkNamespaceMap ( namespaceMap ) ; this . namespaceMap = namespaceMap ; } 
4530	private static String getValue ( JSONTokener x ) throws JSONException { char c ; char q ; StringBuffer sb ; do { c = x . next ( ) ; } while ( c = = ' ' | | c = = ' \ t ' ) ; switch ( c ) { case _NUM : return null ; case ' _STR ; default : x . back ( ) ; return x . nextTo ( ' , ' ) ; } } 
4531	public long getAcquisitionEndTime ( ) { ensureData ( ) ; return mAcquisitionEndTime ; } 
4532	public void setSectionOutlineStroke ( int section , Stroke stroke ) { Comparable key = getSectionKey ( section ) ; setSectionOutlineStroke ( key , stroke ) ; } 
4533	public void groupEventsByDatabase ( DatabaseEventConsumer consumer ) { if ( isEmpty ( ) ) return ; if ( databaseNames . size ( ) < = _NUM ) { consumer . consume ( databaseNames . iterator ( ) . next ( ) , events ) ; return ; } List < Event > dbEvents = new ArrayList < > ( ) ; String currentDatabase = null ; for ( Event event : events ) { String dbName = getDatabase ( event ) ; if ( currentDatabase = = null | | dbName . equals ( currentDatabase ) ) { currentDatabase = dbName ; Accumulate the statement . . . dbEvents . add ( event ) ; } else { Submit the statements . . . consumer . consume ( currentDatabase , dbEvents ) ; } } } 
4534	public void checkLoginAllowed ( ) throws CmsAuthentificationException { if ( ( m _ loginMessage ! = null ) & & ( m _ loginMessage . isLoginCurrentlyForbidden ( ) ) ) { login message has been set and is active throw new CmsAuthentificationException ( Messages . get ( ) . container ( Messages . ERR _ LOGIN _ FAILED _ WITH _ MESSAGE _ _NUM , m _ loginMessage . getMessage ( ) ) ) ; } } 
4535	private String getRandInstructionMR ( int inputIndex , int outputIndex ) { sanity checks if ( getInputs ( ) . size ( ) ! = DataExpression . RAND _ VALID _ PARAM _ NAMES . length ) { throw new LopsException ( printErrorLocation ( ) + _STR : iLop . prepScalarLabel ( ) ) ; return sb . toString ( ) ; } 
4536	public void setSeriesPaint ( Paint paint ) { this . seriesPaint = paint ; fireChangeEvent ( ) ; } 
4537	protected synchronized void updateMergeThreads ( ) { Only look at threads that are alive & not in the process of stopping ( ie have an active merge ) : final List < MergeThread > activeMerges = new ArrayList < MergeThread > ( ) ; int threadIdx = _NUM ; while ( threadIdx < mergeThreads . size ( ) ) { final MergeThread mergeThread = mergeThreads . get ( threadIdx ) ; if ( ! mergeThread . isAlive ( ) ) { Prune any dead threads mergeThreads . remove ( threadIdx ) ; continue ; } if ( mergeThread . getCurrentMerge ( ) ! = null ) { activeMerges . add ( mergeThread ) ; } threadIdx + + ; } Sort the merge threads in descending order . CollectionUtil . mergeSort ( activeMerges , compareByMergeDocCount ) ; int pri = mergeThreadPriority ; final int activeMergeCount = activeMerges . size ( ) ; for ( threadIdx = _NUM ; threadIdx < activeMergeCount ; threadIdx + + ) { final MergeThread mergeThread = activeMerges . get ( threadIdx ) ; final MergePolicy . OneMerge merge = mergeThread . getCurrentMerge ( ) ; if ( merge = = null ) { continue ; } pause the thread if maxThreadCount is smaller than the number of merge threads . final boolean doPause = threadIdx < activeMergeCount - maxThreadCount ; if ( verbose ( ) ) { if ( doPause ! = merge . getPause ( ) ) { if ( doPause ) { message ( _STR + pri ) ; } mergeThread . setThreadPriority ( pri ) ; pri = Math . min ( Thread . MAX _ PRIORITY , _NUM + pri ) ; } } } 
4538	public static String quoteName ( String name ) { StringBuilder sb = new StringBuilder ( ) ; int len = name . length ( ) ; for ( int i = _NUM ; i < len ; i + + ) { char c = name . charAt ( i ) ; if ( c = = ' \ \ ' | | c = = ' " ' ) { sb . append ( ' \ \ ' ) ; } sb . append ( c ) ; } return sb . toString ( ) ; } 
4539	byte [ ] hashed ( byte [ ] val , Integer . . . depths ) { ArrayDeque < Integer > dstack = new ArrayDeque < Integer > ( ) ; ArrayDeque < byte [ ] > hstack = new ArrayDeque < byte [ ] > ( ) ; Iterator < Integer > depthiter = Arrays . asList ( depths ) . iterator ( ) ; if ( depthiter . hasNext ( ) ) { dstack . push ( depthiter . next ( ) ) ; hstack . push ( val ) ; } while ( depthiter . hasNext ( ) ) { Integer depth = depthiter . next ( ) ; byte [ ] hash = val ; while ( depth . equals ( dstack . peek ( ) ) ) { consume the stack hash = Hashable . binaryHash ( hstack . pop ( ) , hash ) ; depth = dstack . pop ( ) - _NUM ; } dstack . push ( depth ) ; hstack . push ( hash ) ; } assert hstack . size ( ) = = _NUM ; return hstack . pop ( ) ; } 
4540	public Builder clearError ( ) { if ( errorBuilder _ = = null ) { error _ = org . apache . drill . exec . proto . UserBitShared . DrillPBError . getDefaultInstance ( ) ; onChanged ( ) ; } else { errorBuilder _ . clear ( ) ; } bitField _NUM _ = ( bitField _NUM _ & ~ _NUM x _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM ) ; return this ; } 
4541	public void testMerge _NUM ( ) { ConcurrentMap map = map _NUM ( ) ; assertEquals ( _STR ) ) ; } 
4542	internal method to make sure mCreated is set properly without requiringusers to call through to super in onCreatevoid dispatchOnCreate ( Bundle savedInstanceState ) { if ( ! mCreated ) { onCreate ( savedInstanceState ) ; mCreated = true ; } } 
4543	public void getMax ( RpcController controller , AggregateRequest request , RpcCallback < AggregateResponse > done ) { InternalScanner scanner = null ; AggregateResponse response = null ; T max = null ; try { ColumnInterpreter < T , S , P , Q , R > ci = constructColumnInterpreterFromRequest ( request ) ; T temp ; Scan scan = ProtobufUtil . toScan ( request . getScan ( ) ) ; scanner = env . getRegion ( ) . getScanner ( scan ) ; List < Cell > results = new ArrayList < > ( ) ; byte [ ] colFamily = scan . getFamilies ( ) [ _NUM ] ; NavigableSet < byte [ ] > qualifiers = scan . getFamilyMap ( ) . get ( colFamily ) ; byte [ ] qualifier = null ; if ( qualifiers ! = null & & ! qualifiers . isEmpty ( ) ) { qualifier = qualifiers . pollFirst ( ) ; } qualifier can be null . boolean hasMoreRows = false ; do { hasMoreRows = scanner . next ( results ) ; int listSize = results . size ( ) ; for ( int i = _NUM ; i < listSize ; i + + ) { temp = ci . getValue ( colFamily , qualifier , results . get ( i ) ) ; max = ( max = = null | | ( temp ! = null & & ci . compare ( temp , max ) > _NUM ) ) ? temp : max ; } results . clear ( ) ; } while ( hasMoreRows ) ; if ( max ! = null ) { AggregateResponse . Builder builder = AggregateResponse . newBuilder ( ) ; builder . addFirstPart ( ci . getProtoForCellType ( max ) . toByteString ( ) ) ; response = builder . build ( ) ; } } catch ( IOException e ) { CoprocessorRpcUtils . setControllerException ( controller , e ) ; } finally { if ( scanner ! = null ) { try { scanner . close ( ) ; } catch ( IOException ignored ) { } } } log . info ( _STR + max ) ; done . run ( response ) ; } 
4544	public final int next ( ) { final int p = pos ; if ( p < size ) { pos + = cl ( token , p ) ; return cp ( token , p ) ; } return - _NUM ; } 
4545	public static void scanFile ( Context context , String [ ] paths , String [ ] mimeTypes , OnScanCompletedListener callback ) { ClientProxy client = new ClientProxy ( paths , mimeTypes , callback ) ; MediaScannerConnection connection = new MediaScannerConnection ( context , client ) ; client . mConnection = connection ; connection . connect ( ) ; } 
4546	public static XmlAnySimpleType parse ( javax . xml . stream . XMLStreamReader xsr ) throws org . apache . xmlbeans . XmlException { return ( XmlAnySimpleType ) XmlBeans . getContextTypeLoader ( ) . parse ( xsr , type , null ) ; } 
4547	private void publishFileSet ( CopyEntity . DatasetAndPartition datasetAndPartition , Collection < WorkUnitState > datasetWorkUnitStates ) throws IOException { Map < String , String > additionalMetadata = Maps . newHashMap ( ) ; Preconditions . checkArgument ( ! datasetWorkUnitStates . isEmpty ( ) , _STR ) ) ; CopyEventSubmitterHelper . submitSuccessfulDatasetPublish ( this . eventSubmitter , datasetAndPartition , Long . toString ( datasetOriginTimestamp ) , Long . toString ( datasetUpstreamTimestamp ) , additionalMetadata ) ; } 
4548	public void setMinimumScaleX ( float xScale ) { if ( xScale < _NUM f ) xScale = _NUM f ; mMinScaleX = xScale ; limitTransAndScale ( mMatrixTouch , mContentRect ) ; } 
4549	public void testServiceRemovedEventForDefaultAlertGroup ( ) throws Exception { Class < ? extends AmbariEvent > eventClass = ServiceRemovedEvent . class ; Assert . assertFalse ( m _ listener . isAmbariEventReceived ( eventClass ) ) ; installHdfsService ( ) ; get the default group for HDFS AlertGroupEntity group = m _ alertDispatchDao . findGroupByName ( m _ cluster . getClusterId ( ) , _STR ) ; Assert . assertNull ( group ) ; } 
4550	public void setOnExpandedVisibleListener ( Runnable r ) { mExpandedVisibleListener = r ; fireExpandedVisibleListenerIfVisible ( ) ; } 
4551	public static GenericValue create ( ModelEntity modelEntity ) { GenericValue newValue = new GenericValue ( ) ; newValue . init ( modelEntity ) ; return newValue ; } 
4552	public static int toMilliOfDay ( Object value , TemporalAdjuster adjuster ) { LocalTime time = Conversions . toLocalTime ( value ) ; if ( adjuster ! = null ) { time = time . with ( adjuster ) ; } long micros = Math . floorDiv ( time . toNanoOfDay ( ) , Conversions . NANOSECONDS _ PER _ MILLISECOND ) ; assert Math . abs ( micros ) < Integer . MAX _ VALUE ; return ( int ) micros ; } 
4553	public static void uint _NUM _NUM ToByteStreamLE ( int val , OutputStream stream ) throws IOException { stream . write ( ( int ) ( _NUM xFF & val ) ) ; stream . write ( ( int ) ( _NUM xFF & ( val > > _NUM ) ) ) ; } 
4554	public int getProvisionedValue ( int item ) throws ImsException { return getConfigInt ( item ) ; } 
4555	public org . fife . ui . rsyntaxtextarea . Token yylex ( ) throws java . io . IOException { int zzInput ; int zzAction ; cached fields : int zzCurrentPosL ; int zzMarkedPosL ; int zzEndReadL = zzEndRead ; char [ ] zzBufferL = zzBuffer ; char [ ] zzCMapL = ZZ _ CMAP ; int [ ] zzTransL = ZZ _ TRANS ; int [ ] zzRowMapL = ZZ _ ROWMAP ; int [ ] zzAttrL = ZZ _ ATTRIBUTE ; while ( true ) { zzMarkedPosL = zzMarkedPos ; zzAction = - _NUM ; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL ; zzState = zzLexicalState ; zzForAction : { while ( true ) { if ( zzCurrentPosL < zzEndReadL ) zzInput = zzBufferL [ zzCurrentPosL + + ] ; else if ( zzAtEOF ) { zzInput = YYEOF ; break zzForAction ; } else { store back cached positions zzCurrentPos = zzCurrentPosL ; zzMarkedPos = zzMarkedPosL ; boolean eof = zzRefill ( ) ; get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos ; zzMarkedPosL = zzMarkedPos ; zzBufferL = zzBuffer ; zzEndReadL = zzEndRead ; if ( eof ) { zzInput = YYEOF ; break zzForAction ; } else { zzInput = zzBufferL [ zzCurrentPosL + + ] ; } } int zzNext = zzTransL [ zzRowMapL [ zzState ] + zzCMapL [ zzInput ] ] ; if ( zzNext = = - _NUM ) break zzForAction ; zzState = zzNext ; int zzAttributes = zzAttrL [ zzState ] ; if ( ( zzAttributes & _NUM ) = = _NUM ) { zzAction = zzState ; zzMarkedPosL = zzCurrentPosL ; if ( ( zzAttributes & _NUM ) = = _NUM ) break zzForAction ; } } } store back cached position zzMarkedPos = zzMarkedPosL ; switch ( zzAction < _NUM ? zzAction : ZZ _ ACTION [ zzAction ] ) { case _NUM _NUM : { int temp = zzStartRead ; addToken ( start , zzStartRead - _NUM , Token . COMMENT _ DOCUMENTATION ) ; addHyperlinkToken ( temp , zzMarkedPos - _NUM , Token . COMMENT _ DOCUMENTATION ) ; start = zzMarkedPos ; } case _NUM _NUM : break ; case _NUM _NUM : { addToken ( Token . PREPROCESSOR ) ; } case _NUM _NUM : break ; case _NUM : { addNullToken ( ) ; return firstToken ; } case _NUM _NUM : break ; case _NUM _NUM : { addToken ( Token . LITERAL _ CHAR ) ; } case _NUM _NUM : break ; case _NUM _NUM : { yybegin ( YYINITIAL ) ; addToken ( start , zzStartRead + _NUM , Token . COMMENT _ MULTILINE ) ; } case _NUM _NUM : break ; case _NUM : { addToken ( Token . WHITESPACE ) ; } case _NUM _NUM : break ; case _NUM _NUM : { addToken ( Token . LITERAL _ NUMBER _ HEXADECIMAL ) ; } case _NUM _NUM : break ; case _NUM _NUM : { addToken ( Token . ERROR _ CHAR ) ; } case _NUM _NUM : break ; case _NUM _NUM : { addToken ( Token . ERROR _ STRING _ DOUBLE ) ; } case _NUM _NUM : break ; case _NUM _NUM : { addToken ( Token . LITERAL _ NUMBER _ FLOAT ) ; } case _NUM _NUM : break ; case _NUM _NUM : { addToken ( Token . RESERVED _ WORD ) ; } case _NUM _NUM : break ; case _NUM _NUM : { addToken ( Token . SEPARATOR ) ; } case _NUM _NUM : break ; case _NUM _NUM : { addToken ( start , zzStartRead - _NUM , Token . COMMENT _ DOCUMENTATION ) ; addNullToken ( ) ; return firstToken ; } case _NUM _NUM : break ; case _NUM : { addToken ( Token . IDENTIFIER ) ; } case _NUM _NUM : break ; case _NUM _NUM : { int temp = zzStartRead ; addToken ( start , zzStartRead - _NUM , Token . COMMENT _ DOCUMENTATION ) ; addToken ( temp , zzEndRead , Token . PREPROCESSOR ) ; addNullToken ( ) ; return firstToken ; } case _NUM _NUM : break ; case _NUM : { addToken ( Token . ERROR _ CHAR ) ; addNullToken ( ) ; return firstToken ; } case _NUM _NUM : break ; case _NUM : { addToken ( Token . ERROR _ STRING _ DOUBLE ) ; addNullToken ( ) ; return firstToken ; } case _NUM _NUM : break ; case _NUM _NUM : { addToken ( Token . DATA _ TYPE ) ; } case _NUM _NUM : break ; case _NUM : { addToken ( Token . ERROR _ IDENTIFIER ) ; } case _NUM _NUM : break ; case _NUM _NUM : { addToken ( Token . ERROR _ CHAR ) ; } case _NUM _NUM : break ; case _NUM _NUM : { addToken ( Token . LITERAL _ BOOLEAN ) ; } case _NUM _NUM : break ; case _NUM _NUM : { start = zzMarkedPos - _NUM ; yybegin ( VERBATIMSTRING ) ; } case _NUM _NUM : break ; case _NUM _NUM : { addToken ( Token . LITERAL _ STRING _ DOUBLE _ QUOTE ) ; } case _NUM _NUM : break ; case _NUM _NUM : { addToken ( start , zzStartRead - _NUM , Token . LITERAL _ STRING _ DOUBLE _ QUOTE ) ; return firstToken ; } case _NUM _NUM : break ; case _NUM _NUM : { int temp = zzStartRead ; addToken ( start , zzStartRead - _NUM , Token . COMMENT _ MULTILINE ) ; addHyperlinkToken ( temp , zzMarkedPos - _NUM , Token . COMMENT _ MULTILINE ) ; start = zzMarkedPos ; } case _NUM _NUM : break ; case _NUM _NUM : { addToken ( Token . COMMENT _ EOL ) ; addNullToken ( ) ; return firstToken ; } case _NUM _NUM : break ; case _NUM _NUM : { addToken ( Token . ERROR _ NUMBER _ FORMAT ) ; } case _NUM _NUM : break ; case _NUM _NUM : { start = zzMarkedPos - _NUM ; yybegin ( DOCUMENTCOMMENT ) ; } case _NUM _NUM : break ; case _NUM _NUM : { start = zzMarkedPos - _NUM ; yybegin ( DELIMITEDCOMMENT ) ; } case _NUM _NUM : break ; case _NUM : { addToken ( Token . LITERAL _ NUMBER _ DECIMAL _ INT ) ; } case _NUM _NUM : break ; case _NUM : { addToken ( Token . OPERATOR ) ; } case _NUM _NUM : break ; case _NUM _NUM : { int temp = zzStartRead ; addToken ( start , zzStartRead - _NUM , Token . COMMENT _ DOCUMENTATION ) ; addToken ( temp , zzMarkedPos - _NUM , Token . PREPROCESSOR ) ; start = zzMarkedPos ; } case _NUM _NUM : break ; case _NUM _NUM : { yybegin ( YYINITIAL ) ; addToken ( start , zzStartRead , Token . LITERAL _ STRING _ DOUBLE _ QUOTE ) ; } case _NUM _NUM : break ; case _NUM : { } case _NUM _NUM : break ; case _NUM _NUM : { addToken ( start , zzStartRead - _NUM , Token . COMMENT _ MULTILINE ) ; return firstToken ; } case _NUM _NUM : break ; default : if ( zzInput = = YYEOF & & zzStartRead = = zzCurrentPos ) { zzAtEOF = true ; switch ( zzLexicalState ) { case VERBATIMSTRING : { addToken ( start , zzStartRead - _NUM , Token . LITERAL _ STRING _ DOUBLE _ QUOTE ) ; return firstToken ; } case _NUM _NUM _NUM : break ; case DOCUMENTCOMMENT : { addToken ( start , zzStartRead - _NUM , Token . COMMENT _ DOCUMENTATION ) ; addNullToken ( ) ; return firstToken ; } case _NUM _NUM _NUM : break ; case YYINITIAL : { addNullToken ( ) ; return firstToken ; } case _NUM _NUM _NUM : break ; case DELIMITEDCOMMENT : { addToken ( start , zzStartRead - _NUM , Token . COMMENT _ MULTILINE ) ; return firstToken ; } case _NUM _NUM _NUM : break ; default : return null ; } } else { zzScanError ( ZZ _ NO _ MATCH ) ; } } } } 
4556	public void reset ( ) { initialize ( ) ; } 
4557	public final E _ StrLength strlen ( Object expr ) { return new E _ StrLength ( asExpr ( expr ) ) ; } 
4558	public void centerViewTo ( float xIndex , float yValue , AxisDependency axis ) { float valsInView = getDeltaY ( axis ) / mViewPortHandler . getScaleY ( ) ; float xsInView = getXAxis ( ) . getValues ( ) . size ( ) / mViewPortHandler . getScaleX ( ) ; Runnable job = new MoveViewJob ( mViewPortHandler , xIndex - xsInView / _NUM f , yValue + valsInView / _NUM f , getTransformer ( axis ) , this ) ; addViewportJob ( job ) ; } 
4559	public void putMemory ( final WritableMemory dstMem , final ArrayOfItemsSerDe < T > serDe ) { final byte [ ] byteArr = toByteArray ( serDe ) ; final long memCap = dstMem . getCapacity ( ) ; if ( memCap < byteArr . length ) { throw new SketchesArgumentException ( _STR + byteArr . length ) ; } dstMem . putByteArray ( _NUM , byteArr , _NUM , byteArr . length ) ; } 
4560	public String getDialogWidget ( CmsObject cms , I _ CmsWidgetDialog widgetDialog , I _ CmsWidgetParameter param ) { String id = param . getId ( ) ; StringBuffer result = new StringBuffer ( _NUM _NUM _NUM ) ; result . append ( _STR ) ; return result . toString ( ) ; } 
4561	List < Line > getLines ( PDFont font , float fontSize , float width ) throws IOException { BreakIterator iterator = BreakIterator . getLineInstance ( ) ; iterator . setText ( textContent ) ; final float scale = fontSize / FONTSCALE ; int start = iterator . first ( ) ; int end = iterator . next ( ) ; float lineWidth = _NUM ; List < Line > textLines = new ArrayList < > ( ) ; Line textLine = new Line ( ) ; while ( end ! = BreakIterator . DONE ) { String word = textContent . substring ( start , end ) ; float wordWidth = font . getStringWidth ( word ) * scale ; lineWidth = lineWidth + wordWidth ; check if the last word would fit without the whitespace ending it if ( lineWidth > = width & & Character . isWhitespace ( word . charAt ( word . length ( ) - _NUM ) ) ) { float whitespaceWidth = font . getStringWidth ( word . substring ( word . length ( ) - _NUM ) ) * scale ; lineWidth = lineWidth - whitespaceWidth ; } if ( lineWidth > = width ) { textLine . setWidth ( textLine . calculateWidth ( font , fontSize ) ) ; textLines . add ( textLine ) ; textLine = new Line ( ) ; lineWidth = font . getStringWidth ( word ) * scale ; } AttributedString as = new AttributedString ( word ) ; as . addAttribute ( TextAttribute . WIDTH , wordWidth ) ; Word wordInstance = new Word ( word ) ; wordInstance . setAttributes ( as ) ; textLine . addWord ( wordInstance ) ; start = end ; end = iterator . next ( ) ; } textLine . setWidth ( textLine . calculateWidth ( font , fontSize ) ) ; textLines . add ( textLine ) ; return textLines ; } 
4562	private void visualizeResizeForDelta ( int deltaX , int deltaY , boolean onDismiss ) { updateDeltas ( deltaX , deltaY ) ; DragLayer . LayoutParams lp = ( DragLayer . LayoutParams ) getLayoutParams ( ) ; if ( mLeftBorderActive ) { lp . x = mBaselineX + mDeltaX ; lp . width = mBaselineWidth - mDeltaX ; } else if ( mRightBorderActive ) { lp . width = mBaselineWidth + mDeltaX ; } if ( mTopBorderActive ) { lp . y = mBaselineY + mDeltaY ; lp . height = mBaselineHeight - mDeltaY ; } else if ( mBottomBorderActive ) { lp . height = mBaselineHeight + mDeltaY ; } resizeWidgetIfNeeded ( onDismiss ) ; requestLayout ( ) ; } 
4563	public void assertIsInstanceOfAny ( Description description , Object actual , Class < ? > [ ] types ) { checkNotNullOrEmpty ( types ) ; assertNotNull ( description , actual ) ; if ( ! isInstanceOfAny ( actual , types ) ) { String format = _STR ; throw failures . failure ( description , new BasicErrorMessageFactory ( format , actual , types , actual . getClass ( ) ) ) ; } } 
4564	protected void deleteResource ( CmsDbContext dbc , CmsResource resource , CmsResource . CmsResourceDeleteMode siblingMode ) throws CmsException { if ( resource . isFolder ( ) ) { collect all resources in the folder ( but exclude deleted ones ) List < CmsResource > resources = m _ driverManager . readChildResources ( dbc , resource , CmsResourceFilter . IGNORE _ EXPIRATION , true , true , false ) ; Set < CmsUUID > deletedResources = new HashSet < CmsUUID > ( ) ; now walk through all sub - resources in the folder for ( int i = _NUM ; i < resources . size ( ) ; i + + ) { CmsResource childResource = resources . get ( i ) ; if ( ( siblingMode = = CmsResource . DELETE _ REMOVE _ SIBLINGS ) & & deletedResources . contains ( childResource . getResourceId ( ) ) ) { been deleted - do nothing and continue with the next child resource . continue ; } if ( childResource . isFolder ( ) ) { recurse into this method for subfolders deleteResource ( dbc , childResource , siblingMode ) ; } else { handle child resources m _ driverManager . deleteResource ( dbc , childResource , siblingMode ) ; } deletedResources . add ( childResource . getResourceId ( ) ) ; } deletedResources . clear ( ) ; } handle the resource itself m _ driverManager . deleteResource ( dbc , resource , siblingMode ) ; } 
4565	public TimelineDomains getDomains ( String owner , UserGroupInformation callerUGI ) throws YarnException , IOException { long startTime = Time . monotonicNow ( ) ; metrics . incrGetDomainsOps ( ) ; try { TimelineDomains domains = doGetDomains ( owner , callerUGI ) ; metrics . incrGetDomainsTotal ( domains . getDomains ( ) . size ( ) ) ; return domains ; } finally { metrics . addGetDomainsTime ( Time . monotonicNow ( ) - startTime ) ; } } 
4566	public boolean waitForActiveAndReadyMaster ( long timeout ) throws IOException { List < JVMClusterUtil . MasterThread > mts ; long start = System . currentTimeMillis ( ) ; while ( ! ( mts = getMasterThreads ( ) ) . isEmpty ( ) & & ( System . currentTimeMillis ( ) - start ) < timeout ) { for ( JVMClusterUtil . MasterThread mt : mts ) { if ( mt . getMaster ( ) . isActiveMaster ( ) & & mt . getMaster ( ) . isInitialized ( ) ) { return true ; } } Threads . sleep ( _NUM _NUM _NUM ) ; } return false ; } 
4567	public static Allocation createSized ( RenderScript rs , Element e , int count , int usage ) { try { Trace . traceBegin ( RenderScript . TRACE _ TAG , _STR ) ; } return new Allocation ( id , rs , t , true , usage , MipmapControl . MIPMAP _ NONE ) ; } finally { Trace . traceEnd ( RenderScript . TRACE _ TAG ) ; } } 
4568	public ComponentName getActivityComponent ( ) { ensureData ( ) ; return mActivityComponent ; } 
4569	public static com . google . gwt . dom . client . Element createIFrameElement ( String name ) { return getDOMImpl ( ) . createIFrameElement ( Document . get ( ) , name ) ; } 
4570	public int [ ] getAsIntegerArray ( final String path ) throws IllegalArgumentException { final List jarr = _ internalGetAsArray ( path ) ; final int [ ] arr = new int [ jarr = = null ? _NUM : jarr . size ( ) ] ; int alen = arr . length ; for ( int i = _NUM ; i < alen ; i + + ) { StructuredContent element = ( StructuredContent ) jarr . get ( i ) ; String s = ( String ) element . getText ( ) ; arr [ i ] = Integer . parseInt ( s ) ; } return arr ; } 
4571	protected void analyzeCreatorToolProperty ( PDDocumentInformation dico , XMPBasicSchema xmp , List < ValidationError > ve ) { String creatorTool = dico . getCreator ( ) ; if ( creatorTool ! = null ) { automatically strip trailing Nul values creatorTool = removeTrailingNul ( creatorTool ) ; if ( xmp ! = null ) { if ( xmp . getCreatorToolProperty ( ) = = null ) { ve . add ( absentXMPPropertyError ( _STR ) ) ; } } } 
4572	public void process ( Exchange exchange ) throws Exception { String dataBaseName = calculateDatabaseName ( exchange ) ; String retentionPolicy = calculateRetentionPolicy ( exchange ) ; switch ( endpoint . getOperation ( ) ) { case InfluxDbOperations . INSERT : doInsert ( exchange , dataBaseName , retentionPolicy ) ; break ; case InfluxDbOperations . QUERY : doQuery ( exchange , dataBaseName , retentionPolicy ) ; break ; default : throw new IllegalArgumentException ( _STR ) ; } } 
4573	public void removeNotify ( ) { if ( parserManager ! = null ) { parserManager . stopParsing ( ) ; } super . removeNotify ( ) ; } 
4574	public void capabilitiesFilterChanged ( CapabilitiesFilterChangeEvent e ) { if ( e . getFilter ( ) = = null ) updateCapabilitiesFilter ( null ) ; else updateCapabilitiesFilter ( ( Capabilities ) e . getFilter ( ) . clone ( ) ) ; } 
4575	private JBlock createInnerBlock ( BlockType type ) { final JBlock currBlock = getBlock ( type ) ; final JBlock innerBlock = new JBlock ( ) ; currBlock . add ( innerBlock ) ; return innerBlock ; } 
4576	private List < ByteBuffer > filter ( List < ByteBuffer > values , QueryOptions options ) throws InvalidRequestException { RangeSet < Token > rangeSet = tokenRestriction . hasSlice ( ) ? toRangeSet ( tokenRestriction , options ) : toRangeSet ( tokenRestriction . values ( options ) ) ; return filterWithRangeSet ( rangeSet , values ) ; } 
4577	public static ProgramStore BLEND _ ALPHA _ DEPTH _ NONE ( RenderScript rs ) { if ( rs . mProgramStore _ BLEND _ ALPHA _ DEPTH _ NO _ DEPTH = = null ) { ProgramStore . Builder builder = new ProgramStore . Builder ( rs ) ; builder . setDepthFunc ( ProgramStore . DepthFunc . ALWAYS ) ; builder . setBlendFunc ( BlendSrcFunc . SRC _ ALPHA , BlendDstFunc . ONE _ MINUS _ SRC _ ALPHA ) ; builder . setDitherEnabled ( false ) ; builder . setDepthMaskEnabled ( false ) ; rs . mProgramStore _ BLEND _ ALPHA _ DEPTH _ NO _ DEPTH = builder . create ( ) ; } return rs . mProgramStore _ BLEND _ ALPHA _ DEPTH _ NO _ DEPTH ; } 
4578	public static XmlNonNegativeInteger parse ( java . io . File f ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( XmlNonNegativeInteger ) XmlBeans . getContextTypeLoader ( ) . parse ( f , type , null ) ; } 
4579	public String [ ] getFieldParams ( String field , String param ) { String [ ] val = getParams ( fpname ( field , param ) ) ; return val ! = null ? val : getParams ( param ) ; } 
4580	public double getUpperBound ( final int numStdDev ) { if ( ! isEstimationMode ( ) ) { return getRetainedEntries ( ) ; } return BinomialBoundsN . getUpperBound ( getRetainedEntries ( ) , getTheta ( ) , numStdDev , isEmpty _ ) ; } 
4581	public static void moveDirectory ( final File srcDir , final File destDir ) throws IOException { validateMoveParameters ( srcDir , destDir ) ; if ( ! srcDir . isDirectory ( ) ) { throw new IOException ( _STR ) ; } } } 
4582	public boolean dismissPopupMenus ( ) { boolean result = hideOverflowMenu ( ) ; result | = hideSubMenus ( ) ; return result ; } 
4583	public void setURL ( String url ) throws IOException { m _ URL = url ; setSource ( new URL ( url ) ) ; } 
4584	private String doRawStream ( final BOMInputStream bom , final BOMInputStream pis , final boolean lenient ) throws IOException { final String bomEnc = bom . getBOMCharsetName ( ) ; final String xmlGuessEnc = pis . getBOMCharsetName ( ) ; final String xmlEnc = getXmlProlog ( pis , xmlGuessEnc ) ; try { return calculateRawEncoding ( bomEnc , xmlGuessEnc , xmlEnc ) ; } catch ( final XmlStreamReaderException ex ) { if ( lenient ) { return doLenientDetection ( null , ex ) ; } throw ex ; } } 
4585	private CognitoUserSession refreshSession ( CognitoUserSession currSession ) { CognitoUserSession cognitoUserSession = null ; final InitiateAuthRequest initiateAuthRequest = initiateRefreshTokenAuthRequest ( currSession ) ; final InitiateAuthResult refreshSessionResult = cognitoIdentityProviderClient . initiateAuth ( initiateAuthRequest ) ; if ( refreshSessionResult . getAuthenticationResult ( ) = = null ) { throw new CognitoNotAuthorizedException ( _STR ) ; } cognitoUserSession = getCognitoUserSession ( refreshSessionResult . getAuthenticationResult ( ) , currSession . getRefreshToken ( ) ) ; return cognitoUserSession ; } 
4586	public boolean isSet ( _ Fields field ) { if ( field = = null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case ARG : return isSetArg ( ) ; } throw new IllegalStateException ( ) ; } 
4587	private static boolean findLeadImage ( List < WebImage > candidates , WebText firstContent ) { if ( candidates . size ( ) = = _NUM ) return false ; Element contentElement = null ; if ( firstContent ! = null ) { contentElement = Element . as ( firstContent . getFirstNonWhitespaceTextNode ( ) ) ; } List < ImageScorer > heuristics = getLeadHeuristics ( contentElement ) ; WebImage bestImage = null ; int bestScore = _NUM ; for ( WebImage i : candidates ) { int curScore = getImageScore ( i , heuristics ) ; if ( MINIMUM _ ACCEPTED _ SCORE < = curScore ) { if ( bestImage = = null | | bestScore < curScore ) { bestImage = i ; bestScore = curScore ; } } } if ( bestImage = = null ) return false ; bestImage . setIsContent ( true ) ; return true ; } 
4588	private boolean onTouchObserved ( MotionEvent srcEvent ) { final View src = mSrc ; if ( ! src . isEnabled ( ) ) { return false ; } final int actionMasked = srcEvent . getActionMasked ( ) ; switch ( actionMasked ) { case MotionEvent . ACTION _ DOWN : mActivePointerId = srcEvent . getPointerId ( _NUM ) ; if ( mDisallowIntercept = = null ) { mDisallowIntercept = new DisallowIntercept ( ) ; } src . postDelayed ( mDisallowIntercept , mTapTimeout ) ; if ( mTriggerLongPress = = null ) { mTriggerLongPress = new TriggerLongPress ( ) ; } src . postDelayed ( mTriggerLongPress , mLongPressTimeout ) ; break ; case MotionEvent . ACTION _ MOVE : final int activePointerIndex = srcEvent . findPointerIndex ( mActivePointerId ) ; if ( activePointerIndex > = _NUM ) { final float x = srcEvent . getX ( activePointerIndex ) ; final float y = srcEvent . getY ( activePointerIndex ) ; Has the pointer moved outside of the view ? if ( ! src . pointInView ( x , y , mScaledTouchSlop ) ) { clearCallbacks ( ) ; Don ' t let the parent intercept our events . src . getParent ( ) . requestDisallowInterceptTouchEvent ( true ) ; return true ; } } break ; case MotionEvent . ACTION _ CANCEL : case MotionEvent . ACTION _ UP : clearCallbacks ( ) ; break ; } return false ; } 
4589	public void kill ( ) { if ( m _ shell ! = null ) { m _ shell . exit ( ) ; } if ( m _ loggingThread ! = null ) { m _ loggingThread . stopThread ( ) ; } m _ shell = null ; m _ setupBean = null ; } 
4590	public static ILeaderElector zkLeaderElector ( Map < String , Object > conf , CuratorFramework zkClient , BlobStore blobStore , final TopoCache tc , IStormClusterState clusterState , List < ACL > acls ) throws UnknownHostException { return _ instance . zkLeaderElectorImpl ( conf , zkClient , blobStore , tc , clusterState , acls ) ; } 
4591	public boolean rmdir ( Path path ) throws IOException { return deleteObject ( path ) ; } 
4592	public void enableItemAtPosition ( int position ) { if ( position < _NUM | | position > items . size ( ) - _NUM ) { Log . w ( TAG , _STR ) ; return ; } itemsEnabledStates [ position ] = true ; createItems ( ) ; } 
4593	void displayPage ( ) { removeAll ( ) ; addComponent ( mainContainer ) ; setScrollY ( _NUM ) ; revalidate ( ) ; repaint ( ) ; Places the focus on the first link in the page , as long as it is within the visible area of the first page if ( getComponentForm ( ) ! = null ) { a revalidate on the component itself does not always result in correct size calculation , thus leaving unreachable elements in the HTML ( Note that the first revalidate on the component is also necessary ) getComponentForm ( ) . revalidate ( ) ; if ( firstFocusable ! = null ) { if ( autoFocus ) { if ( firstFocusable . getY ( ) < getHeight ( ) ) { getComponentForm ( ) . setFocused ( firstFocusable ) ; } else { getComponentForm ( ) . setFocused ( mainContainer ) ; } } } else { If there are no focused components , the main container will become focusable , thus enabling it to be pixel - scrolled mainContainer . setFocusable ( true ) ; getComponentForm ( ) . setFocused ( mainContainer ) ; } if ( marqueeComponents . size ( ) > _NUM ) { getComponentForm ( ) . registerAnimated ( HTMLComponent . this ) ; int dir = getUIManager ( ) . getLookAndFeel ( ) . isRTL ( ) ? _NUM : - _NUM ; marqueeMotion = Motion . createLinearMotion ( _NUM , dir * HTMLComponent . this . getWidth ( ) , MARQUEE _ DELAY / _NUM ) ; marqueeMotion . start ( ) ; } } setPageStatus ( HTMLCallback . STATUS _ DISPLAYED ) ; if ( getComponentForm ( ) ! = null ) { getComponentForm ( ) . revalidate ( ) ; } } 
4594	public static INDArray create ( double [ ] data , int rows , int columns , int [ ] stride , long offset , char ordering ) { int [ ] shape = getEnsuredShape ( rows , columns ) ; checkShapeValues ( data . length , shape ) ; INDArray ret = INSTANCE . create ( Nd _NUM j . createBuffer ( data ) , shape , stride , offset , ordering ) ; logCreationIfNecessary ( ret ) ; return ret ; } 
4595	public static void rotate ( List < ? > lst , int dist ) { List < Object > list = ( List < Object > ) lst ; int size = list . size ( ) ; Can ' t sensibly rotate an empty collection if ( size = = _NUM ) { return ; } normalize the distance int normdist ; if ( dist > _NUM ) { normdist = dist % size ; } else { normdist = size - ( ( dist % size ) * ( - _NUM ) ) ; } if ( normdist = = _NUM | | normdist = = size ) { return ; } if ( list instanceof RandomAccess ) { make sure each element gets juggled with the element in the position it is supposed to go to Object temp = list . get ( _NUM ) ; int index = _NUM , beginIndex = _NUM ; for ( int i = _NUM ; i < size ; i + + ) { index = ( index + normdist ) % size ; temp = list . set ( index , temp ) ; if ( index = = beginIndex ) { index = + + beginIndex ; temp = list . get ( beginIndex ) ; } } } else { int divideIndex = ( size - normdist ) % size ; List < Object > sublist _NUM = list . subList ( _NUM , divideIndex ) ; List < Object > sublist _NUM = list . subList ( divideIndex , size ) ; reverse ( sublist _NUM ) ; reverse ( sublist _NUM ) ; reverse ( list ) ; } } 
4596	public void setDisabledStyle ( Style style ) { if ( this . disabledStyle ! = null ) { this . disabledStyle . removeStyleListener ( this ) ; } this . disabledStyle = style ; this . disabledStyle . addStyleListener ( this ) ; if ( this . disabledStyle . getBgPainter ( ) = = null ) { this . disabledStyle . setBgPainter ( new BGPainter ( ) ) ; } setShouldCalcPreferredSize ( true ) ; checkAnimation ( ) ; } 
4597	public Entity next ( ) { if ( mIsClosed ) { throw new IllegalStateException ( _STR , e ) ; } } 
4598	public void testFileCreationWithOverwrite ( ) throws Exception { Configuration conf = new Configuration ( ) ; conf . setInt ( _STR ; Path filePath = new Path ( file ) ; Case _NUM : Create file with overwrite , check the blocks of old file are cleaned after creating with overwrite NameNode nn = cluster . getNameNode ( ) ; FSNamesystem fsn = NameNodeAdapter . getNamesystem ( nn ) ; BlockManager bm = fsn . getBlockManager ( ) ; FSDataOutputStream out = dfs . create ( filePath ) ; byte [ ] oldData = AppendTestUtil . randomBytes ( seed , fileSize ) ; try { out . write ( oldData ) ; } finally { out . close ( ) ; } LocatedBlocks oldBlocks = NameNodeAdapter . getBlockLocations ( nn , file , _NUM , fileSize ) ; assertBlocks ( bm , oldBlocks , true ) ; out = dfs . create ( filePath , true ) ; byte [ ] newData = AppendTestUtil . randomBytes ( seed , fileSize ) ; try { out . write ( newData ) ; } finally { out . close ( ) ; } dfs . deleteOnExit ( filePath ) ; LocatedBlocks newBlocks = NameNodeAdapter . getBlockLocations ( nn , file , _NUM , fileSize ) ; assertBlocks ( bm , newBlocks , true ) ; assertBlocks ( bm , oldBlocks , false ) ; FSDataInputStream in = dfs . open ( filePath ) ; byte [ ] result = null ; try { result = readAll ( in ) ; } finally { in . close ( ) ; } Assert . assertArrayEquals ( newData , result ) ; Case _NUM : Restart NN , check the file cluster . restartNameNode ( ) ; nn = cluster . getNameNode ( ) ; in = dfs . open ( filePath ) ; try { result = readAll ( in ) ; } finally { in . close ( ) ; } Assert . assertArrayEquals ( newData , result ) ; Case _NUM : Save new checkpoint and restart NN , check the file NameNodeAdapter . enterSafeMode ( nn , false ) ; NameNodeAdapter . saveNamespace ( nn ) ; cluster . restartNameNode ( ) ; nn = cluster . getNameNode ( ) ; in = dfs . open ( filePath ) ; try { result = readAll ( in ) ; } finally { in . close ( ) ; } Assert . assertArrayEquals ( newData , result ) ; } finally { if ( dfs ! = null ) { dfs . close ( ) ; } if ( cluster ! = null ) { cluster . shutdown ( ) ; } } } 
4599	public static Map < String , Object > updatePartyGroup ( DispatchContext ctx , Map < String , ? extends Object > context ) { Map < String , Object > result = new HashMap < String , Object > ( ) ; Delegator delegator = ctx . getDelegator ( ) ; LocalDispatcher dispatcher = ctx . getDispatcher ( ) ; Locale locale = ( Locale ) context . get ( _STR , new Object [ ] { e . getMessage ( ) } , locale ) ) ; } } result . put ( ModelService . RESPONSE _ MESSAGE , ModelService . RESPOND _ SUCCESS ) ; return result ; } 
4600	public static < TSource > TSource single ( Enumerable < TSource > source ) { TSource toRet = null ; try ( Enumerator < TSource > os = source . enumerator ( ) ) { if ( os . moveNext ( ) ) { toRet = os . current ( ) ; if ( os . moveNext ( ) ) { throw new IllegalStateException ( ) ; } } if ( toRet ! = null ) { return toRet ; } throw new IllegalStateException ( ) ; } } 
4601	public TBigInteger gcd ( TBigInteger val ) { TBigInteger val _NUM = this . abs ( ) ; TBigInteger val _NUM = val . abs ( ) ; To avoid a possible division by zero if ( val _NUM . signum ( ) = = _NUM ) { return val _NUM ; } else if ( val _NUM . signum ( ) = = _NUM ) { return val _NUM ; } ( op _NUM . bitLength ( ) < _NUM _NUM ) and ( op _NUM . bitLength ( ) < _NUM _NUM ) if ( ( ( val _NUM . numberLength = = _NUM ) | | ( ( val _NUM . numberLength = = _NUM ) & & ( val _NUM . digits [ _NUM ] > _NUM ) ) ) & & ( val _NUM . numberLength = = _NUM | | ( val _NUM . numberLength = = _NUM & & val _NUM . digits [ _NUM ] > _NUM ) ) ) { return TBigInteger . valueOf ( TDivision . gcdBinary ( val _NUM . longValue ( ) , val _NUM . longValue ( ) ) ) ; } return TDivision . gcdBinary ( val _NUM . copy ( ) , val _NUM . copy ( ) ) ; } 
4602	public void splitAndResolveOperation ( ServerName serverName , Set < RemoteProcedure > operations , RemoteProcedureResolver resolver ) { MasterProcedureEnv env = master . getMasterProcedureExecutor ( ) . getEnvironment ( ) ; ArrayListMultimap < Class < ? > , RemoteOperation > reqsByType = buildAndGroupRequestByType ( env , serverName , operations ) ; List < RegionOpenOperation > openOps = fetchType ( reqsByType , RegionOpenOperation . class ) ; if ( ! openOps . isEmpty ( ) ) { resolver . dispatchOpenRequests ( env , openOps ) ; } List < RegionCloseOperation > closeOps = fetchType ( reqsByType , RegionCloseOperation . class ) ; if ( ! closeOps . isEmpty ( ) ) { resolver . dispatchCloseRequests ( env , closeOps ) ; } List < ServerOperation > refreshOps = fetchType ( reqsByType , ServerOperation . class ) ; if ( ! refreshOps . isEmpty ( ) ) { resolver . dispatchServerOperations ( env , refreshOps ) ; } if ( ! reqsByType . isEmpty ( ) ) { LOG . warn ( _STR + reqsByType ) ; } } 
4603	private void processRpcRequest ( RpcRequestHeaderProto header , DataInputStream dis ) throws WrappedRpcServerException , InterruptedException { Class < ? extends Writable > rpcRequestClass = getRpcRequestWrapper ( header . getRpcKind ( ) ) ; if ( rpcRequestClass = = null ) { LOG . warn ( _STR + t . getMessage ( ) ; throw new WrappedRpcServerException ( RpcErrorCodeProto . FATAL _ DESERIALIZING _ REQUEST , err ) ; } Span traceSpan = null ; if ( header . hasTraceInfo ( ) ) { If the incoming RPC included tracing info , always continue the trace TraceInfo parentSpan = new TraceInfo ( header . getTraceInfo ( ) . getTraceId ( ) , header . getTraceInfo ( ) . getParentId ( ) ) ; traceSpan = Trace . startSpan ( RpcClientUtil . toTraceName ( rpcRequest . toString ( ) ) , parentSpan ) . detach ( ) ; } Call call = new Call ( header . getCallId ( ) , header . getRetryCount ( ) , rpcRequest , this , ProtoUtil . convert ( header . getRpcKind ( ) ) , header . getClientId ( ) . toByteArray ( ) , traceSpan ) ; if ( callQueue . isClientBackoffEnabled ( ) ) { if RPC queue is full , we will ask the RPC client to back off by throwing RetriableException . Whether RPC client will honor RetriableException and retry depends on client ipc retry policy . For example , FailoverOnNetworkExceptionRetry handles RetriableException . queueRequestOrAskClientToBackOff ( call ) ; } else { queue the call ; maybe blocked here callQueue . put ( call ) ; } Increment the rpc count incRpcCount ( ) ; } 
4604	protected final void processTilingPattern ( PDTilingPattern tilingPattern , PDColor color , PDColorSpace colorSpace , Matrix patternMatrix ) throws IOException { PDResources parent = pushResources ( tilingPattern ) ; Matrix parentMatrix = initialMatrix ; initialMatrix = Matrix . concatenate ( initialMatrix , patternMatrix ) ; save the original graphics state Stack < PDGraphicsState > savedStack = saveGraphicsStack ( ) ; save a clean state ( new clipping path , line path , etc . ) Rectangle _NUM D bbox = tilingPattern . getBBox ( ) . transform ( patternMatrix ) . getBounds _NUM D ( ) ; PDRectangle rect = new PDRectangle ( ( float ) bbox . getX ( ) , ( float ) bbox . getY ( ) , ( float ) bbox . getWidth ( ) , ( float ) bbox . getHeight ( ) ) ; graphicsStack . push ( new PDGraphicsState ( rect ) ) ; non - colored patterns have to be given a color if ( colorSpace ! = null ) { color = new PDColor ( color . getComponents ( ) , colorSpace ) ; getGraphicsState ( ) . setNonStrokingColorSpace ( colorSpace ) ; getGraphicsState ( ) . setNonStrokingColor ( color ) ; getGraphicsState ( ) . setStrokingColorSpace ( colorSpace ) ; getGraphicsState ( ) . setStrokingColor ( color ) ; } transform the CTM using the stream ' s matrix getGraphicsState ( ) . getCurrentTransformationMatrix ( ) . concatenate ( patternMatrix ) ; clip to bounding box clipToRect ( tilingPattern . getBBox ( ) ) ; processStreamOperators ( tilingPattern ) ; initialMatrix = parentMatrix ; restoreGraphicsStack ( savedStack ) ; popResources ( parent ) ; } 
4605	public Byte get ( Object key ) { char k ; if ( key ! = null ) { if ( key instanceof Character ) { k = unwrapKey ( key ) ; } else { return null ; } } else { k = _ map . getNoEntryKey ( ) ; } byte v = _ map . get ( k ) ; check here . if ( v = = _ map . getNoEntryValue ( ) ) { return null ; } else { return wrapValue ( v ) ; } } 
4606	public synchronized void gainPrimacy ( ) throws IOException { Preconditions . checkState ( mWriter = = null , _STR ) ; mTailerThread . awaitTermination ( true ) ; long nextSequenceNumber = mTailerThread . getNextSequenceNumber ( ) ; mTailerThread = null ; nextSequenceNumber = catchUp ( nextSequenceNumber ) ; mWriter = new UfsJournalLogWriter ( this , nextSequenceNumber ) ; mAsyncWriter = new AsyncJournalWriter ( mWriter ) ; mState = State . PRIMARY ; } 
4607	public String formatAsString ( ) { Special handling for whole - column references if ( isWholeColumnReference ( ) ) { return CellReference . convertNumToColString ( _ firstCell . getCol ( ) ) + _STR + CellReference . convertNumToColString ( _ lastCell . getCol ( ) ) ; } StringBuilder sb = new StringBuilder ( _NUM _NUM ) ; sb . append ( _ firstCell . formatAsString ( ) ) ; if ( ! _ isSingleCell ) { sb . append ( CELL _ DELIMITER ) ; if ( _ lastCell . getSheetName ( ) = = null ) { sb . append ( _ lastCell . formatAsString ( ) ) ; } else { don ' t want to include the sheet name twice _ lastCell . appendCellReference ( sb ) ; } } return sb . toString ( ) ; } 
4608	protected static void gsAddTriples ( DatasetGraph dsg , Target src , Target dest ) { Graph gSrc = graph ( dsg , src ) ; Graph gDest = graph ( dsg , dest ) ; Avoids concurrency problems by reading fully before writing ThresholdPolicy < Triple > policy = ThresholdPolicyFactory . policyFromContext ( dsg . getContext ( ) ) ; DataBag < Triple > db = BagFactory . newDefaultBag ( policy , SerializationFactoryFinder . tripleSerializationFactory ( ) ) ; try { Iterator < Triple > triples = gSrc . find ( null , null , null ) ; db . addAll ( triples ) ; Iter . close ( triples ) ; GraphOps . addAll ( gDest , db . iterator ( ) ) ; } finally { db . close ( ) ; } } 
4609	public void testSetupGenerateDistCacheData ( ) throws IOException , InterruptedException { long [ ] sortedFileSizes = new long [ _NUM ] ; Configuration jobConf = runSetupGenerateDistCacheData ( true , sortedFileSizes ) ; validateSetupGenDC ( jobConf , sortedFileSizes ) ; Verify if correct exit code is seen when - generate option is missing and distributed cache files are missing in the expected path . runSetupGenerateDistCacheData ( false , sortedFileSizes ) ; } 
4610	public PdfDictionary getAsDict ( PdfName key ) { PdfDictionary dict = null ; PdfObject orig = getDirectObject ( key ) ; if ( orig ! = null & & orig . isDictionary ( ) ) dict = ( PdfDictionary ) orig ; return dict ; } 
4611	public LayeredLayout setInsetLeft ( Component cmp , String inset ) { getOrCreateConstraint ( cmp ) . left ( ) . setValue ( inset ) ; return this ; } 
4612	public void processArgumentsMinDepth ( ) throws IOException { LinkedList < PathData > items = createDirectories ( ) ; Find find = new Find ( ) ; find . getOptions ( ) . setMinDepth ( _NUM ) ; find . setConf ( conf ) ; PrintStream out = mock ( PrintStream . class ) ; find . getOptions ( ) . setOut ( out ) ; PrintStream err = mock ( PrintStream . class ) ; find . getOptions ( ) . setErr ( err ) ; Expression expr = mock ( Expression . class ) ; when ( expr . apply ( ( PathData ) any ( ) , anyInt ( ) ) ) . thenReturn ( Result . PASS ) ; FileStatusChecker fsCheck = mock ( FileStatusChecker . class ) ; Expression test = new TestExpression ( expr , fsCheck ) ; find . setRootExpression ( test ) ; find . processArguments ( items ) ; InOrder inOrder = inOrder ( expr ) ; inOrder . verify ( expr ) . setOptions ( find . getOptions ( ) ) ; inOrder . verify ( expr ) . prepare ( ) ; inOrder . verify ( expr ) . apply ( item _NUM a , _NUM ) ; inOrder . verify ( expr ) . apply ( item _NUM aa , _NUM ) ; inOrder . verify ( expr ) . apply ( item _NUM b , _NUM ) ; inOrder . verify ( expr ) . apply ( item _NUM a , _NUM ) ; inOrder . verify ( expr ) . apply ( item _NUM b , _NUM ) ; inOrder . verify ( expr ) . apply ( item _NUM c , _NUM ) ; inOrder . verify ( expr ) . apply ( item _NUM ca , _NUM ) ; inOrder . verify ( expr ) . apply ( item _NUM d , _NUM ) ; inOrder . verify ( expr ) . apply ( item _NUM e , _NUM ) ; inOrder . verify ( expr ) . finish ( ) ; verifyNoMoreInteractions ( expr ) ; InOrder inOrderFsCheck = inOrder ( fsCheck ) ; inOrderFsCheck . verify ( fsCheck ) . check ( item _NUM a . stat ) ; inOrderFsCheck . verify ( fsCheck ) . check ( item _NUM aa . stat ) ; inOrderFsCheck . verify ( fsCheck ) . check ( item _NUM b . stat ) ; inOrderFsCheck . verify ( fsCheck ) . check ( item _NUM a . stat ) ; inOrderFsCheck . verify ( fsCheck ) . check ( item _NUM b . stat ) ; inOrderFsCheck . verify ( fsCheck ) . check ( item _NUM c . stat ) ; inOrderFsCheck . verify ( fsCheck ) . check ( item _NUM ca . stat ) ; inOrderFsCheck . verify ( fsCheck ) . check ( item _NUM d . stat ) ; inOrderFsCheck . verify ( fsCheck ) . check ( item _NUM e . stat ) ; verifyNoMoreInteractions ( fsCheck ) ; verifyNoMoreInteractions ( out ) ; verifyNoMoreInteractions ( err ) ; } 
4613	public synchronized Player getPlayer ( HttpServletRequest request , HttpServletResponse response , boolean remoteControlEnabled , boolean isStreamRequest ) { Find by ' player ' request parameter . Player player = getPlayerById ( request . getParameter ( _STR , player . getId ( ) ) ; } return player ; } 
4614	public static String [ ] getHyponyms ( POS pos , long offset ) { Synset synset = null ; try { synset = dict . getSynsetAt ( pos , offset ) ; } catch ( JWNLException e ) { } if ( synset = = null ) return null ; Synset [ ] hyponyms = getHyponymSynsets ( synset ) ; if ( hyponyms = = null ) return null ; return getLemmas ( hyponyms ) ; } 
4615	private boolean updateStorefiles ( List < HStoreFile > sfs , long snapshotId ) throws IOException { this . lock . writeLock ( ) . lock ( ) ; try { this . storeEngine . getStoreFileManager ( ) . insertNewFiles ( sfs ) ; if ( snapshotId > _NUM ) { this . memstore . clearSnapshot ( snapshotId ) ; } } finally { We need the lock , as long as we are updating the storeFiles or changing the memstore . Let us release it before calling notifyChangeReadersObservers . See HBASE - _NUM _NUM _NUM _NUM for a possible deadlock scenario that could have happened if continue to hold the lock . this . lock . writeLock ( ) . unlock ( ) ; } notify to be called here - only in case of flushes notifyChangedReadersObservers ( sfs ) ; if ( LOG . isTraceEnabled ( ) ) { long totalSize = getTotalSize ( sfs ) ; String traceMessage = _STR ; LOG . trace ( traceMessage ) ; } return needsCompaction ( ) ; } 
4616	public Iterator < Result > iterator ( ) { return new Iterator < Result > ( ) { private Result nextOne = null ; @ Override public boolean hasNext ( ) { if ( null = = nextOne ) { nextOne = one ( ) ; } return nextOne ! = null ; } @ Override public Result next ( ) { if ( null ! = nextOne | | hasNext ( ) ) { final Result r = nextOne ; nextOne = null ; return r ; } else throw new NoSuchElementException ( ) ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } 
4617	public boolean isPanelSelected ( ) { return ( getCurrentPanel ( ) ! = null ) ; } 
4618	public void writeOrganizationalUnit ( CmsDbContext dbc , CmsOrganizationalUnit organizationalUnit ) throws CmsException { m _ monitor . uncacheOrgUnit ( organizationalUnit ) ; getUserDriver ( dbc ) . writeOrganizationalUnit ( dbc , organizationalUnit ) ; create a publish list for the ' virtual ' publish event CmsResource ouRes = readResource ( dbc , organizationalUnit . getId ( ) , CmsResourceFilter . DEFAULT ) ; CmsPublishList pl = new CmsPublishList ( ouRes , false ) ; pl . add ( ouRes , false ) ; getProjectDriver ( dbc ) . writePublishHistory ( dbc , pl . getPublishHistoryId ( ) , new CmsPublishedResource ( ouRes , - _NUM , CmsResourceState . STATE _ NEW ) ) ; fire the ' virtual ' publish event Map < String , Object > eventData = new HashMap < String , Object > ( ) ; eventData . put ( I _ CmsEventListener . KEY _ PUBLISHID , pl . getPublishHistoryId ( ) . toString ( ) ) ; eventData . put ( I _ CmsEventListener . KEY _ PROJECTID , dbc . currentProject ( ) . getUuid ( ) ) ; eventData . put ( I _ CmsEventListener . KEY _ DBCONTEXT , dbc ) ; CmsEvent afterPublishEvent = new CmsEvent ( I _ CmsEventListener . EVENT _ PUBLISH _ PROJECT , eventData ) ; OpenCms . fireCmsEvent ( afterPublishEvent ) ; m _ monitor . cacheOrgUnit ( organizationalUnit ) ; } 
4619	public static void regenerateGlobalOutputProperties ( ) { if ( GLOBAL _ CREATOR ! = null ) { try { GLOBAL _ CREATOR . execute ( false , false ) ; GLOBAL _ OUTPUT _ PROPERTIES = GLOBAL _ CREATOR . getOutputProperties ( ) ; } catch ( Exception e ) { TODO Auto - generated catch block e . printStackTrace ( ) ; } } } 
4620	String getBaseFont ( ) throws DocumentException , IOException { int [ ] table _ location ; table _ location = ( int [ ] ) tables . get ( _STR , fileName + style ) ) ; rf . seek ( table _ location [ _NUM ] + _NUM ) ; int numRecords = rf . readUnsignedShort ( ) ; int startOfStorage = rf . readUnsignedShort ( ) ; for ( int k = _NUM ; k < numRecords ; + + k ) { int platformID = rf . readUnsignedShort ( ) ; int platformEncodingID = rf . readUnsignedShort ( ) ; int languageID = rf . readUnsignedShort ( ) ; int nameID = rf . readUnsignedShort ( ) ; int length = rf . readUnsignedShort ( ) ; int offset = rf . readUnsignedShort ( ) ; if ( nameID = = _NUM ) { rf . seek ( table _ location [ _NUM ] + startOfStorage + offset ) ; if ( platformID = = _NUM | | platformID = = _NUM ) return readUnicodeString ( length ) ; else return readStandardString ( length ) ; } } File file = new File ( fileName ) ; return file . getName ( ) . replace ( ' ' , ' - ' ) ; } 
4621	public byte [ ] convertToXmlByteArray ( BucketNotificationConfiguration notificationConfiguration ) { final XmlWriter xml = new XmlWriter ( ) ; xml . start ( _STR ) . value ( ( ( LambdaConfiguration ) config ) . getFunctionARN ( ) ) . end ( ) ; addEventsAndFilterCriteria ( xml , config ) ; xml . end ( ) ; } } xml . end ( ) ; return xml . getBytes ( ) ; } 
4622	public static RDD < String > matrixObjectToRDDStringCSV ( MatrixObject matrixObject ) { NOTE : The following works when called from Java but does not currently work when called from Spark Shell ( when you call collect ( ) on the RDD < String > ) . JavaRDD < String > javaRDD = jsc . parallelize ( list ) ; RDD < String > rdd = JavaRDD . toRDD ( javaRDD ) ; Therefore , we call parallelize ( ) on the SparkContext rather than the JavaSparkContext to produce the RDD < String > for Scala . List < String > list = matrixObjectToListStringCSV ( matrixObject ) ; ClassTag < String > tag = scala . reflect . ClassTag $ . MODULE $ . apply ( String . class ) ; return sc ( ) . parallelize ( JavaConversions . asScalaBuffer ( list ) , sc ( ) . defaultParallelism ( ) , tag ) ; } 
4623	public void test _NUM _NUM _NUM _NUM _NUM ( ) throws Exception { Workbook wb = _ testDataProvider . createWorkbook ( ) ; Sheet s = wb . createSheet ( ) ; Cell cell = s . createRow ( _NUM ) . createCell ( _NUM ) ; cell . setCellValue ( ( String ) null ) ; assertEquals ( CellType . BLANK , cell . getCellType ( ) ) ; _ testDataProvider . trackAllColumnsForAutosizing ( s ) ; s . autoSizeColumn ( _NUM ) ; assertEquals ( _NUM _NUM _NUM _NUM , s . getColumnWidth ( _NUM ) ) ; s . autoSizeColumn ( _NUM , true ) ; assertEquals ( _NUM _NUM _NUM _NUM , s . getColumnWidth ( _NUM ) ) ; wb . close ( ) ; } 
4624	 @ SuppressWarnings ( _STR ) ; propertyButtonsPanel . add ( createButton ) ; propertyButtonsPanel . add ( addButton ) ; propertyButtonsPanel . add ( editButton ) ; propertyButtonsPanel . add ( removeButton ) ; return propertyButtonsPanel ; } 
4625	public synchronized void addDataSourceListener ( DataSourceListener dsl ) { super . addDataSourceListener ( dsl ) ; m _ dataSetEventTargets + + ; pass on any current instance format try { if ( ( m _ Loader instanceof DatabaseLoader & & m _ dbSet & & m _ dataFormat = = null ) | | ( ! ( m _ Loader instanceof DatabaseLoader ) & & m _ dataFormat = = null ) ) { m _ dataFormat = m _ Loader . getStructure ( ) ; m _ dbSet = false ; } } catch ( Exception ex ) { } notifyStructureAvailable ( m _ dataFormat ) ; } 
4626	public void showTextString ( byte [ ] string ) throws IOException { showText ( string ) ; } 
4627	public Point findNextViewCenter ( ViewData previousViewData , int nextViewHalfViewWidth , int nextViewHalfViewHeight ) { Point previousViewCenter = previousViewData . getCenterPoint ( ) ; Point nextViewCenter ; boolean foundNextViewCenter ; do { nextViewCenter = getNextViewCenter ( previousViewCenter ) ; int nextViewTop = nextViewCenter . getY ( ) - nextViewHalfViewHeight ; int nextViewBottom = nextViewCenter . getY ( ) + nextViewHalfViewHeight ; int nextViewRight = nextViewCenter . getX ( ) + nextViewHalfViewWidth ; boolean nextViewTopIsBelowPreviousViewBottom = nextViewTop > = previousViewData . getViewBottom ( ) ; boolean nextViewBottomIsAbovePreviousViewTop = nextViewBottom < = previousViewData . getViewTop ( ) ; boolean nextViewIsToTheLeftOfThePreviousView = nextViewRight < = previousViewData . getViewLeft ( ) ; foundNextViewCenter = nextViewTopIsBelowPreviousViewBottom | | nextViewIsToTheLeftOfThePreviousView | | nextViewBottomIsAbovePreviousViewTop ; _STR become previous previousViewCenter = nextViewCenter ; } while ( ! foundNextViewCenter ) ; return nextViewCenter ; } 
4628	public byte [ ] getEncoded ( String encoding ) throws IOException { if ( ASN _NUM Encoding . DL . equals ( encoding ) ) { return new DLSequence ( new ASN _NUM Encodable [ ] { resp . getStatus ( ) , timeStampToken . toCMSSignedData ( ) . toASN _NUM Structure ( ) } ) . getEncoded ( encoding ) ; } return resp . getEncoded ( encoding ) ; } 
4629	public void testIsFileNewerImaginaryFile ( ) { final File imaginaryFile = new File ( getTestDirectory ( ) , _STR , imaginaryFile , m _ testFile _NUM . lastModified ( ) , false ) ; } 
4630	protected void addHistory ( String s ) { if ( s . equals ( _STR ) ) return ; no duplicates ! if ( m _ History . contains ( s ) ) m _ History . removeElement ( s ) ; m _ History . add ( _NUM , s ) ; send notification notifyHistoryChangedListeners ( ) ; } 
4631	public String [ ] getMergedSubscriberIds ( ) { try { ITelephony telephony = getITelephony ( ) ; if ( telephony ! = null ) return telephony . getMergedSubscriberIds ( getOpPackageName ( ) ) ; } catch ( RemoteException ex ) { } catch ( NullPointerException ex ) { } return null ; } 
4632	public Number getStartY ( int series , int item ) { return new Double ( getStartYValue ( series , item ) ) ; } 
4633	public void release ( ) { if ( mToken = = null ) { Log . w ( TAG , _STR ) ; return ; } try { mService . releaseSession ( mToken , mUserId ) ; } catch ( RemoteException e ) { throw e . rethrowFromSystemServer ( ) ; } releaseInternal ( ) ; } 
4634	public static Messenger readMessengerOrNullFromParcel ( Parcel in ) { IBinder b = in . readStrongBinder ( ) ; return b ! = null ? new Messenger ( b ) : null ; } 
4635	public final void testAssertShardCoveredOrAbsentTestIncompleteSplitMax ( ) throws KinesisClientLibIOException { HashKeyRange hashKeyRange = ShardObjectHelper . newHashKeyRange ( _STR ) ; testAssertShardCoveredOrAbsentTestIncompleteSplit ( hashKeyRange , childHashKeyRange _NUM , childHashKeyRange _NUM ) ; } 
4636	public Boolean getAsBoolean ( String key ) { Object value = mValues . get ( key ) ; try { return ( Boolean ) value ; } catch ( ClassCastException e ) { if ( value instanceof CharSequence ) { false . return Boolean . valueOf ( value . toString ( ) ) | | _STR + value , e ) ; return null ; } } } 
4637	 @ SuppressWarnings ( { _STR + ex . getMessage ( ) ) ; } return URLDecoder . decode ( source ) ; } } 
4638	public T [ ] shrink ( ) { if ( items . length ! = size ) resize ( size ) ; return items ; } 
4639	public TBigDecimal divideToIntegralValue ( TBigDecimal divisor ) { the integer of result TBigInteger integralValue ; some power of ten TBigInteger powerOfTen ; TBigInteger [ ] quotAndRem = { getUnscaledValue ( ) } ; long newScale = ( long ) this . scale - divisor . scale ; long tempScale = _NUM ; int i = _NUM ; int lastPow = TEN _ POW . length - _NUM ; if ( divisor . isZero ( ) ) { throw new ArithmeticException ( _STR ) ; } if ( ( divisor . aproxPrecision ( ) + newScale > this . aproxPrecision ( ) + _NUM L ) | | ( this . isZero ( ) ) ) { integralValue = TBigInteger . ZERO ; } else if ( newScale = = _NUM ) { integralValue = getUnscaledValue ( ) . divide ( divisor . getUnscaledValue ( ) ) ; } else if ( newScale > _NUM ) { powerOfTen = TMultiplication . powerOf _NUM _NUM ( newScale ) ; integralValue = getUnscaledValue ( ) . divide ( divisor . getUnscaledValue ( ) . multiply ( powerOfTen ) ) ; integralValue = integralValue . multiply ( powerOfTen ) ; } else { ( newScale < _NUM ) powerOfTen = TMultiplication . powerOf _NUM _NUM ( - newScale ) ; integralValue = getUnscaledValue ( ) . multiply ( powerOfTen ) . divide ( divisor . getUnscaledValue ( ) ) ; To strip trailing zeros approximating to the preferred scale while ( ! integralValue . testBit ( _NUM ) ) { quotAndRem = integralValue . divideAndRemainder ( TEN _ POW [ i ] ) ; if ( ( quotAndRem [ _NUM ] . signum ( ) = = _NUM ) & & ( tempScale - i > = newScale ) ) { tempScale - = i ; if ( i < lastPow ) { i + + ; } integralValue = quotAndRem [ _NUM ] ; } else { if ( i = = _NUM ) { break ; } i = _NUM ; } } newScale = tempScale ; } return ( ( integralValue . signum ( ) = = _NUM ) ? zeroScaledBy ( newScale ) : new TBigDecimal ( integralValue , toIntScale ( newScale ) ) ) ; } 
4640	public CharSequence getText ( @ StyleableRes int index ) { if ( mRecycled ) { throw new RuntimeException ( _STR + Integer . toHexString ( type ) ) ; } 
4641	public BarEntry copy ( ) { BarEntry copied = new BarEntry ( getVal ( ) , getXIndex ( ) , getData ( ) ) ; copied . setVals ( mVals ) ; return copied ; } 
4642	void init ( String traceIn , JobCreator jobCreator , boolean generate ) throws IOException { emulateDistributedCache = jobCreator . canEmulateDistCacheLoad ( ) & & conf . getBoolean ( GRIDMIX _ EMULATE _ DISTRIBUTEDCACHE , true ) ; generateDistCacheData = generate ; if ( generateDistCacheData | | emulateDistributedCache ) { if ( _STR ) ; e . printStackTrace ( ) ; emulateDistributedCache = generateDistCacheData = false ; return ; } } 
4643	protected void invokeHandler ( HttpServletRequest req , HttpServletResponse res ) throws IOException , ServletException { String name = OpenCmsCore . getInstance ( ) . getPathInfo ( req ) . substring ( HANDLE _ PATH . length ( ) ) ; I _ CmsRequestHandler handler = OpenCmsCore . getInstance ( ) . getRequestHandler ( name ) ; if ( handler ! = null ) { handler . handle ( req , res , name ) ; } else { openErrorHandler ( req , res , HttpServletResponse . SC _ INTERNAL _ SERVER _ ERROR ) ; } } 
4644	public static Put makePutFromTableState ( TableState state , long ts ) { Put put = new Put ( state . getTableName ( ) . getName ( ) , ts ) ; put . addColumn ( getTableFamily ( ) , getTableStateColumn ( ) , state . convert ( ) . toByteArray ( ) ) ; return put ; } 
4645	public int getHeaderFlag ( int i ) { if ( proto . getFlagCount ( ) > _NUM ) { return proto . getFlag ( i ) ; } else { return combineHeader ( ECN . DISABLED , proto . getReply ( i ) ) ; } } 
4646	private SignerInformation processSignerStore ( Store < X _NUM _NUM _NUM CertificateHolder > certificatesStore , CMSSignedData signedData , CertSignatureInformation certInfo ) throws IOException , CertificateProccessingException { Collection < SignerInformation > signers = signedData . getSignerInfos ( ) . getSigners ( ) ; SignerInformation signerInformation = signers . iterator ( ) . next ( ) ; Collection < X _NUM _NUM _NUM CertificateHolder > matches = certificatesStore . getMatches ( signerInformation . getSID ( ) ) ; X _NUM _NUM _NUM Certificate certificate = getCertFromHolder ( matches . iterator ( ) . next ( ) ) ; Collection < X _NUM _NUM _NUM CertificateHolder > allCerts = certificatesStore . getMatches ( null ) ; addAllCerts ( allCerts ) ; traverseChain ( certificate , certInfo , MAX _ CERTIFICATE _ CHAIN _ DEPTH ) ; return signerInformation ; } 
4647	public void testZeroResevedBytes _ bug _NUM _NUM _NUM _NUM _NUM ( ) { Taken from bugzilla attachment _NUM _NUM _NUM _NUM _NUM ( offset _NUM x _NUM E _NUM _NUM ) byte [ ] inpData = HexRead . readFromString ( _STR ) ; } throw e ; } assertEquals ( _NUM , in . remaining ( ) ) ; assertArrayEquals ( outData , cir . serialize ( ) ) ; } 
4648	public void abort ( ) throws StreamingException , TxnBatchFailure , InterruptedException { synchronized ( txnBatchLock ) { abortTxn ( ) ; roll to next nextTxn ( true ) ; } } 
4649	void addAppenders ( String contextPath ) { final File logDir = getLogDir ( ) ; if ( logDir = = null ) { No log dir . return ; } try { final String contextPathName = getContextPathSegment ( contextPath ) ; addAppender ( new File ( logDir , _STR , e ) ; } } 
4650	public static boolean getFlag ( String flag , String [ ] options ) throws Exception { int pos = getOptionPos ( flag , options ) ; if ( pos > - _NUM ) options [ pos ] = _STR ; return ( pos > - _NUM ) ; } 
4651	public void setColor ( Color color ) { this . color = color ; applyChanges ( ) ; } 
4652	public static void forceDelete ( final File file ) throws IOException { if ( file . isDirectory ( ) ) { deleteDirectory ( file ) ; } else { final boolean filePresent = file . exists ( ) ; if ( ! file . delete ( ) ) { if ( ! filePresent ) { throw new FileNotFoundException ( _STR + file ; throw new IOException ( message ) ; } } } 
4653	protected List < UUID > getIds ( UUID queueId , UUID consumerId , QueueBounds bounds , SearchParam params ) { return getQueueRange ( queueId , bounds , params ) ; } 
4654	public String readParameter ( ) throws IOException { StringBuffer buffer = new StringBuffer ( ) ; String line = readLine ( ) ; while ( line ! = null ) { line = line . trim ( ) ; if ( ( line . length ( ) ! = _NUM ) & & ( line . charAt ( _NUM ) ! = ' # ' ) ) { if ( endsWithSlash ( line ) ) { line = line . substring ( _NUM , line . length ( ) - _NUM ) ; buffer . append ( line ) ; } else { buffer . append ( line ) ; normal method end return buffer . toString ( ) ; } } line = readLine ( ) ; } EOF reached return null ; } 
4655	public boolean removeByKey ( Record k ) { int x = find ( k ) ; if ( x < _NUM ) return false ; super . remove ( x ) ; return true ; } 
4656	private void upgradeIfNecessary ( ) { int userVersion = mUserVersion ; if ( userVersion < _NUM ) { Assign a proper name for the owner , if not initialized correctly before VUserInfo user = mUsers . get ( VUserHandle . USER _ OWNER ) ; if ( _STR + USER _ VERSION ) ; } else { mUserVersion = userVersion ; writeUserListLocked ( ) ; } } 
4657	public void setPullLabel ( CharSequence pullLabel ) { getLoadingLayoutProxy ( ) . setPullLabel ( pullLabel ) ; } 
4658	private ArrayList < Rect > calculateAllBounds ( Paint paint ) { ArrayList < Rect > list = new ArrayList < Rect > ( ) ; For each views ( If no values then add a fake one ) final int count = mViewPager . getAdapter ( ) . getCount ( ) ; final int width = getWidth ( ) ; final int halfWidth = width / _NUM ; for ( int i = _NUM ; i < count ; i + + ) { Rect bounds = calcBounds ( i , paint ) ; int w = bounds . right - bounds . left ; int h = bounds . bottom - bounds . top ; bounds . left = ( int ) ( halfWidth - ( w / _NUM f ) + ( ( i - mCurrentPage - mPageOffset ) * width ) ) ; bounds . right = bounds . left + w ; bounds . top = _NUM ; bounds . bottom = h ; list . add ( bounds ) ; } return list ; } 
4659	public void animateOut ( ) { mLayoutManager . slideOut ( ) ; } 
4660	private void testEvents ( int nodes , int backups , Replication replication ) throws Throwable { createServers ( nodes ) ; PrimaryBackupClient client _NUM = createClient ( ) ; PrimitiveProxy session _NUM = createProxy ( client _NUM , backups , replication ) ; session _NUM . addEventListener ( event - > { threadAssertNotNull ( event ) ; resume ( ) ; } ) ; PrimaryBackupClient client _NUM = createClient ( ) ; PrimitiveProxy session _NUM = createProxy ( client _NUM , backups , replication ) ; session _NUM . addEventListener ( event - > { threadAssertNotNull ( event ) ; resume ( ) ; } ) ; session _NUM . invoke ( READ ) . thenRun ( this : : resume ) ; session _NUM . invoke ( READ ) . thenRun ( this : : resume ) ; await ( _NUM _NUM _NUM _NUM , _NUM ) ; session _NUM . invoke ( EVENT , SERIALIZER : : encode , false ) . thenRun ( this : : resume ) ; await ( _NUM _NUM _NUM _NUM , _NUM ) ; } 
4661	public void setPadding ( int left , int top , int right , int bottom ) { resetResolvedPaddingInternal ( ) ; mUserPaddingStart = UNDEFINED _ PADDING ; mUserPaddingEnd = UNDEFINED _ PADDING ; mUserPaddingLeftInitial = left ; mUserPaddingRightInitial = right ; mLeftPaddingDefined = true ; mRightPaddingDefined = true ; internalSetPadding ( left , top , right , bottom ) ; } 
4662	private void sendPollRequests ( ) { Set a new timer within which other nodes must respond in order for this node to transition to candidate . heartbeatTimer = raft . getThreadContext ( ) . schedule ( raft . getElectionTimeout ( ) , ( ) - > { log . debug ( _STR , member ) ; quorum . succeed ( ) ; } } } } , raft . getThreadContext ( ) ) ; } } 
4663	public void commitMeasurements ( ) { if ( ! getFilter ( ) . noMeasurementsAvailable ( ) ) { double runningAverage = getFilter ( ) . calculateRssi ( ) ; mBeacon . setRunningAverageRssi ( runningAverage ) ; mBeacon . setRssiMeasurementCount ( getFilter ( ) . getMeasurementCount ( ) ) ; LogManager . d ( TAG , _STR ) ; } mBeacon . setPacketCount ( packetCount ) ; packetCount = _NUM ; } 
4664	public void add ( final LockList locks ) { if ( ! global ) { if ( locks . global ) { addGlobal ( ) ; } else { list . add ( locks . list ) ; } } } 
4665	public void addUnqualifiedSequenceValue ( String simpleSeqName , String seqValue ) { ArrayProperty seq = ( ArrayProperty ) getAbstractProperty ( simpleSeqName ) ; TextType li = createTextType ( XmpConstants . LIST _ NAME , seqValue ) ; if ( seq ! = null ) { seq . getContainer ( ) . addProperty ( li ) ; } else { ArrayProperty newSeq = createArrayProperty ( simpleSeqName , Cardinality . Seq ) ; newSeq . getContainer ( ) . addProperty ( li ) ; addProperty ( newSeq ) ; } } 
4666	private void simpleCreateImpl ( long idx , long val ) { TXBegin ( ) ; if ( ! testMap _NUM . containsKey ( idx ) ) { if ( expectedSum - _NUM > _NUM ) log . debug ( _STR , idx , value , val ) ; testMap _NUM . put ( idx , value + val ) ; } TXEnd ( ) ; } 
4667	public E element ( ) { return getFirst ( ) ; } 
4668	int getPrePerXPos ( final TreeSubtree sub , final int rn , final int lv , final int x ) { final TreeRect r = getTreeRectsPerLevel ( rn , lv ) [ _NUM ] ; final double ratio = ( x - r . x ) / ( double ) r . w ; final int idx = ( int ) ( ratio * sub . levelSize ( rn , lv ) ) ; return sub . prePerIndex ( rn , lv , idx ) ; } 
4669	public void testReadLine _NUM ( ) throws Exception { final ArrayBlockingQueue < ShellProcessContext > contexts = new ArrayBlockingQueue < ShellProcessContext > ( _NUM ) ; shell . addProcess ( new SyncProcess ( ) { @ Override public void run ( String request , ShellProcessContext context ) throws Exception { contexts . add ( context ) ; } } ) ; console . init ( ) ; console . on ( KeyStrokes . a ) ; console . on ( KeyStrokes . ENTER ) ; driver . assertChar ( ' a ' ) . assertFlush ( ) . assertCRLF ( ) . assertFlush ( ) . assertEmpty ( ) ; driver . assertEmpty ( ) ; final ShellProcessContext context = contexts . poll ( ) ; assertNotNull ( context ) ; final ArrayBlockingQueue < Boolean > interrupteds = new ArrayBlockingQueue < Boolean > ( _NUM ) ; Thread t = new Thread ( ) { @ Override public void run ( ) { try { context . readLine ( _STR , true ) ; } catch ( InterruptedException e ) { interrupteds . add ( true ) ; } catch ( Exception e ) { interrupteds . add ( false ) ; } } } ; t . start ( ) ; while ( t . getState ( ) ! = Thread . State . WAITING ) { Wait until the other thread is waiting } console . on ( KeyStrokes . INTERRUPT ) ; boolean interrupted = interrupteds . poll ( _NUM , TimeUnit . SECONDS ) ; assertTrue ( interrupted ) ; } 
4670	 @ JsonProperty ( _STR + DatatypeConverter . printBase _NUM _NUM Binary ( stream . toByteArray ( ) ) ; } 
4671	public void initialize ( int width , int height , int parentWidth , int parentHeight ) { super . initialize ( width , height , parentWidth , parentHeight ) ; boolean durationSet = ( mFlags & PROPERTY _ DURATION _ MASK ) = = PROPERTY _ DURATION _ MASK ; boolean fillAfterSet = ( mFlags & PROPERTY _ FILL _ AFTER _ MASK ) = = PROPERTY _ FILL _ AFTER _ MASK ; boolean fillBeforeSet = ( mFlags & PROPERTY _ FILL _ BEFORE _ MASK ) = = PROPERTY _ FILL _ BEFORE _ MASK ; boolean repeatModeSet = ( mFlags & PROPERTY _ REPEAT _ MODE _ MASK ) = = PROPERTY _ REPEAT _ MODE _ MASK ; boolean shareInterpolator = ( mFlags & PROPERTY _ SHARE _ INTERPOLATOR _ MASK ) = = PROPERTY _ SHARE _ INTERPOLATOR _ MASK ; boolean startOffsetSet = ( mFlags & PROPERTY _ START _ OFFSET _ MASK ) = = PROPERTY _ START _ OFFSET _ MASK ; if ( shareInterpolator ) { ensureInterpolator ( ) ; } final ArrayList < Animation > children = mAnimations ; final int count = children . size ( ) ; final long duration = mDuration ; final boolean fillAfter = mFillAfter ; final boolean fillBefore = mFillBefore ; final int repeatMode = mRepeatMode ; final Interpolator interpolator = mInterpolator ; final long startOffset = mStartOffset ; long [ ] storedOffsets = mStoredOffsets ; if ( startOffsetSet ) { if ( storedOffsets = = null | | storedOffsets . length ! = count ) { storedOffsets = mStoredOffsets = new long [ count ] ; } } else if ( storedOffsets ! = null ) { storedOffsets = mStoredOffsets = null ; } for ( int i = _NUM ; i < count ; i + + ) { Animation a = children . get ( i ) ; if ( durationSet ) { a . setDuration ( duration ) ; } if ( fillAfterSet ) { a . setFillAfter ( fillAfter ) ; } if ( fillBeforeSet ) { a . setFillBefore ( fillBefore ) ; } if ( repeatModeSet ) { a . setRepeatMode ( repeatMode ) ; } if ( shareInterpolator ) { a . setInterpolator ( interpolator ) ; } if ( startOffsetSet ) { long offset = a . getStartOffset ( ) ; a . setStartOffset ( offset + startOffset ) ; storedOffsets [ i ] = offset ; } a . initialize ( width , height , parentWidth , parentHeight ) ; } } 
4672	public static String sanitizeDescription ( String javadoc , boolean summary ) { if ( StringHelper . isNullOrEmpty ( javadoc ) ) { return null ; } lets just use what java accepts as identifiers StringBuilder sb = new StringBuilder ( ) ; split into lines String [ ] lines = javadoc . split ( _STR ) ; return s . trim ( ) ; } 
4673	public FileStatus [ ] listStatus ( Path p ) throws IOException { Path absF = fixRelativePart ( p ) ; return new FileSystemLinkResolver < FileStatus [ ] > ( ) { @ Override public FileStatus [ ] doCall ( final Path p ) throws IOException , UnresolvedLinkException { return listStatusInternal ( p ) ; } @ Override public FileStatus [ ] next ( final FileSystem fs , final Path p ) throws IOException { return fs . listStatus ( p ) ; } } . resolve ( this , absF ) ; } 
4674	public Object readRemote ( ) throws IOException { String type = readType ( ) ; String url = readString ( ) ; return resolveRemote ( type , url ) ; } 
4675	default V undoRemoveRecord ( ISMRMap < K , V > previousState , K key ) { return previousState . get ( key ) ; } 
4676	public ConcurrentTestCommand addInsertCommand ( int threadId , int order , int timeout , String sql ) { ConcurrentTestCommand command = new InsertCommand ( timeout , sql ) ; return addCommand ( threadId , order , command ) ; } 
4677	private long size ( SegmentInfo info ) throws IOException { final long byteSize = info . sizeInBytes ( true ) ; final int delCount = writer . get ( ) . numDeletedDocs ( info ) ; final double delRatio = ( info . docCount < = _NUM ? _NUM . _NUM f : ( ( double ) delCount / ( double ) info . docCount ) ) ; assert delRatio < = _NUM . _NUM ; return ( long ) ( byteSize * ( _NUM . _NUM - delRatio ) ) ; } 
4678	private boolean cacheBlockFromUfs ( long blockId , long blockSize , Protocol . OpenUfsBlockOptions openUfsBlockOptions ) { Check if the block has been requested in UFS block store try { if ( ! mBlockWorker . openUfsBlock ( Sessions . ASYNC _ CACHE _ SESSION _ ID , blockId , openUfsBlockOptions ) ) { LOG . warn ( _STR , blockId , ee . getMessage ( ) ) ; return false ; } } return true ; } 
4679	public static ThreadedRenderer create ( Context context , boolean translucent , String name ) { ThreadedRenderer renderer = null ; if ( isAvailable ( ) ) { renderer = new ThreadedRenderer ( context , translucent , name ) ; } return renderer ; } 
4680	public void close ( ) { if ( graphLocation ! = null ) saveGraph ( ) ; } 
4681	public Object read ( ) throws IOException { int code = _NUM ; try { code = in . readUnsignedByte ( ) ; } catch ( EOFException eof ) { return null ; } if ( code = = Type . BYTES . code ) { return new Buffer ( readBytes ( ) ) ; } else if ( code = = Type . BYTE . code ) { return readByte ( ) ; } else if ( code = = Type . BOOL . code ) { return readBool ( ) ; } else if ( code = = Type . INT . code ) { return readInt ( ) ; } else if ( code = = Type . LONG . code ) { return readLong ( ) ; } else if ( code = = Type . FLOAT . code ) { return readFloat ( ) ; } else if ( code = = Type . DOUBLE . code ) { return readDouble ( ) ; } else if ( code = = Type . STRING . code ) { return readString ( ) ; } else if ( code = = Type . VECTOR . code ) { return readVector ( ) ; } else if ( code = = Type . LIST . code ) { return readList ( ) ; } else if ( code = = Type . MAP . code ) { return readMap ( ) ; } else if ( code = = Type . MARKER . code ) { return null ; } else if ( _NUM _NUM < = code & & code < = _NUM _NUM _NUM ) { application - specific typecodes return new Buffer ( readBytes ( ) ) ; } else { throw new RuntimeException ( _STR ) ; } } 
4682	public static SlaEventSubmitterBuilder getEventSubmitterBuilder ( Dataset dataset , Optional < Job > job , FileSystem fs ) { SlaEventSubmitterBuilder builder = SlaEventSubmitter . builder ( ) . datasetUrn ( dataset . getUrn ( ) ) . partition ( dataset . jobProps ( ) . getProp ( MRCompactor . COMPACTION _ JOB _ DEST _ PARTITION , _STR ) ) . dedupeStatus ( getOutputDedupeStatus ( dataset . jobProps ( ) ) ) ; long previousPublishTime = getPreviousPublishTime ( dataset , fs ) ; long upstreamTime = dataset . jobProps ( ) . getPropAsLong ( SlaEventKeys . UPSTREAM _ TS _ IN _ MILLI _ SECS _ KEY , - _NUM l ) ; long recordCount = getRecordCount ( job ) ; Previous publish only exists when this is a recompact job if ( previousPublishTime ! = - _NUM l ) { builder . previousPublishTimestamp ( Long . toString ( previousPublishTime ) ) ; } Upstream time is the logical time represented by the compaction input directory if ( upstreamTime ! = - _NUM l ) { builder . upstreamTimestamp ( Long . toString ( upstreamTime ) ) ; } if ( recordCount ! = - _NUM l ) { builder . recordCount ( Long . toString ( recordCount ) ) ; } return builder ; } 
4683	public void setWhiteBalance ( String value ) { String oldValue = get ( KEY _ WHITE _ BALANCE ) ; if ( same ( value , oldValue ) ) return ; set ( KEY _ WHITE _ BALANCE , value ) ; set ( KEY _ AUTO _ WHITEBALANCE _ LOCK , FALSE ) ; } 
4684	public byte [ ] getMac ( ) { if ( resultMac = = null ) { if ( operator . isMacBased ( ) ) { if ( additionalData ! = null ) { try { Streams . drain ( operator . getInputStream ( new ByteArrayInputStream ( additionalData . getAuthAttributes ( ) . getEncoded ( ASN _NUM Encoding . DER ) ) ) ) ; } catch ( IOException e ) { throw new IllegalStateException ( _STR + e . getMessage ( ) ) ; } } resultMac = operator . getMac ( ) ; } } return resultMac ; } 
4685	public BigInteger bigIntegerValue ( ) { return getBigIntegerValue ( ) ; } 
4686	private static String fixTracePath ( String tracePath ) { if ( tracePath = = null | | tracePath . charAt ( _NUM ) ! = ' / ' ) { final Context context = AppGlobals . getInitialApplication ( ) ; final File dir ; if ( context ! = null ) { dir = context . getExternalFilesDir ( null ) ; } else { dir = Environment . getExternalStorageDirectory ( ) ; } if ( tracePath = = null ) { tracePath = new File ( dir , DEFAULT _ TRACE _ BODY ) . getAbsolutePath ( ) ; } else { tracePath = new File ( dir , tracePath ) . getAbsolutePath ( ) ; } } if ( ! tracePath . endsWith ( DEFAULT _ TRACE _ EXTENSION ) ) { tracePath + = DEFAULT _ TRACE _ EXTENSION ; } return tracePath ; } 
4687	public int getShapeId ( ) { return ( int ) getCNvPr ( ) . getId ( ) ; } 
4688	public void prepareDocumentForEncryption ( PDDocument doc ) throws IOException { if ( keyLength = = _NUM _NUM _NUM ) { throw new IOException ( _STR ) ; } catch ( NoSuchAlgorithmException e ) { should never happen throw new RuntimeException ( e ) ; } key . init ( _NUM _NUM _NUM , new SecureRandom ( ) ) ; SecretKey sk = key . generateKey ( ) ; create the _NUM _NUM bytes seed System . arraycopy ( sk . getEncoded ( ) , _NUM , seed , _NUM , _NUM _NUM ) ; byte [ ] [ ] recipientsField = computeRecipientsField ( seed ) ; dictionary . setRecipients ( recipientsField ) ; int sha _NUM InputLength = seed . length ; for ( int j = _NUM ; j < dictionary . getRecipientsLength ( ) ; j + + ) { COSString string = dictionary . getRecipientStringAt ( j ) ; sha _NUM InputLength + = string . getBytes ( ) . length ; } byte [ ] sha _NUM Input = new byte [ sha _NUM InputLength ] ; System . arraycopy ( seed , _NUM , sha _NUM Input , _NUM , _NUM _NUM ) ; int sha _NUM InputOffset = _NUM _NUM ; for ( int j = _NUM ; j < dictionary . getRecipientsLength ( ) ; j + + ) { COSString string = dictionary . getRecipientStringAt ( j ) ; System . arraycopy ( string . getBytes ( ) , _NUM , sha _NUM Input , sha _NUM InputOffset , string . getBytes ( ) . length ) ; sha _NUM InputOffset + = string . getBytes ( ) . length ; } MessageDigest sha _NUM = MessageDigests . getSHA _NUM ( ) ; byte [ ] mdResult = sha _NUM . digest ( sha _NUM Input ) ; this . encryptionKey = new byte [ this . keyLength / _NUM ] ; System . arraycopy ( mdResult , _NUM , this . encryptionKey , _NUM , this . keyLength / _NUM ) ; doc . setEncryptionDictionary ( dictionary ) ; doc . getDocument ( ) . setEncryptionDictionary ( dictionary . getCOSDictionary ( ) ) ; } catch ( GeneralSecurityException e ) { throw new IOException ( e ) ; } } 
4689	public static URI getProxyUri ( URI originalUri , URI proxyUri , ApplicationId id ) { try { String path = getPath ( id , originalUri = = null ? _STR + originalUri , e ) ; } } 
4690	private static OpenCmsTestResourceFilter getFilterImportExportOverwrite ( ) { OpenCmsTestResourceConfigurableFilter filter = getFilterImportExport ( ) ; filter . disableStructureIdTest ( ) ; filter . disableResourceIdTest ( ) ; filter . disableDateLastModifiedSecTest ( ) ; filter . disableDateCreatedSecTest ( ) ; filter . disableDateContentTest ( ) ; return filter ; } 
4691	public DescribeVpcClassicLinkDnsSupportResult withVpcs ( ClassicLinkDnsSupport . . . vpcs ) { if ( getVpcs ( ) = = null ) setVpcs ( new java . util . ArrayList < ClassicLinkDnsSupport > ( vpcs . length ) ) ; for ( ClassicLinkDnsSupport value : vpcs ) { getVpcs ( ) . add ( value ) ; } return this ; } 
4692	public static < T > boolean isEqual ( Iterable < T > first , Iterable < T > second ) { Relies on elements from the iterator arriving in the same order . For every element in first , check elements on the second iterable by marking the ones seen that have been found . Then ensure that all the elements of the second have been seen as well . int firstSize = Iterables . size ( first ) ; int secondSize = Iterables . size ( second ) ; boolean [ ] usedSecondArray = new boolean [ secondSize ] ; Iterator < T > firstIterator = first . iterator ( ) ; while ( firstIterator . hasNext ( ) ) { T firstValue = firstIterator . next ( ) ; boolean foundFirstValue = false ; Iterator < T > secondIterator = second . iterator ( ) ; for ( int i = _NUM ; i < usedSecondArray . length ; + + i ) { T secondValue = secondIterator . next ( ) ; if ( ! usedSecondArray [ i ] ) { if ( firstValue . equals ( secondValue ) ) { usedSecondArray [ i ] = true ; foundFirstValue = true ; break ; } } } if ( ! foundFirstValue ) { LOG . error ( _STR ) ; return false ; } } return true ; } 
4693	public CmsADEConfigData parseSitemapConfiguration ( String basePath , CmsResource configRes ) throws CmsException { LOG . info ( _STR + configRes . getRootPath ( ) ) ; CmsFile configFile = m _ cms . readFile ( configRes ) ; CmsXmlContent content = CmsXmlContentFactory . unmarshal ( m _ cms , configFile ) ; return parseConfiguration ( basePath , content ) ; } 
4694	private static void writeFieldToBuffer ( int fieldNumber , MllpSocketBuffer mllpSocketBuffer , byte [ ] hl _NUM MessageBytes , List < Integer > fieldSeparatorIndexes ) { mllpSocketBuffer . write ( hl _NUM MessageBytes , fieldSeparatorIndexes . get ( fieldNumber ) , fieldSeparatorIndexes . get ( fieldNumber + _NUM ) - fieldSeparatorIndexes . get ( fieldNumber ) ) ; } 
4695	protected void handleMesosFailure ( String taskId ) { int attempt = TaskUtils . getAttemptForTaskId ( taskId ) ; BaseContainer container = containersInfo . get ( TaskUtils . getContainerIndexForTaskId ( taskId ) ) ; boolean hasAttemptsLeft = attempt < container . retries ; if ( hasAttemptsLeft ) { LOG . warning ( String . format ( _STR + attempt ) ; } } 
4696	public static void assertEquals ( File expected , File actual ) { assertNotNull ( expected ) ; assertNotNull ( actual ) ; assertTrue ( _STR , actual . canRead ( ) ) ; try { TreeMap < String , ByteArrayOutputStream > file _NUM = decompress ( expected ) ; TreeMap < String , ByteArrayOutputStream > file _NUM = decompress ( actual ) ; equals ( file _NUM , file _NUM ) ; } catch ( IOException e ) { throw new AssertionFailedError ( e . toString ( ) ) ; } } 
4697	public String toString ( ) { return buffer . toString ( ) ; return getCoveredText ( ) ; } 
4698	public String toString ( ) { if ( springsChanged ) { registerComponents ( horizontalGroup , HORIZONTAL ) ; registerComponents ( verticalGroup , VERTICAL ) ; } StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( _STR , VERTICAL ) ; return buffer . toString ( ) ; } 
4699	private void displayPermissions ( List < MyPermissionGroupInfo > groups , LinearLayout permListView , int which , boolean showRevokeUI ) { permListView . removeAllViews ( ) ; int spacing = ( int ) ( _NUM * mContext . getResources ( ) . getDisplayMetrics ( ) . density ) ; for ( int i = _NUM ; i < groups . size ( ) ; i + + ) { MyPermissionGroupInfo grp = groups . get ( i ) ; final List < MyPermissionInfo > perms = getPermissionList ( grp , which ) ; for ( int j = _NUM ; j < perms . size ( ) ; j + + ) { MyPermissionInfo perm = perms . get ( j ) ; View view = getPermissionItemView ( grp , perm , j = = _NUM , which ! = WHICH _ NEW ? mNewPermPrefix : null , showRevokeUI ) ; LinearLayout . LayoutParams lp = new LinearLayout . LayoutParams ( ViewGroup . LayoutParams . MATCH _ PARENT , ViewGroup . LayoutParams . WRAP _ CONTENT ) ; if ( j = = _NUM ) { lp . topMargin = spacing ; } if ( j = = grp . mAllPermissions . size ( ) - _NUM ) { lp . bottomMargin = spacing ; } if ( permListView . getChildCount ( ) = = _NUM ) { lp . topMargin * = _NUM ; } permListView . addView ( view , lp ) ; } } } 
4700	public void setLogFilePermission ( String fileName ) throws IOException { File file = new File ( logRootDir , fileName ) . getCanonicalFile ( ) ; boolean runAsUser = ObjectReader . getBoolean ( stormConf . get ( SUPERVISOR _ RUN _ WORKER _ AS _ USER ) , false ) ; File parent = new File ( logRootDir , fileName ) . getParentFile ( ) ; Optional < File > mdFile = ( parent = = null ) ? Optional . empty ( ) : getMetadataFileForWorkerLogDir ( parent ) ; Optional < String > topoOwner = mdFile . isPresent ( ) ? Optional . of ( getTopologyOwnerFromMetadataFile ( mdFile . get ( ) . getCanonicalPath ( ) ) ) : Optional . empty ( ) ; if ( runAsUser & & topoOwner . isPresent ( ) & & file . exists ( ) & & ! Files . isReadable ( file . toPath ( ) ) ) { LOG . debug ( _STR + fileName ) ; } } 
4701	final void performAppGcsIfAppropriateLocked ( ) { if ( canGcNowLocked ( ) ) { performAppGcsLocked ( ) ; return ; } Still not idle , wait some more . scheduleAppGcsLocked ( ) ; } 
4702	public void createSubsampleWithoutReplacement ( Random random , int origSize , int sampleSize ) { if ( sampleSize > origSize ) { sampleSize = origSize ; System . err . println ( _STR ) ; } Vector < Integer > indices = new Vector < Integer > ( origSize ) ; Vector < Integer > indicesNew = new Vector < Integer > ( sampleSize ) ; generate list of all indices to draw from for ( int i = _NUM ; i < origSize ; i + + ) indices . add ( i ) ; draw X random indices ( selected ones get removed before next draw ) for ( int i = _NUM ; i < sampleSize ; i + + ) { int index = random . nextInt ( indices . size ( ) ) ; indicesNew . add ( indices . get ( index ) ) ; indices . remove ( index ) ; } if ( getInvertSelection ( ) ) indicesNew = indices ; else Collections . sort ( indicesNew ) ; for ( int i = _NUM ; i < indicesNew . size ( ) ; i + + ) push ( ( Instance ) getInputFormat ( ) . instance ( indicesNew . get ( i ) ) . copy ( ) ) ; clean up indices . clear ( ) ; indicesNew . clear ( ) ; indices = null ; indicesNew = null ; } 
4703	public void setSwitchTextAppearance ( Context context , @ StyleRes int resid ) { TypedArray appearance = context . obtainStyledAttributes ( resid , com . android . internal . R . styleable . TextAppearance ) ; ColorStateList colors ; int ts ; colors = appearance . getColorStateList ( com . android . internal . R . styleable . TextAppearance _ textColor ) ; if ( colors ! = null ) { mTextColors = colors ; } else { If no color set in TextAppearance , default to the view ' s textColor mTextColors = getTextColors ( ) ; } ts = appearance . getDimensionPixelSize ( com . android . internal . R . styleable . TextAppearance _ textSize , _NUM ) ; if ( ts ! = _NUM ) { if ( ts ! = mTextPaint . getTextSize ( ) ) { mTextPaint . setTextSize ( ts ) ; requestLayout ( ) ; } } int typefaceIndex , styleIndex ; typefaceIndex = appearance . getInt ( com . android . internal . R . styleable . TextAppearance _ typeface , - _NUM ) ; styleIndex = appearance . getInt ( com . android . internal . R . styleable . TextAppearance _ textStyle , - _NUM ) ; setSwitchTypefaceByIndex ( typefaceIndex , styleIndex ) ; boolean allCaps = appearance . getBoolean ( com . android . internal . R . styleable . TextAppearance _ textAllCaps , false ) ; if ( allCaps ) { mSwitchTransformationMethod = new AllCapsTransformationMethod ( getContext ( ) ) ; mSwitchTransformationMethod . setLengthChangesAllowed ( true ) ; } else { mSwitchTransformationMethod = null ; } appearance . recycle ( ) ; } 
4704	public void setGradientsAccumulator ( GradientsAccumulator accumulator ) { if ( ! initCalled ) init ( ) ; solver . getOptimizer ( ) . setGradientsAccumulator ( accumulator ) ; } 
4705	public Iterator < Quad > find ( Node g , Node s , Node p , Node o ) { if ( Quad . isDefaultGraph ( g ) ) return findInDftGraph ( s , p , o ) ; if ( ! isWildcard ( g ) ) return findNG ( g , s , p , o ) ; return findAny ( s , p , o ) ; } 
4706	public boolean isDataExist ( String dataValue , UUID templateId , String fieldColName ) { boolean isExist = false ; if ( templateId = = null ) { return isExist ; } String tableName = TableRuleManager . getInstance ( ) . getDataTableName ( templateId ) ; Connection conn = null ; PreparedStatement pstm = null ; ResultSet rs = null ; try { conn = DbPoolConnection . getInstance ( ) . getReadConnection ( ) ; pstm = conn . prepareStatement ( _STR , e ) ; } finally { DbPoolConnection . getInstance ( ) . closeAll ( rs , pstm , conn ) ; return isExist ; } } 
4707	private void writeObject ( ObjectOutputStream stream ) throws IOException { stream . defaultWriteObject ( ) ; stream . writeInt ( this . store . size ( ) ) ; Set keys = this . store . keySet ( ) ; Iterator iterator = keys . iterator ( ) ; while ( iterator . hasNext ( ) ) { Comparable key = ( Comparable ) iterator . next ( ) ; stream . writeObject ( key ) ; Paint paint = getPaint ( key ) ; SerialUtilities . writePaint ( paint , stream ) ; } } 
4708	public Font getItemLabelFont ( int row , int column ) { Font result = this . itemLabelFont ; if ( result = = null ) { result = getSeriesItemLabelFont ( row ) ; if ( result = = null ) { result = this . baseItemLabelFont ; } } return result ; } 
4709	public RDD < String > toRDDStringIJV ( ) { return MLContextConversionUtil . matrixObjectToRDDStringIJV ( matrixObject ) ; } 
4710	public ComponentSelector slideUpAndWait ( int duration ) { for ( Component c : this ) { c . setHeight ( _NUM ) ; } getParent ( ) . animateUnlayoutAndWait ( duration , _NUM _NUM _NUM ) ; return this ; } 
4711	public TokenBuilder norm ( ) { return add ( NORM ) ; } 
4712	private static void dirToTarArchiveOutputStreamRecursive ( FileStatus dirFileStatus , FileSystem fs , Optional < Path > destDir , TarArchiveOutputStream tarArchiveOutputStream ) throws IOException { Preconditions . checkState ( fs . isDirectory ( dirFileStatus . getPath ( ) ) ) ; Path dir = destDir . isPresent ( ) ? new Path ( destDir . get ( ) , dirFileStatus . getPath ( ) . getName ( ) ) : new Path ( dirFileStatus . getPath ( ) . getName ( ) ) ; dirToTarArchiveOutputStream ( dir , tarArchiveOutputStream ) ; for ( FileStatus childFileStatus : fs . listStatus ( dirFileStatus . getPath ( ) ) ) { Path childFile = new Path ( dir , childFileStatus . getPath ( ) . getName ( ) ) ; if ( fs . isDirectory ( childFileStatus . getPath ( ) ) ) { dirToTarArchiveOutputStreamRecursive ( childFileStatus , fs , Optional . of ( childFile ) , tarArchiveOutputStream ) ; } else { try ( FSDataInputStream fsDataInputStream = fs . open ( childFileStatus . getPath ( ) ) ) { fileToTarArchiveOutputStream ( childFileStatus , fsDataInputStream , childFile , tarArchiveOutputStream ) ; } } } } 
4713	public static boolean filter ( ) { load answer patterns MsgPrinter . printLoadingPatterns ( ) ; if ( ! loadPatterns ( _STR ) ; } 
4714	public String launch ( CmsObject cms , Map parameters ) throws Exception { CmsNotificationCandidates candidates = new CmsNotificationCandidates ( cms ) ; return candidates . notifyResponsibles ( ) ; } 
4715	public void addMetric ( String metricName , Double metricValue ) { if ( metricName = = null ) { log . warn ( _STR ) ; return ; } globalMetrics . put ( metricName , metricValue ) ; saveMetrics ( ) ; } 
4716	private int reselectSelector ( int degrees , boolean isInnerCircle , boolean forceToVisibleValue , boolean forceDrawDot ) { if ( degrees = = - _NUM ) { return - _NUM ; } int currentShowing = getCurrentItemShowing ( ) ; int stepSize ; boolean allowFineGrained = ! forceToVisibleValue & & ( currentShowing = = MINUTE _ INDEX ) ; if ( allowFineGrained ) { degrees = snapPrefer _NUM _NUM s ( degrees ) ; } else { degrees = snapOnly _NUM _NUM s ( degrees , _NUM ) ; } RadialSelectorView radialSelectorView ; if ( currentShowing = = HOUR _ INDEX ) { radialSelectorView = mHourRadialSelectorView ; stepSize = HOUR _ VALUE _ TO _ DEGREES _ STEP _ SIZE ; } else { radialSelectorView = mMinuteRadialSelectorView ; stepSize = MINUTE _ VALUE _ TO _ DEGREES _ STEP _ SIZE ; } radialSelectorView . setSelection ( degrees , isInnerCircle , forceDrawDot ) ; radialSelectorView . invalidate ( ) ; if ( currentShowing = = HOUR _ INDEX ) { if ( mIs _NUM _NUM HourMode ) { if ( degrees = = _NUM & & isInnerCircle ) { degrees = _NUM _NUM _NUM ; } else if ( degrees = = _NUM _NUM _NUM & & ! isInnerCircle ) { degrees = _NUM ; } } else if ( degrees = = _NUM ) { degrees = _NUM _NUM _NUM ; } } else if ( degrees = = _NUM _NUM _NUM & & currentShowing = = MINUTE _ INDEX ) { degrees = _NUM ; } int value = degrees / stepSize ; if ( currentShowing = = HOUR _ INDEX & & mIs _NUM _NUM HourMode & & ! isInnerCircle & & degrees ! = _NUM ) { value + = _NUM _NUM ; } return value ; } 
4717	public Number getStartX ( int series , int item ) { Number startX = null ; Number x = this . dataset . getX ( series , item ) ; if ( x ! = null ) { startX = new Double ( x . doubleValue ( ) - ( getIntervalPositionFactor ( ) * getIntervalWidth ( ) ) ) ; } return startX ; } 
4718	public static XmlNegativeInteger parse ( java . net . URL u ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( XmlNegativeInteger ) XmlBeans . getContextTypeLoader ( ) . parse ( u , type , null ) ; } 
4719	private static Set < String > getOutputPorts ( Filter filter , boolean includeUnconnectedOptional ) { add ( connected ) ports from filter Set < String > ports = new HashSet < String > ( ) ; ports . addAll ( filter . getConnectedOutputPortMap ( ) . keySet ( ) ) ; add ( unconnected ) ports from signature HashMap < String , Signature . PortInfo > signaturePorts = filter . getSignature ( ) . getOutputPorts ( ) ; if ( signaturePorts ! = null ) { for ( Entry < String , Signature . PortInfo > e : signaturePorts . entrySet ( ) ) { if ( includeUnconnectedOptional | | e . getValue ( ) . isRequired ( ) ) { ports . add ( e . getKey ( ) ) ; } } } return ports ; } 
4720	public static void debug ( final Logger logger , final String pattern , final int argument ) { if ( logger . isDebugEnabled ( ) ) { forcedLog ( logger , Level . DEBUG , format ( pattern , valueOf ( argument ) ) ) ; } } 
4721	public void setFormValue ( Object value ) { if ( value = = null ) { value = _STR reset ( ) ; } else { CmsRadioButton button = m _ radioButtons . get ( value ) ; m _ group . selectButton ( button ) ; } } } 
4722	public static void setColfs ( IteratorSetting is , String indexColf , String docColfPrefix ) { setIndexColf ( is , indexColf ) ; setDocColfPrefix ( is , docColfPrefix ) ; } 
4723	public CharSequence getText ( ) { ClipData clip = getPrimaryClip ( ) ; if ( clip ! = null & & clip . getItemCount ( ) > _NUM ) { return clip . getItemAt ( _NUM ) . coerceToText ( mContext ) ; } return null ; } 
4724	public void setConfigurations ( Map < String , Config > configurations ) throws AmbariException { ConfigGroupEntity configGroupEntity = getConfigGroupEntity ( ) ; ClusterEntity clusterEntity = configGroupEntity . getClusterEntity ( ) ; only update the internal state after the configurations have been persisted persistConfigMapping ( clusterEntity , configGroupEntity , configurations ) ; m _ configurations = new ConcurrentHashMap < > ( configurations ) ; } 
4725	public void testClusteringManhattanSeq ( ) throws Exception { List < VectorWritable > points = getPointsWritable ( ) ; Configuration config = getConfiguration ( ) ; ClusteringTestUtils . writePointsToFile ( points , getTestTempFilePath ( _STR , points . size ( ) , count ) ; } 
4726	public static Properties getProperties ( String resource ) { if ( UtilValidate . isEmpty ( resource ) ) { return null ; } URL url = resolvePropertiesUrl ( resource , null ) ; return getProperties ( url ) ; } 
4727	public InfGraph bind ( Graph data ) throws ReasonerException { LPBackwardRuleInfGraph graph = new LPBackwardRuleInfGraph ( this , ruleStore , data , schemaGraph ) ; graph . setDerivationLogging ( recordDerivations ) ; return graph ; } 
4728	public void stopScan ( BluetoothAdapter adapter ) { int mask = BluetoothReceiver . DISCOVERY _ FINISHED _ FLAG ; if ( ! adapter . isEnabled ( ) ) { fail ( _STR , adapter . isDiscovering ( ) , firedFlags , mask ) ) ; } 
4729	public void setBackgroundDrawable ( Drawable drawable ) { mBackgroundDrawable = drawable ; if ( drawable ! = null ) { final int opacity = drawable . getOpacity ( ) ; mIsBackgroundTranslucent = ( opacity = = PixelFormat . TRANSLUCENT | | opacity = = PixelFormat . TRANSPARENT ) ; } updateBackground ( ) ; updateMessage ( ) ; } 
4730	synchronized void updateProfiles ( ParcelUuid [ ] uuids , ParcelUuid [ ] localUuids , Collection < LocalBluetoothProfile > profiles , Collection < LocalBluetoothProfile > removedProfiles , boolean isPanNapConnected , BluetoothDevice device ) { Copy previous profile list into removedProfiles removedProfiles . clear ( ) ; removedProfiles . addAll ( profiles ) ; if ( DEBUG ) { Log . d ( TAG , _STR + profiles . toString ( ) ) ; } } 
4731	public float getHyperfocalDistanceChecked ( ) { Key < Float > key = CameraCharacteristics . LENS _ INFO _ HYPERFOCAL _ DISTANCE ; Float hyperfocalDistance = getValueFromKeyNonNull ( key ) ; if ( hyperfocalDistance = = null ) { return - _NUM ; } if ( hasFocuser ( ) ) { float minFocusDistance = getMinimumFocusDistanceChecked ( ) ; checkTrueForKey ( key , String . format ( _STR , hyperfocalDistance , _NUM . _NUM f , minFocusDistance ) , hyperfocalDistance > _NUM & & hyperfocalDistance < = minFocusDistance ) ; } return hyperfocalDistance ; } 
4732	public boolean zoomIn ( ) { checkThread ( ) ; return mProvider . zoomIn ( ) ; } 
4733	public Object nextContent ( ) throws JSONException { char c ; StringBuffer sb ; do { c = next ( ) ; } while ( Character . isWhitespace ( c ) ) ; if ( c = = _NUM ) { return null ; } if ( c = = ' < ' ) { return XML . LT ; } sb = new StringBuffer ( ) ; for ( ; ; ) { if ( c = = ' < ' | | c = = _NUM ) { back ( ) ; return sb . toString ( ) . trim ( ) ; } if ( c = = ' & ' ) { sb . append ( nextEntity ( c ) ) ; } else { sb . append ( c ) ; } c = next ( ) ; } } 
4734	protected void serializeObject ( String name , Object o ) throws Exception { ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; ObjectOutputStream oout = new ObjectOutputStream ( bout ) ; oout . writeObject ( o ) ; oout . close ( ) ; m _ serializedMap . put ( name , bout . toByteArray ( ) ) ; } 
4735	public boolean goTo ( CalendarDay day , boolean animate , boolean setSelected , boolean forceScroll ) { Set the selected day if ( setSelected ) { mSelectedDay . set ( day ) ; } mTempDay . set ( day ) ; final int position = ( day . year - mController . getMinDate ( ) . year ) * SimpleMonthAdapter . MONTHS _ IN _ YEAR + ( day . month - mController . getMinDate ( ) . month ) ; View child ; int i = _NUM ; int top = _NUM ; Find a child that ' s completely in the view do { child = getChildAt ( i + + ) ; if ( child = = null ) { break ; } top = child . getTop ( ) ; if ( Log . isLoggable ( TAG , Log . DEBUG ) ) { Log . d ( TAG , _STR + position ) ; } and if so scroll to the month that contains it if ( position ! = selectedPosition | | forceScroll ) { setMonthDisplayed ( mTempDay ) ; mPreviousScrollState = OnScrollListener . SCROLL _ STATE _ FLING ; if ( animate & & Build . VERSION . SDK _ INT > = Build . VERSION _ CODES . HONEYCOMB ) { smoothScrollToPositionFromTop ( position , LIST _ TOP _ OFFSET , GOTO _ SCROLL _ DURATION ) ; return true ; } else { postSetSelection ( position ) ; } } else if ( setSelected ) { setMonthDisplayed ( mSelectedDay ) ; } return false ; } 
4736	public Builder setKeyValidityForOriginationEnd ( Date endDate ) { mKeyValidityForOriginationEnd = Utils . cloneIfNotNull ( endDate ) ; return this ; } 
4737	public void addCell ( Cell aCell , Point aLocation ) throws BadElementException { if ( aCell = = null ) throw new NullPointerException ( MessageLocalization . getComposedMessage ( _STR , String . valueOf ( aLocation . x ) , String . valueOf ( aLocation . y ) , String . valueOf ( aCell . getColspan ( ) ) , String . valueOf ( aCell . getRowspan ( ) ) ) ) ; if ( aCell . getBorder ( ) = = UNDEFINED ) aCell . setBorder ( defaultCell . getBorder ( ) ) ; aCell . fill ( ) ; placeCell ( rows , aCell , aLocation ) ; setCurrentLocationToNextValidPosition ( aLocation ) ; } 
4738	public boolean isCapturedViewUnder ( int x , int y ) { return isViewUnder ( mCapturedView , x , y ) ; } 
4739	public void testServerOptions ( ) throws Exception { final String TEST _ PATH = new File ( sockDir . getDir ( ) , _STR , e ) ; } } finally { serv . close ( ) ; Assert . assertFalse ( serv . isOpen ( ) ) ; } } 
4740	public < T > Callback < T > wrapCallbackErrors ( final String operationDescription , final Callback < T > callback , final Callback < ? > errorHandler , final Logger logger ) { return callbackBuilder ( ) . setCallback ( new Callback < T > ( ) { @ Override public void accept ( T t ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( _STR , operationDescription ) ; errorHandler . onTimeout ( ) ; } ) . build ( ) ; } 
4741	public String info ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( _STR ) ; return sb . toString ( ) ; } 
4742	public void setBorderColorBottom ( Color borderColorBottom ) { throwReadOnlyError ( ) ; } 
4743	public Client rebind ( final String graphOrTraversalSource ) { return alias ( graphOrTraversalSource ) ; } 
4744	public void processElement ( ProcessContext context ) throws Exception { Query query = context . element ( ) ; String namespace = options . getNamespace ( ) ; int userLimit = query . hasLimit ( ) ? query . getLimit ( ) . getValue ( ) : Integer . MAX _ VALUE ; boolean moreResults = true ; QueryResultBatch currentBatch = null ; while ( moreResults ) { Query . Builder queryBuilder = query . toBuilder ( ) ; queryBuilder . setLimit ( Int _NUM _NUM Value . newBuilder ( ) . setValue ( Math . min ( userLimit , QUERY _ BATCH _ LIMIT ) ) ) ; if ( currentBatch ! = null & & ! currentBatch . getEndCursor ( ) . isEmpty ( ) ) { queryBuilder . setStartCursor ( currentBatch . getEndCursor ( ) ) ; } RunQueryRequest request = makeRequest ( queryBuilder . build ( ) , namespace ) ; RunQueryResponse response = runQueryWithRetries ( request ) ; currentBatch = response . getBatch ( ) ; MORE _ RESULTS _ AFTER _ LIMIT is not implemented yet : https : so use result count to determine if more results might exist . int numFetch = currentBatch . getEntityResultsCount ( ) ; if ( query . hasLimit ( ) ) { verify ( userLimit > = numFetch , _STR , userLimit , numFetch , query . getLimit ( ) ) ; userLimit - = numFetch ; } output all the entities from the current batch . for ( EntityResult entityResult : currentBatch . getEntityResultsList ( ) ) { context . output ( entityResult . getEntity ( ) ) ; } Check if we have more entities to be read . moreResults = User - limit does not exist ( so userLimit = = MAX _ VALUE ) and / or has not been satisfied ( userLimit > _NUM ) & & All indications from the API are that there are / may be more results . ( ( numFetch = = QUERY _ BATCH _ LIMIT ) | | ( currentBatch . getMoreResults ( ) = = NOT _ FINISHED ) ) ; } } 
4745	public static < E > List < E > filter ( List < E > list , Predicate _NUM < E > predicate ) { sniff : { int hitCount = _NUM ; int missCount = _NUM ; for ( E e : list ) { if ( predicate . apply ( e ) ) { if ( missCount > _NUM ) { break sniff ; } + + hitCount ; } else { if ( hitCount > _NUM ) { break sniff ; } + + missCount ; } } if ( hitCount = = _NUM ) { return Collections . emptyList ( ) ; } if ( missCount = = _NUM ) { return list ; } } final List < E > list _NUM = new ArrayList < > ( list . size ( ) ) ; for ( E e : list ) { if ( predicate . apply ( e ) ) { list _NUM . add ( e ) ; } } return list _NUM ; } 
4746	public static < T > int unstableRemoveIf ( @ Nullable ArrayList < T > collection , @ NonNull java . util . function . Predicate < T > predicate ) { if ( collection = = null ) { return _NUM ; } final int size = collection . size ( ) ; int leftIdx = _NUM ; int rightIdx = size - _NUM ; while ( leftIdx < = rightIdx ) { Find the next element to remove moving left to right . while ( leftIdx < size & & ! predicate . test ( collection . get ( leftIdx ) ) ) { leftIdx + + ; } Find the next element to keep moving right to left . while ( rightIdx > leftIdx & & predicate . test ( collection . get ( rightIdx ) ) ) { rightIdx - - ; } if ( leftIdx > = rightIdx ) { Done . break ; } Collections . swap ( collection , leftIdx , rightIdx ) ; leftIdx + + ; rightIdx - - ; } leftIdx is now at the end . for ( int i = size - _NUM ; i > = leftIdx ; i - - ) { collection . remove ( i ) ; } return size - leftIdx ; } 
4747	public void saveRecentTimezone ( String id ) { SharedPreferences prefs = mContext . getSharedPreferences ( SHARED _ PREFS _ NAME , Context . MODE _ PRIVATE ) ; String recentsString = prefs . getString ( KEY _ RECENT _ TIMEZONES , null ) ; if ( recentsString = = null ) { recentsString = id ; } else { De - dup LinkedHashSet < String > recents = new LinkedHashSet < String > ( ) ; for ( String tzId : recentsString . split ( RECENT _ TIMEZONES _ DELIMITER ) ) { if ( ! recents . contains ( tzId ) & & ! id . equals ( tzId ) ) { recents . add ( tzId ) ; } } Iterator < String > it = recents . iterator ( ) ; while ( recents . size ( ) > = MAX _ RECENT _ TIMEZONES ) { if ( ! it . hasNext ( ) ) { break ; } it . next ( ) ; it . remove ( ) ; } recents . add ( id ) ; StringBuilder builder = new StringBuilder ( ) ; boolean first = true ; for ( String recent : recents ) { if ( first ) { first = false ; } else { builder . append ( RECENT _ TIMEZONES _ DELIMITER ) ; } builder . append ( recent ) ; } recentsString = builder . toString ( ) ; } prefs . edit ( ) . putString ( KEY _ RECENT _ TIMEZONES , recentsString ) . apply ( ) ; } 
4748	public void openFile ( File aFile , String charset ) throws IOException { if ( content ! = null ) { content . dispose ( ) ; content = null ; } throws IOException content = new BinaryContent ( aFile ) ; hexEditControl . setCharset ( charset ) ; hexEditControl . setContentProvider ( content ) ; } 
4749	public Double absoluteValue ( ) { return Math . sqrt ( real * real + imag * imag ) ; } 
4750	public boolean start ( ) { PrintService . throwIfNotCalledOnMainThread ( ) ; final int state = getInfo ( ) . getState ( ) ; if ( state = = PrintJobInfo . STATE _ QUEUED | | state = = PrintJobInfo . STATE _ BLOCKED ) { return setState ( PrintJobInfo . STATE _ STARTED , null ) ; } return false ; } 
4751	public void toStringSymlink ( ) throws IOException { boolean isdir = false ; Path symlink = new Path ( _STR ) ; FileStatus fileStatus = new FileStatus ( LENGTH , isdir , REPLICATION , BLKSIZE , MTIME , ATIME , PERMISSION , OWNER , GROUP , symlink , PATH ) ; validateToString ( fileStatus ) ; } 
4752	private static void run ( final byte [ ] data ) throws IOException { final TokenBuilder tb = new TokenBuilder ( ) ; final TextInput ti = new TextInput ( new IOContent ( data ) ) ; ti . read ( ) ; ti . reset ( ) ; for ( int b ; ( b = ti . read ( ) ) ! = - _NUM ; ) tb . add ( b ) ; try { ti . reset ( ) ; assertTrue ( _STR + data . length , data . length > = IO . BLOCKSIZE ) ; } } 
4753	public static boolean extendDown ( Spannable text , Layout layout ) { int end = getSelectionEnd ( text ) ; int line = layout . getLineForOffset ( end ) ; if ( line < layout . getLineCount ( ) - _NUM ) { int move ; if ( layout . getParagraphDirection ( line ) = = layout . getParagraphDirection ( line + _NUM ) ) { float h = layout . getPrimaryHorizontal ( end ) ; move = layout . getOffsetForHorizontal ( line + _NUM , h ) ; } else { move = layout . getLineStart ( line + _NUM ) ; } extendSelection ( text , move ) ; return true ; } else if ( end ! = text . length ( ) ) { extendSelection ( text , text . length ( ) ) ; return true ; } return true ; } 
4754	public static < T > Constructor < T > getMatchingAccessibleConstructor ( final Class < T > cls , final Class < ? > . . . parameterTypes ) { Validate . notNull ( cls , _STR ) final Constructor < T > constructor = ( Constructor < T > ) ctor ; result = constructor ; } } } } return result ; } 
4755	public static String findFocusWord ( Tree tree ) { try { Tree t = findFocusNode ( tree ) ; if ( t ! = null ) return TreeHelper . getLeaves ( t ) ; return null ; } catch ( Exception e ) { e . printStackTrace ( ) ; return null ; } } 
4756	protected void getLocalDestination ( LinkedList < String > args ) throws IOException { String pathString = ( args . size ( ) < _NUM ) ? Path . CUR _ DIR : args . removeLast ( ) ; try { dst = new PathData ( new URI ( pathString ) , getConf ( ) ) ; } catch ( URISyntaxException e ) { if ( Path . WINDOWS ) { Unlike URI , PathData knows how to parse Windows drive - letter paths . dst = new PathData ( pathString , getConf ( ) ) ; } else { throw new IOException ( _STR , e ) ; } } } 
4757	private final void write _ value _ field _ name _ helper ( IonReader reader ) { if ( this . isInStruct ( ) & & ! isFieldNameSet ( ) ) { SymbolToken tok = reader . getFieldNameSymbol ( ) ; if ( tok = = null ) { throw new IllegalStateException ( _STR ) ; } } 
4758	public Map < String , Component > getComponents ( ) { Map < String , Component > ret = new HashMap < > ( ) ; Map < String , SpoutSpec > spouts = topology . get _ spouts ( ) ; Map < String , Bolt > bolts = topology . get _ bolts ( ) ; Add in all of the components if ( spouts ! = null ) { for ( Map . Entry < String , SpoutSpec > entry : spouts . entrySet ( ) ) { String compId = entry . getKey ( ) ; if ( ! Utils . isSystemId ( compId ) ) { Component comp = new Component ( ComponentType . SPOUT , compId , componentToExecs ( compId ) ) ; ret . put ( compId , comp ) ; } } } if ( bolts ! = null ) { for ( Map . Entry < String , Bolt > entry : bolts . entrySet ( ) ) { String compId = entry . getKey ( ) ; if ( ! Utils . isSystemId ( compId ) ) { Component comp = new Component ( ComponentType . BOLT , compId , componentToExecs ( compId ) ) ; ret . put ( compId , comp ) ; } } } Link the components together if ( spouts ! = null ) { for ( Map . Entry < String , SpoutSpec > entry : spouts . entrySet ( ) ) { Component spout = ret . get ( entry . getKey ( ) ) ; for ( String parentId : getInputsTo ( entry . getValue ( ) . get _ common ( ) ) ) { ret . get ( parentId ) . addChild ( spout ) ; } } } if ( bolts ! = null ) { for ( Map . Entry < String , Bolt > entry : bolts . entrySet ( ) ) { Component bolt = ret . get ( entry . getKey ( ) ) ; for ( String parentId : getInputsTo ( entry . getValue ( ) . get _ common ( ) ) ) { ret . get ( parentId ) . addChild ( bolt ) ; } } } return ret ; } 
4759	public Image scaledHeight ( int height ) { float ratio = ( ( float ) height ) / ( ( float ) getHeight ( ) ) ; return scaled ( Math . max ( _NUM , ( int ) ( getWidth ( ) * ratio ) ) , height ) ; } 
4760	void setSelectionInt ( int position , boolean animate ) { if ( position ! = mOldSelectedPosition ) { mBlockLayoutRequests = true ; int delta = position - mSelectedPosition ; setNextSelectedPositionInt ( position ) ; layout ( delta , animate ) ; mBlockLayoutRequests = false ; } } 
4761	public final GF _NUM nPolynomial multiplyAndReduce ( GF _NUM nPolynomial b , GF _NUM nPolynomial g ) { return multiply ( b ) . reduce ( g ) ; } 
4762	public void testRequestMessageStatement ( ) throws Exception { if ( ! canTest ( ) ) { return ; } Update . Where update = update ( _STR ) ) ; session . close ( ) ; cluster . close ( ) ; } 
4763	public void addDisconnectedEventListener ( Executor executor , PeerDisconnectedEventListener listener ) { peerDisconnectedEventListeners . add ( new ListenerRegistration < > ( checkNotNull ( listener ) , executor ) ) ; for ( Peer peer : getConnectedPeers ( ) ) peer . addDisconnectedEventListener ( executor , listener ) ; for ( Peer peer : getPendingPeers ( ) ) peer . addDisconnectedEventListener ( executor , listener ) ; } 
4764	public void testRegionException ( ) throws InterruptedException , IOException { List < Row > batches = new ArrayList < > ( ) ; batches . add ( new Put ( Bytes . toBytes ( _STR ) ) ) ; assertEquals ( _NUM , result . size ( ) ) ; Cell cell = result . getColumnLatestCell ( FAMILY , null ) ; assertTrue ( Bytes . equals ( CellUtil . cloneValue ( cell ) , new byte [ _NUM _NUM ] ) ) ; } } 
4765	private void initToolTip ( JComponent c , int row , int column ) { String toolTipText = null ; if ( c . getPreferredSize ( ) . width > getCellRect ( row , column , false ) . width ) { toolTipText = getValueAt ( row , column ) . toString ( ) ; } c . setToolTipText ( toolTipText ) ; } 
4766	public void testFilterClauseAlwaysTrueWithAggGone _NUM ( ) { Logically equivalent to select sum ( _STR ; sql ( sql ) . queryContains ( druidChecker ( expectedQuery ) ) ; } 
4767	public IBinder getIBinder ( @ Nullable String key ) { unparcel ( ) ; Object o = mMap . get ( key ) ; if ( o = = null ) { return null ; } try { return ( IBinder ) o ; } catch ( ClassCastException e ) { typeWarning ( key , o , _STR , e ) ; return null ; } } 
4768	public void testBackupDeleteCommand ( ) throws Exception { LOG . info ( _STR ) > = _NUM ) ; } 
4769	public static String compose ( String op , Class < ? extends InputFormat > inf , String . . . path ) { final String infname = inf . getName ( ) ; StringBuffer ret = new StringBuffer ( op + ' ( ' ) ; for ( String p : path ) { compose ( infname , p , ret ) ; ret . append ( ' , ' ) ; } ret . setCharAt ( ret . length ( ) - _NUM , ' ) ' ) ; return ret . toString ( ) ; } 
4770	public GradientColor obtainForTheme ( Theme t ) { if ( t = = null | | ! canApplyTheme ( ) ) { return this ; } final GradientColor clone = new GradientColor ( this ) ; clone . applyTheme ( t ) ; return clone ; } 
4771	public static Script pydml ( String scriptString ) { return pydmlFromString ( scriptString ) ; } 
4772	public static void unzipGzips ( String inFileName , String outFileName ) throws Exception { GZIPInputStream in = null ; FileOutputStream out = null ; try { if ( ! FileUtils . getFileExtension ( inFileName ) . equalsIgnoreCase ( _STR ) ; } } } 
4773	public static long estimateMemory ( long nrows , long ncols , double sparsity ) { double lnnz = Math . max ( INIT _ CAPACITY , Math . ceil ( sparsity * nrows * ncols ) ) ; _NUM _NUM B overhead per array , int / int / double arr in nnz object + _NUM int fields double size = _NUM _NUM + _NUM ; rindexes array ( row indexes ) size + = _NUM _NUM + lnnz * _NUM d ; cindexes array ( column indexes ) size + = _NUM _NUM + lnnz * _NUM d ; values array ( non - zero values ) size + = _NUM _NUM + lnnz * _NUM d ; robustness for long overflows return ( long ) Math . min ( size , Long . MAX _ VALUE ) ; } 
4774	public static ClusterFixture standardCluster ( BaseDirTestWatcher dirTestWatcher ) { return builder ( dirTestWatcher ) . build ( ) ; } 
4775	public static double xbarVariance ( TransposeDataCollection sampleDataCollection , int populationM , double Nbar ) { double xbarVariance = _NUM . _NUM ; int sampleM = sampleDataCollection . size ( ) ; double mean = mean ( sampleDataCollection ) ; for ( Map . Entry < Object , FlatDataCollection > entry : sampleDataCollection . entrySet ( ) ) { double sum = _NUM . _NUM ; Iterator < Double > it = entry . getValue ( ) . iteratorDouble ( ) ; while ( it . hasNext ( ) ) { sum + = ( it . next ( ) - mean ) ; } xbarVariance + = sum * sum / ( sampleM - _NUM ) ; } xbarVariance * = ( populationM - sampleM ) / ( populationM * sampleM * Nbar * Nbar ) ; return xbarVariance ; } 
4776	public boolean isConvertibleToFBE ( ) throws RemoteException { mContext . enforceCallingOrSelfPermission ( Manifest . permission . CRYPT _ KEEPER , _STR ) ; return Integer . parseInt ( event . getMessage ( ) ) ! = _NUM ; } catch ( NativeDaemonConnectorException e ) { throw e . rethrowAsParcelableException ( ) ; } } 
4777	public static XmlNMTOKEN parse ( org . apache . xmlbeans . xml . stream . XMLInputStream xis ) throws org . apache . xmlbeans . XmlException , org . apache . xmlbeans . xml . stream . XMLStreamException { return ( XmlNMTOKEN ) XmlBeans . getContextTypeLoader ( ) . parse ( xis , type , null ) ; } 
4778	public void setDateExpired ( String resourcename , long dateExpired , boolean recursive ) throws CmsException { CmsResource resource = readResource ( resourcename , CmsResourceFilter . IGNORE _ EXPIRATION ) ; setDateExpired ( resource , dateExpired , recursive ) ; } 
4779	public static Evaluation evaluate ( String serializedDir , String [ ] features , String model ) { create data set with selected features from serialized results Dataset dataSet = createDataset ( features , serializedDir ) ; create learner for selected model ClassifierLearner learner = createLearner ( model ) ; cross - validate model on data set RandomElement r = new RandomElement ( System . currentTimeMillis ( ) ) ; Splitter splitter = new CrossValSplitter ( r , NUM _ FOLDS ) ; CrossValidatedDataset cvDataset = new CrossValidatedDataset ( learner , dataSet , splitter , true ) ; Evaluation eval = cvDataset . getEvaluation ( ) ; return eval ; } 
4780	public boolean isOnSameNodeGroup ( Node node _NUM , Node node _NUM ) { if ( node _NUM = = null | | node _NUM = = null ) { return false ; } netlock . readLock ( ) . lock ( ) ; try { return isSameParents ( node _NUM , node _NUM ) ; } finally { netlock . readLock ( ) . unlock ( ) ; } } 
4781	public void addSchemaType ( String className , String defaultWidget ) { Class < ? > classClazz ; initialize class for schema type try { classClazz = Class . forName ( className ) ; } catch ( ClassNotFoundException e ) { LOG . error ( Messages . get ( ) . getBundle ( ) . key ( Messages . LOG _ XML _ CONTENT _ SCHEMA _ TYPE _ CLASS _ NOT _ FOUND _ _NUM , className ) , e ) ; return ; } create the schema type and add it to the internal list I _ CmsXmlSchemaType type ; try { type = addContentType ( classClazz ) ; } catch ( Exception e ) { LOG . error ( Messages . get ( ) . getBundle ( ) . key ( Messages . LOG _ INIT _ XML _ CONTENT _ SCHEMA _ TYPE _ CLASS _ ERROR _ _NUM , classClazz . getName ( ) ) , e ) ; return ; } add the editor widget for the schema type I _ CmsWidget widget = getWidget ( defaultWidget ) ; if ( widget = = null ) { LOG . error ( Messages . get ( ) . getBundle ( ) . key ( Messages . LOG _ INIT _ DEFAULT _ WIDGET _ FOR _ CONTENT _ TYPE _ _NUM , defaultWidget , type . getTypeName ( ) ) ) ; return ; } store the registered default widget m _ defaultWidgets . put ( type . getTypeName ( ) , widget ) ; if ( CmsLog . INIT . isInfoEnabled ( ) ) { CmsLog . INIT . info ( Messages . get ( ) . getBundle ( ) . key ( Messages . INIT _ ADD _ ST _ USING _ WIDGET _ _NUM , type . getTypeName ( ) , widget . getClass ( ) . getName ( ) ) ) ; } } 
4782	public org . bitcoinj . wallet . Protos . DeterministicKey . Builder getDeterministicKeyBuilder ( ) { bitField _NUM _ | = _NUM x _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM ; onChanged ( ) ; return getDeterministicKeyFieldBuilder ( ) . getBuilder ( ) ; } 
4783	private Container getLayeredPaneImpl ( ) { if ( layeredPane = = null ) { layeredPane = new Container ( new LayeredLayout ( ) ) ; Container parent = contentPane . wrapInLayeredPane ( ) ; adds the global layered pane layeredPane . add ( new Container ( ) ) ; parent . addComponent ( layeredPane ) ; revalidate ( ) ; } return layeredPane ; } 
4784	public String dump ( ) { StringBuilder builder = new StringBuilder ( length * _NUM ) ; int i = addBytesToBuilder ( builder ) ; int end = i - _NUM ; if ( end % _NUM _NUM ! = _NUM _NUM ) { int begin = end & ~ _NUM xf ; for ( int j = _NUM ; j < ( _NUM _NUM - ( end % _NUM _NUM ) ) ; j + + ) { builder . append ( _STR ) ; } builder . append ( ' ' ) ; builder . append ( toASCIIString ( begin , end ) ) ; builder . append ( ' \ n ' ) ; } return builder . toString ( ) ; } 
4785	private List < Stem > stem ( char [ ] word , int length , char [ ] flags , int recursionDepth ) { List < Stem > stems = new ArrayList < Stem > ( ) ; for ( int i = _NUM ; i < length ; i + + ) { List < HunspellAffix > suffixes = dictionary . lookupSuffix ( word , i , length - i ) ; if ( suffixes = = null ) { continue ; } for ( HunspellAffix suffix : suffixes ) { if ( hasCrossCheckedFlag ( suffix . getFlag ( ) , flags ) ) { int deAffixedLength = length - suffix . getAppend ( ) . length ( ) ; TODO : can we do this in - place ? String strippedWord = new StringBuilder ( ) . append ( word , _NUM , deAffixedLength ) . append ( suffix . getStrip ( ) ) . toString ( ) ; List < Stem > stemList = applyAffix ( strippedWord . toCharArray ( ) , strippedWord . length ( ) , suffix , recursionDepth ) ; for ( Stem stem : stemList ) { stem . addSuffix ( suffix ) ; } stems . addAll ( stemList ) ; } } } for ( int i = length - _NUM ; i > = _NUM ; i - - ) { List < HunspellAffix > prefixes = dictionary . lookupPrefix ( word , _NUM , i ) ; if ( prefixes = = null ) { continue ; } for ( HunspellAffix prefix : prefixes ) { if ( hasCrossCheckedFlag ( prefix . getFlag ( ) , flags ) ) { int deAffixedStart = prefix . getAppend ( ) . length ( ) ; int deAffixedLength = length - deAffixedStart ; String strippedWord = new StringBuilder ( ) . append ( prefix . getStrip ( ) ) . append ( word , deAffixedStart , deAffixedLength ) . toString ( ) ; List < Stem > stemList = applyAffix ( strippedWord . toCharArray ( ) , strippedWord . length ( ) , prefix , recursionDepth ) ; for ( Stem stem : stemList ) { stem . addPrefix ( prefix ) ; } stems . addAll ( stemList ) ; } } } return stems ; } 
4786	public static void closeSilently ( Closeable . . . closeables ) { if closeables is null , return silently . if ( closeables = = null ) { return ; } for ( Closeable closeable : closeables ) { try { if ( closeable ! = null ) { closeable . close ( ) ; } } catch ( IOException e ) { System . err . println ( _STR + e ) ; } } } 
4787	final void removeListener ( Listener listener ) { if ( mListeners ! = null ) { for ( int i = _NUM ; i < mListeners . size ( ) ; ) { Listener l = mListeners . get ( i ) . get ( ) ; if ( l = = null ) { mListeners . remove ( i ) ; } else { if ( l = = listener ) { mListeners . remove ( i ) ; return ; } i + + ; } } } } 
4788	protected void scheduleReconnect ( ) { Runnable startRunnable = new Runnable ( ) { @ Override public void run ( ) { try { initNetworkConnection ( ) ; addNotificationListener ( ) ; } catch ( Exception e ) { LOG . warn ( _STR , URISupport . sanitizeUri ( mJmxEndpoint . getEndpointUri ( ) ) , mJmxEndpoint . getReconnectDelay ( ) ) ; getExecutor ( ) . schedule ( startRunnable , mJmxEndpoint . getReconnectDelay ( ) , TimeUnit . SECONDS ) ; } 
4789	public static boolean isSameLength ( final boolean [ ] array _NUM , final boolean [ ] array _NUM ) { return getLength ( array _NUM ) = = getLength ( array _NUM ) ; } 
4790	public String getEncoding ( ) { return ( String ) get ( ENCODING ) ; } 
4791	public void resetRtlProperties ( ) { resetResolvedLayoutDirection ( ) ; resetResolvedTextDirection ( ) ; resetResolvedTextAlignment ( ) ; resetResolvedPadding ( ) ; resetResolvedDrawables ( ) ; } 
4792	protected void onCursorChanged ( ) { notifyChanged ( ) ; } 
4793	protected void setupEventWriter ( JobId jobId , AMStartedEvent amStartedEvent ) throws IOException { if ( stagingDirPath = = null ) { LOG . error ( _STR , e ) ; throw e ; } } } String queueName = JobConf . DEFAULT _ QUEUE _ NAME ; if ( conf ! = null ) { queueName = conf . get ( MRJobConfig . QUEUE _ NAME , JobConf . DEFAULT _ QUEUE _ NAME ) ; } MetaInfo fi = new MetaInfo ( historyFile , logDirConfPath , writer , user , jobName , jobId , amStartedEvent . getForcedJobStateOnShutDown ( ) , queueName ) ; fi . getJobSummary ( ) . setJobId ( jobId ) ; fi . getJobSummary ( ) . setJobLaunchTime ( amStartedEvent . getStartTime ( ) ) ; fi . getJobSummary ( ) . setJobSubmitTime ( amStartedEvent . getSubmitTime ( ) ) ; fi . getJobIndexInfo ( ) . setJobStartTime ( amStartedEvent . getStartTime ( ) ) ; fi . getJobIndexInfo ( ) . setSubmitTime ( amStartedEvent . getSubmitTime ( ) ) ; fileMap . put ( jobId , fi ) ; } 
4794	public CmsPair < String , List < Object > > createUserQuery ( CmsUserSearchParameters searchParams , boolean countOnly ) { CmsSelectQuery select = new CmsSelectQuery ( ) ; TableAlias users = select . addTable ( _STR ) ; } else { select . addColumn ( users . getName ( ) ) ; } CmsOrganizationalUnit orgUnit = searchParams . getOrganizationalUnit ( ) ; boolean recursive = searchParams . recursiveOrgUnits ( ) ; if ( orgUnit ! = null ) { addOrgUnitCondition ( select , users , orgUnit , recursive ) ; } if ( searchParams . isFilterCore ( ) ) { select . addCondition ( createCoreCondition ( users ) ) ; } addAllowedOuCondition ( select , users , searchParams . getAllowedOus ( ) ) ; addFlagCondition ( select , users , searchParams . getFlags ( ) , searchParams . keepCoreUsers ( ) ) ; if ( orgUnit ! = null ) { addWebuserCondition ( select , orgUnit , users ) ; } addSearchFilterCondition ( select , users , searchParams ) ; addGroupCondition ( select , users , searchParams ) ; if ( ! countOnly ) { addSorting ( select , users , searchParams ) ; } CmsStatementBuilder builder = new CmsStatementBuilder ( ) ; select . visit ( builder ) ; return CmsPair . create ( builder . getQuery ( ) , builder . getParameters ( ) ) ; } 
4795	public void setAlign ( String value ) { setAttribute ( ATTR _ ALIGN , value ) ; } 
4796	 @ DELETE @ Consumes ( MediaType . WILDCARD ) @ Produces ( MediaType . APPLICATION _ JSON ) @ Path ( _STR ) final String id ) { if ( isReplicateRequest ( ) ) { return replicate ( HttpMethod . DELETE ) ; } final LabelEntity requestLabelEntity = new LabelEntity ( ) ; requestLabelEntity . setId ( id ) ; handle expects request ( usually from the cluster manager ) final Revision requestRevision = new Revision ( version = = null ? null : version . getLong ( ) , clientId . getClientId ( ) , id ) ; return withWriteLock ( serviceFacade , requestLabelEntity , requestRevision , lookup - > { final Authorizable label = lookup . getLabel ( id ) ; ensure write permission to the label label . authorize ( authorizer , RequestAction . WRITE , NiFiUserUtils . getNiFiUser ( ) ) ; ensure write permission to the parent process group label . getParentAuthorizable ( ) . authorize ( authorizer , RequestAction . WRITE , NiFiUserUtils . getNiFiUser ( ) ) ; } , null , ( revision , labelEntity ) - > { delete the specified label final LabelEntity entity = serviceFacade . deleteLabel ( revision , labelEntity . getId ( ) ) ; return generateOkResponse ( entity ) . build ( ) ; } ) ; } 
4797	public void checkSafeToUpdate ( ) { if ( ! activeInterpreters . isEmpty ( ) ) { ArrayList < LPInterpreterContext > toClose = new ArrayList < > ( ) ; for ( LPInterpreter interpreter : activeInterpreters ) { if ( interpreter . getContext ( ) instanceof LPTopGoalIterator ) { toClose . add ( interpreter . getContext ( ) ) ; } } for ( LPInterpreterContext aToClose : toClose ) { ( ( LPTopGoalIterator ) aToClose ) . close ( ) ; } } } 
4798	private File decompressPackage ( PackageParser . Package pkg ) { final File [ ] compressedFiles = getCompressedFiles ( pkg . codePath ) ; if ( compressedFiles = = null | | compressedFiles . length = = _NUM ) { if ( DEBUG _ COMPRESSION ) { Slog . i ( TAG , _STR + pkg . packageName ) ; ret = PackageManager . INSTALL _ FAILED _ INTERNAL _ ERROR ; } finally { IoUtils . closeQuietly ( handle ) ; } } if ( ret ! = PackageManager . INSTALL _ SUCCEEDED ) { if ( dstCodePath = = null | | ! dstCodePath . exists ( ) ) { return null ; } removeCodePathLI ( dstCodePath ) ; return null ; } return dstCodePath ; } 
4799	public static void poolingBackward ( MatrixBlock input , MatrixBlock dout , MatrixBlock outputBlock , ConvolutionParameters params , boolean performReluBackward , PoolingType poolType ) { params . input _NUM = input ; params . input _NUM = dout ; params . output = outputBlock ; if ( poolType = = PoolingType . MAX & & ( input . getNumColumns ( ) ! = params . C * params . H * params . W | | input . getNumRows ( ) ! = params . N ) ) { throw new DMLRuntimeException ( _STR ) ; if ( poolType = = PoolingType . AVG ) { fillIndexesArray ( params ) ; } else { if ( ! ( params . input _NUM . isInSparseFormat ( ) & & ! params . input _NUM . isInSparseFormat ( ) ) ) not needed for sparse - dense fillIndexesArray ( params ) ; } long nnz = execute ( LibMatrixDNNPooling . getPoolingBackwardWorkers ( params , performReluBackward , poolType ) , params ) ; post - processing : maintain nnz outputBlock . setNonZeros ( nnz ) ; outputBlock . examSparsity ( ) ; } 
4800	public void differentSessionLockDifferentBlocks ( ) throws Exception { TieredBlockStoreTestUtils . cache ( SESSION _ ID _NUM , BLOCK _ ID _NUM , BLOCK _ SIZE , mTestDir _NUM , mMetaManager , mEvictor ) ; TieredBlockStoreTestUtils . cache ( SESSION _ ID _NUM , BLOCK _ ID _NUM , BLOCK _ SIZE , mTestDir _NUM , mMetaManager , mEvictor ) ; long lockId _NUM = mBlockStore . lockBlock ( SESSION _ ID _NUM , BLOCK _ ID _NUM ) ; assertTrue ( Sets . difference ( mLockManager . getLockedBlocks ( ) , Sets . newHashSet ( BLOCK _ ID _NUM ) ) . isEmpty ( ) ) ; long lockId _NUM = mBlockStore . lockBlock ( SESSION _ ID _NUM , BLOCK _ ID _NUM ) ; assertNotEquals ( lockId _NUM , lockId _NUM ) ; assertTrue ( Sets . difference ( mLockManager . getLockedBlocks ( ) , Sets . newHashSet ( BLOCK _ ID _NUM , BLOCK _ ID _NUM ) ) . isEmpty ( ) ) ; mBlockStore . unlockBlock ( lockId _NUM ) ; assertTrue ( Sets . difference ( mLockManager . getLockedBlocks ( ) , Sets . newHashSet ( BLOCK _ ID _NUM ) ) . isEmpty ( ) ) ; mBlockStore . unlockBlock ( lockId _NUM ) ; assertTrue ( mLockManager . getLockedBlocks ( ) . isEmpty ( ) ) ; } 
4801	 @ POST @ Path ( GET _ NEW _ BLOCK _ ID _ FOR _ FILE ) @ ReturnType ( _STR ) ; return mFileSystemMaster . getNewBlockIdForFile ( new AlluxioURI ( path ) ) ; } } ) ; } 
4802	public static void end ( ) { getInstance ( ) . doEnd ( ) ; } 
4803	public final JPAParser . arithmetic _ factor _ return arithmetic _ factor ( ) throws RecognitionException { JPAParser . arithmetic _ factor _ return retval = new JPAParser . arithmetic _ factor _ return ( ) ; retval . start = input . LT ( _NUM ) ; Object root _ _NUM = null ; Token set _NUM _NUM _NUM = null ; JPAParser . arithmetic _ primary _ return arithmetic _ primary _NUM _NUM _NUM = null ; Object set _NUM _NUM _NUM _ tree = null ; try { JPA . g : _NUM _NUM _NUM : _NUM : ( ( ' + ' | ' - ' ) ? arithmetic _ primary ) JPA . g : _NUM _NUM _NUM : _NUM : ( ' + ' | ' - ' ) ? arithmetic _ primary { root _ _NUM = ( Object ) adaptor . nil ( ) ; JPA . g : _NUM _NUM _NUM : _NUM : ( ' + ' | ' - ' ) ? int alt _NUM _NUM = _NUM ; int LA _NUM _NUM _ _NUM = input . LA ( _NUM ) ; if ( ( ( LA _NUM _NUM _ _NUM > = _NUM _NUM & & LA _NUM _NUM _ _NUM < = _NUM _NUM ) ) ) { alt _NUM _NUM = _NUM ; } switch ( alt _NUM _NUM ) { case _NUM : JPA . g : { set _NUM _NUM _NUM = ( Token ) input . LT ( _NUM ) ; if ( ( input . LA ( _NUM ) > = _NUM _NUM & & input . LA ( _NUM ) < = _NUM _NUM ) ) { input . consume ( ) ; if ( state . backtracking = = _NUM ) adaptor . addChild ( root _ _NUM , ( Object ) adaptor . create ( set _NUM _NUM _NUM ) ) ; state . errorRecovery = false ; state . failed = false ; } else { if ( state . backtracking > _NUM ) { state . failed = true ; return retval ; } MismatchedSetException mse = new MismatchedSetException ( null , input ) ; throw mse ; } } break ; } pushFollow ( FOLLOW _ arithmetic _ primary _ in _ arithmetic _ factor _NUM _NUM _NUM _NUM ) ; arithmetic _ primary _NUM _NUM _NUM = arithmetic _ primary ( ) ; state . _ fsp - - ; if ( state . failed ) return retval ; if ( state . backtracking = = _NUM ) adaptor . addChild ( root _ _NUM , arithmetic _ primary _NUM _NUM _NUM . getTree ( ) ) ; } retval . stop = input . LT ( - _NUM ) ; if ( state . backtracking = = _NUM ) { retval . tree = ( Object ) adaptor . rulePostProcessing ( root _ _NUM ) ; adaptor . setTokenBoundaries ( retval . tree , retval . start , retval . stop ) ; } } catch ( RecognitionException re ) { reportError ( re ) ; recover ( input , re ) ; retval . tree = ( Object ) adaptor . errorNode ( input , retval . start , input . LT ( - _NUM ) , re ) ; } finally { } return retval ; } 
4804	private void abortOperationsForStage ( Stage stage ) { long now = System . currentTimeMillis ( ) ; for ( String hostName : stage . getHosts ( ) ) { List < ExecutionCommandWrapper > commandWrappers = stage . getExecutionCommands ( hostName ) ; for ( ExecutionCommandWrapper wrapper : commandWrappers ) { ExecutionCommand c = wrapper . getExecutionCommand ( ) ; transitionToFailedState ( stage . getClusterName ( ) , c . getServiceName ( ) , c . getRole ( ) , hostName , now , true ) ; } } Collection < HostRoleCommandEntity > abortedOperations = db . abortOperation ( stage . getRequestId ( ) ) ; for ( HostRoleCommandEntity command : abortedOperations ) { if ( command . getRoleCommand ( ) . equals ( RoleCommand . ACTIONEXECUTE ) ) { String clusterName = stage . getClusterName ( ) ; processActionDeath ( clusterName , command . getHostName ( ) , command . getRole ( ) . name ( ) ) ; } } } 
4805	private void addOrder ( PdfLayer parent , PdfArray arr , Map ocgmap ) { PdfObject obj ; PdfLayer layer ; for ( int i = _NUM ; i < arr . size ( ) ; i + + ) { obj = arr . getPdfObject ( i ) ; if ( obj . isIndirect ( ) ) { layer = ( PdfLayer ) ocgmap . get ( obj . toString ( ) ) ; layer . setOnPanel ( true ) ; registerLayer ( layer ) ; if ( parent ! = null ) { parent . addChild ( layer ) ; } if ( arr . size ( ) > i + _NUM & & arr . getPdfObject ( i + _NUM ) . isArray ( ) ) { i + + ; addOrder ( layer , ( PdfArray ) arr . getPdfObject ( i ) , ocgmap ) ; } } else if ( obj . isArray ( ) ) { PdfArray sub = ( PdfArray ) obj ; if ( sub . isEmpty ( ) ) return ; obj = sub . getPdfObject ( _NUM ) ; if ( obj . isString ( ) ) { layer = new PdfLayer ( obj . toString ( ) ) ; layer . setOnPanel ( true ) ; registerLayer ( layer ) ; if ( parent ! = null ) { parent . addChild ( layer ) ; } PdfArray array = new PdfArray ( ) ; for ( Iterator j = sub . listIterator ( ) ; j . hasNext ( ) ; ) { array . add ( ( PdfObject ) j . next ( ) ) ; } addOrder ( layer , array , ocgmap ) ; } else { addOrder ( parent , ( PdfArray ) obj , ocgmap ) ; } } } } 
4806	public AtomicValue < Integer > next ( ) throws Exception { MutableAtomicValue < Integer > result = new MutableAtomicValue < Integer > ( _NUM , _NUM ) ; if ( currentValue = = null ) { currentValue = number . add ( cacheFactor ) ; if ( ! currentValue . succeeded ( ) ) { currentValue = null ; result . succeeded = false ; return result ; } currentIndex = _NUM ; } result . succeeded = true ; result . preValue = currentValue . preValue ( ) + currentIndex ; result . postValue = result . preValue + _NUM ; if ( + + currentIndex > = cacheFactor ) { currentValue = null ; } return result ; } 
4807	protected void saveObject ( Object object ) { if ( m _ FileChooser = = null ) { createFileChooser ( ) ; } int returnVal = m _ FileChooser . showSaveDialog ( this ) ; if ( returnVal = = JFileChooser . APPROVE _ OPTION ) { File sFile = m _ FileChooser . getSelectedFile ( ) ; try { ObjectOutputStream oo = new ObjectOutputStream ( new BufferedOutputStream ( new FileOutputStream ( sFile ) ) ) ; oo . writeObject ( object ) ; oo . close ( ) ; } catch ( Exception ex ) { JOptionPane . showMessageDialog ( this , _STR , JOptionPane . ERROR _ MESSAGE ) ; } } } 
4808	public void initData ( GlyphTable glyphTable , TTFDataStream data , int leftSideBearing ) throws IOException { numberOfContours = data . readSignedShort ( ) ; xMin = data . readSignedShort ( ) ; yMin = data . readSignedShort ( ) ; xMax = data . readSignedShort ( ) ; yMax = data . readSignedShort ( ) ; boundingBox = new BoundingBox ( xMin , yMin , xMax , yMax ) ; if ( numberOfContours > = _NUM ) { create a simple glyph short x _NUM = ( short ) ( leftSideBearing - xMin ) ; glyphDescription = new GlyfSimpleDescript ( numberOfContours , data , x _NUM ) ; } else { create a composite glyph glyphDescription = new GlyfCompositeDescript ( data , glyphTable ) ; } } 
4809	public static Job createSubmittableJob ( Configuration conf , String [ ] args ) throws IOException { Triple < TableName , Scan , Path > arguments = ExportUtils . getArgumentsFromCommandLine ( conf , args ) ; String tableName = arguments . getFirst ( ) . getNameAsString ( ) ; Path outputDir = arguments . getThird ( ) ; Job job = Job . getInstance ( conf , conf . get ( JOB _ NAME _ CONF _ KEY , NAME + _STR + tableName ) ; job . setJarByClass ( Export . class ) ; Set optional scan parameters Scan s = arguments . getSecond ( ) ; IdentityTableMapper . initJob ( tableName , s , IdentityTableMapper . class , job ) ; No reducers . Just write straight to output files . job . setNumReduceTasks ( _NUM ) ; job . setOutputFormatClass ( SequenceFileOutputFormat . class ) ; job . setOutputKeyClass ( ImmutableBytesWritable . class ) ; job . setOutputValueClass ( Result . class ) ; job conf doesn ' t contain the conf so doesn ' t have a default fs . FileOutputFormat . setOutputPath ( job , outputDir ) ; return job ; } 
4810	protected void doSend ( boolean inOut , String destinationName , Destination destination , MessageCreator messageCreator , MessageSentCallback callback ) { CamelJmsTemplate template = ( CamelJmsTemplate ) ( inOut ? getInOutTemplate ( ) : getInOnlyTemplate ( ) ) ; if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( _STR + endpoint ) ; } } 
4811	public void cancel ( ) { cancelSoftwareAnimations ( ) ; endHardwareAnimations ( ) ; } 
4812	public void insert ( ) { No bucket should expire . List < TtlBucket > expired = getSortedExpiredBuckets ( BUCKET _NUM _ START ) ; Assert . assertTrue ( expired . isEmpty ( ) ) ; mBucketList . insert ( BUCKET _NUM _ FILE _NUM ) ; The first bucket should expire . expired = getSortedExpiredBuckets ( BUCKET _NUM _ END ) ; assertExpired ( expired , _NUM , BUCKET _NUM _ FILE _NUM ) ; mBucketList . insert ( BUCKET _NUM _ FILE _NUM ) ; Only the first bucket should expire . for ( long end = BUCKET _NUM _ START ; end < BUCKET _NUM _ END ; end + + ) { expired = getSortedExpiredBuckets ( end ) ; assertExpired ( expired , _NUM , BUCKET _NUM _ FILE _NUM , BUCKET _NUM _ FILE _NUM ) ; } mBucketList . insert ( BUCKET _NUM _ FILE ) ; All buckets should expire . expired = getSortedExpiredBuckets ( BUCKET _NUM _ END ) ; assertExpired ( expired , _NUM , BUCKET _NUM _ FILE _NUM , BUCKET _NUM _ FILE _NUM ) ; assertExpired ( expired , _NUM , BUCKET _NUM _ FILE ) ; } 
4813	public void addHeaderView ( View v , Object data , boolean isSelectable ) { if ( mAdapter ! = null & & ! ( mAdapter instanceof HeaderViewListAdapter ) ) { throw new IllegalStateException ( _STR ) ; } FixedViewInfo info = new FixedViewInfo ( ) ; info . view = v ; info . data = data ; info . isSelectable = isSelectable ; mHeaderViewInfos . add ( info ) ; we need to notify the observer if ( mAdapter ! = null & & mObserver ! = null ) { mObserver . onChanged ( ) ; } } 
4814	public static byte [ ] hash ( byte [ ] input , int offset , int length ) { MessageDigest digest = newDigest ( ) ; digest . update ( input , offset , length ) ; return digest . digest ( ) ; } 
4815	public ViewPropertyAnimator rotationBy ( float value ) { animatePropertyBy ( ROTATION , value ) ; return this ; } 
4816	private boolean classifyExample ( Instance example ) throws Exception { double classValue = - _NUM . _NUM ; for ( Enumeration e = m _ DecisionList . elements ( ) ; e . hasMoreElements ( ) & & classValue < _NUM . _NUM ; ) { RuleList rl = ( RuleList ) e . nextElement ( ) ; classValue = rl . classifyInstance ( example ) ; } if ( classValue > = _NUM . _NUM ) { example . setClassValue ( classValue ) ; return true ; } else { return false ; } } 
4817	public void stop ( ) { LOG . info ( _STR ) ; } } 
4818	public void setTargetNames ( Collection names ) throws IOException { targetNames = extractGeneralNames ( names ) ; } 
4819	public synchronized void close ( ) throws IOException { if ( clientRunning ) { closeAllFilesBeingWritten ( false ) ; clientRunning = false ; getLeaseRenewer ( ) . closeClient ( this ) ; close connections to the namenode closeConnectionToNamenode ( ) ; } } 
4820	public boolean isLe _NUM MPhySupported ( ) { if ( ! getLeAccess ( ) ) { return false ; } try { mServiceLock . readLock ( ) . lock ( ) ; if ( mService ! = null ) { return mService . isLe _NUM MPhySupported ( ) ; } } catch ( RemoteException e ) { Log . e ( TAG , _STR , e ) ; } finally { mServiceLock . readLock ( ) . unlock ( ) ; } return false ; } 
4821	private boolean supportsCamera _NUM ApiLocked ( String cameraId ) { return supportsCameraApiLocked ( cameraId , API _ VERSION _ _NUM ) ; } 
4822	public final void synpred _NUM _NUM _ JPA _NUM _ fragment ( ) throws RecognitionException { JPA _NUM . g : _NUM _NUM _NUM : _NUM _NUM : ( field ) JPA _NUM . g : _NUM _NUM _NUM : _NUM _NUM : field { pushFollow ( FOLLOW _ field _ in _ synpred _NUM _NUM _ JPA _NUM _NUM _NUM _NUM _NUM ) ; field ( ) ; state . _ fsp - - ; if ( state . failed ) return ; } } 
4823	public Set < Map . Entry < Character , Float > > entrySet ( ) { return new AbstractSet < Map . Entry < Character , Float > > ( ) { public int size ( ) { return _ map . size ( ) ; } public boolean isEmpty ( ) { return TCharFloatMapDecorator . this . isEmpty ( ) ; } public boolean contains ( Object o ) { if ( o instanceof Map . Entry ) { Object k = ( ( Map . Entry ) o ) . getKey ( ) ; Object v = ( ( Map . Entry ) o ) . getValue ( ) ; return TCharFloatMapDecorator . this . containsKey ( k ) & & TCharFloatMapDecorator . this . get ( k ) . equals ( v ) ; } else { return false ; } } public Iterator < Map . Entry < Character , Float > > iterator ( ) { return new Iterator < Map . Entry < Character , Float > > ( ) { private final TCharFloatIterator it = _ map . iterator ( ) ; public Map . Entry < Character , Float > next ( ) { it . advance ( ) ; char ik = it . key ( ) ; final Character key = ( ik = = _ map . getNoEntryKey ( ) ) ? null : wrapKey ( ik ) ; float iv = it . value ( ) ; final Float v = ( iv = = _ map . getNoEntryValue ( ) ) ? null : wrapValue ( iv ) ; return new Map . Entry < Character , Float > ( ) { private Float val = v ; public boolean equals ( Object o ) { return o instanceof Map . Entry & & ( ( Map . Entry ) o ) . getKey ( ) . equals ( key ) & & ( ( Map . Entry ) o ) . getValue ( ) . equals ( val ) ; } public Character getKey ( ) { return key ; } public Float getValue ( ) { return val ; } public int hashCode ( ) { return key . hashCode ( ) + val . hashCode ( ) ; } public Float setValue ( Float value ) { val = value ; return put ( key , value ) ; } } ; } public boolean hasNext ( ) { return it . hasNext ( ) ; } public void remove ( ) { it . remove ( ) ; } } ; } public boolean add ( Map . Entry < Character , Float > o ) { throw new UnsupportedOperationException ( ) ; } public boolean remove ( Object o ) { boolean modified = false ; if ( contains ( o ) ) { noinspection unchecked Character key = ( ( Map . Entry < Character , Float > ) o ) . getKey ( ) ; _ map . remove ( unwrapKey ( key ) ) ; modified = true ; } return modified ; } public boolean addAll ( Collection < ? extends Map . Entry < Character , Float > > c ) { throw new UnsupportedOperationException ( ) ; } public void clear ( ) { TCharFloatMapDecorator . this . clear ( ) ; } } ; } 
4824	public ECFieldElement sqrt ( ) { int [ ] x _NUM = this . x ; if ( Nat _NUM _NUM _NUM . isZero ( x _NUM ) | | Nat _NUM _NUM _NUM . isOne ( x _NUM ) ) { return this ; } int [ ] x _NUM = Nat _NUM _NUM _NUM . create ( ) ; SecP _NUM _NUM _NUM K _NUM Field . square ( x _NUM , x _NUM ) ; SecP _NUM _NUM _NUM K _NUM Field . multiply ( x _NUM , x _NUM , x _NUM ) ; int [ ] x _NUM = Nat _NUM _NUM _NUM . create ( ) ; SecP _NUM _NUM _NUM K _NUM Field . square ( x _NUM , x _NUM ) ; SecP _NUM _NUM _NUM K _NUM Field . multiply ( x _NUM , x _NUM , x _NUM ) ; int [ ] x _NUM = Nat _NUM _NUM _NUM . create ( ) ; SecP _NUM _NUM _NUM K _NUM Field . squareN ( x _NUM , _NUM , x _NUM ) ; SecP _NUM _NUM _NUM K _NUM Field . multiply ( x _NUM , x _NUM , x _NUM ) ; int [ ] x _NUM = x _NUM ; SecP _NUM _NUM _NUM K _NUM Field . squareN ( x _NUM , _NUM , x _NUM ) ; SecP _NUM _NUM _NUM K _NUM Field . multiply ( x _NUM , x _NUM , x _NUM ) ; int [ ] x _NUM _NUM = x _NUM ; SecP _NUM _NUM _NUM K _NUM Field . squareN ( x _NUM , _NUM , x _NUM _NUM ) ; SecP _NUM _NUM _NUM K _NUM Field . multiply ( x _NUM _NUM , x _NUM , x _NUM _NUM ) ; int [ ] x _NUM _NUM = Nat _NUM _NUM _NUM . create ( ) ; SecP _NUM _NUM _NUM K _NUM Field . squareN ( x _NUM _NUM , _NUM _NUM , x _NUM _NUM ) ; SecP _NUM _NUM _NUM K _NUM Field . multiply ( x _NUM _NUM , x _NUM _NUM , x _NUM _NUM ) ; int [ ] x _NUM _NUM = x _NUM _NUM ; SecP _NUM _NUM _NUM K _NUM Field . squareN ( x _NUM _NUM , _NUM _NUM , x _NUM _NUM ) ; SecP _NUM _NUM _NUM K _NUM Field . multiply ( x _NUM _NUM , x _NUM _NUM , x _NUM _NUM ) ; int [ ] x _NUM _NUM = Nat _NUM _NUM _NUM . create ( ) ; SecP _NUM _NUM _NUM K _NUM Field . squareN ( x _NUM _NUM , _NUM _NUM , x _NUM _NUM ) ; SecP _NUM _NUM _NUM K _NUM Field . multiply ( x _NUM _NUM , x _NUM _NUM , x _NUM _NUM ) ; int [ ] x _NUM _NUM _NUM = Nat _NUM _NUM _NUM . create ( ) ; SecP _NUM _NUM _NUM K _NUM Field . squareN ( x _NUM _NUM , _NUM _NUM , x _NUM _NUM _NUM ) ; SecP _NUM _NUM _NUM K _NUM Field . multiply ( x _NUM _NUM _NUM , x _NUM _NUM , x _NUM _NUM _NUM ) ; int [ ] x _NUM _NUM _NUM = x _NUM _NUM ; SecP _NUM _NUM _NUM K _NUM Field . squareN ( x _NUM _NUM _NUM , _NUM _NUM , x _NUM _NUM _NUM ) ; SecP _NUM _NUM _NUM K _NUM Field . multiply ( x _NUM _NUM _NUM , x _NUM _NUM , x _NUM _NUM _NUM ) ; int [ ] x _NUM _NUM _NUM = x _NUM _NUM ; SecP _NUM _NUM _NUM K _NUM Field . squareN ( x _NUM _NUM _NUM , _NUM , x _NUM _NUM _NUM ) ; SecP _NUM _NUM _NUM K _NUM Field . multiply ( x _NUM _NUM _NUM , x _NUM , x _NUM _NUM _NUM ) ; int [ ] t _NUM = x _NUM _NUM _NUM ; SecP _NUM _NUM _NUM K _NUM Field . squareN ( t _NUM , _NUM _NUM , t _NUM ) ; SecP _NUM _NUM _NUM K _NUM Field . multiply ( t _NUM , x _NUM _NUM , t _NUM ) ; SecP _NUM _NUM _NUM K _NUM Field . squareN ( t _NUM , _NUM , t _NUM ) ; SecP _NUM _NUM _NUM K _NUM Field . multiply ( t _NUM , x _NUM , t _NUM ) ; SecP _NUM _NUM _NUM K _NUM Field . squareN ( t _NUM , _NUM , t _NUM ) ; int [ ] t _NUM = x _NUM ; SecP _NUM _NUM _NUM K _NUM Field . square ( t _NUM , t _NUM ) ; return Nat _NUM _NUM _NUM . eq ( x _NUM , t _NUM ) ? new SecP _NUM _NUM _NUM K _NUM FieldElement ( t _NUM ) : null ; } 
4825	public void removeConditionalFormatting ( int index ) { checkIndex ( index ) ; _ sheet . getCTWorksheet ( ) . removeConditionalFormatting ( index ) ; } 
4826	public static byte [ ] getBytes ( String text ) { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; for ( char c : text . toCharArray ( ) ) { Integer code = UNI _ TO _ CODE . get ( c ) ; if ( code = = null ) { out . write ( _NUM ) ; } else { out . write ( code ) ; } } return out . toByteArray ( ) ; } 
4827	public void setTraversalAfter ( View root , int virtualDescendantId ) { enforceNotSealed ( ) ; final int rootAccessibilityViewId = ( root ! = null ) ? root . getAccessibilityViewId ( ) : UNDEFINED _ ITEM _ ID ; mTraversalAfter = makeNodeId ( rootAccessibilityViewId , virtualDescendantId ) ; } 
4828	public boolean isPending ( ) { return getConfidence ( ) . getConfidenceType ( ) = = TransactionConfidence . ConfidenceType . PENDING ; } 
4829	public synchronized void requestPermissionsIfNecessaryForResult ( @ Nullable Activity activity , @ NonNull String [ ] permissions , @ Nullable PermissionsResultAction action ) { if ( activity = = null ) { return ; } addPendingAction ( permissions , action ) ; if ( Build . VERSION . SDK _ INT < Build . VERSION _ CODES . M ) { doPermissionWorkBeforeAndroidM ( activity , permissions , action ) ; } else { List < String > permList = getPermissionsListToRequest ( activity , permissions , action ) ; if ( permList . isEmpty ( ) ) { if there is no permission to request , there is no reason to keep the action int the list removePendingAction ( action ) ; } else { String [ ] permsToRequest = permList . toArray ( new String [ permList . size ( ) ] ) ; mPendingRequests . addAll ( permList ) ; ActivityCompat . requestPermissions ( activity , permsToRequest , _NUM ) ; } } } 
4830	public static List < Size > getSortedSizesForFormat ( String cameraId , CameraManager cameraManager , int format , Size bound ) throws CameraAccessException { Comparator < Size > comparator = new SizeComparator ( ) ; Size [ ] sizes = getSupportedSizeForFormat ( format , cameraId , cameraManager ) ; List < Size > sortedSizes = null ; if ( bound ! = null ) { sortedSizes = new ArrayList < Size > ( _NUM ) ; for ( Size sz : sizes ) { if ( comparator . compare ( sz , bound ) < = _NUM ) { sortedSizes . add ( sz ) ; } } } else { sortedSizes = Arrays . asList ( sizes ) ; } assertTrue ( _STR , sortedSizes . size ( ) > _NUM ) ; Collections . sort ( sortedSizes , comparator ) ; Make it in descending order . Collections . reverse ( sortedSizes ) ; return sortedSizes ; } 
4831	public static void cursorIntToContentValues ( Cursor cursor , String field , ContentValues values , String key ) { int colIndex = cursor . getColumnIndex ( field ) ; if ( ! cursor . isNull ( colIndex ) ) { values . put ( key , cursor . getInt ( colIndex ) ) ; } else { values . put ( key , ( Integer ) null ) ; } } 
4832	public void agentAdded ( Agent agent , Environment source ) { String loc = getMapEnv ( ) . getAgentLocation ( agent ) ; updateTrack ( agent , loc ) ; } 
4833	protected final boolean performPreparation ( Runnable runnable ) { synchronized ( mState ) { if ( mState . current = = State . STATE _ OPEN ) { return false ; } else { runnable . run ( ) ; return true ; } } } 
4834	protected List < ? extends PromotableProduct > buildCrossSaleProductsList ( Product product , Category category , RelatedProductDTO relatedProductDTO ) { List < ? extends PromotableProduct > crossSaleProducts = null ; if ( product ! = null ) { if ( relatedProductDTO . isCumulativeResults ( ) ) { crossSaleProducts = product . getCumulativeCrossSaleProducts ( ) ; } else { crossSaleProducts = product . getCrossSaleProducts ( ) ; } } else if ( category ! = null ) { if ( relatedProductDTO . isCumulativeResults ( ) ) { crossSaleProducts = category . getCumulativeCrossSaleProducts ( ) ; } else { crossSaleProducts = category . getCrossSaleProducts ( ) ; } } removeCurrentProductFromReturnList ( product , crossSaleProducts ) ; crossSaleProducts = removeDuplicatesFromList ( crossSaleProducts ) ; return resizeList ( crossSaleProducts , relatedProductDTO . getQuantity ( ) ) ; } 
4835	public String getToolTip ( int offset , JTextComponent textComponent ) { this . textComponent = textComponent ; String word = getWord ( offset ) ; String rowText = getRowText ( offset ) ; if ( word ! = null ) { ToolTip toolTip ; switch ( word ) { case FONT _ OPERATOR : toolTip = new FontToolTip ( resources , rowText ) ; return toolTip . getToolTipText ( ) ; case STROKING _ COLOR : { String colorSpaceName = findColorSpace ( offset , STROKING _ COLOR _ SPACE ) ; if ( colorSpaceName ! = null ) { toolTip = new SCNToolTip ( resources , colorSpaceName , rowText ) ; return toolTip . getToolTipText ( ) ; } break ; } case NON _ STROKING _ COLOR : { String colorSpaceName = findColorSpace ( offset , NON _ STROKING _ COLOR _ SPACE ) ; if ( colorSpaceName ! = null ) { toolTip = new SCNToolTip ( resources , colorSpaceName , rowText ) ; return toolTip . getToolTipText ( ) ; } break ; } case RGB _ STROKING _ COLOR : case RGB _ NON _ STROKING _ COLOR : toolTip = new RGToolTip ( rowText ) ; return toolTip . getToolTipText ( ) ; case CMYK _ STROKING _ COLOR : case CMYK _ NON _ STROKING _ COLOR : toolTip = new KToolTip ( rowText ) ; return toolTip . getToolTipText ( ) ; case GRAY _ STROKING _ COLOR : case GRAY _ NON _ STROKING _ COLOR : toolTip = new GToolTip ( rowText ) ; return toolTip . getToolTipText ( ) ; default : break ; } } return null ; } 
4836	public Object readObject ( String name ) { name = fixFileName ( name ) ; Object o = cache . get ( name ) ; if ( o ! = null ) { return o ; } DataInputStream d = null ; try { if ( ! exists ( name ) ) { return null ; } d = new DataInputStream ( createInputStream ( name ) ) ; o = Util . readObject ( d ) ; d . close ( ) ; cache . put ( name , o ) ; return o ; } catch ( Exception err ) { Log . e ( err ) ; if ( Log . isCrashBound ( ) ) { Log . sendLog ( ) ; } Util . getImplementation ( ) . cleanup ( d ) ; return null ; } } 
4837	public void addAction ( int action ) { enforceNotSealed ( ) ; if ( ( action & ACTION _ TYPE _ MASK ) ! = _NUM ) { throw new IllegalArgumentException ( _STR + action ) ; } addStandardActions ( action ) ; } 
4838	public boolean deleteCloudFile ( String fileId ) { if ( CloudPersona . getCurrentPersona ( ) . getToken ( ) = = null ) { CloudPersona . createAnonymous ( ) ; } ConnectionRequest req = new ConnectionRequest ( ) ; req . setPost ( false ) ; req . setFailSilently ( true ) ; req . setUrl ( SERVER _ URL + _STR ) ; } return false ; } 
4839	 @ SuppressWarnings ( _STR + e . getMessage ( ) , e ) ; } catch ( Exception e ) { throw new ResponseParseException ( e . getMessage ( ) , e ) ; } } 
4840	public static TransportProvider create ( ) { AuthType authType = Configuration . getEnum ( PropertyKey . SECURITY _ AUTHENTICATION _ TYPE , AuthType . class ) ; switch ( authType ) { case NOSASL : return new NoSaslTransportProvider ( ) ; intended to fall through case SIMPLE : case CUSTOM : return new PlainSaslTransportProvider ( ) ; case KERBEROS : throw new UnsupportedOperationException ( _STR + authType . getAuthName ( ) ) ; } } 
4841	public < C , K extends C , V extends C > Object [ ] update ( Object [ ] btree , Comparator < C > comparator , Iterable < K > source , UpdateFunction < K , V > updateF ) { assert updateF ! = null ; NodeBuilder current = rootBuilder ; current . reset ( btree , POSITIVE _ INFINITY , updateF , comparator ) ; for ( K key : source ) { while ( true ) { if ( updateF . abortEarly ( ) ) { rootBuilder . clear ( ) ; return null ; } NodeBuilder next = current . update ( key ) ; if ( next = = null ) break ; we were in a subtree from a previous key that didn ' t contain this new key ; retry against the correct subtree current = next ; } } finish copying any remaining keys from the original btree while ( true ) { NodeBuilder next = current . finish ( ) ; if ( next = = null ) break ; current = next ; } updating with POSITIVE _ INFINITY means that current should be back to the root assert current . isRoot ( ) ; Object [ ] r = current . toNode ( ) ; current . clear ( ) ; builderRecycler . recycle ( this , recycleHandle ) ; return r ; } 
4842	public static boolean isSignedFloat ( String s ) { if ( isEmpty ( s ) ) return defaultEmptyOK ; try { float temp = Float . parseFloat ( s ) ; if ( temp < = _NUM ) return true ; return false ; } catch ( Exception e ) { return false ; } int startPos = _NUM ; if ( isSignedFloat . arguments . length > _NUM ) secondArg = isSignedFloat . arguments [ _NUM ] ; skip leading + or - if ( ( s . charAt ( _NUM ) = = _STR ) ) startPos = _NUM ; return ( isFloat ( s . substring ( startPos , s . length ) , secondArg ) ) } 
4843	public Bln isEmpty ( final ANode node ) throws QueryException { if ( node = = null ) return Bln . FALSE ; checkGeo ( node ) ; return Bln . TRUE ; } 
4844	public static void rotate ( List < ? > lst , int dist ) { List < Object > list = ( List < Object > ) lst ; int size = list . size ( ) ; Can ' t sensibly rotate an empty collection if ( size = = _NUM ) { return ; } normalize the distance int normdist ; if ( dist > _NUM ) { normdist = dist % size ; } else { normdist = size - ( ( dist % size ) * ( - _NUM ) ) ; } if ( normdist = = _NUM | | normdist = = size ) { return ; } if ( list instanceof RandomAccess ) { make sure each element gets juggled with the element in the position it is supposed to go to Object temp = list . get ( _NUM ) ; int index = _NUM , beginIndex = _NUM ; for ( int i = _NUM ; i < size ; i + + ) { index = ( index + normdist ) % size ; temp = list . set ( index , temp ) ; if ( index = = beginIndex ) { index = + + beginIndex ; temp = list . get ( beginIndex ) ; } } } else { int divideIndex = ( size - normdist ) % size ; List < Object > sublist _NUM = list . subList ( _NUM , divideIndex ) ; List < Object > sublist _NUM = list . subList ( divideIndex , size ) ; reverse ( sublist _NUM ) ; reverse ( sublist _NUM ) ; reverse ( list ) ; } } 
4845	protected void generateOutputProperties ( ) throws Exception { Enumeration keys ; String key ; String value ; String pkg ; StringTokenizer tok ; Vector classes ; HashSet names ; int i ; m _ OutputProperties = new Properties ( ) ; keys = m _ InputProperties . propertyNames ( ) ; while ( keys . hasMoreElements ( ) ) { key = keys . nextElement ( ) . toString ( ) ; if ( key . equals ( USE _ DYNAMIC ) ) continue ; tok = new StringTokenizer ( m _ InputProperties . getProperty ( key ) , _STR + value ) ; set value m _ OutputProperties . setProperty ( key , value ) ; } } 
4846	public void testLocalHBaseCluster ( ) throws Exception { TEST _ UTIL . startMiniCluster ( _NUM , _NUM , null , MyHMaster . class , MyHRegionServer . class ) ; Can we cast back to our master class ? try { int val = ( ( MyHMaster ) TEST _ UTIL . getHBaseCluster ( ) . getMaster ( _NUM ) ) . echo ( _NUM _NUM ) ; assertEquals ( _NUM _NUM , val ) ; } catch ( ClassCastException e ) { fail ( _STR ) ; } TEST _ UTIL . shutdownMiniCluster ( ) ; } 
4847	public void testWALCoprocessorReplay ( ) throws Exception { WAL replay is handled at HRegion : : replayRecoveredEdits ( ) , which is ultimately called by HRegion : : initialize ( ) TableName tableName = TableName . valueOf ( currentTest . getMethodName ( ) ) ; TableDescriptor htd = getBasic _NUM FamilyHTableDescriptor ( tableName ) ; MultiVersionConcurrencyControl mvcc = new MultiVersionConcurrencyControl ( ) ; final HRegionInfo hri = createBasic _NUM FamilyHRegionInfo ( Bytes . toString ( tableName ) ) ; final HRegionInfo hri _NUM = createBasic _NUM FamilyHRegionInfo ( Bytes . toString ( tableName ) ) ; RegionInfo hri = RegionInfoBuilder . newBuilder ( tableName ) . build ( ) ; final Path basedir = FSUtils . getTableDir ( this . hbaseRootDir , tableName ) ; deleteDir ( basedir ) ; fs . mkdirs ( new Path ( basedir , hri . getEncodedName ( ) ) ) ; final Configuration newConf = HBaseConfiguration . create ( this . conf ) ; WAL wal = new WAL ( this . fs , this . dir , this . oldLogDir , this . conf ) ; WAL wal = wals . getWAL ( null ) ; Put p = creatPutWith _NUM Families ( TEST _ ROW ) ; WALEdit edit = new WALEdit ( ) ; long now = EnvironmentEdgeManager . currentTime ( ) ; final int countPerFamily = _NUM _NUM _NUM _NUM ; NavigableMap < byte [ ] , Integer > scopes = new TreeMap < > ( Bytes . BYTES _ COMPARATOR ) ; for ( byte [ ] fam : htd . getColumnFamilyNames ( ) ) { scopes . put ( fam , _NUM ) ; } for ( byte [ ] fam : htd . getColumnFamilyNames ( ) ) { addWALEdits ( tableName , hri , TEST _ ROW , fam , countPerFamily , EnvironmentEdgeManager . getDelegate ( ) , wal , scopes , mvcc ) ; } wal . append ( hri , new WALKeyImpl ( hri . getEncodedNameAsBytes ( ) , tableName , now , mvcc , scopes ) , edit , true ) ; sync to fs . wal . sync ( ) ; User user = HBaseTestingUtility . getDifferentUser ( newConf , _STR , _NUM _NUM _NUM _NUM _NUM , System . currentTimeMillis ( ) ) . toString ( ) ) ; WAL wal _NUM = wals _NUM . getWAL ( null ) ; HRegion region = HRegion . openHRegion ( newConf , FileSystem . get ( newConf ) , hbaseRootDir , hri , htd , wal _NUM , TEST _ UTIL . getHBaseCluster ( ) . getRegionServer ( _NUM ) , null ) ; SampleRegionWALCoprocessor cp _NUM = region . getCoprocessorHost ( ) . findCoprocessor ( SampleRegionWALCoprocessor . class ) ; TODO : asserting here is problematic . assertNotNull ( cp _NUM ) ; assertTrue ( cp _NUM . isPreWALRestoreCalled ( ) ) ; assertTrue ( cp _NUM . isPostWALRestoreCalled ( ) ) ; region . close ( ) ; wals _NUM . close ( ) ; return null ; } } ) ; } 
4848	public String getLockedByName ( ) { String lockedBy = _STR ; if ( ! getLock ( ) . isNullLock ( ) ) { user lockedBy = getLock ( ) . getUserId ( ) . toString ( ) ; try { lockedBy = getCurrentOuRelativeName ( CmsPrincipal . readPrincipalIncludingHistory ( getCms ( ) , getLock ( ) . getUserId ( ) ) . getName ( ) ) ; } catch ( Throwable e ) { lockedBy = e . getMessage ( ) ; } } return lockedBy ; } 
4849	public void clearCustomPrinterIconCache ( ) { throwIfCalledOnMainThread ( ) ; synchronized ( mLock ) { throwIfDestroyedLocked ( ) ; mCanUnbind = false ; } try { mClearCustomPrinterIconCache . clearCustomPrinterIconCache ( getRemoteInstanceLazy ( ) ) ; } catch ( RemoteException | TimeoutException | InterruptedException e ) { Slog . e ( LOG _ TAG , _STR ) ; } synchronized ( mLock ) { mCanUnbind = true ; mLock . notifyAll ( ) ; } } } 
4850	public static XmlGYearMonth parse ( java . net . URL u ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( XmlGYearMonth ) XmlBeans . getContextTypeLoader ( ) . parse ( u , type , null ) ; } 
4851	public static OCSPStatusRequest parse ( InputStream input ) throws IOException { Vector responderIDList = new Vector ( ) ; { int length = TlsUtils . readUint _NUM _NUM ( input ) ; if ( length > _NUM ) { byte [ ] data = TlsUtils . readFully ( length , input ) ; ByteArrayInputStream buf = new ByteArrayInputStream ( data ) ; do { byte [ ] derEncoding = TlsUtils . readOpaque _NUM _NUM ( buf ) ; ResponderID responderID = ResponderID . getInstance ( TlsUtils . readDERObject ( derEncoding ) ) ; responderIDList . addElement ( responderID ) ; } while ( buf . available ( ) > _NUM ) ; } } Extensions requestExtensions = null ; { int length = TlsUtils . readUint _NUM _NUM ( input ) ; if ( length > _NUM ) { byte [ ] derEncoding = TlsUtils . readFully ( length , input ) ; requestExtensions = Extensions . getInstance ( TlsUtils . readDERObject ( derEncoding ) ) ; } } return new OCSPStatusRequest ( responderIDList , requestExtensions ) ; } 
4852	void putStringArrayList ( @ Nullable String key , @ Nullable ArrayList < String > value ) { unparcel ( ) ; mMap . put ( key , value ) ; } 
4853	public ComponentSelector selectUnselectedStyle ( ) { currentStyle = getUnselectedStyle ( ) ; currentStyleType = UNSELECTED _ STYLE ; return this ; } 
4854	public String toShortStringExceptUniqueId ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( Integer . toHexString ( System . identityHashCode ( this ) ) ) ; sb . append ( ' ' ) ; sb . append ( batteryName ) ; return sb . toString ( ) ; } 
4855	public void removeList ( ) { setList ( null ) ; listSave ( ) ; } 
4856	public void setAntibanding ( String antibanding ) { set ( KEY _ ANTIBANDING , antibanding ) ; } 
4857	public void updateUI ( ) { setUI ( ( OutlookBarUI ) LookAndFeelAddons . getUI ( this , OutlookBarUI . class ) ) ; } 
4858	public void removeAnimators ( ) throws Throwable { final FragmentManager fm = mActivityRule . getActivity ( ) . getSupportFragmentManager ( ) ; One fragment with a view final AnimatorFragment fragment = new AnimatorFragment ( ) ; fm . beginTransaction ( ) . add ( R . id . fragmentContainer , fragment , _STR ) . setReorderingAllowed ( true ) . commit ( ) ; FragmentTestUtil . waitForExecution ( mActivityRule ) ; fm . beginTransaction ( ) . setCustomAnimations ( ENTER , EXIT , POP _ ENTER , POP _ EXIT ) . remove ( fragment ) . addToBackStack ( null ) . setReorderingAllowed ( true ) . commit ( ) ; FragmentTestUtil . waitForExecution ( mActivityRule ) ; assertExitPopEnter ( fragment ) ; } 
4859	public void handleServiceComponentInstalledEvent ( ServiceComponentInstalledEvent event ) throws AmbariException { if ( event . isRecoveryEnabled ( ) ) { Cluster cluster = clusters . getClusterById ( event . getClusterId ( ) ) ; if ( cluster ! = null ) { invalidateRecoveryTimestamp ( cluster . getClusterName ( ) , event . getHostName ( ) ) ; } } } 
4860	public void testMapRedExecutionEnv ( ) { test if the env variable can be set try { Application environment Map < String , String > environment = new HashMap < String , String > ( ) ; String setupHadoopHomeCommand = Shell . WINDOWS ? _STR ) ; tearDown ( ) ; } } 
4861	private static CameraMetadataNative convertResultMetadata ( LegacyRequest legacyRequest ) { CameraCharacteristics characteristics = legacyRequest . characteristics ; CaptureRequest request = legacyRequest . captureRequest ; Size previewSize = legacyRequest . previewSize ; Camera . Parameters params = legacyRequest . parameters ; CameraMetadataNative result = new CameraMetadataNative ( ) ; Rect activeArraySize = characteristics . get ( CameraCharacteristics . SENSOR _ INFO _ ACTIVE _ ARRAY _ SIZE ) ; ZoomData zoomData = ParameterUtils . convertScalerCropRegion ( activeArraySize , request . get ( CaptureRequest . SCALER _ CROP _ REGION ) , previewSize , params ) ; colorCorrection . aberrationMode { result . set ( COLOR _ CORRECTION _ ABERRATION _ MODE , request . get ( CaptureRequest . COLOR _ CORRECTION _ ABERRATION _ MODE ) ) ; } mapAe ( result , characteristics , request , activeArraySize , zoomData , params ) ; mapAf ( result , activeArraySize , zoomData , params ) ; mapAwb ( result , params ) ; { int captureIntent = ParamsUtils . getOrDefault ( request , CaptureRequest . CONTROL _ CAPTURE _ INTENT , CaptureRequest . CONTROL _ CAPTURE _ INTENT _ PREVIEW ) ; captureIntent = LegacyRequestMapper . filterSupportedCaptureIntent ( captureIntent ) ; result . set ( CONTROL _ CAPTURE _ INTENT , captureIntent ) ; } { int controlMode = ParamsUtils . getOrDefault ( request , CaptureRequest . CONTROL _ MODE , CONTROL _ MODE _ AUTO ) ; if ( controlMode = = CaptureResult . CONTROL _ MODE _ USE _ SCENE _ MODE ) { result . set ( CONTROL _ MODE , CONTROL _ MODE _ USE _ SCENE _ MODE ) ; } else { result . set ( CONTROL _ MODE , CONTROL _ MODE _ AUTO ) ; } } { String legacySceneMode = params . getSceneMode ( ) ; int mode = LegacyMetadataMapper . convertSceneModeFromLegacy ( legacySceneMode ) ; if ( mode ! = LegacyMetadataMapper . UNKNOWN _ MODE ) { result . set ( CaptureResult . CONTROL _ SCENE _ MODE , mode ) ; In case of SCENE _ MODE = = FACE _ PRIORITY , LegacyFaceDetectMapper will override the result to say SCENE _ MODE = = FACE _ PRIORITY . } else { Log . w ( TAG , _STR ) ; } noiseReduction . mode result . set ( NOISE _ REDUCTION _ MODE , request . get ( CaptureRequest . NOISE _ REDUCTION _ MODE ) ) ; return result ; } 
4862	public void prune ( ) throws Exception { double errorsLargestBranch ; double errorsLeaf ; double errorsTree ; int indexOfLargestBranch ; C _NUM _NUM PruneableClassifierTree largestBranch ; int i ; if ( ! m _ isLeaf ) { Prune all subtrees . for ( i = _NUM ; i < m _ sons . length ; i + + ) son ( i ) . prune ( ) ; Compute error for largest branch indexOfLargestBranch = localModel ( ) . distribution ( ) . maxBag ( ) ; if ( m _ subtreeRaising ) { errorsLargestBranch = son ( indexOfLargestBranch ) . getEstimatedErrorsForBranch ( ( Instances ) m _ train ) ; } else { errorsLargestBranch = Double . MAX _ VALUE ; } Compute error if this Tree would be leaf errorsLeaf = getEstimatedErrorsForDistribution ( localModel ( ) . distribution ( ) ) ; Compute error for the whole subtree errorsTree = getEstimatedErrors ( ) ; Decide if leaf is best choice . if ( Utils . smOrEq ( errorsLeaf , errorsTree + _NUM . _NUM ) & & Utils . smOrEq ( errorsLeaf , errorsLargestBranch + _NUM . _NUM ) ) { Free son Trees m _ sons = null ; m _ isLeaf = true ; Get NoSplit Model for node . m _ localModel = new NoSplit ( localModel ( ) . distribution ( ) ) ; return ; } than whole subtree . if ( Utils . smOrEq ( errorsLargestBranch , errorsTree + _NUM . _NUM ) ) { largestBranch = son ( indexOfLargestBranch ) ; m _ sons = largestBranch . m _ sons ; m _ localModel = largestBranch . localModel ( ) ; m _ isLeaf = largestBranch . m _ isLeaf ; newDistribution ( m _ train ) ; prune ( ) ; } } } 
4863	void dismissPip ( ) { if ( DEBUG ) { Log . d ( TAG , _STR , e ) ; } } ) ; } 
4864	public LaunchResult launchCluster ( ICoordinatedStack stack , ICoordinatedCluster cluster , int timeout ) { RunInstancesResult runInstancesResult = null ; try { RunInstancesRequest runInstancesRequest = new RunInstancesRequest ( ) ; runInstancesRequest . withImageId ( cluster . getInstanceSpec ( ) . getImageId ( ) ) . withInstanceType ( cluster . getInstanceSpec ( ) . getType ( ) ) . withMinCount ( cluster . getSize ( ) ) . withMaxCount ( cluster . getSize ( ) ) . withKeyName ( cluster . getInstanceSpec ( ) . getKeyName ( ) ) . withSecurityGroups ( stack . getIpRuleSet ( ) . getName ( ) ) ; if ( stack . getDataCenter ( ) ! = null & & ! stack . getDataCenter ( ) . isEmpty ( ) ) { runInstancesRequest = runInstancesRequest . withPlacement ( new Placement ( stack . getDataCenter ( ) ) ) ; client . setEndpoint ( AmazonUtils . getEndpoint ( stack . getDataCenter ( ) ) ) ; } runInstancesResult = client . runInstances ( runInstancesRequest ) ; } catch ( Exception e ) { LOG . error ( _STR ) ; } } Collection < Instance > instances = toInstances ( getEC _NUM Instances ( instanceIds ) ) ; return new EC _NUM LaunchResult ( cluster . getInstanceSpec ( ) , instances ) ; } 
4865	protected TlsNullCipher createNullCipher ( TlsCryptoParameters cryptoParams , int macAlgorithm ) throws IOException , GeneralSecurityException { return new TlsNullCipher ( cryptoParams , createMAC ( macAlgorithm ) , createMAC ( macAlgorithm ) ) ; } 
4866	public Canvas lockCanvas ( Rect dirty ) { if ( mDestroyed ) { return null ; } if ( mCanvas = = null ) { mCanvas = new Canvas ( ) ; } if ( nLockCanvas ( mNativeObject , mCanvas , dirty ) ) { mSaveCount = mCanvas . save ( ) ; return mCanvas ; } return null ; } 
4867	public Boolean isPresent ( Predicate < ClusterProcess > filter ) { return getOne ( filter ) . isPresent ( ) ; } 
4868	void resetViewProperties ( ) { OverviewCardTransform . reset ( this ) ; } 
4869	public boolean hasGlyph ( final CharSequence charSequence , int start , final int end ) { final StringBuilder builder = getStringBuilder ( ) ; builder . setLength ( _NUM ) ; while ( start < end ) { builder . append ( charSequence . charAt ( start ) ) ; start + + ; } return PaintCompat . hasGlyph ( mTextPaint , builder . toString ( ) ) ; } 
4870	public void addAttribute ( final String name , final List < String > values ) { if ( null = = name ) { return ; } if ( null ! = values ) { if ( currentNumOfAttributesAndMetrics . get ( ) < MAX _ NUM _ OF _ METRICS _ AND _ ATTRIBUTES ) { final String key = processAttributeMetricKey ( name ) ; if ( ! attributes . containsKey ( key ) ) { currentNumOfAttributesAndMetrics . incrementAndGet ( ) ; } attributes . put ( key , processAttributeValues ( values ) ) ; } else { log . warn ( _STR ) ; } } else { if ( attributes . remove ( name ) ! = null ) { currentNumOfAttributesAndMetrics . decrementAndGet ( ) ; } } } 
4871	private static void add ( final Map < String , int [ ] [ ] > m , final String n , final int [ ] r ) { final int [ ] [ ] old = m . get ( n ) , nw = { r } ; m . put ( n , old = = null ? nw : merge ( old , nw ) ) ; } 
4872	default Traversable < T > recover ( final Function < ? super Throwable , ? extends T > fn ) { return traversable ( ) . recover ( fn ) ; } 
4873	public void addVersion ( String version ) { setProperty ( VERSION , version ) ; } 
4874	protected static Instance toInstance ( com . amazonaws . services . ec _NUM . model . Instance ec _NUM ) { Instance instance ; BasicInstanceSpec spec ; spec = new BasicInstanceSpec ( ) ; spec . setImageId ( ec _NUM . getImageId ( ) ) ; spec . setKeyName ( ec _NUM . getKeyName ( ) ) ; spec . setType ( ec _NUM . getInstanceType ( ) ) ; instance = new BasicInstance ( ec _NUM . getInstanceId ( ) , spec , InstanceState . fromValue ( ec _NUM . getState ( ) . getName ( ) ) , ec _NUM . getPrivateDnsName ( ) , ec _NUM . getPublicDnsName ( ) , ec _NUM . getPrivateIpAddress ( ) , ec _NUM . getPublicIpAddress ( ) ) ; return instance ; } 
4875	public void setUpComboBoxes ( Instances inst ) { super . setUpComboBoxes ( inst ) ; m _ XCombo . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { setBorderText ( ) ; } } ) ; m _ YCombo . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { setBorderText ( ) ; } } ) ; Just in case the default is ROC setBorderText ( ) ; } 
4876	protected AccessTokenValidation getAccessTokenValidation ( String authScheme , String authSchemeData , MultivaluedMap < String , String > extraProps ) { AccessTokenValidation accessTokenV = null ; if ( dataProvider = = null & & tokenHandlers . isEmpty ( ) ) { throw ExceptionUtils . toInternalServerErrorException ( null , null ) ; } if ( maxValidationDataCacheSize > _NUM ) { accessTokenV = accessTokenValidations . get ( authSchemeData ) ; } ServerAccessToken localAccessToken = null ; if ( accessTokenV = = null ) { Get the registered handler capable of processing the token AccessTokenValidator handler = findTokenValidator ( authScheme ) ; if ( handler ! = null ) { try { Convert the HTTP Authorization scheme data into a token accessTokenV = handler . validateAccessToken ( getMessageContext ( ) , authScheme , authSchemeData , extraProps ) ; } catch ( OAuthServiceException ex ) { AuthorizationUtils . throwAuthorizationFailure ( Collections . singleton ( authScheme ) , realm ) ; } catch ( RuntimeException ex ) { AuthorizationUtils . throwAuthorizationFailure ( Collections . singleton ( authScheme ) , realm ) ; } } Default processing if no registered providers available if ( accessTokenV = = null & & dataProvider ! = null & & authScheme . equals ( DEFAULT _ AUTH _ SCHEME ) ) { try { localAccessToken = dataProvider . getAccessToken ( authSchemeData ) ; } catch ( OAuthServiceException ex ) { to be handled next } if ( localAccessToken = = null ) { AuthorizationUtils . throwAuthorizationFailure ( Collections . singleton ( authScheme ) , realm ) ; } accessTokenV = new AccessTokenValidation ( localAccessToken ) ; } } if ( accessTokenV = = null ) { AuthorizationUtils . throwAuthorizationFailure ( supportedSchemes , realm ) ; } Check if token is still valid if ( OAuthUtils . isExpired ( accessTokenV . getTokenIssuedAt ( ) , accessTokenV . getTokenLifetime ( ) ) ) { if ( localAccessToken ! = null ) { removeAccessToken ( localAccessToken ) ; } else if ( maxValidationDataCacheSize > _NUM ) { accessTokenValidations . remove ( authSchemeData ) ; } AuthorizationUtils . throwAuthorizationFailure ( supportedSchemes , realm ) ; } if ( maxValidationDataCacheSize > _NUM ) { if ( accessTokenValidations . size ( ) > = maxValidationDataCacheSize ) { or delete the ones expiring sooner than others , etc accessTokenValidations . clear ( ) ; } accessTokenValidations . put ( authSchemeData , accessTokenV ) ; } return accessTokenV ; } 
4877	public void testBothDataAndIndexAsSource ( ) throws Exception { insert one valid row upsertRow ( dataTableUpsertStmt , _NUM , _STR , _NUM , _NUM _NUM _NUM _NUM ) ; conn . commit ( ) ; List < Job > completedJobs = runScrutiny ( schemaName , dataTableName , indexTableName , _NUM _NUM L , SourceTable . BOTH ) ; assertEquals ( _NUM , completedJobs . size ( ) ) ; for ( Job job : completedJobs ) { assertTrue ( job . isSuccessful ( ) ) ; Counters counters = job . getCounters ( ) ; assertEquals ( _NUM , getCounterValue ( counters , VALID _ ROW _ COUNT ) ) ; assertEquals ( _NUM , getCounterValue ( counters , INVALID _ ROW _ COUNT ) ) ; } } 
4878	private void rollbackDeleteDirectory ( final MasterProcedureEnv env ) throws IOException { try { CreateNamespaceProcedure . createDirectory ( env , nsDescriptor ) ; } catch ( Exception e ) { Ignore exception LOG . debug ( _STR + e ) ; } } 
4879	private AddTemplatesInternalResponse addTemplatesToCloudList ( final File templatesFolder , final List < ComputeTemplateHolder > cloudTemplates ) { final List < String > addedTemplates = new LinkedList < String > ( ) ; final Map < String , String > failedToAddTemplates = new HashMap < String , String > ( ) ; log ( Level . FINE , _STR , e ) ; new File ( templatesFolder , originalTemplateFileName ) . delete ( ) ; continue ; } add template to cloud templates list final ComputeTemplate cloudTemplate = holder . getCloudTemplate ( ) ; templates . put ( templateName , cloudTemplate ) ; addedTemplates . add ( templateName ) ; } final AddTemplatesInternalResponse response = new AddTemplatesInternalResponse ( ) ; response . setAddedTempaltes ( addedTemplates ) ; response . setFailedToAddTempaltesAndReasons ( failedToAddTemplates ) ; return response ; } 
4880	public void testPatchAndApply ( ) throws Exception { Write the old archive to disk . byte [ ] oldArchiveBytes = UnitTestZipArchive . makeTestZip ( Arrays . asList ( OLD _ ENTRY _NUM , OLD _ ENTRY _NUM , OLD _ ENTRY _NUM , OLD _ ENTRY _NUM , OLD _ ENTRY _NUM , OLD _ ENTRY _NUM , OLD _ ENTRY _NUM , OLD _ ENTRY _NUM , OLD _ ENTRY _NUM , OLD _ ENTRY _NUM _NUM , OLD _ ENTRY _NUM _NUM , OLD _ ENTRY _NUM _NUM , OLD _ ENTRY _NUM _NUM ) ) ; writeFile ( oldFile , oldArchiveBytes ) ; Write the new archive to disk . Flip the order around to fully exercise reordering logic where the offsets might otherwise be exactly the same by chance . List < UnitTestZipEntry > newEntries = Arrays . asList ( NEW _ ENTRY _NUM , NEW _ ENTRY _NUM , NEW _ ENTRY _NUM , NEW _ ENTRY _NUM , NEW _ ENTRY _NUM , NEW _ ENTRY _NUM , NEW _ ENTRY _NUM , NEW _ ENTRY _NUM , NEW _ ENTRY _NUM , NEW _ ENTRY _NUM _NUM , NEW _ ENTRY _NUM _NUM , NEW _ ENTRY _NUM _NUM , NEW _ ENTRY _NUM _NUM ) ; Collections . reverse ( newEntries ) ; byte [ ] newArchiveBytes = UnitTestZipArchive . makeTestZip ( newEntries ) ; writeFile ( newFile , newArchiveBytes ) ; Generate the patch . ByteArrayOutputStream patchBuffer = new ByteArrayOutputStream ( ) ; FileByFileV _NUM DeltaGenerator generator = new FileByFileV _NUM DeltaGenerator ( ) ; generator . generateDelta ( oldFile , newFile , patchBuffer ) ; Apply the patch . FileByFileV _NUM DeltaApplier applier = new FileByFileV _NUM DeltaApplier ( tempDir ) ; ByteArrayInputStream patchIn = new ByteArrayInputStream ( patchBuffer . toByteArray ( ) ) ; ByteArrayOutputStream newOut = new ByteArrayOutputStream ( ) ; applier . applyDelta ( oldFile , patchIn , newOut ) ; Finally , expect that the result of applying the patch is exactly the same as the new archive that was written to disk . Assert . assertArrayEquals ( newArchiveBytes , newOut . toByteArray ( ) ) ; } 
4881	 @ RequestMapping ( value = _STR ) ; return deploymentEvents ; } } 
4882	private String getCacheKeyForCurrentProject ( String systemId ) { check the project boolean project = ( m _ cms ! = null ) ? m _ cms . getRequestContext ( ) . getCurrentProject ( ) . isOnlineProject ( ) : false ; remove opencms : prefix if ( systemId . startsWith ( OPENCMS _ SCHEME ) ) { systemId = systemId . substring ( OPENCMS _ SCHEME . length ( ) - _NUM ) ; } return getCacheKey ( systemId , project ) ; } 
4883	Called by hooks to find out whether the service should be hidden . Also handles the proxy creation of services if applicable . Return true if the hook should hide the service for the bundleboolean handleProxificationForHook ( ServiceReference < ? > sr ) { if ( isProxy ( sr ) ) { return false ; } Note does most of the work async proxyIfNotAlreadyProxied ( sr ) ; return true ; } 
4884	public Bitmap toBitmap ( ) { Bitmap result = ( Bitmap ) mBackingStore . lockData ( MODE _ READ , BackingStore . ACCESS _ BITMAP ) ; mBackingStore . unlock ( ) ; return result ; } 
4885	public void clean ( int numberToClean ) { logger . info ( _STR , numberToClean , key ) ; } 
4886	public NSObject parse ( ) throws ParseException { index = _NUM ; Skip Unicode byte order mark ( BOM ) if ( data . length > = _NUM & & ( data [ _NUM ] & _NUM xFF ) = = _NUM xEF & & ( data [ _NUM ] & _NUM xFF ) = = _NUM xBB & & ( data [ _NUM ] & _NUM xFF ) = = _NUM xBF ) skip ( _NUM ) ; skipWhitespacesAndComments ( ) ; expect ( DICTIONARY _ BEGIN _ TOKEN , ARRAY _ BEGIN _ TOKEN , COMMENT _ BEGIN _ TOKEN ) ; try { return parseObject ( ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { throw new ParseException ( _STR , index ) ; } } 
4887	public static String readString ( DataInput in , int maxLength ) throws IOException { int length = WritableUtils . readVIntInRange ( in , _NUM , maxLength ) ; byte [ ] bytes = new byte [ length ] ; in . readFully ( bytes , _NUM , length ) ; return decode ( bytes ) ; } 
4888	public static void trace ( String message ) { final TraceState state = instance . get ( ) ; if ( inline isTracing to avoid implicit two calls to state . get ( ) state = = null ) return ; state . trace ( message ) ; } 
4889	public ViewPropertyAnimator alpha ( float value ) { animateProperty ( ALPHA , value ) ; return this ; } 
4890	public E removeAt ( int index ) { final Object old = mArray [ index ] ; if ( mSize < = _NUM ) { Now empty . if ( DEBUG ) Log . d ( TAG , _STR + index ) ; } System . arraycopy ( mHashes , index + _NUM , mHashes , index , mSize - index ) ; System . arraycopy ( mArray , index + _NUM , mArray , index , mSize - index ) ; } mArray [ mSize ] = null ; } } return ( E ) old ; } 
4891	protected CmsResourceState internalReadStructureState ( CmsDbContext dbc , CmsUUID projectId , CmsResource resource ) throws CmsDbSqlException { CmsResourceState state = CmsResource . STATE _ KEEP ; Connection conn = null ; PreparedStatement stmt = null ; ResultSet res = null ; try { conn = m _ sqlManager . getConnection ( dbc ) ; stmt = m _ sqlManager . getPreparedStatement ( conn , projectId , _STR ) ) ) ; while ( res . next ( ) ) { do nothing only move through all rows because of mssql odbc driver } } } catch ( SQLException e ) { throw new CmsDbSqlException ( Messages . get ( ) . container ( Messages . ERR _ GENERIC _ SQL _ _NUM , CmsDbSqlException . getErrorQuery ( stmt ) ) , e ) ; } finally { m _ sqlManager . closeAll ( dbc , conn , stmt , res ) ; } return state ; } 
4892	public void addMerged ( ) throws IOException { Workbook wb = _ testDataProvider . createWorkbook ( ) ; Sheet sheet = wb . createSheet ( ) ; assertEquals ( _NUM , sheet . getNumMergedRegions ( ) ) ; SpreadsheetVersion ssVersion = _ testDataProvider . getSpreadsheetVersion ( ) ; CellRangeAddress region = new CellRangeAddress ( _NUM , _NUM , _NUM , _NUM ) ; sheet . addMergedRegion ( region ) ; assertEquals ( _NUM , sheet . getNumMergedRegions ( ) ) ; try { region = new CellRangeAddress ( - _NUM , - _NUM , - _NUM , - _NUM ) ; sheet . addMergedRegion ( region ) ; fail ( _STR + ssVersion . getLastRowIndex ( ) , e . getMessage ( ) ) ; } assertEquals ( _NUM , sheet . getNumMergedRegions ( ) ) ; wb . close ( ) ; } 
4893	public final void confirm ( ) { mResult = true ; wakeUp ( ) ; } 
4894	public int hashCode ( ) { int result = super . hashCode ( ) ; it is too slow to look at every data item , so let ' s just look at the first , middle and last items . . . int count = getItemCount ( ) ; if ( count > _NUM ) { XYDataItem item = getDataItem ( _NUM ) ; result = _NUM _NUM * result + item . hashCode ( ) ; } if ( count > _NUM ) { XYDataItem item = getDataItem ( count - _NUM ) ; result = _NUM _NUM * result + item . hashCode ( ) ; } if ( count > _NUM ) { XYDataItem item = getDataItem ( count / _NUM ) ; result = _NUM _NUM * result + item . hashCode ( ) ; } result = _NUM _NUM * result + this . maximumItemCount ; result = _NUM _NUM * result + ( this . autoSort ? _NUM : _NUM ) ; result = _NUM _NUM * result + ( this . allowDuplicateXValues ? _NUM : _NUM ) ; return result ; } 
4895	public static ProfileManager getPac _NUM jProfileManager ( final HttpServletRequest request , final HttpServletResponse response ) { final J _NUM EContext context = getPac _NUM jJ _NUM EContext ( request , response , new J _NUM ESessionStore ( ) ) ; return getPac _NUM jProfileManager ( context ) ; } 
4896	public void showBack ( ) { show ( true ) ; } 
4897	public List < Job > getList ( @ QueryParam ( _STR , ex ) ; throw new ServiceFormattedException ( ex . getMessage ( ) , ex ) ; } } 
4898	public final void init ( ) { trigger obtaining the authorization cache if possible getAvailableAuthenticationCache ( ) ; onInit ( ) ; } 
4899	public static Map < String , Object > fetchJSON ( String url ) throws IOException { ConnectionRequest cr = new ConnectionRequest ( ) ; cr . setFailSilently ( true ) ; cr . setPost ( false ) ; cr . setUrl ( url ) ; NetworkManager . getInstance ( ) . addToQueueAndWait ( cr ) ; if ( cr . getResponseData ( ) = = null ) { if ( cr . failureException ! = null ) { throw new IOException ( cr . failureException . toString ( ) ) ; } else { throw new IOException ( _STR ) ) ; return result ; } 
4900	public void setCustomName ( String name ) { m _ visual . setText ( name ) ; } 
4901	protected void showDialog ( Bundle state ) { Context context = getContext ( ) ; mWhichButtonClicked = DialogInterface . BUTTON _ NEGATIVE ; mBuilder = new AlertDialog . Builder ( context ) . setTitle ( mDialogTitle ) . setIcon ( mDialogIcon ) . setPositiveButton ( mPositiveButtonText , this ) . setNegativeButton ( mNegativeButtonText , this ) ; View contentView = onCreateDialogView ( ) ; if ( contentView ! = null ) { onBindDialogView ( contentView ) ; mBuilder . setView ( contentView ) ; } else { mBuilder . setMessage ( mDialogMessage ) ; } onPrepareDialogBuilder ( mBuilder ) ; PreferenceManagerEx . getInstance ( ) . registerOnActivityDestroyListener ( getPreferenceManager ( ) , this ) ; Create the dialog final Dialog dialog = mDialog = mBuilder . create ( ) ; if ( state ! = null ) { dialog . onRestoreInstanceState ( state ) ; } if ( needInputMethod ( ) ) { requestInputMethod ( dialog ) ; } dialog . setOnDismissListener ( this ) ; dialog . show ( ) ; } 
4902	public String getCustomName ( ) { return m _ visual . getText ( ) ; } 
4903	public void endData ( ) { if ( false ) { Log . v ( LOGTAG , _STR + netRunner ) ; netRunner . decrementRunCount ( ) ; } } } } 
4904	public byte [ ] [ ] readTokens ( ) throws IOException { final int l = readNum ( ) ; final byte [ ] [ ] tmp = new byte [ l ] [ ] ; for ( int i = _NUM ; i < l ; + + i ) tmp [ i ] = readToken ( ) ; return tmp ; } 
4905	void emitHeadGet ( Node node , int argi ) { if ( node instanceof Node _ RuleVariable ) { Node _ RuleVariable var = ( Node _ RuleVariable ) node ; if ( isDummy ( var ) ) { Node code required , var not used return ; } if ( isTemp ( var ) ) { List < TermIndex > occurrences = varOccurrence . get ( var ) ; if ( occurrences . size ( ) = = _NUM & & occurrences . get ( _NUM ) . index < = _NUM & & occurrences . get ( _NUM ) . index = = occurrences . get ( _NUM ) . index ) { No movement code required , var in right place } else { code [ p + + ] = seen . add ( var ) ? GET _ TEMP : UNIFY _ TEMP ; code [ p + + ] = ( byte ) tempVars . indexOf ( var ) ; code [ p + + ] = ( byte ) argi ; } } else { code [ p + + ] = seen . add ( var ) ? GET _ VARIABLE : UNIFY _ VARIABLE ; code [ p + + ] = ( byte ) permanentVars . indexOf ( var ) ; code [ p + + ] = ( byte ) argi ; } } else if ( Functor . isFunctor ( node ) ) { Functor f = ( Functor ) node . getLiteralValue ( ) ; code [ p + + ] = GET _ FUNCTOR ; args . add ( f ) ; Node [ ] fargs = f . getArgs ( ) ; for ( int i = _NUM ; i < fargs . length ; i + + ) { emitHeadGet ( fargs [ i ] , i + _NUM ) ; } } else { code [ p + + ] = GET _ CONSTANT ; code [ p + + ] = ( byte ) argi ; args . add ( node ) ; } } 
4906	public String toXml ( String tab ) { StringBuilder builder = new StringBuilder ( ) ; builder . append ( tab ) . append ( _STR ) ; return builder . toString ( ) ; } 
4907	public static ZTauElement round ( SimpleBigDecimal lambda _NUM , SimpleBigDecimal lambda _NUM , byte mu ) { int scale = lambda _NUM . getScale ( ) ; if ( lambda _NUM . getScale ( ) ! = scale ) { throw new IllegalArgumentException ( _STR ) ; } BigInteger f _NUM = lambda _NUM . round ( ) ; BigInteger f _NUM = lambda _NUM . round ( ) ; SimpleBigDecimal eta _NUM = lambda _NUM . subtract ( f _NUM ) ; SimpleBigDecimal eta _NUM = lambda _NUM . subtract ( f _NUM ) ; eta = _NUM * eta _NUM + mu * eta _NUM SimpleBigDecimal eta = eta _NUM . add ( eta _NUM ) ; if ( mu = = _NUM ) { eta = eta . add ( eta _NUM ) ; } else { mu = = - _NUM eta = eta . subtract ( eta _NUM ) ; } check _NUM = eta _NUM - _NUM * mu * eta _NUM check _NUM = eta _NUM + _NUM * mu * eta _NUM SimpleBigDecimal threeEta _NUM = eta _NUM . add ( eta _NUM ) . add ( eta _NUM ) ; SimpleBigDecimal fourEta _NUM = threeEta _NUM . add ( eta _NUM ) ; SimpleBigDecimal check _NUM ; SimpleBigDecimal check _NUM ; if ( mu = = _NUM ) { check _NUM = eta _NUM . subtract ( threeEta _NUM ) ; check _NUM = eta _NUM . add ( fourEta _NUM ) ; } else { mu = = - _NUM check _NUM = eta _NUM . add ( threeEta _NUM ) ; check _NUM = eta _NUM . subtract ( fourEta _NUM ) ; } byte h _NUM = _NUM ; byte h _NUM = _NUM ; if eta > = _NUM if ( eta . compareTo ( ECConstants . ONE ) > = _NUM ) { if ( check _NUM . compareTo ( MINUS _ ONE ) < _NUM ) { h _NUM = mu ; } else { h _NUM = _NUM ; } } else { eta < _NUM if ( check _NUM . compareTo ( ECConstants . TWO ) > = _NUM ) { h _NUM = mu ; } } if eta < - _NUM if ( eta . compareTo ( MINUS _ ONE ) < _NUM ) { if ( check _NUM . compareTo ( ECConstants . ONE ) > = _NUM ) { h _NUM = ( byte ) - mu ; } else { h _NUM = - _NUM ; } } else { eta > = - _NUM if ( check _NUM . compareTo ( MINUS _ TWO ) < _NUM ) { h _NUM = ( byte ) - mu ; } } BigInteger q _NUM = f _NUM . add ( BigInteger . valueOf ( h _NUM ) ) ; BigInteger q _NUM = f _NUM . add ( BigInteger . valueOf ( h _NUM ) ) ; return new ZTauElement ( q _NUM , q _NUM ) ; } 
4908	public static void deleteRegion ( Connection connection , RegionInfo regionInfo ) throws IOException { long time = EnvironmentEdgeManager . currentTime ( ) ; Delete delete = new Delete ( regionInfo . getRegionName ( ) ) ; delete . addFamily ( getCatalogFamily ( ) , time ) ; deleteFromMetaTable ( connection , delete ) ; LOG . info ( _STR + regionInfo . getRegionNameAsString ( ) ) ; } 
4909	private int addAttributeTo ( CSSElement selector , String attributeName , String value , HTMLComponent htmlC ) { int error = selector . setAttribute ( attributeName , value ) ; reportAddAttributeError ( error , selector , attributeName , value , htmlC ) ; return error ; } 
4910	public final void removeCallbacks ( Runnable r ) { final WeakRunnable runnable = mRunnables . remove ( r ) ; if ( runnable ! = null ) { mExec . removeCallbacks ( runnable ) ; } } 
4911	public List < Album > getAlphabetialAlbums ( final int offset , final int count , boolean byArtist , final List < MusicFolder > musicFolders ) { return getAlphabeticalAlbums ( offset , count , byArtist , false , musicFolders ) ; } 
4912	public DataSet get ( int i ) { if ( i > numExamples ( ) | | i < _NUM ) throw new IllegalArgumentException ( _STR ) ; if ( i = = _NUM & & numExamples ( ) = = _NUM ) return this ; if ( getFeatureMatrix ( ) . rank ( ) = = _NUM ) { ensure rank is preserved INDArray slice = getFeatureMatrix ( ) . slice ( i ) ; return new DataSet ( slice . reshape ( ArrayUtil . combine ( new int [ ] { _NUM } , slice . shape ( ) ) ) , getLabels ( ) . slice ( i ) ) ; } return new DataSet ( getFeatures ( ) . slice ( i ) , getLabels ( ) . slice ( i ) ) ; } 
4913	public CmsPublishList getPublishList ( ) throws JspException { CmsPublishList publishList = null ; if ( isDirectPublish ( ) ) { get the offline resource ( s ) in direct publish mode List publishResources = new ArrayList ( getResourceList ( ) . size ( ) ) ; Iterator i = getResourceList ( ) . iterator ( ) ; while ( i . hasNext ( ) ) { String resName = ( String ) i . next ( ) ; try { publishResources . add ( getCms ( ) . readResource ( resName , CmsResourceFilter . ALL ) ) ; } catch ( CmsException e ) { addMultiOperationException ( e ) ; } } try { boolean publishSubResources = Boolean . valueOf ( getParamSubresources ( ) ) . booleanValue ( ) ; boolean publishSiblings = Boolean . valueOf ( getParamPublishsiblings ( ) ) . booleanValue ( ) ; create publish list for direct publish publishList = OpenCms . getPublishManager ( ) . getPublishList ( getCms ( ) , publishResources , publishSiblings , publishSubResources ) ; } catch ( CmsException e ) { addMultiOperationException ( e ) ; } } else { try { be careful # getParamProjectid ( ) is always the current project publishList = OpenCms . getPublishManager ( ) . getPublishList ( getCms ( ) ) ; } catch ( CmsException e ) { addMultiOperationException ( e ) ; } } try { throw exception for errors unlocking resources checkMultiOperationException ( Messages . get ( ) , Messages . ERR _ PUBLISH _ LIST _ CREATION _ _NUM ) ; } catch ( Throwable e ) { publishList = null ; error while unlocking resources , show error screen includeErrorpage ( this , e ) ; } getSettings ( ) . setPublishList ( publishList ) ; return publishList ; } 
4914	public static InputStream fetchFile ( final URI uri , final ClientConfiguration config ) throws IOException { final URL url = uri . toURL ( ) ; TODO : support proxy ? final HttpURLConnection connection = ( HttpURLConnection ) url . openConnection ( ) ; connection . setConnectTimeout ( getConnectionTimeout ( config ) ) ; connection . setReadTimeout ( getSocketTimeout ( config ) ) ; connection . addRequestProperty ( _STR + connection . getResponseMessage ( ) ) ; } return connection . getInputStream ( ) ; } 
4915	public void setPsSunlightProtectMode ( @ PsSunlightProtectMode int sunlightProtectMode ) throws IOException , IllegalStateException { setPsConf _NUM Ms ( PS _ SUNLIGHT _ PROTECT _ MASK , sunlightProtectMode ) ; } 
4916	public void addHostToTopology ( String hostGroupName , String host ) throws InvalidTopologyException , NoSuchHostGroupException { if ( blueprint . getHostGroup ( hostGroupName ) = = null ) { throw new NoSuchHostGroupException ( _STR + existingHostGroupInfo . getHostGroupName ( ) ) ; } } 
4917	public Set < PermissionDetails > list ( AuthenticatedUser performer , Set < Permission > permissions , IResource resource , RoleResource grantee ) throws RequestValidationException , RequestExecutionException { if ( ! ( performer . isSuper ( ) | | performer . isSystem ( ) ) & & ! performer . getRoles ( ) . contains ( grantee ) ) throw new UnauthorizedException ( String . format ( _STR : grantee . getRoleName ( ) ) ) ; if ( null = = grantee ) return listPermissionsForRole ( permissions , resource , grantee ) ; Set < RoleResource > roles = DatabaseDescriptor . getRoleManager ( ) . getRoles ( grantee , true ) ; Set < PermissionDetails > details = new HashSet < > ( ) ; for ( RoleResource role : roles ) details . addAll ( listPermissionsForRole ( permissions , resource , role ) ) ; return details ; } 
4918	public DescribeSecurityGroupsResult withSecurityGroups ( SecurityGroup . . . securityGroups ) { if ( getSecurityGroups ( ) = = null ) setSecurityGroups ( new java . util . ArrayList < SecurityGroup > ( securityGroups . length ) ) ; for ( SecurityGroup value : securityGroups ) { getSecurityGroups ( ) . add ( value ) ; } return this ; } 
4919	public void allocateDenseBlockUnsafe ( int rl , int cl ) { sparse = false ; rlen = rl ; clen = cl ; allocate dense block allocateDenseBlock ( ) ; } 
4920	public void recoverFileLease ( final FileSystem fs , final Path p , Configuration conf , CancelableProgressable reporter ) throws IOException { lease recovery not needed for local file system case . if ( ! ( fs instanceof DistributedFileSystem ) ) return ; recoverDFSFileLease ( ( DistributedFileSystem ) fs , p , conf , reporter ) ; } 
4921	public void setStepSize ( float stepSize ) { if ( stepSize < = _NUM ) { return ; } final float newMax = mNumStars / stepSize ; final int newProgress = ( int ) ( newMax / getMax ( ) * getProgress ( ) ) ; setMax ( ( int ) newMax ) ; setProgress ( newProgress ) ; } 
4922	public void setCurrentDate ( Date d ) { mv . setCurrentDay ( d . getTime ( ) , true ) ; componentChanged ( ) ; } 
4923	public int getSessionCountAuthenticated ( ) { we have to prevent access before initialization if ( m _ sessionStorageProvider = = null ) { return _NUM ; } return m _ sessionStorageProvider . getSize ( ) ; } 
4924	public String replace ( final LogEvent event , final char [ ] source , final int offset , final int length ) { if ( source = = null ) { return null ; } final StringBuilder buf = new StringBuilder ( length ) . append ( source , offset , length ) ; substitute ( event , buf , _NUM , length ) ; return buf . toString ( ) ; } 
4925	protected void unloadImports ( OntModel model , List < String > unloadQueue ) { while ( ! unloadQueue . isEmpty ( ) ) { we process the import statements as a FIFO queue String importURI = unloadQueue . remove ( _NUM ) ; if ( model . hasLoadedImport ( importURI ) ) { this import has not been unloaded yet look up the cached model - if we can ' t find it , we can ' t unload the import Model importModel = getModel ( importURI ) ; if ( importModel ! = null ) { List < String > imports = new ArrayList < > ( ) ; collect a list of the imports from the model that is scheduled for removal for ( StmtIterator i = importModel . listStatements ( null , model . getProfile ( ) . IMPORTS ( ) , ( RDFNode ) null ) ; i . hasNext ( ) ; ) { imports . add ( i . nextStatement ( ) . getResource ( ) . getURI ( ) ) ; } now remove the sub - model model . removeSubModel ( importModel , false ) ; model . removeLoadedImport ( importURI ) ; imported by other imports that remain , we should remove them as well for ( StmtIterator i = model . listStatements ( null , model . getProfile ( ) . IMPORTS ( ) , ( RDFNode ) null ) ; i . hasNext ( ) ; ) { imports . remove ( i . nextStatement ( ) . getResource ( ) . getURI ( ) ) ; } any imports that remain are scheduled for removal unloadQueue . addAll ( imports ) ; } } } model . rebind ( ) ; } 
4926	public static void deallocDecoder ( CharsetDecoder dec ) { putDecoder ( dec ) ; } 
4927	public static String encodeBytes ( byte [ ] source , int off , int len , int options ) throws java . io . IOException { byte [ ] encoded = encodeBytesToBytes ( source , off , len , options ) ; Return value according to relevant encoding . try { return new String ( encoded , PREFERRED _ ENCODING ) ; } end try catch ( java . io . UnsupportedEncodingException uue ) { return new String ( encoded ) ; } end catch } 
4928	String [ ] strings ( ) throws XMLDBException { return ( String [ ] ) run ( ) ; } 
4929	private EntryIterator keysWithinReverse ( final int first , final int last ) { return new EntryIterator ( ) { int ix = last + _NUM ; int count = - _NUM ; @ Override public byte [ ] next ( ) { if ( - - ix > = first ) { synchronized ( monitor ) { final IndexEntry entry = indexEntry ( ix ) ; count = entry . size ; return entry . key ; } } count = - _NUM ; return null ; } @ Override public int count ( ) { return count ; } } ; } 
4930	public static RelNode toLeafJoinForm ( RelNode rel ) { final Program program = Programs . hep ( ImmutableList . of ( JoinProjectTransposeRule . RIGHT _ PROJECT , JoinProjectTransposeRule . LEFT _ PROJECT , FilterJoinRule . FilterIntoJoinRule . FILTER _ ON _ JOIN , ProjectRemoveRule . INSTANCE , ProjectMergeRule . INSTANCE ) , false , DefaultRelMetadataProvider . INSTANCE ) ; if ( CalcitePrepareImpl . DEBUG ) { System . out . println ( RelOptUtil . dumpPlan ( _STR , rel _NUM , SqlExplainFormat . TEXT , SqlExplainLevel . DIGEST _ ATTRIBUTES ) ) ; } return rel _NUM ; } 
4931	void imageLoadComplete ( ) { Preconditions . checkState ( ! imageLoaded , _STR ) ; setImageLoaded ( ) ; } 
4932	public HSSFBorderFormatting createBorderFormatting ( ) { return getBorderFormatting ( true ) ; } 
4933	protected ClientFactoryBean createClientFactoryBean ( Class < ? > cls ) throws CamelException { if ( CxfEndpointUtils . hasWebServiceAnnotation ( cls ) ) { return new JaxWsClientFactoryBean ( ) { @ Override protected Client createClient ( Endpoint ep ) { return new CamelCxfClientImpl ( getBus ( ) , ep ) ; } } ; } else { return new ClientFactoryBean ( ) { @ Override protected Client createClient ( Endpoint ep ) { return new CamelCxfClientImpl ( getBus ( ) , ep ) ; } } ; } } 
4934	public static TTransport createClientTransport ( HostAndPort address , int timeout , SslConnectionParams sslParams , SaslConnectionParams saslParams ) throws TTransportException { boolean success = false ; TTransport transport = null ; try { if ( sslParams ! = null ) { The check in AccumuloServerContext ensures that servers are brought up with sane configurations , but we also want to validate clients if ( null ! = saslParams ) { throw new IllegalStateException ( _STR , address ) ; throw new TTransportException ( ex ) ; } Open the transport transport . open ( ) ; } transport = ThriftUtil . transportFactory ( ) . getTransport ( transport ) ; } success = true ; } finally { if ( ! success & & transport ! = null ) { transport . close ( ) ; } } return transport ; } 
4935	public String getString ( String varname ) { return getScalarObject ( varname ) . getStringValue ( ) ; } 
4936	private List getXmlPages ( ) { boolean isRecursive = Boolean . valueOf ( getParamRecursive ( ) ) . booleanValue ( ) ; filter definition to read only the required resources int xmlPageId ; try { xmlPageId = OpenCms . getResourceManager ( ) . getResourceType ( CmsResourceTypeXmlPage . getStaticTypeName ( ) ) . getTypeId ( ) ; } catch ( CmsLoaderException e _NUM ) { xmlPageId = CmsResourceTypeXmlPage . getStaticTypeId ( ) ; } CmsResourceFilter filter = CmsResourceFilter . IGNORE _ EXPIRATION . addRequireType ( xmlPageId ) ; trying to read the resources List xmlPages = null ; try { xmlPages = getCms ( ) . readResources ( getParamResource ( ) , filter , isRecursive ) ; } catch ( CmsException e ) { if ( LOG . isErrorEnabled ( ) ) { LOG . error ( e . getLocalizedMessage ( ) , e ) ; } } return xmlPages ; } 
4937	public int getVolumeControlStream ( ) { if ( this = = null ) { throw new IllegalArgumentException ( _STR ) ; } if ( Build . VERSION . SDK _ INT > = _NUM _NUM & & ! sForceLegacyBehavior & & unwrap ( ) ! = null ) { return ( ( AudioAttributes ) unwrap ( ) ) . getVolumeControlStream ( ) ; } return toVolumeStreamType ( true , this ) ; } 
4938	public String htmlCell ( CmsListItem item , boolean isPrintable ) { StringBuffer html = new StringBuffer ( _NUM _NUM _NUM ) ; Iterator < I _ CmsListDirectAction > itActions = m _ directActions . iterator ( ) ; while ( itActions . hasNext ( ) ) { I _ CmsListDirectAction action = itActions . next ( ) ; action . setItem ( item ) ; boolean enabled = action . isEnabled ( ) ; if ( isPrintable ) { action . setEnabled ( false ) ; } html . append ( action . buttonHtml ( ) ) ; if ( isPrintable ) { action . setEnabled ( enabled ) ; } } if ( ! m _ defaultActions . isEmpty ( ) ) { Iterator < CmsListDefaultAction > itDefaultActions = m _ defaultActions . iterator ( ) ; while ( itDefaultActions . hasNext ( ) ) { CmsListDefaultAction defAction = itDefaultActions . next ( ) ; defAction . setItem ( item ) ; boolean enabled = defAction . isEnabled ( ) ; if ( isPrintable ) { defAction . setEnabled ( false ) ; } html . append ( defAction . buttonHtml ( ) ) ; if ( isPrintable ) { defAction . setEnabled ( enabled ) ; } } } else { if ( m _ formatter = = null ) { unformatted output if ( item . get ( m _ id ) ! = null ) { null values are not showed by default html . append ( item . get ( m _ id ) . toString ( ) ) ; } } else { formatted output html . append ( m _ formatter . format ( item . get ( m _ id ) , getWp ( ) . getLocale ( ) ) ) ; } } html . append ( _STR ) ; return html . toString ( ) ; } 
4939	public void shutdown ( ) { Stopping async task from fetching layout . isShutdown = true ; if ( layout ! = null ) { try { layout . cancel ( true ) ; } catch ( Exception e ) { log . error ( _STR , e ) ; } } stop ( true ) ; Shutdown the event loop if ( parameters . shutdownNettyEventLoop ) { nettyEventLoop . shutdownGracefully ( ) . syncUninterruptibly ( ) ; } } 
4940	public XmlOptions setCompileDownloadUrls ( ) { return set ( COMPILE _ DOWNLOAD _ URLS ) ; } 
4941	private DDLDropTableStatement dropTable ( boolean temp ) throws SQLSyntaxErrorException { boolean ifExists = false ; if ( lexer . token ( ) = = KW _ IF ) { lexer . nextToken ( ) ; match ( KW _ EXISTS ) ; ifExists = true ; } Identifier tb = identifier ( ) ; List < Identifier > list ; if ( lexer . token ( ) ! = PUNC _ COMMA ) { list = new ArrayList < Identifier > ( _NUM ) ; list . add ( tb ) ; } else { list = new LinkedList < Identifier > ( ) ; list . add ( tb ) ; for ( ; lexer . token ( ) = = PUNC _ COMMA ; ) { lexer . nextToken ( ) ; tb = identifier ( ) ; list . add ( tb ) ; } } DDLDropTableStatement . Mode mode = DDLDropTableStatement . Mode . UNDEF ; switch ( lexer . token ( ) ) { case KW _ RESTRICT : lexer . nextToken ( ) ; mode = DDLDropTableStatement . Mode . RESTRICT ; break ; case KW _ CASCADE : lexer . nextToken ( ) ; mode = DDLDropTableStatement . Mode . CASCADE ; break ; } return new DDLDropTableStatement ( list , temp , ifExists , mode ) ; } 
4942	public void characters ( final char [ ] ch , final int start , final int length ) throws SAXException { try { peekFactory ( ) . characters ( ch , start , length ) ; } catch ( ParseException pe ) { throw pe ; } catch ( Exception e ) { throw new ParseException ( e , getLocator ( ) ) ; } } 
4943	public static void writeToParcel ( CharSequence cs , Parcel p , int parcelableFlags ) { if ( cs instanceof Spanned ) { p . writeInt ( _NUM ) ; p . writeString ( cs . toString ( ) ) ; Spanned sp = ( Spanned ) cs ; Object [ ] os = sp . getSpans ( _NUM , cs . length ( ) , Object . class ) ; for ( int i = _NUM ; i < os . length ; i + + ) { Object o = os [ i ] ; Object prop = os [ i ] ; if ( prop instanceof CharacterStyle ) { prop = ( ( CharacterStyle ) prop ) . getUnderlying ( ) ; } if ( prop instanceof ParcelableSpan ) { final ParcelableSpan ps = ( ParcelableSpan ) prop ; final int spanTypeId = ps . getSpanTypeIdInternal ( ) ; if ( spanTypeId < FIRST _ SPAN | | spanTypeId > LAST _ SPAN ) { Log . e ( TAG , _STR ) ; } else { p . writeInt ( spanTypeId ) ; ps . writeToParcelInternal ( p , parcelableFlags ) ; writeWhere ( p , sp , o ) ; } } } p . writeInt ( _NUM ) ; } else { p . writeInt ( _NUM ) ; if ( cs ! = null ) { p . writeString ( cs . toString ( ) ) ; } else { p . writeString ( null ) ; } } } 
4944	private void testManyEvents ( int nodes , int backups , Replication replication ) throws Throwable { createServers ( nodes ) ; PrimaryBackupClient client = createClient ( ) ; PrimitiveProxy session = createProxy ( client , backups , replication ) ; session . addEventListener ( message - > { threadAssertNotNull ( message ) ; resume ( ) ; } ) ; for ( int i = _NUM ; i < _NUM _NUM ; i + + ) { session . invoke ( EVENT , SERIALIZER : : encode , true ) . thenRun ( this : : resume ) ; await ( _NUM _NUM _NUM _NUM , _NUM ) ; } } 
4945	public void addLazyExpiration ( ) { Duration creation = getDurationFor ( _STR ) Factory < ? extends ExpiryPolicy > factory = eternal ? EternalExpiryPolicy . factoryOf ( ) : FactoryBuilder . factoryOf ( new JCacheExpiryPolicy ( creation , update , access ) ) ; configuration . setExpiryPolicyFactory ( factory ) ; } 
4946	public boolean set ( long index ) { if ( ! ( index < size ) ) throw new IndexOutOfBoundsException ( ) ; if ( ! get ( index ) ) { bytes . writeLong ( offset ( index ) , bytes . readLong ( offset ( index ) ) | ( _NUM l < < position ( index ) ) ) ; count + + ; return true ; } return false ; } 
4947	public int getStatus ( ) { NamedList header = getResponseHeader ( ) ; if ( header ! = null ) { return ( Integer ) header . get ( _STR ) ; } else { return _NUM ; } } 
4948	protected long registerWithLeader ( int pktType ) throws IOException { long lastLoggedZxid = self . getLastLoggedZxid ( ) ; QuorumPacket qp = new QuorumPacket ( ) ; qp . setType ( pktType ) ; qp . setZxid ( ZxidUtils . makeZxid ( self . getAcceptedEpoch ( ) , _NUM ) ) ; LearnerInfo li = new LearnerInfo ( self . getId ( ) , _NUM x _NUM _NUM _NUM _NUM _NUM , self . getQuorumVerifier ( ) . getVersion ( ) ) ; ByteArrayOutputStream bsid = new ByteArrayOutputStream ( ) ; BinaryOutputArchive boa = BinaryOutputArchive . getArchive ( bsid ) ; boa . writeRecord ( li , _STR ) ; } return qp . getZxid ( ) ; } } 
4949	public boolean setTableModelBounds ( ) { List < ? > entityParts = getChildren ( ) ; for ( Iterator < ? > iter = entityParts . iterator ( ) ; iter . hasNext ( ) ; ) { NodePart entityPart = ( NodePart ) iter . next ( ) ; IFigure entityFigure = entityPart . getFigure ( ) ; continue if ( entityFigure = = null ) { continue ; } Rectangle bounds = entityFigure . getBounds ( ) . getCopy ( ) ; entityPart . setBounds ( bounds ) ; } return true ; } 
4950	public static String resource ( Path path ) { String str = IO . read ( path ) ; return str ; } 
4951	protected void onCancel ( ClickEvent event ) { hide ( ) ; } 
4952	public void actionDeleteProject ( ) throws Exception { String pId = getJsp ( ) . getRequest ( ) . getParameter ( CmsEditProjectDialog . PARAM _ PROJECTID ) ; getCms ( ) . deleteProject ( new CmsUUID ( pId ) ) ; refreshList ( ) ; actionCloseDialog ( ) ; } 
4953	public static XmlNCName parse ( java . io . File f , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( XmlNCName ) XmlBeans . getContextTypeLoader ( ) . parse ( f , type , options ) ; } 
4954	public Instances generateExamples ( int num , Random random , Instances format ) throws Exception { if ( format = = null ) throw new Exception ( _STR ) ; generate values for all attributes for ( int i = _NUM ; i < num ; i + + ) { over all examples to be produced Instance example = generateExample ( random , format ) ; set class of example using decision list boolean classDefined = classifyExample ( example ) ; if ( ! classDefined ) { set class with newly generated rule example = updateDecisionList ( random , example ) ; } example . setDataset ( format ) ; format . add ( example ) ; } return ( format ) ; } 
4955	public static HRegion createRegionAndWAL ( final RegionInfo info , final Path rootDir , final Configuration conf , final TableDescriptor htd , boolean initialize ) throws IOException { ChunkCreator . initialize ( MemStoreLABImpl . CHUNK _ SIZE _ DEFAULT , false , _NUM , _NUM , _NUM , null ) ; WAL wal = createWal ( conf , rootDir , info ) ; return HRegion . createHRegion ( info , rootDir , conf , htd , wal , initialize ) ; } 
4956	public String getHelpText ( I _ CmsWidgetDialog widgetDialog , I _ CmsWidgetParameter param ) { String helpId = getDisabledHelpKey ( param ) ; Set < String > helpIdsShown = widgetDialog . getHelpMessageIds ( ) ; if ( helpIdsShown . contains ( helpId ) ) { help hey has already been included in output return _STR ; } } } 
4957	private boolean isSimple ( ) { ArrayList < Segment _NUM D > edges = getEdges ( ) ; for ( Segment _NUM D e _NUM : edges ) { for ( Segment _NUM D e _NUM : edges ) { if ( e _NUM = = e _NUM ) continue ; if ( e _NUM . hasCommonEnd ( e _NUM ) ) continue ; if ( e _NUM . intersectAtSinglePoint ( e _NUM ) ) { Point _NUM D intersection = e _NUM . getUniqueIntersection ( e _NUM ) ; if ( e _NUM . hasPoint ( intersection ) | | e _NUM . hasPoint ( intersection ) ) TODO Ã  voir si on autorise le cas des edges qui se touchent mais ne se croisent pas continue ; else return false ; } } } return true ; } 
4958	private void setAvailabilityInfo ( CmsResource resource , CmsAvailabilityInfoBean bean ) throws CmsException { ensureLock ( resource ) ; modifyPublishScheduled ( resource , bean . getDatePubScheduled ( ) ) ; modifyAvailability ( resource , bean . getDateReleased ( ) , bean . getDateExpired ( ) ) ; modifyNotification ( resource , bean . getNotificationInterval ( ) , bean . isNotificationEnabled ( ) , bean . isModifySiblings ( ) ) ; tryUnlock ( resource ) ; } 
4959	private copy of bytes if it ' s shared with others : public synchronized byte [ ] copyOnWrite ( ) throws IOException { assert refCount > _NUM & & ( origNorm = = null | | origNorm . refCount > _NUM ) ; bytes ( ) ; assert bytes ! = null ; assert bytesRef ! = null ; if ( bytesRef . get ( ) > _NUM ) { _STR can be changed : assert refCount = = _NUM ; final AtomicInteger oldRef = bytesRef ; bytes = owner . cloneNormBytes ( bytes ) ; bytesRef = new AtomicInteger ( _NUM ) ; oldRef . decrementAndGet ( ) ; } dirty = true ; return bytes ; } 
4960	public static boolean contains ( String name ) { return get ( name ) ! = null ; } 
4961	public String getText ( ) { String text ; try { TextListener tl = triggerExtraction ( ) ; text = tl . _ text . toString ( ) ; if ( ! text . endsWith ( _STR ; } } catch ( IOException e ) { throw new RuntimeException ( e ) ; } return text ; } 
4962	public static DoubleList toDoubleList ( Collection < ? > inputList , String propertyPath ) { if ( inputList . size ( ) = = _NUM ) { return new DoubleList ( _NUM ) ; } DoubleList outputList = new DoubleList ( inputList . size ( ) ) ; if ( propertyPath . contains ( _STR ) ; for ( Object o : inputList ) { outputList . add ( BeanUtils . getPropertyDouble ( o , properties ) ) ; } } else { Map < String , FieldAccess > fields = BeanUtils . getFieldsFromObject ( inputList . iterator ( ) . next ( ) ) ; FieldAccess fieldAccess = fields . get ( propertyPath ) ; for ( Object o : inputList ) { outputList . add ( fieldAccess . getDouble ( o ) ) ; } } return outputList ; } 
4963	private static boolean tenantExists ( final UserGroupProvider userGroupProvider , final String identifier , final String identity ) { for ( User user : userGroupProvider . getUsers ( ) ) { if ( ! user . getIdentifier ( ) . equals ( identifier ) & & user . getIdentity ( ) . equals ( identity ) ) { return true ; } } for ( Group group : userGroupProvider . getGroups ( ) ) { if ( ! group . getIdentifier ( ) . equals ( identifier ) & & group . getName ( ) . equals ( identity ) ) { return true ; } } return false ; } 
4964	public STSResponse renew ( SecurityToken tok ) throws Exception { createClient ( ) ; BindingOperationInfo boi = findOperation ( _STR , namespace ) ; StaxUtils . copy ( tok . getToken ( ) , writer ) ; writer . writeEndElement ( ) ; Write out renewal semantics writeRenewalSemantics ( writer ) ; writer . writeEndElement ( ) ; Object [ ] obj = client . invoke ( boi , new DOMSource ( writer . getDocument ( ) . getDocumentElement ( ) ) ) ; return new STSResponse ( ( DOMSource ) obj [ _NUM ] , null ) ; } 
4965	public static int collectStats ( Row row , PartitionStatisticsCollector collector ) { assert ! row . isEmpty ( ) ; collector . update ( row . primaryKeyLivenessInfo ( ) ) ; collector . update ( row . deletion ( ) . time ( ) ) ; we have to wrap these for the lambda final WrappedInt columnCount = new WrappedInt ( _NUM ) ; final WrappedInt cellCount = new WrappedInt ( _NUM ) ; row . apply ( cd - > { if ( cd . column ( ) . isSimple ( ) ) { columnCount . increment ( ) ; cellCount . increment ( ) ; Cells . collectStats ( ( Cell ) cd , collector ) ; } else { ComplexColumnData complexData = ( ComplexColumnData ) cd ; collector . update ( complexData . complexDeletion ( ) ) ; if ( complexData . hasCells ( ) ) { columnCount . increment ( ) ; for ( Cell cell : complexData ) { cellCount . increment ( ) ; Cells . collectStats ( cell , collector ) ; } } } } , false ) ; collector . updateColumnSetPerRow ( columnCount . get ( ) ) ; return cellCount . get ( ) ; } 
4966	public void getCurrentTaskTransforms ( ArrayList < Task > tasks , ArrayList < TaskViewTransform > transformsOut ) { Utilities . matchTaskListSize ( tasks , transformsOut ) ; int focusState = mLayoutAlgorithm . getFocusState ( ) ; for ( int i = tasks . size ( ) - _NUM ; i > = _NUM ; i - - ) { Task task = tasks . get ( i ) ; TaskViewTransform transform = transformsOut . get ( i ) ; TaskView tv = getChildViewForTask ( task ) ; if ( tv ! = null ) { transform . fillIn ( tv ) ; } else { mLayoutAlgorithm . getStackTransform ( task , mStackScroller . getStackScroll ( ) , focusState , transform , null , true , false ) ; } transform . visible = true ; } } 
4967	 @ SuppressWarnings ( _STR + e . getMessage ( ) , e ) ; } catch ( Exception e ) { throw new ResponseParseException ( e . getMessage ( ) , e ) ; } } 
4968	public void seekToBeginningAfterReadingWholeBlock ( ) throws IOException { Read the whole block . int blockSize = ( int ) BLOCK _ LENGTH ; byte [ ] block = new byte [ blockSize ] ; mTestStream . read ( block ) ; assertArrayEquals ( BufferUtils . getIncreasingByteArray ( _NUM , blockSize ) , block ) ; Seek to the beginning of the current block , then read half of it . mTestStream . seek ( _NUM ) ; int halfBlockSize = blockSize / _NUM ; byte [ ] halfBlock = new byte [ halfBlockSize ] ; mTestStream . read ( halfBlock ) ; assertArrayEquals ( BufferUtils . getIncreasingByteArray ( _NUM , halfBlockSize ) , halfBlock ) ; } 
4969	public synchronized void onDestroy ( ) { cleanupService ( ) ; mHandler . getLooper ( ) . quit ( ) ; } 
4970	public static void matrixMultChain ( MatrixBlock mX , MatrixBlock mV , MatrixBlock mW , MatrixBlock ret , ChainType ct , int k ) { check inputs / outputs ( after that mV and mW guaranteed to be dense ) if ( mX . isEmptyBlock ( false ) | | mV . isEmptyBlock ( false ) | | ( mW ! = null & & mW . isEmptyBlock ( false ) ) ) { turn empty dense into sparse ret . examSparsity ( ) ; return ; } check temporary memory and too small workload for multi - threading if ( ! satisfiesMultiThreadingConstraints ( mX , true , true , mX . sparse ? _NUM : _NUM , k ) ) { matrixMultChain ( mX , mV , mW , ret , ct ) ; return ; } Timing time = new Timing ( true ) ; pre - processing ( no need to check isThreadSafe ) ret . sparse = false ; ret . allocateDenseBlock ( ) ; ( currently : always parallelization over number of rows ) try { ExecutorService pool = CommonThreadPool . get ( k ) ; ArrayList < Integer > blklens = UtilFunctions . getBalancedBlockSizesDefault ( mX . rlen , k , true ) ; ArrayList < MatrixMultChainTask > tasks = new ArrayList < > ( ) ; for ( int i = _NUM , lb = _NUM ; i < blklens . size ( ) ; lb + = blklens . get ( i ) , i + + ) tasks . add ( new MatrixMultChainTask ( mX , mV , mW , ct , lb , lb + blklens . get ( i ) ) ) ; List < Future < double [ ] > > taskret = pool . invokeAll ( tasks ) ; pool . shutdown ( ) ; aggregate partial results and error handling double [ ] [ ] a = new double [ taskret . size ( ) ] [ ] ; for ( int i = _NUM ; i < taskret . size ( ) ; i + + ) a [ i ] = taskret . get ( i ) . get ( ) ; vectAddAll ( a , ret . getDenseBlockValues ( ) , _NUM , _NUM , mX . clen ) ; } catch ( Exception ex ) { throw new DMLRuntimeException ( ex ) ; } post - processing ret . recomputeNonZeros ( ) ; ret . examSparsity ( ) ; System . out . println ( _STR + time . stop ( ) ) ; } 
4971	public void endPhase ( Phase phase ) { if ( ! isComplete ( ) ) { phases . get ( phase ) . endTime = monotonicNow ( ) ; } } 
4972	public void setSubtitle ( CharSequence subtitle ) { if ( ! TextUtils . isEmpty ( subtitle ) ) { if ( mSubtitleTextView = = null ) { final Context context = getContext ( ) ; mSubtitleTextView = new TextView ( context ) ; mSubtitleTextView . setSingleLine ( ) ; mSubtitleTextView . setEllipsize ( TextUtils . TruncateAt . END ) ; if ( mSubtitleTextAppearance ! = _NUM ) { mSubtitleTextView . setTextAppearance ( mSubtitleTextAppearance ) ; } if ( mSubtitleTextColor ! = _NUM ) { mSubtitleTextView . setTextColor ( mSubtitleTextColor ) ; } } if ( ! isChildOrHidden ( mSubtitleTextView ) ) { addSystemView ( mSubtitleTextView , true ) ; } } else if ( mSubtitleTextView ! = null & & isChildOrHidden ( mSubtitleTextView ) ) { removeView ( mSubtitleTextView ) ; mHiddenViews . remove ( mSubtitleTextView ) ; } if ( mSubtitleTextView ! = null ) { mSubtitleTextView . setText ( subtitle ) ; } mSubtitleText = subtitle ; } 
4973	private int getMostSizedNode ( final Data d , final int rn , final int lv , final TreeRect r , final int p ) { final int size = getHitBigRectNodesNum ( rn , lv , r ) ; final int idx = sub . preIndex ( rn , lv , p ) ; if ( idx < _NUM ) return - _NUM ; int dpre = - _NUM ; int si = _NUM ; for ( int i = _NUM ; i < size ; + + i ) { final int pre = sub . prePerIndex ( rn , lv , i + idx ) ; final int k = d . kind ( pre ) ; final int s = d . size ( pre , k ) ; if ( s > si ) { si = s ; dpre = pre ; } } return dpre ; } 
4974	public void testRegisterDexModuleBaseCode ( ) throws Exception { PackageManager pm = getPm ( ) ; ApplicationInfo info = getContext ( ) . getApplicationInfo ( ) ; TestDexModuleRegisterCallback callback = new TestDexModuleRegisterCallback ( ) ; pm . registerDexModule ( info . getBaseCodePath ( ) , callback ) ; assertTrue ( callback . waitTillDone ( ) ) ; assertEquals ( info . getBaseCodePath ( ) , callback . mDexModulePath ) ; assertFalse ( _STR , callback . mSuccess ) ; } 
4975	private I _ CmsWidget getEditorWidget ( CmsObject cms , I _ CmsWidgetDialog widgetDialog ) { if ( m _ editorWidget = = null ) { get HTML widget to use from editor manager String widgetClassName = OpenCms . getWorkplaceManager ( ) . getWorkplaceEditorManager ( ) . getWidgetEditor ( cms . getRequestContext ( ) , widgetDialog . getUserAgent ( ) ) ; boolean foundWidget = true ; if ( CmsStringUtil . isEmpty ( widgetClassName ) ) { no installed widget found , use default text area to edit HTML value widgetClassName = CmsTextareaWidget . class . getName ( ) ; foundWidget = false ; } try { if ( foundWidget ) { get widget instance and set the widget configuration Class < ? > widgetClass = Class . forName ( widgetClassName ) ; A _ CmsHtmlWidget editorWidget = ( A _ CmsHtmlWidget ) widgetClass . newInstance ( ) ; editorWidget . setHtmlWidgetOption ( getHtmlWidgetOption ( ) ) ; m _ editorWidget = editorWidget ; } else { set the text area to display _NUM _NUM rows for editing Class < ? > widgetClass = Class . forName ( widgetClassName ) ; I _ CmsWidget editorWidget = ( I _ CmsWidget ) widgetClass . newInstance ( ) ; editorWidget . setConfiguration ( _STR ) ; m _ editorWidget = editorWidget ; } } catch ( Exception e ) { failed to create widget instance LOG . error ( Messages . get ( ) . container ( Messages . LOG _ CREATE _ HTMLWIDGET _ INSTANCE _ FAILED _ _NUM , widgetClassName ) . key ( ) ) ; } } return m _ editorWidget ; } 
4976	public void buildKernel ( Instances data ) throws Exception { does kernel handle the data ? if ( ! getChecksTurnedOff ( ) ) getCapabilities ( ) . testWithFail ( data ) ; initVars ( data ) ; for ( int i = _NUM ; i < data . numInstances ( ) ; i + + ) m _ kernelPrecalc [ i ] = dotProd ( data . instance ( i ) , data . instance ( i ) ) ; } 
4977	public void setMinorTickMarkOutsideLength ( float length ) { this . minorTickMarkOutsideLength = length ; fireChangeEvent ( ) ; } 
4978	public void testIncompleteBatch ( ) throws IOException { final Agent [ ] agents = new Agent [ ] { Agent . createAgent ( _STR + i ) ) ; } transaction . commit ( ) ; transaction . close ( ) ; eventSource . stop ( ) ; } 
4979	private Multimap < String , PipelineOptionSpec > buildOptionNameToSpecMap ( Set < PipelineOptionSpec > props ) { Multimap < String , PipelineOptionSpec > optionsMap = HashMultimap . create ( ) ; for ( PipelineOptionSpec prop : props ) { optionsMap . put ( prop . getName ( ) , prop ) ; } Filter out overridden options for ( Map . Entry < String , Collection < PipelineOptionSpec > > entry : optionsMap . asMap ( ) . entrySet ( ) ) { List < PipelineOptionSpec > specs = Lists . newArrayList ( entry . getValue ( ) ) ; if ( specs . size ( ) < _NUM ) { Only one known implementing interface , no need to check for inheritance continue ; } for ( int i = _NUM ; i < specs . size ( ) - _NUM ; i + + ) { Class < ? > iface _NUM = specs . get ( i ) . getDefiningInterface ( ) ; for ( int j = i + _NUM ; j < specs . size ( ) ; j + + ) { Class < ? > iface _NUM = specs . get ( j ) . getDefiningInterface ( ) ; if ( iface _NUM . isAssignableFrom ( iface _NUM ) ) { optionsMap . remove ( entry . getKey ( ) , specs . get ( i ) ) ; specs . remove ( i ) ; Removed element at current _STR element in inner - loop . j - - ; } } } } return optionsMap ; } 
4980	public Delete addColumns ( final byte [ ] family , final byte [ ] qualifier , final long timestamp ) { if ( timestamp < _NUM ) { throw new IllegalArgumentException ( _STR + timestamp ) ; } List < Cell > list = getCellList ( family ) ; list . add ( new KeyValue ( this . row , family , qualifier , timestamp , KeyValue . Type . DeleteColumn ) ) ; return this ; } 
4981	private boolean tryBindViewHolderByDeadline ( ViewHolder holder , int offsetPosition , int position , long deadlineNs ) { holder . mOwnerRecyclerView = RecyclerView . this ; final int viewType = holder . getItemViewType ( ) ; long startBindNs = getNanoTime ( ) ; if ( deadlineNs ! = FOREVER _ NS & & ! mRecyclerPool . willBindInTime ( viewType , startBindNs , deadlineNs ) ) { abort - we have a deadline we can ' t meet return false ; } mAdapter . bindViewHolder ( holder , offsetPosition ) ; long endBindNs = getNanoTime ( ) ; mRecyclerPool . factorInBindTime ( holder . getItemViewType ( ) , endBindNs - startBindNs ) ; attachAccessibilityDelegate ( holder . itemView ) ; if ( mState . isPreLayout ( ) ) { holder . mPreLayoutPosition = position ; } return true ; } 
4982	public int getPrevWordBeginningOnTwoWordsBoundary ( int offset ) { return getBeginning ( offset , true ) ; } 
4983	public void afterCommit ( Entity entity ) { if ( ! isAuthorizationRequired ( ) ) { return ; } if ( entity ! = null ) { metadataTools . traverseAttributes ( entity , new ClearInaccessibleAttributesVisitor ( ) ) ; } } 
4984	public static void onServerAboutToStart ( MinecraftServer server ) { File worldDirectory = DimensionManager . getCurrentSaveRootDirectory ( ) ; if ( worldDirectory = = null ) { worldDirectory = server . getActiveAnvilConverter ( ) . getSaveLoader ( server . getFolderName ( ) , false ) . getWorldDirectory ( ) ; } final WorldData newInstance = new WorldData ( worldDirectory ) ; instance = newInstance ; newInstance . onServerStarting ( ) ; } 
4985	private void readParameterAnnotations ( int v , final String desc , final char [ ] buf , final boolean visible , final MethodVisitor mv ) { int i ; int n = b [ v + + ] & _NUM xFF ; workaround for a bug in javac ( javac compiler generates a parameter annotation array whose size is equal to the number of parameters in the Java source file , while it should generate an array whose size is equal to the number of parameters in the method descriptor - which includes the synthetic parameters added by the compiler ) . This work - around supposes that the synthetic parameters are the first ones . int synthetics = Type . getArgumentTypes ( desc ) . length - n ; AnnotationVisitor av ; for ( i = _NUM ; i < synthetics ; + + i ) { virtual annotation to detect synthetic parameters in MethodWriter av = mv . visitParameterAnnotation ( i , _STR , false ) ; if ( av ! = null ) { av . visitEnd ( ) ; } } for ( ; i < n + synthetics ; + + i ) { int j = readUnsignedShort ( v ) ; v + = _NUM ; for ( ; j > _NUM ; - - j ) { av = mv . visitParameterAnnotation ( i , readUTF _NUM ( v , buf ) , visible ) ; v = readAnnotationValues ( v + _NUM , buf , true , av ) ; } } } 
4986	public void assertEqual ( Description description , Character actual , char expected ) { assertNotNull ( description , actual ) ; if ( actual . charValue ( ) ! = expected ) { throw failures . failure ( description , shouldBeEqual ( actual , expected ) ) ; } } 
4987	public ParallelInference build ( ) { ParallelInference inference = new ParallelInference ( ) ; inference . batchLimit = this . batchLimit ; inference . queueLimit = this . queueLimit ; inference . inferenceMode = this . inferenceMode ; inference . model = this . model ; inference . workers = this . workers ; inference . init ( ) ; return inference ; } 
4988	public void buildClassifier ( Instances insts ) throws Exception { can classifier handle the data ? getCapabilities ( ) . testWithFail ( insts ) ; remove instances with missing class insts = new Instances ( insts ) ; insts . deleteWithMissingClass ( ) ; Compute mean of target value double yMean = insts . meanOrMode ( insts . classIndex ( ) ) ; Choose best attribute double minMsq = Double . MAX _ VALUE ; m _ attribute = null ; int chosen = - _NUM ; double chosenSlope = Double . NaN ; double chosenIntercept = Double . NaN ; for ( int i = _NUM ; i < insts . numAttributes ( ) ; i + + ) { if ( i ! = insts . classIndex ( ) ) { m _ attribute = insts . attribute ( i ) ; Compute slope and intercept double xMean = insts . meanOrMode ( i ) ; double sumWeightedXDiffSquared = _NUM ; double sumWeightedYDiffSquared = _NUM ; m _ slope = _NUM ; for ( int j = _NUM ; j < insts . numInstances ( ) ; j + + ) { Instance inst = insts . instance ( j ) ; if ( ! inst . isMissing ( i ) & & ! inst . classIsMissing ( ) ) { double xDiff = inst . value ( i ) - xMean ; double yDiff = inst . classValue ( ) - yMean ; double weightedXDiff = inst . weight ( ) * xDiff ; double weightedYDiff = inst . weight ( ) * yDiff ; m _ slope + = weightedXDiff * yDiff ; sumWeightedXDiffSquared + = weightedXDiff * xDiff ; sumWeightedYDiffSquared + = weightedYDiff * yDiff ; } } Skip attribute if not useful if ( sumWeightedXDiffSquared = = _NUM ) { continue ; } double numerator = m _ slope ; m _ slope / = sumWeightedXDiffSquared ; m _ intercept = yMean - m _ slope * xMean ; Compute sum of squared errors double msq = sumWeightedYDiffSquared - m _ slope * numerator ; Check whether this is the best attribute if ( msq < minMsq ) { minMsq = msq ; chosen = i ; chosenSlope = m _ slope ; chosenIntercept = m _ intercept ; } } } Set parameters if ( chosen = = - _NUM ) { if ( ! m _ suppressErrorMessage ) System . err . println ( _STR ) ; m _ attribute = null ; m _ attributeIndex = _NUM ; m _ slope = _NUM ; m _ intercept = yMean ; } else { m _ attribute = insts . attribute ( chosen ) ; m _ attributeIndex = chosen ; m _ slope = chosenSlope ; m _ intercept = chosenIntercept ; } } 
4989	public String getAggregatedInstanceId ( ShoppingCartItem item , LocalDispatcher dispatcher ) { if ( UtilValidate . isEmpty ( item . getConfigWrapper ( ) ) | | UtilValidate . isEmpty ( item . getConfigWrapper ( ) . getConfigId ( ) ) ) { return null ; } String newProductId = null ; String configId = item . getConfigWrapper ( ) . getConfigId ( ) ; try { first search for existing productId newProductId = ProductWorker . getAggregatedInstanceId ( getDelegator ( ) , item . getProductId ( ) , configId ) ; if ( newProductId ! = null ) { return newProductId ; } Delegator delegator = this . getDelegator ( ) ; create new product and associate it GenericValue product = item . getProduct ( ) ; String productName = product . getString ( _STR , serviceContext ) ; if ( ServiceUtil . isError ( result ) ) { Debug . logError ( ServiceUtil . getErrorMessage ( result ) , module ) ; return null ; } } } catch ( GenericEntityException gse ) { Debug . logError ( gse , module ) ; return null ; } catch ( GenericServiceException gse ) { Debug . logError ( gse , module ) ; return null ; } catch ( Exception e ) { Debug . logError ( e , module ) ; return null ; } return newProductId ; } 
4990	public static DoublesSketch wrap ( final Memory srcMem ) { if ( checkIsCompactMemory ( srcMem ) ) { return DirectCompactDoublesSketch . wrapInstance ( srcMem ) ; } else { return DirectUpdateDoublesSketchR . wrapInstance ( srcMem ) ; } } 
4991	public void setCurrentItemShowing ( int index , boolean animate ) { if ( index ! = HOUR _ INDEX & & index ! = MINUTE _ INDEX ) { Log . e ( TAG , _STR + index ) ; return ; } int lastIndex = getCurrentItemShowing ( ) ; mCurrentItemShowing = index ; if ( animate & & ( index ! = lastIndex ) ) { ObjectAnimator [ ] anims = new ObjectAnimator [ _NUM ] ; if ( index = = MINUTE _ INDEX ) { anims [ _NUM ] = mHourRadialTextsView . getDisappearAnimator ( ) ; anims [ _NUM ] = mHourRadialSelectorView . getDisappearAnimator ( ) ; anims [ _NUM ] = mMinuteRadialTextsView . getReappearAnimator ( ) ; anims [ _NUM ] = mMinuteRadialSelectorView . getReappearAnimator ( ) ; } else if ( index = = HOUR _ INDEX ) { anims [ _NUM ] = mHourRadialTextsView . getReappearAnimator ( ) ; anims [ _NUM ] = mHourRadialSelectorView . getReappearAnimator ( ) ; anims [ _NUM ] = mMinuteRadialTextsView . getDisappearAnimator ( ) ; anims [ _NUM ] = mMinuteRadialSelectorView . getDisappearAnimator ( ) ; } if ( mTransition ! = null & & mTransition . isRunning ( ) ) { mTransition . end ( ) ; } mTransition = new AnimatorSet ( ) ; mTransition . playTogether ( anims ) ; mTransition . start ( ) ; } else { int hourAlpha = ( index = = HOUR _ INDEX ) ? _NUM _NUM _NUM : _NUM ; int minuteAlpha = ( index = = MINUTE _ INDEX ) ? _NUM _NUM _NUM : _NUM ; ViewHelper . setAlpha ( mHourRadialTextsView , hourAlpha ) ; ViewHelper . setAlpha ( mHourRadialSelectorView , hourAlpha ) ; ViewHelper . setAlpha ( mMinuteRadialTextsView , minuteAlpha ) ; ViewHelper . setAlpha ( mMinuteRadialSelectorView , minuteAlpha ) ; } } 
4992	public void reset ( ) { buffer . clear ( ) ; if ( thread ! = null ) thread . interrupt ( ) ; try { called in AsyncLabelAwareIterator . reset ( ) . if ( thread ! = null ) thread . join ( ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new RuntimeException ( e ) ; } thread . shutdown ( ) ; buffer . clear ( ) ; backedIterator . reset ( ) ; shouldWork . set ( true ) ; this . thread = new AsyncPrefetchThread ( buffer , backedIterator , terminator ) ; Nd _NUM j . getAffinityManager ( ) . attachThreadToDevice ( thread , deviceId ) ; thread . setDaemon ( true ) ; thread . start ( ) ; hasDepleted . set ( false ) ; nextElement = null ; } 
4993	public boolean setFeature ( String f , double value ) { int index = featureIndex ( f ) ; assert ( index > = _NUM ) ; boolean hasBeenSet = isSet [ index ] ; values [ index ] = value ; isSet [ index ] = true ; return hasBeenSet ; } 
4994	public void test _NUM ( ) throws IOException { TreeMap < Key , Value > tm = new TreeMap < > ( ) ; newKeyValue ( tm , _STR , _NUM , false ) , EMPTY _ COL _ FAMS , false ) ; assertFalse ( it . hasTop ( ) ) ; } 
4995	public static void dropViewFromSchema ( AbstractSchema drillSchema , String viewName ) throws IOException { try { drillSchema . dropView ( viewName ) ; } catch ( Exception e ) { if ( SqlHandlerUtil . getTableFromSchema ( drillSchema , viewName ) ! = null ) { throw e ; } } } 
4996	public SeqType with ( final Type tp , final Occ oc ) { return type . eq ( tp ) & & occ = = oc & & kind = = null ? this : get ( tp , oc ) ; } 
4997	public double getXValue ( int series , int item ) { double result = Double . NaN ; Number x = getX ( series , item ) ; if ( x ! = null ) { result = x . doubleValue ( ) ; } return result ; } 
4998	public void addToRecentList ( final String clientId ) { CmsRpcAction < Void > action = new CmsRpcAction < Void > ( ) { @ Override public void execute ( ) { getContainerpageService ( ) . addToRecentList ( clientId , this ) ; } @ Override protected void onResponse ( Void result ) { nothing to do } } ; action . execute ( ) ; } 
4999	protected void executeBatchInsert ( final PreparedStatement pstmt ) { try { Need a Callable interface to be wrapped by Retryer . this . retryer . wrap ( new Callable < Boolean > ( ) { @ Override public Boolean call ( ) throws Exception { return insertBatch ( pstmt ) ; } } ) . call ( ) ; } catch ( Exception e ) { throw new RuntimeException ( _STR , e ) ; } resetBatch ( ) ; } 
5000	private PackingPlanBuilder getFFDAllocation ( PackingPlanBuilder packingPlanBuilder , PackingPlan currentPackingPlan , Map < String , Integer > componentChanges ) throws ResourceExceededException { this . numContainers = currentPackingPlan . getContainers ( ) . size ( ) ; Map < String , Integer > componentsToScaleDown = PackingUtils . getComponentsToScale ( componentChanges , PackingUtils . ScalingDirection . DOWN ) ; Map < String , Integer > componentsToScaleUp = PackingUtils . getComponentsToScale ( componentChanges , PackingUtils . ScalingDirection . UP ) ; if ( ! componentsToScaleDown . isEmpty ( ) ) { removeInstancesFromContainers ( packingPlanBuilder , componentsToScaleDown ) ; } if ( ! componentsToScaleUp . isEmpty ( ) ) { assignInstancesToContainers ( packingPlanBuilder , componentsToScaleUp ) ; } return packingPlanBuilder ; } 
5001	public int getNextToken ( ) throws java . io . IOException { int zzInput ; int zzAction ; cached fields : int zzCurrentPosL ; int zzMarkedPosL ; int zzEndReadL = zzEndRead ; char [ ] zzBufferL = zzBuffer ; char [ ] zzCMapL = ZZ _ CMAP ; int [ ] zzTransL = ZZ _ TRANS ; int [ ] zzRowMapL = ZZ _ ROWMAP ; int [ ] zzAttrL = ZZ _ ATTRIBUTE ; while ( true ) { zzMarkedPosL = zzMarkedPos ; yychar + = zzMarkedPosL - zzStartRead ; zzAction = - _NUM ; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL ; zzState = ZZ _ LEXSTATE [ zzLexicalState ] ; set up zzAction for empty match case : int zzAttributes = zzAttrL [ zzState ] ; if ( ( zzAttributes & _NUM ) = = _NUM ) { zzAction = zzState ; } zzForAction : { while ( true ) { if ( zzCurrentPosL < zzEndReadL ) zzInput = zzBufferL [ zzCurrentPosL + + ] ; else if ( zzAtEOF ) { zzInput = YYEOF ; break zzForAction ; } else { store back cached positions zzCurrentPos = zzCurrentPosL ; zzMarkedPos = zzMarkedPosL ; boolean eof = zzRefill ( ) ; get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos ; zzMarkedPosL = zzMarkedPos ; zzBufferL = zzBuffer ; zzEndReadL = zzEndRead ; if ( eof ) { zzInput = YYEOF ; break zzForAction ; } else { zzInput = zzBufferL [ zzCurrentPosL + + ] ; } } int zzNext = zzTransL [ zzRowMapL [ zzState ] + zzCMapL [ zzInput ] ] ; if ( zzNext = = - _NUM ) break zzForAction ; zzState = zzNext ; zzAttributes = zzAttrL [ zzState ] ; if ( ( zzAttributes & _NUM ) = = _NUM ) { zzAction = zzState ; zzMarkedPosL = zzCurrentPosL ; if ( ( zzAttributes & _NUM ) = = _NUM ) break zzForAction ; } } } store back cached position zzMarkedPos = zzMarkedPosL ; switch ( zzAction < _NUM ? zzAction : ZZ _ ACTION [ zzAction ] ) { case _NUM _NUM : { numWikiTokensSeen = _NUM ; positionInc = _NUM ; currentTokType = CATEGORY ; yybegin ( CATEGORY _ STATE ) ; break ; } case _NUM _NUM : break ; case _NUM _NUM : { currentTokType = BOLD _ ITALICS ; yybegin ( FIVE _ SINGLE _ QUOTES _ STATE ) ; break ; } case _NUM _NUM : break ; case _NUM _NUM : { currentTokType = HEADING ; yybegin ( DOUBLE _ EQUALS _ STATE ) ; numWikiTokensSeen + + ; return currentTokType ; } case _NUM _NUM : break ; case _NUM _NUM : { numBalanced = _NUM ; numWikiTokensSeen = _NUM ; currentTokType = EXTERNAL _ LINK ; yybegin ( EXTERNAL _ LINK _ STATE ) ; break ; } case _NUM _NUM : break ; case _NUM _NUM : { positionInc = _NUM ; return ACRONYM ; } case _NUM _NUM : break ; case _NUM : { positionInc = _NUM ; break ; } case _NUM _NUM : break ; case _NUM _NUM : { positionInc = _NUM ; return COMPANY ; } case _NUM _NUM : break ; case _NUM _NUM : { numLinkToks = _NUM ; positionInc = _NUM ; yybegin ( YYINITIAL ) ; break ; } case _NUM _NUM : break ; case _NUM _NUM : { currentTokType = SUB _ HEADING ; numWikiTokensSeen = _NUM ; yybegin ( STRING ) ; break ; } case _NUM _NUM : break ; case _NUM _NUM : { numWikiTokensSeen = _NUM ; positionInc = _NUM ; if ( numBalanced = = _NUM ) { numBalanced + + ; yybegin ( TWO _ SINGLE _ QUOTES _ STATE ) ; } else { numBalanced = _NUM ; } break ; } case _NUM _NUM : break ; case _NUM _NUM : { positionInc = _NUM ; return NUM ; } case _NUM _NUM : break ; case _NUM _NUM : { positionInc = _NUM ; return APOSTROPHE ; } case _NUM _NUM : break ; case _NUM _NUM : { yybegin ( STRING ) ; return currentTokType ; } case _NUM _NUM : break ; case _NUM _NUM : { break ; } case _NUM _NUM : break ; case _NUM : { positionInc = _NUM ; return ALPHANUM ; } case _NUM _NUM : break ; case _NUM : { numWikiTokensSeen = _NUM ; positionInc = _NUM ; break ; } case _NUM _NUM : break ; case _NUM _NUM : { yybegin ( DOUBLE _ BRACE _ STATE ) ; numWikiTokensSeen = _NUM ; return currentTokType ; } case _NUM _NUM : break ; case _NUM _NUM : { numBalanced = _NUM ; currentTokType = ALPHANUM ; yybegin ( YYINITIAL ) ; break ; } case _NUM _NUM : break ; case _NUM _NUM : { currentTokType = INTERNAL _ LINK ; numWikiTokensSeen = _NUM ; yybegin ( INTERNAL _ LINK _ STATE ) ; break ; } case _NUM _NUM : break ; case _NUM _NUM : { numBalanced = _NUM ; numWikiTokensSeen = _NUM ; currentTokType = CATEGORY ; yybegin ( CATEGORY _ STATE ) ; break ; } case _NUM _NUM : break ; case _NUM _NUM : { numLinkToks = _NUM ; yybegin ( YYINITIAL ) ; break ; } case _NUM _NUM : break ; case _NUM : { numWikiTokensSeen = _NUM ; positionInc = _NUM ; currentTokType = EXTERNAL _ LINK _ URL ; yybegin ( EXTERNAL _ LINK _ STATE ) ; break ; } case _NUM _NUM : break ; case _NUM _NUM : { numBalanced = _NUM ; currentTokType = ALPHANUM ; yybegin ( YYINITIAL ) ; break ; } case _NUM _NUM : break ; case _NUM _NUM : { currentTokType = EXTERNAL _ LINK ; numWikiTokensSeen = _NUM ; yybegin ( EXTERNAL _ LINK _ STATE ) ; break ; } case _NUM _NUM : break ; case _NUM : { positionInc = _NUM ; return CJ ; } case _NUM _NUM : break ; case _NUM _NUM : { currentTokType = CATEGORY ; numWikiTokensSeen = _NUM ; yybegin ( CATEGORY _ STATE ) ; break ; } case _NUM _NUM : break ; case _NUM : { yybegin ( CATEGORY _ STATE ) ; numWikiTokensSeen + + ; return currentTokType ; } case _NUM _NUM : break ; case _NUM _NUM : { currentTokType = BOLD ; yybegin ( THREE _ SINGLE _ QUOTES _ STATE ) ; break ; } case _NUM _NUM : break ; case _NUM _NUM : { numWikiTokensSeen = _NUM ; positionInc = _NUM ; currentTokType = CITATION ; yybegin ( DOUBLE _ BRACE _ STATE ) ; break ; } case _NUM _NUM : break ; case _NUM : { break ; } case _NUM _NUM : break ; case _NUM _NUM : { yybegin ( STRING ) ; numWikiTokensSeen + + ; return currentTokType ; } case _NUM _NUM : break ; case _NUM _NUM : { positionInc = _NUM ; numWikiTokensSeen + + ; yybegin ( EXTERNAL _ LINK _ STATE ) ; return currentTokType ; } case _NUM _NUM : break ; case _NUM _NUM : { numBalanced = _NUM ; currentTokType = ALPHANUM ; yybegin ( YYINITIAL ) ; break ; } case _NUM _NUM : break ; case _NUM _NUM : { yybegin ( YYINITIAL ) ; break ; } case _NUM _NUM : break ; case _NUM _NUM : { yybegin ( STRING ) ; numWikiTokensSeen + + ; return currentTokType ; } case _NUM _NUM : break ; case _NUM : { if ( numLinkToks = = _NUM ) { positionInc = _NUM ; } else { positionInc = _NUM ; } numWikiTokensSeen + + ; currentTokType = EXTERNAL _ LINK ; yybegin ( EXTERNAL _ LINK _ STATE ) ; numLinkToks + + ; return currentTokType ; } case _NUM _NUM : break ; case _NUM : { yybegin ( INTERNAL _ LINK _ STATE ) ; numWikiTokensSeen + + ; return currentTokType ; } case _NUM _NUM : break ; case _NUM _NUM : { positionInc = _NUM ; return EMAIL ; } case _NUM _NUM : break ; case _NUM _NUM : { currentTokType = INTERNAL _ LINK ; numWikiTokensSeen = _NUM ; yybegin ( INTERNAL _ LINK _ STATE ) ; break ; } case _NUM _NUM : break ; case _NUM _NUM : { numWikiTokensSeen = _NUM ; positionInc = _NUM ; yybegin ( DOUBLE _ EQUALS _ STATE ) ; break ; } case _NUM _NUM : break ; case _NUM _NUM : { positionInc = _NUM ; return HOST ; } case _NUM _NUM : break ; case _NUM _NUM : { numBalanced = _NUM ; numWikiTokensSeen = _NUM ; currentTokType = INTERNAL _ LINK ; yybegin ( INTERNAL _ LINK _ STATE ) ; break ; } case _NUM _NUM : break ; case _NUM _NUM : { currentTokType = ITALICS ; numWikiTokensSeen + + ; yybegin ( STRING ) ; return currentTokType ; } case _NUM _NUM : break ; case _NUM _NUM : { numWikiTokensSeen = _NUM ; positionInc = _NUM ; currentTokType = INTERNAL _ LINK ; yybegin ( INTERNAL _ LINK _ STATE ) ; break ; } case _NUM _NUM : break ; case _NUM _NUM : { numBalanced = _NUM ; currentTokType = ALPHANUM ; yybegin ( YYINITIAL ) ; break ; } case _NUM _NUM : break ; case _NUM _NUM : { yybegin ( YYINITIAL ) ; break ; } case _NUM _NUM : break ; default : if ( zzInput = = YYEOF & & zzStartRead = = zzCurrentPos ) { zzAtEOF = true ; return YYEOF ; } else { zzScanError ( ZZ _ NO _ MATCH ) ; } } } } 
5002	public static Wavetable square ( float dutyCycle ) { same as pulse return pulse ( dutyCycle ) ; } 
5003	private boolean skipBlankAndComma ( ) { boolean commaFound = false ; while ( ! isEOS ( ) ) { int c = str . charAt ( idx ) ; if ( c = = ' , ' ) { if ( commaFound ) return true ; else commaFound = true ; } else if ( ! ParseUtils . isBlank ( c ) ) { return true ; } + + idx ; } return false ; } 
5004	protected void closeAll ( ) { while ( m _ TabbedPane . getTabCount ( ) > _NUM ) { m _ TabbedPane . setSelectedIndex ( _NUM ) ; try { getCurrentTable ( ) . finalize ( ) ; } catch ( Throwable t ) { System . out . println ( t ) ; } m _ TabbedPane . removeTabAt ( _NUM ) ; } set buttons setButtons ( ) ; } 
5005	public void startTransition ( int durationMillis ) { mFrom = _NUM ; mTo = _NUM _NUM _NUM ; mAlpha = _NUM ; mDuration = mOriginalDuration = durationMillis ; mReverse = false ; mTransitionState = TRANSITION _ STARTING ; invalidateSelf ( ) ; } 
5006	public void iinc ( final int local , final int amount ) { mv . visitIincInsn ( local , amount ) ; } 
5007	public String getCustomName ( ) { return m _ visual . getText ( ) ; } 
5008	public static String pathDecode ( String value ) { return urlDecode ( value , StandardCharsets . UTF _ _NUM . name ( ) , true ) ; } 
5009	public Dimension getDialogPreferredSize ( ) { Component contentPane = super . getContentPane ( ) ; Style contentPaneStyle = getDialogStyle ( ) ; int width = Display . getInstance ( ) . getDisplayWidth ( ) ; int prefHeight = contentPane . getPreferredH ( ) ; int prefWidth = contentPane . getPreferredW ( ) ; prefWidth = Math . min ( prefWidth , width ) ; if ( contentPaneStyle . getBorder ( ) ! = null ) { prefWidth = Math . max ( contentPaneStyle . getBorder ( ) . getMinimumWidth ( ) , prefWidth ) ; prefHeight = Math . max ( contentPaneStyle . getBorder ( ) . getMinimumHeight ( ) , prefHeight ) ; } return new Dimension ( prefWidth , prefHeight ) ; } 
5010	private void autoSizeText ( ) { if ( ! isAutoSizeEnabled ( ) ) { return ; } if ( mNeedsAutoSizeText ) { if ( getMeasuredWidth ( ) < = _NUM | | getMeasuredHeight ( ) < = _NUM ) { return ; } final int availableWidth = mHorizontallyScrolling ? VERY _ WIDE : getMeasuredWidth ( ) - getTotalPaddingLeft ( ) - getTotalPaddingRight ( ) ; final int availableHeight = getMeasuredHeight ( ) - getExtendedPaddingBottom ( ) - getExtendedPaddingTop ( ) ; if ( availableWidth < = _NUM | | availableHeight < = _NUM ) { return ; } synchronized ( TEMP _ RECTF ) { TEMP _ RECTF . setEmpty ( ) ; TEMP _ RECTF . right = availableWidth ; TEMP _ RECTF . bottom = availableHeight ; final float optimalTextSize = findLargestTextSizeWhichFits ( TEMP _ RECTF ) ; if ( optimalTextSize ! = getTextSize ( ) ) { setTextSizeInternal ( TypedValue . COMPLEX _ UNIT _ PX , optimalTextSize , false ) ; makeNewLayout ( availableWidth , _NUM , UNKNOWN _ BORING , UNKNOWN _ BORING , mRight - mLeft - getCompoundPaddingLeft ( ) - getCompoundPaddingRight ( ) , false ) ; } } } Always try to auto - size if enabled . Functions that do not want to trigger auto - sizing after the next layout pass should set this to false . mNeedsAutoSizeText = true ; } 
5011	 - - - - - - - - - - - connections - - - - - - - - - - - @ POST @ Consumes ( MediaType . APPLICATION _ JSON ) @ Produces ( MediaType . APPLICATION _ JSON ) @ Path ( _STR ) ; } destination . authorize ( authorizer , RequestAction . WRITE , NiFiUserUtils . getNiFiUser ( ) ) ; } , ( ) - > serviceFacade . verifyCreateConnection ( groupId , requestConnection ) , connectionEntity - > { final ConnectionDTO connection = connectionEntity . getComponent ( ) ; set the processor id as appropriate connection . setId ( generateUuid ( ) ) ; create the new relationship target final Revision revision = getRevision ( connectionEntity , connection . getId ( ) ) ; final ConnectionEntity entity = serviceFacade . createConnection ( revision , groupId , connection ) ; connectionResource . populateRemainingConnectionEntityContent ( entity ) ; extract the href and build the response String uri = entity . getUri ( ) ; return generateCreatedResponse ( URI . create ( uri ) , entity ) . build ( ) ; } ) ; } 
5012	public void subtractFromThis ( GF _NUM Polynomial b ) { expandN ( b . len ) ; xorThisBy ( b ) ; } 
5013	public static < T , U > DisposableFlowable < U > runAsync ( Scheduler scheduler , final Processor < T , U > processor , final BiConsumer < ? super Subscriber < ? super T > , ? super Disposable > action ) { final SequentialDisposable d = new SequentialDisposable ( ) ; d . replace ( scheduler . scheduleDirect ( new Runnable ( ) { @ Override public void run ( ) { try { action . accept ( processor , d ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; processor . onError ( ex ) ; } } } ) ) ; return new DisposableFlowable < U > ( ) { @ Override protected void subscribeActual ( Subscriber < ? super U > s ) { processor . subscribe ( s ) ; } @ Override public boolean isDisposed ( ) { return d . isDisposed ( ) ; } @ Override public void dispose ( ) { d . dispose ( ) ; } } ; } 
5014	public synchronized Object create ( ) { ClassLoaderHolder orig = null ; ClassLoader loader = null ; try { if ( getBus ( ) ! = null ) { loader = getBus ( ) . getExtension ( ClassLoader . class ) ; if ( loader ! = null ) { orig = ClassLoaderUtils . setThreadContextClassloader ( loader ) ; } } configureObject ( ) ; if ( properties = = null ) { properties = new HashMap < > ( ) ; } if ( username ! = null ) { AuthorizationPolicy authPolicy = new AuthorizationPolicy ( ) ; authPolicy . setUserName ( username ) ; authPolicy . setPassword ( password ) ; properties . put ( AuthorizationPolicy . class . getName ( ) , authPolicy ) ; } initFeatures ( ) ; clientFactoryBean . setProperties ( properties ) ; if ( bus ! = null ) { clientFactoryBean . setBus ( bus ) ; } if ( dataBinding ! = null ) { clientFactoryBean . setDataBinding ( dataBinding ) ; } Client c = clientFactoryBean . create ( ) ; if ( getInInterceptors ( ) ! = null ) { c . getInInterceptors ( ) . addAll ( getInInterceptors ( ) ) ; } if ( getOutInterceptors ( ) ! = null ) { c . getOutInterceptors ( ) . addAll ( getOutInterceptors ( ) ) ; } if ( getInFaultInterceptors ( ) ! = null ) { c . getInFaultInterceptors ( ) . addAll ( getInFaultInterceptors ( ) ) ; } if ( getOutFaultInterceptors ( ) ! = null ) { c . getOutFaultInterceptors ( ) . addAll ( getOutFaultInterceptors ( ) ) ; } ClientProxy handler = clientClientProxy ( c ) ; Class < ? > [ ] classes = getImplementingClasses ( ) ; Object obj = ProxyHelper . getProxy ( getClassLoader ( clientFactoryBean . getServiceClass ( ) ) , classes , handler ) ; this . getServiceFactory ( ) . sendEvent ( FactoryBeanListener . Event . PROXY _ CREATED , classes , handler , obj ) ; return obj ; } finally { if ( orig ! = null ) { orig . reset ( ) ; } } } 
5015	private void generateXmlProlog ( Node . Nodes page ) { String omitXmlDecl = pageInfo . getOmitXmlDecl ( ) ; if ( ( omitXmlDecl ! = null & & ! JspUtil . booleanValue ( omitXmlDecl ) ) | | ( omitXmlDecl = = null & & page . getRoot ( ) . isXmlSyntax ( ) & & ! pageInfo . hasJspRoot ( ) & & ! ctxt . isTagFile ( ) ) ) { String cType = pageInfo . getContentType ( ) ; String charSet = cType . substring ( cType . indexOf ( _STR ) ; } } 
5016	public EscherDgRecord getEscherDgRecord ( ) { if ( dg = = null ) { EscherContainerRecord dgr = getDgContainer ( ) ; if ( dgr ! = null ) { for ( EscherRecord r : dgr . getChildRecords ( ) ) { if ( r instanceof EscherDgRecord ) { dg = ( EscherDgRecord ) r ; break ; } } } } return dg ; } 
5017	private static void parseLastInstallLog ( Context context ) { try ( BufferedReader in = new BufferedReader ( new FileReader ( LAST _ INSTALL _ FILE ) ) ) { String line = null ; int bytesWrittenInMiB = - _NUM , bytesStashedInMiB = - _NUM ; int timeTotal = - _NUM ; int uncryptTime = - _NUM ; int sourceVersion = - _NUM ; int temperatureStart = - _NUM ; int temperatureEnd = - _NUM ; int temperatureMax = - _NUM ; int errorCode = - _NUM ; int causeCode = - _NUM ; while ( ( line = in . readLine ( ) ) ! = null ) { Here is an example of lines in last _ install : . . . time _ total : _NUM _NUM _NUM bytes _ written _ vendor : _NUM _NUM _NUM _NUM _NUM bytes _ stashed _ vendor : _NUM _NUM _NUM int numIndex = line . indexOf ( ' : ' ) ; if ( numIndex = = - _NUM | | numIndex + _NUM > = line . length ( ) ) { continue ; } String numString = line . substring ( numIndex + _NUM ) . trim ( ) ; long parsedNum ; try { parsedNum = Long . parseLong ( numString ) ; } catch ( NumberFormatException ignored ) { Log . e ( TAG , _STR , e ) ; } } 
5018	public void deserialize ( RecordInput rin , String tag ) throws IOException { read in any header , version info rin . startRecord ( tag ) ; name this . name = rin . readString ( tag ) ; sTid . read ( rin , tag ) ; rin . endRecord ( tag ) ; } 
5019	public void checkAndHandleFirstVisibleCellChange ( ) { if ( mCurrentFirstVisibleItem ! = mPreviousFirstVisibleItem ) { if ( mCellIsMobile & & mMobileItemId ! = INVALID _ ID ) { updateNeighborViewsForId ( mMobileItemId ) ; handleCellSwitch ( ) ; } } } 
5020	public static String fromBytes ( byte [ ] bytes ) throws IOException { DataInputBuffer dbuf = new DataInputBuffer ( ) ; dbuf . reset ( bytes , _NUM , bytes . length ) ; StringBuilder buf = new StringBuilder ( bytes . length ) ; readChars ( dbuf , buf , bytes . length ) ; return buf . toString ( ) ; } 
5021	public void run ( ) throws Exception { StatusReporter reporter = null ; float [ ] oldAnims = null ; try { Choose which output we will do . if ( proto ) { reporter = new ProtoStatusReporter ( ) ; } else if ( wait ) { reporter = new TextStatusReporter ( rawMode ) ; } Choose whether we have to wait for the results . InstrumentationWatcher watcher = null ; UiAutomationConnection connection = null ; if ( reporter ! = null ) { watcher = new InstrumentationWatcher ( reporter ) ; connection = new UiAutomationConnection ( ) ; } Set the window animation if necessary if ( noWindowAnimation ) { oldAnims = mWm . getAnimationScales ( ) ; mWm . setAnimationScale ( _NUM , _NUM . _NUM f ) ; mWm . setAnimationScale ( _NUM , _NUM . _NUM f ) ; mWm . setAnimationScale ( _NUM , _NUM . _NUM f ) ; } Figure out which component we are tring to do . final ComponentName cn = parseComponentName ( componentNameArg ) ; Choose an ABI if necessary if ( abi ! = null ) { final String [ ] supportedAbis = Build . SUPPORTED _ ABIS ; boolean matched = false ; for ( String supportedAbi : supportedAbis ) { if ( supportedAbi . equals ( abi ) ) { matched = true ; break ; } } if ( ! matched ) { throw new AndroidException ( _STR , false ) ; return ; } } } catch ( Exception ex ) { Report failures if ( reporter ! = null ) { reporter . onError ( ex . getMessage ( ) , true ) ; } And re - throw the exception throw ex ; } finally { Clean up if ( oldAnims ! = null ) { mWm . setAnimationScales ( oldAnims ) ; } } } 
5022	public void setUri ( Uri uri ) { destroyLocalPlayer ( ) ; mUri = uri ; if ( mUri = = null ) { return ; } TODO : detect READ _ EXTERNAL and specific content provider case , instead of relying on throwing try opening uri locally before delegating to remote player mLocalPlayer = new MediaPlayer ( ) ; try { mLocalPlayer . setDataSource ( mContext , mUri ) ; mLocalPlayer . setAudioAttributes ( mAudioAttributes ) ; synchronized ( mPlaybackSettingsLock ) { applyPlaybackProperties _ sync ( ) ; } mLocalPlayer . prepare ( ) ; } catch ( SecurityException | IOException e ) { destroyLocalPlayer ( ) ; if ( ! mAllowRemote ) { Log . w ( TAG , _STR ) ; } } } 
5023	protected void onActivityResult ( final int requestCode , final int resultCode , final Intent data ) { if ( Log . isLoggable ( TAG , Log . VERBOSE ) ) { if ( data ! = null & & data . getExtras ( ) ! = null ) data . getExtras ( ) . keySet ( ) ; Bundle extras = data ! = null ? data . getExtras ( ) : null ; Log . v ( TAG , _STR ) ; } setResult ( Activity . RESULT _ CANCELED ) ; finish ( ) ; } 
5024	private V getOrLoad ( K key ) { boolean statsEnabled = statistics . isEnabled ( ) ; long start = statsEnabled ? ticker . read ( ) : _NUM L ; long millis = _NUM L ; Expirable < V > expirable = cache . getIfPresent ( key ) ; if ( ( expirable ! = null ) & & ! expirable . isEternal ( ) ) { millis = nanosToMillis ( ( start = = _NUM L ) ? ticker . read ( ) : start ) ; if ( expirable . hasExpired ( millis ) ) { Expirable < V > expired = expirable ; cache . asMap ( ) . computeIfPresent ( key , ( k , e ) - > { if ( e = = expired ) { dispatcher . publishExpired ( this , key , expired . get ( ) ) ; statistics . recordEvictions ( _NUM ) ; return null ; } return e ; } ) ; expirable = null ; } } if ( expirable = = null ) { expirable = cache . get ( key ) ; statistics . recordMisses ( _NUM L ) ; } else { statistics . recordHits ( _NUM L ) ; } V value = null ; if ( expirable ! = null ) { setAccessExpirationTime ( expirable , millis ) ; value = copyValue ( expirable ) ; } if ( statsEnabled ) { statistics . recordGetTime ( ticker . read ( ) - start ) ; } return value ; } 
5025	public MemoryWorkspace notifyScopeLeft ( ) { close ( ) ; return this ; } 
5026	public void setAxisOffset ( RectangleInsets offset ) { if ( offset = = null ) { throw new IllegalArgumentException ( _STR ) ; } this . axisOffset = offset ; fireChangeEvent ( ) ; } 
5027	public void createColumnFamilies ( String keyspace , List < ColumnFamilyDefinition > cfDefs ) { for ( ColumnFamilyDefinition cfDef : cfDefs ) { createColumnFamily ( keyspace , cfDef ) ; } } 
5028	private boolean snapFromFling ( @ NonNull LayoutManager layoutManager , int velocityX , int velocityY ) { if ( ! ( layoutManager instanceof ScrollVectorProvider ) ) { return false ; } SmoothScroller smoothScroller = createScroller ( layoutManager ) ; if ( smoothScroller = = null ) { return false ; } int targetPosition = findTargetSnapPosition ( layoutManager , velocityX , velocityY ) ; if ( targetPosition = = RecyclerView . NO _ POSITION ) { return false ; } smoothScroller . setTargetPosition ( targetPosition ) ; layoutManager . startSmoothScroll ( smoothScroller ) ; return true ; } 
5029	private void updatePasswordValidityCheckpointLocked ( int userHandle ) { DevicePolicyData policy = getUserData ( userHandle ) ; policy . mPasswordValidAtLastCheckpoint = isActivePasswordSufficientForUserLocked ( policy , policy . mUserHandle , false ) ; } 
5030	public boolean isCached ( String url ) { checkNotNull ( url , _STR ) ; return getCacheFile ( url ) . exists ( ) ; } 
5031	private void performRecycling ( int delta , View firstView , View lastView , RecyclerView . Recycler recycler ) { if ( SHOW _ LOGS ) Log . v ( TAG , _STR + delta ) ; if ( delta < _NUM ) { recycleTopIfNeeded ( firstView , recycler ) ; addToBottomIfNeeded ( lastView , recycler ) ; } else { recycleBottomIfNeeded ( lastView , recycler ) ; addTopIfNeeded ( firstView , recycler ) ; } } 
5032	protected Dispatcher initDispatcherWithConfigs ( String configs ) { Map < String , String > params = new HashMap < String , String > ( ) ; params . put ( _STR , configs ) ; return initDispatcher ( params ) ; } 
5033	public void setAvailabilityInfo ( CmsUUID structureId , CmsAvailabilityInfoBean bean ) throws CmsRpcException { try { CmsResource res = getCmsObject ( ) . readResource ( structureId , CmsResourceFilter . IGNORE _ EXPIRATION ) ; setAvailabilityInfo ( res , bean ) ; } catch ( CmsException e ) { error ( e ) ; } } 
5034	public String getCreatedPropertyString ( ) { return getDateValue ( created ) ; } 
5035	protected void executeSearch ( ) { getList ( ) . setSearchFilter ( getParamSearchFilter ( ) ) ; } 
5036	public Builder clearColumns ( ) { if ( columnsBuilder _ = = null ) { columns _ = java . util . Collections . emptyList ( ) ; bitField _NUM _ = ( bitField _NUM _ & ~ _NUM x _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM ) ; onChanged ( ) ; } else { columnsBuilder _ . clear ( ) ; } return this ; } 
5037	public void pressKey ( int keyCode ) { try { iArms . pressKey ( keyCode ) ; } catch ( RemoteException e ) { e . printStackTrace ( ) ; } sleepMini ( ) ; } 
5038	public void testReduceCountNotNullable ( ) { CalciteAssert . hr ( ) . query ( _STR ) ; } 
5039	public Sha _NUM _NUM _NUM Hash getHash ( ) { if ( hash = = null ) hash = calculateHash ( ) ; return hash ; } 
5040	public float calculateHeights ( boolean firsttime ) { if ( totalWidth < = _NUM ) return _NUM ; totalHeight = _NUM ; for ( int k = _NUM ; k < rows . size ( ) ; + + k ) { totalHeight + = getRowHeight ( k , firsttime ) ; } return totalHeight ; } 
5041	public void addBind ( String expression , Var var ) throws ParseException { getClause ( ) . addElement ( new ElementBind ( var , ExprUtils . parse ( query , expression , true ) ) ) ; } 
5042	protected void onDraw ( Canvas canvas ) { super . onDraw ( canvas ) ; do the scrolling animation . Need to tick it here and call postInvalidate ( ) until the scrolling is done . if ( Build . VERSION . SDK _ INT < _NUM _NUM ) { tickScrollAnimation ( ) ; if ( ! mScroller . isFinished ( ) ) { mGraph . postInvalidate ( ) ; } } } 
5043	private Method getPropertyFunction ( Class targetClass , String prefix , Class valueType ) { TODO : faster implementation . . . Method returnVal = null ; String methodName = getMethodName ( prefix , mPropertyName ) ; Class [ ] args = null ; if ( valueType = = null ) { try { returnVal = targetClass . getMethod ( methodName , args ) ; } catch ( NoSuchMethodException e ) { Log . e ( _STR + mValueType ) ; } return returnVal ; } 
5044	public void removeStatusListener ( @ NonNull DownloadRequest request , @ NonNull DownloadStatusListener listener ) { try { IMbmsDownloadService downloadService = mService . get ( ) ; if ( downloadService = = null ) { throw new IllegalStateException ( _STR ) ; } sendErrorToApp ( result , null ) ; return ; } } catch ( RemoteException e ) { mService . set ( null ) ; sIsInitialized . set ( false ) ; sendErrorToApp ( MbmsErrors . ERROR _ MIDDLEWARE _ LOST , null ) ; return ; } } finally { InternalDownloadStatusListener internalCallback = mInternalDownloadStatusListeners . remove ( listener ) ; if ( internalCallback ! = null ) { internalCallback . stop ( ) ; } } } 
5045	public static long getTotalSizeOfCells ( Result result ) { long size = _NUM ; if ( result . isEmpty ( ) ) { return size ; } for ( Cell c : result . rawCells ( ) ) { size + = PrivateCellUtil . estimatedSizeOfCell ( c ) ; } return size ; } 
5046	public void setPageMargin ( int marginPixels ) { final int oldMargin = mPageMargin ; mPageMargin = marginPixels ; final int width = getWidth ( ) ; recomputeScrollPosition ( width , width , marginPixels , oldMargin ) ; requestLayout ( ) ; } 
5047	public static void registerPushOnServer ( String id , String applicationKey , byte pushType , String udid , String packageName ) { registerServerPush ( id , applicationKey , pushType , udid , packageName ) ; } 
5048	public Builder addConnection ( Type t , Script . KernelID from , Script . KernelID to ) { android . util . Log . v ( _STR ) ; } ConnectLine cl = new ConnectLine ( t , from , to ) ; mLines . add ( new ConnectLine ( t , from , to ) ) ; nf . mOutputs . add ( cl ) ; nt . mInputs . add ( cl ) ; validateCycle ( nf , nf ) ; return this ; } 
5049	boolean setBaseCodePath ( @ NonNull final String packageName , final int userId , @ NonNull final String path ) throws BadKeyException { final int idx = select ( packageName , userId ) ; if ( idx < _NUM ) { throw new BadKeyException ( packageName , userId ) ; } return mItems . get ( idx ) . setBaseCodePath ( path ) ; } 
5050	protected void removeCommands ( Command clear , Command t _NUM , Command originalClear ) { Form f = getComponentForm ( ) ; if ( f ! = null ) { f . removeCommand ( clear ) ; f . removeCommand ( t _NUM ) ; if ( selectCommand ! = null ) { f . removeCommand ( selectCommand ) ; } f . setClearCommand ( originalClearCommand ) ; if ( replaceMenu & & originalCommands ! = null ) { int olen = originalCommands . length ; for ( int iter = olen - _NUM ; iter > = _NUM ; iter - - ) { f . addCommand ( originalCommands [ iter ] ) ; } originalCommands = null ; } f . revalidate ( ) ; } } 
5051	public void testBlockCompressSequenceFileWriterSync ( ) throws IOException , EventDeliveryException { String hdfsPath = testPath + _STR ) ) ; } fs . close ( ) ; } 
5052	static ParquetInputSplit from ( FileSplit split ) throws IOException { return new ParquetInputSplit ( split . getPath ( ) , split . getStart ( ) , split . getStart ( ) + split . getLength ( ) , split . getLength ( ) , split . getLocations ( ) , null ) ; } 
5053	public JsonWriter value ( long value ) throws IOException { writeDeferredName ( ) ; beforeValue ( false ) ; out . write ( Long . toString ( value ) ) ; return this ; } 
5054	public Map < Path , WalState > getAllState ( ) throws WalMarkerException { Map < Path , WalState > result = new HashMap < > ( ) ; for ( Entry < TServerInstance , List < UUID > > entry : getAllMarkers ( ) . entrySet ( ) ) { for ( UUID id : entry . getValue ( ) ) { Pair < WalState , Path > state = state ( entry . getKey ( ) , id ) ; result . put ( state . getSecond ( ) , state . getFirst ( ) ) ; } } return result ; } 
5055	private void updateContentShiftHeight ( ) { NotificationHeaderView notificationHeader = getVisibleNotificationHeader ( ) ; if ( notificationHeader ! = null ) { CachingIconView icon = notificationHeader . getIcon ( ) ; mIconTransformContentShift = getRelativeTopPadding ( icon ) + icon . getHeight ( ) ; } else { mIconTransformContentShift = mIconTransformContentShiftNoIcon ; } } 
5056	public void fireBindTargetChange ( Component source , String propertyName , Object oldValue , Object newValue ) { if ( listeners = = null | | listeners . size ( ) = = _NUM ) { return ; } BindTarget [ ] array ; synchronized ( this ) { array = new BindTarget [ listeners . size ( ) ] ; int alen = array . length ; for ( int iter = _NUM ; iter < alen ; iter + + ) { array [ iter ] = ( BindTarget ) listeners . get ( iter ) ; } } if we already are on the EDT just fire the event if ( Display . getInstance ( ) . isEdt ( ) ) { fireBindTargetChangeSync ( array , source , propertyName , oldValue , newValue ) ; } else { bindTargetArray = true ; Runnable cl = new CallbackClass ( array , new Object [ ] { source , propertyName , oldValue , newValue } ) ; if ( blocking ) { Display . getInstance ( ) . callSeriallyAndWait ( cl ) ; } else { Display . getInstance ( ) . callSerially ( cl ) ; } } } 
5057	public void iterateOverTable ( Iterator pti , AssignmentProposition . . . fixedValues ) { Map < RandomVariable , Object > possibleWorld = new LinkedHashMap < RandomVariable , Object > ( ) ; MixedRadixNumber tableMRN = new MixedRadixNumber ( _NUM , radices ) ; int [ ] tableRadixValues = new int [ radices . length ] ; all the fixed values to the possible world . for ( AssignmentProposition ap : fixedValues ) { if ( ! randomVarInfo . containsKey ( ap . getTermVariable ( ) ) ) { throw new IllegalArgumentException ( _STR ) ; } possibleWorld . put ( ap . getTermVariable ( ) , ap . getValue ( ) ) ; RVInfo fixedRVI = randomVarInfo . get ( ap . getTermVariable ( ) ) ; tableRadixValues [ fixedRVI . getRadixIdx ( ) ] = fixedRVI . getIdxForDomain ( ap . getValue ( ) ) ; } in this probability table if ( fixedValues . length = = randomVarInfo . size ( ) ) { Then only _NUM iteration call is required . pti . iterate ( possibleWorld , getValue ( fixedValues ) ) ; } else { Else iterate over the non - fixed values Set < RandomVariable > freeVariables = SetOps . difference ( this . randomVarInfo . keySet ( ) , possibleWorld . keySet ( ) ) ; Map < RandomVariable , RVInfo > freeVarInfo = new LinkedHashMap < RandomVariable , RVInfo > ( ) ; Remove the fixed Variables for ( RandomVariable fv : freeVariables ) { freeVarInfo . put ( fv , new RVInfo ( fv ) ) ; } int [ ] freeRadixValues = createRadixs ( freeVarInfo ) ; MixedRadixNumber freeMRN = new MixedRadixNumber ( _NUM , freeRadixValues ) ; Object fval = null ; Iterate through all combinations of the free variables do { the current index in the table MRN for ( RVInfo freeRVI : freeVarInfo . values ( ) ) { fval = freeRVI . getDomainValueAt ( freeMRN . getCurrentNumeralValue ( freeRVI . getRadixIdx ( ) ) ) ; possibleWorld . put ( freeRVI . getVariable ( ) , fval ) ; tableRadixValues [ randomVarInfo . get ( freeRVI . getVariable ( ) ) . getRadixIdx ( ) ] = freeRVI . getIdxForDomain ( fval ) ; } pti . iterate ( possibleWorld , values [ ( int ) tableMRN . getCurrentValueFor ( tableRadixValues ) ] ) ; } while ( freeMRN . increment ( ) ) ; } } 
5058	private void removeFromDisplay ( ) { final ActivityStackSupervisor . ActivityDisplay display = getDisplay ( ) ; if ( display ! = null ) { display . detachStack ( this ) ; } mDisplayId = INVALID _ DISPLAY ; mStacks = null ; if ( mTaskPositioner ! = null ) { mTaskPositioner . reset ( ) ; } if ( mStackId = = DOCKED _ STACK _ ID ) { If we removed a docked stack we want to resize it so it resizes all other stacks in the system to fullscreen . mStackSupervisor . resizeDockedStackLocked ( null , null , null , null , null , PRESERVE _ WINDOWS ) ; } } 
5059	public static void copyToFile ( final InputStream source , final File destination ) throws IOException { try ( InputStream in = source ; OutputStream out = openOutputStream ( destination ) ) { IOUtils . copy ( in , out ) ; } } 
5060	final void transformPage ( int pageWidth , float position ) { for ( TransformItem transformItem : mTransformItems ) { float translationX = position * pageWidth * transformItem . getShiftCoefficient ( ) ; if ( transformItem . getDirection ( ) = = Direction . RIGHT _ TO _ LEFT ) { translationX = - translationX ; } transformItem . getView ( ) . setTranslationX ( translationX ) ; } } 
5061	public void testRemove _NUM _ NullPointerException ( ) { ConcurrentMap c = map ( ) ; c . put ( _STR ) ; shouldThrow ( ) ; } catch ( NullPointerException success ) { } } 
5062	public void testLineageInfo ( ) throws Exception { String testConfFilePath = _STR ) ; Assert that there are two eventBuilders for nestedOrc and flattenedOrc Collection < LineageEventBuilder > lineageEventBuilders = LineageInfo . load ( Collections . singleton ( workUnit ) ) ; Assert . assertEquals ( lineageEventBuilders . size ( ) , _NUM ) ; } 
5063	private TreeMap . Entry < K , V > findStartNode ( ) { if ( fromStart ) { if ( loInclusive ) { return m . findCeilingEntry ( lo ) ; } else { return m . findHigherEntry ( lo ) ; } } else { return theSmallestEntry ( ) ; } } 
5064	public void setGridPresenter ( VerticalGridPresenter gridPresenter ) { if ( gridPresenter = = null ) { throw new IllegalArgumentException ( _STR ) ; } mGridPresenter = gridPresenter ; mGridPresenter . setOnItemViewSelectedListener ( mViewSelectedListener ) ; if ( mOnItemViewClickedListener ! = null ) { mGridPresenter . setOnItemViewClickedListener ( mOnItemViewClickedListener ) ; } } 
5065	private void recordLocalSymbolInIonRep ( IonStruct ionRep , String symbolName , int sid ) { assert sid > = myFirstLocalSid ; ValueFactory sys = ionRep . getSystem ( ) ; TODO this is crazy inefficient and not as reliable as it looks since it doesn ' t handle the case where ' s theres more than one list IonValue syms = ionRep . get ( SYMBOLS ) ; while ( syms ! = null & & syms . getType ( ) ! = IonType . LIST ) { ionRep . remove ( syms ) ; syms = ionRep . get ( SYMBOLS ) ; } if ( syms = = null ) { syms = sys . newEmptyList ( ) ; ionRep . put ( SYMBOLS , syms ) ; } int this _ offset = sid - myFirstLocalSid ; IonValue name = sys . newString ( symbolName ) ; ( ( IonList ) syms ) . add ( this _ offset , name ) ; } 
5066	public void testDirStatus ( ) throws Throwable { Path path = new Path ( _STR ) ; try { fs . mkdirs ( path ) ; assertIsDirectory ( fs , path ) ; } finally { delete ( fs , path ) ; } } 
5067	public int getMimeTypeCount ( ) { return mMimeTypes . size ( ) ; } 
5068	public void setAsText ( String text ) { SelectedTag s = ( SelectedTag ) getValue ( ) ; Tag [ ] tags = s . getTags ( ) ; try { for ( int i = _NUM ; i < tags . length ; i + + ) { if ( text . equals ( tags [ i ] . getReadable ( ) ) ) { setValue ( new SelectedTag ( tags [ i ] . getID ( ) , tags ) ) ; return ; } } } catch ( Exception ex ) { throw new java . lang . IllegalArgumentException ( text ) ; } } 
5069	public CmsAccessControlEntry readAccessControlEntry ( CmsDbContext dbc , CmsResource resource , CmsUUID principal ) throws CmsException { return getUserDriver ( dbc ) . readAccessControlEntry ( dbc , dbc . currentProject ( ) , resource . getResourceId ( ) , principal ) ; } 
5070	public static String readFileAsString ( String fileName ) { if ( ! fileName . startsWith ( _STR + fileName , e ) ; } } return result ; } 
5071	public static UnitValue parseUnitValueOrAlign ( String s , boolean isHor , UnitValue emptyReplacement ) { if ( s . length ( ) = = _NUM ) { return emptyReplacement ; } UnitValue align = parseAlignKeywords ( s , isHor ) ; if ( align ! = null ) { return align ; } return parseUnitValue ( s , emptyReplacement , isHor ) ; } 
5072	public final AC noGrid ( int . . . indexes ) { for ( int i = indexes . length - _NUM ; i > = _NUM ; i - - ) { int ix = indexes [ i ] ; makeSize ( ix ) ; cList . get ( ix ) . setNoGrid ( true ) ; } return this ; } 
5073	public void setDependencies ( List < CmsModuleDependency > dependencies ) { checkFrozen ( ) ; m _ dependencies = dependencies ; } 
5074	public void queryEmptyString ( ) throws IOException { final Query q = session . query ( _STR , q . next ( ) ) ; assertNull ( q . next ( ) ) ; } 
5075	public synchronized void addInstanceListener ( InstanceListener dsl ) { super . addInstanceListener ( dsl ) ; m _ instanceEventTargets + + ; try { if ( ( m _ Loader instanceof DatabaseLoader & & m _ dbSet & & m _ dataFormat = = null ) | | ( ! ( m _ Loader instanceof DatabaseLoader ) & & m _ dataFormat = = null ) ) { m _ dataFormat = m _ Loader . getStructure ( ) ; m _ dbSet = false ; } } catch ( Exception ex ) { } pass on any current instance format notifyStructureAvailable ( m _ dataFormat ) ; } 
5076	Fold getDeepestFoldContaining ( int offs ) { Fold deepestFold = this ; for ( int i = _NUM ; i < getChildCount ( ) ; i + + ) { Fold fold = getChild ( i ) ; if ( fold . containsOffset ( offs ) ) { deepestFold = fold . getDeepestFoldContaining ( offs ) ; break ; } } return deepestFold ; } 
5077	public static SearchResult replaceAll ( RTextArea textArea , SearchContext context ) { Always clear previous _STR ever . if ( context . getMarkAll ( ) ) { context = context . clone ( ) ; context . setMarkAll ( false ) ; } SearchResult lastFound = null ; int count = _NUM ; textArea . beginAtomicEdit ( ) ; try { int oldOffs = textArea . getCaretPosition ( ) ; textArea . setCaretPosition ( _NUM ) ; SearchResult res = SearchEngine . replace ( textArea , context ) ; while ( res . wasFound ( ) ) { lastFound = res ; count + + ; https : if ( res . getMatchRange ( ) . isZeroLength ( ) ) { if ( res . getMatchRange ( ) . getStartOffset ( ) = = textArea . getDocument ( ) . getLength ( ) ) { break ; } else { End of a line textArea . setCaretPosition ( textArea . getCaretPosition ( ) + _NUM ) ; } } res = SearchEngine . replace ( textArea , context ) ; } if ( lastFound = = null ) { If nothing was found , don ' t move the caret textArea . setCaretPosition ( oldOffs ) ; lastFound = new SearchResult ( ) ; } } finally { textArea . endAtomicEdit ( ) ; } lastFound . setCount ( count ) ; return lastFound ; } 
5078	public void setSimpleLabelOffset ( RectangleInsets offset ) { if ( offset = = null ) { throw new IllegalArgumentException ( _STR ) ; } this . simpleLabelOffset = offset ; fireChangeEvent ( ) ; } 
5079	public void completeTransaction ( ) { final boolean canceled ; canceled = mNumPostponed > _NUM ; FragmentManagerImpl manager = mRecord . mManager ; final int numAdded = manager . mAdded . size ( ) ; for ( int i = _NUM ; i < numAdded ; i + + ) { final Fragment fragment = manager . mAdded . get ( i ) ; fragment . setOnStartEnterTransitionListener ( null ) ; if ( canceled & & fragment . isPostponed ( ) ) { fragment . startPostponedEnterTransition ( ) ; } } mRecord . mManager . completeExecute ( mRecord , mIsBack , ! canceled , true ) ; } 
5080	public void setUnselectedStyle ( Style style ) { if ( this . unSelectedStyle ! = null ) { this . unSelectedStyle . removeStyleListener ( this ) ; } this . unSelectedStyle = style ; this . unSelectedStyle . addStyleListener ( this ) ; if ( this . unSelectedStyle . getBgPainter ( ) = = null ) { this . unSelectedStyle . setBgPainter ( new BGPainter ( ) ) ; } setShouldCalcPreferredSize ( true ) ; checkAnimation ( ) ; } 
5081	protected BeanManager findBeanManager ( ) { BeanManager bm = null ; try { Context initialContext = new InitialContext ( ) ; if ( jndiKey ! = null & & jndiKey . trim ( ) . length ( ) > _NUM ) { Check explicit configuration first , if given bm = lookup ( initialContext , jndiKey ) ; } if ( bm = = null ) { Check CDI default bm = lookup ( initialContext , CDI _ JNDIKEY _ BEANMANAGER _ COMP ) ; } if ( bm = = null ) { Check WELD default bm = lookup ( initialContext , CDI _ JNDIKEY _ BEANMANAGER _ APP ) ; } if ( bm = = null ) { Check Tomcat / Jetty default bm = lookup ( initialContext , CDI _ JNDIKEY _ BEANMANAGER _ COMP _ ENV ) ; } if ( bm = = null ) { LOG . error ( _STR , e ) ; } return bm ; } 
5082	public void testFromClientSideWhileSplitting ( ) throws Throwable { LOG . info ( _STR , regionSplitter . ex ) ; } one final check regionChecker . verify ( ) ; } 
5083	protected Appender findAppenderByName ( Document doc , String appenderName ) { Appender appender = ( Appender ) appenderBag . get ( appenderName ) ; if ( appender ! = null ) { return appender ; } else { Doesn ' t work on DOM Level _NUM : Element element = doc . getElementById ( appenderName ) ; Endre ' s hack : Element element = null ; NodeList list = doc . getElementsByTagName ( _STR ) ; return null ; } else { appender = parseAppender ( element ) ; if ( appender ! = null ) { appenderBag . put ( appenderName , appender ) ; } return appender ; } } } 
5084	public static X _NUM _NUM _NUM StreamParser getInstance ( String type ) throws NoSuchParserException { try { X _NUM _NUM _NUM Util . Implementation impl = X _NUM _NUM _NUM Util . getImplementation ( _STR , type ) ; return createParser ( impl ) ; } catch ( NoSuchAlgorithmException e ) { throw new NoSuchParserException ( e . getMessage ( ) ) ; } } 
5085	private static boolean decideHowtoExecute ( Graph dstGraph , Graph srcGraph ) { Avoid calling dstGraph . size ( ) return decideHowtoExecuteBySizeStep ( dstGraph , srcGraph ) ; } 
5086	private static String getCaller ( ) { StackTraceElement [ ] stackTrace = Thread . currentThread ( ) . getStackTrace ( ) ; if ( stackTrace . length < MIN _ STACK _ TRACE _ LENGTH ) { return UNKNOWN _ METHOD _ STRING ; } StackTraceElement caller = stackTrace [ METHOD _ TO _ TRACE _ LOCATION ] ; StackTraceElement previousCaller = stackTrace [ CALLER _ LOCATION ] ; if ( previousCaller . getClassName ( ) . startsWith ( UIAUTOMATOR _ PACKAGE ) ) { return null ; } int indexOfDot = caller . getClassName ( ) . lastIndexOf ( ' . ' ) ; if ( indexOfDot < _NUM ) { indexOfDot = _NUM ; } if ( indexOfDot + _NUM > = caller . getClassName ( ) . length ( ) ) { return UNKNOWN _ METHOD _ STRING ; } String shortClassName = caller . getClassName ( ) . substring ( indexOfDot + _NUM ) ; return String . format ( _STR , shortClassName , caller . getMethodName ( ) , previousCaller . getMethodName ( ) , previousCaller . getFileName ( ) , previousCaller . getLineNumber ( ) ) ; } 
5087	private void launchCognitoAuth ( final String redirectUri , final Set < String > tokenScopes ) { Build the complete web domain to launch the login screen Uri . Builder builder = new Uri . Builder ( ) . scheme ( ClientConstants . DOMAIN _ SCHEME ) . authority ( pool . getAppWebDomain ( ) ) . appendPath ( ClientConstants . DOMAIN _ PATH _ OAUTH _NUM ) . appendPath ( ClientConstants . DOMAIN _ PATH _ SIGN _ IN ) . appendQueryParameter ( ClientConstants . DOMAIN _ QUERY _ PARAM _ CLIENT _ ID , pool . getAppId ( ) ) . appendQueryParameter ( ClientConstants . DOMAIN _ QUERY _ PARAM _ REDIRECT _ URI , redirectUri ) . appendQueryParameter ( ClientConstants . DOMAIN _ QUERY _ PARAM _ RESPONSE _ TYPE , ClientConstants . AUTH _ RESPONSE _ TYPE _ CODE ) . appendQueryParameter ( ClientConstants . DOMAIN _ QUERY _ PARAM _ CODE _ CHALLENGE , proofKeyHash ) . appendQueryParameter ( ClientConstants . DOMAIN _ QUERY _ PARAM _ CODE _ CHALLENGE _ METHOD , ClientConstants . DOMAIN _ QUERY _ PARAM _ CODE _ CHALLENGE _ METHOD _ SHA _NUM _NUM _NUM ) . appendQueryParameter ( ClientConstants . DOMAIN _ QUERY _ PARAM _ STATE , state ) . appendQueryParameter ( ClientConstants . DOMAIN _ QUERY _ PARAM _ USERCONTEXTDATA , getUserContextData ( ) ) ; ; Convert scopes into a string of comma separated values . final int noOfScopes = tokenScopes . size ( ) ; if ( noOfScopes > _NUM ) { StringBuilder strBuilder = new StringBuilder ( ) ; int index = _NUM ; for ( String scope : tokenScopes ) { strBuilder . append ( scope ) ; if ( index + + < noOfScopes - _NUM ) { strBuilder . append ( _STR ) ; } } final String scopesStr = strBuilder . toString ( ) ; builder . appendQueryParameter ( ClientConstants . DOMAIN _ QUERY _ PARAM _ SCOPES , scopesStr ) ; } final Uri fqdn = builder . build ( ) ; LocalDataManager . cacheState ( context , state , proofKey , tokenScopes ) ; launchCustomTabs ( fqdn ) ; } 
5088	void populateUI ( ) { RandomAccessFile file ; Default values in case there ' s no data file yet int whichFilling = R . id . pastrami ; boolean addMayo = false ; boolean addTomato = false ; synchronized ( HugeBackupActivity . sDataLock ) { boolean exists = mDataFile . exists ( ) ; try { file = new RandomAccessFile ( mDataFile , _STR + buttonView ) ; recordNewUIState ( ) ; } } ; mAddMayoCheckbox . setOnCheckedChangeListener ( checkListener ) ; mAddTomatoCheckbox . setOnCheckedChangeListener ( checkListener ) ; } 
5089	 < Delegated > List < MvpPresenter < ? super Delegated > > getMvpPresenters ( Delegated delegated , String delegateTag ) { if ( ! hasMoxyReflector ( ) ) { return Collections . emptyList ( ) ; } @ SuppressWarnings ( _STR ) Class < ? super Delegated > aClass = ( Class < Delegated > ) delegated . getClass ( ) ; List < Object > presenterBinders = null ; while ( aClass ! = Object . class & & presenterBinders = = null ) { presenterBinders = MoxyReflector . getPresenterBinders ( aClass ) ; aClass = aClass . getSuperclass ( ) ; } if ( presenterBinders = = null | | presenterBinders . isEmpty ( ) ) { return Collections . emptyList ( ) ; } List < MvpPresenter < ? super Delegated > > presenters = new ArrayList < > ( ) ; PresentersCounter presentersCounter = MvpFacade . getInstance ( ) . getPresentersCounter ( ) ; for ( Object presenterBinderObject : presenterBinders ) { noinspection unchecked PresenterBinder < Delegated > presenterBinder = ( PresenterBinder < Delegated > ) presenterBinderObject ; List < PresenterField < Delegated > > presenterFields = presenterBinder . getPresenterFields ( ) ; for ( PresenterField < Delegated > presenterField : presenterFields ) { MvpPresenter < ? super Delegated > presenter = getMvpPresenter ( delegated , presenterField , delegateTag ) ; if ( presenter ! = null ) { presentersCounter . injectPresenter ( presenter , delegateTag ) ; presenters . add ( presenter ) ; presenterField . bind ( delegated , presenter ) ; } } } return presenters ; } 
5090	public void testDecommissionStatus ( ) throws Exception { InetSocketAddress addr = new InetSocketAddress ( _STR ) ; FSDataOutputStream st _NUM = writeIncompleteFile ( fileSys , file _NUM , replicas ) ; for ( DataNode d : cluster . getDataNodes ( ) ) { DataNodeTestUtils . triggerBlockReport ( d ) ; } FSNamesystem fsn = cluster . getNamesystem ( ) ; final DatanodeManager dm = fsn . getBlockManager ( ) . getDatanodeManager ( ) ; for ( int iteration = _NUM ; iteration < numDatanodes ; iteration + + ) { String downnode = decommissionNode ( fsn , client , localFileSys , iteration ) ; dm . refreshNodes ( conf ) ; decommissionedNodes . add ( downnode ) ; BlockManagerTestUtil . recheckDecommissionState ( dm ) ; final List < DatanodeDescriptor > decommissioningNodes = dm . getDecommissioningNodes ( ) ; if ( iteration = = _NUM ) { assertEquals ( decommissioningNodes . size ( ) , _NUM ) ; DatanodeDescriptor decommNode = decommissioningNodes . get ( _NUM ) ; checkDecommissionStatus ( decommNode , _NUM , _NUM , _NUM ) ; checkDFSAdminDecommissionStatus ( decommissioningNodes . subList ( _NUM , _NUM ) , fileSys , admin ) ; } else { assertEquals ( decommissioningNodes . size ( ) , _NUM ) ; DatanodeDescriptor decommNode _NUM = decommissioningNodes . get ( _NUM ) ; DatanodeDescriptor decommNode _NUM = decommissioningNodes . get ( _NUM ) ; This one is still _NUM , _NUM , _NUM since it passed over the UC block earlier , before node _NUM was decommed checkDecommissionStatus ( decommNode _NUM , _NUM , _NUM , _NUM ) ; This one is _NUM , _NUM , _NUM since it has the full state checkDecommissionStatus ( decommNode _NUM , _NUM , _NUM , _NUM ) ; checkDFSAdminDecommissionStatus ( decommissioningNodes . subList ( _NUM , _NUM ) , fileSys , admin ) ; } } Call refreshNodes on FSNamesystem with empty exclude file . This will remove the datanodes from decommissioning list and make them available again . writeConfigFile ( localFileSys , excludeFile , null ) ; dm . refreshNodes ( conf ) ; st _NUM . close ( ) ; cleanupFile ( fileSys , file _NUM ) ; cleanupFile ( fileSys , file _NUM ) ; } 
5091	public void assertNotLessThan ( Description description , Long actual , long expected ) { assertNotNull ( description , actual ) ; if ( isLessThan ( actual , expected ) ) { throw failures . failure ( description , shouldNotBeLessThan ( actual , expected ) ) ; } } 
5092	public void revokeAllOn ( IResource droppedResource ) { try { UntypedResultSet rows = process ( String . format ( _STR , droppedResource , e . getMessage ( ) ) ; return ; } } 
5093	public void highlightDates ( Collection < Date > dates , String uiid ) { for ( Date selectedDay : dates ) { java . util . Calendar cal = java . util . Calendar . getInstance ( tmz ) ; cal . setTime ( selectedDay ) ; cal . set ( java . util . Calendar . HOUR , _NUM ) ; cal . set ( java . util . Calendar . HOUR _ OF _ DAY , _NUM ) ; cal . set ( java . util . Calendar . MINUTE , _NUM ) ; cal . set ( java . util . Calendar . SECOND , _NUM ) ; cal . set ( java . util . Calendar . MILLISECOND , _NUM ) ; if ( ! highlightGroup . isEmpty ( ) ) { Collection < Date > datesArray = new ArrayList < Date > ( ) ; if ( highlightGroup . containsKey ( uiid ) ) { datesArray = highlightGroup . get ( uiid ) ; } datesArray . add ( cal . getTime ( ) ) ; highlightGroup . put ( uiid , datesArray ) ; } else { Collection < Date > datesArray = new ArrayList < Date > ( ) ; datesArray . add ( cal . getTime ( ) ) ; highlightGroup . put ( uiid , datesArray ) ; } } mv . setCurrentDay ( SELECTED _ DAY , true ) ; componentChanged ( ) ; } 
5094	public void onPlaystateChanged ( MediaSessionRecord record , int oldState , int newState ) { if ( shouldUpdatePriority ( oldState , newState ) ) { mSessions . remove ( record ) ; mSessions . add ( _NUM , record ) ; clearCache ( record . getUserId ( ) ) ; } else if ( ! MediaSession . isActiveState ( newState ) ) { Just clear the volume cache when a state goes inactive mCachedVolumeDefault = null ; } the audio playback configuration . if ( mMediaButtonSession ! = null & & mMediaButtonSession . getUid ( ) = = record . getUid ( ) ) { MediaSessionRecord newMediaButtonSession = findMediaButtonSession ( mMediaButtonSession . getUid ( ) ) ; if ( newMediaButtonSession ! = mMediaButtonSession ) { updateMediaButtonSession ( newMediaButtonSession ) ; } } } 
5095	public static XmlID parse ( javax . xml . stream . XMLStreamReader xsr , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException { return ( XmlID ) XmlBeans . getContextTypeLoader ( ) . parse ( xsr , type , options ) ; } 
5096	public static MultiLayerNetwork importKerasSequentialModelAndWeights ( String modelJsonFilename , String weightsHdf _NUM Filename ) throws IOException , InvalidKerasConfigurationException , UnsupportedKerasConfigurationException { KerasSequentialModel kerasModel = new KerasSequentialModel ( ) . modelBuilder ( ) . modelJsonFilename ( modelJsonFilename ) . weightsHdf _NUM Filename ( weightsHdf _NUM Filename ) . enforceTrainingConfig ( true ) . buildSequential ( ) ; return kerasModel . getMultiLayerNetwork ( ) ; } 
5097	public String readStaticExportPublishedResourceParameters ( CmsDbContext dbc , String rfsName ) throws CmsDataAccessException { String returnValue = null ; try { Query q = m _ sqlManager . createQuery ( dbc , C _ STATICEXPORT _ READ _ PUBLISHED _ LINK _ PARAMETERS ) ; q . setParameter ( _NUM , rfsName ) ; try { returnValue = ( String ) q . getSingleResult ( ) ; } catch ( NoResultException e ) { do nothing } } catch ( PersistenceException e ) { throw new CmsDataAccessException ( Messages . get ( ) . container ( Messages . ERR _ JPA _ PERSITENCE , e ) , e ) ; } return returnValue ; } 
5098	public void beforeAndAfterFlush ( CheckedFunction runnable ) throws Throwable { runnable . apply ( ) ; flush ( ) ; runnable . apply ( ) ; } 
5099	public void refresh ( ) { List < PaymentAppInfo > appInfos = mPaymentBackend . getPaymentAppInfos ( ) ; PaymentAppInfo defaultApp = mPaymentBackend . getDefaultApp ( ) ; if ( appInfos ! = null ) { PaymentAppInfo [ ] apps = appInfos . toArray ( new PaymentAppInfo [ appInfos . size ( ) ] ) ; mAdapter . updateApps ( apps , defaultApp ) ; } setTitle ( R . string . nfc _ payment _ default ) ; if ( defaultApp ! = null ) { setSummary ( defaultApp . label ) ; } else { setSummary ( mContext . getString ( R . string . nfc _ payment _ default _ not _ set ) ) ; } updateSettingsVisibility ( ) ; } 
5100	public final double KBRelativeInformation ( ) throws Exception { if ( ! m _ ClassIsNominal ) { throw new Exception ( _STR ) ; } if ( m _ NoPriors ) return Double . NaN ; return _NUM _NUM _NUM . _NUM * KBInformation ( ) / priorEntropy ( ) ; } 
5101	public void setDownloadStatus ( String jobId , Status status ) { DownloadJob dj = jobs . get ( jobId ) ; if ( dj = = null ) { s _ logger . warn ( _STR + new SimpleDateFormat ( ) . format ( new Date ( ) ) ) ; } } dj . cleanup ( ) ; break ; default : break ; } } 
5102	public String toSummaryString ( String title ) { StringBuffer result ; result = new StringBuffer ( title ) ; if ( title . length ( ) ! = _NUM ) result . append ( _STR ) ; result . append ( m _ Result ) ; return result . toString ( ) ; } 
5103	public Span addAll ( Iterable < ? extends SqlNode > nodes ) { for ( SqlNode node : nodes ) { add ( node ) ; } return this ; } 
5104	public static boolean isGroupSummary ( Notification notification ) { if ( Build . VERSION . SDK _ INT > = _NUM _NUM ) { return ( notification . flags & Notification . FLAG _ GROUP _ SUMMARY ) ! = _NUM ; } else if ( Build . VERSION . SDK _ INT > = _NUM _NUM ) { return notification . extras . getBoolean ( NotificationCompatExtras . EXTRA _ GROUP _ SUMMARY ) ; } else if ( Build . VERSION . SDK _ INT > = _NUM _NUM ) { return NotificationCompatJellybean . getExtras ( notification ) . getBoolean ( NotificationCompatExtras . EXTRA _ GROUP _ SUMMARY ) ; } else { return false ; } } 
5105	public static String convertNumberToString ( String input ) { if ( input . startsWith ( _STR + convertToString ( Long . parseLong ( rest ) ) ) ) . trim ( ) ; } 
5106	public void testScannableTableFunctionWithNamedParameters ( ) throws SQLException , ClassNotFoundException { Connection connection = DriverManager . getConnection ( _STR ) ) ; connection . close ( ) ; } 
5107	public Pair < Message , CellScanner > call ( RpcCall call , MonitoredRPCHandler status ) throws IOException { try { MethodDescriptor md = call . getMethod ( ) ; Message param = call . getParam ( ) ; status . setRPC ( md . getName ( ) , new Object [ ] { param } , call . getReceiveTime ( ) ) ; TODO : Review after we add in encoded data blocks . status . setRPCPacket ( param ) ; status . resume ( _STR , e ) ; throw new IOException ( e . getMessage ( ) , e ) ; } } 
5108	private long getBytesWritten ( ) { long bytesWritten = _NUM ; for ( Optional < Fork > fork : this . forks . keySet ( ) ) { bytesWritten + = fork . get ( ) . getBytesWritten ( ) ; } return bytesWritten ; } 
5109	public RexNode patternExclude ( RexNode node ) { final RelDataType t = getTypeFactory ( ) . createSqlType ( SqlTypeName . NULL ) ; return getRexBuilder ( ) . makeCall ( t , SqlStdOperatorTable . PATTERN _ EXCLUDE , ImmutableList . of ( node ) ) ; } 
5110	public void restartTest ( ) throws Exception { final int PORT _ _NUM = _NUM _NUM _NUM _NUM ; Process corfuServer = runSinglePersistentServer ( corfuSingleNodeHost , PORT _ _NUM ) ; CorfuRuntime corfuRuntime = createDefaultRuntime ( ) ; Layout l = incrementClusterEpoch ( corfuRuntime ) ; corfuRuntime . getLayoutView ( ) . getRuntimeLayout ( l ) . getBaseClient ( _STR ) . restart ( ) . get ( ) ; restartServer ( corfuRuntime , DEFAULT _ ENDPOINT ) ; assertThat ( corfuRuntime . getLayoutView ( ) . getLayout ( ) . getEpoch ( ) ) . isGreaterThanOrEqualTo ( l . getEpoch ( ) + _NUM ) ; assertThat ( shutdownCorfuServer ( corfuServer ) ) . isTrue ( ) ; } 
5111	public void setFillViewport ( boolean fillViewport ) { if ( fillViewport ! = mFillViewport ) { mFillViewport = fillViewport ; requestLayout ( ) ; } } 
5112	private CmsResourceTypeBean createTypeBean ( I _ CmsResourceType type , I _ CmsPreviewProvider preview , boolean creatable ) { CmsResourceTypeBean result = new CmsResourceTypeBean ( ) ; result . setType ( type . getTypeName ( ) ) ; result . setTypeId ( type . getTypeId ( ) ) ; Locale wpLocale = getWorkplaceLocale ( ) ; type title and subtitle result . setTitle ( CmsWorkplaceMessages . getResourceTypeName ( wpLocale , type . getTypeName ( ) ) ) ; result . setDescription ( CmsWorkplaceMessages . getResourceTypeDescription ( wpLocale , type . getTypeName ( ) ) ) ; gallery id of corresponding galleries ArrayList < String > galleryNames = new ArrayList < String > ( ) ; Iterator < I _ CmsResourceType > galleryTypes = type . getGalleryTypes ( ) . iterator ( ) ; while ( galleryTypes . hasNext ( ) ) { I _ CmsResourceType galleryType = galleryTypes . next ( ) ; galleryNames . add ( galleryType . getTypeName ( ) ) ; } result . setGalleryTypeNames ( galleryNames ) ; if ( preview ! = null ) { result . setPreviewProviderName ( preview . getPreviewName ( ) ) ; } result . setCreatableType ( creatable ) ; return result ; } 
5113	private void verifyPKCS _NUM ( byte [ ] byteArray , COSString contents , PDSignature sig ) throws CMSException , CertificateException , StoreException , OperatorCreationException , NoSuchAlgorithmException , NoSuchProviderException { inspiration : http : http : CMSProcessable signedContent = new CMSProcessableByteArray ( byteArray ) ; CMSSignedData signedData = new CMSSignedData ( signedContent , contents . getBytes ( ) ) ; Store < X _NUM _NUM _NUM CertificateHolder > certificatesStore = signedData . getCertificates ( ) ; Collection < SignerInformation > signers = signedData . getSignerInfos ( ) . getSigners ( ) ; SignerInformation signerInformation = signers . iterator ( ) . next ( ) ; Collection < X _NUM _NUM _NUM CertificateHolder > matches = certificatesStore . getMatches ( signerInformation . getSID ( ) ) ; X _NUM _NUM _NUM CertificateHolder certificateHolder = matches . iterator ( ) . next ( ) ; X _NUM _NUM _NUM Certificate certFromSignedData = new JcaX _NUM _NUM _NUM CertificateConverter ( ) . getCertificate ( certificateHolder ) ; System . out . println ( _STR ) ; } } 
5114	public String getPath ( ) { return URIHelper . decodeString ( path , true ) ; } 
5115	public static JSONArray toJSONArray ( JSONArray names , JSONTokener x ) throws JSONException { if ( names = = null | | names . length ( ) = = _NUM ) { return null ; } JSONArray ja = new JSONArray ( ) ; for ( ; ; ) { JSONObject jo = rowToJSONObject ( names , x ) ; if ( jo = = null ) { break ; } ja . put ( jo ) ; } if ( ja . length ( ) = = _NUM ) { return null ; } return ja ; } 
5116	public static void setThreadStatsTagApp ( ) { setThreadStatsTag ( TAG _ SYSTEM _ APP ) ; } 
5117	public E load ( Path path , String className , int priority , Configuration conf , String [ ] includedClassPrefixes ) throws IOException { Class < ? > implClass ; LOG . debug ( _STR + className , e ) ; } } load custom code for coprocessor Thread currentThread = Thread . currentThread ( ) ; ClassLoader hostClassLoader = currentThread . getContextClassLoader ( ) ; try { switch temporarily to the thread classloader for custom CP currentThread . setContextClassLoader ( cl ) ; E cpInstance = checkAndLoadInstance ( implClass , priority , conf ) ; return cpInstance ; } finally { restore the fresh ( host ) classloader currentThread . setContextClassLoader ( hostClassLoader ) ; } } 
5118	public static String readTextFile ( File file , int max , String ellipsis ) throws IOException { InputStream input = new FileInputStream ( file ) ; wrapping a BufferedInputStream around it because when reading / proc with unbuffered input stream , bytes read not equal to buffer size is not necessarily the correct indication for EOF ; but it is true for BufferedInputStream due to its implementation . BufferedInputStream bis = new BufferedInputStream ( input ) ; try { long size = file . length ( ) ; if ( max > _NUM | | ( size > _NUM & & max = = _NUM ) ) { _STR mode : size unknown , read it all in streaming fashion ByteArrayOutputStream contents = new ByteArrayOutputStream ( ) ; int len ; byte [ ] data = new byte [ _NUM _NUM _NUM _NUM ] ; do { len = bis . read ( data ) ; if ( len > _NUM ) contents . write ( data , _NUM , len ) ; } while ( len = = data . length ) ; return contents . toString ( ) ; } } finally { bis . close ( ) ; input . close ( ) ; } } 
5119	public Enumerable < V > valuesEnumerable ( ) { return new AbstractEnumerable < V > ( ) { public Enumerator < V > enumerator ( ) { final Enumerator < Enumerable < V > > listEnumerator = Linq _NUM j . iterableEnumerator ( values ( ) ) ; return new Enumerator < V > ( ) { Enumerator < V > enumerator = Linq _NUM j . emptyEnumerator ( ) ; public V current ( ) { return enumerator . current ( ) ; } public boolean moveNext ( ) { for ( ; ; ) { if ( enumerator . moveNext ( ) ) { return true ; } enumerator . close ( ) ; if ( ! listEnumerator . moveNext ( ) ) { enumerator = Linq _NUM j . emptyEnumerator ( ) ; return false ; } enumerator = listEnumerator . current ( ) . enumerator ( ) ; } } public void reset ( ) { listEnumerator . reset ( ) ; enumerator = Linq _NUM j . emptyEnumerator ( ) ; } public void close ( ) { enumerator . close ( ) ; } } ; } } ; } 
5120	private Token readToken ( ) throws IOException { if ( ! input . incrementToken ( ) ) { return null ; } else { Token token = new Token ( ) ; token . copyBuffer ( termAtt . buffer ( ) , _NUM , termAtt . length ( ) ) ; token . setOffset ( offsetAtt . startOffset ( ) , offsetAtt . endOffset ( ) ) ; token . setType ( typeAtt . type ( ) ) ; token . setFlags ( flagsAtt . getFlags ( ) ) ; token . setPositionIncrement ( posIncAtt . getPositionIncrement ( ) ) ; token . setPayload ( payloadAtt . getPayload ( ) ) ; return token ; } } 
5121	public static void addPackageConvenienceMethodsToMLContext ( String dirPath , CtClass ctMLContext ) { try { if ( ! SOURCE . equalsIgnoreCase ( dirPath ) ) { return ; } File dir = new File ( dirPath ) ; File [ ] subdirs = dir . listFiles ( new FileFilter ( ) { @ Override public boolean accept ( File f ) { return f . isDirectory ( ) ; } } ) ; for ( File subdir : subdirs ) { String subDirPath = dirPath + File . separator + subdir . getName ( ) ; if ( skipDir ( subdir , false ) ) { continue ; } String fullSubDirClassName = dirPathToFullDirClassName ( subDirPath ) ; ClassPool pool = ClassPool . getDefault ( ) ; CtClass subDirClass = pool . get ( fullSubDirClassName ) ; String subDirName = subdir . getName ( ) ; subDirName = subDirName . replaceAll ( _STR ; CtMethod ctMethod = CtNewMethod . make ( Modifier . PUBLIC , subDirClass , subDirName , null , null , methodBody , ctMLContext ) ; ctMLContext . addMethod ( ctMethod ) ; } } catch ( NotFoundException e ) { e . printStackTrace ( ) ; } catch ( CannotCompileException e ) { e . printStackTrace ( ) ; } } 
5122	public XSLFSheet appendContent ( XSLFSheet src ) { int numShapes = getShapes ( ) . size ( ) ; CTGroupShape spTree = getSpTree ( ) ; CTGroupShape srcTree = src . getSpTree ( ) ; for ( XmlObject ch : srcTree . selectPath ( _STR ) ) { if ( ch instanceof CTShape ) { simple shape spTree . addNewSp ( ) . set ( ch . copy ( ) ) ; } else if ( ch instanceof CTGroupShape ) { spTree . addNewGrpSp ( ) . set ( ch . copy ( ) ) ; } else if ( ch instanceof CTConnector ) { spTree . addNewCxnSp ( ) . set ( ch . copy ( ) ) ; } else if ( ch instanceof CTPicture ) { spTree . addNewPic ( ) . set ( ch . copy ( ) ) ; } else if ( ch instanceof CTGraphicalObjectFrame ) { spTree . addNewGraphicFrame ( ) . set ( ch . copy ( ) ) ; } } wipeAndReinitialize ( src , numShapes ) ; return this ; } 
5123	ColorDetails addSimple ( PdfSpotColor spc ) { ColorDetails ret = ( ColorDetails ) documentColors . get ( spc ) ; if ( ret = = null ) { ret = new ColorDetails ( getColorspaceName ( ) , body . getPdfIndirectReference ( ) , spc ) ; documentColors . put ( spc , ret ) ; } return ret ; } 
5124	public void getDecoratedBoundsWithMargins ( View view , Rect outBounds ) { getDecoratedBoundsWithMarginsInt ( view , outBounds ) ; } 
5125	public Class getParameterDefinition ( final String name ) { if ( name . equals ( _STR ) ) { return Integer . TYPE ; } final int par = parseParameterName ( name ) ; if ( par < _NUM ) { return null ; } return getObjectClass ( ) . getComponentType ( ) ; } 
5126	protected String printOptions ( String [ ] options ) { if ( options = = null ) { return ( _STR ) ; } else { return Utils . joinOptions ( options ) ; } } 
5127	public static JSONObject getPayload ( String jwt ) { try { validateJWT ( jwt ) ; final String payload = jwt . split ( _STR ) ; } } 
5128	private void addSlab ( int minimumSize ) { int nextSlabSize ; if ( bytesUsed = = _NUM ) { nextSlabSize = initialSlabSize ; } else if ( bytesUsed > maxCapacityHint / _NUM ) { to avoid an overhead of up to twice the needed size , we get linear when approaching target page size nextSlabSize = maxCapacityHint / _NUM ; } else { double the size every time nextSlabSize = bytesUsed ; } if ( nextSlabSize < minimumSize ) { LOG . debug ( _STR , slabs . size ( ) , nextSlabSize ) ; this . currentSlab = allocator . allocate ( nextSlabSize ) ; this . slabs . add ( currentSlab ) ; this . bytesAllocated + = nextSlabSize ; this . currentSlabIndex = _NUM ; } 
5129	public RandomAccessData increment ( ) throws IOException { RandomAccessData copy = copy ( ) ; for ( int i = copy . size - _NUM ; i > = _NUM ; - - i ) { if ( copy . buffer [ i ] ! = UnsignedBytes . MAX _ VALUE ) { copy . buffer [ i ] = UnsignedBytes . checkedCast ( UnsignedBytes . toInt ( copy . buffer [ i ] ) + _NUM ) ; return copy ; } } return POSITIVE _ INFINITY ; } 
5130	public void goForward ( ) { checkThread ( ) ; mProvider . goForward ( ) ; } 
5131	public static boolean validate ( DVCSRequestInfo requestInfo , DVCSRequestInfo responseInfo ) { RFC _NUM _NUM _NUM _NUM , _NUM . _NUM The DVCS MAY modify the fields : ' dvcs ' , ' requester ' , ' dataLocations ' , and ' nonce ' of the ReqInfo structure . DVCSRequestInformation clientInfo = requestInfo . data ; DVCSRequestInformation serverInfo = responseInfo . data ; if ( clientInfo . getVersion ( ) ! = serverInfo . getVersion ( ) ) { return false ; } if ( ! clientEqualsServer ( clientInfo . getService ( ) , serverInfo . getService ( ) ) ) { return false ; } if ( ! clientEqualsServer ( clientInfo . getRequestTime ( ) , serverInfo . getRequestTime ( ) ) ) { return false ; } if ( ! clientEqualsServer ( clientInfo . getRequestPolicy ( ) , serverInfo . getRequestPolicy ( ) ) ) { return false ; } if ( ! clientEqualsServer ( clientInfo . getExtensions ( ) , serverInfo . getExtensions ( ) ) ) { return false ; } if ( clientInfo . getNonce ( ) ! = null ) { if ( serverInfo . getNonce ( ) = = null ) { return false ; } byte [ ] clientNonce = clientInfo . getNonce ( ) . toByteArray ( ) ; byte [ ] serverNonce = serverInfo . getNonce ( ) . toByteArray ( ) ; if ( serverNonce . length < clientNonce . length ) { return false ; } if ( ! Arrays . areEqual ( clientNonce , Arrays . copyOfRange ( serverNonce , _NUM , clientNonce . length ) ) ) { return false ; } } return true ; } 
5132	public void getInodeByNonexistingPath ( ) throws Exception { mThrown . expect ( FileDoesNotExistException . class ) ; mThrown . expectMessage ( _STR ) ; assertFalse ( mTree . inodePathExists ( TEST _ URI ) ) ; getInodeByPath ( mTree , TEST _ URI ) ; } 
5133	public < T extends RDFNode > T as ( Class < T > t ) { return asInternal ( t ) ; } 
5134	public void setAvailableExtraData ( List < String > extraDataKeys ) { enforceNotSealed ( ) ; mExtraDataKeys = new ArrayList < > ( extraDataKeys ) ; } 
5135	public double getXValue ( int series , int item ) { OHLCSeries s = ( OHLCSeries ) this . data . get ( series ) ; OHLCItem di = ( OHLCItem ) s . getDataItem ( item ) ; RegularTimePeriod period = di . getPeriod ( ) ; return getX ( period ) ; } 
5136	public void open ( ) { Display display = null ; display = Display . getDefault ( ) ; createContents ( ) ; shell . open ( ) ; shell . layout ( ) ; while ( ! shell . isDisposed ( ) ) { try { if ( ! display . readAndDispatch ( ) ) { display . sleep ( ) ; } } catch ( Exception e ) { MessageDialog . openError ( shell , i _NUM _NUM nFile . getText ( I _NUM _NUM nFile . ERROR ) , e . getLocalizedMessage ( ) ) ; e . printStackTrace ( ) ; } } display . dispose ( ) ; } 
5137	public FSDataInputStream open ( Path path , int bufferSize ) throws IOException { LOG . debug ( _STR , path , bufferSize ) ; if ( mStatistics ! = null ) { mStatistics . incrementReadOps ( _NUM ) ; } AlluxioURI uri = new AlluxioURI ( HadoopUtils . getPathWithoutScheme ( path ) ) ; return new FSDataInputStream ( new HdfsFileInputStream ( mContext , uri , mStatistics ) ) ; } 
5138	public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; if ( mUri . getScheme ( ) ! = null ) { sb . append ( mUri . getScheme ( ) ) ; sb . append ( _STR ) ; sb . append ( mUri . getQuery ( ) ) ; } return sb . toString ( ) ; } 
5139	void close ( ) throws IOException { lockExclusive ( ) ; try { open = false ; try { if ( checkpointOnClose ) { do this before acquiring exclusive lock writeCheckpoint ( true ) ; } } catch ( Exception err ) { LOGGER . warn ( _STR + logDir , ex ) ; } } } finally { unlockExclusive ( ) ; } } 
5140	public void changeLock ( CmsDbContext dbc , CmsResource resource , CmsLockType lockType ) throws CmsException , CmsSecurityException { get the current lock CmsLock currentLock = getLock ( dbc , resource ) ; check if the resource is locked at all if ( currentLock . getEditionLock ( ) . isUnlocked ( ) & & currentLock . getSystemLock ( ) . isUnlocked ( ) ) { throw new CmsLockException ( Messages . get ( ) . container ( Messages . ERR _ CHANGE _ LOCK _ UNLOCKED _ RESOURCE _ _NUM , dbc . getRequestContext ( ) . getSitePath ( resource ) ) ) ; } else if ( ( lockType = = CmsLockType . EXCLUSIVE ) & & currentLock . isExclusiveOwnedInProjectBy ( dbc . currentUser ( ) , dbc . currentProject ( ) ) ) { the current lock requires no change return ; } duplicate logic from CmsSecurityManager # hasPermissions ( ) because lock state can ' t be ignored if another user has locked the file , the current user can never get WRITE permissions with the default check int denied = _NUM ; check if the current user is vfs manager boolean canIgnorePermissions = m _ securityManager . hasRoleForResource ( dbc , dbc . currentUser ( ) , CmsRole . VFS _ MANAGER , resource ) ; write is only allowed for developers if ( ! canIgnorePermissions & & ( CmsResourceTypeJsp . isJsp ( resource ) ) ) { if ( ! m _ securityManager . hasRoleForResource ( dbc , dbc . currentUser ( ) , CmsRole . DEVELOPER , resource ) ) { denied | = CmsPermissionSet . PERMISSION _ WRITE ; } } CmsPermissionSetCustom permissions ; if ( canIgnorePermissions ) { if the current user is administrator , anything is allowed permissions = new CmsPermissionSetCustom ( ~ _NUM ) ; } else { otherwise , get the permissions from the access control list permissions = getPermissions ( dbc , resource , dbc . currentUser ( ) ) ; } revoke the denied permissions permissions . denyPermissions ( denied ) ; now check if write permission is granted if ( ( CmsPermissionSet . ACCESS _ WRITE . getPermissions ( ) & permissions . getPermissions ( ) ) ! = CmsPermissionSet . ACCESS _ WRITE . getPermissions ( ) ) { check failed , throw exception m _ securityManager . checkPermissions ( dbc . getRequestContext ( ) , resource , CmsPermissionSet . ACCESS _ WRITE , I _ CmsPermissionHandler . PERM _ DENIED ) ; } if we got here write permission is granted on the target remove the old lock m _ lockManager . removeResource ( dbc , resource , true , lockType . isSystem ( ) ) ; apply the new lock lockResource ( dbc , resource , lockType ) ; } 
5141	public void update ( int p , int m ) { p = roundKey ( p , roundSeconds ) ; if ( spool . capacity > _NUM ) { if ( ! spool . tryAddOrAccumulate ( p , m ) ) { flushHistogram ( ) ; final boolean success = spool . tryAddOrAccumulate ( p , m ) ; after spool flushing we should always be able to insert new value assert success : _STR ; } } else { flushValue ( p , m ) ; } } 
5142	protected void readFileId ( ) throws IOException { byte [ ] b = new byte [ HEADER . length ] ; in . readFully ( b ) ; if ( ! Arrays . equals ( b , HEADER ) ) { throw new IOException ( _STR + new String ( b , Charsets . ISO _ _NUM _NUM _NUM _NUM _ _NUM ) ) ; } } 
5143	 @ GuardedBy ( _STR ) ; } return result ; } catch ( IOException ex ) { zygoteState . close ( ) ; throw new ZygoteStartFailedEx ( ex ) ; } } 
5144	private List < Slice > normalize ( List < Slice > slices ) { if ( slices . size ( ) < = _NUM ) return slices ; Collections . sort ( slices , new Comparator < Slice > ( ) { @ Override public int compare ( Slice s _NUM , Slice s _NUM ) { int c = comparator . compare ( s _NUM . start ( ) , s _NUM . start ( ) ) ; if ( c ! = _NUM ) return c ; return comparator . compare ( s _NUM . end ( ) , s _NUM . end ( ) ) ; } } ) ; List < Slice > slicesCopy = new ArrayList < > ( slices . size ( ) ) ; Slice last = slices . get ( _NUM ) ; for ( int i = _NUM ; i < slices . size ( ) ; i + + ) { Slice s _NUM = slices . get ( i ) ; boolean includesStart = last . includes ( comparator , s _NUM . start ( ) ) ; boolean includesFinish = last . includes ( comparator , s _NUM . end ( ) ) ; if ( includesStart & & includesFinish ) continue ; if ( ! includesStart & & ! includesFinish ) { slicesCopy . add ( last ) ; last = s _NUM ; continue ; } if ( includesStart ) { last = Slice . make ( last . start ( ) , s _NUM . end ( ) ) ; continue ; } assert ! includesFinish ; } slicesCopy . add ( last ) ; return slicesCopy ; } 
5145	private void considerAtomic ( final BasicUpdate candidate , final boolean slack ) { fill the one - atomic - update buffer if ( recent = = null ) { recent = candidate ; if ( recent instanceof StructuralUpdate ) recentStruct = candidate ; return ; } if ( candidate instanceof StructuralUpdate & & recentStruct ! = null ) { ( ( StructuralUpdate ) candidate ) . accumulatedShifts + = recentStruct . accumulatedShifts ( ) ; } prepare & optimize incoming update if ( slack ) { add ( candidate , false ) ; } else { check ( recent , candidate ) ; if ( treeAwareUpdates ( recent , candidate ) ) return ; final BasicUpdate m = recent . merge ( data , candidate ) ; if ( m ! = null ) add ( m , true ) ; else add ( candidate , false ) ; } } 
5146	public void lockWriteAndCheckNameAndParentInvalid ( ) throws Exception { mExpectedException . expect ( InvalidPathException . class ) ; mExpectedException . expectMessage ( ExceptionMessage . PATH _ INVALID _ CONCURRENT _ RENAME . getMessage ( ) ) ; String name = _STR ) ; } 
5147	protected void writeFooter ( ) { if ( layout = = null | | skipFooter ) { return ; } final byte [ ] footer = layout . getFooter ( ) ; if ( footer ! = null ) { write ( footer ) ; } } 
5148	public static void write ( File file , List < String > lines , StandardOpenOption . . . options ) { Set < StandardOpenOption > optionsSet = new HashSet < > ( Arrays . asList ( options ) ) ; Emulate the old FileSystemProvider . newOutputStream behavior for open options . if ( optionsSet . isEmpty ( ) ) { optionsSet . add ( StandardOpenOption . CREATE ) ; optionsSet . add ( StandardOpenOption . TRUNCATE _ EXISTING ) ; } boolean sync = optionsSet . remove ( StandardOpenOption . SYNC ) ; boolean dsync = optionsSet . remove ( StandardOpenOption . DSYNC ) ; optionsSet . add ( StandardOpenOption . WRITE ) ; Path filePath = file . toPath ( ) ; try ( FileChannel fc = filePath . getFileSystem ( ) . provider ( ) . newFileChannel ( filePath , optionsSet ) ; BufferedWriter writer = new BufferedWriter ( new OutputStreamWriter ( Channels . newOutputStream ( fc ) , CHARSET . newEncoder ( ) ) ) ) { for ( CharSequence line : lines ) { writer . append ( line ) ; writer . newLine ( ) ; } if ( sync ) { SyncUtil . force ( fc , true ) ; } else if ( dsync ) { SyncUtil . force ( fc , false ) ; } } catch ( IOException ex ) { throw new RuntimeException ( ex ) ; } } 
5149	public void autoSizeColumn ( int column , boolean useMergedCells ) { double width = SheetUtil . getColumnWidth ( this , column , useMergedCells ) ; if ( width ! = - _NUM ) { width * = _NUM _NUM _NUM ; The maximum column width for an individual cell is _NUM _NUM _NUM characters int maxColumnWidth = _NUM _NUM _NUM * _NUM _NUM _NUM ; if ( width > maxColumnWidth ) { width = maxColumnWidth ; } setColumnWidth ( column , ( int ) ( width ) ) ; } } 
5150	public static String fixForNamespace ( String namespace , String path , boolean isSequential ) { Child path must be valid in and of itself . PathUtils . validatePath ( path , isSequential ) ; if ( namespace ! = null ) { return makePath ( namespace , path ) ; } return path ; } 
5151	public static String dump ( byte [ ] arr , int offset , int length , int outOffset , int bpl , int addressLength ) { int end = offset + length ; twos - complement math trick : ( ( x < _NUM ) | | ( y < _NUM ) ) < = > ( ( x | y ) < _NUM ) if ( ( ( offset | length | end ) < _NUM ) | | ( end > arr . length ) ) { throw new IndexOutOfBoundsException ( _STR ) ; } else if ( ( col & _NUM ) = = _NUM ) { sb . append ( ' ' ) ; } sb . append ( Hex . u _NUM ( arr [ offset ] ) ) ; outOffset + + ; offset + + ; col + + ; if ( col = = bpl ) { sb . append ( ' \ n ' ) ; col = _NUM ; } length - - ; } if ( col ! = _NUM ) { sb . append ( ' \ n ' ) ; } return sb . toString ( ) ; } 
5152	default Array transform ( BiFunction < Integer , Value , Value > transformer ) { for ( int i = _NUM ; i ! = size ( ) ; + + i ) { Value existing = get ( i ) ; Value updated = transformer . apply ( Integer . valueOf ( i ) , existing ) ; if ( updated = = null ) updated = Value . nullValue ( ) ; if ( updated ! = existing ) { setValue ( i , updated ) ; } } return this ; } 
5153	public boolean containsValue ( Object value ) { return indexOfValue ( value ) > = _NUM ; } 
5154	public static Record [ ] createRecord ( RecordInputStream in ) { Record record = createSingleRecord ( in ) ; if ( record instanceof DBCellRecord ) { Not needed by POI . Regenerated from scratch by POI when spreadsheet is written return new Record [ ] { null } ; } if ( record instanceof RKRecord ) { return new Record [ ] { convertToNumberRecord ( ( RKRecord ) record ) } ; } if ( record instanceof MulRKRecord ) { return convertRKRecords ( ( MulRKRecord ) record ) ; } return new Record [ ] { record } ; } 
5155	public static BufferedImage createThumbnail ( File f , int width , int height ) throws IOException { validateDimensions ( width , height ) ; if ( f = = null ) { throw new NullPointerException ( _STR ) ; } return Thumbnails . of ( f ) . size ( width , height ) . asBufferedImage ( ) ; } 
5156	public void add ( @ Nullable T object ) { synchronized ( mLock ) { if ( mOriginalValues ! = null ) { mOriginalValues . add ( object ) ; } else { mObjects . add ( object ) ; } mObjectsFromResources = false ; } if ( mNotifyOnChange ) notifyDataSetChanged ( ) ; } 
5157	private void inplaceRound ( TMathContext mc ) { int mcPrecision = mc . getPrecision ( ) ; if ( aproxPrecision ( ) - mcPrecision < = _NUM | | mcPrecision = = _NUM ) { return ; } int discardedPrecision = precision ( ) - mcPrecision ; If no rounding is necessary it returns immediately if ( ( discardedPrecision < = _NUM ) ) { return ; } When the number is small perform an efficient rounding if ( this . bitLength < _NUM _NUM ) { smallRound ( mc , discardedPrecision ) ; return ; } Getting the integer part and the discarded fraction TBigInteger sizeOfFraction = TMultiplication . powerOf _NUM _NUM ( discardedPrecision ) ; TBigInteger [ ] integerAndFraction = getUnscaledValue ( ) . divideAndRemainder ( sizeOfFraction ) ; long newScale = ( long ) scale - discardedPrecision ; int compRem ; TBigDecimal tempBD ; If the discarded fraction is non - zero , perform rounding if ( integerAndFraction [ _NUM ] . signum ( ) ! = _NUM ) { To check if the discarded fraction > = _NUM . _NUM compRem = ( integerAndFraction [ _NUM ] . abs ( ) . shiftLeftOneBit ( ) . compareTo ( sizeOfFraction ) ) ; To look if there is a carry compRem = roundingBehavior ( integerAndFraction [ _NUM ] . testBit ( _NUM ) ? _NUM : _NUM , integerAndFraction [ _NUM ] . signum ( ) * ( _NUM + compRem ) , mc . getRoundingMode ( ) ) ; if ( compRem ! = _NUM ) { integerAndFraction [ _NUM ] = integerAndFraction [ _NUM ] . add ( TBigInteger . valueOf ( compRem ) ) ; } tempBD = new TBigDecimal ( integerAndFraction [ _NUM ] ) ; If after to add the increment the precision changed , we normalize the size if ( tempBD . precision ( ) > mcPrecision ) { integerAndFraction [ _NUM ] = integerAndFraction [ _NUM ] . divide ( TBigInteger . TEN ) ; newScale - - ; } } To update all internal fields scale = toIntScale ( newScale ) ; precision = mcPrecision ; setUnscaledValue ( integerAndFraction [ _NUM ] ) ; } 
5158	public static void checkState ( boolean expression , @ Nullable String errorMessageTemplate , @ Nullable Object . . . errorMessageArgs ) { if ( ! expression ) { throw new IllegalStateException ( format ( errorMessageTemplate , errorMessageArgs ) ) ; } } 
5159	protected int insertKey ( long val ) { int hash , index ; hash = HashFunctions . hash ( val ) & _NUM x _NUM fffffff ; index = hash % _ states . length ; byte state = _ states [ index ] ; consumeFreeSlot = false ; if ( state = = FREE ) { consumeFreeSlot = true ; insertKeyAt ( index , val ) ; empty , all done return index ; } if ( state = = FULL & & _ set [ index ] = = val ) { already stored return - index - _NUM ; } already FULL or REMOVED , must probe return insertKeyRehash ( val , index , hash , state ) ; } 
5160	public LayeredLayout setReferencePositionRight ( Component cmp , float position ) { getOrCreateConstraint ( cmp ) . right ( ) . referencePosition ( position ) ; return this ; } 
5161	public void testFSBlocks ( String rootName ) throws Exception { createInputFile ( rootName ) ; runDistributedFSCheck ( ) ; clean up after all to restore the system state cleanup ( ) ; } 
5162	public static Expression bean ( String expression ) { BeanLanguage language = new BeanLanguage ( ) ; return language . createExpression ( expression ) ; } 
5163	boolean animationFrame ( long currentTime ) { boolean done = false ; if ( mPlayingState = = STOPPED ) { mPlayingState = RUNNING ; if ( mSeekTime < _NUM ) { mStartTime = currentTime ; } else { mStartTime = currentTime - mSeekTime ; Now that we ' re playing , reset the seek time mSeekTime = - _NUM ; } } switch ( mPlayingState ) { case RUNNING : case SEEKED : float fraction = mDuration > _NUM ? ( float ) ( currentTime - mStartTime ) / mDuration : _NUM f ; if ( fraction > = _NUM f ) { if ( mCurrentIteration < mRepeatCount | | mRepeatCount = = INFINITE ) { Time to repeat if ( mListeners ! = null ) { int numListeners = mListeners . size ( ) ; for ( int i = _NUM ; i < numListeners ; + + i ) { mListeners . get ( i ) . onAnimationRepeat ( this ) ; } } if ( mRepeatMode = = REVERSE ) { mPlayingBackwards = mPlayingBackwards ? false : true ; } mCurrentIteration + = ( int ) fraction ; fraction = fraction % _NUM f ; mStartTime + = mDuration ; } else { done = true ; fraction = Math . min ( fraction , _NUM . _NUM f ) ; } } if ( mPlayingBackwards ) { fraction = _NUM f - fraction ; } animateValue ( fraction ) ; break ; } return done ; } 
5164	public String formatNumberDateCell ( CellValueRecordInterface cell ) { double value ; if ( cell instanceof NumberRecord ) { value = ( ( NumberRecord ) cell ) . getValue ( ) ; } else if ( cell instanceof FormulaRecord ) { value = ( ( FormulaRecord ) cell ) . getValue ( ) ; } else { throw new IllegalArgumentException ( _STR + cell ) ; } Get the built in format , if there is one int formatIndex = getFormatIndex ( cell ) ; String formatString = getFormatString ( cell ) ; if ( formatString = = null ) { return _ defaultFormat . format ( value ) ; } HSSFDataFormatter to do the work for us return _ formatter . formatRawCellContents ( value , formatIndex , formatString ) ; } 
5165	public void notifyChange ( Uri uri , IContentObserver observer , boolean observerWantsSelfNotifications , int flags , int userHandle , int targetSdkVersion ) { if ( DEBUG ) Slog . d ( TAG , _STR ) ; IBinder binder = oc . mObserver . asBinder ( ) ; final ArrayList < ObserverNode . ObserverEntry > list = oc . mNode . mObservers ; int numList = list . size ( ) ; for ( int j = _NUM ; j < numList ; j + + ) { ObserverNode . ObserverEntry oe = list . get ( j ) ; if ( oe . observer . asBinder ( ) = = binder ) { list . remove ( j ) ; j - - ; numList - - ; } } } } } if ( ( flags & ContentResolver . NOTIFY _ SYNC _ TO _ NETWORK ) ! = _NUM ) { SyncManager syncManager = getSyncManager ( ) ; if ( syncManager ! = null ) { syncManager . scheduleLocalSync ( null , callingUserHandle , uid , uri . getAuthority ( ) ) ; } } synchronized ( mCache ) { final String providerPackageName = getProviderPackageName ( uri ) ; invalidateCacheLocked ( userHandle , providerPackageName , uri ) ; } } finally { restoreCallingIdentity ( identityToken ) ; } } 
5166	public final E _ LessThanOrEqual le ( Object expr _NUM , Object expr _NUM ) { return new E _ LessThanOrEqual ( asExpr ( expr _NUM ) , asExpr ( expr _NUM ) ) ; } 
5167	public String getString ( ) { int [ ] codePoints = getStringCodePoints ( ) ; return new String ( codePoints , _NUM , codePoints . length ) ; } 
5168	private static void s _ uaColSumLtGe ( MatrixBlock in , MatrixBlock out , double [ ] bv , BinaryOperator bOp ) { int agg _NUM = sumRowSumGtLeColSumLtGe ( _NUM . _NUM , bv , bOp ) ; allocate and initialize output values ( not indices ) out . allocateDenseBlock ( true ) ; if ( agg _NUM ! = _NUM . _NUM ) { out . getDenseBlock ( ) . set ( _NUM , _NUM , _NUM , out . clen , agg _NUM ) ; out . setNonZeros ( out . clen ) ; } if ( in . isEmptyBlock ( false ) ) return ; SparseBlock sblock = in . getSparseBlock ( ) ; for ( int j = _NUM ; j < sblock . numRows ( ) ; j + + ) if ( ! sblock . isEmpty ( j ) ) { int apos = sblock . pos ( j ) ; int alen = sblock . size ( j ) ; int [ ] aix = sblock . indexes ( j ) ; double [ ] avals = sblock . values ( j ) ; for ( int i = apos ; i < apos + alen ; i + + ) { int cnt = sumRowSumGtLeColSumLtGe ( avals [ i ] , bv , bOp ) ; out . quickSetValue ( _NUM , aix [ i ] , cnt ) ; } } } 
5169	public int untether ( String iface , String callerPkg ) { ConnectivityManager . enforceTetherChangePermission ( mContext , callerPkg ) ; if ( isTetheringSupported ( ) ) { final int status = mTethering . untether ( iface ) ; return status ; } else { return ConnectivityManager . TETHER _ ERROR _ UNSUPPORTED ; } } 
5170	public static DataFile makeDataFile ( URL definitionUrl , String dataFileName ) throws DataFileException { ModelDataFileReader reader = ModelDataFileReader . getModelDataFileReader ( definitionUrl ) ; if ( reader = = null ) { throw new DataFileException ( _STR ) ; } DataFile dataFile = new DataFile ( modelDataFile ) ; return dataFile ; } 
5171	protected void writeTag ( final Writer writer , final String tagName , final String attribute , final String value , final Comments comments ) throws IOException { if ( comments = = null ) { this . writerSupport . writeTag ( writer , tagName , attribute , value , XMLWriterSupport . CLOSE ) ; } else { writeOpenComment ( writer , comments ) ; if ( comments . getCloseTagComment ( ) ! = null ) { this . writerSupport . writeTag ( writer , tagName , attribute , value , XMLWriterSupport . OPEN ) ; writeCloseComment ( writer , comments ) ; this . writerSupport . writeCloseTag ( writer , tagName ) ; } else { this . writerSupport . writeTag ( writer , tagName , attribute , value , XMLWriterSupport . CLOSE ) ; } } } 
5172	private AuthenticatedUser getAuthenticatedUser ( GuacamoleSession existingSession , Credentials credentials ) throws GuacamoleException { try { Re - authenticate user if session exists if ( existingSession ! = null ) { AuthenticatedUser updatedUser = updateAuthenticatedUser ( existingSession . getAuthenticatedUser ( ) , credentials ) ; fireAuthenticationSuccessEvent ( updatedUser ) ; return updatedUser ; } Otherwise , attempt authentication as a new user AuthenticatedUser authenticatedUser = AuthenticationService . this . authenticateUser ( credentials ) ; fireAuthenticationSuccessEvent ( authenticatedUser ) ; if ( logger . isInfoEnabled ( ) ) logger . info ( _STR , getLoggableAddress ( request ) ) ; Rethrow exception throw e ; } } 
5173	public LayeredLayout setReferenceComponentBottom ( Component cmp , Component referenceComponent , float position ) { getOrCreateConstraint ( cmp ) . bottom ( ) . referenceComponent ( referenceComponent ) . referencePosition ( position ) ; return this ; } 
5174	public Integer setPrincipalPassword ( String principal , String password , boolean service ) throws KerberosOperationException { if ( ! isOpen ( ) ) { throw new KerberosOperationException ( _STR , e ) ; } return _NUM ; } 
5175	private String getPropertyValueToWrite ( Object obj ) { String value ; String valueToWrite = null ; if ( obj instanceof List < ? > ) { String [ ] values = { } ; values = CmsCollectionsGenericWrapper . list ( obj ) . toArray ( values ) ; write it valueToWrite = _STR ) ; write it valueToWrite = value ; } return valueToWrite ; } 
5176	private void removeBorders ( CellRangeAddress range ) { Set < String > properties = new HashSet < > ( ) ; properties . add ( CellUtil . BORDER _ TOP ) ; properties . add ( CellUtil . BORDER _ BOTTOM ) ; properties . add ( CellUtil . BORDER _ LEFT ) ; properties . add ( CellUtil . BORDER _ RIGHT ) ; for ( int row = range . getFirstRow ( ) ; row < = range . getLastRow ( ) ; row + + ) { for ( int col = range . getFirstColumn ( ) ; col < = range . getLastColumn ( ) ; col + + ) { removeProperties ( row , col , properties ) ; } } removeBorderColors ( range ) ; } 
5177	private List < String > processLdif ( Reader reader ) throws CamelException { LdapConnection conn = getLdapConnection ( ) ; LdifReader ldifReader ; List < String > results = new ArrayList < String > ( ) ; Create the reader try { ldifReader = new LdifReader ( reader ) ; } catch ( LdapException e ) { throw new CamelException ( _STR , e ) ; } Process each entry for ( LdifEntry e : ldifReader ) { results . add ( processLdifEntry ( conn , e ) ) ; } IOHelper . close ( conn , ldifReader , reader ) ; return results ; } 
5178	public long getTime ( ) throws RemoteException { throwOnDeadServer ( ) ; return mUtils . transactGetLong ( METHOD _ GET _ COMMON _ TIME , TIME _ NOT _ SYNCED ) ; } 
5179	public void testNonExistentObjectReturnsEmptyResult ( ) throws IOException { GcsOptions pipelineOptions = gcsOptionsWithTestCredential ( ) ; GcsUtil gcsUtil = pipelineOptions . getGcsUtil ( ) ; Storage mockStorage = Mockito . mock ( Storage . class ) ; gcsUtil . setStorageClient ( mockStorage ) ; Storage . Objects mockStorageObjects = Mockito . mock ( Storage . Objects . class ) ; Storage . Objects . Get mockStorageGet = Mockito . mock ( Storage . Objects . Get . class ) ; GcsPath pattern = GcsPath . fromUri ( _STR ) ; when ( mockStorage . objects ( ) ) . thenReturn ( mockStorageObjects ) ; when ( mockStorageObjects . get ( pattern . getBucket ( ) , pattern . getObject ( ) ) ) . thenReturn ( mockStorageGet ) ; when ( mockStorageGet . execute ( ) ) . thenThrow ( expectedException ) ; assertEquals ( Collections . EMPTY _ LIST , gcsUtil . expand ( pattern ) ) ; } 
5180	public boolean isSet ( _ Fields field ) { if ( field = = null ) { throw new java . lang . IllegalArgumentException ( ) ; } switch ( field ) { case STATUS : return isSetStatus ( ) ; case ELAPSED : return isSetElapsed ( ) ; case NUM : return isSetNum ( ) ; case COUNT : return isSetCount ( ) ; case SUM _ DEV : return isSetSumDev ( ) ; case FAIL : return isSetFail ( ) ; case QUEUE _ TIME : return isSetQueueTime ( ) ; case QUEUE _ SUM _ DEV : return isSetQueueSumDev ( ) ; } throw new java . lang . IllegalStateException ( ) ; } 
5181	public Builder with ( Animator anim ) { Node node = mNodeMap . get ( anim ) ; if ( node = = null ) { node = new Node ( anim ) ; mNodeMap . put ( anim , node ) ; mNodes . add ( node ) ; } Dependency dependency = new Dependency ( mCurrentNode , Dependency . WITH ) ; node . addDependency ( dependency ) ; return this ; } 
5182	public void rotate ( int rotateDegrees ) { Matrix mtx = new Matrix ( ) ; mtx . postRotate ( rotateDegrees ) ; image = Bitmap . createBitmap ( image , _NUM , _NUM , width , height , mtx , true ) ; width = image . getWidth ( ) ; height = image . getHeight ( ) ; updateColorArray ( ) ; } 
5183	public CmsUUID getLockedInProjectId ( ) { CmsUUID lockedInProject = null ; if ( getLock ( ) . isNullLock ( ) & & ! getResource ( ) . getState ( ) . isUnchanged ( ) ) { resource is unlocked and modified lockedInProject = getResource ( ) . getProjectLastModified ( ) ; } else if ( ! getResource ( ) . getState ( ) . isUnchanged ( ) ) { resource is locked and modified lockedInProject = getProjectId ( ) ; } else if ( ! getLock ( ) . isNullLock ( ) ) { resource is locked and unchanged lockedInProject = getLock ( ) . getProjectId ( ) ; } return lockedInProject ; } 
5184	public final List < String > getLinesToPrint ( final List < Map < String , String > > allLines ) { if ( allLines = = null | | allLines . isEmpty ( ) ) { return null ; } String outputMessage ; List < String > outputList = new ArrayList < String > ( ) ; for ( Map < String , String > map : allLines ) { Map < String , Object > sortedMap = new TreeMap < String , Object > ( map ) ; String storedMapStr = sortedMap . toString ( ) ; if ( ! eventsSet . contains ( storedMapStr ) ) { eventsSet . add ( storedMapStr ) ; outputMessage = getMessageFromMap ( sortedMap ) ; outputList . add ( outputMessage ) ; } } return outputList ; } 
5185	protected void createSourceReferences ( CellReference position , Sheet sourceSheet , PivotTableReferenceConfigurator refConfig ) { Get cell one to the right and one down from position , add both to AreaReference and set pivot table location . AreaReference destination = new AreaReference ( position , new CellReference ( position . getRow ( ) + _NUM , position . getCol ( ) + _NUM ) , SpreadsheetVersion . EXCEL _NUM _NUM _NUM _NUM ) ; CTLocation location ; if ( pivotTableDefinition . getLocation ( ) = = null ) { location = pivotTableDefinition . addNewLocation ( ) ; location . setFirstDataCol ( _NUM ) ; location . setFirstDataRow ( _NUM ) ; location . setFirstHeaderRow ( _NUM ) ; } else { location = pivotTableDefinition . getLocation ( ) ; } location . setRef ( destination . formatAsString ( ) ) ; pivotTableDefinition . setLocation ( location ) ; Set source for the pivot table CTPivotCacheDefinition cacheDef = getPivotCacheDefinition ( ) . getCTPivotCacheDefinition ( ) ; CTCacheSource cacheSource = cacheDef . addNewCacheSource ( ) ; cacheSource . setType ( STSourceType . WORKSHEET ) ; CTWorksheetSource worksheetSource = cacheSource . addNewWorksheetSource ( ) ; worksheetSource . setSheet ( sourceSheet . getSheetName ( ) ) ; setDataSheet ( sourceSheet ) ; refConfig . configureReference ( worksheetSource ) ; if ( worksheetSource . getName ( ) = = null & & worksheetSource . getRef ( ) = = null ) throw new IllegalArgumentException ( _STR ) ; } 
5186	boolean canPlaceEntityOnDisplay ( int displayId , boolean resizeable , int callingPid , int callingUid , ActivityInfo activityInfo ) { if ( displayId = = DEFAULT _ DISPLAY ) { No restrictions for the default display . return true ; } if ( ! mService . mSupportsMultiDisplay ) { Can ' t launch on secondary displays if feature is not supported . return false ; } if ( ! resizeable & & ! displayConfigMatchesGlobal ( displayId ) ) { Can ' t apply wrong configuration to non - resizeable activities . return false ; } if ( ! isCallerAllowedToLaunchOnDisplay ( callingPid , callingUid , displayId , activityInfo ) ) { by caller with corresponding permissions . See # isCallerAllowedToLaunchOnDisplay ( ) . return false ; } return true ; } 
5187	protected int computeHashCode ( ) { return rootElement _ . hashCode ( ) ; } 
5188	public void txn _ promote _ deadlock ( ) { Transaction txn _NUM = txnMgr . begin ( TxnType . READ ) ; Transaction txn _NUM = txnMgr . begin ( TxnType . WRITE ) ; Deadlock . Promotion waits for the writer to decide whether it is commiting or not . This can ' t be done on one thread . boolean b = txn _NUM . promote ( ) ; assertFalse ( b ) ; txn _NUM . end ( ) ; txn _NUM . commit ( ) ; txn _NUM . end ( ) ; checkClear ( ) ; } 
5189	public void readBadBuffer ( ) throws IOException { try { mTestStream . read ( new byte [ _NUM _NUM ] , _NUM , _NUM ) ; fail ( _STR ) ; } catch ( IllegalArgumentException e ) { assertEquals ( String . format ( PreconditionMessage . ERR _ BUFFER _ STATE . toString ( ) , _NUM _NUM , _NUM , _NUM ) , e . getMessage ( ) ) ; } } 
5190	public void write ( long fieldId , boolean val ) { assertNotCompacted ( ) ; final int id = ( int ) fieldId ; switch ( ( int ) ( ( fieldId & ( FIELD _ TYPE _ MASK | FIELD _ COUNT _ MASK ) ) > > FIELD _ TYPE _ SHIFT ) ) { bool case ( int ) ( ( FIELD _ TYPE _ BOOL | FIELD _ COUNT _ SINGLE ) > > FIELD _ TYPE _ SHIFT ) : writeBoolImpl ( id , val ) ; break ; case ( int ) ( ( FIELD _ TYPE _ BOOL | FIELD _ COUNT _ REPEATED ) > > FIELD _ TYPE _ SHIFT ) : case ( int ) ( ( FIELD _ TYPE _ BOOL | FIELD _ COUNT _ PACKED ) > > FIELD _ TYPE _ SHIFT ) : writeRepeatedBoolImpl ( id , val ) ; break ; nothing else allowed default : { throw new IllegalArgumentException ( _STR + getFieldIdString ( fieldId ) ) ; } } } 
5191	public Iterator < Character > iterator ( ) { return new Iterator < Character > ( ) { private final TCharIterator it = _ set . iterator ( ) ; public Character next ( ) { return Character . valueOf ( it . next ( ) ) ; } public boolean hasNext ( ) { return it . hasNext ( ) ; } public void remove ( ) { it . remove ( ) ; } } ; } 
5192	public PKCS _NUM _NUM CertificationRequestBuilder setAttribute ( ASN _NUM ObjectIdentifier attrType , ASN _NUM Encodable attrValue ) { Remove existing copies of the attribute . for ( Iterator it = attributes . iterator ( ) ; it . hasNext ( ) ; ) { if ( ( ( Attribute ) it . next ( ) ) . getAttrType ( ) . equals ( attrType ) ) { throw new IllegalStateException ( _STR ) ; } } addAttribute ( attrType , attrValue ) ; return this ; } 
5193	public static ViewModelProvider of ( @ NonNull FragmentActivity activity , @ NonNull Factory factory ) { checkApplication ( activity ) ; return new ViewModelProvider ( ViewModelStores . of ( activity ) , factory ) ; } 
5194	public void onBindViewHolder ( K holder , int position ) { Add up fetch logic , almost like load more , but simpler . autoUpFetch ( position ) ; Do not move position , need to change before LoadMoreView binding autoLoadMore ( position ) ; int viewType = holder . getItemViewType ( ) ; switch ( viewType ) { case _NUM : convert ( holder , getItem ( position - getHeaderLayoutCount ( ) ) ) ; break ; case LOADING _ VIEW : mLoadMoreView . convert ( holder ) ; break ; case HEADER _ VIEW : break ; case EMPTY _ VIEW : break ; case FOOTER _ VIEW : break ; default : convert ( holder , getItem ( position - getHeaderLayoutCount ( ) ) ) ; break ; } } 
5195	protected static String makeOptionString ( DataGenerator generator ) { StringBuffer result ; Enumeration enm ; Option option ; result = new StringBuffer ( ) ; result . append ( _STR ) ; } return result . toString ( ) ; } 
5196	public String getVisualVoicemailPackageName ( ) { try { ITelephony telephony = getITelephony ( ) ; if ( telephony ! = null ) { return telephony . getVisualVoicemailPackageName ( mContext . getOpPackageName ( ) , getSubId ( ) ) ; } } catch ( RemoteException ex ) { } catch ( NullPointerException ex ) { } return null ; } 
5197	public Serializer getSerializer ( Class cl ) throws HessianProtocolException { Serializer serializer ; serializer = ( Serializer ) _ staticSerializerMap . get ( cl ) ; if ( serializer ! = null ) { return serializer ; } if ( _ cachedSerializerMap ! = null ) { serializer = ( Serializer ) _ cachedSerializerMap . get ( cl ) ; if ( serializer ! = null ) { return serializer ; } } for ( int i = _NUM ; serializer = = null & & _ factories ! = null & & i < _ factories . size ( ) ; i + + ) { AbstractSerializerFactory factory ; factory = ( AbstractSerializerFactory ) _ factories . get ( i ) ; serializer = factory . getSerializer ( cl ) ; } if ( serializer ! = null ) { } else if ( must before _STR isZoneId ( cl ) ) serializer = ZoneIdSerializer . getInstance ( ) ; else if ( isEnumSet ( cl ) ) serializer = EnumSetSerializer . getInstance ( ) ; else if ( JavaSerializer . getWriteReplace ( cl ) ! = null ) serializer = new JavaSerializer ( cl , _ loader ) ; else if ( HessianRemoteObject . class . isAssignableFrom ( cl ) ) serializer = new RemoteSerializer ( ) ; else if ( Map . class . isAssignableFrom ( cl ) ) { if ( _ mapSerializer = = null ) _ mapSerializer = new MapSerializer ( ) ; serializer = _ mapSerializer ; } else if ( Collection . class . isAssignableFrom ( cl ) ) { if ( _ collectionSerializer = = null ) { _ collectionSerializer = new CollectionSerializer ( ) ; } serializer = _ collectionSerializer ; } else if ( cl . isArray ( ) ) { serializer = new ArraySerializer ( ) ; } else if ( Throwable . class . isAssignableFrom ( cl ) ) { serializer = new ThrowableSerializer ( cl , getClassLoader ( ) ) ; } else if ( InputStream . class . isAssignableFrom ( cl ) ) { serializer = new InputStreamSerializer ( ) ; } else if ( Iterator . class . isAssignableFrom ( cl ) ) { serializer = IteratorSerializer . create ( ) ; } else if ( Enumeration . class . isAssignableFrom ( cl ) ) { serializer = EnumerationSerializer . create ( ) ; } else if ( Calendar . class . isAssignableFrom ( cl ) ) { serializer = CalendarSerializer . create ( ) ; } else if ( Locale . class . isAssignableFrom ( cl ) ) { serializer = LocaleSerializer . create ( ) ; } else if ( Enum . class . isAssignableFrom ( cl ) ) { serializer = new EnumSerializer ( cl ) ; } if ( serializer = = null ) { serializer = getDefaultSerializer ( cl ) ; } if ( _ cachedSerializerMap = = null ) { _ cachedSerializerMap = new ConcurrentHashMap ( _NUM ) ; } _ cachedSerializerMap . put ( cl , serializer ) ; return serializer ; } 
5198	public void setContentWidth ( int width ) { Drawable popupBackground = mPopup . getBackground ( ) ; if ( popupBackground ! = null ) { popupBackground . getPadding ( mTempRect ) ; mDropDownWidth = mTempRect . left + mTempRect . right + width ; } else { setWidth ( width ) ; } } 
5199	public Enumeration < TechnicalInformation > additional ( ) { return m _ Additional . elements ( ) ; } 
5200	public static void setStarRatingDisableAskingForEachAppVersion ( Context context , boolean disableAsking ) { StarRatingPreferences srp = loadStarRatingPreferences ( context ) ; srp . disabledAutomaticForNewVersions = disableAsking ; saveStarRatingPreferences ( context , srp ) ; } 
5201	public boolean isEmpty ( ) { if ( s _ checkValid ) { checkValid ( ) ; } return equals ( listNil ( ) ) ; } 
5202	 @ VisibleForTestingboolean isCallerDeviceOwner ( int callerUid ) { synchronized ( this ) { if ( ! mOwners . hasDeviceOwner ( ) ) { return false ; } if ( UserHandle . getUserId ( callerUid ) ! = mOwners . getDeviceOwnerUserId ( ) ) { return false ; } final String deviceOwnerPackageName = mOwners . getDeviceOwnerComponent ( ) . getPackageName ( ) ; try { String [ ] pkgs = mInjector . getIPackageManager ( ) . getPackagesForUid ( callerUid ) ; for ( String pkg : pkgs ) { if ( deviceOwnerPackageName . equals ( pkg ) ) { return true ; } } } catch ( RemoteException e ) { return false ; } } return false ; } 
5203	public ComponentSelector removeTags ( String . . . tags ) { for ( Component c : this ) { String existing = ( String ) c . getClientProperty ( PROPERTY _ TAG ) ; if ( existing = = null ) { continue ; } Set < String > existingSet = new HashSet < String > ( ) ; String [ ] existingStrs = Util . split ( _STR ; } c . putClientProperty ( PROPERTY _ TAG , existing ) ; } return this ; } 
5204	public static RadioButton createToggle ( String text , Image icon , ButtonGroup bg ) { RadioButton rb = new RadioButton ( text , icon ) ; bg . add ( rb ) ; rb . setToggle ( true ) ; return rb ; } 
5205	public String getTabTitle ( int index ) { checkIndex ( index ) ; return getTabTitle ( tabsContainer . getComponentAt ( index ) ) ; } 
5206	public void testE _NUM EV _NUM WriteWithLargeEntities ( ) throws Exception { Pipeline p = Pipeline . create ( options ) ; final int rawPropertySize = _NUM _NUM _NUM _ _NUM _NUM _NUM ; final int numLargeEntities = _NUM _NUM _NUM ; Write to datastore p . apply ( GenerateSequence . from ( _NUM ) . to ( numLargeEntities ) ) . apply ( ParDo . of ( new CreateEntityFn ( options . getKind ( ) , options . getNamespace ( ) , ancestor , rawPropertySize ) ) ) . apply ( DatastoreIO . v _NUM ( ) . write ( ) . withProjectId ( project ) ) ; p . run ( ) ; Count number of entities written to datastore . long numEntitiesWritten = countEntities ( options , project , ancestor ) ; assertEquals ( numEntitiesWritten , numLargeEntities ) ; } 
5207	protected Clock getClock ( ) { return getWallClock ( ) ; } 
5208	void takeScreenshot ( Runnable finisher , boolean statusBarVisible , boolean navBarVisible , int x , int y , int width , int height ) { We need to orient the screenshot correctly ( and the Surface api seems to take screenshots only in the natural orientation of the device : ! ) mDisplay . getRealMetrics ( mDisplayMetrics ) ; float [ ] dims = { mDisplayMetrics . widthPixels , mDisplayMetrics . heightPixels } ; float degrees = getDegreesForRotation ( mDisplay . getRotation ( ) ) ; boolean requiresRotation = ( degrees > _NUM ) ; if ( requiresRotation ) { Get the dimensions of the device in its native orientation mDisplayMatrix . reset ( ) ; mDisplayMatrix . preRotate ( - degrees ) ; mDisplayMatrix . mapPoints ( dims ) ; dims [ _NUM ] = Math . abs ( dims [ _NUM ] ) ; dims [ _NUM ] = Math . abs ( dims [ _NUM ] ) ; } Take the screenshot mScreenBitmap = SurfaceControl . screenshot ( ( int ) dims [ _NUM ] , ( int ) dims [ _NUM ] ) ; if ( mScreenBitmap = = null ) { notifyScreenshotError ( mContext , mNotificationManager , R . string . screenshot _ failed _ to _ capture _ text ) ; finisher . run ( ) ; return ; } if ( requiresRotation ) { Rotate the screenshot to the current orientation Bitmap ss = Bitmap . createBitmap ( mDisplayMetrics . widthPixels , mDisplayMetrics . heightPixels , Bitmap . Config . ARGB _ _NUM _NUM _NUM _NUM , mScreenBitmap . hasAlpha ( ) , mScreenBitmap . getColorSpace ( ) ) ; Canvas c = new Canvas ( ss ) ; c . translate ( ss . getWidth ( ) / _NUM , ss . getHeight ( ) / _NUM ) ; c . rotate ( degrees ) ; c . translate ( - dims [ _NUM ] / _NUM , - dims [ _NUM ] / _NUM ) ; c . drawBitmap ( mScreenBitmap , _NUM , _NUM , null ) ; c . setBitmap ( null ) ; Recycle the previous bitmap mScreenBitmap . recycle ( ) ; mScreenBitmap = ss ; } if ( width ! = mDisplayMetrics . widthPixels | | height ! = mDisplayMetrics . heightPixels ) { Crop the screenshot to selected region Bitmap cropped = Bitmap . createBitmap ( mScreenBitmap , x , y , width , height ) ; mScreenBitmap . recycle ( ) ; mScreenBitmap = cropped ; } Optimizations mScreenBitmap . setHasAlpha ( false ) ; mScreenBitmap . prepareToDraw ( ) ; Start the post - screenshot animation startAnimation ( finisher , mDisplayMetrics . widthPixels , mDisplayMetrics . heightPixels , statusBarVisible , navBarVisible ) ; } 
5209	public void setSelected ( int index ) { if ( index < _NUM | | index > = getButtonCount ( ) ) throw new IllegalArgumentException ( _STR ) ; if ( selectedIndex = = index ) { return ; } if ( selectedIndex ! = - _NUM ) { unselect last selected Radio button ( ( RadioButton ) buttons . get ( selectedIndex ) ) . setSelectedImpl ( false ) ; } ( ( RadioButton ) buttons . get ( index ) ) . setSelectedImpl ( true ) ; selectedIndex = index ; } 
5210	public LinkProperties getLinkProperties ( Network network ) { enforceAccessPermission ( ) ; return getLinkProperties ( getNetworkAgentInfoForNetwork ( network ) ) ; } 
5211	public Statement saveQuery ( T entity , Option . . . options ) { checkNotInEventLoop ( ) ; try { return Uninterruptibles . getUninterruptibly ( saveQueryAsync ( entity , toMapWithDefaults ( options , this . defaultSaveOptions ) ) ) ; } catch ( ExecutionException e ) { throw DriverThrowables . propagateCause ( e ) ; } } 
5212	public void testCreateConnectionFromConfiguration ( ) throws Exception { Properties props = new Properties ( ) ; standard lookup . this already checks if we set hbase . zookeeper . clientPort Configuration conf = new Configuration ( false ) ; conf . set ( HConstants . ZOOKEEPER _ QUORUM , _STR ) ; conn = QueryUtil . getConnectionUrl ( props , conf ) ; validateUrl ( conn ) ; } 
5213	public void clearLinks ( ) { links . clear ( ) ; } 
5214	public void append ( LoggingEvent event ) { if ( ! checkEntryConditions ( ) ) { return ; } try { ObjectMessage msg = queueSession . createObjectMessage ( ) ; msg . setObject ( event ) ; queueSender . send ( msg ) ; } catch ( Exception e ) { errorHandler . error ( _STR , e , ErrorCode . GENERIC _ FAILURE ) ; } } 
5215	public String getPath ( Property property ) { checkType ( property , PropertyType . PATH ) ; String pathString = get ( property ) ; if ( pathString = = null ) return null ; for ( String replaceableEnvVar : Constants . PATH _ PROPERTY _ ENV _ VARS ) { String envValue = System . getenv ( replaceableEnvVar ) ; if ( envValue ! = null ) pathString = pathString . replace ( _STR + replaceableEnvVar , envValue ) ; } return pathString ; } 
5216	public static void warn ( Object . . . messages ) { _ log ( ) . warn ( messages ) ; } 
5217	public static String nameToIdentifier ( String name , IdentifierType type ) { if ( null = = name | | name . length ( ) = = _NUM ) { return name ; } algorithm will not change an XML name that is already a legal and conventional ( ! ) Java class , method , or constant identifier boolean legalIdentifier = false ; StringBuilder buf = new StringBuilder ( name ) ; boolean hasUnderscore = false ; legalIdentifier = Character . isJavaIdentifierStart ( buf . charAt ( _NUM ) ) ; for ( int i = _NUM ; i < name . length ( ) & & legalIdentifier ; i + + ) { legalIdentifier & = Character . isJavaIdentifierPart ( buf . charAt ( i ) ) ; hasUnderscore | = ' _ ' = = buf . charAt ( i ) ; } boolean conventionalIdentifier = isConventionalIdentifier ( buf , type ) ; if ( legalIdentifier & & conventionalIdentifier ) { if ( JAXBUtils . isJavaKeyword ( name ) & & type = = IdentifierType . VARIABLE ) { name = normalizePackageNamePart ( name ) ; } if ( ! hasUnderscore | | IdentifierType . CLASS ! = type ) { return name ; } } split into words List < String > words = new ArrayList < > ( ) ; StringTokenizer st = new StringTokenizer ( name , XML _ NAME _ PUNCTUATION _ STRING ) ; while ( st . hasMoreTokens ( ) ) { words . add ( st . nextToken ( ) ) ; } for ( int i = _NUM ; i < words . size ( ) ; i + + ) { splitWord ( words , i ) ; } return makeConventionalIdentifier ( words , type ) ; } 
5218	private void downgradeEasyCorrectionSpans ( ) { CharSequence text = mTextView . getText ( ) ; if ( text instanceof Spannable ) { Spannable spannable = ( Spannable ) text ; SuggestionSpan [ ] suggestionSpans = spannable . getSpans ( _NUM , spannable . length ( ) , SuggestionSpan . class ) ; for ( int i = _NUM ; i < suggestionSpans . length ; i + + ) { int flags = suggestionSpans [ i ] . getFlags ( ) ; if ( ( flags & SuggestionSpan . FLAG _ EASY _ CORRECT ) ! = _NUM & & ( flags & SuggestionSpan . FLAG _ MISSPELLED ) = = _NUM ) { flags & = ~ SuggestionSpan . FLAG _ EASY _ CORRECT ; suggestionSpans [ i ] . setFlags ( flags ) ; } } } } 
5219	 @ SuppressWarnings ( _STR , key , value , e ) ; } } 
5220	public < T extends Comparable < ? super T > > void expectKeyValueInRange ( CameraCharacteristics characteristics , CameraCharacteristics . Key < T > key , T min , T max ) { T value ; if ( ( value = expectKeyValueNotNull ( characteristics , key ) ) = = null ) { return ; } expectInRange ( key . getName ( ) , value , min , max ) ; } 
5221	public static double calculatePieDatasetTotal ( PieDataset dataset ) { if ( dataset = = null ) { throw new IllegalArgumentException ( _STR ) ; } List keys = dataset . getKeys ( ) ; double totalValue = _NUM ; Iterator iterator = keys . iterator ( ) ; while ( iterator . hasNext ( ) ) { Comparable current = ( Comparable ) iterator . next ( ) ; if ( current ! = null ) { Number value = dataset . getValue ( current ) ; double v = _NUM . _NUM ; if ( value ! = null ) { v = value . doubleValue ( ) ; } if ( v > _NUM ) { totalValue = totalValue + v ; } } } return totalValue ; } 
5222	public void uninstallCaCert ( @ Nullable ComponentName admin , byte [ ] certBuffer ) { throwIfParentInstance ( _STR , e ) ; } catch ( RemoteException e ) { throw e . rethrowFromSystemServer ( ) ; } } } 
5223	private Set < Resource > getKerberosDescriptors ( Request request , Predicate predicate ) throws SystemException , UnsupportedPropertyException , NoSuchParentResourceException , NoSuchResourceException { Set < Resource > resources = new HashSet < > ( ) ; for ( Map < String , Object > properties : getPropertyMaps ( predicate ) ) { String artifactName = ( String ) properties . get ( ARTIFACT _ NAME _ PROPERTY _ ID ) ; if ( artifactName = = null | | artifactName . equals ( KERBEROS _ DESCRIPTOR _ NAME ) ) { String stackName = ( String ) properties . get ( STACK _ NAME _ PROPERTY _ ID ) ; String stackVersion = ( String ) properties . get ( STACK _ VERSION _ PROPERTY _ ID ) ; String stackService = ( String ) properties . get ( STACK _ SERVICE _ NAME _ PROPERTY _ ID ) ; Map < String , Object > descriptor ; try { descriptor = getKerberosDescriptor ( stackName , stackVersion , stackService ) ; } catch ( IOException e ) { LOG . error ( _STR , e ) ; } if ( descriptor ! = null ) { Resource resource = new ResourceImpl ( Resource . Type . StackArtifact ) ; Set < String > requestedIds = getRequestPropertyIds ( request , predicate ) ; setResourceProperty ( resource , ARTIFACT _ NAME _ PROPERTY _ ID , KERBEROS _ DESCRIPTOR _ NAME , requestedIds ) ; setResourceProperty ( resource , ARTIFACT _ DATA _ PROPERTY _ ID , descriptor , requestedIds ) ; setResourceProperty ( resource , STACK _ NAME _ PROPERTY _ ID , stackName , requestedIds ) ; setResourceProperty ( resource , STACK _ VERSION _ PROPERTY _ ID , stackVersion , requestedIds ) ; if ( stackService ! = null ) { setResourceProperty ( resource , STACK _ SERVICE _ NAME _ PROPERTY _ ID , stackService , requestedIds ) ; } resources . add ( resource ) ; } } } return resources ; } 
5224	public static void propagateCxfToCamel ( HeaderFilterStrategy strategy , Message cxfMessage , org . apache . camel . Message camelMessage , Exchange exchange ) { if ( strategy = = null ) { return ; } Copy the CXF protocol headers to the camel headers copyProtocolHeadersFromCxfToCamel ( strategy , exchange , cxfMessage , camelMessage ) ; Copy the CXF HTTP headers to the camel headers copyHttpHeadersFromCxfToCamel ( strategy , cxfMessage , camelMessage , exchange ) ; propagate request context copyCxfHeaderToCamel ( strategy , exchange , cxfMessage , camelMessage , Client . REQUEST _ CONTEXT ) ; propagate response context copyCxfHeaderToCamel ( strategy , exchange , cxfMessage , camelMessage , Client . RESPONSE _ CONTEXT ) ; } 
5225	public static PortletPhase getPhase ( ) { return ( PortletPhase ) getContext ( ) . get ( PHASE ) ; } 
5226	public double getSpoutEmittedAggregate ( ) { double ret = _NUM ; for ( LoadCompConf spout : spouts ) { ret + = spout . getAllEmittedAggregate ( ) ; } return ret ; } 
5227	public void ping ( ) { otherwise , the learner will crash if ( ! sendingThreadStarted ) { return ; } long id ; if ( syncLimitCheck . check ( System . nanoTime ( ) ) ) { synchronized ( leader ) { id = leader . lastProposed ; } QuorumPacket ping = new QuorumPacket ( Leader . PING , id , null , null ) ; queuePacket ( ping ) ; } else { LOG . warn ( _STR ) ; shutdown ( ) ; } } 
5228	public void testDataDirectories ( ) throws IOException { File dataDir = new File ( BASE _ DIR , _STR , cluster . isDataNodeUp ( ) ) ; } finally { if ( cluster ! = null ) { cluster . shutdownDataNodes ( ) ; } } } 
5229	public void writeImpl ( D record ) throws IOException { if ( ! isRetry ( ) ) { If currentRequest is still here , it means this is retry request . In this case , don ' t invoke onNewRecord again as onNewRecord is not guaranteed to be idempotent . ( e . g : If you do batch processing duplicate record can go in , etc . ) curRequest = onNewRecord ( record ) ; } if ( curRequest . isPresent ( ) ) { ListenableFuture < CloseableHttpResponse > responseFuture = sendRequest ( curRequest . get ( ) ) ; try ( CloseableHttpResponse response = waitForResponse ( responseFuture ) ) { processResponse ( response ) ; } Clear request if successful curRequest = Optional . absent ( ) ; } numRecordsWritten + + ; } 
5230	public boolean isException ( final String name ) { checkName ( name ) ; return exceptions . containsKey ( name ) ; } 
5231	static String [ ] getSuffixIDs ( final Configuration conf , final String addressKey , String knownNsId , String knownNNId , final AddressMatcher matcher ) { String nameserviceId = null ; String namenodeId = null ; int found = _NUM ; Collection < String > nsIds = DFSUtilClient . getNameServiceIds ( conf ) ; for ( String nsId : DFSUtilClient . emptyAsSingletonNull ( nsIds ) ) { if ( knownNsId ! = null & & ! knownNsId . equals ( nsId ) ) { continue ; } Collection < String > nnIds = DFSUtilClient . getNameNodeIds ( conf , nsId ) ; for ( String nnId : DFSUtilClient . emptyAsSingletonNull ( nnIds ) ) { if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( String . format ( _STR + DFS _ HA _ NAMENODE _ ID _ KEY ; throw new HadoopIllegalArgumentException ( msg ) ; } return new String [ ] { nameserviceId , namenodeId } ; } 
5232	public void actionPerformed ( ActionEvent event ) { String command = event . getActionCommand ( ) ; if ( command . equals ( _STR ) ) { attemptModifyShowTitle ( ) ; } } 
5233	public String toString ( ) { StringBuffer text = new StringBuffer ( toStringNoWeight ( ) ) ; if ( m _ Weight ! = _NUM . _NUM ) { text . append ( _STR ) ; } return text . toString ( ) ; } 
5234	public void updateResultsTab ( final boolean isNextPage ) { if the RPC call will be sent the search object is in a unchanged state m _ searchObjectChanged = false ; if ( m _ searchObject . isEmpty ( ) ) { don ' t search : notify the user that at least one search criteria should be selected m _ handler . showNoParamsMessage ( ) ; } else { perform the search CmsRpcAction < CmsGallerySearchBean > searchAction = new CmsRpcAction < CmsGallerySearchBean > ( ) { private int m _ callId ; @ Override public void execute ( ) { m _ currentCallId + + ; m _ callId = m _ currentCallId ; m _ loading = true ; CmsGallerySearchBean preparedObject = prepareSearchObject ( ) ; if ( isNextPage ) { preparedObject . setPage ( preparedObject . getLastPage ( ) + _NUM ) ; } else { preparedObject . setPage ( _NUM ) ; } getGalleryService ( ) . getSearch ( preparedObject , this ) ; } @ Override public void onResponse ( CmsGallerySearchBean searchObj ) { if ( m _ callId ! = m _ currentCallId ) { return ; } if ( ! isNextPage ) { m _ handler . hideShowPreviewButton ( true ) ; } m _ loading = false ; m _ searchObject . setResults ( searchObj . getResults ( ) ) ; m _ searchObject . setResultCount ( searchObj . getResultCount ( ) ) ; m _ searchObject . setSortOrder ( searchObj . getSortOrder ( ) ) ; m _ searchObject . setPage ( searchObj . getPage ( ) ) ; m _ searchObject . setLastPage ( searchObj . getLastPage ( ) ) ; m _ handler . onResultTabSelection ( m _ searchObject ) ; } } ; searchAction . execute ( ) ; } } 
5235	public void testOr ( ) { final Fixture f = new Fixture ( ) ; final RexNode xGt _NUM = f . gt ( f . i , f . literal ( _NUM ) ) ; final RexNode yGt _NUM = f . gt ( f . dec , f . literal ( _NUM ) ) ; final RexNode yGt _NUM = f . gt ( f . dec , f . literal ( _NUM ) ) ; final RexNode zGt _NUM = f . gt ( f . lg , f . literal ( _NUM ) ) ; final RexNode zGt _NUM = f . gt ( f . lg , f . literal ( _NUM ) ) ; final RexNode yGt _NUM AndZGt _NUM = f . and ( yGt _NUM , zGt _NUM ) ; final RexNode yGt _NUM AndZGt _NUM = f . and ( yGt _NUM , zGt _NUM ) ; final RexNode or = f . or ( xGt _NUM , yGt _NUM AndZGt _NUM ) ; f . checkNotImplies ( or , yGt _NUM AndZGt _NUM ) ; f . checkImplies ( yGt _NUM AndZGt _NUM , or ) ; } 
5236	public void compact ( boolean major ) throws IOException { getMiniHBaseCluster ( ) . compact ( major ) ; } 
5237	public static String toString ( Object o , String tagName ) throws JSONException { StringBuffer b = new StringBuffer ( ) ; int i ; JSONArray ja ; JSONObject jo ; String k ; Iterator keys ; int len ; String s ; Object v ; if ( o instanceof JSONObject ) { if ( tagName ! = null ) { b . append ( ' < ' ) ; b . append ( tagName ) ; b . append ( ' > ' ) ; } Loop thru the keys . jo = ( JSONObject ) o ; keys = jo . keys ( ) ; while ( keys . hasNext ( ) ) { k = keys . next ( ) . toString ( ) ; v = jo . get ( k ) ; if ( v instanceof String ) { s = ( String ) v ; } else { s = null ; } if ( k . equals ( _STR ; } } 
5238	public void testXbarStd ( ) { logger . info ( _STR ) ; FlatDataCollection flatDataCollection = generateFlatDataCollection ( ) ; double expResult = _NUM _NUM . _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM ; double result = SystematicSampling . xbarStd ( flatDataCollection ) ; assertEquals ( expResult , result , Constants . DOUBLE _ ACCURACY _ HIGH ) ; } 
5239	public void setPadding ( int left , int top , int right , int bottom ) { if ( ( left | top | right | bottom ) = = _NUM ) { mShapeState . mPadding = null ; } else { if ( mShapeState . mPadding = = null ) { mShapeState . mPadding = new Rect ( ) ; } mShapeState . mPadding . set ( left , top , right , bottom ) ; } invalidateSelf ( ) ; } 
5240	public void finishWrite ( FileOutputStream str ) { if ( str ! = null ) { FileUtils . sync ( str ) ; try { str . close ( ) ; mBackupName . delete ( ) ; } catch ( IOException e ) { Log . w ( _STR , e ) ; } } } 
5241	public static String parseCharset ( Map < String , String > headers , String defaultCharset ) { String contentType = headers . get ( HTTP . CONTENT _ TYPE ) ; if ( contentType ! = null ) { String [ ] params = contentType . split ( _STR ) ) { return pair [ _NUM ] ; } } } } return defaultCharset ; } 
5242	public Widget getButton ( int index ) { return m _ buttonPanel . getWidget ( index ) ; } 
5243	public void testExportImportCollection ( ) throws Exception { create a collection of _STR , null , Level . ALL _ PROPERTIES ) . getEntities ( ) ; assertTrue ( ! importedThings . isEmpty ( ) ) ; } finally { deleteBucket ( ) ; } } 
5244	public static String removeQueryStringFromTarget ( String target ) { if ( UtilValidate . isEmpty ( target ) ) return null ; int queryStart = target . indexOf ( ' ? ' ) ; if ( queryStart < _NUM ) { return target ; } return target . substring ( _NUM , queryStart ) ; } 
5245	public RecordReader < ImmutableBytesWritable , Result > getRecordReader ( InputSplit split , JobConf job , Reporter reporter ) throws IOException { In case a subclass uses the deprecated approach or calls initializeTable directly if ( table = = null ) { initialize ( job ) ; } null check in case our child overrides getTable to not throw . try { if ( getTable ( ) = = null ) { initialize ( ) must not have been implemented in the subclass . throw new IOException ( INITIALIZATION _ ERROR ) ; } } catch ( IllegalStateException exception ) { throw new IOException ( INITIALIZATION _ ERROR , exception ) ; } TableSplit tSplit = ( TableSplit ) split ; if no table record reader was provided use default final TableRecordReader trr = this . tableRecordReader = = null ? new TableRecordReader ( ) : this . tableRecordReader ; trr . setStartRow ( tSplit . getStartRow ( ) ) ; trr . setEndRow ( tSplit . getEndRow ( ) ) ; trr . setHTable ( this . table ) ; trr . setInputColumns ( this . inputColumns ) ; trr . setRowFilter ( this . rowFilter ) ; trr . init ( ) ; return new RecordReader < ImmutableBytesWritable , Result > ( ) { @ Override public void close ( ) throws IOException { trr . close ( ) ; closeTable ( ) ; } @ Override public ImmutableBytesWritable createKey ( ) { return trr . createKey ( ) ; } @ Override public Result createValue ( ) { return trr . createValue ( ) ; } @ Override public long getPos ( ) throws IOException { return trr . getPos ( ) ; } @ Override public float getProgress ( ) throws IOException { return trr . getProgress ( ) ; } @ Override public boolean next ( ImmutableBytesWritable key , Result value ) throws IOException { return trr . next ( key , value ) ; } } ; } 
5246	public void actionReport ( ) throws JspException { save initialized instance of this class in request attribute for included sub - elements getJsp ( ) . getRequest ( ) . setAttribute ( SESSION _ WORKPLACE _ CLASS , this ) ; switch ( getAction ( ) ) { case ACTION _ REPORT _ END : actionCloseDialog ( ) ; break ; case ACTION _ REPORT _ UPDATE : setParamAction ( REPORT _ UPDATE ) ; getJsp ( ) . include ( FILE _ REPORT _ OUTPUT ) ; break ; case ACTION _ REPORT _ BEGIN : case ACTION _ CONFIRMED : default : CmsMergePagesThread thread = new CmsMergePagesThread ( getCms ( ) , this ) ; thread . start ( ) ; setParamAction ( REPORT _ BEGIN ) ; setParamThread ( thread . getUUID ( ) . toString ( ) ) ; getJsp ( ) . include ( FILE _ REPORT _ OUTPUT ) ; break ; } } 
5247	public void unLockWindows ( ) { safeGetWorkbookProtection ( ) . setLockWindows ( false ) ; } 
5248	private void createLinks ( ) { LOG . info ( _STR ) ; Collection < ExtensionInfo > extensions = getExtensions ( ) ; Set < String > names = new HashSet < > ( ) ; for ( ExtensionInfo extension : extensions ) { names . add ( extension . getName ( ) ) ; } for ( String name : names ) { createLinksForExtension ( name ) ; } } 
5249	public static Predicate fromJSON ( String json ) { Map < String , Object > map = new Gson ( ) . fromJson ( json , PARSED _ TYPE ) ; return ( StringUtils . isEmpty ( json ) ? null : fromMap ( map ) ) ; } 
5250	private synchronized void detectorTaskScheduler ( ) { CorfuRuntime corfuRuntime = getCorfuRuntime ( ) ; getCorfuRuntime ( ) . invalidateLayout ( ) ; serverContext . saveManagementLayout ( corfuRuntime . getLayoutView ( ) . getLayout ( ) ) ; if ( ! canHandleReconfigurations ( ) ) { return ; } runFailureDetectorTask ( ) ; runHealingDetectorTask ( ) ; } 
5251	public void testSort ( ) { { Integer [ ] input = new Integer [ ] { _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM } ; Integer [ ] expected = new Integer [ ] { _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM } ; doTest ( input , expected ) ; } { Integer [ ] input = new Integer [ ] { _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM } ; Integer [ ] expected = new Integer [ ] { _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM } ; doTest ( input , expected ) ; } { Integer [ ] input = new Integer [ ] { } ; Integer [ ] expected = new Integer [ ] { } ; doTest ( input , expected ) ; } { Integer [ ] input = new Integer [ ] { _NUM } ; Integer [ ] expected = new Integer [ ] { _NUM } ; doTest ( input , expected ) ; } { Integer [ ] input = new Integer [ ] { _NUM , _NUM } ; Integer [ ] expected = new Integer [ ] { _NUM , _NUM } ; doTest ( input , expected ) ; } { Integer [ ] input = new Integer [ ] { _NUM , _NUM } ; Integer [ ] expected = new Integer [ ] { _NUM , _NUM } ; doTest ( input , expected ) ; } Random rnd = new Random ( _NUM _NUM _NUM _NUM _NUM ) ; for ( int cnt = _NUM ; cnt < _NUM _NUM _NUM ; + + cnt ) { int len = rnd . nextInt ( _NUM _NUM _NUM _NUM _NUM ) + _NUM ; Integer [ ] input = new Integer [ len ] ; Integer [ ] expected = new Integer [ len ] ; for ( int i = _NUM ; i < len ; + + i ) { choose values so that there are some duplicates expected [ i ] = input [ i ] = rnd . nextInt ( rnd . nextInt ( _NUM _NUM _NUM ) + _NUM ) ; } Arrays . sort ( expected ) ; doTest ( input , expected ) ; } } 
5252	public Text getServiceName ( ) { requireNonNull ( identifier ) ; return new Text ( SERVICE _ NAME + _STR + identifier . getInstanceId ( ) ) ; } 
5253	public static WebApplicationService getService ( final List < ArgumentExtractor > argumentExtractors , final RequestContext context ) { final HttpServletRequest request = WebUtils . getHttpServletRequestFromExternalWebflowContext ( context ) ; return HttpRequestUtils . getService ( argumentExtractors , request ) ; } 
5254	public static GCSUnderFileSystem createInstance ( AlluxioURI uri , UnderFileSystemConfiguration conf ) throws ServiceException { String bucketName = UnderFileSystemUtils . getBucketName ( uri ) ; Preconditions . checkArgument ( conf . containsKey ( PropertyKey . GCS _ ACCESS _ KEY ) , _STR ) ; } GSAccessControlList acl = googleStorageService . getBucketAcl ( bucketName ) ; short bucketMode = GCSUtils . translateBucketAcl ( acl , accountOwnerId ) ; return new GCSUnderFileSystem ( uri , googleStorageService , bucketName , bucketMode , accountOwner , conf ) ; } 
5255	public void onAnimationUpdate ( ValueAnimator animation ) { setStackScroll ( ( Float ) animation . getAnimatedValue ( ) ) ; } } ) ; mScrollAnimator . addListener ( new AnimatorListenerAdapter ( ) { @ Override public void onAnimationEnd ( Animator animation ) { if ( postRunnable ! = null ) { postRunnable . run ( ) ; } mScrollAnimator . removeAllListeners ( ) ; } } ) ; mScrollAnimator . start ( ) ; } 
5256	void doImportCheckpoint ( FSNamesystem target ) throws IOException { Collection < URI > checkpointDirs = FSImage . getCheckpointDirs ( conf , null ) ; List < URI > checkpointEditsDirs = FSImage . getCheckpointEditsDirs ( conf , null ) ; if ( checkpointDirs = = null | | checkpointDirs . isEmpty ( ) ) { throw new IOException ( _STR ) ; } FSImage realImage = target . getFSImage ( ) ; FSImage ckptImage = new FSImage ( conf , checkpointDirs , checkpointEditsDirs ) ; load from the checkpoint dirs try { ckptImage . recoverTransitionRead ( StartupOption . REGULAR , target , null ) ; } finally { ckptImage . close ( ) ; } return back the real image realImage . getStorage ( ) . setStorageInfo ( ckptImage . getStorage ( ) ) ; realImage . getEditLog ( ) . setNextTxId ( ckptImage . getEditLog ( ) . getLastWrittenTxId ( ) + _NUM ) ; realImage . initEditLog ( StartupOption . IMPORT ) ; realImage . getStorage ( ) . setBlockPoolID ( ckptImage . getBlockPoolID ( ) ) ; and save it but keep the same checkpointTime saveNamespace ( target ) ; getStorage ( ) . writeAll ( ) ; } 
5257	ArrayList < String > updateOverlaysForUser ( final int newUserId ) { if ( DEBUG ) { Slog . d ( TAG , _STR , e ) ; mSettings . remove ( overlayPackage . packageName , newUserId ) ; } packagesToUpdateAssets . add ( overlayPackage . overlayTarget ) ; storedOverlayInfos . remove ( overlayPackage . packageName ) ; } any OverlayInfo left in storedOverlayInfos is no longer installed and should be removed final int storedOverlayInfosSize = storedOverlayInfos . size ( ) ; for ( int i = _NUM ; i < storedOverlayInfosSize ; i + + ) { final OverlayInfo oi = storedOverlayInfos . valueAt ( i ) ; mSettings . remove ( oi . packageName , oi . userId ) ; removeIdmapIfPossible ( oi ) ; packagesToUpdateAssets . add ( oi . targetPackageName ) ; } remove target packages that are not installed final Iterator < String > iter = packagesToUpdateAssets . iterator ( ) ; while ( iter . hasNext ( ) ) { String targetPackageName = iter . next ( ) ; if ( mPackageManager . getPackageInfo ( targetPackageName , newUserId ) = = null ) { iter . remove ( ) ; } } return new ArrayList < > ( packagesToUpdateAssets ) ; } 
5258	void calcScore ( ) { clear current network for ( int iNode = _NUM ; iNode < m _ nNodes ; iNode + + ) { ParentSet parentSet = m _ BayesNet . getParentSet ( iNode ) ; while ( parentSet . getNrOfParents ( ) > _NUM ) { parentSet . deleteLastParent ( m _ BayesNet . m _ Instances ) ; } } insert arrows for ( int iNode = _NUM ; iNode < m _ nNodes ; iNode + + ) { ParentSet parentSet = m _ BayesNet . getParentSet ( iNode ) ; for ( int iNode _NUM = _NUM ; iNode _NUM < m _ nNodes ; iNode _NUM + + ) { if ( m _ bits [ iNode _NUM + iNode * m _ nNodes ] ) { parentSet . addParent ( iNode _NUM , m _ BayesNet . m _ Instances ) ; } } } calc score m _ fScore = _NUM . _NUM ; for ( int iNode = _NUM ; iNode < m _ nNodes ; iNode + + ) { m _ fScore + = calcNodeScore ( iNode ) ; } } 
5259	public static String extractBodyAsString ( Message message ) { if ( message = = null ) { return null ; } optimize if the body is a String type already Object body = message . getBody ( ) ; if ( body instanceof String ) { return ( String ) body ; } we need to favor using stream cache so the body can be re - read later StreamCache newBody = message . getBody ( StreamCache . class ) ; if ( newBody ! = null ) { message . setBody ( newBody ) ; } Object answer = message . getBody ( String . class ) ; if ( answer = = null ) { answer = message . getBody ( ) ; } if ( newBody ! = null ) { Reset the InputStreamCache newBody . reset ( ) ; } return answer ! = null ? answer . toString ( ) : null ; } 
5260	private void onVoiceDataIntegrityCheckDone ( Intent data ) { final String engine = mTts . getCurrentEngine ( ) ; if ( engine = = null ) { Log . e ( TAG , _STR ) ; Set mAvailableStrLocals to empty list mAvailableStrLocals = new ArrayList < String > ( ) ; } if ( evaluateDefaultLocale ( ) ) { getSampleText ( ) ; } } 
5261	public static < I , R , T extends Throwable > Optional < R > applyIfNotEmpty ( I value , ThrowingFunction < I , R , T > function ) throws T { if ( isNotEmpty ( value ) ) { return Optional . ofNullable ( function . apply ( value ) ) ; } return Optional . empty ( ) ; } 
5262	public static Bid nextBid ( long eventId , Random random , long timestamp , GeneratorConfig config ) { long auction ; Here P ( bid will be for a hot auction ) = _NUM - _NUM / hotAuctionRatio . if ( random . nextInt ( config . getHotAuctionRatio ( ) ) > _NUM ) { Choose the first auction in the batch of last HOT _ AUCTION _ RATIO auctions . auction = ( lastBase _NUM AuctionId ( eventId ) / HOT _ AUCTION _ RATIO ) * HOT _ AUCTION _ RATIO ; } else { auction = nextBase _NUM AuctionId ( eventId , random , config ) ; } auction + = GeneratorConfig . FIRST _ AUCTION _ ID ; long bidder ; Here P ( bid will be by a hot bidder ) = _NUM - _NUM / hotBiddersRatio if ( random . nextInt ( config . getHotBiddersRatio ( ) ) > _NUM ) { Choose the second person ( so hot bidders and hot sellers don ' t collide ) in the batch of last HOT _ BIDDER _ RATIO people . bidder = ( lastBase _NUM PersonId ( eventId ) / HOT _ BIDDER _ RATIO ) * HOT _ BIDDER _ RATIO + _NUM ; } else { bidder = nextBase _NUM PersonId ( eventId , random , config ) ; } bidder + = GeneratorConfig . FIRST _ PERSON _ ID ; long price = PriceGenerator . nextPrice ( random ) ; int currentSize = _NUM + _NUM + _NUM + _NUM ; String extra = nextExtra ( random , currentSize , config . getAvgBidByteSize ( ) ) ; return new Bid ( auction , bidder , price , timestamp , extra ) ; } 
5263	public int getInteger ( @ StyleableRes int index , int defValue ) { if ( mRecycled ) { throw new RuntimeException ( _STR + Integer . toHexString ( type ) ) ; } 
5264	public int getSearchAffordanceColor ( ) { return getSearchAffordanceColors ( ) . color ; } 
5265	public void inputContentsAreNotAltered _ FloatConstructor ( ) { given BufferedImage originalImage = new BufferedImage ( _NUM _NUM _NUM , _NUM _NUM _NUM , BufferedImage . TYPE _ INT _ ARGB ) ; BufferedImage copyImage = BufferedImages . copy ( originalImage ) ; ImageFilter filter = new Transparency ( _NUM . _NUM f ) ; when filter . apply ( originalImage ) ; then assertTrue ( BufferedImageComparer . isSame ( originalImage , copyImage ) ) ; } 
5266	public void writePropertyObject ( CmsDbContext dbc , CmsProject project , CmsResource resource , CmsProperty property ) throws CmsDataAccessException { CmsUUID projectId = ( ( dbc . getProjectId ( ) = = null ) | | dbc . getProjectId ( ) . isNullUUID ( ) ) ? project . getUuid ( ) : dbc . getProjectId ( ) ; TODO : check if we need autocreation for link property definition types too CmsPropertyDefinition propertyDefinition = null ; try { read the property definition propertyDefinition = readPropertyDefinition ( dbc , property . getName ( ) , projectId ) ; } catch ( CmsDbEntryNotFoundException e ) { if ( property . autoCreatePropertyDefinition ( ) ) { propertyDefinition = createPropertyDefinition ( dbc , projectId , property . getName ( ) , CmsPropertyDefinition . TYPE _ NORMAL ) ; try { readPropertyDefinition ( dbc , property . getName ( ) , CmsProject . ONLINE _ PROJECT _ ID ) ; } catch ( CmsDataAccessException e _NUM ) { createPropertyDefinition ( dbc , CmsProject . ONLINE _ PROJECT _ ID , property . getName ( ) , CmsPropertyDefinition . TYPE _ NORMAL ) ; } try { m _ driverManager . getHistoryDriver ( dbc ) . readPropertyDefinition ( dbc , property . getName ( ) ) ; } catch ( CmsDataAccessException e _NUM ) { m _ driverManager . getHistoryDriver ( dbc ) . createPropertyDefinition ( dbc , property . getName ( ) , CmsPropertyDefinition . TYPE _ NORMAL ) ; } OpenCms . fireCmsEvent ( new CmsEvent ( I _ CmsEventListener . EVENT _ PROPERTY _ DEFINITION _ CREATED , Collections . < String , Object > singletonMap ( _STR ) List < I _ CmsDAOProperties > res = q . getResultList ( ) ; for ( I _ CmsDAOProperties pr : res ) { m _ sqlManager . remove ( dbc , pr ) ; } } } } catch ( PersistenceException e ) { throw new CmsDataAccessException ( Messages . get ( ) . container ( Messages . ERR _ JPA _ PERSITENCE , e ) , e ) ; } } 
5267	public static String extractText ( InputStream in , String encoding ) throws ParserException , UnsupportedEncodingException { Parser parser = new Parser ( ) ; Lexer lexer = new Lexer ( ) ; Page page = new Page ( in , encoding ) ; lexer . setPage ( page ) ; parser . setLexer ( lexer ) ; StringBean stringBean = new StringBean ( ) ; parser . visitAllNodesWith ( stringBean ) ; String result = stringBean . getStrings ( ) ; return result = = null ? _STR : result ; } 
5268	public PreparedStatement prepareAutoCloseStatement ( String sql , int resultSetType , int resultSetConcurrency , int resultSetHoldability ) throws SQLException { final Connection conn = getConnection ( ) ; final PreparedStatement pstmt = conn . prepareStatement ( sql , resultSetType , resultSetConcurrency , resultSetHoldability ) ; if ( s _ stmtLogger . isTraceEnabled ( ) ) { s _ stmtLogger . trace ( _STR + sql ) ; } closePreviousStatement ( ) ; _ stmt = pstmt ; return pstmt ; } 
5269	 @ NullableItemHolderInfo popFromPreLayout ( ViewHolder vh ) { return popFromLayoutStep ( vh , FLAG _ PRE ) ; } 
5270	private void sendClick ( ) { if ( mLastMotionEvent = = null | | mNext = = null ) { return ; } final int pointerIndex = mLastMotionEvent . getActionIndex ( ) ; if ( mTempPointerProperties = = null ) { mTempPointerProperties = new PointerProperties [ _NUM ] ; mTempPointerProperties [ _NUM ] = new PointerProperties ( ) ; } mLastMotionEvent . getPointerProperties ( pointerIndex , mTempPointerProperties [ _NUM ] ) ; if ( mTempPointerCoords = = null ) { mTempPointerCoords = new PointerCoords [ _NUM ] ; mTempPointerCoords [ _NUM ] = new PointerCoords ( ) ; } mLastMotionEvent . getPointerCoords ( pointerIndex , mTempPointerCoords [ _NUM ] ) ; final long now = SystemClock . uptimeMillis ( ) ; MotionEvent downEvent = MotionEvent . obtain ( now , now , MotionEvent . ACTION _ DOWN , _NUM , mTempPointerProperties , mTempPointerCoords , mMetaState , MotionEvent . BUTTON _ PRIMARY , _NUM . _NUM f , _NUM . _NUM f , mLastMotionEvent . getDeviceId ( ) , _NUM , mLastMotionEvent . getSource ( ) , mLastMotionEvent . getFlags ( ) ) ; The only real difference between these two events is the action flag . MotionEvent upEvent = MotionEvent . obtain ( downEvent ) ; upEvent . setAction ( MotionEvent . ACTION _ UP ) ; mNext . onMotionEvent ( downEvent , downEvent , mEventPolicyFlags ) ; downEvent . recycle ( ) ; mNext . onMotionEvent ( upEvent , upEvent , mEventPolicyFlags ) ; upEvent . recycle ( ) ; } 
5271	private IonWriter build ( PrivateFastAppendable appender ) { IonCatalog catalog = getCatalog ( ) ; SymbolTable [ ] imports = getImports ( ) ; TODO We shouldn ' t need a system here IonSystem system = IonSystemBuilder . standard ( ) . withCatalog ( catalog ) . build ( ) ; SymbolTable defaultSystemSymtab = system . getSystemSymbolTable ( ) ; IonWriterSystemText systemWriter = new IonWriterSystemText ( defaultSystemSymtab , this , appender ) ; SymbolTable initialSymtab = initialSymtab ( system , defaultSystemSymtab , imports ) ; return new IonWriterUser ( catalog , system , systemWriter , initialSymtab ) ; } 
5272	public static EndpointReferenceType parseEndpointReference ( Element ref ) throws JAXBException { Element child = DOMUtils . getFirstElement ( ref ) ; String tns = null ; while ( child ! = null & & tns = = null ) { if ( isSupported ( child . getNamespaceURI ( ) ) ) { tns = child . getNamespaceURI ( ) ; } child = DOMUtils . getNextElement ( child ) ; } if ( tns = = null ) { return null ; } JAXBContext ctx = getExposedJAXBContext ( tns ) ; Unmarshaller um = ctx . createUnmarshaller ( ) ; um . setEventHandler ( null ) ; try { JAXBElement < ? > o = um . unmarshal ( ref , getExposedReferenceType ( tns ) ) ; if ( o ! = null ) { return convertToNative ( o . getValue ( ) ) ; } return convertToNative ( null ) ; } finally { JAXBUtils . closeUnmarshaller ( um ) ; } } 
5273	protected boolean canUpdateModifiedParents ( ModeledAuthenticatedUser user , String identifier , ModelType model ) throws GuacamoleException { If user is an administrator , no need to check if ( user . getUser ( ) . isAdministrator ( ) ) return true ; Verify that we have permission to modify any modified parents Collection < String > modifiedParents = getModifiedParents ( user , identifier , model ) ; if ( ! modifiedParents . isEmpty ( ) ) { ObjectPermissionSet permissionSet = getParentPermissionSet ( user ) ; Collection < String > updateableParents = permissionSet . getAccessibleObjects ( Collections . singleton ( ObjectPermission . Type . UPDATE ) , modifiedParents ) ; return updateableParents . size ( ) = = modifiedParents . size ( ) ; } return true ; } 
5274	public List < String > getUnqualifiedBagValueList ( String bagName ) { ArrayProperty array = ( ArrayProperty ) getAbstractProperty ( bagName ) ; if ( array ! = null ) { return array . getElementsAsString ( ) ; } else { return null ; } } 
5275	public boolean hasValueOfTrue ( ArgDecl argDecl ) { String x = getValue ( argDecl ) ; if ( x = = null ) return false ; if ( x . equalsIgnoreCase ( _STR ) ) return true ; return false ; } 
5276	public void addEnchantment ( Enchantment ench , int level ) { Validate . notNull ( ench , _STR ) ; } addUnsafeEnchantment ( ench , level ) ; } 
5277	Path getTableInfoPath ( TableName tableName ) throws IOException { Path tableSnapShotPath = getTableSnapshotPath ( backupRootPath , tableName , backupId ) ; Path tableInfoPath = null ; can ' t build the path directly as the timestamp values are different FileStatus [ ] snapshots = fs . listStatus ( tableSnapShotPath ) ; for ( FileStatus snapshot : snapshots ) { tableInfoPath = snapshot . getPath ( ) ; SnapshotManifest . DATA _ MANIFEST _ NAME = _STR ) ) { break ; } } return tableInfoPath ; } 
5278	public static XmlInt parse ( java . io . InputStream is , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( XmlInt ) XmlBeans . getContextTypeLoader ( ) . parse ( is , type , options ) ; } 
5279	public void setTasks ( Context context , List < Task > tasks , boolean notifyStackChanges ) { Compute a has set for each of the tasks ArrayMap < Task . TaskKey , Task > currentTasksMap = createTaskKeyMapFromList ( mRawTaskList ) ; ArrayMap < Task . TaskKey , Task > newTasksMap = createTaskKeyMapFromList ( tasks ) ; ArrayList < Task > addedTasks = new ArrayList < > ( ) ; ArrayList < Task > removedTasks = new ArrayList < > ( ) ; ArrayList < Task > allTasks = new ArrayList < > ( ) ; Disable notifications if there are no callbacks if ( mCb = = null ) { notifyStackChanges = false ; } Remove any tasks that no longer exist int taskCount = mRawTaskList . size ( ) ; for ( int i = taskCount - _NUM ; i > = _NUM ; i - - ) { Task task = mRawTaskList . get ( i ) ; if ( ! newTasksMap . containsKey ( task . key ) ) { if ( notifyStackChanges ) { removedTasks . add ( task ) ; } } task . setGroup ( null ) ; } Add any new tasks taskCount = tasks . size ( ) ; for ( int i = _NUM ; i < taskCount ; i + + ) { Task newTask = tasks . get ( i ) ; Task currentTask = currentTasksMap . get ( newTask . key ) ; if ( currentTask = = null & & notifyStackChanges ) { addedTasks . add ( newTask ) ; } else if ( currentTask ! = null ) { The current task has bound callbacks , so just copy the data from the new task state and add it back into the list currentTask . copyFrom ( newTask ) ; newTask = currentTask ; } allTasks . add ( newTask ) ; } Sort all the tasks to ensure they are ordered correctly for ( int i = allTasks . size ( ) - _NUM ; i > = _NUM ; i - - ) { allTasks . get ( i ) . temporarySortIndexInStack = i ; } Collections . sort ( allTasks , FREEFORM _ COMPARATOR ) ; mStackTaskList . set ( allTasks ) ; mRawTaskList = allTasks ; Update the affiliated groupings createAffiliatedGroupings ( context ) ; Only callback for the removed tasks after the stack has updated int removedTaskCount = removedTasks . size ( ) ; Task newFrontMostTask = getStackFrontMostTask ( false ) ; for ( int i = _NUM ; i < removedTaskCount ; i + + ) { mCb . onStackTaskRemoved ( this , removedTasks . get ( i ) , newFrontMostTask , AnimationProps . IMMEDIATE , false , true ) ; } Only callback for the newly added tasks after this stack has been updated int addedTaskCount = addedTasks . size ( ) ; for ( int i = _NUM ; i < addedTaskCount ; i + + ) { mCb . onStackTaskAdded ( this , addedTasks . get ( i ) ) ; } Notify that the task stack has been updated if ( notifyStackChanges ) { mCb . onStackTasksUpdated ( this ) ; } } 
5280	public Double get ( Object key ) { int k ; if ( key ! = null ) { if ( key instanceof Integer ) { k = unwrapKey ( key ) ; } else { return null ; } } else { k = _ map . getNoEntryKey ( ) ; } double v = _ map . get ( k ) ; check here . if ( v = = _ map . getNoEntryValue ( ) ) { return null ; } else { return wrapValue ( v ) ; } } 
5281	public void stopReplicationService ( ) { join ( ) ; } 
5282	 @ VisibleForTestingNamespaceInfo retrieveNamespaceInfo ( ) throws IOException { NamespaceInfo nsInfo = null ; while ( shouldRun ( ) ) { try { nsInfo = bpNamenode . versionRequest ( ) ; LOG . debug ( this + _STR ) ; } return nsInfo ; } 
5283	private void addNewAlgorithm ( Classifier newScheme ) { if ( ! m _ Editing ) m _ AlgorithmListModel . addElement ( newScheme ) ; else m _ AlgorithmListModel . setElementAt ( newScheme , m _ List . getSelectedIndex ( ) ) ; updateExperiment ( ) ; m _ Editing = false ; } 
5284	public void search ( BayesNet bayesNet , Instances instances ) throws Exception { int [ ] nOrder = new int [ instances . numAttributes ( ) ] ; nOrder [ _NUM ] = instances . classIndex ( ) ; int nAttribute = _NUM ; for ( int iOrder = _NUM ; iOrder < instances . numAttributes ( ) ; iOrder + + ) { if ( nAttribute = = instances . classIndex ( ) ) { nAttribute + + ; } nOrder [ iOrder ] = nAttribute + + ; } if ( m _ bRandomOrder ) { generate random ordering ( if required ) Random random = new Random ( ) ; int iClass ; if ( getInitAsNaiveBayes ( ) ) { iClass = _NUM ; } else { iClass = - _NUM ; } for ( int iOrder = _NUM ; iOrder < instances . numAttributes ( ) ; iOrder + + ) { int iOrder _NUM = Math . abs ( random . nextInt ( ) ) % instances . numAttributes ( ) ; if ( iOrder ! = iClass & & iOrder _NUM ! = iClass ) { int nTmp = nOrder [ iOrder ] ; nOrder [ iOrder ] = nOrder [ iOrder _NUM ] ; nOrder [ iOrder _NUM ] = nTmp ; } } } determine base scores double [ ] fBaseScores = new double [ instances . numAttributes ( ) ] ; for ( int iOrder = _NUM ; iOrder < instances . numAttributes ( ) ; iOrder + + ) { int iAttribute = nOrder [ iOrder ] ; fBaseScores [ iAttribute ] = calcNodeScore ( iAttribute ) ; } K _NUM algorithm : greedy search restricted by ordering for ( int iOrder = _NUM ; iOrder < instances . numAttributes ( ) ; iOrder + + ) { int iAttribute = nOrder [ iOrder ] ; double fBestScore = fBaseScores [ iAttribute ] ; boolean bProgress = ( bayesNet . getParentSet ( iAttribute ) . getNrOfParents ( ) < getMaxNrOfParents ( ) ) ; while ( bProgress ) { int nBestAttribute = - _NUM ; for ( int iOrder _NUM = _NUM ; iOrder _NUM < iOrder ; iOrder _NUM + + ) { int iAttribute _NUM = nOrder [ iOrder _NUM ] ; double fScore = calcScoreWithExtraParent ( iAttribute , iAttribute _NUM ) ; if ( fScore > fBestScore ) { fBestScore = fScore ; nBestAttribute = iAttribute _NUM ; } } if ( nBestAttribute ! = - _NUM ) { bayesNet . getParentSet ( iAttribute ) . addParent ( nBestAttribute , instances ) ; fBaseScores [ iAttribute ] = fBestScore ; bProgress = ( bayesNet . getParentSet ( iAttribute ) . getNrOfParents ( ) < getMaxNrOfParents ( ) ) ; } else { bProgress = false ; } } } } 
5285	public int getItemViewType ( int position ) { Pair < AdapterDataObserver , Adapter > p = findAdapterByPosition ( position ) ; if ( p = = null ) { return RecyclerView . INVALID _ TYPE ; } int subItemType = p . second . getItemViewType ( position - p . first . mStartPosition ) ; if ( subItemType < _NUM ) { negative integer , invalid , just return return subItemType ; } if ( mHasConsistItemType ) { mItemTypeAry . put ( subItemType , p . second ) ; return subItemType ; } int index = p . first . mIndex ; return ( int ) Cantor . getCantor ( subItemType , index ) ; } 
5286	public void writeOut ( OutputStream out ) throws IOException { Header out . write ( _ header ) ; The sizes and zoom ratios writeLittleEndian ( ( int ) slideSizeX , out ) ; writeLittleEndian ( ( int ) slideSizeY , out ) ; writeLittleEndian ( ( int ) notesSizeX , out ) ; writeLittleEndian ( ( int ) notesSizeY , out ) ; writeLittleEndian ( ( int ) serverZoomFrom , out ) ; writeLittleEndian ( ( int ) serverZoomTo , out ) ; The master persists writeLittleEndian ( ( int ) notesMasterPersist , out ) ; writeLittleEndian ( ( int ) handoutMasterPersist , out ) ; The ID of the first slide writeLittleEndian ( ( short ) firstSlideNum , out ) ; The slide size type writeLittleEndian ( ( short ) slideSizeType , out ) ; The booleans as bytes out . write ( saveWithFonts ) ; out . write ( omitTitlePlace ) ; out . write ( rightToLeft ) ; out . write ( showComments ) ; Reserved data out . write ( reserved ) ; } 
5287	public Builder clearIdentity ( ) { if ( identityBuilder _ = = null ) { identity _ = com . alibaba . otter . node . etl . model . protobuf . BatchProto . Identity . getDefaultInstance ( ) ; onChanged ( ) ; } else { identityBuilder _ . clear ( ) ; } bitField _NUM _ = ( bitField _NUM _ & ~ _NUM x _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM ) ; return this ; } 
5288	protected void useAsReference ( MapEntity entity ) { currMatchLevel = getMatchLevel ( entity ) ; } 
5289	public void test _ NotifiedDubbo _NUM ( ) { URL errorPathUrl = URL . valueOf ( _STR ) ; invokers = registryDirectory . list ( invocation ) ; Assert . assertEquals ( _NUM , invokers . size ( ) ) ; Assert . assertEquals ( DemoService . class . getName ( ) , invokers . get ( _NUM ) . getUrl ( ) . getPath ( ) ) ; } 
5290	public String getDeviceOwner ( ) { throwIfParentInstance ( _STR ) ; final ComponentName name = getDeviceOwnerComponentOnCallingUser ( ) ; return name ! = null ? name . getPackageName ( ) : null ; } 
5291	static void zipDirectory ( File sourceDirectory , File zipFile ) throws IOException { checkNotNull ( sourceDirectory ) ; checkNotNull ( zipFile ) ; checkArgument ( sourceDirectory . isDirectory ( ) , _STR , zipFile . getAbsolutePath ( ) ) ; Closer closer = Closer . create ( ) ; try { OutputStream outputStream = closer . register ( new BufferedOutputStream ( new FileOutputStream ( zipFile ) ) ) ; zipDirectory ( sourceDirectory , outputStream ) ; } catch ( Throwable t ) { throw closer . rethrow ( t ) ; } finally { closer . close ( ) ; } } 
5292	public static String toHex ( int value ) { StringBuilder sb = new StringBuilder ( _NUM ) ; writeHex ( sb , value & _NUM xFFFFFFFFL , _NUM , _STR ) ; return sb . toString ( ) ; } 
5293	public int substract ( ByteChunk src ) throws IOException { if ( ( end - start ) = = _NUM ) { if ( in = = null ) { return - _NUM ; } int n = in . realReadBytes ( buff , _NUM , buff . length ) ; if ( n < _NUM ) { return - _NUM ; } } int len = getLength ( ) ; src . append ( buff , start , len ) ; start = end ; return len ; } 
5294	public List < AggregateCall > getAggregateCalls ( Window windowRel ) { final List < String > fieldNames = Util . skip ( windowRel . getRowType ( ) . getFieldNames ( ) , windowRel . getInput ( ) . getRowType ( ) . getFieldCount ( ) ) ; return new AbstractList < AggregateCall > ( ) { public int size ( ) { return aggCalls . size ( ) ; } public AggregateCall get ( int index ) { final RexWinAggCall aggCall = aggCalls . get ( index ) ; final SqlAggFunction op = ( SqlAggFunction ) aggCall . getOperator ( ) ; return AggregateCall . create ( op , aggCall . distinct , false , getProjectOrdinals ( aggCall . getOperands ( ) ) , - _NUM , aggCall . getType ( ) , fieldNames . get ( aggCall . ordinal ) ) ; } } ; } 
5295	public boolean isEOF ( ) { return readChannel . getCurrentPosition ( ) = = channel . size ( ) & & buffer . remaining ( ) = = _NUM ; } 
5296	protected void updateContextRequestTime ( ) { CmsContextInfo context = ( CmsContextInfo ) m _ context . clone ( ) ; context . setRequestTime ( System . currentTimeMillis ( ) ) ; context . freeze ( ) ; m _ context = context ; } 
5297	public void startAnimationToAllApps ( final Workspace . State fromWorkspaceState , final boolean animated , final boolean startSearchAfterTransition ) { final AllAppsContainerView toView = mLauncher . getAppsView ( ) ; final View buttonView = mLauncher . getStartViewForAllAppsRevealAnimation ( ) ; PrivateTransitionCallbacks cb = new PrivateTransitionCallbacks ( _NUM f ) { @ Override public float getMaterialRevealViewStartFinalRadius ( ) { int allAppsButtonSize = mLauncher . getDeviceProfile ( ) . allAppsButtonVisualSize ; return allAppsButtonSize / _NUM ; } @ Override public AnimatorListenerAdapter getMaterialRevealViewAnimatorListener ( final View revealView , final View allAppsButtonView ) { return new AnimatorListenerAdapter ( ) { public void onAnimationStart ( Animator animation ) { allAppsButtonView . setVisibility ( View . INVISIBLE ) ; } public void onAnimationEnd ( Animator animation ) { allAppsButtonView . setVisibility ( View . VISIBLE ) ; } } ; } @ Override void onTransitionComplete ( ) { mLauncher . getUserEventDispatcher ( ) . resetElapsedContainerMillis ( ) ; if ( startSearchAfterTransition ) { toView . startAppsSearch ( ) ; } } } ; int animType = CIRCULAR _ REVEAL ; if ( FeatureFlags . LAUNCHER _NUM _ ALL _ APPS _ PULL _ UP ) { animType = PULLUP ; } Only animate the search bar if animating from spring loaded mode back to all apps startAnimationToOverlay ( fromWorkspaceState , Workspace . State . NORMAL _ HIDDEN , buttonView , toView , animated , animType , cb ) ; } 
5298	public void softCloneNonPositionParameters ( Rectangle rect ) { throwReadOnlyError ( ) ; } 
5299	public static int getDnsNegativeCachePolicy ( ) { try { return InetAddressCacheUtil . getDnsNegativeCachePolicy ( ) ; } catch ( Exception e ) { throw new DnsCacheManipulatorException ( _STR + e . toString ( ) , e ) ; } } 
5300	public Map < String , CmsJspContentAccessValueWrapper > getValue ( ) { return getLocaleValue ( ) . get ( m _ locale ) ; } 
5301	 @ ServiceThreadOnlyboolean dispatchMessage ( HdmiCecMessage message ) { assertRunOnServiceThread ( ) ; int dest = message . getDestination ( ) ; if ( dest ! = mAddress & & dest ! = Constants . ADDR _ BROADCAST ) { return false ; } Cache incoming message . Note that it caches only white - listed one . mCecMessageCache . cacheMessage ( message ) ; return onMessage ( message ) ; } 
5302	private boolean shouldEntryBeApplied ( UUID streamId , SMREntry entry , boolean isCheckpointEntry ) { passed by the client + derived checkpoint streams ) . if ( whiteList & & ! streamsToLoad . contains ( streamId ) ) { return false ; } We don ' t want to create a Map for it . if ( streamId = = runtime . getObjectsView ( ) . TRANSACTION _ STREAM _ ID | | streamsToIgnore . contains ( streamId ) ) { return false ; } If the entry was already processed with the previous checkpoint . if ( ! isCheckpointEntry & & entryAlreadyContainedInCheckpoint ( streamId , entry ) ) { return false ; } return true ; } 
5303	public static Bitmap decodeSampledBitmapFromDescriptor ( FileDescriptor fileDescriptor , int reqWidth , int reqHeight ) { First decode with inJustDecodeBounds = true to check dimensions final BitmapFactory . Options options = new BitmapFactory . Options ( ) ; options . inJustDecodeBounds = true ; BitmapFactory . decodeFileDescriptor ( fileDescriptor , null , options ) ; Calculate inSampleSize options . inSampleSize = calculateInSampleSize ( options , reqWidth , reqHeight ) ; Decode bitmap with inSampleSize set options . inJustDecodeBounds = false ; return BitmapFactory . decodeFileDescriptor ( fileDescriptor , null , options ) ; } 
5304	public void setError ( CharSequence error ) { enforceNotSealed ( ) ; mError = ( error = = null ) ? null : error . subSequence ( _NUM , error . length ( ) ) ; } 
5305	public void testWritePDF ( ) { WritePDFTester writePDFTester = new WritePDFTester ( ) ; writePDFTester . runTests ( ) ; test a corner case as described in PDFBOX - _NUM _NUM _NUM _NUM writePDFTester . runTest ( _NUM . _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM f ) ; } 
5306	public void setFormat ( Format format ) { this . format = format . toString ( ) ; } 
5307	public static void closeQuietly ( Closeable closeable ) { try { if ( closeable ! = null ) { closeable . close ( ) ; } } catch ( IOException ioe ) { LOG . debug ( _STR , ioe ) ; ignore } } 
5308	public Response getExistingWadl ( Message m , UriInfo ui , MediaType mt ) { Endpoint ep = m . getExchange ( ) . getEndpoint ( ) ; if ( ep ! = null ) { String loc = ( String ) ep . get ( JAXRSUtils . DOC _ LOCATION ) ; if ( loc ! = null ) { try { InputStream is = ResourceUtils . getResourceStream ( loc , ( Bus ) ep . get ( Bus . class . getName ( ) ) ) ; if ( is ! = null ) { Object contextProp = m . getContextualProperty ( CONVERT _ WADL _ RESOURCES _ TO _ DOM ) ; boolean doConvertResourcesToDOM = contextProp = = null ? convertResourcesToDOM : PropertyUtils . isTrue ( contextProp ) ; if ( ! doConvertResourcesToDOM | | isJson ( mt ) ) { return Response . ok ( is , mt ) . build ( ) ; } Document wadlDoc = StaxUtils . read ( is ) ; Element appEl = wadlDoc . getDocumentElement ( ) ; List < Element > grammarEls = DOMUtils . getChildrenWithName ( appEl , WadlGenerator . WADL _ NS , _STR , m , ui ) ; return finalizeExistingWadlResponse ( wadlDoc , m , ui , mt ) ; } } } catch ( Exception ex ) { throw ExceptionUtils . toInternalServerErrorException ( ex , null ) ; } } } return null ; } 
5309	private void waitForJournalFlush ( ) throws UnavailableException { if ( mFlushCounter = = INVALID _ FLUSH _ COUNTER ) { Check this before the precondition . return ; } RetryPolicy retry = new TimeoutRetry ( FLUSH _ RETRY _ TIMEOUT _ MS , FLUSH _ RETRY _ INTERVAL _ MS ) ; while ( retry . attempt ( ) ) { try { mAsyncJournalWriter . flush ( mFlushCounter ) ; return ; } catch ( IOException e ) { LOG . warn ( _STR ) ; } System . exit ( - _NUM ) ; } 
5310	public void should _ wait _ on _ connection _ if _ not _ convicted _ and _ no _ connections _ available ( ) throws Exception { int readTimeout = _NUM _NUM _NUM _NUM ; int reconnectInterval = _NUM _NUM _NUM _NUM ; Cluster cluster = this . createClusterBuilder ( ) . withSocketOptions ( new SocketOptions ( ) . setConnectTimeoutMillis ( readTimeout ) . setReadTimeoutMillis ( reconnectInterval ) ) . withReconnectionPolicy ( new ConstantReconnectionPolicy ( _NUM _NUM _NUM _NUM ) ) . build ( ) ; try { Init cluster so control connection is created . cluster . init ( ) ; assertThat ( cluster ) . hasOpenControlConnection ( ) ; Connection . Factory factory = spy ( cluster . manager . connectionFactory ) ; cluster . manager . connectionFactory = factory ; Disable listener so all connections on pool fail . currentClient . disableListener ( ) ; HostConnectionPool pool = createPool ( cluster , _NUM , _NUM ) ; Pool should be empty . assertThat ( pool . connections ) . hasSize ( _NUM ) ; Control connection should stay up with the host . assertThat ( cluster ) . host ( _NUM ) . hasState ( Host . State . UP ) ; assertThat ( cluster ) . hasOpenControlConnection ( ) ; currentClient . enableListener ( ) ; Wait for reconnectInterval so ConvictionPolicy allows connection to be created . Uninterruptibles . sleepUninterruptibly ( reconnectInterval , TimeUnit . MILLISECONDS ) ; reset ( factory ) ; MockRequest request = MockRequest . send ( pool , _NUM ) ; Should create up to core connections . verify ( factory , timeout ( readTimeout * _NUM ) . times ( _NUM ) ) . open ( any ( HostConnectionPool . class ) ) ; assertPoolSize ( pool , _NUM ) ; request . simulateSuccessResponse ( ) ; } finally { cluster . close ( ) ; } } 
5311	public void testUnionAllOrderBy ( ) { hr ( ) . query ( _STR ) ; } 
5312	private void calcHashCode ( ) { hashCode = _NUM ; for ( EncodedValue encodedValue : values ) { hashCode = _NUM _NUM * hashCode + encodedValue . hashCode ( ) ; } } 
5313	private void handleSingleOutputJobs ( ArrayList < Lop > execNodes , ArrayList < ArrayList < Lop > > jobNodes , ArrayList < Lop > finishedNodes ) { ArrayList < Lop > nodesWithUnfinishedOutputs = new ArrayList < > ( ) ; int [ ] jobIndices = { JobType . MMCJ . getId ( ) } ; Lop . Type [ ] lopTypes = { Lop . Type . MMCJ } ; for ( int jobi = _NUM ; jobi < jobIndices . length ; jobi + + ) { int jindex = jobIndices [ jobi ] ; if ( ! jobNodes . get ( jindex ) . isEmpty ( ) ) { ArrayList < Lop > vec = jobNodes . get ( jindex ) ; first find all nodes with more than one parent that is not finished . for ( int i = _NUM ; i < vec . size ( ) ; i + + ) { Lop node = vec . get ( i ) ; if ( node . getExecLocation ( ) = = ExecLocation . MapOrReduce | | node . getExecLocation ( ) = = ExecLocation . Map ) { Lop MRparent = getParentNode ( node , execNodes , ExecLocation . MapAndReduce ) ; if ( MRparent ! = null & & MRparent . getType ( ) = = lopTypes [ jobi ] ) { int numParents = node . getOutputs ( ) . size ( ) ; if ( numParents > _NUM ) { for ( int j = _NUM ; j < numParents ; j + + ) { if ( ! finishedNodes . contains ( node . getOutputs ( ) . get ( j ) ) ) nodesWithUnfinishedOutputs . add ( node ) ; } } } } } need to redo all nodes in nodesWithOutput as well as their children for ( Lop node : vec ) { if ( node . getExecLocation ( ) = = ExecLocation . MapOrReduce | | node . getExecLocation ( ) = = ExecLocation . Map ) { if ( nodesWithUnfinishedOutputs . contains ( node ) ) finishedNodes . remove ( node ) ; if ( hasParentNode ( node , nodesWithUnfinishedOutputs ) ) finishedNodes . remove ( node ) ; } } } } } 
5314	public void addExceptions ( List exceptionList ) { for ( Iterator iter = exceptionList . iterator ( ) ; iter . hasNext ( ) ; ) { addException ( ( Date ) iter . next ( ) ) ; } } 
5315	public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( _STR ) ; return sb . toString ( ) ; } 
5316	public OpenSessionRequest build ( ) { validate ( ) ; return new OpenSessionRequest ( nodeId , serviceName , serviceType , readConsistency , minTimeout , maxTimeout ) ; } 
5317	public int addControl ( String name , String progId ) { ExControl ctrl = new ExControl ( ) ; ctrl . setProgId ( progId ) ; ctrl . setMenuName ( name ) ; ctrl . setClipboardName ( name ) ; ExOleObjAtom oleObj = ctrl . getExOleObjAtom ( ) ; oleObj . setDrawAspect ( ExOleObjAtom . DRAW _ ASPECT _ VISIBLE ) ; oleObj . setType ( ExOleObjAtom . TYPE _ CONTROL ) ; oleObj . setSubType ( ExOleObjAtom . SUBTYPE _ DEFAULT ) ; int objectId = addToObjListAtom ( ctrl ) ; oleObj . setObjID ( objectId ) ; return objectId ; } 
5318	public JSONObject setStillSize ( String ratio , String size ) throws IOException { String service = _STR + responseJson ) ; return new JSONObject ( responseJson ) ; } catch ( JSONException e ) { throw new IOException ( e ) ; } } 
5319	public static void copyHeaders ( Message source , Message target , HeaderFilterStrategy strategy , boolean override ) { if ( ! source . hasHeaders ( ) ) { return ; } for ( Map . Entry < String , Object > entry : source . getHeaders ( ) . entrySet ( ) ) { String key = entry . getKey ( ) ; Object value = entry . getValue ( ) ; if ( target . getHeader ( key ) = = null | | override ) { if ( strategy = = null ) { target . setHeader ( key , value ) ; } else if ( ! strategy . applyFilterToExternalHeaders ( key , value , target . getExchange ( ) ) ) { Just make sure we don ' t copy the protocol headers to target target . setHeader ( key , value ) ; } } } } 
5320	public void connect ( CometdProducerConsumer prodcon ) throws Exception { Server server = null ; Make sure that there is a connector for the requested endpoint . CometdEndpoint endpoint = prodcon . getEndpoint ( ) ; String connectorKey = endpoint . getProtocol ( ) + _STR ) ; } server . addConnector ( connector ) ; CometDServlet servlet = createServletForConnector ( server , connector , endpoint ) ; connectorRef = new ConnectorRef ( connector , servlet , server ) ; server . start ( ) ; connectors . put ( connectorKey , connectorRef ) ; } else { connectorRef . increment ( ) ; } BayeuxServerImpl bayeux = connectorRef . servlet . getBayeux ( ) ; if ( securityPolicy ! = null ) { bayeux . setSecurityPolicy ( securityPolicy ) ; } if ( extensions ! = null ) { for ( BayeuxServer . Extension extension : extensions ) { bayeux . addExtension ( extension ) ; } } if ( serverListeners ! = null ) { for ( BayeuxServer . BayeuxServerListener serverListener : serverListeners ) { bayeux . addListener ( serverListener ) ; } } prodcon . setBayeux ( bayeux ) ; } } 
5321	public void testInFilterOnKey ( ) throws Exception { String query = _STR ; String url = getUrl ( ) ; Properties props = PropertiesUtil . deepCopy ( TEST _ PROPERTIES ) ; Connection conn = DriverManager . getConnection ( url , props ) ; try { PreparedStatement statement = conn . prepareStatement ( query ) ; statement . setString ( _NUM , tenantId ) ; statement . setString ( _NUM , tenantId ) ; ResultSet rs = statement . executeQuery ( ) ; assertTrue ( rs . next ( ) ) ; assertEquals ( _NUM , rs . getInt ( _NUM ) ) ; assertFalse ( rs . next ( ) ) ; } finally { conn . close ( ) ; } } 
5322	public Builder clearClientInfos ( ) { if ( clientInfosBuilder _ = = null ) { clientInfos _ = org . apache . drill . exec . proto . UserProtos . RpcEndpointInfos . getDefaultInstance ( ) ; onChanged ( ) ; } else { clientInfosBuilder _ . clear ( ) ; } bitField _NUM _ = ( bitField _NUM _ & ~ _NUM x _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM ) ; return this ; } 
5323	public ASN _NUM Encodable getExtensionParsedValue ( ASN _NUM ObjectIdentifier oid ) { Extension ext = this . getExtension ( oid ) ; if ( ext ! = null ) { return ext . getParsedValue ( ) ; } return null ; } 
5324	public synchronized void removeAddressFromTunnelInterface ( int tunnelResourceId , LinkAddress localAddr ) { enforceNetworkStackPermission ( ) ; UserRecord userRecord = mUserResourceTracker . getUserRecord ( Binder . getCallingUid ( ) ) ; Get tunnelInterface record ; if no such interface is found , will throw IllegalArgumentException TunnelInterfaceRecord tunnelInterfaceInfo = userRecord . mTunnelInterfaceRecords . getResourceOrThrow ( tunnelResourceId ) ; try { We can assume general validity of the IP address , since we get them as a LinkAddress , which does some validation . mSrvConfig . getNetdInstance ( ) . interfaceDelAddress ( tunnelInterfaceInfo . mInterfaceName , localAddr . getAddress ( ) . getHostAddress ( ) , localAddr . getPrefixLength ( ) ) ; } catch ( RemoteException e ) { throw e . rethrowFromSystemServer ( ) ; } catch ( ServiceSpecificException e ) { If we get here , one of the arguments provided was invalid . Wrap the SSE , and throw . throw new IllegalArgumentException ( e ) ; } } 
5325	public void box ( final Type type ) { if ( type . getSort ( ) = = Type . OBJECT | | type . getSort ( ) = = Type . ARRAY ) { return ; } if ( type = = Type . VOID _ TYPE ) { push ( ( String ) null ) ; } else { Type boxed = getBoxedType ( type ) ; newInstance ( boxed ) ; if ( type . getSize ( ) = = _NUM ) { Pp - > Ppo - > oPpo - > ooPpo - > ooPp - > o dupX _NUM ( ) ; dupX _NUM ( ) ; pop ( ) ; } else { p - > po - > opo - > oop - > o dupX _NUM ( ) ; swap ( ) ; } invokeConstructor ( boxed , new Method ( _STR , Type . VOID _ TYPE , new Type [ ] { type } ) ) ; } } 
5326	public void removeInstanceData ( String key ) { ViewInstanceDataEntity entity = getInstanceData ( key ) ; if ( entity ! = null ) { data . remove ( entity ) ; } } 
5327	public double leaveOneOutCV ( BayesNet bayesNet ) throws Exception { m _ BayesNet = bayesNet ; double fAccuracy = _NUM . _NUM ; double fWeight = _NUM . _NUM ; Instances instances = bayesNet . m _ Instances ; bayesNet . estimateCPTs ( ) ; for ( int iInstance = _NUM ; iInstance < instances . numInstances ( ) ; iInstance + + ) { Instance instance = instances . instance ( iInstance ) ; instance . setWeight ( - instance . weight ( ) ) ; bayesNet . updateClassifier ( instance ) ; fAccuracy + = accuracyIncrease ( instance ) ; fWeight + = instance . weight ( ) ; instance . setWeight ( - instance . weight ( ) ) ; bayesNet . updateClassifier ( instance ) ; } return fAccuracy / fWeight ; } 
5328	public PdfIndirectObject addToBody ( PdfObject object , PdfIndirectReference ref , boolean inObjStm ) throws IOException { PdfIndirectObject iobj = body . add ( object , ref , inObjStm ) ; return iobj ; } 
5329	public static AccessibilityRecord obtain ( AccessibilityRecord record ) { AccessibilityRecord clone = AccessibilityRecord . obtain ( ) ; clone . init ( record ) ; return clone ; } 
5330	public void cleanup ( Exception e ) { LOG . info ( _STR , e ) ; try { taskManager . cancelTasks ( ) ; } catch ( InterruptedException e _NUM ) { Thread . currentThread ( ) . interrupt ( ) ; } } 
5331	public int prevBoundary ( int offset ) { checkOffsetIsValid ( offset ) ; return mIterator . preceding ( offset ) ; } 
5332	private String readRawTypeParameters ( ) { idx = skipSpaces ( str , idx ) ; if ( isEOS ( ) | | str . charAt ( idx ) = = ' > ' | | str . charAt ( idx ) = = ' , ' ) return _STR ' ) { inQuotes = false ; } } we ' ve stopped at the last closing ' ) ' so move past that + + idx ; return str . substring ( i , idx ) ; } 
5333	public void run ( ) { stoppedLatch = new CountDownLatch ( _NUM ) ; while ( keepRunning ) { doRun ( ) ; if the previous call didn ' t return because we have stopped running , then regenerate the cursor if ( keepRunning ) { cursor . close ( ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( _STR , tailTracking . lastVal , cursorRegenerationDelay ) ; } if ( cursorRegenerationDelayEnabled ) { try { Thread . sleep ( cursorRegenerationDelay ) ; } catch ( InterruptedException e ) { ignore } } cursor = initializeCursor ( ) ; } } stopped = true ; stoppedLatch . countDown ( ) ; } 
5334	public long insertStartSyncEvent ( SyncOperation op , long now ) { long id ; synchronized ( mAuthorities ) { if ( Log . isLoggable ( TAG , Log . VERBOSE ) ) { Slog . v ( TAG , _STR + id ) ; } reportChange ( ContentResolver . SYNC _ OBSERVER _ TYPE _ STATUS ) ; return id ; } 
5335	public void testDontReportDeferredRemoval ( ) { Create a display and add an animating window to it . final DisplayContent dc = createNewDisplay ( ) ; final WindowState window = createWindow ( null , TYPE _ BASE _ APPLICATION , dc , _STR ) ; window . mAnimatingExit = true ; Request display removal , it should be deferred . dc . removeIfPossible ( ) ; Request ordered display ids from WM . final SparseIntArray orderedDisplayIds = new SparseIntArray ( ) ; sWm . getDisplaysInFocusOrder ( orderedDisplayIds ) ; Make sure that display that is marked for removal is not reported . assertEquals ( - _NUM , orderedDisplayIds . indexOfValue ( dc . getDisplayId ( ) ) ) ; } 
5336	public void setUp ( ) throws Exception { testAccount = AzureBlobStorageTestAccount . createOutOfBandStore ( UPLOAD _ BLOCK _ SIZE , DOWNLOAD _ BLOCK _ SIZE ) ; assumeNotNull ( testAccount ) ; } 
5337	public void removeListener ( CloseListener listener ) { removeCloseListener ( listener ) ; } 
5338	public static XmlAnyURI parse ( java . io . File f , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( XmlAnyURI ) XmlBeans . getContextTypeLoader ( ) . parse ( f , type , options ) ; } 
5339	public void tearDown ( ) throws Exception { coll . close ( ) ; dropDB ( ) ; } 
5340	void updateNotificationsNL ( ) { if ( LOGV ) Slog . v ( TAG , _STR ) ; keep track of previously active notifications final ArraySet < NotificationId > beforeNotifs = new ArraySet < NotificationId > ( mActiveNotifs ) ; mActiveNotifs . clear ( ) ; examine stats for each active policy for ( int i = mNetworkPolicy . size ( ) - _NUM ; i > = _NUM ; i - - ) { final NetworkPolicy policy = mNetworkPolicy . valueAt ( i ) ; ignore policies that aren ' t relevant to user if ( ! isTemplateRelevant ( policy . template ) ) continue ; if ( ! policy . hasCycle ( ) ) continue ; final Pair < ZonedDateTime , ZonedDateTime > cycle = NetworkPolicyManager . cycleIterator ( policy ) . next ( ) ; final long start = cycle . first . toInstant ( ) . toEpochMilli ( ) ; final long end = cycle . second . toInstant ( ) . toEpochMilli ( ) ; final long totalBytes = getTotalBytes ( policy . template , start , end ) ; if ( policy . isOverLimit ( totalBytes ) ) { if ( policy . lastLimitSnooze > = start ) { enqueueNotification ( policy , TYPE _ LIMIT _ SNOOZED , totalBytes ) ; } else { enqueueNotification ( policy , TYPE _ LIMIT , totalBytes ) ; notifyOverLimitNL ( policy . template ) ; } } else { notifyUnderLimitNL ( policy . template ) ; if ( policy . isOverWarning ( totalBytes ) & & policy . lastWarningSnooze < start ) { enqueueNotification ( policy , TYPE _ WARNING , totalBytes ) ; } } } cancel stale notifications that we didn ' t renew above for ( int i = beforeNotifs . size ( ) - _NUM ; i > = _NUM ; i - - ) { final NotificationId notificationId = beforeNotifs . valueAt ( i ) ; if ( ! mActiveNotifs . contains ( notificationId ) ) { cancelNotification ( notificationId ) ; } } } 
5341	public void closeAllWindows ( ) { app . cleanupBackgroundTasks ( ) ; app . closeAllWindows ( ) ; } 
5342	public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( _STR ) ; return sb . toString ( ) ; } 
5343	public T get ( ViewContext context ) { if ( ! viewSingletonObjects . containsKey ( tClass ) ) { synchronized ( viewSingletonObjects ) { if ( ! viewSingletonObjects . containsKey ( tClass ) ) { viewSingletonObjects . put ( tClass , new ConcurrentHashMap < String , Object > ( ) ) ; } } } Map < String , Object > instances = viewSingletonObjects . get ( tClass ) ; String key = getTagName ( context ) ; LOG . debug ( _STR , initValue , key ) ; instances . put ( key , initValue ) ; } } finally { lock . unlock ( ) ; } } } return ( T ) instances . get ( key ) ; } 
5344	public Builder setText ( @ NonNull CharSequence value ) { return setLongLabel ( value ) ; } 
5345	public PointersPair malloc ( AllocationShape shape , AllocationPoint point , AllocationStatus location ) { long reqMemory = AllocationUtils . getRequiredMemory ( shape ) ; if ( location = = AllocationStatus . HOST & & reqMemory < CudaEnvironment . getInstance ( ) . getConfiguration ( ) . getMaximumHostCacheableLength ( ) ) { CacheHolder cache = zeroCache . get ( shape ) ; if ( cache ! = null ) { Pointer pointer = cache . poll ( ) ; if ( pointer ! = null ) { cacheZeroHit . incrementAndGet ( ) ; since this memory chunk is going to be used now , remove it ' s amount from zeroCachedAmount . addAndGet ( - _NUM * reqMemory ) ; PointersPair pair = new PointersPair ( ) ; pair . setDevicePointer ( new CudaPointer ( pointer . address ( ) ) ) ; pair . setHostPointer ( new CudaPointer ( pointer . address ( ) ) ) ; point . setAllocationStatus ( AllocationStatus . HOST ) ; return pair ; } } cacheZeroMiss . incrementAndGet ( ) ; if ( CudaEnvironment . getInstance ( ) . getConfiguration ( ) . isUsePreallocation ( ) & & zeroCachedAmount . get ( ) < CudaEnvironment . getInstance ( ) . getConfiguration ( ) . getMaximumHostCache ( ) / _NUM _NUM & & reqMemory < _NUM _NUM * _NUM _NUM _NUM _NUM * _NUM _NUM _NUM _NUM L ) { CachePreallocator preallocator = new CachePreallocator ( shape , location , CudaEnvironment . getInstance ( ) . getConfiguration ( ) . getPreallocationCalls ( ) ) ; preallocator . start ( ) ; } cacheZeroMiss . incrementAndGet ( ) ; return super . malloc ( shape , point , location ) ; } return super . malloc ( shape , point , location ) ; } 
5346	private < C extends Comparable < C > > RexNode simplifyComparison ( RexCall e , Class < C > clazz ) { final List < RexNode > operands = new ArrayList < > ( e . operands ) ; simplifyList ( operands ) ; Simplify _STR is unchanged because the types are not the same . if ( o _NUM . isA ( SqlKind . LITERAL ) & & o _NUM . isA ( SqlKind . LITERAL ) & & o _NUM . getType ( ) . equals ( o _NUM . getType ( ) ) ) { final C v _NUM = ( ( RexLiteral ) o _NUM ) . getValueAs ( clazz ) ; final C v _NUM = ( ( RexLiteral ) o _NUM ) . getValueAs ( clazz ) ; if ( v _NUM = = null | | v _NUM = = null ) { return unknownAsFalse ? rexBuilder . makeLiteral ( false ) : rexBuilder . makeNullLiteral ( e . getType ( ) ) ; } final int comparisonResult = v _NUM . compareTo ( v _NUM ) ; switch ( e . getKind ( ) ) { case EQUALS : return rexBuilder . makeLiteral ( comparisonResult = = _NUM ) ; case GREATER _ THAN : return rexBuilder . makeLiteral ( comparisonResult > _NUM ) ; case GREATER _ THAN _ OR _ EQUAL : return rexBuilder . makeLiteral ( comparisonResult > = _NUM ) ; case LESS _ THAN : return rexBuilder . makeLiteral ( comparisonResult < _NUM ) ; case LESS _ THAN _ OR _ EQUAL : return rexBuilder . makeLiteral ( comparisonResult < = _NUM ) ; case NOT _ EQUALS : return rexBuilder . makeLiteral ( comparisonResult ! = _NUM ) ; default : throw new AssertionError ( ) ; } } If none of the arguments were simplified , return the call unchanged . final RexNode e _NUM ; if ( operands . equals ( e . operands ) ) { e _NUM = e ; } else { e _NUM = rexBuilder . makeCall ( e . op , operands ) ; } return simplifyUsingPredicates ( e _NUM , clazz ) ; } 
5347	public static < A extends Annotation > A getAnnotation ( final Method method , final Class < A > annotationCls , final boolean searchSupers , final boolean ignoreAccess ) { Validate . isTrue ( method ! = null , _STR ) ; if ( ! ignoreAccess & & ! MemberUtils . isAccessible ( method ) ) { return null ; } A annotation = method . getAnnotation ( annotationCls ) ; if ( annotation = = null & & searchSupers ) { final Class < ? > mcls = method . getDeclaringClass ( ) ; final List < Class < ? > > classes = getAllSuperclassesAndInterfaces ( mcls ) ; for ( final Class < ? > acls : classes ) { Method equivalentMethod ; try { equivalentMethod = ( ignoreAccess ? acls . getDeclaredMethod ( method . getName ( ) , method . getParameterTypes ( ) ) : acls . getMethod ( method . getName ( ) , method . getParameterTypes ( ) ) ) ; } catch ( final NoSuchMethodException e ) { if not found , just keep searching continue ; } annotation = equivalentMethod . getAnnotation ( annotationCls ) ; if ( annotation ! = null ) { break ; } } } return annotation ; } 
5348	public void setFilterEntity ( FilterEntity filterEntity ) { this . filterEntity = filterEntity ; conditions = filterParser . getConditions ( filter , filterEntity . getXml ( ) ) ; prevConditions = conditions ; initialConditions = conditions . toConditionsList ( ) ; for ( AbstractCondition condition : initialConditions ) { if ( ! suitableCondition ( condition ) ) { String message = String . format ( getMainMessage ( _STR ) , filterEntity . getName ( ) , datasource . getMetaClass ( ) . getName ( ) ) ; windowManager . showNotification ( message , Frame . NotificationType . HUMANIZED ) ; setFilterEntity ( adHocFilter ) ; break ; } condition . addListener ( new AbstractCondition . Listener ( ) { @ Override public void captionChanged ( ) { } @ Override public void paramChanged ( Param oldParam , Param newParam ) { updateFilterModifiedIndicator ( ) ; } } ) ; } If there are window parameters named as filter parameters , assign values to the corresponding filter params . Together with passing a filter code in ' filter ' window parameter it allows to open an arbitrary filter with parameters regardless of a user defined default filter . Window window = ComponentsHelper . getWindow ( filter ) ; for ( AbstractCondition condition : conditions . toConditionsList ( ) ) { if ( condition . getParam ( ) ! = null ) { for ( Map . Entry < String , Object > entry : window . getContext ( ) . getParams ( ) . entrySet ( ) ) { if ( entry . getKey ( ) . equals ( condition . getParam ( ) . getName ( ) ) ) condition . getParam ( ) . parseValue ( ( String ) entry . getValue ( ) ) ; } } } saveInitialFilterState ( ) ; if ( filtersLookupDisplayed ) { filtersLookupListenerEnabled = false ; filtersLookup . setValue ( filterEntity ) ; filtersLookupListenerEnabled = true ; } setFilterActionsEnabled ( ) ; setFilterActionsVisible ( ) ; fillConditionsLayout ( ConditionsFocusType . FIRST ) ; if ( delayedFocus ) { delayedFocus = false ; requestFocus ( ) ; } else { requestFocusToParamEditComponent ( ) ; } setConditionsLayoutVisible ( true ) ; if ( BooleanUtils . isTrue ( filterEntity . getIsSet ( ) ) | | ( filterEntity . getFolder ( ) ! = null & & BooleanUtils . isNotFalse ( filterEntity . getApplyDefault ( ) ) ) ) { apply ( true ) ; } for ( Filter . FilterEntityChangeListener listener : filterEntityChangeListeners ) { listener . filterEntityChanged ( filterEntity ) ; } updateWindowCaption ( ) ; } 
5349	public void setOptions ( String [ ] options ) throws Exception { String tmpStr ; Vector list ; super . setOptions ( options ) ; list = new Vector ( ) ; list . add ( _STR + defaultCardinality ( ) ) ; setGeneratorOptions ( list ) ; } 
5350	public void bug _NUM _NUM _NUM _NUM _NUM ( ) throws Exception { HSSFWorkbook wb _NUM = new HSSFWorkbook ( ) ; HSSFSheet sheet = wb _NUM . createSheet ( _STR , ( ( Area _NUM DPtg ) nr . getNameDefinition ( ) [ _NUM ] ) . toFormulaString ( HSSFEvaluationWorkbook . create ( wb _NUM ) ) ) ; assertEquals ( ' R ' , nr . getNameDefinition ( ) [ _NUM ] . getRVAType ( ) ) ; wb _NUM . close ( ) ; } 
5351	public void HelperFunction ( String scriptFileName ) throws URISyntaxException , IOException { create the DatanodeManager which will be tested Configuration conf = new Configuration ( ) ; FSNamesystem fsn = Mockito . mock ( FSNamesystem . class ) ; Mockito . when ( fsn . hasWriteLock ( ) ) . thenReturn ( true ) ; if ( scriptFileName ! = null & & ! scriptFileName . isEmpty ( ) ) { URL shellScript = getClass ( ) . getResource ( scriptFileName ) ; Path resourcePath = Paths . get ( shellScript . toURI ( ) ) ; FileUtil . setExecutable ( resourcePath . toFile ( ) , true ) ; conf . set ( DFSConfigKeys . NET _ TOPOLOGY _ SCRIPT _ FILE _ NAME _ KEY , resourcePath . toString ( ) ) ; } DatanodeManager dm = mockDatanodeManager ( fsn , conf ) ; register _NUM datanodes , each with different storage ID and type DatanodeInfo [ ] locs = new DatanodeInfo [ _NUM ] ; String [ ] storageIDs = new String [ _NUM ] ; StorageType [ ] storageTypes = new StorageType [ ] { StorageType . ARCHIVE , StorageType . DEFAULT , StorageType . DISK , StorageType . RAM _ DISK , StorageType . SSD } ; for ( int i = _NUM ; i < _NUM ; i + + ) { register new datanode String uuid = _STR , _NUM _NUM _NUM _NUM ) ; LocatedBlock block = new LocatedBlock ( b , locs , storageIDs , storageTypes ) ; List < LocatedBlock > blocks = new ArrayList < > ( ) ; blocks . add ( block ) ; final String targetIp = locs [ _NUM ] . getIpAddr ( ) ; sort block locations dm . sortLocatedBlocks ( targetIp , blocks ) ; check that storage IDs / types are aligned with datanode locs DatanodeInfo [ ] sortedLocs = block . getLocations ( ) ; storageIDs = block . getStorageIDs ( ) ; storageTypes = block . getStorageTypes ( ) ; assertThat ( sortedLocs . length , is ( _NUM ) ) ; assertThat ( storageIDs . length , is ( _NUM ) ) ; assertThat ( storageTypes . length , is ( _NUM ) ) ; for ( int i = _NUM ; i < sortedLocs . length ; i + + ) { assertThat ( ( ( DatanodeInfoWithStorage ) sortedLocs [ i ] ) . getStorageID ( ) , is ( storageIDs [ i ] ) ) ; assertThat ( ( ( DatanodeInfoWithStorage ) sortedLocs [ i ] ) . getStorageType ( ) , is ( storageTypes [ i ] ) ) ; } Ensure the local node is first . assertThat ( sortedLocs [ _NUM ] . getIpAddr ( ) , is ( targetIp ) ) ; Ensure the two decommissioned DNs were moved to the end . assertThat ( sortedLocs [ sortedLocs . length - _NUM ] . getAdminState ( ) , is ( DatanodeInfo . AdminStates . DECOMMISSIONED ) ) ; assertThat ( sortedLocs [ sortedLocs . length - _NUM ] . getAdminState ( ) , is ( DatanodeInfo . AdminStates . DECOMMISSIONED ) ) ; } 
5352	private void getMonitorLock ( ) throws KeeperException , InterruptedException { final String zRoot = ZooUtil . getRoot ( instance ) ; final String monitorPath = zRoot + Constants . ZMONITOR ; final String monitorLockPath = zRoot + Constants . ZMONITOR _ LOCK ; Ensure that everything is kosher with ZK as this has changed . ZooReaderWriter zoo = ZooReaderWriter . getInstance ( ) ; if ( zoo . exists ( monitorPath ) ) { byte [ ] data = zoo . getData ( monitorPath , null ) ; If the node isn ' t empty , it ' s from a previous install ( has hostname : port for HTTP server ) if ( _NUM ! = data . length ) { Recursively delete from that parent node zoo . recursiveDelete ( monitorPath , NodeMissingPolicy . SKIP ) ; And then make the nodes that we expect for the incoming ephemeral nodes zoo . putPersistentData ( monitorPath , new byte [ _NUM ] , NodeExistsPolicy . FAIL ) ; zoo . putPersistentData ( monitorLockPath , new byte [ _NUM ] , NodeExistsPolicy . FAIL ) ; } else if ( ! zoo . exists ( monitorLockPath ) ) { monitor node in ZK exists and is empty as we expect but the monitor / lock node does not zoo . putPersistentData ( monitorLockPath , new byte [ _NUM ] , NodeExistsPolicy . FAIL ) ; } } else { _NUM . _NUM . _NUM and earlier zoo . putPersistentData ( zRoot + Constants . ZMONITOR , new byte [ _NUM ] , NodeExistsPolicy . FAIL ) ; if ( ! zoo . exists ( monitorLockPath ) ) { Somehow the monitor node exists but not monitor / lock zoo . putPersistentData ( monitorLockPath , new byte [ _NUM ] , NodeExistsPolicy . FAIL ) ; } } Get a ZooLock for the monitor while ( true ) { MoniterLockWatcher monitorLockWatcher = new MoniterLockWatcher ( ) ; monitorLock = new ZooLock ( monitorLockPath ) ; monitorLock . lockAsync ( monitorLockWatcher , new byte [ _NUM ] ) ; monitorLockWatcher . waitForChange ( ) ; if ( monitorLockWatcher . acquiredLock ) { break ; } if ( ! monitorLockWatcher . failedToAcquireLock ) { throw new IllegalStateException ( _STR ) ; } 
5353	public Builder after ( Animator anim ) { Node node = mNodeMap . get ( anim ) ; if ( node = = null ) { node = new Node ( anim ) ; mNodeMap . put ( anim , node ) ; mNodes . add ( node ) ; } Dependency dependency = new Dependency ( node , Dependency . AFTER ) ; mCurrentNode . addDependency ( dependency ) ; return this ; } 
5354	public static Token getNMToken ( String nodeAddr ) { return NM _ TOKEN _ CACHE . getToken ( nodeAddr ) ; } 
5355	 @ Test ( groups = { _STR ) ; try { this . jobLauncherTestHelper . runTestWithCommitSuccessfulTasksPolicy ( jobProps ) ; } finally { this . jobLauncherTestHelper . deleteStateStore ( jobProps . getProperty ( ConfigurationKeys . JOB _ NAME _ KEY ) ) ; } } 
5356	public Properties getConfiguration ( Environment environment ) { Properties properties = new Properties ( ) ; Path pathPrefix = Paths . get ( environment . getName ( ) ) ; URL url = getClass ( ) . getClassLoader ( ) . getResource ( pathPrefix . toString ( ) ) ; if ( url = = null & & ! environment . getName ( ) . isEmpty ( ) ) { throw new MissingEnvironmentException ( _STR + path , e ) ; } } return properties ; } 
5357	public byte [ ] getLMHash ( ) throws NTLMEngineException { if ( lmHash = = null ) { lmHash = lmHash ( password ) ; } return lmHash ; } 
5358	public long getClipboardFormat ( ) throws HPSFException { if ( ! ( getClipboardFormatTag ( ) = = CFTAG _ WINDOWS ) ) throw new HPSFException ( _STR ) ; return LittleEndian . getInt ( getThumbnail ( ) , OFFSET _ CF ) ; } 
5359	public AbstractFreeSqlBuilder appendWhen ( boolean condition , Clause template ) { return condition ? append ( template ) : this ; } 
5360	public int skip ( PositionedByteRange src ) { if ( wrapped . isSkippable ( ) ) { int ret = wrapped . skip ( src ) ; src . setPosition ( src . getPosition ( ) + term . length ) ; return ret + term . length ; } else { find the terminator position final int start = src . getPosition ( ) ; int skipped = terminatorPosition ( src ) ; if ( - _NUM = = skipped ) { throw new IllegalArgumentException ( _STR ) ; } skipped + = term . length ; src . setPosition ( skipped ) ; return skipped - start ; } } 
5361	public static Expression convertToExpression ( final Expression expression , final Class < ? > type ) { return new ExpressionAdapter ( ) { public Object evaluate ( Exchange exchange ) { if ( type ! = null ) { return expression . evaluate ( exchange , type ) ; } else { return expression ; } } @ Override public String toString ( ) { return _STR + expression ; } } ; } 
5362	public final RpcRequestBuilder setContentType ( String contentType ) { assert builder ! = null : _STR ; doSetContentType ( builder , contentType ) ; return this ; } 
5363	public void sliceVectors ( List < INDArray > list ) { if ( isVector ( ) ) list . add ( this ) ; else { for ( int i = _NUM ; i < slices ( ) ; i + + ) { slice ( i ) . sliceVectors ( list ) ; } } } 
5364	public void testNoDynamicConfig ( ) throws Exception { ClientBase . setupTestEnv ( ) ; final int CLIENT _ PORT = PortAssignment . unique ( ) ; MainThread mt = new MainThread ( MainThread . UNSET _ MYID , CLIENT _ PORT , _STR , false ) ; verifyStandalone ( mt , CLIENT _ PORT ) ; } 
5365	private void removeServiceLocked ( Service service , UserState userState ) { userState . mBoundServices . remove ( service ) ; service . onRemoved ( ) ; It may be possible to bind a service twice , which confuses the map . Rebuild the map to make sure we can still reach a service userState . mComponentNameToServiceMap . clear ( ) ; for ( int i = _NUM ; i < userState . mBoundServices . size ( ) ; i + + ) { Service boundService = userState . mBoundServices . get ( i ) ; userState . mComponentNameToServiceMap . put ( boundService . mComponentName , boundService ) ; } scheduleNotifyClientsOfServicesStateChange ( userState ) ; } 
5366	public static Feature getRequiredFeature ( Type type , String featureName , String rangeType ) throws AnalysisEngineProcessException { Feature feature = getRequiredFeature ( type , featureName ) ; checkFeatureType ( feature , rangeType ) ; return feature ; } 
5367	protected void finishBlockAndWriteHeaderAndData ( DataOutputStream out ) throws IOException { ensureBlockReady ( ) ; long startTime = System . currentTimeMillis ( ) ; out . write ( onDiskBlockBytesWithHeader . getBuffer ( ) , _NUM , onDiskBlockBytesWithHeader . size ( ) ) ; out . write ( onDiskChecksum ) ; HFile . updateWriteLatency ( System . currentTimeMillis ( ) - startTime ) ; } 
5368	private void forceClose ( List < Connection > connections ) { for ( Connection connection : connections ) { connection . closeAsync ( ) . force ( ) ; } } 
5369	public int lookupGroupExpr ( SqlNode expr ) { for ( int i = _NUM ; i < groupExprs . size ( ) ; i + + ) { SqlNode groupExpr = groupExprs . get ( i ) ; if ( expr . equalsDeep ( groupExpr , Litmus . IGNORE ) ) { return i ; } } return - _NUM ; } 
5370	private static void runFetchImage ( DFSAdmin dfsAdmin , MiniDFSCluster cluster ) throws Exception { int retVal = dfsAdmin . run ( new String [ ] { _STR , FETCHED _ IMAGE _ FILE . getPath ( ) } ) ; assertEquals ( _NUM , retVal ) ; File highestImageOnNn = getHighestFsImageOnCluster ( cluster ) ; MD _NUM Hash expected = MD _NUM FileUtils . computeMd _NUM ForFile ( highestImageOnNn ) ; MD _NUM Hash actual = MD _NUM FileUtils . computeMd _NUM ForFile ( new File ( FETCHED _ IMAGE _ FILE , highestImageOnNn . getName ( ) ) ) ; assertEquals ( expected , actual ) ; } 
5371	public void testCompressorDecopressorLogicWithCompressionStreams ( ) { DataOutputStream deflateOut = null ; DataInputStream inflateIn = null ; int BYTE _ SIZE = _NUM _NUM _NUM _NUM * _NUM _NUM _NUM ; byte [ ] bytes = generate ( BYTE _ SIZE ) ; int bufferSize = _NUM _NUM _NUM _NUM _NUM _NUM ; int compressionOverhead = ( bufferSize / _NUM ) + _NUM _NUM ; try { DataOutputBuffer compressedDataBuffer = new DataOutputBuffer ( ) ; CompressionOutputStream deflateFilter = new BlockCompressorStream ( compressedDataBuffer , new Lz _NUM Compressor ( bufferSize ) , bufferSize , compressionOverhead ) ; deflateOut = new DataOutputStream ( new BufferedOutputStream ( deflateFilter ) ) ; deflateOut . write ( bytes , _NUM , bytes . length ) ; deflateOut . flush ( ) ; deflateFilter . finish ( ) ; DataInputBuffer deCompressedDataBuffer = new DataInputBuffer ( ) ; deCompressedDataBuffer . reset ( compressedDataBuffer . getData ( ) , _NUM , compressedDataBuffer . getLength ( ) ) ; CompressionInputStream inflateFilter = new BlockDecompressorStream ( deCompressedDataBuffer , new Lz _NUM Decompressor ( bufferSize ) , bufferSize ) ; inflateIn = new DataInputStream ( new BufferedInputStream ( inflateFilter ) ) ; byte [ ] result = new byte [ BYTE _ SIZE ] ; inflateIn . read ( result ) ; assertArrayEquals ( _STR ) ; } finally { try { if ( deflateOut ! = null ) deflateOut . close ( ) ; if ( inflateIn ! = null ) inflateIn . close ( ) ; } catch ( Exception e ) { } } } 
5372	public Set < String > getMissingProperties ( String methodName , Set < String > argNames ) { final List < Object > argsWithTypes = getArguments ( methodName ) ; final Set < String > missingArgs = new HashSet < String > ( ) ; for ( int i = _NUM ; i < argsWithTypes . size ( ) ; i + = _NUM ) { final String name = ( String ) argsWithTypes . get ( i ) ; if ( ! argNames . contains ( name ) ) { missingArgs . add ( name ) ; } } return missingArgs ; } 
5373	public void testOuterFilterRemainsWithAlwaysTrueClause ( ) { Logically equivalent to select sum ( _STR ; sql ( sql ) . queryContains ( druidChecker ( expectedQuery ) ) ; } 
5374	public void registerSignalStrength ( int cellID , int signalStrength ) { Returns the current time in milliseconds since January _NUM , _NUM _NUM _NUM _NUM _NUM _NUM : _NUM _NUM : _NUM _NUM . _NUM UTC . _STR , maxTime ) ; } } 
5375	public void setWorking ( boolean working ) { mWorkingSpinner . setAlpha ( working ? _NUM _NUM _NUM : _NUM ) ; mWorkingSpinner . setVisible ( working , false ) ; mWorkingSpinner . invalidateSelf ( ) ; } 
5376	public void testNormalFailure _NUM ( ) throws Exception { Test propagation of KILLED status to embedded flows . this . runner = this . testUtil . createFromFlowMap ( _STR , Status . CANCELLED ) ; waitForAndAssertFlowStatus ( Status . FAILED ) ; assertThreadShutDown ( ) ; } 
5377	public static void puts ( Object . . . messages ) { for ( Object message : messages ) { print ( message ) ; if ( ! ( message instanceof Terminal . Escape ) ) print ( ' ' ) ; } println ( ) ; } 
5378	public String getExcludedUsers ( ) { if ( CmsStringUtil . isEmptyOrWhitespaceOnly ( m _ excludedUsers ) ) { getToNames ( ) ; } if ( CmsStringUtil . isEmptyOrWhitespaceOnly ( m _ excludedUsers ) ) { return _STR ; } return m _ excludedUsers ; } 
5379	public static String [ ] splitRecodeMapEntry ( String value ) { Instead of using splitCSV which is forcing string with RFC - _NUM _NUM _NUM _NUM format , using Lop . DATATYPE _ PREFIX separator to split token and code int pos = value . toString ( ) . lastIndexOf ( Lop . DATATYPE _ PREFIX ) ; return new String [ ] { value . substring ( _NUM , pos ) , value . substring ( pos + _NUM ) } ; } 
5380	public PageIterator getPageIterator ( String sqlqueryAllCount , String sqlquery , String queryParam , int start , int count ) { if ( UtilValidate . isEmpty ( sqlqueryAllCount ) ) { Debug . logError ( _STR , module ) ; return new PageIterator ( ) ; } return getDatas ( queryParam , sqlqueryAllCount , sqlquery , start , count ) ; } 
5381	public void setRoomLevel ( short room ) throws IllegalStateException , IllegalArgumentException , UnsupportedOperationException { byte [ ] param = shortToByteArray ( room ) ; checkStatus ( setParameter ( PARAM _ ROOM _ LEVEL , param ) ) ; } 
5382	public void addMergedRegionUnsafe ( ) throws IOException { Workbook wb = _ testDataProvider . createWorkbook ( ) ; Sheet sh = wb . createSheet ( ) ; CellRangeAddress region _NUM = CellRangeAddress . valueOf ( _STR ) ; } catch ( final IllegalStateException e ) { expected } wb . close ( ) ; } 
5383	private String getHostId ( String hostname ) throws IOException { String hostId = null ; URI uri = UriBuilder . fromUri ( serverHostname ) . path ( _STR ) . textValue ( ) ; break ; } } } else { hostId = null ; } return hostId ; } 
5384	private void setParameters ( final BasicNodeIter params , final PreparedStatement stmt ) throws QueryException { int i = _NUM ; for ( ANode next ; ( next = params . next ( ) ) ! = null ; ) { Check name if ( ! next . qname ( ) . eq ( Q _ PARAMETER ) ) throw INVALIDOPTION _ X . get ( info , next . qname ( ) . local ( ) ) ; final BasicNodeIter attrs = next . attributes ( ) ; byte [ ] paramType = null ; boolean isNull = false ; for ( ANode attr ; ( attr = attrs . next ( ) ) ! = null ; ) { attribute _STR if ( eq ( attr . name ( ) , NULL ) ) isNull = attr . string ( ) ! = null & & Bln . parse ( attr , info ) ; else attribute not expected throw SQL _ ATTRIBUTE _ X . get ( info , attr . name ( ) ) ; } if ( paramType = = null ) throw SQL _ PARAMETERS . get ( info ) ; final byte [ ] v = next . string ( ) ; setParam ( + + i , stmt , paramType , isNull ? null : string ( v ) , isNull ) ; } } 
5385	public int optInt ( String key , int defaultValue ) { try { return getInt ( key ) ; } catch ( Exception e ) { return defaultValue ; } } 
5386	public JSONObject actTakePicture ( ) throws IOException { String service = _STR + responseJson ) ; return new JSONObject ( responseJson ) ; } catch ( JSONException e ) { throw new IOException ( e ) ; } } 
5387	private constructor . return new SharedSymbolTable ( name , version , symbolsList , symbolsMap ) ; } 
5388	public void setDrawable ( Drawable drawable ) { if ( DEBUG ) Log . v ( TAG , _STR + drawable ) ; mService . setDrawable ( drawable ) ; mBackgroundDrawable = drawable ; if ( mLayerDrawable = = null ) { return ; } if ( drawable = = null ) { setDrawableInternal ( getDefaultDrawable ( ) ) ; } else { setDrawableInternal ( drawable ) ; } } 
5389	public CreateVolumePermissionModifications withAdd ( CreateVolumePermission . . . add ) { if ( getAdd ( ) = = null ) setAdd ( new java . util . ArrayList < CreateVolumePermission > ( add . length ) ) ; for ( CreateVolumePermission value : add ) { getAdd ( ) . add ( value ) ; } return this ; } 
5390	private boolean addHostToExistingConfigGroups ( String hostName , ClusterTopology topology , String configGroupName ) { boolean addedHost = false ; Clusters clusters ; Cluster cluster ; try { clusters = getController ( ) . getClusters ( ) ; cluster = clusters . getClusterById ( topology . getClusterId ( ) ) ; } catch ( AmbariException e ) { throw new RuntimeException ( String . format ( _STR , hostName , group . getName ( ) ) , e ) ; } } } return addedHost ; } 
5391	protected boolean consumeArgumentDelimiter ( ) throws ParseException { if ( hasMoreArguments ( ) ) { sp . expect ( _STR ) ; return true ; } return false ; } 
5392	public static void beginDelayedTransition ( @ NonNull final ViewGroup sceneRoot , @ Nullable Transition transition ) { if ( ! sPendingTransitions . contains ( sceneRoot ) & & ViewCompat . isLaidOut ( sceneRoot ) ) { if ( Transition . DBG ) { Log . d ( LOG _ TAG , _STR + transition ) ; } sPendingTransitions . add ( sceneRoot ) ; if ( transition = = null ) { transition = sDefaultTransition ; } final Transition transitionClone = transition . clone ( ) ; sceneChangeSetup ( sceneRoot , transitionClone ) ; Scene . setCurrentScene ( sceneRoot , null ) ; sceneChangeRunTransition ( sceneRoot , transitionClone ) ; } } 
5393	public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; String nl = Strings . lineSeparator ( ) ; buf . append ( _STR ) . append ( nl ) ; } } else { buf . append ( nl ) ; } } } Set set = getRevokedCertificates ( ) ; if ( set ! = null ) { Iterator it = set . iterator ( ) ; while ( it . hasNext ( ) ) { buf . append ( it . next ( ) ) ; buf . append ( nl ) ; } } return buf . toString ( ) ; } 
5394	public static void setParameters ( final PreparedStatement stmt , final Map < String , String > attributes ) throws SQLException { for ( final Map . Entry < String , String > entry : attributes . entrySet ( ) ) { final String key = entry . getKey ( ) ; final Matcher matcher = SQL _ TYPE _ ATTRIBUTE _ PATTERN . matcher ( key ) ; if ( matcher . matches ( ) ) { final int parameterIndex = Integer . parseInt ( matcher . group ( _NUM ) ) ; final boolean isNumeric = NUMBER _ PATTERN . matcher ( entry . getValue ( ) ) . matches ( ) ; if ( ! isNumeric ) { throw new SQLDataException ( _STR , uee ) ; } } } } 
5395	public void longSeekBackwardCachingPartiallyReadBlocks ( ) throws IOException { OpenFileOptions options = OpenFileOptions . defaults ( ) . setReadType ( ReadType . CACHE _ PROMOTE ) ; mTestStream = new FileInStream ( mStatus , new InStreamOptions ( mStatus , options ) , mContext ) ; int seekAmount = ( int ) ( BLOCK _ LENGTH / _NUM + BLOCK _ LENGTH ) ; int readAmount = ( int ) ( BLOCK _ LENGTH * _NUM - BLOCK _ LENGTH / _NUM ) ; byte [ ] buffer = new byte [ readAmount ] ; mTestStream . read ( buffer ) ; Seek backward . mTestStream . seek ( readAmount - seekAmount ) ; Block _NUM is cached though it is not fully read . validatePartialCaching ( _NUM , ( int ) BLOCK _ LENGTH / _NUM ) ; } 
5396	public void parse ( ) throws IOException { try { need to first parse the header . int numberOfObjects = stream . getInt ( _STR + object ) ; } skip endobject marker if present if ( ! seqSource . isEOF ( ) & & seqSource . peek ( ) = = ' e ' ) { readLine ( ) ; } objectCounter + + ; } } finally { seqSource . close ( ) ; } } 
5397	public void setStartEndDegree ( int startDegree , int endDegree ) { this . startDegree = startDegree ; this . endDegree = endDegree ; checkStartAndEndDegree ( ) ; if ( ticks . size ( ) ! = _NUM ) setTickNumber ( ticks . size ( ) ) ; cancelSpeedAnimator ( ) ; degree = getDegreeAtSpeed ( getSpeed ( ) ) ; if ( ! isAttachedToWindow ( ) ) return ; updateBackgroundBitmap ( ) ; tremble ( ) ; invalidate ( ) ; } 
5398	public static int getIntValue ( String value , int defaultValue , String key ) { int result ; try { result = Integer . valueOf ( value ) . intValue ( ) ; } catch ( Exception e ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( Messages . get ( ) . getBundle ( ) . key ( Messages . ERR _ UNABLE _ TO _ PARSE _ INT _ _NUM , value , key ) ) ; } result = defaultValue ; } return result ; } 
5399	public SortedMap < String , Counter > getCounters ( MetricFilter filter ) { return getSimplyNamedMetrics ( Counter . class , Optional . of ( filter ) ) ; } 
5400	public void clients _NUM _NUM _NUM runs _NUM _NUM _NUM ( ) throws Exception { run ( _NUM _NUM _NUM , _NUM _NUM _NUM ) ; } 
5401	public void verifyParcelWithoutHomeSP ( ) throws Exception { PasspointConfiguration config = createConfig ( ) ; config . setHomeSp ( null ) ; verifyParcel ( config ) ; } 
5402	public boolean isSet ( _ Fields field ) { if ( field = = null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case SUCCESS : return isSetSuccess ( ) ; case IO : return isSetIo ( ) ; } throw new IllegalStateException ( ) ; } 
5403	 / * * * Given a dotNotation style outputPath like _STR ; } char prev = dotNotaton . charAt ( _NUM ) ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( prev ) ; for ( int index = _NUM ; index < dotNotaton . length ( ) ; index + + ) { char curr = dotNotaton . charAt ( index ) ; if ( curr = = ' [ ' & & prev ! = ' \ \ ' ) { if ( prev = = ' @ ' | | prev = = ' . ' ) { no need to add an extra ' . ' } else { sb . append ( ' . ' ) ; } } sb . append ( curr ) ; prev = curr ; } return sb . toString ( ) ; } 
5404	public void prevFocusElement ( ) { int selectedColumn = getActiveColumn ( ) ; int selectedRow = getActiveRow ( ) ; int prevColumn = selectedColumn - _NUM ; int prevRow = selectedRow ; if ( selectedColumn = = - _NUM ) { selectedColumn = _NUM ; } if ( selectedRow = = - _NUM ) { if ( impl . getModel ( ) . getRowCount ( ) > _NUM ) { moveToEnd ( impl . getRowCount ( ) - _NUM , impl . getColumnCount ( ) - _NUM ) ; } else moveFocusToPrevControl ( ) ; return ; } if ( selectedColumn = = _NUM ) { prevColumn = impl . getColumnCount ( ) - _NUM ; prevRow = selectedRow - _NUM ; } JComponent activeComponent = getActiveComponent ( ) ; boolean wasMoved = false ; if ( activeComponent ! = null ) { wasMoved = moveFocusPrevIntoComponent ( activeComponent ) ; } if ( ! wasMoved ) { if ( prevRow < _NUM ) impl . transferFocusBackward ( ) ; else moveToEnd ( prevRow , prevColumn ) ; } } 
5405	public float wallpaperOffsetForScroll ( int scroll ) { To match the default wallpaper behavior in the system , we default to either the left or right edge on initialization int numScrollingPages = getNumScreensExcludingEmptyAndCustom ( ) ; if ( mLockedToDefaultPage | | numScrollingPages < = _NUM ) { return mIsRtl ? _NUM f : _NUM f ; } screens , not including the custom screen , and empty screens ( if > MIN _ PARALLAX _ PAGE _ SPAN ) if ( mWallpaperIsLiveWallpaper ) { mNumPagesForWallpaperParallax = numScrollingPages ; } else { mNumPagesForWallpaperParallax = Math . max ( MIN _ PARALLAX _ PAGE _ SPAN , numScrollingPages ) ; } Offset by the custom screen int leftPageIndex ; int rightPageIndex ; if ( mIsRtl ) { rightPageIndex = mWorkspace . numCustomPages ( ) ; leftPageIndex = rightPageIndex + numScrollingPages - _NUM ; } else { leftPageIndex = mWorkspace . numCustomPages ( ) ; rightPageIndex = leftPageIndex + numScrollingPages - _NUM ; } Calculate the scroll range int leftPageScrollX = mWorkspace . getScrollForPage ( leftPageIndex ) ; int rightPageScrollX = mWorkspace . getScrollForPage ( rightPageIndex ) ; int scrollRange = rightPageScrollX - leftPageScrollX ; if ( scrollRange = = _NUM ) { return _NUM f ; } Sometimes the left parameter of the pages is animated during a layout transition ; this parameter offsets it to keep the wallpaper from animating as well int adjustedScroll = scroll - leftPageScrollX - mWorkspace . getLayoutTransitionOffsetForPage ( _NUM ) ; float offset = Utilities . boundToRange ( ( float ) adjustedScroll / scrollRange , _NUM f , _NUM f ) ; The offset is now distributed _NUM . . _NUM between the left and right pages that we care about , so we just map that between the pages that we are using for parallax float rtlOffset = _NUM ; if ( mIsRtl ) { In RTL , the pages are right aligned , so adjust the offset from the end rtlOffset = ( float ) ( ( mNumPagesForWallpaperParallax - _NUM ) - ( numScrollingPages - _NUM ) ) / ( mNumPagesForWallpaperParallax - _NUM ) ; } return rtlOffset + offset * ( ( float ) ( numScrollingPages - _NUM ) / ( mNumPagesForWallpaperParallax - _NUM ) ) ; } 
5406	public static < I , O > List < O > mapNotNull ( @ Nullable List < I > cur , Function < ? super I , ? extends O > f ) { if ( isEmpty ( cur ) ) return Collections . emptyList ( ) ; final ArrayList < O > result = new ArrayList < > ( ) ; for ( int i = _NUM ; i < cur . size ( ) ; i + + ) { O transformed = f . apply ( cur . get ( i ) ) ; if ( transformed ! = null ) { result . add ( transformed ) ; } } return result ; } 
5407	private void markNodes ( ) { markedImage = createImage ( ) ; final Graphics mg = markedImage . getGraphics ( ) ; BaseXLayout . antiAlias ( mg ) ; mg . setFont ( font ) ; final int [ ] marked = gui . context . marked . pres ( ) ; if ( marked . length = = _NUM ) return ; int rn = _NUM ; final int rl = roots . length ; while ( rn < rl ) { final int ml = marked . length ; final LinkedList < Integer > marklink = new LinkedList < > ( ) ; for ( int m = _NUM ; m < ml ; + + m ) marklink . add ( m , marked [ m ] ) ; for ( int lv = _NUM ; lv < sub . subtreeHeight ( rn ) ; + + lv ) { final int y = getYperLevel ( lv ) ; final ListIterator < Integer > li = marklink . listIterator ( ) ; if ( tr . bigRect ( sub , rn , lv ) ) { while ( li . hasNext ( ) ) { final int pre = li . next ( ) ; final TreeRect rect = tr . searchRect ( sub , rn , lv , pre ) ; final int ix = sub . preIndex ( rn , lv , pre ) ; if ( ix > - _NUM ) { li . remove ( ) ; final int x = ( int ) ( rect . w * ix / ( double ) sub . levelSize ( rn , lv ) ) ; mg . setColor ( colormark _NUM ) ; mg . fillRect ( rect . x + x , y , _NUM , nodeHeight + _NUM ) ; } } } else { while ( li . hasNext ( ) ) { final int pre = li . next ( ) ; final TreeRect rect = tr . searchRect ( sub , rn , lv , pre ) ; if ( rect ! = null ) { li . remove ( ) ; drawRectangle ( mg , rn , lv , rect , pre , Draw . MARK ) ; } } } } + + rn ; } } 
5408	public void fitLists ( JavaRDD < List < T > > corpus ) { we just convert List to sequences JavaRDD < Sequence < T > > rdd = corpus . map ( new ListSequenceConvertFunction < T > ( ) ) ; and use fitSequences ( ) fitSequences ( rdd ) ; } 
5409	public BaseViewHolder setImageResource ( @ IdRes int viewId , @ DrawableRes int imageResId ) { ImageView view = getView ( viewId ) ; view . setImageResource ( imageResId ) ; return this ; } 
5410	public XmlObject parseToXmlObject ( XMLInputStream xis , SchemaType type , XmlOptions options ) throws XmlException , org . apache . xmlbeans . xml . stream . XMLStreamException { Cur c ; try { c = loadXMLInputStream ( xis , options ) ; } catch ( org . apache . xmlbeans . xml . stream . XMLStreamException e ) { throw new XmlException ( e . getMessage ( ) , e ) ; } autoTypeDocument ( c , type , options ) ; XmlObject x = ( XmlObject ) c . getUser ( ) ; c . release ( ) ; return x ; } 
5411	public void startActivityFromFragment ( Fragment fragment , Intent intent , int requestCode , @ Nullable Bundle options ) { mStartedActivityFromFragment = true ; try { if ( requestCode = = - _NUM ) { ActivityCompat . startActivityForResult ( this , intent , - _NUM , options ) ; return ; } checkForValidRequestCode ( requestCode ) ; int requestIndex = allocateRequestIndex ( fragment ) ; ActivityCompat . startActivityForResult ( this , intent , ( ( requestIndex + _NUM ) < < _NUM _NUM ) + ( requestCode & _NUM xffff ) , options ) ; } finally { mStartedActivityFromFragment = false ; } } 
5412	public Plan < S , A > getPlan ( int step , S state ) { if ( isActionStep ( step ) | | step ! = actionSteps . size ( ) ) throw new IllegalArgumentException ( _STR ) ; for ( IfStatement < S , A > ifStatement : ifStatements ) { if ( ifStatement . testCondition ( state ) ) return ifStatement . getPlan ( ) ; } no matching plan found for the given state . return null ; } 
5413	public static String displayOutputs ( String name , Set < String > outputNames , LocalVariableMap symbolTable ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( name ) ; sb . append ( _STR ) ; sb . append ( displayOutputs ( outputNames , symbolTable ) ) ; return sb . toString ( ) ; } 
5414	public void setRight ( Component cmp ) { setBottomOrRightComponent ( cmp ) ; } 
5415	 @ RestrictTo ( LIBRARY _ GROUP ) void setAutoSizeTextTypeUniformWithConfiguration ( int autoSizeMinTextSize , int autoSizeMaxTextSize , int autoSizeStepGranularity , int unit ) throws IllegalArgumentException { if ( supportsAutoSizeText ( ) ) { final DisplayMetrics displayMetrics = mContext . getResources ( ) . getDisplayMetrics ( ) ; final float autoSizeMinTextSizeInPx = TypedValue . applyDimension ( unit , autoSizeMinTextSize , displayMetrics ) ; final float autoSizeMaxTextSizeInPx = TypedValue . applyDimension ( unit , autoSizeMaxTextSize , displayMetrics ) ; final float autoSizeStepGranularityInPx = TypedValue . applyDimension ( unit , autoSizeStepGranularity , displayMetrics ) ; validateAndSetAutoSizeTextTypeUniformConfiguration ( autoSizeMinTextSizeInPx , autoSizeMaxTextSizeInPx , autoSizeStepGranularityInPx ) ; if ( setupAutoSizeText ( ) ) { autoSizeText ( ) ; } } } 
5416	private ServerName [ ] multiRackCase ( RegionInfo regionInfo , ServerName primaryRS , String primaryRack ) throws IOException { List < ServerName > favoredNodes = Lists . newArrayList ( primaryRS ) ; Create the secondary and tertiary pair ServerName secondaryRS = generateMissingFavoredNodeMultiRack ( favoredNodes ) ; favoredNodes . add ( secondaryRS ) ; String secondaryRack = getRackOfServer ( secondaryRS ) ; ServerName tertiaryRS ; if ( primaryRack . equals ( secondaryRack ) ) { tertiaryRS = generateMissingFavoredNode ( favoredNodes ) ; } else { Try to place tertiary in secondary RS rack else place on primary rack . tertiaryRS = getOneRandomServer ( secondaryRack , Sets . newHashSet ( secondaryRS ) ) ; if ( tertiaryRS = = null ) { tertiaryRS = getOneRandomServer ( primaryRack , Sets . newHashSet ( primaryRS ) ) ; } We couldn ' t find anything in secondary rack , get any FN if ( tertiaryRS = = null ) { tertiaryRS = generateMissingFavoredNode ( Lists . newArrayList ( primaryRS , secondaryRS ) ) ; } } return new ServerName [ ] { secondaryRS , tertiaryRS } ; } 
5417	private ConfigurableApplicationContext loadModuleApplication ( ModuleConfig moduleConfig , List < String > tempFileJarURLs ) { ClassLoader currentClassLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; èŽ· å– æ¨¡ å— çš„ ClassLoader ClassLoader moduleClassLoader = new ModuleClassLoader ( moduleConfig . getModuleUrl ( ) , applicationContext . getClassLoader ( ) , getOverridePackages ( moduleConfig ) ) ; try { æŠŠ å½“ å‰ çº¿ ç¨‹ çš„ ClassLoader åˆ‡ æ¢ æˆ æ¨¡ å— çš„ Thread . currentThread ( ) . setContextClassLoader ( moduleClassLoader ) ; ConfigurableApplicationContext context ; Properties properties = getProperties ( moduleConfig ) ; Set < String > scanBase = moduleConfig . getScanPackages ( ) ; æ³¨ è§£ æ–¹ å¼ åŠ  è½½ bean if ( ! scanBase . isEmpty ( ) ) { ModuleAnnotationApplicationContext annotationConfigApplicationContext = new ModuleAnnotationApplicationContext ( properties ) ; annotationConfigApplicationContext . scan ( scanBase . toArray ( new String [ _NUM ] ) ) ; context = annotationConfigApplicationContext ; } else { XML æ–¹ å¼ åŠ  è½½ bean ModuleXmlApplicationContext moduleApplicationContext = new ModuleXmlApplicationContext ( ) ; moduleApplicationContext . setProperties ( properties ) ; moduleApplicationContext . setConfigLocations ( findSpringConfigs ( tempFileJarURLs , moduleClassLoader , getExclusionConfigeNameList ( properties ) ) ) ; context = moduleApplicationContext ; } context . setParent ( applicationContext ) ; if ( LOGGER . isInfoEnabled ( ) ) { LOGGER . info ( _STR , moduleConfig . getName ( ) , moduleConfig . getVersion ( ) ) ; } ( ( DefaultResourceLoader ) context ) . setClassLoader ( moduleClassLoader ) ; context . refresh ( ) ; return context ; } catch ( Throwable e ) { CachedIntrospectionResults . clearClassLoader ( moduleClassLoader ) ; throw Throwables . propagate ( e ) ; } finally { è¿˜ åŽŸ å½“ å‰ çº¿ ç¨‹ çš„ ClassLoader Thread . currentThread ( ) . setContextClassLoader ( currentClassLoader ) ; } } 
5418	public PackagePart getNodesPart ( CTSlideIdListEntry parentSlide ) throws IOException , XmlException { PackageRelationshipCollection notes ; PackagePart slidePart = getSlidePart ( parentSlide ) ; try { notes = slidePart . getRelationshipsByType ( XSLFRelation . NOTES . getRelation ( ) ) ; } catch ( InvalidFormatException e ) { throw new IllegalStateException ( e ) ; } if ( notes . size ( ) = = _NUM ) { No notes for this slide return null ; } if ( notes . size ( ) > _NUM ) { throw new IllegalStateException ( _STR + notes . size ( ) ) ; } try { return slidePart . getRelatedPart ( notes . getRelationship ( _NUM ) ) ; } catch ( InvalidFormatException e ) { throw new IllegalStateException ( e ) ; } } 
5419	public static TextBlock createTextBlock ( final String text , final Font font , final Paint paint ) { if ( text = = null ) { throw new IllegalArgumentException ( _STR ) ; if ( index > start ) { final String line = input . substring ( start , index ) ; if ( index < input . length ( ) - _NUM ) { result . addLine ( line , font , paint ) ; input = input . substring ( index + _NUM ) ; } else { moreInputToProcess = false ; } } else if ( index = = start ) { if ( index < input . length ( ) - _NUM ) { input = input . substring ( index + _NUM ) ; } else { moreInputToProcess = false ; } } else { result . addLine ( input , font , paint ) ; moreInputToProcess = false ; } } return result ; } 
5420	public void processHeartbeat ( HeartBeat heartbeat ) throws AmbariException { long now = System . currentTimeMillis ( ) ; processAlerts ( heartbeat ) ; process status reports before command reports to prevent status override immediately after task finish processStatusReports ( heartbeat ) ; processCommandReports ( heartbeat , now ) ; host status calculation are based on task and status reports , should be performed last processHostStatus ( heartbeat ) ; } 
5421	public final void setConferenceableConnections ( List < Connection > conferenceableConnections ) { clearConferenceableList ( ) ; for ( Connection c : conferenceableConnections ) { small amount of items here . if ( ! mConferenceableConnections . contains ( c ) ) { c . addConnectionListener ( mConnectionDeathListener ) ; mConferenceableConnections . add ( c ) ; } } fireOnConferenceableConnectionsChanged ( ) ; } 
5422	public void uploadProject ( final Project project , final int version , final File localFile , final User uploader ) { byte [ ] md _NUM = null ; if ( ! ( this . storage instanceof DatabaseStorage ) ) { md _NUM = computeHash ( localFile ) ; } final StorageMetadata metadata = new StorageMetadata ( project . getId ( ) , version , uploader . getUserId ( ) , md _NUM ) ; log . info ( String . format ( _STR , metadata , localFile . getName ( ) , localFile . length ( ) , resourceId ) ) ; } } 
5423	public void receive ( ClusterMetrics ncs ) { if ( ncs . getDeadServerNames ( ) ! = null ) { for ( ServerName sn : ncs . getDeadServerNames ( ) ) { if ( ! isDeadServer ( sn ) ) { LOG . info ( _STR + sn ) ; deadServers . add ( sn ) ; if ( deadServerHandler ! = null ) { deadServerHandler . newDead ( sn ) ; } } } } } 
5424	public synchronized MediaMetadataEditor putObject ( int key , Object value ) throws IllegalArgumentException { if ( mApplied ) { Log . e ( TAG , _STR + key ) ) ; } return this ; } 
5425	public Integer remove ( Object key ) { int v = _ map . remove ( key ) ; check here . if ( v = = _ map . getNoEntryValue ( ) ) { return null ; } else { return wrapValue ( v ) ; } } 
5426	public void reset ( ) { resetMappings ( ) ; notifyDataSetChanged ( ) ; } 
5427	 @ Test ( groups = _STR ; BatchExecution batch = executeBatch ( session , batchStateString , cl , null ) ; assertTrue ( batch . getConsistency ( ) . equals ( cl . toString ( ) ) ) ; } finally { cluster . close ( ) ; } } 
5428	private void open ( ) { for ( final String file : selectedValues ( ) ) view . open ( new IOFile ( file ) , search ) ; } 
5429	public void testWriteKeySetSettings ( ) throws ReflectiveOperationException , IllegalAccessException { write out files and read writeOldFiles ( ) ; Settings settings = new Settings ( InstrumentationRegistry . getContext ( ) . getFilesDir ( ) , new Object ( ) ) ; assertThat ( settings . readLPw ( createFakeUsers ( ) ) , is ( true ) ) ; write out , read back in and verify the same settings . writeLPr ( ) ; assertThat ( settings . readLPw ( createFakeUsers ( ) ) , is ( true ) ) ; verifyKeySetMetaData ( settings ) ; } 
5430	public static String parseRegionName ( final String host , final String serviceHint ) { if ( host = = null ) { throw new IllegalArgumentException ( _STR ; } 
5431	public void setLabelPaint ( Paint paint ) { if ( paint = = null ) { throw new IllegalArgumentException ( _STR ) ; } this . labelPaint = paint ; fireChangeEvent ( ) ; } 
5432	public void setFacePainted ( BlockFace face , boolean painted ) { if ( painted = = isFacePainted ( face ) ) { return ; } byte data = getData ( ) ; if ( data = = SHROOM _ STEM ) { data = _NUM ; } switch ( face ) { case WEST : if ( painted ) { data - = NORTH _ SOUTH _ MOD ; } else { data + = NORTH _ SOUTH _ MOD ; } break ; case EAST : if ( painted ) { data + = NORTH _ SOUTH _ MOD ; } else { data - = NORTH _ SOUTH _ MOD ; } break ; case NORTH : if ( painted ) { data + = EAST _ WEST _ MOD ; } else { data - = EAST _ WEST _ MOD ; } break ; case SOUTH : if ( painted ) { data - = EAST _ WEST _ MOD ; } else { data + = EAST _ WEST _ MOD ; } break ; case UP : if ( ! painted ) { data = _NUM ; } break ; default : throw new IllegalArgumentException ( _STR ) ; } setData ( data ) ; } 
5433	public void setUIID ( String id ) { super . setUIID ( id ) ; String t = ( String ) getClientProperty ( _STR , null ) ; } } } 
5434	public static XmlNMTOKEN parse ( java . net . URL u ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( XmlNMTOKEN ) XmlBeans . getContextTypeLoader ( ) . parse ( u , type , null ) ; } 
5435	private boolean addHisoricalRecord ( HistoricalRecord historicalRecord ) { synchronized ( mInstanceLock ) { final boolean added = mHistoricalRecords . add ( historicalRecord ) ; if ( added ) { mHistoricalRecordsChanged = true ; pruneExcessiveHistoricalRecordsLocked ( ) ; persistHistoricalData ( ) ; sortActivities ( ) ; } return added ; } } 
5436	public final boolean isLinearText ( ) { return ( getFlags ( ) & LINEAR _ TEXT _ FLAG ) ! = _NUM ; } 
5437	public static String getHistoricalUrl ( WebView webView ) { WebBackForwardList webBackForwardList = getHistoricalList ( webView ) ; return webBackForwardList . getItemAtIndex ( webBackForwardList . getCurrentIndex ( ) - _NUM ) . getUrl ( ) ; } 
5438	public void unlockBlock ( long lockId ) throws BlockDoesNotExistException { if ( ! unlockBlockNoException ( lockId ) ) { throw new BlockDoesNotExistException ( ExceptionMessage . LOCK _ RECORD _ NOT _ FOUND _ FOR _ LOCK _ ID , lockId ) ; } } 
5439	private void fitImageToView ( ) { Drawable drawable = getDrawable ( ) ; if ( drawable = = null | | drawable . getIntrinsicWidth ( ) = = _NUM | | drawable . getIntrinsicHeight ( ) = = _NUM ) { return ; } if ( matrix = = null | | prevMatrix = = null ) { return ; } int drawableWidth = drawable . getIntrinsicWidth ( ) ; int drawableHeight = drawable . getIntrinsicHeight ( ) ; Scale image for view float scaleX = ( float ) viewWidth / drawableWidth ; float scaleY = ( float ) viewHeight / drawableHeight ; switch ( mScaleType ) { case CENTER : scaleX = scaleY = _NUM ; break ; case CENTER _ CROP : scaleX = scaleY = Math . max ( scaleX , scaleY ) ; break ; case CENTER _ INSIDE : scaleX = scaleY = Math . min ( _NUM , Math . min ( scaleX , scaleY ) ) ; case FIT _ CENTER : scaleX = scaleY = Math . min ( scaleX , scaleY ) ; break ; case FIT _ XY : break ; default : throw new UnsupportedOperationException ( _STR ) ; } Center the image float redundantXSpace = viewWidth - ( scaleX * drawableWidth ) ; float redundantYSpace = viewHeight - ( scaleY * drawableHeight ) ; matchViewWidth = viewWidth - redundantXSpace ; matchViewHeight = viewHeight - redundantYSpace ; if ( ! isZoomed ( ) & & ! imageRenderedAtLeastOnce ) { Stretch and center image to fit view matrix . setScale ( scaleX , scaleY ) ; matrix . postTranslate ( redundantXSpace / _NUM , redundantYSpace / _NUM ) ; normalizedScale = _NUM ; } else { if ( prevMatchViewWidth = = _NUM | | prevMatchViewHeight = = _NUM ) { savePreviousImageValues ( ) ; } prevMatrix . getValues ( m ) ; Rescale Matrix after rotation m [ Matrix . MSCALE _ X ] = matchViewWidth / drawableWidth * normalizedScale ; m [ Matrix . MSCALE _ Y ] = matchViewHeight / drawableHeight * normalizedScale ; TransX and TransY from previous matrix float transX = m [ Matrix . MTRANS _ X ] ; float transY = m [ Matrix . MTRANS _ Y ] ; Width float prevActualWidth = prevMatchViewWidth * normalizedScale ; float actualWidth = getImageWidth ( ) ; translateMatrixAfterRotate ( Matrix . MTRANS _ X , transX , prevActualWidth , actualWidth , prevViewWidth , viewWidth , drawableWidth ) ; Height float prevActualHeight = prevMatchViewHeight * normalizedScale ; float actualHeight = getImageHeight ( ) ; translateMatrixAfterRotate ( Matrix . MTRANS _ Y , transY , prevActualHeight , actualHeight , prevViewHeight , viewHeight , drawableHeight ) ; Set the matrix to the adjusted scale and translate values . matrix . setValues ( m ) ; } fixTrans ( ) ; setImageMatrix ( matrix ) ; } 
5440	public void sendKeySync ( KeyEvent event ) { validateNotAppThread ( ) ; long downTime = event . getDownTime ( ) ; long eventTime = event . getEventTime ( ) ; int action = event . getAction ( ) ; int code = event . getKeyCode ( ) ; int repeatCount = event . getRepeatCount ( ) ; int metaState = event . getMetaState ( ) ; int deviceId = event . getDeviceId ( ) ; int scancode = event . getScanCode ( ) ; int source = event . getSource ( ) ; int flags = event . getFlags ( ) ; if ( source = = InputDevice . SOURCE _ UNKNOWN ) { source = InputDevice . SOURCE _ KEYBOARD ; } if ( eventTime = = _NUM ) { eventTime = SystemClock . uptimeMillis ( ) ; } if ( downTime = = _NUM ) { downTime = eventTime ; } KeyEvent newEvent = new KeyEvent ( downTime , eventTime , action , code , repeatCount , metaState , deviceId , scancode , flags | KeyEvent . FLAG _ FROM _ SYSTEM , source ) ; InputManager . getInstance ( ) . injectInputEvent ( newEvent , InputManager . INJECT _ INPUT _ EVENT _ MODE _ WAIT _ FOR _ FINISH ) ; } 
5441	private int updateLastTokensBelow ( int line , int numLines , int previousTokenType ) { int firstLine = line ; Loop through all lines past our starting point . Update even the last line ' s info , even though there aren ' t any lines after it that depend on it changing for them to be changed , as its state may be used elsewhere in the library . int end = numLines ; System . err . println ( _STR + line ) ; fireChangedUpdate ( new DefaultDocumentEvent ( firstLine , line , DocumentEvent . EventType . CHANGE ) ) ; } return line ; } 
5442	public void importVocabulary ( @ NonNull VocabCache < T > vocabCache ) { for ( T element : vocabCache . vocabWords ( ) ) { this . addToken ( element ) ; } logger . info ( _STR , this . documentsCounter . get ( ) , vocabCache . totalNumberOfDocs ( ) ) ; this . documentsCounter . addAndGet ( vocabCache . totalNumberOfDocs ( ) ) ; } 
5443	public org . bitcoinj . protocols . channels . ClientState . StoredClientPaymentChannel . Builder addChannelsBuilder ( ) { return getChannelsFieldBuilder ( ) . addBuilder ( org . bitcoinj . protocols . channels . ClientState . StoredClientPaymentChannel . getDefaultInstance ( ) ) ; } 
5444	protected void finishUp ( ) { super . finishUp ( ) ; if ( ! m _ SaveForVisualization ) return ; if ( m _ Instances . attribute ( m _ ClassIndex ) . isNumeric ( ) ) { scaleNumericPredictions ( ) ; if ( m _ Classifier instanceof IntervalEstimator ) addPredictionIntervals ( ) ; } } 
5445	private static Map < StructuralKey < ? > , List < TimerData > > extractFiredTimers ( Instant latestTime , Map < StructuralKey < ? > , NavigableSet < TimerData > > objectTimers ) { Map < StructuralKey < ? > , List < TimerData > > result = new HashMap < > ( ) ; Set < StructuralKey < ? > > emptyKeys = new HashSet < > ( ) ; for ( Map . Entry < StructuralKey < ? > , NavigableSet < TimerData > > pendingTimers : objectTimers . entrySet ( ) ) { NavigableSet < TimerData > timers = pendingTimers . getValue ( ) ; if ( ! timers . isEmpty ( ) & & timers . first ( ) . getTimestamp ( ) . isBefore ( latestTime ) ) { ArrayList < TimerData > keyFiredTimers = new ArrayList < > ( ) ; result . put ( pendingTimers . getKey ( ) , keyFiredTimers ) ; while ( ! timers . isEmpty ( ) & & timers . first ( ) . getTimestamp ( ) . isBefore ( latestTime ) ) { keyFiredTimers . add ( timers . first ( ) ) ; timers . remove ( timers . first ( ) ) ; } } if ( timers . isEmpty ( ) ) { emptyKeys . add ( pendingTimers . getKey ( ) ) ; } } objectTimers . keySet ( ) . removeAll ( emptyKeys ) ; return result ; } 
5446	public String [ ] getOptions ( ) { Vector < String > result ; String [ ] options ; int i ; result = new Vector < String > ( ) ; options = super . getOptions ( ) ; for ( i = _NUM ; i < options . length ; i + + ) result . add ( options [ i ] ) ; if ( getOptionHandler ( ) ! = null ) { result . add ( _STR ) ; for ( i = _NUM ; i < options . length ; i + + ) result . add ( options [ i ] ) ; } return ( String [ ] ) result . toArray ( new String [ result . size ( ) ] ) ; } 
5447	public Builder addChildAsBits ( int tag , int value ) { if ( isConstructedTag ( tag ) ) { throw new IllegalStateException ( _STR + tag ) ; } Always allocate _NUM bytes for simplicity . byte [ ] dataBytes = new byte [ INT _ BYTES + _NUM ] ; Puts the integer into the byte [ _NUM - _NUM ] . value = Integer . reverse ( value ) ; int dataLength = _NUM ; for ( int i = _NUM ; i < dataBytes . length ; i + + ) { dataBytes [ i ] = ( byte ) ( value > > ( ( INT _ BYTES - i ) * Byte . SIZE ) ) ; if ( dataBytes [ i ] ! = _NUM ) { dataLength = i ; } } dataLength + + ; The first byte is the number of trailing zeros of the last byte . dataBytes [ _NUM ] = IccUtils . countTrailingZeros ( dataBytes [ dataLength - _NUM ] ) ; addChild ( new Asn _NUM Node ( tag , dataBytes , _NUM , dataLength ) ) ; return this ; } 
5448	public void toFiles ( Iterable < File > iterable ) throws IOException { asFiles ( iterable ) ; } 
5449	protected void setExceptions ( List < CmsException > exceptions ) { m _ exceptions = new ArrayList < CmsException > ( exceptions ) ; updateMessage ( ) ; } 
5450	SHOW @ @ SQL WHERE ID = XXXXXXstatic int show _NUM SqlBlankCheck ( String stmt , int offset ) { for ( + + offset ; stmt . length ( ) > offset ; + + offset ) { switch ( stmt . charAt ( offset ) ) { case ' ' : continue ; case ' W ' : case ' w ' : if ( isWhere ( stmt , offset ) ) { return SQL ; } else { return OTHER ; } default : return OTHER ; } } return OTHER ; } 
5451	public void prev ( ) throws IOException { if ( getCurrentIndex ( ) > _NUM ) { seek ( getFilePointer ( ) - getEntryLength ( ) ) ; } } 
5452	public static String addAdditionalParty ( HttpServletRequest request , HttpServletResponse response ) { ShoppingCart cart = getCartObject ( request ) ; String partyId = request . getParameter ( _STR ; } 
5453	public final CC push ( Float weightX , Float weightY ) { return pushX ( weightX ) . pushY ( weightY ) ; } 
5454	public boolean bodyCall ( Node [ ] args , int length , RuleContext context ) { checkArgs ( length , context ) ; Node n _NUM = getArg ( _NUM , args , context ) ; Node n _NUM = getArg ( _NUM , args , context ) ; if ( Util . comparable ( n _NUM , n _NUM ) ) { return Util . compareTypedLiterals ( n _NUM , n _NUM ) < = _NUM ; } else { return false ; } } 
5455	public String getFormattedMessage ( ) { if ( formattedMessage = = null ) { if ( message = = null ) { message = getMessage ( messagePattern , argArray , throwable ) ; } formattedMessage = message . getFormattedMessage ( ) ; } return formattedMessage ; } 
5456	public static boolean isValidUUID ( String uuid ) { try { return ( null ! = uuid ) & & ( null ! = UUID . valueOf ( uuid ) ) ; } catch ( NumberFormatException e ) { return false } return false ; } 
5457	public ViewPropertyAnimator yBy ( float value ) { animatePropertyBy ( Y , value ) ; return this ; } 
5458	private void bleAbortScanInternal ( int scanAttempt ) { if ( mState = = STATE _ WAITING _ FOR _ DEVICE _ DISCOVERY & & scanAttempt = = mScanAttempt ) { if ( DEBUG ) { Slog . d ( TAG , _STR ) ; } stopScanning ( ) ; FIXME : should we also try shutting off bluetooth if we enabled it in the first place ? mState = STATE _ DEVICE _ NOT _ FOUND ; } } 
5459	public double twoHourRate ( ) { tickIfNecessary ( ) ; return m _NUM _NUM _NUM Rate . rate ( ) ; } 
5460	private void registerServiceBean ( BeanDefinitionHolder beanDefinitionHolder , BeanDefinitionRegistry registry , DubboClassPathBeanDefinitionScanner scanner ) { Class < ? > beanClass = resolveClass ( beanDefinitionHolder ) ; Service service = findAnnotation ( beanClass , Service . class ) ; Class < ? > interfaceClass = resolveServiceInterfaceClass ( beanClass , service ) ; String annotatedServiceBeanName = beanDefinitionHolder . getBeanName ( ) ; AbstractBeanDefinition serviceBeanDefinition = buildServiceBeanDefinition ( service , interfaceClass , annotatedServiceBeanName ) ; ServiceBean Bean name String beanName = generateServiceBeanName ( interfaceClass , annotatedServiceBeanName ) ; if ( scanner . checkCandidate ( beanName , serviceBeanDefinition ) ) { check duplicated candidate bean registry . registerBeanDefinition ( beanName , serviceBeanDefinition ) ; if ( logger . isInfoEnabled ( ) ) { logger . warn ( _STR ) ; } } } 
5461	public static FSDataOutputStream create ( FileSystem fs , Path file , FsPermission permission ) throws IOException { create the file with default permission FSDataOutputStream out = fs . create ( file ) ; set its permission to the supplied one fs . setPermission ( file , permission ) ; return out ; } 
5462	public static I _ CmsContextMenuCommand getContextMenuCommand ( ) { return new I _ CmsContextMenuCommand ( ) { public void execute ( CmsUUID structureId , I _ CmsContextMenuHandler handler , CmsContextMenuEntryBean bean ) { openWorkplace ( structureId ) ; } public String getCommandIconClass ( ) { return org . opencms . gwt . client . ui . css . I _ CmsImageBundle . INSTANCE . contextMenuIcons ( ) . workplace ( ) ; } } ; } 
5463	public synchronized void write ( final byte [ ] record ) throws WriteFailure , SerializationError , InterruptedException { if ( closed ) { throw new IllegalStateException ( _STR , se ) ; } catch ( StreamingException e ) { throw new WriteFailure ( endPoint , txnBatch . getCurrentTxnId ( ) , e ) ; } catch ( TimeoutException e ) { throw new WriteFailure ( endPoint , txnBatch . getCurrentTxnId ( ) , e ) ; } } 
5464	public Uri resolve ( final Uri add , final InputInfo info ) throws QueryException { if ( add . value . length = = _NUM ) return this ; try { final URI base = new URI ( Token . string ( value ) ) , res = new URI ( Token . string ( add . value ) ) ; String uri = base . resolve ( res ) . toString ( ) ; if ( uri . startsWith ( IO . FILEPREF ) ) uri = uri . replaceAll ( ' ^ ' + IO . FILEPREF + _STR return uri ( Token . token ( uri ) , false ) ; } catch ( final URISyntaxException ex ) { throw URIARG _ X . get ( info , ex . getMessage ( ) ) ; } } 
5465	public org . apache . phoenix . coprocessor . generated . PTableProtos . PTable . Builder addIndexesBuilder ( ) { return getIndexesFieldBuilder ( ) . addBuilder ( org . apache . phoenix . coprocessor . generated . PTableProtos . PTable . getDefaultInstance ( ) ) ; } 
5466	private void ensureTempTables _NUM ( ) throws SQLException { boolean b = connection ( ) . loggingSQLExceptions ( ) ; try { connection ( ) . setLogSQLExceptions ( false ) ; createTempTables ( ) ; } catch ( SQLException ex ) { Some problem - due to the differences in databases we didn ' t check whether tables existed first . So attempt to cleanup , then tryagain to create the temporary tables . TableUtils . dropTableSilent ( connection ( ) , getNodeLoader ( ) ) ; TableUtils . dropTableSilent ( connection ( ) , getTupleLoader ( ) ) ; Allow this to throw the SQLException createTempTables ( ) ; } finally { connection ( ) . setLogSQLExceptions ( b ) ; } } 
5467	public static HeartbeatMessage parse ( InputStream input ) throws IOException { short type = TlsUtils . readUint _NUM ( input ) ; if ( ! HeartbeatMessageType . isValid ( type ) ) { throw new TlsFatalAlert ( AlertDescription . illegal _ parameter ) ; } int payload _ length = TlsUtils . readUint _NUM _NUM ( input ) ; PayloadBuffer buf = new PayloadBuffer ( ) ; Streams . pipeAll ( input , buf ) ; byte [ ] payload = buf . toTruncatedByteArray ( payload _ length ) ; if ( payload = = null ) { return null ; } int padding _ length = buf . size ( ) - payload . length ; return new HeartbeatMessage ( type , payload , padding _ length ) ; } 
5468	private final void ssMintroSort ( int PA , int first , int last , int depth ) throws IOException { final int STACK _ SIZE = SS _ MISORT _ STACKSIZE ; StackElement [ ] stack = new StackElement [ STACK _ SIZE ] ; T ptr int Td ; SA ptr int a , b , c , d , e , f ; int s , t ; int ssize ; int limit ; int v , x = _NUM ; for ( ssize = _NUM , limit = ssIlg ( last - first ) ; ; ) { if ( ( last - first ) < = SS _ INSERTIONSORT _ THRESHOLD ) { if ( _NUM < ( last - first ) ) { ssInsertionSort ( PA , first , last , depth ) ; } if ( ssize > _NUM ) { StackElement se = stack [ - - ssize ] ; first = se . a ; last = se . b ; depth = se . c ; limit = se . d ; } else { return ; } continue ; } Td = depth ; if ( limit - - = = _NUM ) { ssHeapSort ( Td , PA , first , last - first ) ; } if ( limit < _NUM ) { for ( a = first + _NUM , v = readInput ( Td + readSuffixArray ( PA + readSuffixArray ( first ) ) ) ; a < last ; + + a ) { if ( ( x = readInput ( Td + readSuffixArray ( PA + readSuffixArray ( a ) ) ) ) ! = v ) { if ( _NUM < ( a - first ) ) { break ; } v = x ; first = a ; } } if ( readInput ( Td + readSuffixArray ( PA + readSuffixArray ( first ) ) - _NUM ) < v ) { first = ssPartition ( PA , first , a , depth ) ; } if ( ( a - first ) < = ( last - a ) ) { if ( _NUM < ( a - first ) ) { stack [ ssize + + ] = new StackElement ( a , last , depth , - _NUM ) ; last = a ; depth + = _NUM ; limit = ssIlg ( a - first ) ; } else { first = a ; limit = - _NUM ; } } else { if ( _NUM < ( last - a ) ) { stack [ ssize + + ] = new StackElement ( first , a , depth + _NUM , ssIlg ( a - first ) ) ; first = a ; limit = - _NUM ; } else { last = a ; depth + = _NUM ; limit = ssIlg ( a - first ) ; } } continue ; } choose pivot a = ssPivot ( Td , PA , first , last ) ; v = readInput ( Td + readSuffixArray ( PA + readSuffixArray ( a ) ) ) ; swapInSA ( first , a ) ; partition for ( b = first ; ( + + b < last ) & & ( ( x = readInput ( Td + readSuffixArray ( PA + readSuffixArray ( b ) ) ) ) = = v ) ; ) { } if ( ( ( a = b ) < last ) & & ( x < v ) ) { for ( ; ( + + b < last ) & & ( ( x = readInput ( Td + readSuffixArray ( PA + readSuffixArray ( b ) ) ) ) < = v ) ; ) { if ( x = = v ) { swapInSA ( b , a ) ; + + a ; } } } for ( c = last ; ( b < - - c ) & & ( ( x = readInput ( Td + readSuffixArray ( PA + readSuffixArray ( c ) ) ) ) = = v ) ; ) { } if ( ( b < ( d = c ) ) & & ( x > v ) ) { for ( ; ( b < - - c ) & & ( ( x = readInput ( Td + readSuffixArray ( PA + readSuffixArray ( c ) ) ) ) > = v ) ; ) { if ( x = = v ) { swapInSA ( c , d ) ; - - d ; } } } for ( ; b < c ; ) { swapInSA ( b , c ) ; for ( ; ( + + b < c ) & & ( ( x = readInput ( Td + readSuffixArray ( PA + readSuffixArray ( b ) ) ) ) < = v ) ; ) { if ( x = = v ) { swapInSA ( b , a ) ; + + a ; } } for ( ; ( b < - - c ) & & ( ( x = readInput ( Td + readSuffixArray ( PA + readSuffixArray ( c ) ) ) ) > = v ) ; ) { if ( x = = v ) { swapInSA ( c , d ) ; - - d ; } } } if ( a < = d ) { c = b - _NUM ; if ( ( s = a - first ) > ( t = b - a ) ) { s = t ; } for ( e = first , f = b - s ; _NUM < s ; - - s , + + e , + + f ) { swapInSA ( e , f ) ; } if ( ( s = d - c ) > ( t = last - d - _NUM ) ) { s = t ; } for ( e = b , f = last - s ; _NUM < s ; - - s , + + e , + + f ) { swapInSA ( e , f ) ; } a = first + ( b - a ) ; c = last - ( d - c ) ; b = ( v < = readInput ( Td + readSuffixArray ( PA + readSuffixArray ( a ) ) - _NUM ) ) ? a : ssPartition ( PA , a , c , depth ) ; if ( ( a - first ) < = ( last - c ) ) { if ( ( last - c ) < = ( c - b ) ) { stack [ ssize + + ] = new StackElement ( b , c , depth + _NUM , ssIlg ( c - b ) ) ; stack [ ssize + + ] = new StackElement ( c , last , depth , limit ) ; last = a ; } else if ( ( a - first ) < = ( c - b ) ) { stack [ ssize + + ] = new StackElement ( c , last , depth , limit ) ; stack [ ssize + + ] = new StackElement ( b , c , depth + _NUM , ssIlg ( c - b ) ) ; last = a ; } else { stack [ ssize + + ] = new StackElement ( c , last , depth , limit ) ; stack [ ssize + + ] = new StackElement ( first , a , depth , limit ) ; first = b ; last = c ; depth + = _NUM ; limit = ssIlg ( c - b ) ; } } else { if ( ( a - first ) < = ( c - b ) ) { stack [ ssize + + ] = new StackElement ( b , c , depth + _NUM , ssIlg ( c - b ) ) ; stack [ ssize + + ] = new StackElement ( first , a , depth , limit ) ; first = c ; } else if ( ( last - c ) < = ( c - b ) ) { stack [ ssize + + ] = new StackElement ( first , a , depth , limit ) ; stack [ ssize + + ] = new StackElement ( b , c , depth + _NUM , ssIlg ( c - b ) ) ; first = c ; } else { stack [ ssize + + ] = new StackElement ( first , a , depth , limit ) ; stack [ ssize + + ] = new StackElement ( c , last , depth , limit ) ; first = b ; last = c ; depth + = _NUM ; limit = ssIlg ( c - b ) ; } } } else { limit + = _NUM ; if ( readInput ( Td + readSuffixArray ( PA + readSuffixArray ( first ) ) - _NUM ) < v ) { first = ssPartition ( PA , first , last , depth ) ; limit = ssIlg ( last - first ) ; } depth + = _NUM ; } } } 
5469	public List < NeighboringCellInfo > getNeighboringCellInfo ( ) { try { ITelephony telephony = getITelephony ( ) ; if ( telephony = = null ) return null ; return telephony . getNeighboringCellInfo ( mContext . getOpPackageName ( ) ) ; } catch ( RemoteException ex ) { return null ; } catch ( NullPointerException ex ) { return null ; } } 
5470	public static Expression convertToExpression ( final Expression expression , final Expression type ) { return new ExpressionAdapter ( ) { public Object evaluate ( Exchange exchange ) { Object result = type . evaluate ( exchange , Object . class ) ; if ( result ! = null ) { return expression . evaluate ( exchange , result . getClass ( ) ) ; } else { return expression ; } } @ Override public String toString ( ) { return _STR + expression ; } } ; } 
5471	public void terminate ( ) { if ( _ out = = null ) { throw new IllegalStateException ( _STR ) ; } _ dataSizeOutput . writeShort ( _ size ) ; if ( _ byteBuffer ! = null ) { _ originalOut . write ( _ byteBuffer , _NUM , _ size ) ; _ out = null ; return ; } _ out = null ; } 
5472	public static boolean checkIRI ( String iriStr ) { IRI iri = parseIRI ( iriStr ) ; return iri . hasViolation ( false ) ; } 
5473	public void emulateShiftHeld ( ) { checkThread ( ) ; } 
5474	public default < C extends Collection < E > > C fill ( final C collection ) { try { if ( ! this . asAdmin ( ) . isLocked ( ) ) this . asAdmin ( ) . applyStrategies ( ) ; use the end step so the results are bulked final Step < ? , E > endStep = this . asAdmin ( ) . getEndStep ( ) ; while ( true ) { final Traverser < E > traverser = endStep . next ( ) ; TraversalHelper . addToCollection ( collection , traverser . get ( ) , traverser . bulk ( ) ) ; } } catch ( final NoSuchElementException ignored ) { } return collection ; } 
5475	void addChild ( JobQueueInfo child ) { List < JobQueueInfo > children = getChildren ( ) ; children . add ( child ) ; setChildren ( children ) ; } 
5476	protected final void processOp ( Op op ) throws IOException { switch ( op ) { case READ _ BLOCK : opReadBlock ( ) ; break ; case WRITE _ BLOCK : opWriteBlock ( in ) ; break ; case REPLACE _ BLOCK : opReplaceBlock ( in ) ; break ; case COPY _ BLOCK : opCopyBlock ( in ) ; break ; case BLOCK _ CHECKSUM : opBlockChecksum ( in ) ; break ; case TRANSFER _ BLOCK : opTransferBlock ( in ) ; break ; case REQUEST _ SHORT _ CIRCUIT _ FDS : opRequestShortCircuitFds ( in ) ; break ; case RELEASE _ SHORT _ CIRCUIT _ FDS : opReleaseShortCircuitFds ( in ) ; break ; case REQUEST _ SHORT _ CIRCUIT _ SHM : opRequestShortCircuitShm ( in ) ; break ; default : throw new IOException ( _STR ) ; } } 
5477	public void test _ Notified _ acceptProtocol _NUM ( ) { URL errorPathUrl = URL . valueOf ( _STR injvm : serviceUrls . add ( dubbo _NUM URL ) ; serviceUrls . add ( dubbo _NUM URL ) ; registryDirectory . notify ( serviceUrls ) ; invocation = new RpcInvocation ( ) ; List < Invoker < DemoService > > invokers = registryDirectory . list ( invocation ) ; Assert . assertEquals ( _NUM , invokers . size ( ) ) ; } 
5478	private void startQueryIterator ( ) { execInit ( ) ; if ( queryIterator ! = null ) Log . warn ( this , _STR ) ; if ( ! isTimeoutSet ( timeout _NUM ) & & ! isTimeoutSet ( timeout _NUM ) ) { Case - _NUM , - _NUM queryIterator = getPlan ( ) . iterator ( ) ; return ; } if ( ! isTimeoutSet ( timeout _NUM ) & & isTimeoutSet ( timeout _NUM ) ) { Single overall timeout . TimeoutCallback callback = new TimeoutCallback ( ) ; expectedCallback = callback ; timeout _NUM Alarm = alarmClock . add ( callback , timeout _NUM ) ; Start the query . queryIterator = getPlan ( ) . iterator ( ) ; But don ' t add resetter . return ; } Case isTimeoutSet ( timeout _NUM ) Whether timeout _NUM is set is determined by QueryIteratorTimer _NUM Subcase _NUM : ! isTimeoutSet ( timeout _NUM ) Add timeout to first row . TimeoutCallback callback = new TimeoutCallback ( ) ; timeout _NUM Alarm = alarmClock . add ( callback , timeout _NUM ) ; expectedCallback = callback ; We don ' t know if getPlan ( ) . iterator ( ) does a lot of work or not ( ideally it shouldn ' t start executing the query but in some sub - systems it might be necessary ) queryIterator = getPlan ( ) . iterator ( ) ; Add the timeout _NUM resetter wrapper . queryIterator = new QueryIteratorTimer _NUM ( queryIterator ) ; if ( isCancelled ) queryIterator . cancel ( ) ; } 
5479	public Map < String , String > getFlatSubsystemsMap ( ) { if ( flatSubsystemsMap = = null ) { flatSubsystemsMap = new HashMap < > ( ) ; findSubsystemsToFlatten ( root , flatSubsystemsMap ) ; } return flatSubsystemsMap ; } 
5480	public Builder putUserMap ( java . lang . String key , io . protostuff . runtime . model . ModelProtobuf . User value ) { if ( key = = null ) { throw new java . lang . NullPointerException ( ) ; } if ( value = = null ) { throw new java . lang . NullPointerException ( ) ; } internalGetMutableUserMap ( ) . getMutableMap ( ) . put ( key , value ) ; return this ; } 
5481	 @ VisibleForTestingCollection < Range < Token > > createRepairRangeFrom ( String beginToken , String endToken ) { Token parsedBeginToken = getTokenFactory ( ) . fromString ( beginToken ) ; Token parsedEndToken = getTokenFactory ( ) . fromString ( endToken ) ; Break up given range to match ring layout in TokenMetadata ArrayList < Range < Token > > repairingRange = new ArrayList < > ( ) ; ArrayList < Token > tokens = new ArrayList < > ( tokenMetadata . sortedTokens ( ) ) ; if ( ! tokens . contains ( parsedBeginToken ) ) { tokens . add ( parsedBeginToken ) ; } if ( ! tokens . contains ( parsedEndToken ) ) { tokens . add ( parsedEndToken ) ; } tokens now contain all tokens including our endpoints Collections . sort ( tokens ) ; int start = tokens . indexOf ( parsedBeginToken ) , end = tokens . indexOf ( parsedEndToken ) ; for ( int i = start ; i ! = end ; i = ( i + _NUM ) % tokens . size ( ) ) { Range < Token > range = new Range < > ( tokens . get ( i ) , tokens . get ( ( i + _NUM ) % tokens . size ( ) ) ) ; repairingRange . add ( range ) ; } return repairingRange ; } 
5482	public int getMaxNumFocusAreas ( ) { return getInt ( KEY _ MAX _ NUM _ FOCUS _ AREAS , _NUM ) ; } 
5483	public static DoublesSketch heapify ( final Memory srcMem ) { if ( checkIsCompactMemory ( srcMem ) ) { return CompactDoublesSketch . heapify ( srcMem ) ; } else { return UpdateDoublesSketch . heapify ( srcMem ) ; } } 
5484	public void testConcat ( ) throws IOException , InterruptedException { final int numFiles = _NUM _NUM ; long fileLen = blockSize * _NUM ; HdfsFileStatus fStatus ; FSDataInputStream stm ; String trg = _STR ) ; int sFileLen = _NUM _NUM ; DFSTestUtil . createFile ( dfs , smallFile , sFileLen , REPL _ FACTOR , _NUM ) ; dfs . concat ( trgPath , new Path [ ] { smallFile } ) ; fStatus = nn . getFileInfo ( trg ) ; new length trgLen = fStatus . getLen ( ) ; check number of blocks trgBlocks = nn . getBlockLocations ( trg , _NUM , trgLen ) . locatedBlockCount ( ) ; assertEquals ( trgBlocks , totalBlocks + _NUM ) ; and length assertEquals ( trgLen , totalLen + sFileLen ) ; } 
5485	public void init ( CmsDbContext dbc , CmsConfigurationManager configurationManager , List < String > successiveDrivers , CmsDriverManager driverManager ) { CmsParameterConfiguration configuration = configurationManager . getConfiguration ( ) ; String poolUrl = configuration . get ( _STR ) ; m _ sqlManager = initSqlManager ( classname ) ; m _ sqlManager . init ( I _ CmsProjectDriver . DRIVER _ TYPE _ ID , poolUrl ) ; m _ driverManager = driverManager ; if ( CmsLog . INIT . isInfoEnabled ( ) ) { CmsLog . INIT . info ( Messages . get ( ) . getBundle ( ) . key ( Messages . INIT _ ASSIGNED _ POOL _ _NUM , poolUrl ) ) ; } if ( ( successiveDrivers ! = null ) & & ! successiveDrivers . isEmpty ( ) ) { if ( LOG . isWarnEnabled ( ) ) { LOG . warn ( Messages . get ( ) . getBundle ( ) . key ( Messages . LOG _ SUCCESSIVE _ DRIVERS _ UNSUPPORTED _ _NUM , getClass ( ) . getName ( ) ) ) ; } } } 
5486	public RectangleEdge getDomainAxisEdge ( int index ) { AxisLocation location = getDomainAxisLocation ( index ) ; RectangleEdge result = Plot . resolveDomainAxisLocation ( location , this . orientation ) ; if ( result = = null ) { result = RectangleEdge . opposite ( getDomainAxisEdge ( ) ) ; } return result ; } 
5487	public void releaseAccess ( long sessionId , long blockId ) { try ( LockResource lr = new LockResource ( mLock ) ) { Key key = new Key ( sessionId , blockId ) ; if ( ! mBlocks . containsKey ( key ) ) { LOG . warn ( _STR , blockId , sessionId ) ; } mBlocks . remove ( key ) ; Set < Long > blockIds = mSessionIdToBlockIds . get ( sessionId ) ; if ( blockIds ! = null ) { blockIds . remove ( blockId ) ; if ( blockIds . isEmpty ( ) ) { mSessionIdToBlockIds . remove ( sessionId ) ; } } Set < Long > sessionIds = mBlockIdToSessionIds . get ( blockId ) ; if ( sessionIds ! = null ) { sessionIds . remove ( sessionId ) ; if ( sessionIds . isEmpty ( ) ) { mBlockIdToSessionIds . remove ( blockId ) ; } } } } 
5488	public synchronized void close ( ) { if ( closed ) { return ; } LogLog . debug ( _STR ) ; } 
5489	public static RequestAsyncTask executePostRequestAsync ( Session session , String graphPath , GraphObject graphObject , Callback callback ) { return newPostRequest ( session , graphPath , graphObject , callback ) . executeAsync ( ) ; } 
5490	public void testOnlineSnapshotAppendIndependent ( ) throws Exception { createAndCloneSnapshot ( true ) ; runTestSnapshotAppendIndependent ( ) ; } 
5491	boolean restoreSession ( int sessionId , int uid , @ NonNull IBinder activityToken , @ NonNull IBinder appCallback ) { final Session session = mSessions . get ( sessionId ) ; if ( session = = null | | uid ! = session . uid ) { return false ; } else { session . switchActivity ( activityToken , appCallback ) ; return true ; } } 
5492	public static int write ( final OutputStream out , final long type , final Object value , final int codepage ) throws IOException , WritingNotSupportedException { int length = - _NUM ; switch ( ( int ) type ) { case Variant . VT _ BOOL : { if ( value instanceof Boolean ) { int bb = ( ( Boolean ) value ) ? _NUM xff : _NUM x _NUM _NUM ; out . write ( bb ) ; out . write ( bb ) ; length = _NUM ; } break ; } case Variant . VT _ LPSTR : if ( value instanceof String ) { CodePageString codePageString = new CodePageString ( ) ; codePageString . setJavaValue ( ( String ) value , codepage ) ; length = codePageString . write ( out ) ; } break ; case Variant . VT _ LPWSTR : if ( value instanceof String ) { UnicodeString uniString = new UnicodeString ( ) ; uniString . setJavaValue ( ( String ) value ) ; length = uniString . write ( out ) ; } break ; case Variant . VT _ CF : if ( value instanceof byte [ ] ) { final byte [ ] cf = ( byte [ ] ) value ; out . write ( cf ) ; length = cf . length ; } break ; case Variant . VT _ EMPTY : LittleEndian . putUInt ( Variant . VT _ EMPTY , out ) ; length = LittleEndianConsts . INT _ SIZE ; break ; case Variant . VT _ I _NUM : if ( value instanceof Number ) { LittleEndian . putShort ( out , ( ( Number ) value ) . shortValue ( ) ) ; length = LittleEndianConsts . SHORT _ SIZE ; } break ; case Variant . VT _ UI _NUM : if ( value instanceof Number ) { LittleEndian . putUShort ( ( ( Number ) value ) . intValue ( ) , out ) ; length = LittleEndianConsts . SHORT _ SIZE ; } break ; case Variant . VT _ I _NUM : if ( value instanceof Number ) { LittleEndian . putInt ( ( ( Number ) value ) . intValue ( ) , out ) ; length = LittleEndianConsts . INT _ SIZE ; } break ; case Variant . VT _ UI _NUM : if ( value instanceof Number ) { LittleEndian . putUInt ( ( ( Number ) value ) . longValue ( ) , out ) ; length = LittleEndianConsts . INT _ SIZE ; } break ; case Variant . VT _ I _NUM : if ( value instanceof Number ) { LittleEndian . putLong ( ( ( Number ) value ) . longValue ( ) , out ) ; length = LittleEndianConsts . LONG _ SIZE ; } break ; case Variant . VT _ UI _NUM : { if ( value instanceof Number ) { BigInteger bi = ( value instanceof BigInteger ) ? ( BigInteger ) value : BigInteger . valueOf ( ( ( Number ) value ) . longValue ( ) ) ; if ( bi . bitLength ( ) > _NUM _NUM ) { throw new WritingNotSupportedException ( type , value ) ; } byte [ ] biBytesBE = bi . toByteArray ( ) , biBytesLE = new byte [ LittleEndianConsts . LONG _ SIZE ] ; int i = biBytesBE . length ; for ( byte b : biBytesBE ) { if ( i < = LittleEndianConsts . LONG _ SIZE ) { biBytesLE [ i - _NUM ] = b ; } i - - ; } out . write ( biBytesLE ) ; length = LittleEndianConsts . LONG _ SIZE ; } break ; } case Variant . VT _ R _NUM : { if ( value instanceof Number ) { int floatBits = Float . floatToIntBits ( ( ( Number ) value ) . floatValue ( ) ) ; LittleEndian . putInt ( floatBits , out ) ; length = LittleEndianConsts . INT _ SIZE ; } break ; } case Variant . VT _ R _NUM : if ( value instanceof Number ) { LittleEndian . putDouble ( ( ( Number ) value ) . doubleValue ( ) , out ) ; length = LittleEndianConsts . DOUBLE _ SIZE ; } break ; case Variant . VT _ FILETIME : Filetime filetimeValue = ( value instanceof Date ) ? new Filetime ( ( Date ) value ) : new Filetime ( ) ; length = filetimeValue . write ( out ) ; break ; default : break ; } if ( length = = - _NUM ) { if ( value instanceof byte [ ] ) { final byte [ ] b = ( byte [ ] ) value ; out . write ( b ) ; length = b . length ; writeUnsupportedTypeMessage ( new WritingNotSupportedException ( type , value ) ) ; } else { throw new WritingNotSupportedException ( type , value ) ; } } int padding = ( _NUM - ( length & _NUM x _NUM ) ) & _NUM x _NUM ; out . write ( paddingBytes , _NUM , padding ) ; return length + padding ; } 
5493	JobQueueInfo getJobQueueInfo ( ) { JobQueueInfo queueInfo = new JobQueueInfo ( ) ; queueInfo . setQueueName ( name ) ; LOG . debug ( _STR + queueInfo . getQueueName ( ) ) ; queueInfo . setQueueState ( state . getStateName ( ) ) ; if ( schedulingInfo ! = null ) { queueInfo . setSchedulingInfo ( schedulingInfo . toString ( ) ) ; } if ( props ! = null ) { Create deep copy of properties . Properties newProps = new Properties ( ) ; for ( Object key : props . keySet ( ) ) { newProps . setProperty ( key . toString ( ) , props . getProperty ( key . toString ( ) ) ) ; } queueInfo . setProperties ( newProps ) ; } if ( children ! = null & & children . size ( ) > _NUM ) { List < JobQueueInfo > list = new ArrayList < JobQueueInfo > ( ) ; for ( Queue child : children ) { list . add ( child . getJobQueueInfo ( ) ) ; } queueInfo . setChildren ( list ) ; } return queueInfo ; } 
5494	public int getInt ( Symbol symbol , int defaultValue ) { if ( isUndef ( symbol ) ) return defaultValue ; Object obj = context . get ( symbol ) ; if ( obj instanceof String ) { return Integer . parseInt ( ( String ) obj ) ; } else if ( obj instanceof Integer ) { return ( ( Integer ) obj ) . intValue ( ) ; } else { throw new ARQException ( _STR + Lib . className ( obj ) ) ; } } 
5495	public < R > R acceptCall ( SqlVisitor < R > visitor , SqlCall call ) { for ( SqlNode operand : call . getOperandList ( ) ) { if ( operand = = null ) { continue ; } operand . accept ( visitor ) ; } return null ; } 
5496	private String translateMatch ( RexNode condition ) { Returns condition decomposed by OR List < RexNode > disjunctions = RelOptUtil . disjunctions ( condition ) ; if ( disjunctions . size ( ) = = _NUM ) { return translateAnd ( disjunctions . get ( _NUM ) ) ; } else { return translateOr ( disjunctions ) ; } } 
5497	public boolean dispatchTouchEvent ( MotionEvent event ) { If the event should be handled by accessibility focus first . if ( event . isTargetAccessibilityFocus ( ) ) { We don ' t have focus or no virtual descendant has it , do not handle the event . if ( ! isAccessibilityFocusedViewOrHost ( ) ) { return false ; } We have focus and got the event , then use normal event dispatch . event . setTargetAccessibilityFocus ( false ) ; } boolean result = false ; if ( mInputEventConsistencyVerifier ! = null ) { mInputEventConsistencyVerifier . onTouchEvent ( event , _NUM ) ; } final int actionMasked = event . getActionMasked ( ) ; if ( actionMasked = = MotionEvent . ACTION _ DOWN ) { Defensive cleanup for new gesture stopNestedScroll ( ) ; } if ( onFilterTouchEventForSecurity ( event ) ) { if ( ( mViewFlags & ENABLED _ MASK ) = = ENABLED & & handleScrollBarDragging ( event ) ) { result = true ; } noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo ; if ( li ! = null & & li . mOnTouchListener ! = null & & ( mViewFlags & ENABLED _ MASK ) = = ENABLED & & li . mOnTouchListener . onTouch ( this , event ) ) { result = true ; } if ( ! result & & onTouchEvent ( event ) ) { result = true ; } } if ( ! result & & mInputEventConsistencyVerifier ! = null ) { mInputEventConsistencyVerifier . onUnhandledEvent ( event , _NUM ) ; } of the gesture . if ( actionMasked = = MotionEvent . ACTION _ UP | | actionMasked = = MotionEvent . ACTION _ CANCEL | | ( actionMasked = = MotionEvent . ACTION _ DOWN & & ! result ) ) { stopNestedScroll ( ) ; } return result ; } 
5498	public ListView getListView ( ) { ensureList ( ) ; return mList ; } 
5499	public String getHook ( String noteId , String event ) { InterpreterHookRegistry hooks = interpreterGroup . getInterpreterHookRegistry ( ) ; String className = getClassName ( ) ; return hooks . get ( noteId , className , event ) ; } 
5500	public long readCheckpoint ( AggregationTaskRunner . AGGREGATOR _ NAME aggregatorName ) { String path = getCheckpointZKPath ( aggregatorName ) ; LOG . debug ( _STR + checkpoint ) ; return checkpoint ; } 
5501	public void asFilesRename _ AllowOverwrite _ MultipleFiles _ AllOutputFilesDoNotExist ( ) throws IOException { set up File sourceFile = new File ( _STR ) ; File fileThatDoesntExist _NUM = makeRenamedFile ( originalFile _NUM , rename ) ; File fileThatDoesntExist _NUM = makeRenamedFile ( originalFile _NUM , rename ) ; copy the image to a temporary file . TestUtils . copyFile ( sourceFile , originalFile _NUM ) ; TestUtils . copyFile ( sourceFile , originalFile _NUM ) ; given when List < File > list = Thumbnails . of ( originalFile _NUM , originalFile _NUM ) . size ( _NUM _NUM _NUM , _NUM _NUM _NUM ) . allowOverwrite ( true ) . asFiles ( rename ) ; then assertTrue ( fileThatDoesntExist _NUM . exists ( ) ) ; assertTrue ( fileThatDoesntExist _NUM . exists ( ) ) ; assertEquals ( Arrays . asList ( fileThatDoesntExist _NUM , fileThatDoesntExist _NUM ) , list ) ; clean up originalFile _NUM . delete ( ) ; originalFile _NUM . delete ( ) ; fileThatDoesntExist _NUM . delete ( ) ; fileThatDoesntExist _NUM . delete ( ) ; } 
5502	public double getCloseValue ( int series , int item ) { double result = Double . NaN ; Number close = getClose ( series , item ) ; if ( close ! = null ) { result = close . doubleValue ( ) ; } return result ; } 
5503	public Builder after ( long delay ) { setup dummy ValueAnimator just to run the clock ValueAnimator anim = ValueAnimator . ofFloat ( _NUM f , _NUM f ) ; anim . setDuration ( delay ) ; after ( anim ) ; return this ; } 
5504	private static String getProcCmdLine ( ) { String cmdline = _STR + cmdline ) ; return cmdline ; } 
5505	public void setWidthByPercent ( @ FloatRange ( from = _NUM , to = _NUM ) float percent ) { setWidth ( ( int ) ( screenWidth * percent ) ) ; } 
5506	public static Term findFocusTerm ( Tree tree ) { try { Tree t = findFocusNode ( tree ) ; if ( t ! = null ) { Term res = new Term ( _NUM , _NUM , TreeHelper . getLeaves ( t ) ) ; res . setPOS ( t . getLabel ( ) ) ; return res ; } return null ; } catch ( Exception e ) { e . printStackTrace ( ) ; return null ; } } 
5507	public void authenticate ( @ NonNull String username , @ NonNull String password ) throws GpodnetServiceException { URL url ; try { url = new URI ( BASE _ SCHEME , BASE _ HOST , String . format ( _STR ) ; Request . Builder request = new Request . Builder ( ) . url ( url ) . post ( body ) ; executeRequestWithAuthentication ( request , username , password ) ; } 
5508	private Expression caseWhenExpression ( ) throws SQLSyntaxErrorException { Expression comparee = null ; if ( lexer . token ( ) ! = KW _ WHEN ) { comparee = expression ( ) ; } List < Pair < Expression , Expression > > list = new LinkedList < Pair < Expression , Expression > > ( ) ; for ( ; lexer . token ( ) = = KW _ WHEN ; ) { lexer . nextToken ( ) ; Expression when = expression ( ) ; match ( KW _ THEN ) ; Expression then = expression ( ) ; if ( when = = null | | then = = null ) throw err ( _STR ) ; } return new CaseWhenOperatorExpression ( comparee , list , elseValue ) . setCacheEvalRst ( cacheEvalRst ) ; } 
5509	public void testParallelGenerate ( ) throws InterruptedException { AtomicInteger control = new AtomicInteger ( - _NUM ) ; Set < Long > uidSet = new ConcurrentSkipListSet < > ( ) ; Initialize threads List < Thread > threadList = new ArrayList < > ( THREADS ) ; for ( int i = _NUM ; i < THREADS ; i + + ) { Thread thread = new Thread ( ( ) - > workerRun ( uidSet , control ) ) ; thread . setName ( _STR + i ) ; threadList . add ( thread ) ; thread . start ( ) ; } Wait for worker done for ( Thread thread : threadList ) { thread . join ( ) ; } Check generate _NUM _NUM w times Assert . assertEquals ( SIZE , control . get ( ) ) ; Check UIDs are all unique checkUniqueID ( uidSet ) ; } 
5510	public void cancelImmediately ( ) { cancel ( false ) ; } 
5511	public static boolean test ( TransposeDataList transposeDataList , boolean is _ twoTailed , double aLevel ) { int k = transposeDataList . size ( ) ; if ( k ! = _NUM ) { throw new IllegalArgumentException ( _STR ) ; } int rank = _NUM ; for ( Double value : allUniqueValues ) { Object objValue = value ; if ( ! transposeDataList . get ( keyj ) . contains ( objValue ) ) { if this is a missing value add the probability that matches the previous rank distributionAndValue _NUM Probability . put _NUM d ( keyj , objValue , ( rank - _NUM . _NUM ) / nj ) ; continue ; } if ( distributionAndValue _NUM Probability . get _NUM d ( keyj , objValue ) = = null ) { keeps the lowest probability in case of ties distributionAndValue _NUM Probability . put _NUM d ( keyj , objValue , ( double ) rank / nj ) ; } + + rank ; } } allUniqueValues = null ; double maxDelta = _NUM . _NUM ; for ( Object key : distributionAndValue _NUM Probability . get ( keys [ _NUM ] ) . keySet ( ) ) { get the _NUM probabilities from the _NUM dataTables and find max delta double v _NUM = distributionAndValue _NUM Probability . get ( keys [ _NUM ] ) . getDouble ( key ) ; double v _NUM = distributionAndValue _NUM Probability . get ( keys [ _NUM ] ) . getDouble ( key ) ; double delta = Math . abs ( v _NUM - v _NUM ) ; if ( delta > maxDelta ) { maxDelta = delta ; } } distributionAndValue _NUM Probability = null ; int n _NUM = transposeDataList . get ( keys [ _NUM ] ) . size ( ) ; int n _NUM = transposeDataList . get ( keys [ _NUM ] ) . size ( ) ; keys = null ; boolean rejectH _NUM = checkCriticalValue ( maxDelta , is _ twoTailed , n _NUM , n _NUM , aLevel ) ; return rejectH _NUM ; } 
5512	private void checkAndFixConsistency ( ) throws IOException , KeeperException , InterruptedException { Divide the checks in two phases . One for default / primary replicas and another for the non - primary ones . Keeps code cleaner this way . List < CheckRegionConsistencyWorkItem > workItems = new ArrayList < > ( regionInfoMap . size ( ) ) ; for ( java . util . Map . Entry < String , HbckInfo > e : regionInfoMap . entrySet ( ) ) { if ( e . getValue ( ) . getReplicaId ( ) = = RegionInfo . DEFAULT _ REPLICA _ ID ) { workItems . add ( new CheckRegionConsistencyWorkItem ( e . getKey ( ) , e . getValue ( ) ) ) ; } } checkRegionConsistencyConcurrently ( workItems ) ; boolean prevHdfsCheck = shouldCheckHdfs ( ) ; replicas don ' t have any hdfs data setCheckHdfs ( false ) ; Run a pass over the replicas and fix any assignment issues that exist on the currently deployed / undeployed replicas . List < CheckRegionConsistencyWorkItem > replicaWorkItems = new ArrayList < > ( regionInfoMap . size ( ) ) ; for ( java . util . Map . Entry < String , HbckInfo > e : regionInfoMap . entrySet ( ) ) { if ( e . getValue ( ) . getReplicaId ( ) ! = RegionInfo . DEFAULT _ REPLICA _ ID ) { replicaWorkItems . add ( new CheckRegionConsistencyWorkItem ( e . getKey ( ) , e . getValue ( ) ) ) ; } } checkRegionConsistencyConcurrently ( replicaWorkItems ) ; setCheckHdfs ( prevHdfsCheck ) ; If some regions is skipped during checkRegionConsistencyConcurrently ( ) phase , we might not get accurate state of the hbase if continuing . The config here allows users to tune the tolerance of number of skipped region . TODO : evaluate the consequence to continue the hbck operation without config . int terminateThreshold = getConf ( ) . getInt ( _STR ) ; } if ( shouldCheckHdfs ( ) ) { checkAndFixTableStates ( ) ; } } 
5513	public boolean pressKeyCode ( int keyCode ) { Tracer . trace ( keyCode ) ; waitForIdle ( ) ; return getAutomatorBridge ( ) . getInteractionController ( ) . sendKey ( keyCode , _NUM ) ; } 
5514	public static JobLauncher newJobLauncher ( Properties sysProps , Properties jobProps , String launcherTypeValue , SharedResourcesBroker < GobblinScopeTypes > instanceBroker ) { Optional < JobLauncherType > launcherType = Enums . getIfPresent ( JobLauncherType . class , launcherTypeValue ) ; try { if ( launcherType . isPresent ( ) ) { switch ( launcherType . get ( ) ) { case LOCAL : return new LocalJobLauncher ( JobConfigurationUtils . combineSysAndJobProperties ( sysProps , jobProps ) , instanceBroker ) ; case MAPREDUCE : return new MRJobLauncher ( JobConfigurationUtils . combineSysAndJobProperties ( sysProps , jobProps ) , instanceBroker ) ; default : throw new RuntimeException ( _STR + e , e ) ; } } 
5515	public boolean equals ( Object obj ) { if ( obj = = this ) { return true ; } if ( ! ( obj instanceof TimePeriodValues ) ) { return false ; } if ( ! super . equals ( obj ) ) { return false ; } TimePeriodValues that = ( TimePeriodValues ) obj ; if ( ! ObjectUtilities . equal ( this . getDomainDescription ( ) , that . getDomainDescription ( ) ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . getRangeDescription ( ) , that . getRangeDescription ( ) ) ) { return false ; } int count = getItemCount ( ) ; if ( count ! = that . getItemCount ( ) ) { return false ; } for ( int i = _NUM ; i < count ; i + + ) { if ( ! getDataItem ( i ) . equals ( that . getDataItem ( i ) ) ) { return false ; } } return true ; } 
5516	public void write ( File file ) throws IOException { InterpreterResultMessageOutput out = getCurrentOutputForWriting ( ) ; out . write ( file ) ; } 
5517	public static final void removeSelection ( Spannable text ) { text . removeSpan ( SELECTION _ START ) ; text . removeSpan ( SELECTION _ END ) ; } 
5518	private void writeObject ( ObjectOutputStream stream ) throws IOException { stream . defaultWriteObject ( ) ; stream . writeInt ( this . store . size ( ) ) ; Set keys = this . store . keySet ( ) ; Iterator iterator = keys . iterator ( ) ; while ( iterator . hasNext ( ) ) { Comparable key = ( Comparable ) iterator . next ( ) ; stream . writeObject ( key ) ; Stroke stroke = getStroke ( key ) ; SerialUtilities . writeStroke ( stroke , stream ) ; } } 
5519	public static Result [ ] doSearch ( Query [ ] queries ) { results = new ArrayList < Result > ( ) ; pending = _NUM ; System . out . println ( _STR + queries . length ) ; send only the first query to the KnowledgeAnnotators if ( queries . length > _NUM ) queryKAs ( queries [ _NUM ] ) ; send all queries to the KnowledgeMiners for ( Query query : queries ) queryKMs ( query ) ; wait until all queries have been completed waitForResults ( ) ; drop duplicates among results from KnowledgeMiners results = dropDuplicates ( results ) ; return results . toArray ( new Result [ results . size ( ) ] ) ; } 
5520	protected void onStart ( ) { super . onStart ( ) ; mStopped = false ; mReallyStopped = false ; mHandler . removeMessages ( MSG _ REALLY _ STOPPED ) ; if ( ! mCreated ) { mCreated = true ; mFragments . dispatchActivityCreated ( ) ; } mFragments . noteStateNotSaved ( ) ; mFragments . execPendingActions ( ) ; if ( ! mLoadersStarted ) { mLoadersStarted = true ; if ( mLoaderManager ! = null ) { mLoaderManager . doStart ( ) ; } else if ( ! mCheckedForLoaderManager ) { mLoaderManager = getLoaderManager ( null , mLoadersStarted , false ) ; the returned loader manager may be a new one , so we have to start it if ( ( mLoaderManager ! = null ) & & ( ! mLoaderManager . mStarted ) ) { mLoaderManager . doStart ( ) ; } } mCheckedForLoaderManager = true ; } NOTE : HC onStart goes here . mFragments . dispatchStart ( ) ; if ( mAllLoaderManagers ! = null ) { LoaderManagerImpl [ ] loaders = new LoaderManagerImpl [ mAllLoaderManagers . size ( ) ] ; mAllLoaderManagers . values ( ) . toArray ( loaders ) ; if ( loaders ! = null ) { for ( int i = _NUM ; i < loaders . length ; i + + ) { LoaderManagerImpl lm = loaders [ i ] ; lm . finishRetain ( ) ; lm . doReportStart ( ) ; } } } } 
5521	private static void sendNotModified ( ChannelHandlerContext ctx ) { FullHttpResponse response = new DefaultFullHttpResponse ( HTTP _ _NUM _ _NUM , NOT _ MODIFIED ) ; setDateHeader ( response ) ; Close the connection as soon as the error message is sent . ctx . writeAndFlush ( response ) . addListener ( ChannelFutureListener . CLOSE ) ; } 
5522	public static void main ( String [ ] args ) { indicates progress when reading large maps ( for testing only ) Logger . getLogger ( _STR ) . getHandlers ( ) [ _NUM ] . setLevel ( Level . FINE ) ; Locale . setDefault ( Locale . US ) ; OsmViewerPlusApp demo = new OsmViewerPlusApp ( args ) ; demo . getFrame ( ) . readMap ( DataResource . getUlmFileResource ( ) ) ; demo . showFrame ( ) ; } 
5523	public void copyData ( Path input , FSDataInputStream fsin , FSDataOutputStream fout , Reporter reporter ) throws IOException { try { for ( int cbread = _NUM ; ( cbread = fsin . read ( buffer ) ) > = _NUM ; ) { fout . write ( buffer , _NUM , cbread ) ; reporter . progress ( ) ; } } finally { fsin . close ( ) ; } } 
5524	public Span [ ] find ( String [ ] tokens , String [ ] [ ] additionalContext ) { additionalContextFeatureGenerator . setCurrentContext ( additionalContext ) ; bestSequence = model . bestSequence ( tokens , additionalContext , contextGenerator , sequenceValidator ) ; List < String > c = bestSequence . getOutcomes ( ) ; contextGenerator . updateAdaptiveData ( tokens , c . toArray ( new String [ c . size ( ) ] ) ) ; Span [ ] spans = seqCodec . decode ( c ) ; spans = setProbs ( spans ) ; return spans ; } 
5525	public List < Integer > getKeysSorted ( ) { List < Integer > keyList = new ArrayList < > ( ) ; for ( int key : keys ) { if ( key > = _NUM ) { keyList . add ( key ) ; } } Collections . sort ( keyList ) ; return keyList ; } 
5526	private void pauseAutoCycle ( ) { if ( mCycling ) { mCycleTimer . cancel ( ) ; mCycleTask . cancel ( ) ; mCycling = false ; } else { if ( mResumingTimer ! = null & & mResumingTask ! = null ) { recoverCycle ( ) ; } } } 
5527	void addToDisappearedInLayout ( ViewHolder holder ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record = = null ) { record = InfoRecord . obtain ( ) ; mLayoutHolderMap . put ( holder , record ) ; } record . flags | = FLAG _ DISAPPEARED ; } 
5528	public boolean seekToLastRow ( ) throws IOException { if ( closed ) { return false ; } Cell higherCell = segment . isEmpty ( ) ? null : segment . last ( ) ; if ( higherCell = = null ) { return false ; } Cell firstCellOnLastRow = PrivateCellUtil . createFirstOnRow ( higherCell ) ; if ( seek ( firstCellOnLastRow ) ) { return true ; } else { return seekToPreviousRow ( higherCell ) ; } } 
5529	public boolean isUndef ( Symbol property ) { return ! isDefined ( property ) ; } 
5530	public void setVisible ( boolean visible ) { if ( visible ) { if ( mOwnerView . getWindowToken ( ) = = null ) { if ( ! mHandler . hasMessages ( MSG _ POST _ SET _ VISIBLE ) ) { mHandler . sendEmptyMessage ( MSG _ POST _ SET _ VISIBLE ) ; } return ; } dismissControlsDelayed ( ZOOM _ CONTROLS _ TIMEOUT ) ; } if ( mIsVisible = = visible ) { return ; } mIsVisible = visible ; if ( visible ) { if ( mContainerLayoutParams . token = = null ) { mContainerLayoutParams . token = mOwnerView . getWindowToken ( ) ; } mWindowManager . addView ( mContainer , mContainerLayoutParams ) ; if ( mPostedVisibleInitializer = = null ) { mPostedVisibleInitializer = new Runnable ( ) { public void run ( ) { refreshPositioningVariables ( ) ; if ( mCallback ! = null ) { mCallback . onVisibilityChanged ( true ) ; } } } ; } mHandler . post ( mPostedVisibleInitializer ) ; Handle configuration changes when visible mContext . registerReceiver ( mConfigurationChangedReceiver , mConfigurationChangedFilter ) ; Steal touches events from the owner mOwnerView . setOnTouchListener ( this ) ; mReleaseTouchListenerOnUp = false ; } else { Don ' t want to steal any more touches if ( mTouchTargetView ! = null ) { We are still stealing the touch events for this touch sequence , so release the touch listener later mReleaseTouchListenerOnUp = true ; } else { mOwnerView . setOnTouchListener ( null ) ; } No longer care about configuration changes mContext . unregisterReceiver ( mConfigurationChangedReceiver ) ; mWindowManager . removeViewImmediate ( mContainer ) ; mHandler . removeCallbacks ( mPostedVisibleInitializer ) ; if ( mCallback ! = null ) { mCallback . onVisibilityChanged ( false ) ; } } } 
5531	public Map < String , String [ ] > addParameterMap ( Map < String , String [ ] > map ) { if ( map = = null ) { return m _ parameters ; } if ( ( m _ parameters = = null ) | | ( m _ parameters . size ( ) = = _NUM ) ) { m _ parameters = Collections . unmodifiableMap ( map ) ; } else { Map < String , String [ ] > parameters = new HashMap < String , String [ ] > ( ) ; parameters . putAll ( m _ parameters ) ; Iterator < Map . Entry < String , String [ ] > > it = map . entrySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { Map . Entry < String , String [ ] > entry = it . next ( ) ; String key = entry . getKey ( ) ; Check if the parameter name ( key ) exists if ( parameters . containsKey ( key ) ) { String [ ] oldValues = parameters . get ( key ) ; String [ ] newValues = entry . getValue ( ) ; String [ ] mergeValues = new String [ oldValues . length + newValues . length ] ; System . arraycopy ( newValues , _NUM , mergeValues , _NUM , newValues . length ) ; System . arraycopy ( oldValues , _NUM , mergeValues , newValues . length , oldValues . length ) ; parameters . put ( key , mergeValues ) ; } else { No : Add new value array parameters . put ( key , entry . getValue ( ) ) ; } } m _ parameters = Collections . unmodifiableMap ( parameters ) ; } return m _ parameters ; } 
5532	public static Set < Method > getOverrideHierarchy ( final Method method , final Interfaces interfacesBehavior ) { Validate . notNull ( method ) ; final Set < Method > result = new LinkedHashSet < > ( ) ; result . add ( method ) ; final Class < ? > [ ] parameterTypes = method . getParameterTypes ( ) ; final Class < ? > declaringClass = method . getDeclaringClass ( ) ; final Iterator < Class < ? > > hierarchy = ClassUtils . hierarchy ( declaringClass , interfacesBehavior ) . iterator ( ) ; skip the declaring class : P hierarchy . next ( ) ; hierarchyTraversal : while ( hierarchy . hasNext ( ) ) { final Class < ? > c = hierarchy . next ( ) ; final Method m = getMatchingAccessibleMethod ( c , method . getName ( ) , parameterTypes ) ; if ( m = = null ) { continue ; } if ( Arrays . equals ( m . getParameterTypes ( ) , parameterTypes ) ) { matches without generics result . add ( m ) ; continue ; } necessary to get arguments every time in the case that we are including interfaces final Map < TypeVariable < ? > , Type > typeArguments = TypeUtils . getTypeArguments ( declaringClass , m . getDeclaringClass ( ) ) ; for ( int i = _NUM ; i < parameterTypes . length ; i + + ) { final Type childType = TypeUtils . unrollVariables ( typeArguments , method . getGenericParameterTypes ( ) [ i ] ) ; final Type parentType = TypeUtils . unrollVariables ( typeArguments , m . getGenericParameterTypes ( ) [ i ] ) ; if ( ! TypeUtils . equals ( childType , parentType ) ) { continue hierarchyTraversal ; } } result . add ( m ) ; } return result ; } 
5533	private Map < String , String > createMapFromValue ( String value ) { if ( value = = null ) { return null ; } List < String > entries = createListFromValue ( value ) ; Iterator < String > i = entries . iterator ( ) ; Map < String , String > result = new HashMap < String , String > ( entries . size ( ) ) ; boolean rebuildDelimiters = false ; if ( value . indexOf ( VALUE _ MAP _ DELIMITER _ REPLACEMENT ) ! = - _NUM ) { rebuildDelimiters = true ; } while ( i . hasNext ( ) ) { String entry = i . next ( ) ; int index = entry . indexOf ( VALUE _ MAP _ DELIMITER ) ; if ( index ! = - _NUM ) { String key = entry . substring ( _NUM , index ) ; String val = _STR ; if ( ( index + _NUM ) < entry . length ( ) ) { val = entry . substring ( index + _NUM ) ; } if ( CmsStringUtil . isNotEmpty ( key ) ) { if ( rebuildDelimiters ) { key = rebuildDelimiter ( key , VALUE _ MAP _ DELIMITER , VALUE _ MAP _ DELIMITER _ REPLACEMENT ) ; val = rebuildDelimiter ( val , VALUE _ MAP _ DELIMITER , VALUE _ MAP _ DELIMITER _ REPLACEMENT ) ; } result . put ( key , val ) ; } } } return result ; } 
5534	public synchronized String exec ( @ NotNull String command ) throws GhcModiError { if ( ! enabled ) { return null ; } if ( path = = null ) { return null ; } if ( ! validateGhcVersion ( ) ) { return null ; } if ( process = = null ) { spawnProcess ( ) ; } if ( output = = null ) { throw new InitError ( _STR ) ; } return interact ( command , input , output ) ; } 
5535	public String [ ] getOptions ( ) { String [ ] options = new String [ _NUM ] ; int current = _NUM ; if ( getBinaryAttributesNominal ( ) ) { options [ current + + ] = _STR ; } return options ; } 
5536	public void setSectionOutlinesVisible ( boolean visible ) { this . sectionOutlinesVisible = visible ; fireChangeEvent ( ) ; } 
5537	public void setForegroundAt ( int index , Color foreground ) { getExtendedPage ( index ) . setForeground ( foreground ) ; firePropertyChange ( _STR , null , new Integer ( index ) ) ; } 
5538	public void getAndMergeHostConfigAttributes ( Map < String , Map < String , Map < String , String > > > configurationAttributes , Map < String , Map < String , String > > configurationTags , Cluster cluster ) { if ( null ! = configurationTags & & ! configurationTags . isEmpty ( ) ) { Map < String , Map < String , Map < String , String > > > configAttributes = getEffectiveConfigAttributes ( cluster , configurationTags ) ; for ( Map . Entry < String , Map < String , Map < String , String > > > attributesOccurrence : configAttributes . entrySet ( ) ) { String type = attributesOccurrence . getKey ( ) ; Map < String , Map < String , String > > attributes = attributesOccurrence . getValue ( ) ; if ( configurationAttributes ! = null ) { if ( ! configurationAttributes . containsKey ( type ) ) { configurationAttributes . put ( type , new TreeMap < > ( ) ) ; } cloneAttributesMap ( attributes , configurationAttributes . get ( type ) ) ; } } } } 
5539	public static FileA _NUM D createFromAsset ( RenderScript rs , AssetManager mgr , String path ) { rs . validate ( ) ; long fileId = rs . nFileA _NUM DCreateFromAsset ( mgr , path ) ; if ( fileId = = _NUM ) { throw new RSRuntimeException ( _STR + path ) ; } FileA _NUM D fa _NUM d = new FileA _NUM D ( fileId , rs , null ) ; fa _NUM d . initEntries ( ) ; return fa _NUM d ; } 
5540	public int addMergedRegionUnsafe ( CellRangeAddress region ) { return addMergedRegion ( region , false ) ; } 
5541	void schedule ( int delayMillis ) { if ( mIsPending ) { Log . e ( LOG _ TAG , _STR ) ; flush ( ) ; } mIsPending = true ; mTextView . postDelayed ( this , delayMillis ) ; } 
5542	public static String createQueryString ( Map < String , String > options , String ampersand , boolean encode ) throws URISyntaxException { try { if ( options . size ( ) > _NUM ) { StringBuilder rc = new StringBuilder ( ) ; boolean first = true ; for ( Object o : options . keySet ( ) ) { if ( first ) { first = false ; } else { rc . append ( ampersand ) ; } String key = ( String ) o ; Object value = options . get ( key ) ; use the value as a String String s = value ! = null ? value . toString ( ) : null ; appendQueryStringParameter ( key , s , rc , encode ) ; } return rc . toString ( ) ; } else { return _STR ) ; se . initCause ( e ) ; throw se ; } } 
5543	public void testMultipleCallsToReadFieldsAreSafe ( ) throws Exception { Create an instance and add a key / value . MapWritable m = new MapWritable ( ) ; final Text t = new Text ( getName ( ) ) ; m . put ( t , t ) ; Get current size of map . Key values are ' t ' . int count = m . size ( ) ; Now serialize . . . save off the bytes . ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; DataOutputStream dos = new DataOutputStream ( baos ) ; m . write ( dos ) ; dos . close ( ) ; Now add new values to the MapWritable . m . put ( new Text ( _STR ) ) ; Now deserialize the original MapWritable . Ensure count and key values match original state . ByteArrayInputStream bais = new ByteArrayInputStream ( baos . toByteArray ( ) ) ; DataInputStream dis = new DataInputStream ( bais ) ; m . readFields ( dis ) ; assertEquals ( count , m . size ( ) ) ; assertTrue ( m . get ( t ) . equals ( t ) ) ; dis . close ( ) ; } 
5544	public void addFocusables ( ArrayList < View > views , int direction , int focusableMode ) { final int focusableCount = views . size ( ) ; final int descendantFocusability = getDescendantFocusability ( ) ; if ( descendantFocusability ! = FOCUS _ BLOCK _ DESCENDANTS ) { for ( int i = _NUM ; i < getChildCount ( ) ; i + + ) { final View child = getChildAt ( i ) ; if ( child . getVisibility ( ) = = VISIBLE ) { ItemInfo ii = infoForChild ( child ) ; if ( ii ! = null & & ii . position = = mCurItem ) { child . addFocusables ( views , direction , focusableMode ) ; } } } } among the focusable children would be more interesting . if ( descendantFocusability ! = FOCUS _ AFTER _ DESCENDANTS | | No focusable descendants ( focusableCount = = views . size ( ) ) ) { add all views in . So we need to do the same thing View does . if ( ! isFocusable ( ) ) { return ; } if ( ( focusableMode & FOCUSABLES _ TOUCH _ MODE ) = = FOCUSABLES _ TOUCH _ MODE & & isInTouchMode ( ) & & ! isFocusableInTouchMode ( ) ) { return ; } if ( views ! = null ) { views . add ( this ) ; } } } 
5545	public static XmlIDREFS newInstance ( org . apache . xmlbeans . XmlOptions options ) { return ( XmlIDREFS ) XmlBeans . getContextTypeLoader ( ) . newInstance ( type , options ) ; } 
5546	public void testRemoveXAttr ( ) throws Exception { FileSystem . mkdirs ( fs , path , FsPermission . createImmutable ( ( short ) _NUM _NUM _NUM _NUM ) ) ; fs . setXAttr ( path , name _NUM , value _NUM , EnumSet . of ( XAttrSetFlag . CREATE ) ) ; fs . setXAttr ( path , name _NUM , value _NUM , EnumSet . of ( XAttrSetFlag . CREATE ) ) ; fs . setXAttr ( path , name _NUM , null , EnumSet . of ( XAttrSetFlag . CREATE ) ) ; fs . removeXAttr ( path , name _NUM ) ; fs . removeXAttr ( path , name _NUM ) ; Map < String , byte [ ] > xattrs = fs . getXAttrs ( path ) ; Assert . assertEquals ( xattrs . size ( ) , _NUM ) ; Assert . assertArrayEquals ( new byte [ _NUM ] , xattrs . get ( name _NUM ) ) ; restart ( false ) ; initFileSystem ( ) ; xattrs = fs . getXAttrs ( path ) ; Assert . assertEquals ( xattrs . size ( ) , _NUM ) ; Assert . assertArrayEquals ( new byte [ _NUM ] , xattrs . get ( name _NUM ) ) ; restart ( true ) ; initFileSystem ( ) ; xattrs = fs . getXAttrs ( path ) ; Assert . assertEquals ( xattrs . size ( ) , _NUM ) ; Assert . assertArrayEquals ( new byte [ _NUM ] , xattrs . get ( name _NUM ) ) ; fs . removeXAttr ( path , name _NUM ) ; } 
5547	public static XmlName parse ( java . io . Reader r , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( XmlName ) XmlBeans . getContextTypeLoader ( ) . parse ( r , type , options ) ; } 
5548	private void updateConnection ( ) { Step _NUM . Stop scans if necessary to prevent interference while connected . Resume scans later when no longer attempting to connect . updateScanState ( ) ; have disconnected from the old one . if ( mRemoteDisplay ! = null & & mConnectedDevice ! = mDesiredDevice ) { Slog . i ( TAG , _STR + mConnectedDevice . deviceName ) ; mHandler . removeCallbacks ( mRtspTimeout ) ; handleConnectionFailure ( false ) ; } } } , mHandler , mContext . getOpPackageName ( ) ) ; Use extended timeout value for certification , as some tests require user inputs int rtspTimeout = mWifiDisplayCertMode ? RTSP _ TIMEOUT _ SECONDS _ CERT _ MODE : RTSP _ TIMEOUT _ SECONDS ; mHandler . postDelayed ( mRtspTimeout , rtspTimeout * _NUM _NUM _NUM _NUM ) ; } } 
5549	public void add ( Cell cell , boolean mslabUsed , MemStoreSizing memStoreSizing ) { internalAdd ( cell , mslabUsed , memStoreSizing ) ; } 
5550	public static Schema schema ( String allowedValues ) { return builder ( allowedValues ) . build ( ) ; } 
5551	public org . apache . drill . exec . proto . UserBitShared . RecordBatchDef . Builder getDefBuilder ( ) { bitField _NUM _ | = _NUM x _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM ; onChanged ( ) ; return getDefFieldBuilder ( ) . getBuilder ( ) ; } 
5552	public TimerAction queryTimerAction ( UUID timerActionId ) { TimerAction timerAction = null ; Connection conn = null ; PreparedStatement pstm = null ; ResultSet rst = null ; try { conn = DbPoolConnection . getInstance ( ) . getReadConnection ( ) ; pstm = conn . prepareStatement ( _STR ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { DbPoolConnection . getInstance ( ) . closeResultSet ( rst ) ; DbPoolConnection . getInstance ( ) . closeStatment ( pstm ) ; DbPoolConnection . getInstance ( ) . closeConn ( conn ) ; } return timerAction ; } 
5553	protected Vertex < I , V , E > addVertexIfDesired ( I vertexId , Vertex < I , V , E > vertex , VertexChanges < I , V , E > vertexChanges , boolean hasMessages ) { if ( vertex = = null ) { if ( hasVertexAdditions ( vertexChanges ) ) { vertex = vertexChanges . getAddedVertexList ( ) . get ( _NUM ) ; } else if ( ( hasMessages & & createVertexesOnMessages ) | | hasEdgeAdditions ( vertexChanges ) ) { vertex = getConf ( ) . createVertex ( ) ; vertex . initialize ( vertexId , getConf ( ) . createVertexValue ( ) ) ; } } else if ( hasVertexAdditions ( vertexChanges ) ) { LOG . warn ( _STR ) ; } return vertex ; } 
5554	public Byte getAsByte ( String key ) { Object value = mValues . get ( key ) ; try { return value ! = null ? ( ( Number ) value ) . byteValue ( ) : null ; } catch ( ClassCastException e ) { if ( value instanceof CharSequence ) { try { return Byte . valueOf ( value . toString ( ) ) ; } catch ( NumberFormatException e _NUM ) { Log . e ( TAG , _STR + value , e ) ; return null ; } } } 
5555	public void validate ( SignerInformationVerifier sigVerifier ) throws TSPException , TSPValidationException { if ( ! sigVerifier . hasAssociatedCertificate ( ) ) { throw new IllegalArgumentException ( _STR + e . getMessage ( ) , e ) ; } } 
5556	public ANode next ( ) throws QueryException { ANode n ; while ( ( n = iter . next ( ) ) ! = null & & ! nt . eq ( n ) ) qc . checkStop ( ) ; return n ; } } ; } 
5557	public void setStyle ( String value ) { setAttribute ( ATTR _ STYLE , value ) ; } 
5558	public double transProb ( ) { String debug = _STR ; double transProb = _NUM . _NUM ; in which case it should be in the nominal cache if ( m _ Cache . containsKey ( m _ Test . value ( m _ AttrIndex ) ) ) { KStarCache . TableEntry te = m _ Cache . getCacheValues ( m _ Test . value ( m _ AttrIndex ) ) ; m _ Stop = te . value ; m _ MissingProb = te . pmiss ; } else { generateAttrDistribution ( ) ; we have to compute the parameters if ( m _ BlendMethod = = B _ ENTROPY ) { m _ Stop = stopProbUsingEntropy ( ) ; } else { default is B _ SPHERE m _ Stop = stopProbUsingBlend ( ) ; } store the values in cache m _ Cache . store ( m _ Test . value ( m _ AttrIndex ) , m _ Stop , m _ MissingProb ) ; } we ' ve got our m _ Stop , then what ? if ( m _ Train . isMissing ( m _ AttrIndex ) ) { transProb = m _ MissingProb ; } else { try { transProb = ( _NUM . _NUM - m _ Stop ) / m _ Test . attribute ( m _ AttrIndex ) . numValues ( ) ; if ( ( int ) m _ Test . value ( m _ AttrIndex ) = = ( int ) m _ Train . value ( m _ AttrIndex ) ) { transProb + = m _ Stop ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } return transProb ; } 
5559	public void testIncBackupRestore ( ) throws Exception { int ADD _ ROWS = _NUM _NUM ; # _NUM - create full backup for all tables LOG . info ( _STR + table _NUM ) ; # _NUM - incremental backup for multiple tables incrementalBackupWithFailures ( ) ; admin . close ( ) ; conn . close ( ) ; } 
5560	public void testYearChoice ( ) throws Throwable { setKnownDate ( ) ; runTestOnUiThread ( new Runnable ( ) { @ Override public void run ( ) { View year = mDatePicker . findViewById ( com . android . internal . R . id . date _ picker _ header _ year ) ; assertTrue ( year . requestFocus ( ) ) ; } } ) ; sendKey ( KeyEvent . KEYCODE _ ENTER ) ; runTestOnUiThread ( new Runnable ( ) { @ Override public void run ( ) { View yearSelect = mDatePicker . findViewById ( com . android . internal . R . id . date _ picker _ year _ picker ) ; assertEquals ( yearSelect , mDatePicker . findFocus ( ) ) ; } } ) ; sendKey ( KeyEvent . KEYCODE _ DPAD _ UP ) ; sendKey ( KeyEvent . KEYCODE _ ENTER ) ; runTestOnUiThread ( new Runnable ( ) { @ Override public void run ( ) { View yearSelect = mDatePicker . findViewById ( com . android . internal . R . id . date _ picker _ year _ picker ) ; assertNotSame ( View . VISIBLE , yearSelect . getVisibility ( ) ) ; View year = mDatePicker . findViewById ( com . android . internal . R . id . date _ picker _ header _ year ) ; assertTrue ( year . hasFocus ( ) ) ; assertEquals ( _NUM _NUM _NUM _NUM , mDatePicker . getYear ( ) ) ; } } ) ; } 
5561	public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( _STR ) ; return sb . toString ( ) ; } 
5562	void updateParentOpenCount ( int delta ) { PDOutlineNode parent = getParent ( ) ; if ( parent ! = null ) { if ( parent . isNodeOpen ( ) ) { parent . setOpenCount ( parent . getOpenCount ( ) + delta ) ; parent . updateParentOpenCount ( delta ) ; } else { parent . setOpenCount ( parent . getOpenCount ( ) - delta ) ; } } } 
5563	public void translate ( float tx , float ty ) { Matrix m = Matrix . getTranslateInstance ( tx , ty ) ; concatenate ( m ) ; } 
5564	public DatanodeProtocolClientSideTranslatorPB getActiveNamenodeForBP ( String bpid ) throws IOException { BPOfferService bpos = blockPoolManager . get ( bpid ) ; if ( bpos = = null ) { throw new IOException ( _STR ) ; } return activeNN ; } 
5565	private ParseNode parseSimpleFactor ( ) { SkipWhite ( ) ; switch ( look ) { case ' # ' : return new ParseNode ( ErrPtg . valueOf ( parseErrorLiteral ( ) ) ) ; case ' - ' : Match ( ' - ' ) ; return parseUnary ( false ) ; case ' + ' : Match ( ' + ' ) ; return parseUnary ( true ) ; case ' ( ' : Match ( ' ( ' ) ; ParseNode inside = unionExpression ( ) ; Match ( ' ) ' ) ; return new ParseNode ( ParenthesisPtg . instance , inside ) ; case ' _STR ) ; } 
5566	public boolean isRtlCharAt ( int offset ) { int line = getLineForOffset ( offset ) ; Directions dirs = getLineDirections ( line ) ; if ( dirs = = DIRS _ ALL _ LEFT _ TO _ RIGHT ) { return false ; } if ( dirs = = DIRS _ ALL _ RIGHT _ TO _ LEFT ) { return true ; } int [ ] runs = dirs . mDirections ; int lineStart = getLineStart ( line ) ; for ( int i = _NUM ; i < runs . length ; i + = _NUM ) { int start = lineStart + runs [ i ] ; int limit = start + ( runs [ i + _NUM ] & RUN _ LENGTH _ MASK ) ; if ( offset > = start & & offset < limit ) { int level = ( runs [ i + _NUM ] > > > RUN _ LEVEL _ SHIFT ) & RUN _ LEVEL _ MASK ; return ( ( level & _NUM ) ! = _NUM ) ; } } Should happen only if the offset is _STR return false ; } 
5567	public void scan ( JavaBackend javaBackend , Method method , Class < ? > glueCodeClass ) { Annotation [ ] methodAnnotations = method . getAnnotations ( ) ; for ( Annotation annotation : methodAnnotations ) { if ( isHookAnnotation ( annotation ) ) { validateMethod ( method , glueCodeClass ) ; javaBackend . addHook ( annotation , method ) ; } else if ( isStepdefAnnotation ( annotation ) ) { validateMethod ( method , glueCodeClass ) ; javaBackend . addStepDefinition ( annotation , method ) ; } } } 
5568	public boolean contains ( byte val ) { return index ( val ) > = _NUM ; } 
5569	public MimeBodyPart encrypt ( MimeMessage message , OutputEncryptor contentEncryptor , RecipientInfoGenerator recipientGenerator ) throws SMIMEException { SMIMEEnvelopedGenerator envGen = new SMIMEEnvelopedGenerator ( ) ; envGen . addRecipientInfoGenerator ( recipientGenerator ) ; return envGen . generate ( message , contentEncryptor ) ; } 
5570	public void testCreatedServerIsNotAlive ( ) throws Throwable { HttpServer _NUM server = createTestServer ( ) ; assertNotLive ( server ) ; } 
5571	public Character get ( Object key ) { float k ; if ( key ! = null ) { if ( key instanceof Float ) { k = unwrapKey ( key ) ; } else { return null ; } } else { k = _ map . getNoEntryKey ( ) ; } char v = _ map . get ( k ) ; check here . if ( v = = _ map . getNoEntryValue ( ) ) { return null ; } else { return wrapValue ( v ) ; } } 
5572	public void processElements ( Iterable < WindowedValue < InputT > > values ) throws Exception { if ( ! values . iterator ( ) . hasNext ( ) ) { return ; } Determine all the windows for elements . Set < W > windows = collectWindows ( values ) ; If an incoming element introduces a new window , attempt to merge it into an existing window eagerly . Map < W , W > windowToMergeResult = mergeWindows ( windows ) ; if ( ! windowToMergeResult . isEmpty ( ) ) { Update windows by removing all windows that were merged away and adding the windows they were merged to . We add after completing all the removals to avoid removing a window that was also added . List < W > addedWindows = new ArrayList < > ( windowToMergeResult . size ( ) ) ; for ( Map . Entry < W , W > entry : windowToMergeResult . entrySet ( ) ) { windows . remove ( entry . getKey ( ) ) ; addedWindows . add ( entry . getValue ( ) ) ; } windows . addAll ( addedWindows ) ; } prefetchWindowsForValues ( windows ) ; All windows that are open before element processing may need to fire . Set < W > windowsToConsider = windowsThatAreOpen ( windows ) ; Process each element , using the updated activeWindows determined by mergeWindows . for ( WindowedValue < InputT > value : values ) { processElement ( windowToMergeResult , value ) ; } Prefetch state necessary to determine if the triggers should fire . for ( W mergedWindow : windowsToConsider ) { triggerRunner . prefetchShouldFire ( mergedWindow , contextFactory . base ( mergedWindow , StateStyle . DIRECT ) . state ( ) ) ; } Filter to windows that are firing . Collection < W > windowsToFire = windowsThatShouldFire ( windowsToConsider ) ; Prefetch windows that are firing . for ( W window : windowsToFire ) { prefetchEmit ( contextFactory . base ( window , StateStyle . DIRECT ) , contextFactory . base ( window , StateStyle . RENAMED ) ) ; } Trigger output from firing windows . for ( W window : windowsToFire ) { emit ( contextFactory . base ( window , StateStyle . DIRECT ) , contextFactory . base ( window , StateStyle . RENAMED ) ) ; } We ' re all done with merging and emitting elements so can compress the activeWindow state . Any windows which are still NEW must have come in on a new element which was then discarded due to the window ' s trigger being closed . We can thus delete them . activeWindows . cleanupTemporaryWindows ( ) ; } 
5573	public void testEditLogFailOverFromCorrupt ( ) throws IOException { File f _NUM = new File ( TEST _ DIR + _STR ) ; } finally { IOUtils . cleanup ( null , streams . toArray ( new EditLogInputStream [ _NUM ] ) ) ; } } 
5574	public final ModernAsyncTask < Params , Progress , Result > execute ( Params . . . params ) { return executeOnExecutor ( sDefaultExecutor , params ) ; } 
5575	public static void sendTriplesToStream ( Graph graph , StreamRDF stream ) { sendGraphToStream ( graph , stream , null ) ; } 
5576	public boolean isValidSigningKeyPOP ( ContentVerifierProvider verifierProvider , PKMACBuilder macBuilder , char [ ] password ) throws CRMFException , IllegalStateException { ProofOfPossession pop = certReqMsg . getPopo ( ) ; if ( pop . getType ( ) = = popSigningKey ) { POPOSigningKey popoSign = POPOSigningKey . getInstance ( pop . getObject ( ) ) ; if ( popoSign . getPoposkInput ( ) = = null | | popoSign . getPoposkInput ( ) . getSender ( ) ! = null ) { throw new IllegalStateException ( _STR ) ; } } 
5577	protected DynamicQueryContext createDynamicContext ( Exchange exchange ) throws Exception { Configuration config = getConfiguration ( ) ; DynamicQueryContext dynamicQueryContext = new DynamicQueryContext ( config ) ; Message in = exchange . getIn ( ) ; Item item = null ; if ( ObjectHelper . isNotEmpty ( getHeaderName ( ) ) ) { item = in . getHeader ( getHeaderName ( ) , Item . class ) ; } else { item = in . getBody ( Item . class ) ; } if ( item ! = null ) { dynamicQueryContext . setContextItem ( item ) ; } else { Object body = null ; if ( ObjectHelper . isNotEmpty ( getHeaderName ( ) ) ) { body = in . getHeader ( getHeaderName ( ) ) ; } else { body = in . getBody ( ) ; } the underlying input stream , which we need to close to avoid locking files or other resources InputStream is = null ; try { Source source ; only convert to input stream if really needed if ( isInputStreamNeeded ( exchange ) ) { if ( ObjectHelper . isNotEmpty ( getHeaderName ( ) ) ) { is = exchange . getIn ( ) . getHeader ( getHeaderName ( ) , InputStream . class ) ; } else { is = exchange . getIn ( ) . getBody ( InputStream . class ) ; } source = getSource ( exchange , is ) ; } else { source = getSource ( exchange , body ) ; } special for bean invocation if ( source = = null ) { if ( body instanceof BeanInvocation ) { if its a null bean invocation then handle that BeanInvocation bi = exchange . getContext ( ) . getTypeConverter ( ) . convertTo ( BeanInvocation . class , body ) ; if ( bi . getArgs ( ) ! = null & & bi . getArgs ( ) . length = = _NUM & & bi . getArgs ( ) [ _NUM ] = = null ) { its a null argument from the bean invocation so use null as answer source = null ; } } } if ( source = = null ) { indicate it was not possible to convert to a Source type throw new NoTypeConversionAvailableException ( body , Source . class ) ; } DocumentInfo doc = config . buildDocument ( source ) ; dynamicQueryContext . setContextItem ( doc ) ; } finally { can deal if is is null IOHelper . close ( is ) ; } } configureQuery ( dynamicQueryContext , exchange ) ; call the reset if the in message body is StreamCache MessageHelper . resetStreamCache ( exchange . getIn ( ) ) ; return dynamicQueryContext ; } 
5578	public boolean moveResource ( CmsObject cms , String source , String destination ) throws CmsException , CmsIllegalArgumentException { only allow copying of xml pages at whole or locales and elements inside the same xml page CmsResource srcXmlPage = findXmlPage ( cms , source ) ; if ( srcXmlPage ! = null ) { String srcPath = getSubPath ( cms , srcXmlPage , source ) ; if the source is the xml page itself just copy the resource if ( CmsStringUtil . isEmptyOrWhitespaceOnly ( srcPath ) ) { cms . moveResource ( source , destination ) ; return true ; } else { only a locale or an element should be copied CmsResource destXmlPage = findXmlPage ( cms , destination ) ; if ( srcXmlPage . equals ( destXmlPage ) ) { copying inside the same xml page resource String destPath = getSubPath ( cms , destXmlPage , destination ) ; String [ ] srcTokens = srcPath . split ( _STR ) ; if ( srcTokens . length = = destTokens . length ) { CmsFile srcFile = cms . readFile ( srcXmlPage ) ; CmsXmlPage srcXml = CmsXmlPageFactory . unmarshal ( cms , srcFile ) ; if ( srcTokens . length = = _NUM ) { copy locale srcXml . moveLocale ( CmsLocaleManager . getLocale ( srcTokens [ _NUM ] ) , CmsLocaleManager . getLocale ( destTokens [ _NUM ] ) ) ; } else if ( srcTokens . length = = _NUM ) { TODO : move element } write file srcFile . setContents ( srcXml . marshal ( ) ) ; cms . writeFile ( srcFile ) ; } else { TODO : error : destination path is invalid } } else { TODO : error : moving only allowed inside the same xml page } } return true ; } return false ; } 
5579	protected void setInnerName ( String innerName ) { m _ innerName = innerName ; if ( m _ innerName ! = null ) { m _ typeName = createTypeName ( innerName ) ; } } 
5580	public void changeLocalDirPermissionTests ( ) throws IOException { This test only works with normal users - superusers can operate on files whether or not they have the proper permission bits set . assumeFalse ( System . getProperty ( _STR ) ; assertTrue ( tempFile . delete ( ) ) ; } 
5581	private StackId getTargetStackId ( Cluster cluster ) throws AmbariException { UpgradeContext upgradeContext = getUpgradeContext ( cluster ) ; ! ! ! FIXME in a per - service view , what does this become ? Set < StackId > stackIds = new HashSet < > ( ) ; for ( Service service : cluster . getServices ( ) . values ( ) ) { RepositoryVersionEntity targetRepoVersion = upgradeContext . getTargetRepositoryVersion ( service . getName ( ) ) ; StackId targetStackId = targetRepoVersion . getStackId ( ) ; stackIds . add ( targetStackId ) ; } if ( _NUM ! = stackIds . size ( ) ) { throw new AmbariException ( _STR ) ; } return stackIds . iterator ( ) . next ( ) ; } 
5582	public void setConnectionTimeout ( int timeout ) { getConnectionManager ( ) . getParams ( ) . setConnectionTimeout ( timeout ) ; } 
5583	protected boolean [ ] multiInstanceHandler ( ) { boolean [ ] result = new boolean [ _NUM ] ; print ( _STR ) ; result [ _NUM ] = false ; } return result ; } 
5584	private void removeExternalEntry ( TrieEntry < K , V > h ) { if ( h = = root ) { throw new IllegalArgumentException ( _STR ) ; } TrieEntry < K , V > parent = h . parent ; TrieEntry < K , V > child = ( h . left = = h ) ? h . right : h . left ; if ( parent . left = = h ) { parent . left = child ; } else { parent . right = child ; } either the parent is changing , or the predecessor is changing . if ( child . bitIndex > parent . bitIndex ) { child . parent = parent ; } else { child . predecessor = parent ; } } 
5585	public final void notifyDataSetChanged ( ) { mObservable . notifyChanged ( ) ; } 
5586	public static void exportevaluationCalibrationToHtmlFile ( EvaluationCalibration ec , File file ) throws IOException { String asHtml = evaluationCalibrationToHtml ( ec ) ; FileUtils . writeStringToFile ( file , asHtml ) ; } 
5587	public static long toLong ( Object obj ) { Long result = toLongObject ( obj ) ; return result = = null ? _NUM : result . longValue ( ) ; } 
5588	public static Snackbar make ( @ NonNull View view , @ NonNull CharSequence text , @ Duration int duration ) { final ViewGroup parent = findSuitableParent ( view ) ; if ( parent = = null ) { throw new IllegalArgumentException ( _STR ) ; } final LayoutInflater inflater = LayoutInflater . from ( parent . getContext ( ) ) ; final SnackbarContentLayout content = ( SnackbarContentLayout ) inflater . inflate ( R . layout . design _ layout _ snackbar _ include , parent , false ) ; final Snackbar snackbar = new Snackbar ( parent , content , content ) ; snackbar . setText ( text ) ; snackbar . setDuration ( duration ) ; return snackbar ; } 
5589	public void appendValue ( int r , int c , double v ) { early abort ( append guarantees no overwrite ) if ( v = = _NUM ) return ; if ( DENSE ! sparse ) { allocate on demand ( w / o overwriting nnz ) allocateDenseBlock ( false ) ; set value and maintain nnz denseBlock . set ( r , c , v ) ; nonZeros + + ; } else SPARSE { allocation on demand ( w / o overwriting nnz ) allocateSparseRowsBlock ( false ) ; sparseBlock . allocate ( r , estimatedNNzsPerRow , clen ) ; set value and maintain nnz sparseBlock . append ( r , c , v ) ; nonZeros + + ; } } 
5590	public void validateAction ( ExecuteActionRequest actionRequest ) throws AmbariException { if ( actionRequest . getActionName ( ) = = null | | actionRequest . getActionName ( ) . isEmpty ( ) ) { throw new AmbariException ( _STR ) ; } } } 
5591	public boolean draw ( Canvas canvas ) { update ( ) ; final float centerX = mBounds . centerX ( ) ; final float centerY = mBounds . height ( ) - mRadius ; canvas . scale ( _NUM . f , Math . min ( mGlowScaleY , _NUM . f ) * mBaseGlowScale , centerX , _NUM ) ; final float displacement = Math . max ( _NUM , Math . min ( mDisplacement , _NUM . f ) ) - _NUM . _NUM f ; float translateX = mBounds . width ( ) * displacement / _NUM ; mPaint . setAlpha ( ( int ) ( _NUM xff * mGlowAlpha ) ) ; canvas . drawCircle ( centerX + translateX , centerY , mRadius , mPaint ) ; boolean oneLastFrame = false ; if ( mState = = STATE _ RECEDE & & mGlowScaleY = = _NUM ) { mState = STATE _ IDLE ; oneLastFrame = true ; } return mState ! = STATE _ IDLE | | oneLastFrame ; } 
5592	public ProcedureFactory get ( String uri ) { ProcedureFactory procedure = registry . get ( uri ) ; if ( procedure ! = null ) return procedure ; if ( attemptedLoads . contains ( uri ) ) return null ; Class < ? > procedureClass = MappedLoader . loadClass ( uri , Procedure . class ) ; if ( procedureClass = = null ) return null ; Registry it put ( uri , procedureClass ) ; attemptedLoads . add ( uri ) ; Call again to get it . return registry . get ( uri ) ; } 
5593	public int findOpeningPeer ( int start , int openingPeer , int closingPeer ) { assert ( start < _ document . getLength ( ) ) ; int depth = _NUM ; start + = _NUM ; int token ; int offset = start ; while ( true ) { token = previousToken ( offset , UNBOUND ) ; offset = getPosition ( ) ; if ( token = = SQLIndentSymbols . TokenEOF ) { return NOT _ FOUND ; } if ( isSameToken ( token , closingPeer ) ) { depth + + ; } else if ( isSameToken ( token , openingPeer ) ) { depth - - ; } if ( depth = = _NUM ) { if ( offset = = - _NUM ) { return _NUM ; } return offset ; } } } 
5594	public List < DescriptorPreCheck > getApplicablePrerequisiteChecks ( PrereqCheckRequest request , List < AbstractCheckDescriptor > checksRegistry ) { List < DescriptorPreCheck > applicablePreChecks = new LinkedList < > ( ) ; final String clusterName = request . getClusterName ( ) ; for ( AbstractCheckDescriptor checkDescriptor : checksRegistry ) { final PrerequisiteCheck prerequisiteCheck = new PrerequisiteCheck ( checkDescriptor . getDescription ( ) , clusterName ) ; try { if ( checkDescriptor . isApplicable ( request ) ) { applicablePreChecks . add ( new DescriptorPreCheck ( checkDescriptor , prerequisiteCheck ) ) ; } } catch ( Exception ex ) { LOG . error ( _STR , checkDescriptor . getDescription ( ) . name ( ) , ex ) ; } } return applicablePreChecks ; } 
5595	public Image modifyAlphaWithTranslucency ( byte alpha ) { int w = getWidth ( ) ; int h = getHeight ( ) ; int size = w * h ; int [ ] arr = getRGB ( ) ; int alphaInt = ( ( ( int ) alpha ) < < _NUM _NUM ) & _NUM xff _NUM _NUM _NUM _NUM _NUM _NUM ; float alphaRatio = ( alpha & _NUM xff ) ; alphaRatio = ( alpha & _NUM xff ) / _NUM _NUM _NUM . _NUM f ; for ( int iter = _NUM ; iter < size ; iter + + ) { int currentAlpha = ( arr [ iter ] > > _NUM _NUM ) & _NUM xff ; if ( currentAlpha ! = _NUM ) { if ( currentAlpha = = _NUM xff ) { arr [ iter ] = ( arr [ iter ] & _NUM xffffff ) | alphaInt ; } else { int relative = ( int ) ( currentAlpha * alphaRatio ) ; relative = ( relative < < _NUM _NUM ) & _NUM xff _NUM _NUM _NUM _NUM _NUM _NUM ; arr [ iter ] = ( arr [ iter ] & _NUM xffffff ) | relative ; } } } Image i = new Image ( arr , w , h ) ; i . opaqueTested = true ; i . opaque = false ; return i ; } 
5596	protected void saveHistory ( ) { int size ; int from ; int i ; String filename ; BufferedOutputStream stream ; size = Integer . parseInt ( PROPERTIES . getProperty ( _STR ) ; stream . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } 
5597	private void clipTaskViews ( ) { We never clip task views in grid layout if ( Recents . getConfiguration ( ) . isGridEnabled ) { return ; } Update the clip on each task child List < TaskView > taskViews = getTaskViews ( ) ; TaskView tmpTv = null ; TaskView prevVisibleTv = null ; int taskViewCount = taskViews . size ( ) ; for ( int i = _NUM ; i < taskViewCount ; i + + ) { TaskView tv = taskViews . get ( i ) ; TaskView frontTv = null ; int clipBottom = _NUM ; if ( isIgnoredTask ( tv . getTask ( ) ) ) { between the translationZ of the tasks immediately underneath it if ( prevVisibleTv ! = null ) { tv . setTranslationZ ( Math . max ( tv . getTranslationZ ( ) , prevVisibleTv . getTranslationZ ( ) + _NUM . _NUM f ) ) ; } } if ( i < ( taskViewCount - _NUM ) & & tv . shouldClipViewInStack ( ) ) { Find the next view to clip against for ( int j = i + _NUM ; j < taskViewCount ; j + + ) { tmpTv = taskViews . get ( j ) ; if ( tmpTv . shouldClipViewInStack ( ) ) { frontTv = tmpTv ; break ; } } task relative to the ones in front of it . if ( frontTv ! = null ) { float taskBottom = tv . getBottom ( ) ; float frontTaskTop = frontTv . getTop ( ) ; if ( frontTaskTop < taskBottom ) { Map the stack view space coordinate ( the rects ) to view space clipBottom = ( int ) ( taskBottom - frontTaskTop ) - mTaskCornerRadiusPx ; } } } tv . getViewBounds ( ) . setClipBottom ( clipBottom ) ; tv . mThumbnailView . updateThumbnailVisibility ( clipBottom - tv . getPaddingBottom ( ) ) ; prevVisibleTv = tv ; } mTaskViewsClipDirty = false ; } 
5598	View findOneViewWithinBoundFlags ( int fromIndex , int toIndex , @ ViewBounds int preferredBoundFlags , @ ViewBounds int acceptableBoundFlags ) { final int start = mCallback . getParentStart ( ) ; final int end = mCallback . getParentEnd ( ) ; final int next = toIndex > fromIndex ? _NUM : - _NUM ; View acceptableMatch = null ; for ( int i = fromIndex ; i ! = toIndex ; i + = next ) { final View child = mCallback . getChildAt ( i ) ; final int childStart = mCallback . getChildStart ( child ) ; final int childEnd = mCallback . getChildEnd ( child ) ; mBoundFlags . setBounds ( start , end , childStart , childEnd ) ; if ( preferredBoundFlags ! = _NUM ) { mBoundFlags . resetFlags ( ) ; mBoundFlags . addFlags ( preferredBoundFlags ) ; if ( mBoundFlags . boundsMatch ( ) ) { found a perfect match return child ; } } if ( acceptableBoundFlags ! = _NUM ) { mBoundFlags . resetFlags ( ) ; mBoundFlags . addFlags ( acceptableBoundFlags ) ; if ( mBoundFlags . boundsMatch ( ) ) { acceptableMatch = child ; } } } return acceptableMatch ; } 
5599	public JSONObject setExposureCompensation ( int value ) throws IOException { String service = _STR + responseJson ) ; return new JSONObject ( responseJson ) ; } catch ( JSONException e ) { throw new IOException ( e ) ; } } 
5600	private List < Token > readProc ( ) throws IOException { List < Token > value = new ArrayList < > ( ) ; int openProc = _NUM ; while ( true ) { if ( lexer . peekToken ( ) . getKind ( ) = = Token . START _ PROC ) { openProc + + ; } Token token = lexer . nextToken ( ) ; value . add ( token ) ; if ( token . getKind ( ) = = Token . END _ PROC ) { openProc - - ; if ( openProc = = _NUM ) { break ; } } } Token executeonly = readMaybe ( Token . NAME , _STR ) ; if ( executeonly ! = null ) { value . add ( executeonly ) ; } return value ; } 
5601	public void cleanUp ( ) { if ( oos ! = null ) { try { oos . close ( ) ; } catch ( IOException e ) { if ( e instanceof InterruptedIOException ) { Thread . currentThread ( ) . interrupt ( ) ; } LogLog . error ( _STR ) ; connector . interrupted = true ; allow gc connector = null ; } } 
5602	 @ SuppressWarnings ( _STR ) ; complete ( subscriber ) ; } 
5603	protected static TrustAnchor findTrustAnchor ( X _NUM _NUM _NUM Certificate cert , Set trustAnchors , String sigProvider ) throws AnnotatedException { TrustAnchor trust = null ; PublicKey trustPublicKey = null ; Exception invalidKeyEx = null ; X _NUM _NUM _NUM CertSelector certSelectX _NUM _NUM _NUM = new X _NUM _NUM _NUM CertSelector ( ) ; X _NUM _NUM _NUM Name certIssuer = PrincipalUtils . getEncodedIssuerPrincipal ( cert ) ; try { certSelectX _NUM _NUM _NUM . setSubject ( certIssuer . getEncoded ( ) ) ; } catch ( IOException ex ) { throw new AnnotatedException ( _STR , invalidKeyEx ) ; } return trust ; } 
5604	private Map < String , ServiceModule > parseCommonServicesDirectory ( File commonServicesRoot ) throws AmbariException { Map < String , ServiceModule > commonServiceModules = new HashMap < > ( ) ; if ( commonServicesRoot ! = null ) { File [ ] commonServiceFiles = commonServicesRoot . listFiles ( StackDirectory . FILENAME _ FILTER ) ; for ( File commonService : commonServiceFiles ) { if ( commonService . isFile ( ) ) { continue ; } for ( File serviceFolder : commonService . listFiles ( StackDirectory . FILENAME _ FILTER ) ) { ServiceDirectory serviceDirectory = new CommonServiceDirectory ( serviceFolder . getPath ( ) ) ; ServiceMetainfoXml metaInfoXml = serviceDirectory . getMetaInfoFile ( ) ; if ( metaInfoXml ! = null ) { if ( metaInfoXml . isValid ( ) ) { for ( ServiceInfo serviceInfo : metaInfoXml . getServices ( ) ) { ServiceModule serviceModule = new ServiceModule ( stackContext , serviceInfo , serviceDirectory , true ) ; String commonServiceKey = serviceInfo . getName ( ) + StackManager . PATH _ DELIMITER + serviceInfo . getVersion ( ) ; commonServiceModules . put ( commonServiceKey , serviceModule ) ; } } else { ServiceModule serviceModule = new ServiceModule ( stackContext , new ServiceInfo ( ) , serviceDirectory , true ) ; serviceModule . setValid ( false ) ; serviceModule . addErrors ( metaInfoXml . getErrors ( ) ) ; commonServiceModules . put ( metaInfoXml . getSchemaVersion ( ) , serviceModule ) ; metaInfoXml . setSchemaVersion ( null ) ; } } } } } return commonServiceModules ; } 
5605	protected long populateInputFile ( long length , long start , long end ) throws Exception { long checksum = _NUM ; File file = mTestFolder . newFile ( ) ; long pos = _NUM ; if ( length > _NUM ) { FileOutputStream fileOutputStream = new FileOutputStream ( file ) ; while ( length > _NUM ) { byte [ ] buffer = new byte [ ( int ) Math . min ( length , Constants . MB ) ] ; mRandom . nextBytes ( buffer ) ; for ( int i = _NUM ; i < buffer . length ; i + + ) { if ( pos > = start & & pos < = end ) { checksum + = BufferUtils . byteToInt ( buffer [ i ] ) ; } pos + + ; } fileOutputStream . write ( buffer ) ; length - = buffer . length ; } fileOutputStream . close ( ) ; } mFile = file . getPath ( ) ; mockReader ( start ) ; return checksum ; } 
5606	public ParseExpr resolve ( final QNm name , final InputInfo ii ) throws QueryException { local variable final VarRef local = resolveLocal ( name , ii ) ; if ( local ! = null ) return local ; static variable final byte [ ] uri = name . uri ( ) ; - if it is specified in the main module if ( qp . module = = null | | eq ( qp . module . uri ( ) , uri ) | | qp . modules . contains ( uri ) ) return qp . qc . vars . newRef ( name , qp . sc , ii ) ; throw qp . error ( VARUNDEF _ X , ii , ' $ ' + string ( name . string ( ) ) ) ; } 
5607	public void setDropdownData ( String [ ] dropdownData ) { this . dropdownData = dropdownData ; createDropDown ( ) ; updateDropDownState ( ) ; } 
5608	public HSSFFontFormatting createFontFormatting ( ) { return getFontFormatting ( true ) ; } 
5609	public void initialize ( Context context ) { if ( mInitialized ) { return ; } mInitialized = true ; mContext = context ; mActivityManager = ActivityManager . getService ( ) ; mWindowManager = WindowManagerGlobal . getWindowManagerService ( ) ; SystemServicesProxy . getInstance ( context ) . registerTaskStackListener ( mTaskStackListener ) ; IntentFilter intentFilter = new IntentFilter ( ) ; intentFilter . addAction ( Intent . ACTION _ MEDIA _ RESOURCE _ GRANTED ) ; mContext . registerReceiver ( mBroadcastReceiver , intentFilter ) ; if ( sSettingsPackageAndClassNamePairList = = null ) { String [ ] settings = mContext . getResources ( ) . getStringArray ( R . array . tv _ pip _ settings _ class _ name ) ; sSettingsPackageAndClassNamePairList = new ArrayList < > ( ) ; if ( settings ! = null ) { for ( int i = _NUM ; i < settings . length ; i + + ) { Pair < String , String > entry = null ; String [ ] packageAndClassName = settings [ i ] . split ( SETTINGS _ PACKAGE _ AND _ CLASS _ DELIMITER ) ; switch ( packageAndClassName . length ) { case _NUM : entry = Pair . < String , String > create ( packageAndClassName [ _NUM ] , null ) ; break ; case _NUM : if ( packageAndClassName [ _NUM ] ! = null & & packageAndClassName [ _NUM ] . startsWith ( _STR , e ) ; } mPipNotification = new PipNotification ( context ) ; } 
5610	private FastVector defineClustersGRID ( Random random ) throws Exception { FastVector clusters = new FastVector ( m _ NumClusters ) ; double diffInstNum = ( double ) ( m _ MaxInstNum - m _ MinInstNum ) ; double minInstNum = ( double ) m _ MinInstNum ; double diffRadius = m _ MaxRadius - m _ MinRadius ; Cluster cluster ; compute gridsize double gs = Math . pow ( m _ NumClusters , _NUM . _NUM / getNumAttributes ( ) ) ; if ( gs - ( ( double ) ( ( int ) gs ) ) > _NUM . _NUM ) { m _ GridSize = ( int ) ( gs + _NUM . _NUM ) ; } else { m _ GridSize = ( int ) gs ; } compute gridwidth m _ GridWidth = ( ( m _ MaxRadius + m _ MinRadius ) / _NUM ) * m _ DistMult ; System . out . println ( _STR + m _ GridWidth ) ; initialize gridvector with zeros GridVector gv = new GridVector ( getNumAttributes ( ) , m _ GridSize ) ; for ( int i = _NUM ; i < m _ NumClusters ; i + + ) { int instNum = ( int ) ( random . nextDouble ( ) * diffInstNum + minInstNum ) ; double radius = ( random . nextDouble ( ) * diffRadius ) + m _ MinRadius ; center is defined in the constructor of cluster cluster = new Cluster ( instNum , radius , gv . getGridVector ( ) , m _ GridWidth ) ; clusters . addElement ( ( Object ) cluster ) ; gv . addOne ( ) ; } return clusters ; } 
5611	public static XmlNMTOKENS parse ( java . io . File f ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( XmlNMTOKENS ) XmlBeans . getContextTypeLoader ( ) . parse ( f , type , null ) ; } 
5612	public void multiple _ _NUM _NUM ( ) { DatasetGraph dsg = dataset ( ) ; int port = FusekiLib . choosePort ( ) ; FusekiServer server _NUM = FusekiServer . create ( ) . setPort ( port ) . add ( _STR , dsg ) . build ( ) ; server _NUM . start ( ) ; try { server _NUM . start ( ) ; } catch ( FusekiException ex ) { assertTrue ( ex . getCause ( ) instanceof java . net . BindException ) ; throw ex ; } finally { try { server _NUM . stop ( ) ; } catch ( Exception ex ) { } try { server _NUM . stop ( ) ; } catch ( Exception ex ) { } } } 
5613	public static Resources getResourcesForSubId ( Context context , int subId ) { final SubscriptionInfo subInfo = SubscriptionManager . from ( context ) . getActiveSubscriptionInfo ( subId ) ; Configuration config = context . getResources ( ) . getConfiguration ( ) ; Configuration newConfig = new Configuration ( ) ; newConfig . setTo ( config ) ; if ( subInfo ! = null ) { newConfig . mcc = subInfo . getMcc ( ) ; newConfig . mnc = subInfo . getMnc ( ) ; if ( newConfig . mnc = = _NUM ) newConfig . mnc = Configuration . MNC _ ZERO ; } DisplayMetrics metrics = context . getResources ( ) . getDisplayMetrics ( ) ; DisplayMetrics newMetrics = new DisplayMetrics ( ) ; newMetrics . setTo ( metrics ) ; return new Resources ( context . getResources ( ) . getAssets ( ) , newMetrics , newConfig ) ; } 
5614	public void execute ( ) { Exception ex ; ResultSet rs ; not connected ? if ( ! m _ ButtonExecute . isEnabled ( ) ) return ; no query ? if ( m _ TextQuery . getText ( ) . trim ( ) . equals ( _STR ) ) return ; close old resultset try { if ( m _ DbUtils . getResultSet ( ) ! = null ) m _ DbUtils . close ( ) ; } catch ( Exception e ) { ignore ( if no resultset present we get an unncessary NullPointerEx . ) } ex = null ; rs = null ; try { if ( m _ DbUtils . execute ( getQuery ( ) ) ) { rs = m _ DbUtils . getResultSet ( ) ; add to history addHistory ( getQuery ( ) ) ; } } catch ( Exception e ) { ex = new Exception ( e . getMessage ( ) ) ; } notifyQueryExecuteListeners ( rs , ex ) ; setButtons ( ) ; } 
5615	Grows the cropping rectangle by ( dx , dy ) in image spacevoid moveBy ( float dx , float dy ) { Rect invalRect = new Rect ( drawRect ) ; cropRect . offset ( dx , dy ) ; Put the cropping rectangle inside image rectangle cropRect . offset ( Math . max ( _NUM , imageRect . left - cropRect . left ) , Math . max ( _NUM , imageRect . top - cropRect . top ) ) ; cropRect . offset ( Math . min ( _NUM , imageRect . right - cropRect . right ) , Math . min ( _NUM , imageRect . bottom - cropRect . bottom ) ) ; drawRect = computeLayout ( ) ; invalRect . union ( drawRect ) ; invalRect . inset ( - ( int ) handleRadius , - ( int ) handleRadius ) ; viewContext . invalidate ( invalRect ) ; } 
5616	public Endpoint getExternalEndpoint ( String api ) { return findByAPI ( external , api ) ; } 
5617	public void testListViewLayout ( ) { final View decorView = mActivity . getWindow ( ) . getDecorView ( ) ; ViewAsserts . assertOnScreen ( decorView , mListView ) ; final ViewGroup . LayoutParams layoutParams = mListView . getLayoutParams ( ) ; assertNotNull ( _STR , View . VISIBLE = = mListView . getVisibility ( ) ) ; } 
5618	public static void enableSlowWholeDocumentDraw ( ) { getFactory ( ) . getStatics ( ) . enableSlowWholeDocumentDraw ( ) ; } 
5619	public static String getColumnString ( Cursor cursor , String columnName ) { int col = cursor . getColumnIndex ( columnName ) ; return getStringOrNull ( cursor , col ) ; } 
5620	public void init ( CamelContext camelContext , Mapper mapper ) { this . camelContext = camelContext ; if ( mapper ! = null ) { this . mapper = mapper ; } ClassLoader tccl = Thread . currentThread ( ) . getContextClassLoader ( ) ; try { ClassLoader appcl = camelContext . getApplicationContextClassLoader ( ) ; if ( appcl ! = null ) { Thread . currentThread ( ) . setContextClassLoader ( appcl ) ; } Map < String , Mapper > mappers = lookupDozerBeanMappers ( ) ; only add if we do not already have it if ( mapper ! = null & & ! mappers . containsValue ( mapper ) ) { mappers . put ( _STR , Mapper . class . getName ( ) ) ; } TypeConverterRegistry registry = camelContext . getTypeConverterRegistry ( ) ; for ( Map . Entry < String , Mapper > entry : mappers . entrySet ( ) ) { String mapperId = entry . getKey ( ) ; Mapper dozer = entry . getValue ( ) ; MappingMetadata meta = dozer . getMappingMetadata ( ) ; List < ClassMappingMetadata > all = meta . getClassMappings ( ) ; registerClassMaps ( registry , mapperId , dozer , all ) ; } } finally { Thread . currentThread ( ) . setContextClassLoader ( tccl ) ; } } 
5621	public void setBaseSeriesPaint ( Paint paint ) { if ( paint = = null ) { throw new IllegalArgumentException ( _STR ) ; } this . baseSeriesPaint = paint ; fireChangeEvent ( ) ; } 
5622	public synchronized NSObject anyObject ( ) { if ( set . isEmpty ( ) ) return null ; else return set . iterator ( ) . next ( ) ; } 
5623	public Builder setCacheFactory ( org . apache . phoenix . coprocessor . generated . ServerCacheFactoryProtos . ServerCacheFactory . Builder builderForValue ) { if ( cacheFactoryBuilder _ = = null ) { cacheFactory _ = builderForValue . build ( ) ; onChanged ( ) ; } else { cacheFactoryBuilder _ . setMessage ( builderForValue . build ( ) ) ; } bitField _NUM _ | = _NUM x _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM ; return this ; } 
5624	public String addResource ( String key , String fileName ) { String interned = intern ( key ) ; synchronized ( interned ) { SharedCacheResource resource = cachedResources . get ( interned ) ; if ( resource = = null ) { resource = new SharedCacheResource ( fileName ) ; cachedResources . put ( interned , resource ) ; } return resource . getFileName ( ) ; } } 
5625	private String getVersionTag ( ) throws AmbariHttpException { JSONObject json = getDesiredConfigs ( ) ; JSONObject clusters = ( JSONObject ) json . get ( _STR ) ; } 
5626	public void testCustomSchema ( ) throws IOException { final ObjectMapper mapper = mapper ( ) ; JsonRoot root = mapper . readValue ( _STR ) ; assertEquals ( _NUM , list . size ( ) ) ; assertEquals ( _NUM , list . get ( _NUM ) ) ; assertEquals ( _NUM . _NUM , list . get ( _NUM ) ) ; assertEquals ( _NUM , schema . tables . size ( ) ) ; assertNull ( ( ( JsonCustomTable ) schema . tables . get ( _NUM ) ) . operand ) ; assertTrue ( ( ( JsonCustomTable ) schema . tables . get ( _NUM ) ) . operand . isEmpty ( ) ) ; } 
5627	public String getLocationId ( Exchange exchange ) { String operation = ( ( JcloudsBlobStoreEndpoint ) getEndpoint ( ) ) . getLocationId ( ) ; if ( ObjectHelper . isNotEmpty ( exchange . getIn ( ) . getHeader ( JcloudsConstants . LOCATION _ ID ) ) ) { operation = exchange . getIn ( ) . getHeader ( JcloudsConstants . LOCATION _ ID , String . class ) ; } return operation ; } 
5628	public void copy ( int rl , int ru , int cl , int cu , MatrixBlock src , boolean awareDestNZ ) { if ( sparse & & src . sparse ) copySparseToSparse ( rl , ru , cl , cu , src , awareDestNZ ) ; else if ( sparse & & ! src . sparse ) copyDenseToSparse ( rl , ru , cl , cu , src , awareDestNZ ) ; else if ( ! sparse & & src . sparse ) copySparseToDense ( rl , ru , cl , cu , src , awareDestNZ ) ; else copyDenseToDense ( rl , ru , cl , cu , src , awareDestNZ ) ; } 
5629	static String toHex ( int n ) { if ( n < _NUM x _NUM _NUM _NUM _NUM _NUM ) return _STR ; } 
5630	public static Op pathToTriples ( PathBlock pattern ) { BasicPattern bp = null ; Op op = null ; for ( TriplePath tp : pattern ) { if ( tp . isTriple ( ) ) { if ( bp = = null ) bp = new BasicPattern ( ) ; bp . add ( tp . asTriple ( ) ) ; continue ; } Path form . op = flush ( bp , op ) ; bp = null ; OpPath opPath _NUM = new OpPath ( tp ) ; op = OpSequence . create ( op , opPath _NUM ) ; continue ; } End . Finish off any outstanding BGP . op = flush ( bp , op ) ; return op ; } 
5631	public boolean end ( Writer writer , String body ) { evaluateParams ( ) ; try { addParameter ( _STR , e ) ; } finally { popComponentStack ( ) ; } return false ; } 
5632	public < T > T queryFirstNullable ( String sql , StatementParameters parameters , DalHints hints , DalRowMapper < T > mapper ) throws SQLException { return queryFirst ( sql , parameters , hints , mapper , NULLABLE ) ; } 
5633	public void flush ( ) throws InterruptedException { Inserter inserter = getInserter ( ) ; inserter . flush ( ) ; } 
5634	public synchronized void close ( ) throws IOException { if ( journalWriter = = null ) { Already closed . return ; } for ( Entry entry : new ArrayList < Entry > ( lruEntries . values ( ) ) ) { if ( entry . currentEditor ! = null ) { entry . currentEditor . abort ( ) ; } } trimToSize ( ) ; journalWriter . close ( ) ; journalWriter = null ; } 
5635	public void toXml ( Writer writer ) throws IOException { writer . write ( _STR ) ; } } 
5636	private void addSharedDeploymentParameters ( final ElasticDeploymentTopology deployment ) { deployment . name ( deploymentConfig . getAbsolutePUName ( ) ) ; add context properties final Properties contextProperties = createServiceContextProperties ( ) ; setContextProperties ( deployment , contextProperties ) ; if ( ! isLocalcloud ( ) ) { logger . fine ( _STR + deploymentConfig . getCloud ( ) . getConfiguration ( ) . getComponents ( ) . getUsm ( ) . getMinMemory ( ) ) ; final CloudifyMachineProvisioningConfig config = createCloudifyMachineProvisioningConfig ( ) ; TODO : uncomment this when isolation is defined for pu types . isolation should work out of the box for every pu type . setIsolationConfig ( deployment , dedicated , config ) ; deployment . dedicatedMachineProvisioning ( config ) ; } else { localcloud setLocalcloudMachineProvisioningConfig ( deployment ) ; } } 
5637	public static boolean isNotPoBox ( String s ) { if ( isEmpty ( s ) ) return defaultEmptyOK ; strings to check from Greg ' s program _STR ) ! = - _NUM ) return false ; return true ; } 
5638	private static Object getSharedElementTransition ( FragmentTransitionImpl impl , Fragment inFragment , Fragment outFragment , boolean isPop ) { if ( inFragment = = null | | outFragment = = null ) { return null ; } Object transition = impl . cloneTransition ( isPop ? outFragment . getSharedElementReturnTransition ( ) : inFragment . getSharedElementEnterTransition ( ) ) ; return impl . wrapTransitionInSet ( transition ) ; } 
5639	void layoutHorizontal ( int left , int top , int right , int bottom ) { final boolean isLayoutRtl = ViewUtils . isLayoutRtl ( this ) ; final int paddingTop = getPaddingTop ( ) ; int childTop ; int childLeft ; Where bottom of child should go final int height = bottom - top ; int childBottom = height - getPaddingBottom ( ) ; Space available for child int childSpace = height - paddingTop - getPaddingBottom ( ) ; final int count = getVirtualChildCount ( ) ; final int majorGravity = mGravity & GravityCompat . RELATIVE _ HORIZONTAL _ GRAVITY _ MASK ; final int minorGravity = mGravity & Gravity . VERTICAL _ GRAVITY _ MASK ; final boolean baselineAligned = mBaselineAligned ; final int [ ] maxAscent = mMaxAscent ; final int [ ] maxDescent = mMaxDescent ; final int layoutDirection = ViewCompat . getLayoutDirection ( this ) ; switch ( GravityCompat . getAbsoluteGravity ( majorGravity , layoutDirection ) ) { case Gravity . RIGHT : mTotalLength contains the padding already childLeft = getPaddingLeft ( ) + right - left - mTotalLength ; break ; case Gravity . CENTER _ HORIZONTAL : mTotalLength contains the padding already childLeft = getPaddingLeft ( ) + ( right - left - mTotalLength ) / _NUM ; break ; case Gravity . LEFT : default : childLeft = getPaddingLeft ( ) ; break ; } int start = _NUM ; int dir = _NUM ; In case of RTL , start drawing from the last child . if ( isLayoutRtl ) { start = count - _NUM ; dir = - _NUM ; } for ( int i = _NUM ; i < count ; i + + ) { int childIndex = start + dir * i ; final View child = getVirtualChildAt ( childIndex ) ; if ( child = = null ) { childLeft + = measureNullChild ( childIndex ) ; } else if ( child . getVisibility ( ) ! = GONE ) { final int childWidth = child . getMeasuredWidth ( ) ; final int childHeight = child . getMeasuredHeight ( ) ; int childBaseline = - _NUM ; final LinearLayoutCompat . LayoutParams lp = ( LinearLayoutCompat . LayoutParams ) child . getLayoutParams ( ) ; if ( baselineAligned & & lp . height ! = LayoutParams . MATCH _ PARENT ) { childBaseline = child . getBaseline ( ) ; } int gravity = lp . gravity ; if ( gravity < _NUM ) { gravity = minorGravity ; } switch ( gravity & Gravity . VERTICAL _ GRAVITY _ MASK ) { case Gravity . TOP : childTop = paddingTop + lp . topMargin ; if ( childBaseline ! = - _NUM ) { childTop + = maxAscent [ INDEX _ TOP ] - childBaseline ; } break ; case Gravity . CENTER _ VERTICAL : Removed support for baseline alignment when layout _ gravity or gravity = = center _ vertical . See bug # _NUM _NUM _NUM _NUM _NUM _NUM _NUM . Keep the code around if we need to re - enable this feature if ( childBaseline ! = - _NUM ) { Align baselines vertically only if the child is smaller than us if ( childSpace - childHeight > _NUM ) { childTop = paddingTop + ( childSpace / _NUM ) - childBaseline ; } else { childTop = paddingTop + ( childSpace - childHeight ) / _NUM ; } } else { childTop = paddingTop + ( ( childSpace - childHeight ) / _NUM ) + lp . topMargin - lp . bottomMargin ; break ; case Gravity . BOTTOM : childTop = childBottom - childHeight - lp . bottomMargin ; if ( childBaseline ! = - _NUM ) { int descent = child . getMeasuredHeight ( ) - childBaseline ; childTop - = ( maxDescent [ INDEX _ BOTTOM ] - descent ) ; } break ; default : childTop = paddingTop ; break ; } if ( hasDividerBeforeChildAt ( childIndex ) ) { childLeft + = mDividerWidth ; } childLeft + = lp . leftMargin ; setChildFrame ( child , childLeft + getLocationOffset ( child ) , childTop , childWidth , childHeight ) ; childLeft + = childWidth + lp . rightMargin + getNextLocationOffset ( child ) ; i + = getChildrenSkipCount ( child , childIndex ) ; } } } 
5640	protected String getImports ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( _STR ) ; buf . append ( m _ nl ) ; } return buf . toString ( ) ; } 
5641	protected CmsADEConfigData internalLookupConfiguration ( CmsObject cms , String rootPath ) { boolean online = cms . getRequestContext ( ) . getCurrentProject ( ) . isOnlineProject ( ) ; CmsConfigurationCache cache = online ? m _ onlineCache : m _ offlineCache ; CmsADEConfigData result = cache . getSiteConfigData ( rootPath ) ; if ( result = = null ) { result = cache . getModuleConfiguration ( ) ; } return result ; } 
5642	public CellStyle getColumnStyle ( int column ) { int idx = columnHelper . getColDefaultStyle ( column ) ; return getWorkbook ( ) . getCellStyleAt ( ( short ) ( idx = = - _NUM ? _NUM : idx ) ) ; } 
5643	public StrBuilder appendln ( final String str , final int startIndex , final int length ) { return append ( str , startIndex , length ) . appendNewLine ( ) ; } 
5644	public void initializeMetaBlockLargerThanCapacity ( ) throws Exception { File testDir = mFolder . newFolder ( ) ; newBlockFile ( testDir , String . valueOf ( TEST _ BLOCK _ ID ) , Ints . checkedCast ( TEST _ DIR _ CAPACITY + _NUM ) ) ; String alias = _STR ; mThrown . expect ( WorkerOutOfSpaceException . class ) ; mThrown . expectMessage ( ExceptionMessage . NO _ SPACE _ FOR _ BLOCK _ META . getMessage ( TEST _ BLOCK _ ID , TEST _ DIR _ CAPACITY + _NUM , TEST _ DIR _ CAPACITY , alias ) ) ; mDir = newStorageDir ( testDir ) ; assertMetadataEmpty ( mDir , TEST _ DIR _ CAPACITY ) ; assert file not deleted File [ ] files = testDir . listFiles ( ) ; Assert . assertNotNull ( files ) ; assertEquals ( _NUM , files . length ) ; } 
5645	public boolean isAllowed ( Class c , String displayName ) { boolean result ; HashSet list ; result = true ; retrieve list list = ( HashSet ) m _ Allowed . get ( c ) ; check list if ( list ! = null ) result = list . contains ( displayName ) ; return result ; } 
5646	private void createSmallItems ( LinearLayout linearLayout ) { LayoutInflater inflater = ( LayoutInflater ) context . getSystemService ( Context . LAYOUT _ INFLATER _ SERVICE ) ; float height = resources . getDimension ( R . dimen . bottom _ navigation _ height ) ; float minWidth = resources . getDimension ( R . dimen . bottom _ navigation _ small _ inactive _ min _ width ) ; float maxWidth = resources . getDimension ( R . dimen . bottom _ navigation _ small _ inactive _ max _ width ) ; int layoutWidth = getWidth ( ) ; if ( layoutWidth = = _NUM | | items . size ( ) = = _NUM ) { return ; } float itemWidth = layoutWidth / items . size ( ) ; if ( itemWidth < minWidth ) { itemWidth = minWidth ; } else if ( itemWidth > maxWidth ) { itemWidth = maxWidth ; } int activeMarginTop = ( int ) resources . getDimension ( R . dimen . bottom _ navigation _ small _ margin _ top _ active ) ; float difference = resources . getDimension ( R . dimen . bottom _ navigation _ small _ selected _ width _ difference ) ; selectedItemWidth = itemWidth + items . size ( ) * difference ; itemWidth - = difference ; notSelectedItemWidth = itemWidth ; for ( int i = _NUM ; i < items . size ( ) ; i + + ) { final int itemIndex = i ; AHBottomNavigationItem item = items . get ( itemIndex ) ; View view = inflater . inflate ( R . layout . bottom _ navigation _ small _ item , this , false ) ; ImageView icon = ( ImageView ) view . findViewById ( R . id . bottom _ navigation _ small _ item _ icon ) ; TextView title = ( TextView ) view . findViewById ( R . id . bottom _ navigation _ small _ item _ title ) ; TextView notification = ( TextView ) view . findViewById ( R . id . bottom _ navigation _ notification ) ; icon . setImageDrawable ( item . getDrawable ( context ) ) ; if ( titleState ! = TitleState . ALWAYS _ HIDE ) { title . setText ( item . getTitle ( context ) ) ; } if ( titleActiveTextSize ! = _NUM ) { title . setTextSize ( TypedValue . COMPLEX _ UNIT _ PX , titleActiveTextSize ) ; } if ( titleTypeface ! = null ) { title . setTypeface ( titleTypeface ) ; } if ( i = = currentItem ) { if ( selectedBackgroundVisible ) { view . setSelected ( true ) ; } icon . setSelected ( true ) ; if ( titleState ! = TitleState . ALWAYS _ HIDE ) { if ( view . getLayoutParams ( ) instanceof ViewGroup . MarginLayoutParams ) { ViewGroup . MarginLayoutParams p = ( ViewGroup . MarginLayoutParams ) icon . getLayoutParams ( ) ; p . setMargins ( p . leftMargin , activeMarginTop , p . rightMargin , p . bottomMargin ) ; ViewGroup . MarginLayoutParams paramsNotification = ( ViewGroup . MarginLayoutParams ) notification . getLayoutParams ( ) ; paramsNotification . setMargins ( notificationActiveMarginLeft , notificationActiveMarginTop , paramsNotification . rightMargin , paramsNotification . bottomMargin ) ; view . requestLayout ( ) ; } } } else { icon . setSelected ( false ) ; ViewGroup . MarginLayoutParams paramsNotification = ( ViewGroup . MarginLayoutParams ) notification . getLayoutParams ( ) ; paramsNotification . setMargins ( notificationInactiveMarginLeft , notificationInactiveMarginTop , paramsNotification . rightMargin , paramsNotification . bottomMargin ) ; } if ( colored ) { if ( i = = currentItem ) { setBackgroundColor ( item . getColor ( context ) ) ; currentColor = item . getColor ( context ) ; } } else { if ( defaultBackgroundResource ! = _NUM ) { setBackgroundResource ( defaultBackgroundResource ) ; } else { setBackgroundColor ( defaultBackgroundColor ) ; } } if ( itemsEnabledStates [ i ] ) { icon . setImageDrawable ( AHHelper . getTintDrawable ( items . get ( i ) . getDrawable ( context ) , currentItem = = i ? itemActiveColor : itemInactiveColor , forceTint ) ) ; title . setTextColor ( currentItem = = i ? itemActiveColor : itemInactiveColor ) ; title . setAlpha ( currentItem = = i ? _NUM : _NUM ) ; view . setOnClickListener ( new OnClickListener ( ) { @ Override public void onClick ( View v ) { updateSmallItems ( itemIndex , true ) ; } } ) ; view . setSoundEffectsEnabled ( soundEffectsEnabled ) ; } else { icon . setImageDrawable ( AHHelper . getTintDrawable ( items . get ( i ) . getDrawable ( context ) , itemDisableColor , forceTint ) ) ; title . setTextColor ( itemDisableColor ) ; title . setAlpha ( _NUM ) ; } int width = i = = currentItem ? ( int ) selectedItemWidth : ( int ) itemWidth ; if ( titleState = = TitleState . ALWAYS _ HIDE ) { width = ( int ) ( itemWidth * _NUM . _NUM _NUM ) ; } LayoutParams params = new LayoutParams ( width , ( int ) height ) ; linearLayout . addView ( view , params ) ; views . add ( view ) ; } updateNotifications ( true , UPDATE _ ALL _ NOTIFICATIONS ) ; } 
5647	Guts of a key / value restore operationvoid initiateOneRestore ( PackageInfo app , int appVersionCode ) { final String packageName = app . packageName ; if ( DEBUG ) { Slog . d ( TAG , _STR + packageName , e ) ; EventLog . writeEvent ( EventLogTags . RESTORE _ AGENT _ FAILURE , packageName , e . toString ( ) ) ; clears any pending timeout messages as well keyValueAgentErrorCleanup ( ) ; After a restore failure we go back to running the queue . If there are no more packages to be restored that will be handled by the next step . executeNextState ( UnifiedRestoreState . RUNNING _ QUEUE ) ; } } 
5648	public void buildClassifier ( Instances instances ) throws Exception { can classifier handle the data ? getCapabilities ( ) . testWithFail ( instances ) ; remove instances with missing class instances = new Instances ( instances ) ; instances . deleteWithMissingClass ( ) ; m _ NumClasses = instances . numClasses ( ) ; m _ ClassType = instances . classAttribute ( ) . type ( ) ; m _ Train = new Instances ( instances , _NUM , instances . numInstances ( ) ) ; Throw away initial instances until within the specified window size if ( ( m _ WindowSize > _NUM ) & & ( instances . numInstances ( ) > m _ WindowSize ) ) { m _ Train = new Instances ( m _ Train , m _ Train . numInstances ( ) - m _ WindowSize , m _ WindowSize ) ; } m _ NumAttributesUsed = _NUM . _NUM ; for ( int i = _NUM ; i < m _ Train . numAttributes ( ) ; i + + ) { if ( ( i ! = m _ Train . classIndex ( ) ) & & ( m _ Train . attribute ( i ) . isNominal ( ) | | m _ Train . attribute ( i ) . isNumeric ( ) ) ) { m _ NumAttributesUsed + = _NUM . _NUM ; } } m _ NNSearch . setInstances ( m _ Train ) ; Invalidate any currently cross - validation selected k m _ kNNValid = false ; m _ defaultModel = new ZeroR ( ) ; m _ defaultModel . buildClassifier ( instances ) ; } 
5649	public static char [ ] getValueFromCredentialProvider ( Configuration conf , String alias ) throws IOException { requireNonNull ( conf ) ; requireNonNull ( alias ) ; if ( isHadoopCredentialProviderAvailable ( ) ) { log . trace ( _STR , alias ) ; return getFromHadoopCredentialProvider ( conf , alias ) ; } return null ; } 
5650	public void testStorageReportHasStorageTypeAndState ( ) throws IOException { Make sure we are not testing with the default type , that would not be a very good test . assertNotSame ( storageType , StorageType . DEFAULT ) ; NameNode nn = cluster . getNameNode ( ) ; DataNode dn = cluster . getDataNodes ( ) . get ( _NUM ) ; Insert a spy object for the NN RPC . DatanodeProtocolClientSideTranslatorPB nnSpy = DataNodeTestUtils . spyOnBposToNN ( dn , nn ) ; Trigger a heartbeat so there is an interaction with the spy object . DataNodeTestUtils . triggerHeartbeat ( dn ) ; Verify that the callback passed in the expected parameters . ArgumentCaptor < StorageReport [ ] > captor = ArgumentCaptor . forClass ( StorageReport [ ] . class ) ; Mockito . verify ( nnSpy ) . sendHeartbeat ( any ( DatanodeRegistration . class ) , captor . capture ( ) , anyLong ( ) , anyLong ( ) , anyInt ( ) , anyInt ( ) , anyInt ( ) , Mockito . any ( VolumeFailureSummary . class ) , Mockito . anyBoolean ( ) ) ; StorageReport [ ] reports = captor . getValue ( ) ; for ( StorageReport report : reports ) { assertThat ( report . getStorage ( ) . getStorageType ( ) , is ( storageType ) ) ; assertThat ( report . getStorage ( ) . getState ( ) , is ( DatanodeStorage . State . NORMAL ) ) ; } } 
5651	public static void normalizeRequests ( List < ResourceRequest > asks , ResourceCalculator resourceCalculator , Resource clusterResource , Resource minimumResource , Resource maximumResource ) { for ( ResourceRequest ask : asks ) { normalizeRequest ( ask , resourceCalculator , clusterResource , minimumResource , maximumResource , minimumResource ) ; } } 
5652	private List < KeyStatus > keyStatusListFromParcel ( @ NonNull Parcel parcel ) { int nelems = parcel . readInt ( ) ; List < KeyStatus > keyStatusList = new ArrayList ( nelems ) ; while ( nelems - - > _NUM ) { byte [ ] keyId = parcel . createByteArray ( ) ; int keyStatusCode = parcel . readInt ( ) ; keyStatusList . add ( new KeyStatus ( keyId , keyStatusCode ) ) ; } return keyStatusList ; } 
5653	public void testCreateReporterUsesCorrectSender ( ) throws Exception { testedService = new TestableGraphiteMetricReporterService ( ) ; runner . addControllerService ( SERVICE _ IDENTIFIER , testedService ) ; setServiceProperties ( TEST _ HOST , TEST _ PORT , TEST _ CHARSET , METRIC _ NAMES _ PREFIX ) ; when ( graphiteSenderMock . isConnected ( ) ) . thenReturn ( false ) ; runner . enableControllerService ( testedService ) ; ScheduledReporter createdReporter = testedService . createReporter ( metricRegistryStub ) ; createdReporter . report ( ) ; String expectedMetricName = MetricRegistry . name ( METRIC _ NAMES _ PREFIX , TEST _ METRIC _ NAME ) ; verify ( graphiteSenderMock ) . send ( eq ( expectedMetricName ) , eq ( String . valueOf ( TEST _ METRIC _ VALUE ) ) , anyLong ( ) ) ; } 
5654	public double fBeta ( double beta , int classLabel , double defaultValue ) { double precision = precision ( classLabel , - _NUM ) ; double recall = recall ( classLabel , - _NUM ) ; if ( precision = = - _NUM | | recall = = - _NUM ) { return defaultValue ; } return EvaluationUtils . fBeta ( beta , precision , recall ) ; } 
5655	public Delete addFamily ( final byte [ ] family , final long timestamp ) { if ( timestamp < _NUM ) { throw new IllegalArgumentException ( _STR + timestamp ) ; } List < Cell > list = getCellList ( family ) ; if ( ! list . isEmpty ( ) ) { list . clear ( ) ; } KeyValue kv = new KeyValue ( row , family , null , timestamp , KeyValue . Type . DeleteFamily ) ; list . add ( kv ) ; return this ; } 
5656	public void clearMatches ( ) { checkThread ( ) ; mProvider . clearMatches ( ) ; } 
5657	protected void doPost ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { doCommon ( request , response ) ; } 
5658	public void usage ( ) { StringBuilder sb = new StringBuilder ( ) ; usageFormatter . usage ( sb ) ; getConsole ( ) . println ( sb . toString ( ) ) ; } 
5659	public static boolean isVersionInStack ( StackId stackId , String version ) { if ( null ! = version & & ! StringUtils . isBlank ( version ) ) { String stackName = stackId . getStackName ( ) ; if ( version . startsWith ( stackName + _STR + leadingParts [ _NUM ] ; } return version . startsWith ( leading ) ; } return false ; } 
5660	public void rebuildAll ( ) { synchronized ( mLock ) { mInstalledSet . clear ( ) ; mEnabledSet . clear ( ) ; final int [ ] userIds = getCurrentProfileIds ( ) ; for ( int i : userIds ) { ArraySet < ComponentName > implementingPackages = loadComponentNamesForUser ( i ) ; ArraySet < ComponentName > packagesFromSettings = loadComponentNamesFromSetting ( mSettingName , i ) ; packagesFromSettings . retainAll ( implementingPackages ) ; mInstalledSet . put ( i , implementingPackages ) ; mEnabledSet . put ( i , packagesFromSettings ) ; } } sendSettingChanged ( ) ; } 
5661	public static Marker getMarker ( final String name ) { Marker result = MARKERS . get ( name ) ; if ( result = = null ) { MARKERS . putIfAbsent ( name , new Log _NUM jMarker ( name ) ) ; result = MARKERS . get ( name ) ; } return result ; } 
5662	public float getVerticalPosition ( boolean ensureNewLine ) { ensuring that a new line has been started . if ( ensureNewLine ) { ensureNewLine ( ) ; } return top ( ) - currentHeight - indentation . indentTop ; } 
5663	public static NetworkParameters regTests ( ) { return RegTestParams . get ( ) ; } 
5664	private boolean existsAndIsExpectedFile ( FileStatus status ) throws IOException { if ( ! getFS ( ) . exists ( status . getPath ( ) ) ) { return false ; } FileStatus currentFileStatus = getFS ( ) . getFileStatus ( status . getPath ( ) ) ; if ( currentFileStatus . getLen ( ) ! = status . getLen ( ) | | currentFileStatus . getModificationTime ( ) > status . getModificationTime ( ) ) { return false ; } return true ; } 
5665	public static void doResponseJson ( HttpAction action , Iterator < JsonObject > jsonItem ) { if ( jsonItem = = null ) { xlog . warn ( _STR ) ; } jsonOutput ( action , jsonItem ) ; } 
5666	public final void removeMedia ( int index ) { logger . debug ( _STR , index ) ; try { lock ( ) ; libvlc _ media _ t oldMediaInstance = libvlc . libvlc _ media _ list _ item _ at _ index ( mediaListInstance , index ) ; if ( oldMediaInstance ! = null ) { Remove the media descriptor from the media list libvlc . libvlc _ media _ list _ remove _ index ( mediaListInstance , index ) ; Release the native media instance libvlc . libvlc _ media _ release ( oldMediaInstance ) ; } } finally { unlock ( ) ; } } 
5667	public void execPBSZ ( long pbsz ) throws SSLException , IOException { if ( pbsz < _NUM | | _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM L < pbsz ) { _NUM _NUM - bit unsigned number throw new IllegalArgumentException ( ) ; } int status = sendCommand ( CMD _ PBSZ , String . valueOf ( pbsz ) ) ; if ( FTPReply . COMMAND _ OK ! = status ) { throw new SSLException ( getReplyString ( ) ) ; } } 
5668	private static void headR ( final String function ) throws IOException { install ( function ) ; assertEquals ( _STR ) ) ; } 
5669	private void startConsumers ( ) { Try starting consumers ( which will fail if RabbitMQ can ' t connect ) try { for ( RabbitConsumer consumer : this . consumers ) { consumer . start ( ) ; } } catch ( Exception e ) { log . info ( _STR , e ) ; reconnect ( ) ; } } 
5670	public void stop ( final JobException ex ) throws IOException { final int code = _NUM _NUM _NUM ; final String info = ex . getMessage ( ) ; log ( code , info ) ; try { res . resetBuffer ( ) ; res . setStatus ( code ) ; res . setContentType ( MediaType . TEXT _ PLAIN . toString ( ) ) ; client directive : do not cache result ( HTTP _NUM . _NUM , old clients ) res . setHeader ( CACHE _ CONTROL , _STR ) ; res . getOutputStream ( ) . write ( token ( info ) ) ; } catch ( final IllegalStateException e ) { too late ( response has already been committed ) logError ( code , null , info , e ) ; } } 
5671	public Exchange recover ( CamelContext camelContext , String exchangeId ) { List < Row > rows = selectKeyIds ( ) ; String keyColumnName = getKeyColumn ( ) ; String lKey = null ; for ( Row row : rows ) { String lExchangeId = row . getString ( exchangeIdColumn ) ; if ( lExchangeId . equals ( exchangeId ) ) { lKey = row . getString ( keyColumnName ) ; break ; } } return lKey = = null ? null : get ( camelContext , lKey ) ; } 
5672	public void addExcludedSubtree ( GeneralSubtree subtree ) { GeneralName base = subtree . getBase ( ) ; switch ( base . getTagNo ( ) ) { case _NUM : excludedSubtreesEmail = unionEmail ( excludedSubtreesEmail , extractNameAsString ( base ) ) ; break ; case _NUM : excludedSubtreesDNS = unionDNS ( excludedSubtreesDNS , extractNameAsString ( base ) ) ; break ; case _NUM : excludedSubtreesDN = unionDN ( excludedSubtreesDN , ( ASN _NUM Sequence ) base . getName ( ) . toASN _NUM Primitive ( ) ) ; break ; case _NUM : excludedSubtreesURI = unionURI ( excludedSubtreesURI , extractNameAsString ( base ) ) ; break ; case _NUM : excludedSubtreesIP = unionIP ( excludedSubtreesIP , ASN _NUM OctetString . getInstance ( base . getName ( ) ) . getOctets ( ) ) ; break ; } } 
5673	protected Object parse ( final InputSource input , final URL contentBase ) throws ElementDefinitionException { try { final SAXParser parser = getParser ( ) ; final XMLReader reader = parser . getXMLReader ( ) ; try { reader . setFeature ( _STR , se ) ; } final FrontendDefaultHandler handler = createDefaultHandler ( contentBase ) ; configureReader ( reader , handler ) ; try { reader . setContentHandler ( handler ) ; reader . setDTDHandler ( handler ) ; if ( getEntityResolver ( ) ! = null ) { reader . setEntityResolver ( getEntityResolver ( ) ) ; } reader . setErrorHandler ( handler ) ; reader . parse ( input ) ; return handler . getResult ( ) ; } catch ( IOException e ) { throw new ElementDefinitionException ( e ) ; } } catch ( ParserConfigurationException e ) { throw new ElementDefinitionException ( e ) ; } catch ( SAXException e ) { throw new ElementDefinitionException ( e ) ; } } 
5674	public static long maxValue ( RelDataType type ) { assert SqlTypeUtil . isIntType ( type ) ; switch ( type . getSqlTypeName ( ) ) { case TINYINT : return Byte . MAX _ VALUE ; case SMALLINT : return Short . MAX _ VALUE ; case INTEGER : return Integer . MAX _ VALUE ; case BIGINT : return Long . MAX _ VALUE ; default : throw Util . unexpected ( type . getSqlTypeName ( ) ) ; } } 
5675	public short getIndex ( ) { return ( short ) ctColor . getIndexed ( ) ; } 
5676	public void setBasebandVersion ( String version ) { int phoneId = getPhoneId ( ) ; setBasebandVersionForPhone ( phoneId , version ) ; } 
5677	increment ref count if not already tidied , and return success / failureboolean ref ( ) { while ( true ) { int cur = counts . get ( ) ; if ( cur < _NUM ) return false ; if ( counts . compareAndSet ( cur , cur + _NUM ) ) return true ; } } 
5678	public void testGroupUserPerms ( ) throws Exception { startNewMiniCluster ( ) ; if ( isNamespaceMapped ) { verifyAllowed ( createSchema ( SCHEMA _ NAME ) , superUser _NUM ) ; } verifyAllowed ( createTable ( FULL _ TABLE _ NAME ) , superUser _NUM ) ; Grant SYSTEM table access to GROUP _ SYSTEM _ ACCESS and regularUser _NUM verifyAllowed ( grantPermissions ( _STR , regularUser _NUM , FULL _ TABLE _ NAME , false ) , groupUser ) ; verifyAllowed ( readTable ( FULL _ TABLE _ NAME ) , regularUser _NUM ) ; Revoke the perms and try accessing data again verifyAllowed ( revokePermissions ( GROUP _ SYSTEM _ ACCESS , FULL _ TABLE _ NAME , false ) , superUser _NUM ) ; verifyDenied ( readTable ( FULL _ TABLE _ NAME ) , AccessDeniedException . class , groupUser ) ; } 
5679	public void testLoopedReplication ( ) throws Exception { LOG . info ( _STR ) ) ; List < String > listChildrenNoWatch = ZKUtil . listChildrenNoWatch ( zkw , ZNodePaths . joinZNode ( queuesZnode , rsName . toString ( ) ) ) ; assertEquals ( _NUM , listChildrenNoWatch . size ( ) ) ; } 
5680	public void register ( Resource node , Dataset ds ) { Dataset dsCurrent = map . get ( node ) ; if ( dsCurrent ! = null ) { if ( ! dsCurrent . equals ( ds ) ) Log . warn ( this . getClass ( ) , _STR + node ) ; } map . add ( node , ds ) ; } 
5681	public EncodedImage scaledEncoded ( int width , int height ) { if ( width = = getWidth ( ) & & height = = getHeight ( ) ) { return this ; } if ( width < _NUM ) { float ratio = ( ( float ) height ) / ( ( float ) getHeight ( ) ) ; width = Math . max ( _NUM , ( int ) ( getWidth ( ) * ratio ) ) ; } else { if ( height < _NUM ) { float ratio = ( ( float ) width ) / ( ( float ) getWidth ( ) ) ; height = Math . max ( _NUM , ( int ) ( getHeight ( ) * ratio ) ) ; } } try { ImageIO io = ImageIO . getImageIO ( ) ; if ( io ! = null ) { String format = ImageIO . FORMAT _ PNG ; if ( isOpaque ( ) | | ! io . isFormatSupported ( ImageIO . FORMAT _ PNG ) ) { if ( io . isFormatSupported ( ImageIO . FORMAT _ JPEG ) ) { format = ImageIO . FORMAT _ JPEG ; } } if ( io . isFormatSupported ( format ) ) { do an image IO scale which is more efficient ByteArrayOutputStream bo = new ByteArrayOutputStream ( ) ; io . save ( new ByteArrayInputStream ( getImageData ( ) ) , bo , format , width , height , _NUM . _NUM f ) ; EncodedImage img = EncodedImage . create ( bo . toByteArray ( ) ) ; Util . cleanup ( bo ) ; img . opaque = opaque ; img . opaqueChecked = opaqueChecked ; if ( width > - _NUM & & height > - _NUM ) { img . width = width ; img . height = height ; } return img ; } } } catch ( IOException err ) { normally this shouldn ' t happen but this will keep falling back to the existing scaled code Log . e ( err ) ; } return null ; } 
5682	public static SchemaChange deserializeEvent ( ByteBuf cb , ProtocolVersion version ) { Change change = CBUtil . readEnumValue ( Change . class , cb ) ; if ( version . isGreaterOrEqualTo ( ProtocolVersion . V _NUM ) ) { Target target = CBUtil . readEnumValue ( Target . class , cb ) ; String keyspace = CBUtil . readString ( cb ) ; String tableOrType = target = = Target . KEYSPACE ? null : CBUtil . readString ( cb ) ; List < String > argTypes = null ; if ( target = = Target . FUNCTION | | target = = Target . AGGREGATE ) argTypes = CBUtil . readStringList ( cb ) ; return new SchemaChange ( change , target , keyspace , tableOrType , argTypes ) ; } else { String keyspace = CBUtil . readString ( cb ) ; String table = CBUtil . readString ( cb ) ; return new SchemaChange ( change , table . isEmpty ( ) ? Target . KEYSPACE : Target . TABLE , keyspace , table . isEmpty ( ) ? null : table ) ; } } 
5683	protected final void moveToNextIndex ( ) { _NUM opcodes . . . if ( ( _ index = nextIndex ( ) ) < _NUM ) { throw new NoSuchElementException ( ) ; } } 
5684	 @ Test ( groups = _STR + type ) ; } } 
5685	public < T > CompletableFuture < T > sendMessageAndGetCompletable ( ChannelHandlerContext ctx , CorfuMsg message ) { Simulate a _STR , thisRequest ) ; return null ; } ) ; return cfTimeout ; } 
5686	public void delayedProposeTest ( ) throws Exception { addServer ( SERVERS . PORT _ _NUM ) ; addServer ( SERVERS . PORT _ _NUM ) ; addServer ( SERVERS . PORT _ _NUM ) ; Layout l = new TestLayoutBuilder ( ) . setEpoch ( _NUM L ) . addLayoutServer ( SERVERS . PORT _ _NUM ) . addLayoutServer ( SERVERS . PORT _ _NUM ) . addLayoutServer ( SERVERS . PORT _ _NUM ) . addSequencer ( SERVERS . PORT _ _NUM ) . buildSegment ( ) . buildStripe ( ) . addLogUnit ( SERVERS . PORT _ _NUM ) . addToSegment ( ) . addToLayout ( ) . build ( ) ; bootstrapAllServers ( l ) ; CorfuRuntime corfuRuntime _NUM = getRuntime ( l ) . connect ( ) ; CorfuRuntime corfuRuntime _NUM = getRuntime ( l ) . connect ( ) ; getManagementServer ( SERVERS . PORT _ _NUM ) . shutdown ( ) ; getManagementServer ( SERVERS . PORT _ _NUM ) . shutdown ( ) ; getManagementServer ( SERVERS . PORT _ _NUM ) . shutdown ( ) ; setAggressiveTimeouts ( l , corfuRuntime _NUM , corfuRuntime _NUM ) ; Layout l _NUM = new TestLayoutBuilder ( ) . setEpoch ( _NUM L ) . addLayoutServer ( SERVERS . PORT _ _NUM ) . addLayoutServer ( SERVERS . PORT _ _NUM ) . addLayoutServer ( SERVERS . PORT _ _NUM ) . addSequencer ( SERVERS . PORT _ _NUM ) . addSequencer ( SERVERS . PORT _ _NUM ) . buildSegment ( ) . buildStripe ( ) . addLogUnit ( SERVERS . PORT _ _NUM ) . addToSegment ( ) . addToLayout ( ) . build ( ) ; Layout l _NUM = new TestLayoutBuilder ( ) . setEpoch ( _NUM L ) . addLayoutServer ( SERVERS . PORT _ _NUM ) . addLayoutServer ( SERVERS . PORT _ _NUM ) . addLayoutServer ( SERVERS . PORT _ _NUM ) . addSequencer ( SERVERS . PORT _ _NUM ) . addSequencer ( SERVERS . PORT _ _NUM ) . buildSegment ( ) . buildStripe ( ) . addLogUnit ( SERVERS . PORT _ _NUM ) . addToSegment ( ) . addToLayout ( ) . build ( ) ; l . setEpoch ( l . getEpoch ( ) + _NUM ) ; corfuRuntime _NUM . getLayoutView ( ) . getRuntimeLayout ( l ) . moveServersToEpoch ( ) ; Semaphore proposeLock = new Semaphore ( _NUM ) ; ExecutorService executorService = Executors . newSingleThreadExecutor ( ) ; STEP _NUM : Send prepare to all _NUM nodes with rank _NUM . final long rank _NUM = _NUM L ; Layout alreadyProposedLayout _NUM = corfuRuntime _NUM . getLayoutView ( ) . prepare ( l _NUM . getEpoch ( ) , rank _NUM ) ; assertThat ( alreadyProposedLayout _NUM ) . isNull ( ) ; PORT _ _NUM drops the oncoming propose message . addClientRule ( corfuRuntime _NUM , SERVERS . ENDPOINT _ _NUM , new TestRule ( ) . drop ( ) . always ( ) ) ; Add rule to hold the propose message sent to PORT _ _NUM . addClientRule ( corfuRuntime _NUM , SERVERS . ENDPOINT _ _NUM , new TestRule ( ) . matches ( msg - > { if ( msg . getMsgType ( ) . equals ( CorfuMsgType . LAYOUT _ PROPOSE ) ) { proposeLock . release ( ) ; } return true ; } ) ) ; holdMessage ( corfuRuntime _NUM , SERVERS . ENDPOINT _ _NUM , CorfuMsgType . LAYOUT _ PROPOSE ) ; Asynchronously send a propose message to PORT _ _NUM and PORT _ _NUM ( PORT _ _NUM is disabled ) Future < Boolean > future = executorService . submit ( ( ) - > { try { corfuRuntime _NUM . getLayoutView ( ) . propose ( l _NUM . getEpoch ( ) , rank _NUM , l _NUM ) ; } catch ( QuorumUnreachableException e ) { return true ; } catch ( OutrankedException ignore ) { } return false ; } ) ; AtomicBoolean proposalRejected = new AtomicBoolean ( false ) ; addServerRule ( SERVERS . PORT _ _NUM , new TestRule ( ) . matches ( msg - > { if ( msg . getMsgType ( ) . equals ( CorfuMsgType . LAYOUT _ PROPOSE _ REJECT ) ) { proposalRejected . set ( true ) ; } return true ; } ) ) ; proposeLock . tryAcquire ( PARAMETERS . TIMEOUT _ NORMAL . toMillis ( ) , TimeUnit . MILLISECONDS ) ; After propose delayed , send a prepare to PORT _ _NUM and PORT _ _NUM . final long rank _NUM = _NUM L ; addClientRule ( corfuRuntime _NUM , SERVERS . ENDPOINT _ _NUM , new TestRule ( ) . drop ( ) . always ( ) ) ; Layout alreadyProposedLayout _NUM = corfuRuntime _NUM . getLayoutView ( ) . prepare ( l _NUM . getEpoch ( ) , rank _NUM ) ; assertThat ( alreadyProposedLayout _NUM ) . isNull ( ) ; while ( messageLocks . isEmpty ( ) ) { Thread . sleep ( PARAMETERS . TIMEOUT _ VERY _ SHORT . toMillis ( ) ) ; } release the held propose message releaseMessages ( SERVERS . ENDPOINT _ _NUM , CorfuMsgType . LAYOUT _ PROPOSE ) ; try { alreadyProposedLayout _NUM = corfuRuntime _NUM . getLayoutView ( ) . propose ( l _NUM . getEpoch ( ) , rank _NUM , l _NUM ) ; assertThat ( alreadyProposedLayout _NUM ) . isEqualTo ( l _NUM ) ; } catch ( QuorumUnreachableException ignore ) { } Assert that the proposal with rank _NUM and layout l _NUM is rejected and a LAYOUT _ PROPOSE _ REJECTED is returned by the server . assertThat ( future . get ( ) ) . isTrue ( ) ; assertThat ( proposalRejected . get ( ) ) . isTrue ( ) ; clearClientRules ( corfuRuntime _NUM ) ; final long rank _NUM = _NUM L ; Layout alreadyProposedLayout _NUM = corfuRuntime _NUM . getLayoutView ( ) . prepare ( l . getEpoch ( ) , rank _NUM ) ; assertThat ( alreadyProposedLayout _NUM ) . isEqualTo ( l _NUM ) ; } 
5687	public static XmlInteger parse ( javax . xml . stream . XMLStreamReader xsr ) throws org . apache . xmlbeans . XmlException { return ( XmlInteger ) XmlBeans . getContextTypeLoader ( ) . parse ( xsr , type , null ) ; } 
5688	public Builder clearCatalogs ( ) { if ( catalogsBuilder _ = = null ) { catalogs _ = java . util . Collections . emptyList ( ) ; bitField _NUM _ = ( bitField _NUM _ & ~ _NUM x _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM ) ; onChanged ( ) ; } else { catalogsBuilder _ . clear ( ) ; } return this ; } 
5689	public String usage ( ) { return getName ( ) ; } 
5690	public static void fatal ( Class < ? > cls , String msg ) { log ( cls ) . error ( msg ) ; } 
5691	public void addUnfocusedTaskOverride ( Task task , float stackScroll ) { if ( mFocusState ! = STATE _ UNFOCUSED ) { mFocusedRange . offset ( stackScroll ) ; mUnfocusedRange . offset ( stackScroll ) ; float focusedRangeX = mFocusedRange . getNormalizedX ( mTaskIndexMap . get ( task . key . id ) ) ; float focusedY = mFocusedCurveInterpolator . getInterpolation ( focusedRangeX ) ; float unfocusedRangeX = mUnfocusedCurveInterpolator . getX ( focusedY ) ; float unfocusedTaskProgress = stackScroll + mUnfocusedRange . getAbsoluteX ( unfocusedRangeX ) ; if ( Float . compare ( focusedRangeX , unfocusedRangeX ) ! = _NUM ) { mTaskIndexOverrideMap . put ( task . key . id , unfocusedTaskProgress ) ; } } } 
5692	public static void main ( String [ ] args ) throws Exception { if ( args . length ! = _NUM ) { System . err . println ( _STR ) ; System . exit ( _NUM ) ; } Pair < Language , Language > languagePair = new Pair < Language , Language > ( Language . valueOf ( args [ _NUM ] ) , Language . valueOf ( args [ _NUM ] ) ) ; Experimenter er = new Experimenter ( languagePair ) ; er . runExperiments ( ) ; } 
5693	public String toString ( ) { StringBuffer sb = new StringBuffer ( ) ; String s = getMessage ( ) ; if ( s ! = null ) { sb . append ( s ) ; } if ( getIndex ( ) > = _NUM ) { sb . append ( _STR ) . append ( getIndex ( ) ) . append ( ' \ n ' ) ; sb . append ( getCertPath ( ) ) ; } return sb . toString ( ) ; } 
5694	protected String allocateSourceIpForLbRule ( Scheme scheme , Network sourceIpNtwk , String requestedIp ) { String sourceIp = null ; if ( scheme ! = Scheme . Internal ) { throw new InvalidParameterValueException ( _STR ) ; } else { sourceIp = allocateSourceIpForInternalLbRule ( sourceIpNtwk , requestedIp ) ; } return sourceIp ; } 
5695	public void initialLastModificationTime ( ) { long lowerBoundMs = System . currentTimeMillis ( ) ; InodeDirectory inodeDirectory = createInodeDirectory ( ) ; long upperBoundMs = System . currentTimeMillis ( ) ; long lastModificationTimeMs = inodeDirectory . getLastModificationTimeMs ( ) ; Assert . assertTrue ( lowerBoundMs < = lastModificationTimeMs ) ; Assert . assertTrue ( upperBoundMs > = lastModificationTimeMs ) ; } 
5696	public String toString ( int annoWidth , int line , boolean useLocalLabels ) { StringBuilder builder = new StringBuilder ( ) ; builder . append ( StringUtil . alignLeft ( annotation , annoWidth ) ) ; if ( useLocalLabels ) { labels . formatAddress ( address , builder ) ; } else { builder . append ( S _ HEX _ PREFIX ) . append ( StringUtil . pad ( Long . toHexString ( address ) , _NUM _NUM , ' _NUM ' , true ) ) ; } builder . append ( C _ COLON ) . append ( C _ SPACE ) ; if ( ! prefixes . isEmpty ( ) ) { for ( String prefix : prefixes ) { builder . append ( prefix ) ; builder . append ( C _ SPACE ) ; } } builder . append ( mnemonic ) ; if ( useLocalLabels ) { labels . formatOperands ( this , builder ) ; } else { if ( operands . size ( ) > _NUM ) { builder . append ( C _ SPACE ) ; for ( String op : operands ) { builder . append ( op ) . append ( S _ COMMA ) ; } builder . deleteCharAt ( builder . length ( ) - _NUM ) ; } } int lineLength = builder . length ( ) ; if ( commentLines . size ( ) > _NUM ) { String comment = commentLines . get ( line ) ; if ( line = = _NUM ) { first comment on same line as instruction builder . append ( S _ DOUBLE _ SPACE ) . append ( comment ) ; } else { later comments on own line builder . delete ( _NUM , builder . length ( ) ) ; builder . append ( StringUtil . repeat ( C _ SPACE , lineLength + _NUM ) ) ; builder . append ( comment ) ; } if ( comment . contains ( S _ SAFEPOINT _ POLL ) | | comment . contains ( S _ SAFEPOINT _ POLL _ RETURN ) ) { builder . append ( _STR ) ; } builder . append ( S _ NEWLINE ) ; } else { builder . append ( S _ NEWLINE ) ; } return StringUtil . rtrim ( builder . toString ( ) ) ; } 
5697	public static ValidateResult updateValidate ( String dbName , String sql , int [ ] paramsTypes , String [ ] vals ) { Object [ ] mockedVals = parseSQLValue ( paramsTypes , vals ) ; return updateValidate ( dbName , sql , paramsTypes , mockedVals ) ; } 
5698	public static Factory newSliceFactory ( String name , Selector . Factory factory , CollectionType < ? > type , final Term from , final Term to ) { return new AbstractFactory ( name , factory , type ) { protected AbstractType < ? > getReturnType ( ) { return type ; } public Selector newInstance ( QueryOptions options ) throws InvalidRequestException { ByteBuffer fromValue = from . bindAndGet ( options ) ; ByteBuffer toValue = to . bindAndGet ( options ) ; Note that we use UNSET values to represent no bound , so null is truly invalid if ( fromValue = = null | | toValue = = null ) throw new InvalidRequestException ( _STR + factory . getColumnName ( ) ) ; return new SliceSelector ( factory . newInstance ( options ) , from . bindAndGet ( options ) , to . bindAndGet ( options ) ) ; } public boolean areAllFetchedColumnsKnown ( ) { _NUM ) the bound of the selected slice are terminal . return factory . areAllFetchedColumnsKnown ( ) & & ( ! type . isMultiCell ( ) | | ! factory . isSimpleSelectorFactory ( ) | | ( from . isTerminal ( ) & & to . isTerminal ( ) ) ) ; } public void addFetchedColumns ( ColumnFilter . Builder builder ) { if ( ! type . isMultiCell ( ) | | ! factory . isSimpleSelectorFactory ( ) ) { factory . addFetchedColumns ( builder ) ; return ; } ColumnMetadata column = ( ( SimpleSelectorFactory ) factory ) . getColumn ( ) ; ByteBuffer fromBB = ( ( Term . Terminal ) from ) . get ( ProtocolVersion . V _NUM ) ; ByteBuffer toBB = ( ( Term . Terminal ) to ) . get ( ProtocolVersion . V _NUM ) ; builder . slice ( column , isUnset ( fromBB ) ? CellPath . BOTTOM : CellPath . create ( fromBB ) , isUnset ( toBB ) ? CellPath . TOP : CellPath . create ( toBB ) ) ; } } ; } 
5699	public void testFour ( ) throws Exception { for ( int i = _NUM ; i < _NUM _NUM _NUM ; i + + ) { testThree ( ) ; closeAndReOpen ( ) ; } } 
5700	private void shutdownClientServers ( ) { setRpcReady ( false ) ; stopNativeTransport ( ) ; } 
5701	public OutputStream getOutputStream ( ) throws IOException { implCreateIfNeeded ( ) ; return impl . getOutputStream ( ) ; } 
5702	public double getProbability ( double data , double given ) { return getEstimator ( given ) . getProbability ( data ) ; } 
5703	public BloxClientBuilder iamCredentials ( AWSCredentialsProvider iamCredentials ) { setIamCredentials ( iamCredentials ) ; return this ; } 
5704	public void putInBuffer ( final ByteBuffer buf ) { assert proto . getSerializedSize ( ) < = MAX _ PROTO _ SIZE : _STR + proto . getSerializedSize ( ) ; try { buf . putInt ( packetLen ) ; buf . putShort ( ( short ) proto . getSerializedSize ( ) ) ; proto . writeTo ( new ByteBufferOutputStream ( buf ) ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } 
5705	private FlowDTO postProcessNewFlowSnippet ( final String groupId , final FlowSnippetDTO snippet ) { validate the new snippet validateSnippetContents ( snippet ) ; identify all components added final Set < String > identifiers = new HashSet < > ( ) ; snippet . getProcessors ( ) . stream ( ) . map ( proc - > proc . getId ( ) ) . forEach ( id - > identifiers . add ( id ) ) ; snippet . getConnections ( ) . stream ( ) . map ( conn - > conn . getId ( ) ) . forEach ( id - > identifiers . add ( id ) ) ; snippet . getInputPorts ( ) . stream ( ) . map ( port - > port . getId ( ) ) . forEach ( id - > identifiers . add ( id ) ) ; snippet . getOutputPorts ( ) . stream ( ) . map ( port - > port . getId ( ) ) . forEach ( id - > identifiers . add ( id ) ) ; snippet . getProcessGroups ( ) . stream ( ) . map ( group - > group . getId ( ) ) . forEach ( id - > identifiers . add ( id ) ) ; snippet . getRemoteProcessGroups ( ) . stream ( ) . map ( remoteGroup - > remoteGroup . getId ( ) ) . forEach ( id - > identifiers . add ( id ) ) ; snippet . getRemoteProcessGroups ( ) . stream ( ) . filter ( remoteGroup - > remoteGroup . getContents ( ) ! = null & & remoteGroup . getContents ( ) . getInputPorts ( ) ! = null ) . flatMap ( remoteGroup - > remoteGroup . getContents ( ) . getInputPorts ( ) . stream ( ) ) . map ( remoteInputPort - > remoteInputPort . getId ( ) ) . forEach ( id - > identifiers . add ( id ) ) ; snippet . getRemoteProcessGroups ( ) . stream ( ) . filter ( remoteGroup - > remoteGroup . getContents ( ) ! = null & & remoteGroup . getContents ( ) . getOutputPorts ( ) ! = null ) . flatMap ( remoteGroup - > remoteGroup . getContents ( ) . getOutputPorts ( ) . stream ( ) ) . map ( remoteOutputPort - > remoteOutputPort . getId ( ) ) . forEach ( id - > identifiers . add ( id ) ) ; snippet . getLabels ( ) . stream ( ) . map ( label - > label . getId ( ) ) . forEach ( id - > identifiers . add ( id ) ) ; final ProcessGroup group = processGroupDAO . getProcessGroup ( groupId ) ; final ProcessGroupStatus groupStatus = controllerFacade . getProcessGroupStatus ( groupId ) ; return dtoFactory . createFlowDto ( group , groupStatus , snippet , revisionManager , this : : getProcessGroupBulletins ) ; } 
5706	protected int insertKey ( float val ) { int hash , index ; hash = HashFunctions . hash ( val ) & _NUM x _NUM fffffff ; index = hash % _ states . length ; byte state = _ states [ index ] ; consumeFreeSlot = false ; if ( state = = FREE ) { consumeFreeSlot = true ; insertKeyAt ( index , val ) ; empty , all done return index ; } if ( state = = FULL & & _ set [ index ] = = val ) { already stored return - index - _NUM ; } already FULL or REMOVED , must probe return insertKeyRehash ( val , index , hash , state ) ; } 
5707	public void testRemoveRestrictBackgroundWhitelist _ restrictBackgroundOff ( ) throws Exception { Sanity check . assertRestrictBackgroundOff ( ) ; removeRestrictBackgroundWhitelist ( false ) ; } 
5708	public static void attachView ( View view ) { Make sure hardware acceleration isn ' t turned on . view . getContext ( ) . getApplicationInfo ( ) . flags & = ~ ( ApplicationInfo . FLAG _ HARDWARE _ ACCELERATED ) ; WindowManager . LayoutParams lp = new WindowManager . LayoutParams ( LayoutParams . MATCH _ PARENT , LayoutParams . MATCH _ PARENT , LayoutParams . TYPE _ APPLICATION _ OVERLAY , _NUM , PixelFormat . TRANSLUCENT ) ; view . getContext ( ) . getSystemService ( WindowManager . class ) . addView ( view , lp ) ; } 
5709	public void setLabelGap ( double gap ) { this . labelGap = gap ; fireChangeEvent ( ) ; } 
5710	public byte [ ] toByteArray ( ) { try { ByteArrayOutputStream array = new ByteArrayOutputStream ( ) ; DataOutputStream out = new DataOutputStream ( array ) ; out . writeShort ( width ) ; out . writeShort ( height ) ; out . writeByte ( palette . length ) ; int plen = palette . length ; for ( int iter = _NUM ; iter < plen ; iter + + ) { out . writeInt ( palette [ iter ] ) ; } out . write ( imageDataByte ) ; out . close ( ) ; return array . toByteArray ( ) ; } catch ( IOException ex ) { will never happen since IO is purely in memory ex . printStackTrace ( ) ; return null ; } } 
5711	public synchronized void close ( CloseMode closeMode ) throws IOException { Preconditions . checkState ( state . compareAndSet ( State . STARTED , State . CLOSED ) , _STR ) ; cancelStartTask ( ) ; try { setNode ( null ) ; client . removeWatchers ( ) ; } catch ( Exception e ) { ThreadUtils . checkInterrupted ( e ) ; throw new IOException ( e ) ; } finally { client . getConnectionStateListenable ( ) . removeListener ( listener ) ; switch ( closeMode ) { case NOTIFY _ LEADER : { setLeadership ( false ) ; listeners . clear ( ) ; break ; } default : { listeners . clear ( ) ; setLeadership ( false ) ; break ; } } } } 
5712	public boolean tryExclusiveMode ( ) { return startExclusiveMode ( false ) ; } 
5713	public static void move ( final File src , File dest , final int retryTimes ) throws IOException { copy ( src , dest , retryTimes ) ; delete ( src , retryTimes ) ; } 
5714	private LogicalExpression rewriteUnionFunction ( FunctionCall call , FunctionLookupContext functionLookupContext ) { LogicalExpression [ ] args = new LogicalExpression [ call . args . size ( ) ] ; call . args . toArray ( args ) ; for ( int i = _NUM ; i < args . length ; i + + ) { LogicalExpression arg = call . args . get ( i ) ; MajorType majorType = arg . getMajorType ( ) ; if ( majorType . getMinorType ( ) ! = MinorType . UNION ) { continue ; } List < MinorType > subTypes = majorType . getSubTypeList ( ) ; Preconditions . checkState ( subTypes . size ( ) > _NUM , _STR ) ; } 
5715	public boolean isAllSegmentScanFinished ( ) { synchronized ( segmentScanStates ) { for ( int segment = _NUM ; segment < totalSegments ; segment + + ) { if ( segmentScanStates . get ( segment ) ! = SegmentScanState . SegmentScanCompleted ) { return false ; } } Shut down if all data have been scanned and loaded . executorService . shutdown ( ) ; return true ; } } 
5716	public static Op toQuadBlockForm ( Op op ) { return AlgebraQuad . quadizeBlock ( op ) ; } 
5717	private void drawIntermediateGridLine ( final Graphics g , final boolean drawX , final double d , final String caption ) { String cap = caption ; final int pos = calcCoordinate ( drawX , d ) ; final int h = getHeight ( ) ; final int w = getWidth ( ) ; final int fs = fontSize ; final int sf = sizeFactor ( ) ; g . setColor ( color ( _NUM ) ) ; if ( cap ! = null ) { if ( cap . length ( ) > MAXL ) cap = cap . substring ( _NUM , CUTOFF ) + _STR ; final int textH = g . getFontMetrics ( ) . getHeight ( ) ; final int imgW = BaseXLayout . width ( g , cap ) + fs ; final BufferedImage img = createCaptionImage ( g , cap , true , imgW ) ; final int y = h - MARGIN [ _NUM ] ; if ( drawX ) { g . drawImage ( img , pos - imgW + textH - fs + _NUM , y - textH / _NUM , this ) ; g . drawLine ( pos , MARGIN [ _NUM ] , pos , h - MARGIN [ _NUM ] ) ; } else { g . drawImage ( img , MARGIN [ _NUM ] - imgW - fs / _NUM , pos - fs , this ) ; g . drawLine ( MARGIN [ _NUM ] , pos , w - MARGIN [ _NUM ] , pos ) ; } } else { if ( drawX ) { g . drawLine ( pos , MARGIN [ _NUM ] , pos , h - MARGIN [ _NUM ] - sf ) ; } else { g . drawLine ( MARGIN [ _NUM ] + sf , pos , w - MARGIN [ _NUM ] , pos ) ; } } } 
5718	public byte [ ] toByteArray ( ) { final int preLongs , outBytes ; final boolean empty = gadget _ = = null ; final byte [ ] gadgetBytes = ( gadget _ ! = null ? gadget _ . toByteArray ( ) : null ) ; if ( empty ) { preLongs = Family . RESERVOIR _ UNION . getMinPreLongs ( ) ; outBytes = _NUM ; } else { preLongs = Family . RESERVOIR _ UNION . getMaxPreLongs ( ) ; longs , so we know the size outBytes = ( preLongs < < _NUM ) + gadgetBytes . length ; } final byte [ ] outArr = new byte [ outBytes ] ; final WritableMemory mem = WritableMemory . wrap ( outArr ) ; may be null final Object memObj = mem . getArray ( ) ; final long memAddr = mem . getCumulativeOffset ( _NUM L ) ; construct header Byte _NUM PreambleUtil . insertPreLongs ( memObj , memAddr , preLongs ) ; Byte _NUM PreambleUtil . insertSerVer ( memObj , memAddr , SER _ VER ) ; Byte _NUM PreambleUtil . insertFamilyID ( memObj , memAddr , Family . RESERVOIR _ UNION . getID ( ) ) ; if ( empty ) { Byte _NUM PreambleUtil . insertFlags ( memObj , memAddr , EMPTY _ FLAG _ MASK ) ; } else { PreambleUtil . insertFlags ( memObj , memAddr , _NUM ) ; } Bytes _NUM - _NUM PreambleUtil . insertMaxK ( memObj , memAddr , maxK _ ) ; if ( ! empty ) { final int preBytes = preLongs < < _NUM ; mem . putByteArray ( preBytes , gadgetBytes , _NUM , gadgetBytes . length ) ; } return outArr ; } 
5719	public SaslConnectionParams getSaslParams ( ) { return saslSupplier . get ( ) ; } 
5720	public void onStartedWakingUp ( ) { Trace . beginSection ( _STR + mDelayedShowingSequence ) ; notifyStartedWakingUp ( ) ; } KeyguardUpdateMonitor . getInstance ( mContext ) . dispatchStartedWakingUp ( ) ; maybeSendUserPresentBroadcast ( ) ; Trace . endSection ( ) ; } 
5721	public void testChecksums ( ) throws Exception { File tmpDir = ClientBase . createTmpDir ( ) ; ClientBase . setupTestEnv ( ) ; ZooKeeperServer zks = new ZooKeeperServer ( tmpDir , tmpDir , _NUM _NUM _NUM _NUM ) ; SyncRequestProcessor . setSnapCount ( _NUM _NUM _NUM ) ; final int PORT = Integer . parseInt ( HOSTPORT . split ( _STR , ie ) ; } itr . close ( ) ; find the last snapshot FileSnap snap = new FileSnap ( versionDir ) ; List < File > snapFiles = snap . findNRecentSnapshots ( _NUM ) ; snapFile = snapFiles . get ( _NUM ) ; corruptFile ( snapFile ) ; boolean cfile = false ; try { cfile = getCheckSum ( snap , snapFile ) ; } catch ( IOException ie ) { the last snapshot seems incompelte corrupt the last but one and use that snapFile = snapFiles . get ( _NUM ) ; corruptFile ( snapFile ) ; cfile = getCheckSum ( snap , snapFile ) ; } Assert . assertTrue ( cfile ) ; } 
5722	void rename ( final int pre , final byte [ ] value ) { if ( pathIndex ) paths ( ) . set ( docs ( ) . sortedIndexOf ( pre ) , normalize ( value ) ) ; update ( ) ; } 
5723	private byte [ ] getSchemaBytes ( ) { StringBuffer schema = new StringBuffer ( _NUM _NUM _NUM ) ; schema . append ( _STR ) ; String schemaStr = schema . toString ( ) ; try { pretty print the XML schema this helps in debugging the auto - generated schema includes since it makes them more human - readable Document doc = CmsXmlUtils . unmarshalHelper ( schemaStr , null ) ; schemaStr = CmsXmlUtils . marshal ( doc , CmsEncoder . ENCODING _ UTF _ _NUM ) ; } catch ( CmsXmlException e ) { should not ever happen LOG . error ( Messages . get ( ) . getBundle ( ) . key ( Messages . LOG _ PRETTY _ PRINT _ SCHEMA _ BYTES _ ERROR _ _NUM ) , e ) ; } if ( LOG . isInfoEnabled ( ) ) { LOG . info ( Messages . get ( ) . getBundle ( ) . key ( Messages . LOG _ XML _ TYPE _ DEFINITION _ XSD _ _NUM , CmsXmlContentDefinition . XSD _ INCLUDE _ OPENCMS , schemaStr ) ) ; } try { return schemaStr . getBytes ( CmsEncoder . ENCODING _ UTF _ _NUM ) ; } catch ( UnsupportedEncodingException e ) { should not happen since the default encoding of UTF - _NUM is always valid LOG . error ( Messages . get ( ) . getBundle ( ) . key ( Messages . LOG _ CONVERTING _ SCHEMA _ BYTES _ ERROR _ _NUM ) , e ) ; } return null ; } 
5724	private void signRequest ( String authnRequest , String relayState , UriBuilder ub ) throws Exception { Crypto crypto = getSignatureCrypto ( ) ; if ( crypto = = null ) { LOG . fine ( _STR + URLEncoder . encode ( sigAlgo , StandardCharsets . UTF _ _NUM . name ( ) ) ; signature . update ( requestToSign . getBytes ( StandardCharsets . UTF _ _NUM ) ) ; byte [ ] signBytes = signature . sign ( ) ; String encodedSignature = Base _NUM _NUM . getEncoder ( ) . encodeToString ( signBytes ) ; ub . queryParam ( SSOConstants . SIGNATURE , URLEncoder . encode ( encodedSignature , StandardCharsets . UTF _ _NUM . name ( ) ) ) ; } 
5725	public static List < AclEntry > mergeAclEntries ( List < AclEntry > existingAcl , List < AclEntry > inAclSpec ) throws AclException { ValidatedAclSpec aclSpec = new ValidatedAclSpec ( inAclSpec ) ; ArrayList < AclEntry > aclBuilder = Lists . newArrayListWithCapacity ( MAX _ ENTRIES ) ; List < AclEntry > foundAclSpecEntries = Lists . newArrayListWithCapacity ( MAX _ ENTRIES ) ; EnumMap < AclEntryScope , AclEntry > providedMask = Maps . newEnumMap ( AclEntryScope . class ) ; EnumSet < AclEntryScope > maskDirty = EnumSet . noneOf ( AclEntryScope . class ) ; EnumSet < AclEntryScope > scopeDirty = EnumSet . noneOf ( AclEntryScope . class ) ; for ( AclEntry existingEntry : existingAcl ) { AclEntry aclSpecEntry = aclSpec . findByKey ( existingEntry ) ; if ( aclSpecEntry ! = null ) { foundAclSpecEntries . add ( aclSpecEntry ) ; scopeDirty . add ( aclSpecEntry . getScope ( ) ) ; if ( aclSpecEntry . getType ( ) = = MASK ) { providedMask . put ( aclSpecEntry . getScope ( ) , aclSpecEntry ) ; maskDirty . add ( aclSpecEntry . getScope ( ) ) ; } else { aclBuilder . add ( aclSpecEntry ) ; } } else { if ( existingEntry . getType ( ) = = MASK ) { providedMask . put ( existingEntry . getScope ( ) , existingEntry ) ; } else { aclBuilder . add ( existingEntry ) ; } } } ACL spec entries that were not replacements are new additions . for ( AclEntry newEntry : aclSpec ) { if ( Collections . binarySearch ( foundAclSpecEntries , newEntry , ACL _ ENTRY _ COMPARATOR ) < _NUM ) { scopeDirty . add ( newEntry . getScope ( ) ) ; if ( newEntry . getType ( ) = = MASK ) { providedMask . put ( newEntry . getScope ( ) , newEntry ) ; maskDirty . add ( newEntry . getScope ( ) ) ; } else { aclBuilder . add ( newEntry ) ; } } } copyDefaultsIfNeeded ( aclBuilder ) ; calculateMasks ( aclBuilder , providedMask , maskDirty , scopeDirty ) ; return buildAndValidateAcl ( aclBuilder ) ; } 
5726	public boolean checkCanonicalUserOptions ( ) { boolean result ; OptionHandler handler ; String [ ] userOptions ; String [ ] userOptionsCheck ; print ( _STR ) ; result = false ; if ( getDebug ( ) ) println ( e ) ; } return result ; } 
5727	public final void removeCallbacks ( Runnable r , Object token ) { final WeakRunnable runnable = mRunnables . remove ( r ) ; if ( runnable ! = null ) { mExec . removeCallbacks ( runnable , token ) ; } } 
5728	public void setFastScrollAlwaysVisible ( final boolean alwaysShow ) { if ( mFastScrollAlwaysVisible ! = alwaysShow ) { if ( alwaysShow & & ! mFastScrollEnabled ) { setFastScrollEnabled ( true ) ; } mFastScrollAlwaysVisible = alwaysShow ; if ( isOwnerThread ( ) ) { setFastScrollerAlwaysVisibleUiThread ( alwaysShow ) ; } else { post ( new Runnable ( ) { @ Override public void run ( ) { setFastScrollerAlwaysVisibleUiThread ( alwaysShow ) ; } } ) ; } } } 
5729	private void joinClusters ( ) { if ( clusters . size ( ) > _NUM ) { Node sourceNode = null ; Node targetNode = null ; add an edge from each successive cluster to next for ( Iterator < Cluster > iter = clusters . iterator ( ) ; iter . hasNext ( ) ; ) { Cluster cluster = iter . next ( ) ; if ( sourceNode ! = null ) { use first node in set as target node targetNode = cluster . set . get ( _NUM ) ; newDummyEdge ( sourceNode , targetNode ) ; } set up source node for the next iteration using last node in set sourceNode = cluster . set . get ( cluster . set . size ( ) - _NUM ) ; } } } 
5730	public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( _STR ) ; return sb . toString ( ) ; } 
5731	public final void loadView ( View view , int id ) { if ( mChildStates ! = null ) { String key = getSaveStatesKey ( id ) ; Once loaded the state , do not keep the state of child . The child state will be saved again either when child is offscreen or when the parent is saved . SparseArray < Parcelable > container = mChildStates . remove ( key ) ; if ( container ! = null ) { view . restoreHierarchyState ( container ) ; } } } 
5732	public RowPresenter . ViewHolder findRowViewHolderByPosition ( int position ) { if ( mVerticalGridView = = null ) { return null ; } return getRowViewHolder ( ( ItemBridgeAdapter . ViewHolder ) mVerticalGridView . findViewHolderForAdapterPosition ( position ) ) ; } 
5733	public void drawWindowIfNeededLocked ( ) { recomputeBoundsLocked ( ) ; mWindow . drawIfNeeded ( ) ; } 
5734	public static String getLibVlcCoreName ( ) { if ( RuntimeUtil . isNix ( ) ) { return _STR ) ; } } 
5735	public ShoppingCartItem findCartItem ( int index ) { if ( cartLines . size ( ) < = index ) { return null ; } return cartLines . get ( index ) ; } 
5736	public boolean isSet ( _ Fields field ) { if ( field = = null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case SUCCESS : return isSetSuccess ( ) ; } throw new IllegalStateException ( ) ; } 
5737	protected void selectAutoTickUnit ( Graphics _NUM D g _NUM , Rectangle _NUM D dataArea , RectangleEdge edge ) { if ( RectangleEdge . isTopOrBottom ( edge ) ) { selectHorizontalAutoTickUnit ( g _NUM , dataArea , edge ) ; } else if ( RectangleEdge . isLeftOrRight ( edge ) ) { selectVerticalAutoTickUnit ( g _NUM , dataArea , edge ) ; } } 
5738	protected UrlService getConnectedUrlService ( ) throws IOException { return UrlService . newConnection ( collectorServiceAddress ) ; } 
5739	public void startBootPhase ( final int phase ) { if ( phase < = mCurrentPhase ) { throw new IllegalArgumentException ( _STR ) ; Trace . traceEnd ( Trace . TRACE _ TAG _ SYSTEM _ SERVER ) ; } } finally { Trace . traceEnd ( Trace . TRACE _ TAG _ SYSTEM _ SERVER ) ; } } 
5740	public void setProgressViewOffset ( boolean scale , int start , int end ) { mScale = scale ; mOriginalOffsetTop = start ; mSpinnerOffsetEnd = end ; mUsingCustomStart = true ; reset ( ) ; mRefreshing = false ; } 
5741	protected void createField ( Document document , String xpath , CmsSearchField field ) { CmsSetupXmlHelper . setValue ( document , xpath + _STR ; } createFieldMapping ( document , mappingPath , mapping ) ; } } 
5742	private void smoothSnapToPosition ( int scrollY , int availableScrollHeight , AlphabeticalAppsList . FastScrollSectionInfo info ) { mRv . removeCallbacks ( mSmoothSnapNextFrameRunnable ) ; mRv . removeCallbacks ( mFastScrollToTargetSectionRunnable ) ; trackAllChildViews ( ) ; if ( mHasFastScrollTouchSettled ) { In this case , the user has already settled once ( and the fast scroll state has animated ) and they are just fine - tuning their section from the last section , so we should make it feel fast and update immediately . mCurrentFastScrollSection = info . sectionName ; mTargetFastScrollSection = null ; updateTrackedViewsFastScrollFocusState ( ) ; } else { Otherwise , the user has scrubbed really far , and we don ' t want to distract the user with the flashing fast scroll state change animation in addition to the fast scroll section popup , so reset the views to normal , and wait for the touch to settle again before animating the fast scroll state . mCurrentFastScrollSection = null ; mTargetFastScrollSection = info . sectionName ; mHasFastScrollTouchSettled = false ; updateTrackedViewsFastScrollFocusState ( ) ; Delay scrolling to a new section until after some duration . If the user has been scrubbing a while and makes multiple big jumps , then reduce the time needed for the fast scroll to settle so it doesn ' t feel so long . mRv . postDelayed ( mFastScrollToTargetSectionRunnable , mHasFastScrollTouchSettledAtLeastOnce ? REPEAT _ TOUCH _ SETTLING _ DURATION : INITIAL _ TOUCH _ SETTLING _ DURATION ) ; } Calculate the full animation from the current scroll position to the final scroll position , and then run the animation for the duration . If we are scrolling to the first fast scroll section , then just scroll to the top of the list itself . List < AlphabeticalAppsList . FastScrollSectionInfo > fastScrollSections = mApps . getFastScrollerSections ( ) ; int newPosition = info . fastScrollToItem . position ; int newScrollY = fastScrollSections . size ( ) > _NUM & & fastScrollSections . get ( _NUM ) = = info ? _NUM : Math . min ( availableScrollHeight , mRv . getCurrentScrollY ( newPosition , _NUM ) ) ; int numFrames = mFastScrollFrames . length ; int deltaY = newScrollY - scrollY ; float ySign = Math . signum ( deltaY ) ; int step = ( int ) ( ySign * Math . ceil ( ( float ) Math . abs ( deltaY ) / numFrames ) ) ; for ( int i = _NUM ; i < numFrames ; i + + ) { TODO ( winsonc ) : We can interpolate this as well . mFastScrollFrames [ i ] = ( int ) ( ySign * Math . min ( Math . abs ( step ) , Math . abs ( deltaY ) ) ) ; deltaY - = step ; } mFastScrollFrameIndex = _NUM ; mRv . postOnAnimation ( mSmoothSnapNextFrameRunnable ) ; } 
5743	public boolean equals ( Object obj ) { if ( ! ( obj instanceof DocSet ) ) return false ; DocSet other = ( DocSet ) obj ; if ( this . size ( ) ! = other . size ( ) ) return false ; if ( this instanceof DocList & & other instanceof DocList ) { compare ordering DocIterator i _NUM = this . iterator ( ) ; DocIterator i _NUM = other . iterator ( ) ; while ( i _NUM . hasNext ( ) & & i _NUM . hasNext ( ) ) { if ( i _NUM . nextDoc ( ) ! = i _NUM . nextDoc ( ) ) return false ; } return true ; don ' t compare matches } if ( this . size ( ) ! = other . size ( ) ) return false ; return this . getBits ( ) . equals ( other . getBits ( ) ) ; } 
5744	public static String getTaskAttemptIDsPattern ( String jtIdentifier , Integer jobId , TaskType type , Integer taskId , Integer attemptId ) { StringBuilder builder = new StringBuilder ( ATTEMPT ) . append ( SEPARATOR ) ; builder . append ( getTaskAttemptIDsPatternWOPrefix ( jtIdentifier , jobId , type , taskId , attemptId ) ) ; return builder . toString ( ) ; } 
5745	public void setAll ( Properties properties ) { @ SuppressWarnings ( _STR + name ) ; } String value = properties . getProperty ( name ) ; if ( property . isMultiValuePermitted ( ) ) { this . set ( property , new String [ ] { value } ) ; } else { this . set ( property , value ) ; } } } 
5746	public boolean isSet ( _ Fields field ) { if ( field = = null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case TYPE : return is _ set _ type ( ) ; case DATA : return is _ set _ data ( ) ; case MESSAGE _ ID : return is _ set _ message _ id ( ) ; } throw new IllegalStateException ( ) ; } 
5747	public void testPublicPresentationVirtualDisplay ( ) throws Exception { VirtualDisplay virtualDisplay = mDisplayManager . createVirtualDisplay ( NAME , WIDTH , HEIGHT , DENSITY , mSurface , DisplayManager . VIRTUAL _ DISPLAY _ FLAG _ PUBLIC | DisplayManager . VIRTUAL _ DISPLAY _ FLAG _ PRESENTATION ) ; assertNotNull ( _STR , display , Color . BLACK , WindowManager . LayoutParams . TYPE _ TOAST , WindowManager . LayoutParams . FLAG _ SECURE ) ; } finally { virtualDisplay . release ( ) ; } assertDisplayUnregistered ( display ) ; } 
5748	public Expression handleNull ( Expression input , RexImpTable . NullAs nullAs ) { final Expression nullHandled = nullAs . handle ( input ) ; If we get ConstantExpression , just return it ( i . e . primitive false ) if ( nullHandled instanceof ConstantExpression ) { return nullHandled ; } then we can just reuse it if ( nullHandled = = input ) { return input ; } If nullHandled is different , then it might be unsafe to compute early ( i . e . unbox of null value should not happen _ before _ ternary ) . Thus we wrap it into brand - new ParameterExpression , and we are guaranteed that ParameterExpression will not be shared String unboxVarName = _STR ; } ParameterExpression unboxed = Expressions . parameter ( nullHandled . getType ( ) , list . newName ( unboxVarName ) ) ; list . add ( Expressions . declare ( Modifier . FINAL , unboxed , nullHandled ) ) ; return unboxed ; } 
5749	public static String encrypt ( final byte [ ] plainTextAsBytes , final char [ ] password ) throws IOException { final byte [ ] encryptedBytes = encryptRaw ( plainTextAsBytes , password ) ; OpenSSL prefixes the salt bytes + encryptedBytes with Salted _ _ _ and then base _NUM _NUM encodes it final byte [ ] encryptedBytesPlusSaltedText = concat ( OPENSSL _ SALTED _ BYTES , encryptedBytes ) ; return BASE _NUM _NUM _ ENCRYPT . encode ( encryptedBytesPlusSaltedText ) ; } 
5750	public Selector getTargetConstraints ( ) { if ( selector ! = null ) { return ( Selector ) selector . clone ( ) ; } else { return null ; } } 
5751	public void cleanup ( Exception e ) { LOG . info ( _STR , e ) ; try { taskManager . cancelTasks ( ) ; } catch ( InterruptedException e _NUM ) { Thread . currentThread ( ) . interrupt ( ) ; } } 
5752	public int createParticle ( ParticleDef def ) { assertNotLocked ( ) ; return particleSystem . createParticle ( def ) ; } 
5753	public void setResizedPaddingAdjustmentTop ( int adjustment ) { if ( mResizedPaddingAdjustmentTop ! = adjustment ) { mResizedPaddingAdjustmentTop = adjustment ; resizeParamsChanged ( ) ; } } 
5754	private TypedRange < JreDeflateParameters > findRangeWithParams ( File tempFile , UnitTestZipEntry unitTestEntry ) { MinimalZipEntry found = findEntry ( tempFile , unitTestEntry ) ; Assert . assertNotNull ( _STR , found ) ; return new TypedRange < JreDeflateParameters > ( found . getFileOffsetOfCompressedData ( ) , found . getCompressedSize ( ) , JreDeflateParameters . of ( unitTestEntry . level , _NUM , true ) ) ; } 
5755	public double [ ] toRealPoint ( float screenX , float screenY , int scale ) { double realMinX = mRenderer . getXAxisMin ( scale ) ; double realMaxX = mRenderer . getXAxisMax ( scale ) ; double realMinY = mRenderer . getYAxisMin ( scale ) ; double realMaxY = mRenderer . getYAxisMax ( scale ) ; if ( ! mRenderer . isMinXSet ( scale ) | | ! mRenderer . isMaxXSet ( scale ) | | ! mRenderer . isMinYSet ( scale ) | | ! mRenderer . isMaxYSet ( scale ) ) { double [ ] calcRange = getCalcRange ( scale ) ; if ( calcRange ! = null ) { realMinX = calcRange [ _NUM ] ; realMaxX = calcRange [ _NUM ] ; realMinY = calcRange [ _NUM ] ; realMaxY = calcRange [ _NUM ] ; } } if ( mScreenR ! = null ) { return new double [ ] { ( screenX - mScreenR . getX ( ) ) * ( realMaxX - realMinX ) / mScreenR . getWidth ( ) + realMinX , ( mScreenR . getY ( ) + mScreenR . getHeight ( ) - screenY ) * ( realMaxY - realMinY ) / mScreenR . getHeight ( ) + realMinY } ; } else { return new double [ ] { screenX , screenY } ; } } 
5756	private void refreshKeys ( ) { this . keys . clear ( ) ; for ( int i = _NUM ; i < getSeriesCount ( ) ; i + + ) { TaskSeries series = ( TaskSeries ) this . data . get ( i ) ; look for any keys that we don ' t already know about . . . Iterator iterator = series . getTasks ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Task task = ( Task ) iterator . next ( ) ; String key = task . getDescription ( ) ; int index = this . keys . indexOf ( key ) ; if ( index < _NUM ) { this . keys . add ( key ) ; } } } } 
5757	public Paint getSeriesPaint ( int series ) { return the override , if there is one . . . if ( this . seriesPaint ! = null ) { return this . seriesPaint ; } otherwise look up the paint list Paint result = this . seriesPaintList . getPaint ( series ) ; if ( result = = null ) { DrawingSupplier supplier = getDrawingSupplier ( ) ; if ( supplier ! = null ) { Paint p = supplier . getNextPaint ( ) ; this . seriesPaintList . setPaint ( series , p ) ; result = p ; } else { result = this . baseSeriesPaint ; } } return result ; } 
5758	public static int i ( String tag , String msg , Throwable tr ) { return printlns ( LOG _ ID _ MAIN , INFO , tag , msg , tr ) ; } 
5759	public void throwIfCauseOf ( Exception exception ) throws IOException { if ( exception instanceof TaggedIOException ) { TaggedIOException tagged = ( TaggedIOException ) exception ; if ( tag . equals ( tagged . getTag ( ) ) ) { throw tagged . getCause ( ) ; } } } 
5760	private void notifyRecurseLocked ( T sender , int arg , A arg _NUM ) { final int callbackCount = mCallbacks . size ( ) ; final int remainderIndex = mRemainderRemoved = = null ? - _NUM : mRemainderRemoved . length - _NUM ; Now we ' ve got all callbacks that have no mRemainderRemoved value , so notify the others . notifyRemainderLocked ( sender , arg , arg _NUM , remainderIndex ) ; notifyRemainderLocked notifies all at maxIndex , so we ' d normally start at maxIndex + _NUM However , we must also keep track of those in mFirst _NUM _NUM Removed , so we add _NUM instead : final int startCallbackIndex = ( remainderIndex + _NUM ) * Long . SIZE ; The remaining have no bit set notifyCallbacksLocked ( sender , arg , arg _NUM , startCallbackIndex , callbackCount , _NUM ) ; } 
5761	public void writeAll ( ) throws IOException { this . layoutVersion = getServiceLayoutVersion ( ) ; for ( Iterator < StorageDirectory > it = storageDirs . iterator ( ) ; it . hasNext ( ) ; ) { writeProperties ( it . next ( ) ) ; } } 
5762	public < K > T ajax ( String url , Class < K > type , Object handler , String callback ) public void testAjaxHandler ( ) { String url = _STR ) ) ; } 
5763	public Response getRpcAddress ( ) { return RestUtils . call ( new RestUtils . RestCallable < String > ( ) { @ Override public String call ( ) throws Exception { return mWorkerProcess . getRpcAddress ( ) . toString ( ) ; } } ) ; } 
5764	public String getPlainColumnName ( int columnIndex ) { ArffSortedTableModel arffModel ; String result ; result = _STR ; else result = arffModel . getAttributeAt ( columnIndex ) . name ( ) ; } return result ; } 
5765	private static Put makePutFromRegionInfo ( RegionInfo regionInfo , List < ServerName > favoredNodeList ) throws IOException { Put put = null ; if ( favoredNodeList ! = null ) { long time = EnvironmentEdgeManager . currentTime ( ) ; put = MetaTableAccessor . makePutFromRegionInfo ( regionInfo , time ) ; byte [ ] favoredNodes = getFavoredNodes ( favoredNodeList ) ; put . add ( CellBuilderFactory . create ( CellBuilderType . SHALLOW _ COPY ) . setRow ( put . getRow ( ) ) . setFamily ( HConstants . CATALOG _ FAMILY ) . setQualifier ( FAVOREDNODES _ QUALIFIER ) . setTimestamp ( time ) . setType ( Type . Put ) . setValue ( favoredNodes ) . build ( ) ) ; LOG . debug ( _STR , regionInfo . getRegionNameAsString ( ) , favoredNodeList ) ; } return put ; } 
5766	private synchronized ReplicaBeingWritten append ( String bpid , FinalizedReplica replicaInfo , long newGS , long estimateBlockLen ) throws IOException { If the block is cached , start uncaching it . cacheManager . uncacheBlock ( bpid , replicaInfo . getBlockId ( ) ) ; unlink the finalized replica replicaInfo . unlinkBlock ( _NUM ) ; construct a RBW replica with the new GS File blkfile = replicaInfo . getBlockFile ( ) ; FsVolumeImpl v = ( FsVolumeImpl ) replicaInfo . getVolume ( ) ; if ( v . getAvailable ( ) < estimateBlockLen - replicaInfo . getNumBytes ( ) ) { throw new DiskOutOfSpaceException ( _STR + newBlkFile , e ) ; } Replace finalized replica by a RBW replica in replicas map volumeMap . add ( bpid , newReplicaInfo ) ; v . reserveSpaceForRbw ( estimateBlockLen - replicaInfo . getNumBytes ( ) ) ; return newReplicaInfo ; } 
5767	 @ SuppressWarnings ( _STR + declaredClass ) ; } } else if ( declaredClass . isArray ( ) ) { array int length = in . readInt ( ) ; instance = Array . newInstance ( declaredClass . getComponentType ( ) , length ) ; for ( int i = _NUM ; i < length ; i + + ) { Array . set ( instance , i , readObject ( in , conf ) ) ; } } else if ( declaredClass = = ArrayPrimitiveWritable . Internal . class ) { Read and unwrap ArrayPrimitiveWritable $ Internal array . Always allow the read , even if write is disabled by allowCompactArrays . ArrayPrimitiveWritable . Internal temp = new ArrayPrimitiveWritable . Internal ( ) ; temp . readFields ( in ) ; instance = temp . get ( ) ; declaredClass = instance . getClass ( ) ; } else if ( declaredClass = = String . class ) { String instance = UTF _NUM . readString ( in ) ; } else if ( declaredClass . isEnum ( ) ) { enum instance = Enum . valueOf ( ( Class < ? extends Enum > ) declaredClass , UTF _NUM . readString ( in ) ) ; } else if ( Message . class . isAssignableFrom ( declaredClass ) ) { instance = tryInstantiateProtobuf ( declaredClass , in ) ; } else { Writable Class instanceClass = null ; String str = UTF _NUM . readString ( in ) ; instanceClass = loadClass ( conf , str ) ; Writable writable = WritableFactories . newInstance ( instanceClass , conf ) ; writable . readFields ( in ) ; instance = writable ; if ( instanceClass = = NullInstance . class ) { null declaredClass = ( ( NullInstance ) instance ) . declaredClass ; instance = null ; } } if ( objectWritable ! = null ) { store values objectWritable . declaredClass = declaredClass ; objectWritable . instance = instance ; } return instance ; } 
5768	protected int compareNonNull ( Value value _NUM , Value value _NUM ) { if ( Value . isNull ( value _NUM ) | | Value . isNull ( value _NUM ) ) return _NUM ; return value _NUM . comparable ( ) . compareTo ( value _NUM . comparable ( ) ) ; } 
5769	public Map < BlackCardData , Object > getBlackCard ( ) { synchronized ( blackCardLock ) { if ( blackCard ! = null ) { return blackCard . getClientData ( ) ; } else { return null ; } } } 
5770	protected void validateSafeToInject ( String command , int index , int position , Node n ) throws ARQException { Parse out delimiter info DelimiterInfo delims = this . findDelimiters ( command ) ; Check each occurrence of the variable for safety if ( n . isLiteral ( ) ) { if ( delims . isInsideLiteral ( position , position ) ) { throw new ARQException ( _STR ) ; } } } 
5771	void addToPostLayout ( ViewHolder holder , ItemHolderInfo info ) { InfoRecord record = mLayoutHolderMap . get ( holder ) ; if ( record = = null ) { record = InfoRecord . obtain ( ) ; mLayoutHolderMap . put ( holder , record ) ; } record . postInfo = info ; record . flags | = FLAG _ POST ; } 
5772	public static Read read ( ) { return Read . create ( ) ; } 
5773	private static Object [ ] transformValues ( Object [ ] values ) { We could partly rely on QueryProcessor . executeOnceInternal doing type conversion for us , but it would complain with ClassCastException if we pass say a string where an int is excepted ( since it bases conversion on what the value should be , not what it is ) . For testing , we sometimes want to pass value of the wrong type and assert that this properly raise an InvalidRequestException and executeOnceInternal goes into way . So instead , we pre - convert everything to bytes here based on the value . Besides , we need to handle things like TupleValue that executeOnceInternal don ' t know about . Object [ ] buffers = new ByteBuffer [ values . length ] ; for ( int i = _NUM ; i < values . length ; i + + ) { Object value = values [ i ] ; if ( value = = null ) { buffers [ i ] = null ; continue ; } else if ( value = = ByteBufferUtil . UNSET _ BYTE _ BUFFER ) { buffers [ i ] = ByteBufferUtil . UNSET _ BYTE _ BUFFER ; continue ; } try { buffers [ i ] = typeFor ( value ) . decompose ( serializeTuples ( value ) ) ; } catch ( Exception ex ) { logger . info ( _STR , value , ex ) ; throw ex ; } } return buffers ; } 
5774	public void setService ( Class < ? extends Service > klass ) throws ServerException { ensureOperational ( ) ; Check . notNull ( klass , _STR , klass , ex ) ; destroy ( ) ; throw new ServerException ( ServerException . ERROR . S _NUM _NUM , klass , ex . getMessage ( ) , ex ) ; } } 
5775	public static String createSequence ( final String . . . names ) { if ( names = = null ) { return getDefaultStyle ( ) ; } final StringBuilder sb = new StringBuilder ( AnsiEscape . CSI . getCode ( ) ) ; boolean first = true ; for ( final String name : names ) { try { final AnsiEscape escape = EnglishEnums . valueOf ( AnsiEscape . class , name . trim ( ) ) ; if ( ! first ) { sb . append ( AnsiEscape . SEPARATOR . getCode ( ) ) ; } first = false ; sb . append ( escape . getCode ( ) ) ; } catch ( final Exception ex ) { Ignore the error . } } sb . append ( AnsiEscape . SUFFIX . getCode ( ) ) ; return sb . toString ( ) ; } 
5776	private void preSaveHook ( ) { ghcModLegacyInteractivePreSaveHook ( ) ; } 
5777	private static void init ( final AbstractButton button , final String icon , final String tooltip , final GUI gui ) { button . setIcon ( BaseXImages . icon ( icon ) ) ; BaseXLayout . addInteraction ( button , gui ) ; if ( tooltip ! = null ) button . setToolTipText ( tooltip ) ; style ( button ) ; } 
5778	public void testRepeatedStartAutoDispatchThrowsException ( ) { mTestLooper . startAutoDispatch ( ) ; mTestLooper . startAutoDispatch ( ) ; } 
5779	public int getReverbDelay ( ) throws IllegalStateException , IllegalArgumentException , UnsupportedOperationException { byte [ ] param = new byte [ _NUM ] ; checkStatus ( getParameter ( PARAM _ REVERB _ DELAY , param ) ) ; return byteArrayToInt ( param ) ; } 
5780	public static String patternToString ( List < LockPatternView . Cell > pattern ) { if ( pattern = = null ) { return _STR ; } final int patternSize = pattern . size ( ) ; byte [ ] res = new byte [ patternSize ] ; for ( int i = _NUM ; i < patternSize ; i + + ) { LockPatternView . Cell cell = pattern . get ( i ) ; res [ i ] = ( byte ) ( cell . getRow ( ) * _NUM + cell . getColumn ( ) + ' _NUM ' ) ; } return new String ( res ) ; } 
5781	public List < GpodnetPodcast > getPodcastsForTag ( @ NonNull GpodnetTag tag , int count ) throws GpodnetServiceException { try { URL url = new URI ( BASE _ SCHEME , BASE _ HOST , String . format ( _STR , tag . getTag ( ) , count ) , null ) . toURL ( ) ; Request . Builder request = new Request . Builder ( ) . url ( url ) ; String response = executeRequest ( request ) ; JSONArray jsonArray = new JSONArray ( response ) ; return readPodcastListFromJSONArray ( jsonArray ) ; } catch ( JSONException | MalformedURLException | URISyntaxException e ) { e . printStackTrace ( ) ; throw new GpodnetServiceException ( e ) ; } } 
5782	public int getStreamCount ( ) { if ( mStreams = = null & & isMultipleShare ( ) ) { mStreams = mIntent . getParcelableArrayListExtra ( Intent . EXTRA _ STREAM ) ; } if ( mStreams ! = null ) { return mStreams . size ( ) ; } return mIntent . hasExtra ( Intent . EXTRA _ STREAM ) ? _NUM : _NUM ; } 
5783	public Collection < String > getOrderProductIds ( ) { Set < String > productIds = new HashSet < String > ( ) ; for ( GenericValue orderItem : getOrderItems ( ) ) { if ( orderItem . get ( _STR ) ) ; } } return productIds ; } 
5784	public void writeToFileWriter ( ParquetFileWriter writer ) throws IOException { writer . startColumn ( path , totalValueCount , compressor . getCodecName ( ) ) ; if ( dictionaryPage ! = null ) { writer . writeDictionaryPage ( dictionaryPage ) ; tracking the dictionary encoding is handled in writeDictionaryPage } List < Encoding > encodings = Lists . newArrayList ( ) ; encodings . addAll ( rlEncodings ) ; encodings . addAll ( dlEncodings ) ; encodings . addAll ( dataEncodings ) ; writer . writeDataPages ( BytesInput . from ( buf ) , uncompressedLength , compressedLength , totalStatistics , encodings ) ; writer . endColumn ( ) ; logger . debug ( String . format ( _STR ) ) ; rlEncodings . clear ( ) ; dlEncodings . clear ( ) ; dataEncodings . clear ( ) ; pageCount = _NUM ; } 
5785	public void onActivityDestroyed ( Activity activity ) { synchronized ( NfcActivityManager . this ) { NfcActivityState state = findActivityState ( activity ) ; if ( DBG ) Log . d ( TAG , _STR + state ) ; if ( state ! = null ) { release all associated references destroyActivityState ( activity ) ; } } } 
5786	public static void validateClusterKey ( String key ) throws IOException { transformClusterKey ( key ) ; } 
5787	public static void waitForBlueprintContainer ( final Set < Long > eventHistory , BundleContext context , final String symbolicName , final int bpEvent , final Runnable runAndWait ) throws InterruptedException { final CountDownLatch latch = new CountDownLatch ( _NUM ) ; final Throwable [ ] pThrowable = new Throwable [ ] { null } ; ServiceRegistration < BlueprintListener > registration = context . registerService ( BlueprintListener . class , new BlueprintListener ( ) { @ Override public void blueprintEvent ( BlueprintEvent event ) { if ( event . getBundle ( ) . getSymbolicName ( ) . equals ( symbolicName ) ) { if ( event . getType ( ) = = bpEvent ) { it works with BP container reloads if next CREATE state is at least _NUM ms after previous one if ( eventHistory = = null | | eventHistory . add ( event . getTimestamp ( ) ) ) { latch . countDown ( ) ; } } else if ( event . getType ( ) = = BlueprintEvent . FAILURE ) { we didn ' t wait for FAILURE , but we got it - fail fast then pThrowable [ _NUM ] = event . getCause ( ) ; latch . countDown ( ) ; } } } } , null ) ; if ( runAndWait ! = null ) { runAndWait . run ( ) ; } boolean found = latch . await ( CamelBlueprintHelper . DEFAULT _ TIMEOUT , TimeUnit . MILLISECONDS ) ; registration . unregister ( ) ; if ( ! found ) { throw new RuntimeException ( _STR ) ; } if ( pThrowable [ _NUM ] ! = null ) { throw new RuntimeException ( pThrowable [ _NUM ] . getMessage ( ) , pThrowable [ _NUM ] ) ; } } 
5788	public Map < CellAddress , XSSFComment > getCellComments ( ) { prepareCTCommentCache ( ) ; final TreeMap < CellAddress , XSSFComment > map = new TreeMap < > ( ) ; for ( final Entry < CellAddress , CTComment > e : commentRefs . entrySet ( ) ) { map . put ( e . getKey ( ) , new XSSFComment ( this , e . getValue ( ) , null ) ) ; } return map ; } 
5789	private static void createThumbnailFromEXIF ( String filePath , int targetSize , int maxPixels , SizedThumbnailBitmap sizedThumbBitmap ) { if ( filePath = = null ) return ; ExifInterface exif = null ; byte [ ] thumbData = null ; try { exif = new ExifInterface ( filePath ) ; thumbData = exif . getThumbnail ( ) ; } catch ( IOException ex ) { Log . w ( TAG , ex ) ; } BitmapFactory . Options fullOptions = new BitmapFactory . Options ( ) ; BitmapFactory . Options exifOptions = new BitmapFactory . Options ( ) ; int exifThumbWidth = _NUM ; int fullThumbWidth = _NUM ; Compute exifThumbWidth . if ( thumbData ! = null ) { exifOptions . inJustDecodeBounds = true ; BitmapFactory . decodeByteArray ( thumbData , _NUM , thumbData . length , exifOptions ) ; exifOptions . inSampleSize = computeSampleSize ( exifOptions , targetSize , maxPixels ) ; exifThumbWidth = exifOptions . outWidth / exifOptions . inSampleSize ; } Compute fullThumbWidth . fullOptions . inJustDecodeBounds = true ; BitmapFactory . decodeFile ( filePath , fullOptions ) ; fullOptions . inSampleSize = computeSampleSize ( fullOptions , targetSize , maxPixels ) ; fullThumbWidth = fullOptions . outWidth / fullOptions . inSampleSize ; Choose the larger thumbnail as the returning sizedThumbBitmap . if ( thumbData ! = null & & exifThumbWidth > = fullThumbWidth ) { int width = exifOptions . outWidth ; int height = exifOptions . outHeight ; exifOptions . inJustDecodeBounds = false ; sizedThumbBitmap . mBitmap = BitmapFactory . decodeByteArray ( thumbData , _NUM , thumbData . length , exifOptions ) ; if ( sizedThumbBitmap . mBitmap ! = null ) { sizedThumbBitmap . mThumbnailData = thumbData ; sizedThumbBitmap . mThumbnailWidth = width ; sizedThumbBitmap . mThumbnailHeight = height ; } } else { fullOptions . inJustDecodeBounds = false ; sizedThumbBitmap . mBitmap = BitmapFactory . decodeFile ( filePath , fullOptions ) ; } } 
5790	private String formatNum ( int lvlNum , boolean isLegal , LevelTuple [ ] overrideLevelTuples ) { int numFmtStyle = _NUM ; String numFmt = getNumFormat ( lvlNum , isLegal , overrideLevelTuples ) ; int count = getCount ( lvlNum ) ; if ( count < _NUM ) { count = _NUM ; } if ( _STR ; } } 
5791	protected void update ( DbEntry item ) { mTempValues . clear ( ) ; item . addToContentValues ( mTempValues ) ; mUpdateOperations . add ( ContentProviderOperation . newUpdate ( LauncherSettings . Favorites . getContentUri ( item . id ) ) . withValues ( mTempValues ) . build ( ) ) ; } 
5792	public java . util . List < org . apache . drill . exec . proto . BitControl . FragmentStatus . Builder > getFragmentStatusBuilderList ( ) { return getFragmentStatusFieldBuilder ( ) . getBuilderList ( ) ; } 
5793	public String getLocValue ( String attribute , Instance instance ) { String value = instance . getValue ( attribute ) ; if ( value = = null ) return null ; String mp = inferMessagePack ( attribute , instance ) ; if ( mp = = null ) return value ; else return messages . getMessage ( mp , value ) ; } 
5794	public boolean add ( T key ) { if ( key = = null ) { throw new IllegalArgumentException ( _STR ) ; } if ( keyCount + removeCount = = threshold ) { expand ( ) ; } int loc = locate ( key ) ; if ( loc > = _NUM ) { return false ; } else { loc = - loc - _NUM ; keys [ loc ] = key ; keyCount + + ; return true ; } } 
5795	public final void setResultData ( String data ) { checkSynchronousHint ( ) ; mPendingResult . mResultData = data ; } 
5796	public void insert ( int n , int value ) { if ( n > size ) { throw new IndexOutOfBoundsException ( _STR ) ; } growIfNeeded ( ) ; System . arraycopy ( values , n , values , n + _NUM , size - n ) ; values [ n ] = value ; size + + ; } 
5797	public void validateUserCredentialWithoutAuthMethod ( ) throws Exception { Credential cred = createCredentialWithUserCredential ( ) ; cred . getUserCredential ( ) . setNonEapInnerMethod ( null ) ; assertFalse ( cred . validate ( ) ) ; } 
5798	public void testProduct ( ) { logger . info ( _STR , _NUM . _NUM _NUM _NUM _NUM _NUM _NUM ) ; AssociativeArray result = FixedCombinationRules . product ( classifierClassProbabilityMatrix ) ; for ( Object k : expResult . keySet ( ) ) { assertEquals ( TypeInference . toDouble ( expResult . get ( k ) ) , TypeInference . toDouble ( result . get ( k ) ) , Constants . DOUBLE _ ACCURACY _ HIGH ) ; } } 
5799	public static void debug ( final Logger logger , final String pattern , final double argument ) { if ( logger . isDebugEnabled ( ) ) { forcedLog ( logger , Level . DEBUG , format ( pattern , valueOf ( argument ) ) ) ; } } 
5800	public BluetoothSocket createRfcommSocket ( int channel ) throws IOException { if ( ! isBluetoothEnabled ( ) ) { Log . e ( TAG , _STR ) ; throw new IOException ( ) ; } return new BluetoothSocket ( BluetoothSocket . TYPE _ RFCOMM , - _NUM , true , true , this , channel , null ) ; } 
5801	public void testStatsBucketResize ( ) throws Exception { NetworkStatsHistory history = null ; assertStatsFilesExist ( false ) ; pretend that wifi network comes online ; service should ask about full network state , and poll any existing interfaces before updating . expectCurrentTime ( ) ; expectSettings ( _NUM L , HOUR _ IN _ MILLIS , WEEK _ IN _ MILLIS ) ; expectNetworkState ( buildWifiState ( ) ) ; expectNetworkStatsSummary ( buildEmptyStats ( ) ) ; expectNetworkStatsUidDetail ( buildEmptyStats ( ) ) ; expectBandwidthControlCheck ( ) ; mService . forceUpdateIfaces ( NETWORKS _ WIFI ) ; modify some number on wifi , and trigger poll event incrementCurrentTime ( _NUM * HOUR _ IN _ MILLIS ) ; expectCurrentTime ( ) ; expectSettings ( _NUM L , HOUR _ IN _ MILLIS , WEEK _ IN _ MILLIS ) ; expectNetworkStatsSummary ( new NetworkStats ( getElapsedRealtime ( ) , _NUM ) . addIfaceValues ( TEST _ IFACE , _NUM _NUM _NUM L , _NUM L , _NUM _NUM _NUM L , _NUM L ) ) ; expectNetworkStatsUidDetail ( buildEmptyStats ( ) ) ; forcePollAndWaitForIdle ( ) ; verify service recorded history history = mSession . getHistoryForNetwork ( sTemplateWifi , FIELD _ ALL ) ; assertValues ( history , Long . MIN _ VALUE , Long . MAX _ VALUE , _NUM _NUM _NUM L , _NUM L , _NUM _NUM _NUM L , _NUM L , _NUM ) ; assertEquals ( HOUR _ IN _ MILLIS , history . getBucketDuration ( ) ) ; assertEquals ( _NUM , history . size ( ) ) ; now change bucket duration setting and trigger another poll with exact same values , which should resize existing buckets . expectCurrentTime ( ) ; expectSettings ( _NUM L , _NUM _NUM * MINUTE _ IN _ MILLIS , WEEK _ IN _ MILLIS ) ; expectNetworkStatsSummary ( buildEmptyStats ( ) ) ; expectNetworkStatsUidDetail ( buildEmptyStats ( ) ) ; forcePollAndWaitForIdle ( ) ; verify identical stats , but spread across _NUM buckets now history = mSession . getHistoryForNetwork ( sTemplateWifi , FIELD _ ALL ) ; assertValues ( history , Long . MIN _ VALUE , Long . MAX _ VALUE , _NUM _NUM _NUM L , _NUM L , _NUM _NUM _NUM L , _NUM L , _NUM ) ; assertEquals ( _NUM _NUM * MINUTE _ IN _ MILLIS , history . getBucketDuration ( ) ) ; assertEquals ( _NUM , history . size ( ) ) ; } 
5802	protected void registerEndpointsWithIdsDefinedInFromOrToTypes ( Element element , ParserContext parserContext , String contextId , Binder < Node > binder ) { NodeList list = element . getChildNodes ( ) ; int size = list . getLength ( ) ; for ( int i = _NUM ; i < size ; i + + ) { Node child = list . item ( i ) ; if ( child instanceof Element ) { Element childElement = ( Element ) child ; Object object = binder . getJAXBNode ( child ) ; we only want from / to types to be registered as endpoints if ( object instanceof FromDefinition | | object instanceof SendDefinition ) { registerEndpoint ( childElement , parserContext , contextId ) ; } recursive registerEndpointsWithIdsDefinedInFromOrToTypes ( childElement , parserContext , contextId , binder ) ; } } } 
5803	public void testUncompressedStreamEncode ( ) throws IOException { byte [ ] testString = _STR ) ; COSStream stream = createStream ( testString , null ) ; validateEncoded ( stream , testString ) ; } 
5804	public double getQuick ( int row , int column ) { if ( row = = column ) { return diagonal . get ( row ) ; } else { return _NUM ; } } 
5805	public Query getRangeQuery ( QParser parser , SchemaField field , String part _NUM , String part _NUM , boolean minInclusive , boolean maxInclusive ) { constant score mode is now enabled per default return new TermRangeQuery ( field . getName ( ) , part _NUM = = null ? null : toInternal ( part _NUM ) , part _NUM = = null ? null : toInternal ( part _NUM ) , minInclusive , maxInclusive ) ; } 
5806	public void testPreparedStatementInsert ( ) throws Exception { Connection connection = makeConnection ( new ArrayList < JdbcTest . Employee > ( ) ) ; assertFalse ( connection . isClosed ( ) ) ; String sql = _STR ; PreparedStatement preparedStatement = connection . prepareStatement ( sql ) ; assertFalse ( preparedStatement . isClosed ( ) ) ; boolean status = preparedStatement . execute ( ) ; assertFalse ( status ) ; ResultSet resultSet = preparedStatement . getResultSet ( ) ; assertTrue ( resultSet = = null ) ; int updateCount = preparedStatement . getUpdateCount ( ) ; assertTrue ( updateCount = = _NUM ) ; } 
5807	public static double [ ] weightsFor ( double [ ] vector ) { List < double [ ] > coords = coordSplit ( vector ) ; double [ ] x = coords . get ( _NUM ) ; double [ ] y = coords . get ( _NUM ) ; double meanX = sum ( x ) / x . length ; double meanY = sum ( y ) / y . length ; double sumOfMeanDifferences = sumOfMeanDifferences ( x , y ) ; double xDifferenceOfMean = sumOfMeanDifferencesOnePoint ( x ) ; double w _ _NUM = sumOfMeanDifferences / xDifferenceOfMean ; double w _ _NUM = meanY - ( w _ _NUM ) * meanX ; double [ ] ret = new double [ vector . length ] ; ret [ _NUM ] = w _ _NUM ; ret [ _NUM ] = w _ _NUM ; return ret ; } 
5808	public boolean isSet ( _ Fields field ) { if ( field = = null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case TASK _ ID : return is _ set _ task _ id ( ) ; case COMPONENT _ ID : return is _ set _ component _ id ( ) ; case HOST : return is _ set _ host ( ) ; case PORT : return is _ set _ port ( ) ; case UPTIME _ SECS : return is _ set _ uptime _ secs ( ) ; case ERRORS : return is _ set _ errors ( ) ; case STATS : return is _ set _ stats ( ) ; } throw new IllegalStateException ( ) ; } 
5809	public void testSeek ( ) throws Exception { OutputStream out = getOutputStream ( defaultBufferSize ) ; writeData ( out ) ; InputStream in = getInputStream ( defaultBufferSize ) ; Pos : _NUM / _NUM dataLen seekCheck ( in , dataLen / _NUM ) ; Pos : _NUM seekCheck ( in , _NUM ) ; Pos : _NUM / _NUM dataLen seekCheck ( in , dataLen / _NUM ) ; final long pos = ( ( Seekable ) in ) . getPos ( ) ; Pos : - _NUM try { seekCheck ( in , - _NUM ) ; Assert . fail ( _STR , e ) ; } Assert . assertEquals ( pos , ( ( Seekable ) in ) . getPos ( ) ) ; in . close ( ) ; } 
5810	public Vector getDescendantsByTagId ( int tagId , int depth ) { if ( depth < _NUM ) { throw new IllegalArgumentException ( _STR ) ; } if ( isEmpty ( ) ) { return null ; } Vector v = new Vector ( ) ; getDescendantsByTagIdInternal ( v , tagId , depth ) ; return v ; } 
5811	public static RexProgram createIdentity ( RelDataType rowType , RelDataType outputRowType ) { if ( rowType ! = outputRowType & & ! Pair . right ( rowType . getFieldList ( ) ) . equals ( Pair . right ( outputRowType . getFieldList ( ) ) ) ) { throw new IllegalArgumentException ( _STR + outputRowType ) ; } final List < RelDataTypeField > fields = rowType . getFieldList ( ) ; final List < RexLocalRef > projectRefs = new ArrayList < > ( ) ; final List < RexInputRef > refs = new ArrayList < > ( ) ; for ( int i = _NUM ; i < fields . size ( ) ; i + + ) { final RexInputRef ref = RexInputRef . of ( i , fields ) ; refs . add ( ref ) ; projectRefs . add ( new RexLocalRef ( i , ref . getType ( ) ) ) ; } return new RexProgram ( rowType , refs , projectRefs , null , outputRowType ) ; } 
5812	public boolean isValidLockdownProfile ( ) { return isTypeValidForLockdown ( ) & & isServerAddressNumeric ( ) & & hasDns ( ) & & areDnsAddressesNumeric ( ) ; } 
5813	public void testEmptyDir ( ) throws IOException { TestCaseDescription tc = new TestCaseDescription ( ) ; tc . addRoot ( _STR , NameNodeDirType . IMAGE _ AND _ EDITS ) ; runTest ( tc ) ; } 
5814	public static boolean validToken ( ) { String tokenName = getTokenName ( ) ; if ( tokenName = = null ) { LOG . debug ( _STR , new Object [ ] { token , sessionToken } ) ) ; } return false ; } remove the token so it won ' t be used again session . remove ( tokenSessionName ) ; return true ; } 
5815	ContentCryptoMaterial recreate ( EncryptionMaterials newKEK , EncryptionMaterialsAccessor accessor , S _NUM CryptoScheme targetScheme , Provider p , AWSKMSClient kms , AmazonWebServiceRequest req ) { if ( ! usesKMSKey ( ) & & newKEK . getMaterialsDescription ( ) . equals ( kekMaterialsDescription ) ) { throw new SecurityException ( _STR ) ; } return output ; } 
5816	public void doLogin ( ) { if ( isNativeLoginSupported ( ) ) { nativelogin ( ) ; } else { if ( oauth _NUM URL = = null ) { System . out . println ( _STR ) ; return ; } Oauth _NUM auth = createOauth _NUM ( ) ; auth . showAuthentication ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { success if ( evt . getSource ( ) instanceof AccessToken ) { AccessToken t = ( AccessToken ) evt . getSource ( ) ; setAccessToken ( t ) ; if ( callback ! = null ) { callback . loginSuccessful ( ) ; } return ; } if ( evt . getSource ( ) instanceof String ) { String t = ( String ) evt . getSource ( ) ; setAccessToken ( new AccessToken ( t , null ) ) ; if ( callback ! = null ) { callback . loginSuccessful ( ) ; } return ; } if ( evt . getSource ( ) instanceof Exception ) { if ( callback ! = null ) { Exception e = ( Exception ) evt . getSource ( ) ; Log . e ( e ) ; callback . loginFailed ( e . getMessage ( ) ) ; } } } } ) ; } } 
5817	private void clearCaches ( ) { flush all caches OpenCms . getMemoryMonitor ( ) . flushCache ( CmsMemoryMonitor . CacheType . LOCALE ) ; CmsResourceBundleLoader . flushBundleCache ( ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( Messages . get ( ) . getBundle ( ) . key ( Messages . LOG _ LOCALE _ MANAGER _ FLUSH _ CACHE _ _NUM , _STR ) ) ; } } 
5818	 @ Test @ LocalAlluxioClusterResource . Config ( confParams = { PropertyKey . Name . SECURITY _ AUTHORIZATION _ PERMISSION _ ENABLED , _STR , dirStatus . getLastModificationTimeMs ( ) , _NUM , LsCommand . IN _ ALLUXIO _ STATE _ DIR , dirStatus . getPersistenceState ( ) ) ; Assert . assertEquals ( expected , mOutput . toString ( ) ) ; } 
5819	public void testTestability ( ) throws Exception { TestableZooKeeper zk = createClient ( ) ; try { LOG . info ( _STR , zk . toString ( ) ) ; } } 
5820	private void resubmit ( ServerName oldServer , List < Action > toReplay , int numAttempt , int failureCount , Throwable throwable ) { We have something to replay . We ' re going to sleep a little before . We have two contradicting needs here : _NUM ) We want to get the new location after having slept , as it may change . _NUM ) We want to take into account the location when calculating the sleep time . _NUM ) If all this is just because the response needed to be chunked try again FAST . It should be possible to have some heuristics to take the right decision . Short term , we go for one . boolean retryImmediately = throwable instanceof RetryImmediatelyException ; int nextAttemptNumber = retryImmediately ? numAttempt : numAttempt + _NUM ; long backOffTime ; if ( retryImmediately ) { backOffTime = _NUM ; } else if ( throwable instanceof CallQueueTooBigException ) { Give a special check on CQTBE , see # HBASE - _NUM _NUM _NUM _NUM _NUM backOffTime = errorsByServer . calculateBackoffTime ( oldServer , asyncProcess . pauseForCQTBE ) ; } else { backOffTime = errorsByServer . calculateBackoffTime ( oldServer , asyncProcess . pause ) ; } if ( numAttempt > asyncProcess . startLogErrorsCnt ) { We use this value to have some logs when we have multiple failures , but not too many logs , as errors are to be expected when a region moves , splits and so on LOG . info ( createLog ( numAttempt , failureCount , toReplay . size ( ) , oldServer , throwable , backOffTime , true , null , - _NUM , - _NUM ) ) ; } try { if ( backOffTime > _NUM ) { Thread . sleep ( backOffTime ) ; } } catch ( InterruptedException e ) { LOG . warn ( _STR + oldServer , e ) ; Thread . currentThread ( ) . interrupt ( ) ; return ; } groupAndSendMultiAction ( toReplay , nextAttemptNumber ) ; } 
5821	public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( _STR ) ; return sb . toString ( ) ; } 
5822	public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { mDslv = ( DragSortListView ) inflater . inflate ( getLayout ( ) , container , false ) ; mController = buildController ( mDslv ) ; mDslv . setFloatViewManager ( mController ) ; mDslv . setOnTouchListener ( mController ) ; mDslv . setDragEnabled ( dragEnabled ) ; return mDslv ; } 
5823	public V get ( Object key ) { LinkedHashMapEntry < K , V > m ; if ( key = = null ) { m = ( LinkedHashMapEntry < K , V > ) findNullKeyEntry ( ) ; } else { int hash = key . hashCode ( ) ; int index = ( hash & _NUM x _NUM FFFFFFF ) % elementData . length ; m = ( LinkedHashMapEntry < K , V > ) findNonNullKeyEntry ( key , index , hash ) ; } if ( m = = null ) { return null ; } if ( accessOrder & & tail ! = m ) { LinkedHashMapEntry < K , V > p = m . chainBackward ; LinkedHashMapEntry < K , V > n = m . chainForward ; n . chainBackward = p ; if ( p ! = null ) { p . chainForward = n ; } else { head = n ; } m . chainForward = null ; m . chainBackward = tail ; tail . chainForward = m ; tail = m ; } return m . value ; } 
5824	public void testAddNewTextParagraphWithRTS ( ) throws IOException { XSSFWorkbook wb _NUM = new XSSFWorkbook ( ) ; XSSFSheet sheet = wb _NUM . createSheet ( ) ; XSSFDrawing drawing = sheet . createDrawingPatriarch ( ) ; XSSFTextBox shape = drawing . createTextbox ( new XSSFClientAnchor ( _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM ) ) ; XSSFRichTextString rt = new XSSFRichTextString ( _STR , runs . get ( _NUM ) . getFontFamily ( ) ) ; clr = runs . get ( _NUM ) . getFontColor ( ) ; assertArrayEquals ( new int [ ] { _NUM , _NUM _NUM _NUM , _NUM _NUM _NUM } , new int [ ] { clr . getRed ( ) , clr . getGreen ( ) , clr . getBlue ( ) } ) ; checkRewrite ( wb _NUM ) ; wb _NUM . close ( ) ; } 
5825	public ImageSource dimensions ( int sWidth , int sHeight ) { if ( bitmap = = null ) { this . sWidth = sWidth ; this . sHeight = sHeight ; } setInvariants ( ) ; return this ; } 
5826	public void onCreateContextMenu ( ContextMenu menu , View v , ContextMenuInfo menuInfo ) { getActivity ( ) . onCreateContextMenu ( menu , v , menuInfo ) ; } 
5827	public void mergeIntoWorkUnitState ( WorkUnitState state ) { Properties overwriteProperties = getOverwriteProperties ( ) ; state . addAll ( overwriteProperties ) ; removeProp ( OVERWRITE _ PROPS _ KEY ) ; for ( String key : getPropertyNames ( ) ) { state . setProp ( FINAL _ CONSTRUCT _ STATE _ PREFIX + key , getProp ( key ) ) ; } } 
5828	public void setEndRule ( int month , int day , int dayOfWeek , int time , boolean after ) { endMonth = month ; endDay = after ? day : - day ; endDayOfWeek = - dayOfWeek ; endTime = time ; setEndMode ( ) ; BEGIN android - removedif ( isSimple ) { ( ( com . ibm . icu . util . SimpleTimeZone ) icuTZ ) . setEndRule ( month , day , dayOfWeek , time , after ) ; } END android - removed } 
5829	public boolean canPerformSystemActions ( TCredentials credentials ) throws ThriftSecurityException { authenticate ( credentials ) ; return hasSystemPermission ( credentials , SystemPermission . SYSTEM , false ) ; } 
5830	private boolean changeFocusState ( Component cmp , boolean gained ) { boolean trigger = false ; Style selected = cmp . getSelectedStyle ( ) ; Style unselected = cmp . getUnselectedStyle ( ) ; chance we need to trigger a revalidate if ( ! selected . getFont ( ) . equals ( unselected . getFont ( ) ) | | selected . getPaddingTop ( ) ! = unselected . getPaddingTop ( ) | | selected . getPaddingBottom ( ) ! = unselected . getPaddingBottom ( ) | | selected . getPaddingRight ( isRTL ( ) ) ! = unselected . getPaddingRight ( isRTL ( ) ) | | selected . getPaddingLeft ( isRTL ( ) ) ! = unselected . getPaddingLeft ( isRTL ( ) ) | | selected . getMarginTop ( ) ! = unselected . getMarginTop ( ) | | selected . getMarginBottom ( ) ! = unselected . getMarginBottom ( ) | | selected . getMarginRight ( isRTL ( ) ) ! = unselected . getMarginRight ( isRTL ( ) ) | | selected . getMarginLeft ( isRTL ( ) ) ! = unselected . getMarginLeft ( isRTL ( ) ) ) { trigger = true ; } int prefW = _NUM ; int prefH = _NUM ; if ( trigger ) { Dimension d = cmp . getPreferredSize ( ) ; prefW = d . getWidth ( ) ; prefH = d . getHeight ( ) ; } if ( gained ) { cmp . setFocus ( true ) ; cmp . fireFocusGained ( ) ; fireFocusGained ( cmp ) ; } else { cmp . setFocus ( false ) ; cmp . fireFocusLost ( ) ; fireFocusLost ( cmp ) ; } a revalidate if ( trigger ) { cmp . setShouldCalcPreferredSize ( true ) ; Dimension d = cmp . getPreferredSize ( ) ; if ( prefW ! = d . getWidth ( ) | | prefH ! = d . getHeight ( ) ) { cmp . setShouldCalcPreferredSize ( false ) ; trigger = false ; } } return trigger ; } 
5831	public byte [ ] getMetadata ( ) throws IOException { PdfObject obj = getPdfObject ( catalog . get ( PdfName . METADATA ) ) ; if ( ! ( obj instanceof PRStream ) ) return null ; RandomAccessFileOrArray rf = getSafeFile ( ) ; byte [ ] b = null ; try { rf . reOpen ( ) ; b = getStreamBytes ( ( PRStream ) obj , rf ) ; } finally { try { rf . close ( ) ; } catch ( Exception e ) { empty on purpose } } return b ; } 
5832	public static double fleschKincaidReadingEase ( String strText ) { strText = cleanText ( strText ) ; return PHPMethods . round ( ( _NUM _NUM _NUM . _NUM _NUM _NUM - ( _NUM . _NUM _NUM _NUM * averageWordsPerSentence ( strText ) ) - ( _NUM _NUM . _NUM * averageSyllablesPerWord ( strText ) ) ) , _NUM ) ; } 
5833	public CMSEncryptedData generate ( CMSTypedData content , OutputEncryptor contentEncryptor ) throws CMSException { return doGenerate ( content , contentEncryptor ) ; } 
5834	public void expectAddRequests ( final int count ) { assertNoExpectations ( ) ; mExpectingAdditions = true ; mExpectations = new CountDownLatch ( count ) ; } 
5835	public void markActive ( @ NonNull String nodeName , boolean active ) { ensureNodeStateExists ( nodeName ) ; states . get ( nodeName ) . setActive ( active ) ; } 
5836	public void add ( XYPlot subplot , int weight ) { verify valid weight if ( weight < = _NUM ) { String msg = _STR ; throw new IllegalArgumentException ( msg ) ; } store the plot and its weight subplot . setParent ( this ) ; subplot . setWeight ( weight ) ; subplot . setInsets ( new RectangleInsets ( _NUM . _NUM , _NUM . _NUM , _NUM . _NUM , _NUM . _NUM ) ) ; subplot . setRangeAxis ( null ) ; subplot . addChangeListener ( this ) ; this . subplots . add ( subplot ) ; configureRangeAxes ( ) ; fireChangeEvent ( ) ; } 
5837	 @ Ignore ( _STR ) ) ) ; } } } 
5838	public V put ( K key , V value ) { V result = putImpl ( key , value ) ; if ( removeEldestEntry ( head ) ) { remove ( head . key ) ; } return result ; } 
5839	public Class findClass ( String cname , String . . . subpackages ) { if ( subpackages = = null | | subpackages . length = = _NUM | | subpackages = = packages ) { subpackages = packages ; String c = classNameCache . get ( cname ) ; if ( c ! = null ) { try { return Class . forName ( c , true , classLoader ) ; } catch ( ClassNotFoundException e ) { this is unlikely log . error ( _STR , e , false ) ; } finally { using a shortname if ( clazz ! = null & & clazz . getClassLoader ( ) = = SolrResourceLoader . class . getClassLoader ( ) & & ! cname . equals ( clazz . getName ( ) ) & & ( subpackages . length = = _NUM | | subpackages = = packages ) ) { store in the cache classNameCache . put ( cname , clazz . getName ( ) ) ; } } } 
5840	private void setPos ( final int pre ) { final int off = getOff ( pre ) ; if ( off = = - _NUM ) return ; final int h = getHeight ( ) - header . getHeight ( ) - _NUM * tdata . rowH ; final int y = ( off - _NUM ) * tdata . rowH ; final int s = scroll . pos ( ) ; if ( y < s | | y > s + h ) scroll . pos ( y ) ; } 
5841	public void setPrefix ( String prefix ) { this . mPrefix = prefix ; updateTextDisplay ( ) ; } 
5842	public boolean start ( ) { Session session = null ; try { session = sessionProvider . get ( ) ; if ( state ! = GameState . LOBBY | | ! hasEnoughCards ( session ) ) { return false ; } boolean started ; final int numPlayers = players . size ( ) ; if ( numPlayers > = _NUM ) { Pick a random start judge , though the _STR , id , options . cardSetIds , cardcastDeckIds , options . blanksInDeck , options . playerLimit , options . spectatorLimit , options . scoreGoal , players , currentUniqueId ) ) ; do this stuff outside the players lock ; they will lock players again later for much less time , and not at the same time as trying to lock users , which has caused deadlocks final List < CardSet > cardSets ; synchronized ( options . cardSetIds ) { cardSets = loadCardSets ( session ) ; blackDeck = loadBlackDeck ( cardSets ) ; whiteDeck = loadWhiteDeck ( cardSets ) ; } metrics . gameStart ( currentUniqueId , cardSets , options . blanksInDeck , options . playerLimit , options . scoreGoal , ! StringUtils . isBlank ( options . password ) ) ; startNextRound ( ) ; gameManager . broadcastGameListRefresh ( ) ; } return started ; } finally { if ( null ! = session ) { session . close ( ) ; } } } 
5843	public Pane createRootPane ( ) { BorderPane root = new BorderPane ( ) ; StackPane stateView = new StackPane ( ) ; stateViewCtrl = new CspViewCtrl < > ( stateView ) ; List < Parameter > params = createParameters ( ) ; TaskExecutionPaneBuilder builder = new TaskExecutionPaneBuilder ( ) ; builder . defineParameters ( params ) ; builder . defineStateView ( stateView ) ; builder . defineInitMethod ( this : : initialize ) ; builder . defineTaskMethod ( this : : startExperiment ) ; taskPaneCtrl = builder . getResultFor ( root ) ; return root ; } 
5844	public Paint getItemPaint ( int row , int column ) { return lookupSeriesPaint ( row ) ; } 
5845	public String toStringWithoutDomain ( ) { String hostname = getHostname ( ) ; String [ ] parts = hostname . split ( _STR ) ; if ( parts . length > _NUM ) { for ( String part : parts ) { if ( ! StringUtils . isNumeric ( part ) ) { return Address . fromParts ( parts [ _NUM ] , getPort ( ) ) . toString ( ) ; } } } return toString ( ) ; } 
5846	public List < Data > queryDatas ( String sql , boolean needLog , UUID templateId ) { Connection conn = null ; Statement stat = null ; ResultSet rs = null ; List < Data > allDatas = new ArrayList < Data > ( ) ; if ( CynthiaUtil . isNull ( sql ) ) { return allDatas ; } try { conn = DbPoolConnection . getInstance ( ) . getReadConnection ( ) ; stat = conn . createStatement ( ) ; System . out . println ( _STR , e ) ; e . printStackTrace ( ) ; } finally { DbPoolConnection . getInstance ( ) . closeResultSet ( rs ) ; DbPoolConnection . getInstance ( ) . closeStatment ( stat ) ; DbPoolConnection . getInstance ( ) . closeConn ( conn ) ; } return allDatas ; } 
5847	protected void appendDetail ( final StringBuffer buffer , final String fieldName , final long value ) { buffer . append ( value ) ; } 
5848	public void run ( ) { Intent intent = new Intent ( mRule . getActivity ( ) , TestActivity . class ) ; intent . putExtra ( TestActivity . EXTRA _ PROVIDER , providerName _NUM ) ; mRule . getActivity ( ) . startActivity ( intent ) ; } } ) ; PollingCheck . waitFor ( _NUM _NUM _NUM _NUM , new PollingCheck . PollingCheckCondition ( ) { @ Override public boolean canPreProceed ( ) { return false ; } @ Override public boolean canProceed ( ) { return provider _NUM . getActivity ( ) ! = null & & provider _NUM . getActivity ( ) . isStarted ( ) ; } } ) ; return provider _NUM . getActivity ( ) ; } 
5849	public int invokeOemRilRequestRaw ( byte [ ] oemReq , byte [ ] oemResp ) { try { ITelephony telephony = getITelephony ( ) ; if ( telephony ! = null ) return telephony . invokeOemRilRequestRaw ( oemReq , oemResp ) ; } catch ( RemoteException ex ) { } catch ( NullPointerException ex ) { } return - _NUM ; } 
5850	public static XmlGDay parse ( java . net . URL u ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( XmlGDay ) XmlBeans . getContextTypeLoader ( ) . parse ( u , type , null ) ; } 
5851	public void expandAllParents ( ) { for ( P parent : mParentList ) { expandParent ( parent ) ; } } 
5852	protected void setDataReaderValidation ( Service service , Message message , DataReader < ? > reader ) { if ( shouldValidate ( message ) ) { all serviceInfos have the same schemas Schema schema = EndpointReferenceUtils . getSchema ( service . getServiceInfos ( ) . get ( _NUM ) , message . getExchange ( ) . getBus ( ) ) ; reader . setSchema ( schema ) ; } else { if this is being called for an operation , then override the service level reader . setSchema ( null ) ; } } 
5853	public void writeString ( String value ) throws IOException { if ( value = = null ) { os . write ( ' N ' ) ; } else { int length = value . length ( ) ; int offset = _NUM ; while ( length > _NUM x _NUM _NUM _NUM _NUM ) { int sublen = _NUM x _NUM _NUM _NUM _NUM ; chunk can ' t end in high surrogate char tail = value . charAt ( offset + sublen - _NUM ) ; if ( _NUM xd _NUM _NUM _NUM < = tail & & tail < = _NUM xdbff ) sublen - - ; os . write ( ' s ' ) ; os . write ( sublen > > _NUM ) ; os . write ( sublen ) ; printString ( value , offset , sublen ) ; length - = sublen ; offset + = sublen ; } os . write ( ' S ' ) ; os . write ( length > > _NUM ) ; os . write ( length ) ; printString ( value , offset , length ) ; } } 
5854	private void calcHashCode ( ) { hashCode = visibility . value ; hashCode = hashCode * _NUM _NUM + annotationValue . hashCode ( ) ; } 
5855	public void testUpdateOnCobarSqlMapClientTemplate ( ) { String [ ] names = { _STR , id ) ; assertNotNull ( follower ) ; assertEquals ( name + nameSuffix , follower . getName ( ) ) ; } } 
5856	public static RequestStatusResponse updateServices ( AmbariManagementController controller , Set < ServiceRequest > requests , Map < String , String > requestProperties , boolean runSmokeTest , boolean reconfigureClients , MaintenanceStateHelper maintenanceStateHelper ) throws AmbariException , AuthorizationException , NoSuchFieldException , IllegalAccessException { ServiceResourceProvider provider ; if ( maintenanceStateHelper ! = null ) { provider = getServiceProvider ( controller , maintenanceStateHelper , null ) ; } else { provider = getServiceProvider ( controller ) ; } RequestStageContainer request = provider . updateServices ( null , requests , requestProperties , runSmokeTest , reconfigureClients , true ) ; request . persist ( ) ; return request . getRequestStatusResponse ( ) ; } 
5857	public static Collection < Component > getComponents ( Component . Container container ) { do not return LinkedHashSet , it uses much more memory than ArrayList Collection < Component > res = new ArrayList < > ( ) ; fillChildComponents ( container , res ) ; if ( res . isEmpty ( ) ) { return Collections . emptyList ( ) ; } return Collections . unmodifiableCollection ( res ) ; } 
5858	Promotional move of coupons to an HllSketch from either List or Set . called by CouponHashSet . couponUpdate ( ) called by CouponList . couponUpdate ( ) static final HllSketchImpl promoteHeapListOrSetToHll ( final CouponList src ) { final HllArray tgtHllArr = HllArray . newHeapHll ( src . lgConfigK , src . tgtHllType ) ; final PairIterator srcItr = src . getIterator ( ) ; tgtHllArr . putKxQ _NUM ( _NUM < < src . lgConfigK ) ; while ( srcItr . nextValid ( ) ) { tgtHllArr . couponUpdate ( srcItr . getPair ( ) ) ; } tgtHllArr . putHipAccum ( src . getEstimate ( ) ) ; tgtHllArr . putOutOfOrderFlag ( false ) ; return tgtHllArr ; } 
5859	private void setupAccelerometer ( Context context ) { set up accelerometer sensor mSensorManager = ( SensorManager ) context . getSystemService ( Context . SENSOR _ SERVICE ) ; mAccelerometer = mSensorManager . getDefaultSensor ( Sensor . TYPE _ ACCELEROMETER ) ; mSensorListener = new SensorEventListener ( ) { @ Override public void onSensorChanged ( SensorEvent event ) { float x = event . values [ _NUM ] ; float y = event . values [ _NUM ] ; float z = event . values [ _NUM ] ; if ( ! mInitialized ) { mInitialized = true ; mLastX = x ; mLastY = y ; mLastZ = z ; } else { float deltaX = Math . abs ( mLastX - x ) ; float deltaY = Math . abs ( mLastY - y ) ; float deltaZ = Math . abs ( mLastZ - z ) ; if ( deltaX < ACCELEROMETER _ NOISE ) { deltaX = _NUM . _NUM f ; } if ( deltaY < ACCELEROMETER _ NOISE ) { deltaY = _NUM . _NUM f ; } if ( deltaZ < ACCELEROMETER _ NOISE ) { deltaZ = _NUM . _NUM f ; } mLastX = x ; mLastY = y ; mLastZ = z ; if ( deltaX > _NUM | | deltaY > _NUM | | deltaZ > _NUM ) { movement detected disable the movement sensor to save power stop ( ) ; lastMovementTime = System . currentTimeMillis ( ) ; if ( onMovement ! = null ) { Thread runThread = new Thread ( onMovement ) ; runThread . start ( ) ; } } } } @ Override public void onAccuracyChanged ( Sensor sensor , int i ) { } } ; start ( ) ; } 
5860	public SchemaField getFieldOrNull ( String fieldName ) { SchemaField f = fields . get ( fieldName ) ; if ( f ! = null ) return f ; for ( DynamicField df : dynamicFields ) { if ( df . matches ( fieldName ) ) return df . makeSchemaField ( fieldName ) ; } if ( ! fieldName . endsWith ( _STR ) ; } return f ; } 
5861	protected void writeInputBinaryMatrixWithMTD ( String name , double [ ] [ ] matrix , int rowsInBlock , int colsInBlock , boolean sparseFormat , MatrixCharacteristics mc ) throws IOException { writeInputBinaryMatrix ( name , matrix , rowsInBlock , colsInBlock , sparseFormat ) ; write metadata file String completeMTDPath = baseDirectory + INPUT _ DIR + name + _STR ) ) ; } 
5862	public static Dataset generateDataset ( CharSequence descriptor , boolean regression , FileSystem fs , Path path ) throws DescriptorException , IOException { Attribute [ ] attrs = DescriptorUtils . parseDescriptor ( descriptor ) ; FSDataInputStream input = fs . open ( path ) ; Scanner scanner = new Scanner ( input , _STR ) List < String > [ ] values = new List [ attrs . length ] ; for ( int i = _NUM ; i < valsets . length ; i + + ) { if ( valsets [ i ] ! = null ) { values [ i ] = Lists . newArrayList ( valsets [ i ] ) ; } } return new Dataset ( attrs , values , size , regression ) ; } 
5863	public boolean equals ( Object other ) { if ( ! ( other instanceof TObjectShortMap ) ) { return false ; } TObjectShortMap that = ( TObjectShortMap ) other ; if ( that . size ( ) ! = this . size ( ) ) { return false ; } try { TObjectShortIterator iter = this . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; Object key = iter . key ( ) ; short value = iter . value ( ) ; if ( value = = no _ entry _ value ) { if ( ! ( that . get ( key ) = = that . getNoEntryValue ( ) & & that . containsKey ( key ) ) ) { return false ; } } else { if ( value ! = that . get ( key ) ) { return false ; } } } } catch ( ClassCastException ex ) { unused . } return true ; } 
5864	public int pre ( final int id ) { no updates or id is not affected by updates if ( rows = = _NUM | | id < pres [ _NUM ] ) return id ; if ( id > baseid ) { id was inserted by update for ( int i = _NUM ; i < rows ; + + i ) { if ( fids [ i ] = = id ) return pres [ i ] ; is this optimization ? if ( fids [ i ] < = id & & id < = nids [ i ] ) return pres [ i ] + id - fids [ i ] ; } } else { id is affected by updates final int i = sortedLastIndexOf ( oids , id ) ; return id + incs [ i < _NUM ? - i - _NUM : i ] ; } return - _NUM ; } 
5865	public boolean addFlow ( Flow flow ) { Connection conn = null ; PreparedStatement pstm = null ; try { conn = DbPoolConnection . getInstance ( ) . getConnection ( ) ; String sql = _STR ; pstm = conn . prepareStatement ( sql ) ; pstm . setString ( _NUM , flow . getId ( ) . getValue ( ) ) ; pstm . setString ( _NUM , XMLUtil . toSafeXMLString ( flow . getName ( ) ) ) ; pstm . setString ( _NUM , flow . toXMLString ( ) ) ; pstm . setString ( _NUM , flow . getCreateUser ( ) ) ; if ( pstm . executeUpdate ( ) > _NUM ) { return true ; } else { return false ; } } catch ( Exception e ) { e . printStackTrace ( ) ; return false ; } finally { DbPoolConnection . getInstance ( ) . closeStatment ( pstm ) ; DbPoolConnection . getInstance ( ) . closeConn ( conn ) ; } } 
5866	protected synchronized void createWindowMenu ( ) { Iterator iter ; JMenuItem menuItem ; int startIndex ; remove all existing entries jMenuWindows . removeAll ( ) ; minimize + restore + separator menuItem = new JMenuItem ( _STR ) ; menuItem . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { restoreWindows ( ) ; } } ) ; jMenuWindows . add ( menuItem ) ; jMenuWindows . addSeparator ( ) ; windows startIndex = jMenuWindows . getMenuComponentCount ( ) - _NUM ; iter = getWindowList ( ) ; jMenuWindows . setVisible ( iter . hasNext ( ) ) ; while ( iter . hasNext ( ) ) { Container frame = ( Container ) iter . next ( ) ; if ( frame instanceof ChildFrameMDI ) menuItem = new JMenuItem ( ( ( ChildFrameMDI ) frame ) . getTitle ( ) ) ; else if ( frame instanceof ChildFrameSDI ) menuItem = new JMenuItem ( ( ( ChildFrameSDI ) frame ) . getTitle ( ) ) ; insertMenuItem ( jMenuWindows , menuItem , startIndex ) ; menuItem . setActionCommand ( Integer . toString ( frame . hashCode ( ) ) ) ; menuItem . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { Container frame = null ; Iterator iter = getWindowList ( ) ; while ( iter . hasNext ( ) ) { frame = ( Container ) iter . next ( ) ; String hashFrame = Integer . toString ( frame . hashCode ( ) ) ; if ( hashFrame . equals ( evt . getActionCommand ( ) ) ) { showWindow ( frame ) ; break ; } } showWindow ( frame ) ; } } ) ; } } 
5867	public void print ( String s ) throws IOException { if ( s = = null ) { s = _STR ; } write ( s ) ; } 
5868	public boolean absolute ( int rowNum ) throws GenericEntityException { if ( closed ) throw new GenericResultSetClosedException ( _STR + rowNum , e ) ; } } 
5869	public void testEqualReversed ( ) { ResolutionNode a _NUM n = createResolutionNode ( a _NUM ) ; ResolutionNode a _NUM n = createResolutionNode ( a _NUM ) ; assertResolveConflict ( a _NUM n , a _NUM n , a _NUM n ) ; } 
5870	public void exception ( Throwable rawThrowable ) { source . exception ( ) ; Throwable throwable = unwrap ( rawThrowable ) ; if ( throwable ! = null ) { if ( throwable instanceof OutOfOrderScannerNextException ) { source . outOfOrderException ( ) ; } else if ( throwable instanceof RegionTooBusyException ) { source . tooBusyException ( ) ; } else if ( throwable instanceof UnknownScannerException ) { source . unknownScannerException ( ) ; } else if ( throwable instanceof ScannerResetException ) { source . scannerResetException ( ) ; } else if ( throwable instanceof RegionMovedException ) { source . movedRegionException ( ) ; } else if ( throwable instanceof NotServingRegionException ) { source . notServingRegionException ( ) ; } else if ( throwable instanceof FailedSanityCheckException ) { source . failedSanityException ( ) ; } else if ( throwable instanceof MultiActionResultTooLarge ) { source . multiActionTooLargeException ( ) ; } else if ( throwable instanceof CallQueueTooBigException ) { source . callQueueTooBigException ( ) ; } } } 
5871	public static NNStorage setupEdits ( List < URI > editUris , int numrolls , boolean closeOnFinish , AbortSpec . . . abortAtRolls ) throws IOException { List < AbortSpec > aborts = new ArrayList < AbortSpec > ( Arrays . asList ( abortAtRolls ) ) ; NNStorage storage = new NNStorage ( new Configuration ( ) , Collections . < URI > emptyList ( ) , editUris ) ; storage . format ( new NamespaceInfo ( ) ) ; FSEditLog editlog = getFSEditLog ( storage ) ; open the edit log and add two transactions logGenerationStamp is used , simply because it doesn ' t require complex arguments . editlog . initJournalsForWrite ( ) ; editlog . openForWrite ( NameNodeLayoutVersion . CURRENT _ LAYOUT _ VERSION ) ; for ( int i = _NUM ; i < TXNS _ PER _ ROLL ; i + + ) { editlog . logGenerationStampV _NUM ( ( long ) _NUM ) ; } editlog . logSync ( ) ; back into rotation automatically by rollEditLog for ( int i = _NUM ; i < numrolls ; i + + ) { editlog . rollEditLog ( NameNodeLayoutVersion . CURRENT _ LAYOUT _ VERSION ) ; editlog . logGenerationStampV _NUM ( ( long ) i ) ; editlog . logSync ( ) ; while ( aborts . size ( ) > _NUM & & aborts . get ( _NUM ) . roll = = ( i + _NUM ) ) { AbortSpec spec = aborts . remove ( _NUM ) ; editlog . getJournals ( ) . get ( spec . logindex ) . abort ( ) ; } for ( int j = _NUM ; j < TXNS _ PER _ ROLL ; j + + ) { editlog . logGenerationStampV _NUM ( ( long ) i ) ; } editlog . logSync ( ) ; } if ( closeOnFinish ) { editlog . close ( ) ; } FSImageTestUtil . logStorageContents ( LOG , storage ) ; return storage ; } 
5872	public void resetView ( ) { if ( mForwardAnimatorSet ! = null & & mForwardAnimatorSet . isRunning ( ) ) { mForwardAnimatorSet . end ( ) ; } if ( mReverseAnimatorSet ! = null & & mReverseAnimatorSet . isRunning ( ) ) { mReverseAnimatorSet . end ( ) ; } if ( mAnimationView ! = null & & mAnimationView . isPlaying ( ) ) { mAnimationView . stopAnimation ( ) ; } if ( mBaseContainer ! = null ) { mBaseContainer . setVisibility ( VISIBLE ) ; } if ( mAnimationView ! = null ) { mAnimationView . setAnimated ( false ) ; } if ( mContextView ! = null ) { mContextView . setVisibility ( GONE ) ; } } 
5873	default void undoPutAll ( ISMRMap < K , V > map , Map < K , V > undoRecord , Map < ? extends K , ? extends V > m ) { undoRecord . entrySet ( ) . forEach ( e - > { if ( e . getValue ( ) = = UndoNullable . NULL ) { map . remove ( e . getKey ( ) ) ; } else { map . put ( e . getKey ( ) , e . getValue ( ) ) ; } } ) ; } 
5874	private void testFocusRecoveryBeforeLayout ( int descendantFocusability ) throws Throwable { RecyclerView recyclerView = new RecyclerView ( getActivity ( ) ) ; recyclerView . setDescendantFocusability ( descendantFocusability ) ; mLayoutManager = new FocusLayoutManager ( ) ; mAdapter = new FocusTestAdapter ( _NUM _NUM ) ; recyclerView . setLayoutManager ( mLayoutManager ) ; recyclerView . setPreserveFocusAfterLayout ( ! mDisableRecovery ) ; if ( mDisableAnimation ) { recyclerView . setItemAnimator ( null ) ; } setRecyclerView ( recyclerView ) ; assertThat ( _STR , mRecyclerView . isFocusable ( ) , is ( true ) ) ; mLayoutManager . expectLayouts ( _NUM ) ; mActivityRule . runOnUiThread ( new Runnable ( ) { @ Override public void run ( ) { requestFocusOnRV ( ) ; mRecyclerView . setAdapter ( mAdapter ) ; } } ) ; mLayoutManager . waitForLayout ( _NUM ) ; assertFocusAfterLayout ( _NUM , - _NUM ) ; } 
5875	protected void updateCurrentBlock ( HFileBlock newBlock ) throws CorruptHFileException { sanity checks if ( newBlock . getBlockType ( ) ! = BlockType . ENCODED _ DATA ) { throw new IllegalStateException ( _STR + DataBlockEncoding . getNameFromId ( dataBlockEncoderId ) ) ; } updateCurrBlockRef ( newBlock ) ; ByteBuff encodedBuffer = getEncodedBuffer ( newBlock ) ; seeker . setCurrentBuffer ( encodedBuffer ) ; blockFetches . incrementAndGet ( ) ; Reset the next indexed key this . nextIndexedKey = null ; } 
5876	private void scrollIntoSlots ( ) { if ( getChildCount ( ) = = _NUM | | mSelectedChild = = null ) return ; int selectedCenter = getCenterOfView ( mSelectedChild ) ; int targetCenter = getCenterOfGallery ( ) ; int scrollAmount = targetCenter - selectedCenter ; if ( scrollAmount ! = _NUM ) { mFlingRunnable . startUsingDistance ( scrollAmount ) ; } else { onFinishedMovement ( ) ; } } 
5877	public < KK > EntryStream < KK , V > flatMapToKey ( BiFunction < ? super K , ? super V , ? extends Stream < ? extends KK > > mapper ) { return new EntryStream < > ( stream ( ) . flatMap ( e - > withValue ( mapper . apply ( e . getKey ( ) , e . getValue ( ) ) , e . getValue ( ) ) ) , context ) ; } 
5878	public static List < Integer > getValidKeyLengthsForAlgorithm ( String algorithm ) { List < Integer > validKeyLengths = new ArrayList < > ( ) ; if ( StringUtils . isEmpty ( algorithm ) ) { return validKeyLengths ; } Some algorithms specify a single key size int keyLength = parseActualKeyLengthFromAlgorithm ( algorithm ) ; if ( keyLength ! = - _NUM ) { validKeyLengths . add ( keyLength ) ; return validKeyLengths ; } The algorithm does not specify a key size String cipher = parseCipherFromAlgorithm ( algorithm ) ; switch ( cipher . toUpperCase ( ) ) { case _STR : return Arrays . asList ( _NUM _NUM _NUM , _NUM _NUM _NUM , _NUM _NUM _NUM ) ; default : return validKeyLengths ; } } 
5879	public RexNode dot ( RexNode node , int fieldOrdinal ) { final RexBuilder builder = cluster . getRexBuilder ( ) ; return builder . makeFieldAccess ( node , fieldOrdinal ) ; } 
5880	public boolean getStorageEncryption ( ComponentName who , int userHandle ) { if ( ! mHasFeature ) { return false ; } enforceFullCrossUsersPermission ( userHandle ) ; synchronized ( this ) { Check for permissions if a particular caller is specified if ( who ! = null ) { When checking for a single caller , status is based on caller ' s request ActiveAdmin ap = getActiveAdminUncheckedLocked ( who , userHandle ) ; return ap ! = null ? ap . encryptionRequested : false ; } If no particular caller is specified , return the aggregate set of requests . This is short circuited by returning true on the first hit . DevicePolicyData policy = getUserData ( userHandle ) ; final int N = policy . mAdminList . size ( ) ; for ( int i = _NUM ; i < N ; i + + ) { if ( policy . mAdminList . get ( i ) . encryptionRequested ) { return true ; } } return false ; } } 
5881	public void reloadForm ( ) { Form currentForm = Display . getInstance ( ) . getCurrent ( ) ; Command backCommand = currentForm . getBackCommand ( ) ; Form newForm = ( Form ) createContainer ( fetchResourceFile ( ) , currentForm . getName ( ) ) ; if ( backCommand ! = null ) { setBackCommand ( newForm , backCommand ) ; trigger listener creation if this is the only command in the form getFormListenerInstance ( newForm , null ) ; for ( int iter = _NUM ; iter < currentForm . getCommandCount ( ) ; iter + + ) { if ( backCommand = = currentForm . getCommand ( iter ) ) { newForm . addCommand ( backCommand , newForm . getCommandCount ( ) ) ; break ; } } } beforeShow ( newForm ) ; Transition tin = newForm . getTransitionInAnimator ( ) ; Transition tout = newForm . getTransitionOutAnimator ( ) ; currentForm . setTransitionInAnimator ( CommonTransitions . createEmpty ( ) ) ; currentForm . setTransitionOutAnimator ( CommonTransitions . createEmpty ( ) ) ; newForm . setTransitionInAnimator ( CommonTransitions . createEmpty ( ) ) ; newForm . setTransitionOutAnimator ( CommonTransitions . createEmpty ( ) ) ; newForm . layoutContainer ( ) ; newForm . show ( ) ; postShowImpl ( newForm ) ; newForm . setTransitionInAnimator ( tin ) ; newForm . setTransitionOutAnimator ( tout ) ; } 
5882	public static < T _NUM , T _NUM , R > Function _NUM < T _NUM , T _NUM , R > memoizeBiFunctionAsync ( final BiFunction < T _NUM , T _NUM , R > fn , ScheduledExecutorService ex , long updateRateInMillis ) { val memoise _NUM = memoizeFunctionAsync ( ( final Tuple _NUM < T _NUM , T _NUM > pair ) - > fn . apply ( pair . _ _NUM ( ) , pair . _ _NUM ( ) ) , ex , updateRateInMillis ) ; return ( t _NUM , t _NUM ) - > memoise _NUM . apply ( tuple ( t _NUM , t _NUM ) ) ; } 
5883	void flush ( ) { mTextView . removeCallbacks ( this ) ; run ( ) ; } 
5884	public String [ ] getPropertySplit ( String key ) { String str = getProperty ( key ) ; if ( str = = null ) return null ; return str . split ( _STR ) ; } 
5885	public Set < Map . Entry < K , Double > > entrySet ( ) { return new AbstractSet < Map . Entry < K , Double > > ( ) { public int size ( ) { return _ map . size ( ) ; } public boolean isEmpty ( ) { return TObjectDoubleMapDecorator . this . isEmpty ( ) ; } public boolean contains ( Object o ) { if ( o instanceof Map . Entry ) { Object k = ( ( Map . Entry ) o ) . getKey ( ) ; Object v = ( ( Map . Entry ) o ) . getValue ( ) ; return TObjectDoubleMapDecorator . this . containsKey ( k ) & & TObjectDoubleMapDecorator . this . get ( k ) . equals ( v ) ; } else { return false ; } } public Iterator < Map . Entry < K , Double > > iterator ( ) { return new Iterator < Map . Entry < K , Double > > ( ) { private final TObjectDoubleIterator < K > it = _ map . iterator ( ) ; public Map . Entry < K , Double > next ( ) { it . advance ( ) ; final K key = it . key ( ) ; final Double v = wrapValue ( it . value ( ) ) ; return new Map . Entry < K , Double > ( ) { private Double val = v ; public boolean equals ( Object o ) { return o instanceof Map . Entry & & ( ( Map . Entry ) o ) . getKey ( ) . equals ( key ) & & ( ( Map . Entry ) o ) . getValue ( ) . equals ( val ) ; } public K getKey ( ) { return key ; } public Double getValue ( ) { return val ; } public int hashCode ( ) { return key . hashCode ( ) + val . hashCode ( ) ; } public Double setValue ( Double value ) { val = value ; return put ( key , value ) ; } } ; } public boolean hasNext ( ) { return it . hasNext ( ) ; } public void remove ( ) { it . remove ( ) ; } } ; } public boolean add ( Map . Entry < K , Double > o ) { throw new UnsupportedOperationException ( ) ; } public boolean remove ( Object o ) { boolean modified = false ; if ( contains ( o ) ) { noinspection unchecked K key = ( ( Map . Entry < K , Double > ) o ) . getKey ( ) ; _ map . remove ( key ) ; modified = true ; } return modified ; } public boolean addAll ( Collection < ? extends Map . Entry < K , Double > > c ) { throw new UnsupportedOperationException ( ) ; } public void clear ( ) { TObjectDoubleMapDecorator . this . clear ( ) ; } } ; } 
5886	public String generateNavBar ( String toolPath , CmsWorkplace wp ) { if ( toolPath . equals ( getBaseToolPath ( wp ) ) ) { return _STR ; return html ; } 
5887	public void setData ( final Object [ ] keys , final Object [ ] values ) { if ( values . length ! = keys . length ) { throw new IllegalArgumentException ( _STR ) ; } this . data . clear ( ) ; this . data . ensureCapacity ( keys . length ) ; for ( int i = _NUM ; i < values . length ; i + + ) { add ( keys [ i ] , values [ i ] ) ; } this . selectedItemIndex = - _NUM ; final ListDataEvent evt = new ListDataEvent ( this , ListDataEvent . CONTENTS _ CHANGED , _NUM , this . data . size ( ) - _NUM ) ; fireListDataEvent ( evt ) ; } 
5888	public static ObjectAnimator ofMultiFloat ( Object target , String propertyName , float [ ] [ ] values ) { PropertyValuesHolder pvh = PropertyValuesHolder . ofMultiFloat ( propertyName , values ) ; return ofPropertyValuesHolder ( target , pvh ) ; } 
5889	public void testFilterClauseSameAsOuterFilterGone ( ) { Logically equivalent to select sum ( _STR ) ; } 
5890	public String getTextResolved ( CmsWorkplace wp ) { CmsMacroResolver resolver = CmsMacroResolver . newInstance ( ) ; resolver . setCmsObject ( wp . getCms ( ) ) ; resolver . setJspPageContext ( wp . getJsp ( ) . getJspContext ( ) ) ; resolver . setMessages ( wp . getMessages ( ) ) ; if ( m _ textShown = = null ) { create the shown text containing macros StringBuffer text = new StringBuffer ( _NUM _NUM _NUM ) ; if ( ! isReplaceDefault ( ) ) { the default text should be shown try { if ( OpenCms . getOrgUnitManager ( ) . getOrganizationalUnits ( wp . getCms ( ) , _STR ) ; } } text . append ( m _ text ) ; m _ textShown = text . toString ( ) ; } return the resolved text return resolver . resolveMacros ( m _ textShown ) ; } 
5891	public void setDisabledIcon ( Image disabledIcon ) { this . disabledIcon = disabledIcon ; setShouldCalcPreferredSize ( true ) ; checkAnimation ( ) ; repaint ( ) ; } 
5892	public void setHandlers ( @ SuppressWarnings ( _STR ) List < Handler > h ) { handlers . clear ( ) ; handlers . addAll ( h ) ; } 
5893	public void show ( ) { init ( ) ; } 
5894	public void testWeirdCacheBehaviour ( ) throws Exception { final TableName tableName = TableName . valueOf ( name . getMethodName ( ) ) ; byte [ ] [ ] FAMILIES = new byte [ ] [ ] { Bytes . toBytes ( _STR + keyPrefix _NUM , _NUM , getNumberOfRows ( keyPrefix _NUM , value _NUM , table ) ) ; } 
5895	public static void rFindAndRecompileIndexingHOP ( StatementBlock sb , ProgramBlock pb , String var , ExecutionContext ec , boolean force ) { if ( pb instanceof IfProgramBlock & & sb instanceof IfStatementBlock ) { IfProgramBlock ipb = ( IfProgramBlock ) pb ; IfStatementBlock isb = ( IfStatementBlock ) sb ; IfStatement is = ( IfStatement ) sb . getStatement ( _NUM ) ; process if condition if ( isb . getPredicateHops ( ) ! = null ) ipb . setPredicate ( rFindAndRecompileIndexingHOP ( isb . getPredicateHops ( ) , ipb . getPredicate ( ) , var , ec , force ) ) ; process if branch int len = is . getIfBody ( ) . size ( ) ; for ( int i = _NUM ; i < ipb . getChildBlocksIfBody ( ) . size ( ) & & i < len ; i + + ) { ProgramBlock lpb = ipb . getChildBlocksIfBody ( ) . get ( i ) ; StatementBlock lsb = is . getIfBody ( ) . get ( i ) ; rFindAndRecompileIndexingHOP ( lsb , lpb , var , ec , force ) ; } process else branch if ( ipb . getChildBlocksElseBody ( ) ! = null ) { int len _NUM = is . getElseBody ( ) . size ( ) ; for ( int i = _NUM ; i < ipb . getChildBlocksElseBody ( ) . size ( ) & & i < len _NUM ; i + + ) { ProgramBlock lpb = ipb . getChildBlocksElseBody ( ) . get ( i ) ; StatementBlock lsb = is . getElseBody ( ) . get ( i ) ; rFindAndRecompileIndexingHOP ( lsb , lpb , var , ec , force ) ; } } } else if ( pb instanceof WhileProgramBlock & & sb instanceof WhileStatementBlock ) { WhileProgramBlock wpb = ( WhileProgramBlock ) pb ; WhileStatementBlock wsb = ( WhileStatementBlock ) sb ; WhileStatement ws = ( WhileStatement ) sb . getStatement ( _NUM ) ; process while condition if ( wsb . getPredicateHops ( ) ! = null ) wpb . setPredicate ( rFindAndRecompileIndexingHOP ( wsb . getPredicateHops ( ) , wpb . getPredicate ( ) , var , ec , force ) ) ; process body robustness for potentially added problem blocks int len = ws . getBody ( ) . size ( ) ; for ( int i = _NUM ; i < wpb . getChildBlocks ( ) . size ( ) & & i < len ; i + + ) { ProgramBlock lpb = wpb . getChildBlocks ( ) . get ( i ) ; StatementBlock lsb = ws . getBody ( ) . get ( i ) ; rFindAndRecompileIndexingHOP ( lsb , lpb , var , ec , force ) ; } } else if ( for or parfor pb instanceof ForProgramBlock & & sb instanceof ForStatementBlock ) { ForProgramBlock fpb = ( ForProgramBlock ) pb ; ForStatementBlock fsb = ( ForStatementBlock ) sb ; ForStatement fs = ( ForStatement ) fsb . getStatement ( _NUM ) ; if ( fsb . getFromHops ( ) ! = null ) fpb . setFromInstructions ( rFindAndRecompileIndexingHOP ( fsb . getFromHops ( ) , fpb . getFromInstructions ( ) , var , ec , force ) ) ; if ( fsb . getToHops ( ) ! = null ) fpb . setToInstructions ( rFindAndRecompileIndexingHOP ( fsb . getToHops ( ) , fpb . getToInstructions ( ) , var , ec , force ) ) ; if ( fsb . getIncrementHops ( ) ! = null ) fpb . setIncrementInstructions ( rFindAndRecompileIndexingHOP ( fsb . getIncrementHops ( ) , fpb . getIncrementInstructions ( ) , var , ec , force ) ) ; process body robustness for potentially added problem blocks int len = fs . getBody ( ) . size ( ) ; for ( int i = _NUM ; i < fpb . getChildBlocks ( ) . size ( ) & & i < len ; i + + ) { ProgramBlock lpb = fpb . getChildBlocks ( ) . get ( i ) ; StatementBlock lsb = fs . getBody ( ) . get ( i ) ; rFindAndRecompileIndexingHOP ( lsb , lpb , var , ec , force ) ; } } else last level program block { try { process actual hops boolean ret = false ; Hop . resetVisitStatus ( sb . getHops ( ) ) ; if ( force ) { set forced execution type for ( Hop h : sb . getHops ( ) ) ret | = rFindAndSetCPIndexingHOP ( h , var ) ; } else { release forced execution type for ( Hop h : sb . getHops ( ) ) ret | = rFindAndReleaseIndexingHOP ( h , var ) ; } recompilation on - demand if ( ret ) { construct new instructions ArrayList < Instruction > newInst = Recompiler . recompileHopsDag ( sb , sb . getHops ( ) , ec . getVariables ( ) , null , true , false , _NUM ) ; pb . setInstructions ( newInst ) ; } } catch ( Exception ex ) { throw new DMLRuntimeException ( ex ) ; } } } 
5896	public void place ( Node r ) { note i might write count groups into the node class as well as it may be useful too ; i could swap over to the node class m _ groupNum = Node . getGCount ( r , _NUM ) ; group count , but this works os i ' m not gonna m _ groups = new Group [ m _ groupNum ] ; for ( int noa = _NUM ; noa < m _ groupNum ; noa + + ) { m _ groups [ noa ] = new Group ( ) ; m _ groups [ noa ] . m _ gap = _NUM ; m _ groups [ noa ] . m _ start = - _NUM ; } groupBuild ( r ) ; m _ levelNum = Node . getHeight ( r , _NUM ) ; m _ yRatio = _NUM / ( double ) ( m _ levelNum + _NUM ) ; m _ levels = new Level [ m _ levelNum ] ; for ( int noa = _NUM ; noa < m _ levelNum ; noa + + ) { m _ levels [ noa ] = new Level ( ) ; } r . setTop ( m _ yRatio ) ; yPlacer ( ) ; r . setCenter ( _NUM ) ; xPlacer ( _NUM ) ; ok now i just have to untangle then scale down note instead of starting with coords between _NUM and _NUM i will use ints then scale them down i will scale them down either by all relative to the largest line or by each line individually untangle _NUM ( ) ; scaleByMax ( ) ; scaleByInd ( ) ; } 
5897	public boolean contains ( Object key ) { return indexOfKey ( ( T ) key ) > = _NUM ; } 
5898	protected void initWorkplaceRequestValues ( CmsWorkplaceSettings settings , HttpServletRequest request ) { fill the parameter values in the get / set methods fillParamValues ( request ) ; set the dialog type setParamDialogtype ( DIALOG _ TYPE ) ; m _ progress = new CmsProgressWidget ( getJsp ( ) ) ; m _ progress . setWidth ( _STR ) ; set the publishing type : publish project or direct publish if ( CmsStringUtil . isNotEmptyOrWhitespaceOnly ( getParamResource ( ) ) | | isMultiOperation ( ) ) { setParamDirectpublish ( CmsStringUtil . TRUE ) ; } set default options if ( CmsStringUtil . isEmptyOrWhitespaceOnly ( getParamAction ( ) ) | | DIALOG _ INITIAL . equals ( getParamAction ( ) ) ) { siblings option . set to the default value defined in the opencms - workplace . xml setParamPublishsiblings ( String . valueOf ( getSettings ( ) . getUserSettings ( ) . getDialogPublishSiblings ( ) ) ) ; sub resources option . default value is true setParamSubresources ( Boolean . TRUE . toString ( ) ) ; related resources option . String defValue = CmsStringUtil . TRUE ; if ( OpenCms . getWorkplaceManager ( ) . getDefaultUserSettings ( ) . getPublishRelatedResources ( ) = = CmsDefaultUserSettings . PUBLISH _ RELATED _ RESOURCES _ MODE _ FALSE ) { defValue = CmsStringUtil . FALSE ; } setParamRelatedresources ( defValue ) ; } set the action for the JSP switch if ( DIALOG _ TYPE . equals ( getParamAction ( ) ) ) { setAction ( ACTION _ PUBLISH ) ; } else if ( DIALOG _ LOCKS _ CONFIRMED . equals ( getParamAction ( ) ) ) { setAction ( ACTION _ LOCKS _ CONFIRMED ) ; } else if ( DIALOG _ RESOURCES _ CONFIRMED . equals ( getParamAction ( ) ) ) { setAction ( ACTION _ RESOURCES _ CONFIRMED ) ; merge publish list with related resources if needed CmsPublishList publishList = getSettings ( ) . getPublishList ( ) ; if ( publishList = = null ) { this may happen if the user has not publish permissions ( with multi selection ) no publish permissions for the resource , set cancel action to close dialog setAction ( ACTION _ CANCEL ) ; return ; } if ( Boolean . valueOf ( getParamRelatedresources ( ) ) . booleanValue ( ) & & publishList . isDirectPublish ( ) ) { try { try to find the publish list with related related resources in the progress thread CmsProgressThread thread = CmsProgressWidget . getProgressThread ( getParamProgresskey ( ) ) ; CmsPublishList storedList = null ; if ( thread ! = null ) { storedList = ( ( CmsPublishResourcesList ) thread . getList ( ) ) . getPublishList ( ) ; } if ( storedList = = null ) { CmsPublishList relResources = OpenCms . getPublishManager ( ) . getRelatedResourcesToPublish ( getCms ( ) , publishList ) ; publishList = OpenCms . getPublishManager ( ) . mergePublishLists ( getCms ( ) , publishList , relResources ) ; } else { publishList = storedList ; } getSettings ( ) . setPublishList ( publishList ) ; } catch ( CmsException e ) { should never happen if ( LOG . isErrorEnabled ( ) ) { LOG . error ( e . getLocalizedMessage ( ) , e ) ; } } } start the progress CmsProgressWidget . removeProgressThread ( getProgress ( ) . getKey ( ) ) ; getProgress ( ) . startProgress ( getBrokenRelationsList ( ) ) ; wait to see if already finished synchronized ( this ) { try { wait ( _NUM _NUM _NUM ) ; } catch ( InterruptedException e ) { ignore } } CmsProgressThread thread = CmsProgressWidget . getProgressThread ( getProgress ( ) . getKey ( ) ) ; if ( ( ! thread . isAlive ( ) ) & & ( thread . getList ( ) . getList ( ) . getTotalSize ( ) = = _NUM ) ) { skip broken links confirmation screen setAction ( ACTION _ PUBLISH ) ; } } else if ( DIALOG _ WAIT . equals ( getParamAction ( ) ) ) { setAction ( ACTION _ WAIT ) ; } else if ( DIALOG _ CANCEL . equals ( getParamAction ( ) ) ) { setAction ( ACTION _ CANCEL ) ; } else { setAction ( ACTION _ DEFAULT ) ; set parameters depending on publishing type if ( isDirectPublish ( ) ) { check the required permissions to publish the resource directly if ( ! getCms ( ) . isManagerOfProject ( ) & & ! checkResourcePermissions ( CmsPermissionSet . ACCESS _ DIRECT _ PUBLISH , false ) ) { no publish permissions for the single resource , set cancel action to close dialog setAction ( ACTION _ CANCEL ) ; return ; } add the title for the direct publish dialog setDialogTitle ( Messages . GUI _ PUBLISH _ RESOURCE _ _NUM , Messages . GUI _ PUBLISH _ MULTI _ _NUM ) ; } else { add the title for the publish project dialog setParamTitle ( key ( Messages . GUI _ PUBLISH _ PROJECT _ _NUM ) ) ; determine the project id and name for publishing computePublishProject ( ) ; determine target to close the report } if lock state if not as expected if ( isLockStateOk ( ) ) { this may take a while : ( skip lock confirmation screen setAction ( ACTION _ LOCKS _ CONFIRMED ) ; } } } 
5899	public boolean equals ( Object otherFold ) { return otherFold instanceof Fold & & compareTo ( ( Fold ) otherFold ) = = _NUM ; } 
5900	public final void synpred _NUM _NUM _ JPA _ fragment ( ) throws RecognitionException { JPA . g : _NUM _NUM _NUM : _NUM : ( in _ expression ) JPA . g : _NUM _NUM _NUM : _NUM : in _ expression { pushFollow ( FOLLOW _ in _ expression _ in _ synpred _NUM _NUM _ JPA _NUM _NUM _NUM _NUM ) ; in _ expression ( ) ; state . _ fsp - - ; if ( state . failed ) return ; } } 
5901	public static int hash ( int h , Object o ) { int k = ( o = = null ) ? _NUM : o . hashCode ( ) ; return ( ( h < < _NUM ) | h ) ^ k ; } 
5902	public void testTwoParamDeprecatedAppend ( ) throws FlumeException , EventDeliveryException { RpcClient client = null ; Server server = RpcTestUtils . startServer ( new OKAvroHandler ( ) ) ; try { client = RpcClientFactory . getInstance ( localhost , server . getPort ( ) ) ; client . append ( EventBuilder . withBody ( _STR ) ) ) ; } finally { RpcTestUtils . stopServer ( server ) ; if ( client ! = null ) client . close ( ) ; } } 
5903	 @ DELETE @ Path ( _STR ) String clusterName ) { ResourceInstance resource = createClusterResource ( clusterName ) ; return handleRequest ( headers , null , ui , Request . Type . DELETE , resource ) ; } 
5904	public void addedDocument ( int commitWithin ) { maxDocs - triggered autoCommit . Use = = instead of > so we only trigger once on the way up if ( docsUpperBound > _NUM ) { long docs = docsSinceCommit . incrementAndGet ( ) ; if ( docs = = docsUpperBound + _NUM ) { reset the count here instead of run ( ) so we don ' t miss other documents being added docsSinceCommit . set ( _NUM ) ; _ scheduleCommitWithin ( DOC _ COMMIT _ DELAY _ MS ) ; } } maxTime - triggered autoCommit long ctime = ( commitWithin > _NUM ) ? commitWithin : timeUpperBound ; if ( ctime > _NUM ) { _ scheduleCommitWithin ( ctime ) ; } } 
5905	private String convertUriToPath ( Uri uri ) { String path = null ; if ( null ! = uri ) { String scheme = uri . getScheme ( ) ; if ( null = = scheme | | scheme . equals ( _STR ) ; } } return path ; } 
5906	public < T > HttpResponse < T > doGet ( HttpRequest httpRequest , final Class < T > responseType ) { Function < String , T > convertResponse = new Function < String , T > ( ) { @ Override public T apply ( String input ) { return gson . fromJson ( input , responseType ) ; } } ; return doGetWithSerializeFunction ( httpRequest , convertResponse ) ; } 
5907	public double correlationR _NUM ( int column ) { return pearsonCorrelation ( column ) ; } 
5908	private void findMasterSlides ( ) { SlideListWithText masterSLWT = _ documentRecord . getMasterSlideListWithText ( ) ; if ( masterSLWT = = null ) { return ; } for ( SlideAtomsSet sas : masterSLWT . getSlideAtomsSets ( ) ) { Record r = getCoreRecordForSAS ( sas ) ; int sheetNo = sas . getSlidePersistAtom ( ) . getSlideIdentifier ( ) ; if ( r instanceof Slide ) { HSLFTitleMaster master = new HSLFTitleMaster ( ( Slide ) r , sheetNo ) ; master . setSlideShow ( this ) ; _ titleMasters . add ( master ) ; } else if ( r instanceof MainMaster ) { HSLFSlideMaster master = new HSLFSlideMaster ( ( MainMaster ) r , sheetNo ) ; master . setSlideShow ( this ) ; _ masters . add ( master ) ; } } } 
5909	public void setListAdapter ( ListAdapter adapter ) { synchronized ( this ) { ensureLayout ( ) ; mAdapter = adapter ; mListView . setAdapter ( adapter ) ; } } 
5910	public DescribeSecurityGroupReferencesResult withSecurityGroupReferenceSet ( SecurityGroupReference . . . securityGroupReferenceSet ) { if ( getSecurityGroupReferenceSet ( ) = = null ) setSecurityGroupReferenceSet ( new java . util . ArrayList < SecurityGroupReference > ( securityGroupReferenceSet . length ) ) ; for ( SecurityGroupReference value : securityGroupReferenceSet ) { getSecurityGroupReferenceSet ( ) . add ( value ) ; } return this ; } 
5911	public void scheduleAndDeliverMessage ( ) { final long when = _NUM _NUM _NUM _NUM ; scheduleAndVerifyAlarm ( when ) ; verify ( mHandler , never ( ) ) . handleMessage ( any ( Message . class ) ) ; mListenerCaptor . getValue ( ) . onAlarm ( ) ; verifyMessageDispatchedOnce ( ) ; } 
5912	public void init ( Context context , boolean bootsToVr ) { startVrModeListener ( ) ; startDebugOnlyBroadcastReceiver ( context ) ; mBootsToVr = bootsToVr ; if ( mBootsToVr ) { If we are booting into VR , we need to start the virtual display immediately . This ensures that the virtual display is up by the time Setup Wizard is started . updateVirtualDisplay ( ) ; } } 
5913	public void close ( ) { synchronized ( ackQueue ) { while ( isRunning ( ) & & ackQueue . size ( ) ! = _NUM ) { try { ackQueue . wait ( ) ; } catch ( InterruptedException e ) { running = false ; Thread . currentThread ( ) . interrupt ( ) ; } } if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( myString + _STR ) ; } running = false ; ackQueue . notifyAll ( ) ; } synchronized ( this ) { running = false ; notifyAll ( ) ; } } 
5914	public static void main ( String [ ] args ) { try { if ( args . length < _NUM ) { System . err . println ( _STR + args [ j ] ) ; java . io . Reader r = new java . io . BufferedReader ( new java . io . FileReader ( args [ j ] ) ) ; Instances i = new Instances ( r ) ; PlotData _NUM D tmp = new PlotData _NUM D ( i ) ; if ( j ! = _NUM ) { tmp . m _ useCustomColour = true ; tmp . m _ customColour = Color . red ; } tmp . setPlotName ( i . relationName ( ) ) ; plotList . addElement ( tmp ) ; } p _NUM . setPlotList ( plotList ) ; jf . setVisible ( true ) ; } catch ( Exception ex ) { System . err . println ( ex . getMessage ( ) ) ; ex . printStackTrace ( ) ; } } 
5915	public IComplexNDArray complexScalar ( Number value , long offset ) { if ( Nd _NUM j . dataType ( ) = = DataBuffer . Type . DOUBLE ) return scalar ( createDouble ( value . doubleValue ( ) , _NUM ) , offset ) ; if ( Nd _NUM j . dataType ( ) = = DataBuffer . Type . FLOAT | | Nd _NUM j . dataType ( ) = = DataBuffer . Type . INT | | Nd _NUM j . dataType ( ) = = DataBuffer . Type . HALF ) return scalar ( createFloat ( value . floatValue ( ) , _NUM ) , offset ) ; throw new IllegalStateException ( _STR + Nd _NUM j . dataType ( ) ) ; } 
5916	public List < String > getIdentifiers ( ) { return getUnqualifiedBagValueList ( IDENTIFIER ) ; } 
5917	private InputWindowToken getNextToken ( InputWindowToken target ) throws IOException { InputWindowToken newTarget = target ; if ( numFillerTokensToInsert > _NUM ) { if ( null = = target ) { newTarget = new InputWindowToken ( nextInputStreamToken . cloneAttributes ( ) ) ; } else { nextInputStreamToken . copyTo ( target . attSource ) ; } A filler token occupies no space newTarget . offsetAtt . setOffset ( newTarget . offsetAtt . startOffset ( ) , newTarget . offsetAtt . startOffset ( ) ) ; newTarget . termAtt . copyBuffer ( FILLER _ TOKEN , _NUM , FILLER _ TOKEN . length ) ; newTarget . isFiller = true ; - - numFillerTokensToInsert ; } else if ( isNextInputStreamToken ) { if ( null = = target ) { newTarget = new InputWindowToken ( nextInputStreamToken . cloneAttributes ( ) ) ; } else { nextInputStreamToken . copyTo ( target . attSource ) ; } isNextInputStreamToken = false ; newTarget . isFiller = false ; } else if ( ! exhausted & & input . incrementToken ( ) ) { if ( null = = target ) { newTarget = new InputWindowToken ( cloneAttributes ( ) ) ; } else { this . copyTo ( target . attSource ) ; } if ( posIncrAtt . getPositionIncrement ( ) > _NUM ) { Each output shingle must contain at least one input token , so no more than ( maxShingleSize - _NUM ) filler tokens will be inserted . numFillerTokensToInsert = Math . min ( posIncrAtt . getPositionIncrement ( ) - _NUM , maxShingleSize - _NUM ) ; Save the current token as the next input stream token if ( null = = nextInputStreamToken ) { nextInputStreamToken = cloneAttributes ( ) ; } else { this . copyTo ( nextInputStreamToken ) ; } isNextInputStreamToken = true ; A filler token occupies no space newTarget . offsetAtt . setOffset ( offsetAtt . startOffset ( ) , offsetAtt . startOffset ( ) ) ; newTarget . termAtt . copyBuffer ( FILLER _ TOKEN , _NUM , FILLER _ TOKEN . length ) ; newTarget . isFiller = true ; - - numFillerTokensToInsert ; } else { newTarget . isFiller = false ; } } else { newTarget = null ; exhausted = true ; } return newTarget ; } 
5918	public int getProperNumerator ( ) { return Math . abs ( numerator % denominator ) ; } 
5919	 $ ANTLR start _STR , _NUM _NUM , _NUM , input ) ; throw nvae ; } switch ( alt _NUM _NUM ) { case _NUM : JPA . g : _NUM _NUM _NUM : _NUM : literal { root _ _NUM = ( Object ) adaptor . nil ( ) ; pushFollow ( FOLLOW _ literal _ in _ in _ item _NUM _NUM _NUM _NUM ) ; literal _NUM _NUM _NUM = literal ( ) ; state . _ fsp - - ; if ( state . failed ) return retval ; if ( state . backtracking = = _NUM ) adaptor . addChild ( root _ _NUM , literal _NUM _NUM _NUM . getTree ( ) ) ; } break ; case _NUM : JPA . g : _NUM _NUM _NUM : _NUM : input _ parameter { root _ _NUM = ( Object ) adaptor . nil ( ) ; pushFollow ( FOLLOW _ input _ parameter _ in _ in _ item _NUM _NUM _NUM _NUM ) ; input _ parameter _NUM _NUM _NUM = input _ parameter ( ) ; state . _ fsp - - ; if ( state . failed ) return retval ; if ( state . backtracking = = _NUM ) adaptor . addChild ( root _ _NUM , input _ parameter _NUM _NUM _NUM . getTree ( ) ) ; } break ; } retval . stop = input . LT ( - _NUM ) ; if ( state . backtracking = = _NUM ) { retval . tree = ( Object ) adaptor . rulePostProcessing ( root _ _NUM ) ; adaptor . setTokenBoundaries ( retval . tree , retval . start , retval . stop ) ; } } catch ( RecognitionException re ) { reportError ( re ) ; recover ( input , re ) ; retval . tree = ( Object ) adaptor . errorNode ( input , retval . start , input . LT ( - _NUM ) , re ) ; } finally { } return retval ; } 
5920	public boolean input ( Instance instance ) { if ( getInputFormat ( ) = = null ) { throw new IllegalStateException ( _STR ) ; } if ( m _ NewBatch ) { resetQueue ( ) ; m _ NewBatch = false ; } push ( ( Instance ) instance . copy ( ) ) ; return true ; } 
5921	public static String getGPIOForButton ( ) { switch ( getBoardVariant ( ) ) { case DEVICE _ EDISON _ ARDUINO : return _STR + Build . DEVICE ) ; } } 
5922	protected boolean eq ( Object x , Object y ) { return x = = y | | x . equals ( y ) ; } 
5923	public List < Map < String , String > > getResultSetListBySql ( String sql ) { Connection conn = null ; Statement stat = null ; ResultSet rs = null ; try { conn = this . getReadConnection ( ) ; stat = conn . createStatement ( ) ; rs = stat . executeQuery ( sql ) ; return getDataMapFromRs ( rs ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return new ArrayList < Map < String , String > > ( ) ; } finally { closeAll ( rs , stat , conn ) ; } } 
5924	private void reset ( ) { if ( pushTransitionAnimator ! = null ) { pushTransitionAnimator . reset ( ) ; } if ( mAnimatorSet ! = null & & mAnimatorSet . isRunning ( ) ) { mAnimatorSet . cancel ( ) ; } if ( mValueAnimator ! = null & & mValueAnimator . isRunning ( ) ) { mValueAnimator . cancel ( ) ; } mCurrentArcPosition = _NUM f ; } 
5925	private Token readString ( ) { StringBuilder sb = new StringBuilder ( ) ; while ( buffer . hasRemaining ( ) ) { char c = getChar ( ) ; string context switch ( c ) { case ' ( ' : openParens + + ; sb . append ( ' ( ' ) ; break ; case ' ) ' : if ( openParens = = _NUM ) { end of string return new Token ( sb . toString ( ) , Token . STRING ) ; } sb . append ( ' ) ' ) ; openParens - - ; break ; case ' \ \ ' : escapes : \ n \ r \ t \ b \ f \ \ \ ( \ ) char c _NUM = getChar ( ) ; switch ( c _NUM ) { case ' n ' : case ' r ' : sb . append ( _STR ) ; break ; default : sb . append ( c ) ; break ; } } return null ; } 
5926	private boolean pathExists ( final String db , final String path ) throws IOException { final WebDAVQuery query = new WebDAVQuery ( EXISTS . args ( _ DB _ LIST . args ( _STR , path ) ; return execute ( query ) . equals ( Text . TRUE ) ; } 
5927	public INode getINode _NUM Write ( String src ) throws UnresolvedLinkException , SnapshotAccessControlException { return getINodesInPath _NUM Write ( src , true ) . getLastINode ( ) ; } 
5928	public static LocationMapper makeGlobal ( ) { LocationMapper lMap = new LocationMapper ( ) ; if ( getGlobalConfigPath ( ) ! = null ) { LocationMapper lMap _NUM = JenaIOEnvironment . createLocationMapper ( getGlobalConfigPath ( ) ) ; lMap . copyFrom ( lMap _NUM ) ; } return lMap ; } 
5929	public void disableCache ( CacheType . . . types ) { for ( CacheType type : types ) { m _ disabled . put ( type , Boolean . TRUE ) ; } flushCache ( types ) ; } 
5930	private void extractRowKeyAndData ( String line , DefaultCategoryDataset dataset , List columnKeys ) { Comparable rowKey = null ; int fieldIndex = _NUM ; int start = _NUM ; for ( int i = _NUM ; i < line . length ( ) ; i + + ) { if ( line . charAt ( i ) = = this . fieldDelimiter ) { if ( fieldIndex = = _NUM ) { first field contains the row key String key = line . substring ( start , i ) ; rowKey = removeStringDelimiters ( key ) ; } else { remaining fields contain values Double value = Double . valueOf ( removeStringDelimiters ( line . substring ( start , i ) ) ) ; dataset . addValue ( value , rowKey , ( Comparable ) columnKeys . get ( fieldIndex - _NUM ) ) ; } start = i + _NUM ; fieldIndex + + ; } } Double value = Double . valueOf ( removeStringDelimiters ( line . substring ( start , line . length ( ) ) ) ) ; dataset . addValue ( value , rowKey , ( Comparable ) columnKeys . get ( fieldIndex - _NUM ) ) ; } 
5931	void internalHide ( ) { if ( ! isVisible ( ) ) { return ; } for ( PresenterWidget < ? > child : children ) { child . internalHide ( ) ; } if ( isPopup ( ) ) { ( ( PopupView ) this . getView ( ) ) . setCloseHandler ( null ) ; ( ( PopupView ) this . getView ( ) ) . hide ( ) ; } unregisterVisibleHandlers ( ) ; visible = false ; onHide ( ) ; } 
5932	protected void testConnectionOnStartup ( ) throws FailedToCreateConsumerException { try { log . debug ( _STR + getDestinationName ( ) ; throw new FailedToCreateConsumerException ( getEndpoint ( ) , msg , e ) ; } } 
5933	public Iterator < Host > newQueryPlan ( String loggedKeyspace , Statement statement ) { final Iterator < Host > childIter = childPolicy . newQueryPlan ( loggedKeyspace , statement ) ; return new AbstractIterator < Host > ( ) { private Queue < Host > skipped ; @ Override protected Host computeNext ( ) { long min = latencyTracker . getMinAverage ( ) ; long now = System . nanoTime ( ) ; while ( childIter . hasNext ( ) ) { Host host = childIter . next ( ) ; TimestampedAverage latency = latencyTracker . latencyOf ( host ) ; is just too old , include the host . if ( min < _NUM | | latency = = null | | latency . nbMeasure < minMeasure | | ( now - latency . timestamp ) > retryPeriod ) { if ( hostMetricsEnabled ( ) ) { metrics . getRegistry ( ) . counter ( MetricsUtil . hostMetricName ( _STR , host ) ) . inc ( ) ; } return host ; } return endOfData ( ) ; } } ; } 
5934	public void stop ( ) throws RemoteException { try { stopScan ( ) ; } catch ( RuntimeException ex ) { throw new RemoteException ( _STR + mScanId ) ; } } 
5935	private SeqType sequenceType ( ) throws QueryException { empty sequence if ( wsConsumeWs ( EMPTY _ SEQUENCE , PAREN _NUM , null ) ) { wsCheck ( PAREN _NUM ) ; wsCheck ( PAREN _NUM ) ; return SeqType . EMP ; } parse item type and occurrence indicator final SeqType st = itemType ( ) ; skipWs ( ) ; final Occ occ = consume ( ' ? ' ) ? Occ . ZERO _ ONE : consume ( ' + ' ) ? Occ . ONE _ MORE : consume ( ' * ' ) ? Occ . ZERO _ MORE : Occ . ONE ; skipWs ( ) ; return st . with ( occ ) ; } 
5936	public void addToThis ( GF _NUM Polynomial b ) { expandN ( b . len ) ; xorThisBy ( b ) ; } 
5937	public FluentInitializer init ( Date minDate , Date maxDate , Locale locale ) { if ( minDate = = null | | maxDate = = null ) { throw new IllegalArgumentException ( _STR + month ) ; months . add ( month ) ; monthCounter . add ( MONTH , _NUM ) ; } validateAndUpdate ( ) ; return new FluentInitializer ( ) ; } 
5938	public double learnSequence ( @ NonNull Sequence < T > sequence , @ NonNull AtomicLong nextRandom , double learningRate ) { Sequence < T > tempSequence = sequence ; if ( sampling > _NUM ) tempSequence = applySubsampling ( sequence , nextRandom ) ; double score = _NUM . _NUM ; int currentWindow = window ; if ( variableWindows ! = null & & variableWindows . length ! = _NUM ) { currentWindow = variableWindows [ RandomUtils . nextInt ( variableWindows . length ) ] ; } for ( int i = _NUM ; i < tempSequence . getElements ( ) . size ( ) ; i + + ) { nextRandom . set ( Math . abs ( nextRandom . get ( ) * _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM L + _NUM _NUM ) ) ; score = skipGram ( i , tempSequence . getElements ( ) , ( int ) nextRandom . get ( ) % currentWindow , nextRandom , learningRate , currentWindow ) ; } if ( batches ! = null & & batches . get ( ) ! = null & & batches . get ( ) . size ( ) > = configuration . getBatchSize ( ) ) { Nd _NUM j . getExecutioner ( ) . exec ( batches . get ( ) ) ; batches . get ( ) . clear ( ) ; } return score ; } 
5939	protected void initSettings ( Element root , CmsXmlContentDefinition contentDefinition ) { Iterator < Element > itProperties = CmsXmlGenericWrapper . elementIterator ( root , APPINFO _ SETTING ) ; while ( itProperties . hasNext ( ) ) { Element element = itProperties . next ( ) ; CmsXmlContentProperty setting = new CmsXmlContentProperty ( element . attributeValue ( APPINFO _ ATTR _ NAME ) , element . attributeValue ( APPINFO _ ATTR _ TYPE ) , element . attributeValue ( APPINFO _ ATTR _ WIDGET ) , element . attributeValue ( APPINFO _ ATTR _ WIDGET _ CONFIG ) , element . attributeValue ( APPINFO _ ATTR _ RULE _ REGEX ) , element . attributeValue ( APPINFO _ ATTR _ RULE _ TYPE ) , element . attributeValue ( APPINFO _ ATTR _ DEFAULT ) , element . attributeValue ( APPINFO _ ATTR _ NICE _ NAME ) , element . attributeValue ( APPINFO _ ATTR _ DESCRIPTION ) , element . attributeValue ( APPINFO _ ATTR _ ERROR ) , element . attributeValue ( APPINFO _ ATTR _ PREFERFOLDER ) ) ; String name = setting . getName ( ) ; if ( CmsStringUtil . isNotEmptyOrWhitespaceOnly ( name ) ) { m _ settings . put ( name , setting ) ; } } } 
5940	protected void executeAction ( HttpAction action ) { executeLifecycle ( action ) ; } 
5941	public boolean isValidSignedResponse ( AuthenticatedUser authenticatedUser , String signedResponse ) throws GuacamoleException { SignedDuoCookie duoCookie ; SignedDuoCookie appCookie ; Retrieve username from externally - authenticated user String username = authenticatedUser . getIdentifier ( ) ; Retrieve Duo - specific keys from configuration String applicationKey = confService . getApplicationKey ( ) ; String integrationKey = confService . getIntegrationKey ( ) ; String secretKey = confService . getSecretKey ( ) ; try { Verify format of response Matcher matcher = RESPONSE _ FORMAT . matcher ( signedResponse ) ; if ( ! matcher . matches ( ) ) { logger . debug ( _STR ) ; return false ; } All verifications tests pass return true ; } 
5942	protected void connectToLeader ( InetSocketAddress addr , String hostname ) throws IOException , ConnectException , InterruptedException { sock = new Socket ( ) ; sock . setSoTimeout ( self . tickTime * self . initLimit ) ; int initLimitTime = self . tickTime * self . initLimit ; int remainingInitLimitTime = initLimitTime ; long startNanoTime = nanoTime ( ) ; for ( int tries = _NUM ; tries < _NUM ; tries + + ) { try { recalculate the init limit time because retries sleep for _NUM _NUM _NUM _NUM milliseconds remainingInitLimitTime = initLimitTime - ( int ) ( ( nanoTime ( ) - startNanoTime ) / _NUM _NUM _NUM _NUM _NUM _NUM _NUM ) ; if ( remainingInitLimitTime < = _NUM ) { LOG . error ( _STR + addr , e ) ; sock = new Socket ( ) ; sock . setSoTimeout ( self . tickTime * self . initLimit ) ; } } Thread . sleep ( _NUM _NUM _NUM _NUM ) ; } self . authLearner . authenticate ( sock , hostname ) ; leaderIs = BinaryInputArchive . getArchive ( new BufferedInputStream ( sock . getInputStream ( ) ) ) ; bufferedOutput = new BufferedOutputStream ( sock . getOutputStream ( ) ) ; leaderOs = BinaryOutputArchive . getArchive ( bufferedOutput ) ; } 
5943	public MessageResponse addResultEntry ( String key , MessageResult value ) { if ( null = = this . result ) { this . result = new java . util . HashMap < String , MessageResult > ( ) ; } if ( this . result . containsKey ( key ) ) throw new IllegalArgumentException ( _STR ) ; this . result . put ( key , value ) ; return this ; } 
5944	public byte [ ] [ ] getAuthPath ( ) { return GMSSUtils . clone ( AuthPath ) ; } 
5945	public void testIssueSaml _NUM Token ( ) throws Exception { TokenIssueOperation issueOperation = new TokenIssueOperation ( ) ; addTokenProvider ( issueOperation ) ; addService ( issueOperation ) ; addSTSProperties ( issueOperation ) ; Set the ClaimsManager ClaimsManager claimsManager = new ClaimsManager ( ) ; ClaimsHandler claimsHandler = new CustomClaimsHandler ( ) ; claimsManager . setClaimHandlers ( Collections . singletonList ( claimsHandler ) ) ; issueOperation . setClaimsManager ( claimsManager ) ; Mock up a request RequestSecurityTokenType request = new RequestSecurityTokenType ( ) ; JAXBElement < String > tokenType = new JAXBElement < String > ( QNameConstants . TOKEN _ TYPE , String . class , WSS _NUM JConstants . WSS _ SAML _ TOKEN _ TYPE ) ; request . getAny ( ) . add ( tokenType ) ; Element secondaryParameters = createSecondaryParameters ( ) ; request . getAny ( ) . add ( secondaryParameters ) ; request . getAny ( ) . add ( createAppliesToElement ( _STR ) ) ; } 
5946	public void run ( String name , Config config , Builder builder ) { BuilderImpl bldr = ( BuilderImpl ) builder ; TopologyBuilder topologyBuilder = bldr . build ( ) ; try { HeronSubmitter . submitTopology ( name , config . getHeronConfig ( ) , topologyBuilder . createTopology ( ) ) ; } catch ( AlreadyAliveException | InvalidTopologyException e ) { e . printStackTrace ( ) ; } } 
5947	public void bug _NUM _NUM _NUM _NUM _NUM ( ) throws IOException { Workbook wb = _ testDataProvider . createWorkbook ( ) ; Sheet s = wb . createSheet ( ) ; Row r _NUM = s . createRow ( _NUM ) ; Row r _NUM = s . createRow ( _NUM ) ; r _NUM . createCell ( _NUM ) . setCellValue ( _STR , eval . evaluate ( c ) . getStringValue ( ) ) ; wb . close ( ) ; } 
5948	public static XmlNOTATION parse ( javax . xml . stream . XMLStreamReader xsr ) throws org . apache . xmlbeans . XmlException { return ( XmlNOTATION ) XmlBeans . getContextTypeLoader ( ) . parse ( xsr , type , null ) ; } 
5949	public final ImageViewState getState ( ) { if ( vTranslate ! = null & & sWidth > _NUM & & sHeight > _NUM ) { return new ImageViewState ( getScale ( ) , getCenter ( ) , getOrientation ( ) ) ; } return null ; } 
5950	public static String [ ] executorCommandArgs ( Config config , Config runtime , Map < ExecutorPort , String > ports , String containerIndex ) { List < String > args = new ArrayList < > ( ) ; addExecutorTopologyArgs ( args , config , runtime ) ; addExecutorContainerArgs ( args , ports , containerIndex ) ; return args . toArray ( new String [ args . size ( ) ] ) ; } 
5951	public void clear ( ) { m _ Model . clear ( ) ; setButtons ( null ) ; } 
5952	public static ShoppingCartItem makePurchaseOrderItem ( Integer cartLocation , String productId , BigDecimal selectedAmount , BigDecimal quantity , Map < String , GenericValue > additionalProductFeatureAndAppls , Map < String , Object > attributes , String prodCatalogId , ProductConfigWrapper configWrapper , String itemType , ShoppingCart . ShoppingCartItemGroup itemGroup , LocalDispatcher dispatcher , ShoppingCart cart , GenericValue supplierProduct , Timestamp shipBeforeDate , Timestamp shipAfterDate , Timestamp cancelBackOrderDate ) throws CartItemModifyException , ItemNotFoundException { Delegator delegator = cart . getDelegator ( ) ; GenericValue product = null ; try { product = EntityQuery . use ( delegator ) . from ( _STR ) ) ; } return newItem ; } 
5953	public Path getLocalPathForWrite ( String pathStr , long size , Configuration conf , boolean checkWrite ) throws IOException { AllocatorPerContext context = obtainContext ( contextCfgItemName ) ; return context . getLocalPathForWrite ( pathStr , size , conf , checkWrite ) ; } 
5954	just in case the LgArr is missingstatic int getLgCouponArrInts ( final AbstractCoupons impl , final int lgArr ) { < _NUM is invalid if ( lgArr > = _NUM ) { return lgArr ; } final int coupons = impl . getCouponCount ( ) ; int ceilPwr _NUM = ceilingPowerOf _NUM ( coupons ) ; final int minLgArr = ( impl . curMode = = CurMode . LIST ) ? LG _ INIT _ LIST _ SIZE : LG _ INIT _ SET _ SIZE ; if ( ( RESIZE _ DENOM * coupons ) > ( RESIZE _ NUMER * ceilPwr _NUM ) ) { ceilPwr _NUM < < = _NUM ; } return Math . max ( minLgArr , ceilPwr _NUM < < _NUM ) ; } 
5955	 @ Test ( groups = _STR , host ) ; Uninterruptibles . sleepUninterruptibly ( _NUM , TimeUnit . SECONDS ) ; } assertThat ( cluster ) . host ( failingHost . address ) . isReconnectingFromDown ( ) ; } assertThat ( TestUtils . findHost ( cluster , missingHostAddress ) ) . isNull ( ) ; } finally { if ( cluster ! = null ) cluster . close ( ) ; for ( FakeHost fakeHost : failingHosts ) fakeHost . stop ( ) ; if ( scassandra ! = null ) scassandra . stop ( ) ; } } 
5956	private void lazyInit ( ) { if ( lazyInited . compareAndSet ( false , true ) & & fileLength < Long . MAX _ VALUE ) { debug ( _STR + e . getMessage ( ) ) ; } } } } ; thread . start ( ) ; } } 
5957	private static final void checkManageOrCreateUsersPermission ( String message ) { if ( ! hasManageOrCreateUsersPermission ( ) ) { throw new SecurityException ( _STR + message ) ; } } 
5958	public void notifyBlocking ( @ NonNull String name , @ NonNull String message , String context , @ NonNull StackTraceElement [ ] stacktrace , Severity severity , @ NonNull MetaData metaData ) { Error error = new Error . Builder ( config , name , message , stacktrace , sessionTracker . getCurrentSession ( ) ) . severity ( severity ) . metaData ( metaData ) . build ( ) ; error . setContext ( context ) ; notify ( error , BLOCKING ) ; } 
5959	public void setStackFromBottom ( boolean stackFromBottom ) { if ( mStackFromBottom ! = stackFromBottom ) { mStackFromBottom = stackFromBottom ; requestLayoutIfNecessary ( ) ; } } 
5960	public org . fife . ui . rsyntaxtextarea . Token yylex ( ) throws java . io . IOException { int zzInput ; int zzAction ; cached fields : int zzCurrentPosL ; int zzMarkedPosL ; int zzEndReadL = zzEndRead ; char [ ] zzBufferL = zzBuffer ; char [ ] zzCMapL = ZZ _ CMAP ; int [ ] zzTransL = ZZ _ TRANS ; int [ ] zzRowMapL = ZZ _ ROWMAP ; int [ ] zzAttrL = ZZ _ ATTRIBUTE ; while ( true ) { zzMarkedPosL = zzMarkedPos ; zzAction = - _NUM ; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL ; zzState = zzLexicalState ; zzForAction : { while ( true ) { if ( zzCurrentPosL < zzEndReadL ) zzInput = zzBufferL [ zzCurrentPosL + + ] ; else if ( zzAtEOF ) { zzInput = YYEOF ; break zzForAction ; } else { store back cached positions zzCurrentPos = zzCurrentPosL ; zzMarkedPos = zzMarkedPosL ; boolean eof = zzRefill ( ) ; get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos ; zzMarkedPosL = zzMarkedPos ; zzBufferL = zzBuffer ; zzEndReadL = zzEndRead ; if ( eof ) { zzInput = YYEOF ; break zzForAction ; } else { zzInput = zzBufferL [ zzCurrentPosL + + ] ; } } int zzNext = zzTransL [ zzRowMapL [ zzState ] + zzCMapL [ zzInput ] ] ; if ( zzNext = = - _NUM ) break zzForAction ; zzState = zzNext ; int zzAttributes = zzAttrL [ zzState ] ; if ( ( zzAttributes & _NUM ) = = _NUM ) { zzAction = zzState ; zzMarkedPosL = zzCurrentPosL ; if ( ( zzAttributes & _NUM ) = = _NUM ) break zzForAction ; } } } store back cached position zzMarkedPos = zzMarkedPosL ; switch ( zzAction < _NUM ? zzAction : ZZ _ ACTION [ zzAction ] ) { case _NUM _NUM : { start = zzMarkedPos - yylength ( ) ; yybegin ( STRING _ Q _ LT ) ; } case _NUM _NUM : break ; case _NUM : { addToken ( Token . IDENTIFIER ) ; } case _NUM _NUM : break ; case _NUM _NUM : { addToken ( Token . LITERAL _ BOOLEAN ) ; } case _NUM _NUM : break ; case _NUM _NUM : { addToken ( start , zzStartRead - _NUM , Token . COMMENT _ DOCUMENTATION ) ; return firstToken ; } case _NUM _NUM : break ; case _NUM _NUM : { addToken ( start , zzStartRead - _NUM , Token . LITERAL _ STRING _ DOUBLE _ QUOTE ) ; addEndToken ( INTERNAL _ STRING _ Q _ PAREN ) ; return firstToken ; } case _NUM _NUM : break ; case _NUM _NUM : { addToken ( start , zzStartRead - _NUM , Token . LITERAL _ STRING _ DOUBLE _ QUOTE ) ; addEndToken ( INTERNAL _ STRING _ Q _ CURLY _ BRACE ) ; return firstToken ; } case _NUM _NUM : break ; case _NUM _NUM : { addToken ( start , zzStartRead - _NUM , Token . LITERAL _ STRING _ DOUBLE _ QUOTE ) ; addEndToken ( INTERNAL _ STRING _ Q _ SLASH ) ; return firstToken ; } case _NUM _NUM : break ; case _NUM _NUM : { yybegin ( YYINITIAL ) ; addToken ( start , zzStartRead + _NUM , Token . COMMENT _ DOCUMENTATION ) ; } case _NUM _NUM : break ; case _NUM _NUM : { start = zzMarkedPos - _NUM ; yybegin ( STRING ) ; } case _NUM _NUM : break ; case _NUM _NUM : { if ( start = = zzStartRead ) { addToken ( Token . PREPROCESSOR ) ; addNullToken ( ) ; return firstToken ; } } case _NUM _NUM : break ; case _NUM : { addToken ( Token . FUNCTION ) ; } case _NUM _NUM : break ; case _NUM _NUM : { addToken ( start , zzStartRead - _NUM , Token . LITERAL _ STRING _ DOUBLE _ QUOTE ) ; addEndToken ( INTERNAL _ STRING _ Q _ LT ) ; return firstToken ; } case _NUM _NUM : break ; case _NUM _NUM : { addToken ( Token . VARIABLE ) ; } case _NUM _NUM : break ; case _NUM : { addToken ( Token . ERROR _ IDENTIFIER ) ; } case _NUM _NUM : break ; case _NUM _NUM : { addToken ( start , zzStartRead - _NUM , Token . PREPROCESSOR ) ; addEndToken ( INTERNAL _ HEREDOC _ EOT _ SINGLE _ QUOTED ) ; return firstToken ; } case _NUM _NUM : break ; case _NUM : { addToken ( Token . COMMENT _ EOL ) ; addNullToken ( ) ; return firstToken ; } case _NUM _NUM : break ; case _NUM _NUM : { start = zzMarkedPos - yylength ( ) ; yybegin ( STRING _ Q _ CURLY _ BRACE ) ; } case _NUM _NUM : break ; case _NUM _NUM : { start = zzStartRead ; yybegin ( HEREDOC _ EOF _ SINGLE _ QUOTED ) ; } case _NUM _NUM : break ; case _NUM _NUM : { start = zzStartRead ; yybegin ( HEREDOC _ EOT _ SINGLE _ QUOTED ) ; } case _NUM _NUM : break ; case _NUM _NUM : { start = zzStartRead ; yybegin ( HEREDOC _ EOF _ UNQUOTED ) ; } case _NUM _NUM : break ; case _NUM _NUM : { } case _NUM _NUM : break ; case _NUM _NUM : { yybegin ( YYINITIAL ) ; addToken ( start , zzStartRead , Token . LITERAL _ CHAR ) ; } case _NUM _NUM : break ; case _NUM _NUM : { addToken ( Token . LITERAL _ NUMBER _ HEXADECIMAL ) ; } case _NUM _NUM : break ; case _NUM _NUM : { addToken ( start , zzStartRead - _NUM , Token . PREPROCESSOR ) ; addEndToken ( INTERNAL _ HEREDOC _ EOF _ UNQUOTED ) ; return firstToken ; } case _NUM _NUM : break ; case _NUM : { addToken ( Token . WHITESPACE ) ; } case _NUM _NUM : break ; case _NUM _NUM : { addToken ( start , zzStartRead - _NUM , Token . LITERAL _ STRING _ DOUBLE _ QUOTE ) ; addEndToken ( INTERNAL _ STRING _ Q _ BANG ) ; return firstToken ; } case _NUM _NUM : break ; case _NUM _NUM : { addToken ( Token . PREPROCESSOR ) ; } case _NUM _NUM : break ; case _NUM _NUM : { start = zzMarkedPos - _NUM ; yybegin ( CHAR _ LITERAL ) ; } case _NUM _NUM : break ; case _NUM : { addToken ( Token . LITERAL _ NUMBER _ DECIMAL _ INT ) ; } case _NUM _NUM : break ; case _NUM _NUM : { start = zzMarkedPos - yylength ( ) ; yybegin ( STRING _ Q _ SLASH ) ; } case _NUM _NUM : break ; case _NUM _NUM : { yybegin ( YYINITIAL ) ; addToken ( start , zzStartRead , Token . LITERAL _ BACKQUOTE ) ; } case _NUM _NUM : break ; case _NUM _NUM : { yybegin ( YYINITIAL ) ; addToken ( start , zzStartRead , Token . LITERAL _ STRING _ DOUBLE _ QUOTE ) ; } case _NUM _NUM : break ; case _NUM _NUM : { start = zzMarkedPos - yylength ( ) ; yybegin ( STRING _ Q _ BANG ) ; } case _NUM _NUM : break ; case _NUM _NUM : { } case _NUM _NUM : break ; case _NUM _NUM : { addToken ( start , zzStartRead - _NUM , Token . PREPROCESSOR ) ; addEndToken ( INTERNAL _ HEREDOC _ EOT _ UNQUOTED ) ; return firstToken ; } case _NUM _NUM : break ; case _NUM _NUM : { start = zzMarkedPos - _NUM ; yybegin ( DOCCOMMENT ) ; } case _NUM _NUM : break ; case _NUM _NUM : { addToken ( Token . RESERVED _ WORD ) ; } case _NUM _NUM : break ; case _NUM _NUM : { addToken ( start , zzStartRead - _NUM , Token . LITERAL _ BACKQUOTE ) ; return firstToken ; } case _NUM _NUM : break ; case _NUM _NUM : { start = zzMarkedPos - yylength ( ) ; yybegin ( STRING _ Q _ SQUARE _ BRACKET ) ; } case _NUM _NUM : break ; case _NUM : { addToken ( Token . SEPARATOR ) ; } case _NUM _NUM : break ; case _NUM : { addNullToken ( ) ; return firstToken ; } case _NUM _NUM : break ; case _NUM _NUM : { addToken ( start , zzStartRead - _NUM , Token . LITERAL _ STRING _ DOUBLE _ QUOTE ) ; addEndToken ( INTERNAL _ STRING _ Q _ SQUARE _ BRACKET ) ; return firstToken ; } case _NUM _NUM : break ; case _NUM _NUM : { start = zzMarkedPos - yylength ( ) ; yybegin ( STRING _ Q _ PAREN ) ; } case _NUM _NUM : break ; case _NUM : { addToken ( Token . OPERATOR ) ; } case _NUM _NUM : break ; case _NUM _NUM : { addToken ( start , zzStartRead - _NUM , Token . LITERAL _ CHAR ) ; return firstToken ; } case _NUM _NUM : break ; case _NUM _NUM : { addToken ( Token . LITERAL _ NUMBER _ FLOAT ) ; } case _NUM _NUM : break ; case _NUM _NUM : { start = zzStartRead ; yybegin ( HEREDOC _ EOT _ UNQUOTED ) ; } case _NUM _NUM : break ; case _NUM _NUM : { start = zzMarkedPos - _NUM ; yybegin ( BACKTICKS ) ; } case _NUM _NUM : break ; case _NUM _NUM : { } case _NUM _NUM _NUM : break ; case _NUM _NUM : { addToken ( start , zzStartRead - _NUM , Token . LITERAL _ STRING _ DOUBLE _ QUOTE ) ; return firstToken ; } case _NUM _NUM _NUM : break ; case _NUM _NUM : { addToken ( start , zzStartRead - _NUM , Token . PREPROCESSOR ) ; addEndToken ( INTERNAL _ HEREDOC _ EOF _ SINGLE _ QUOTED ) ; return firstToken ; } case _NUM _NUM _NUM : break ; default : if ( zzInput = = YYEOF & & zzStartRead = = zzCurrentPos ) { zzAtEOF = true ; switch ( zzLexicalState ) { case HEREDOC _ EOF _ SINGLE _ QUOTED : { addToken ( start , zzStartRead - _NUM , Token . PREPROCESSOR ) ; addEndToken ( INTERNAL _ HEREDOC _ EOF _ SINGLE _ QUOTED ) ; return firstToken ; } case _NUM _NUM _NUM : break ; case DOCCOMMENT : { yybegin ( YYINITIAL ) ; addToken ( start , zzEndRead , Token . COMMENT _ DOCUMENTATION ) ; return firstToken ; } case _NUM _NUM _NUM : break ; case HEREDOC _ EOT _ SINGLE _ QUOTED : { addToken ( start , zzStartRead - _NUM , Token . PREPROCESSOR ) ; addEndToken ( INTERNAL _ HEREDOC _ EOT _ SINGLE _ QUOTED ) ; return firstToken ; } case _NUM _NUM _NUM : break ; case HEREDOC _ EOT _ UNQUOTED : { addToken ( start , zzStartRead - _NUM , Token . PREPROCESSOR ) ; addEndToken ( INTERNAL _ HEREDOC _ EOT _ UNQUOTED ) ; return firstToken ; } case _NUM _NUM _NUM : break ; case STRING _ Q _ SLASH : { addToken ( start , zzStartRead - _NUM , Token . LITERAL _ STRING _ DOUBLE _ QUOTE ) ; addEndToken ( INTERNAL _ STRING _ Q _ SLASH ) ; return firstToken ; } case _NUM _NUM _NUM : break ; case STRING _ Q _ BANG : { addToken ( start , zzStartRead - _NUM , Token . LITERAL _ STRING _ DOUBLE _ QUOTE ) ; addEndToken ( INTERNAL _ STRING _ Q _ BANG ) ; return firstToken ; } case _NUM _NUM _NUM : break ; case STRING _ Q _ LT : { addToken ( start , zzStartRead - _NUM , Token . LITERAL _ STRING _ DOUBLE _ QUOTE ) ; addEndToken ( INTERNAL _ STRING _ Q _ LT ) ; return firstToken ; } case _NUM _NUM _NUM : break ; case STRING : { addToken ( start , zzStartRead - _NUM , Token . LITERAL _ STRING _ DOUBLE _ QUOTE ) ; return firstToken ; } case _NUM _NUM _NUM : break ; case BACKTICKS : { addToken ( start , zzStartRead - _NUM , Token . LITERAL _ BACKQUOTE ) ; return firstToken ; } case _NUM _NUM _NUM : break ; case YYINITIAL : { addNullToken ( ) ; return firstToken ; } case _NUM _NUM _NUM : break ; case HEREDOC _ EOF _ UNQUOTED : { addToken ( start , zzStartRead - _NUM , Token . PREPROCESSOR ) ; addEndToken ( INTERNAL _ HEREDOC _ EOF _ UNQUOTED ) ; return firstToken ; } case _NUM _NUM _NUM : break ; case STRING _ Q _ CURLY _ BRACE : { addToken ( start , zzStartRead - _NUM , Token . LITERAL _ STRING _ DOUBLE _ QUOTE ) ; addEndToken ( INTERNAL _ STRING _ Q _ CURLY _ BRACE ) ; return firstToken ; } case _NUM _NUM _NUM : break ; case STRING _ Q _ PAREN : { addToken ( start , zzStartRead - _NUM , Token . LITERAL _ STRING _ DOUBLE _ QUOTE ) ; addEndToken ( INTERNAL _ STRING _ Q _ PAREN ) ; return firstToken ; } case _NUM _NUM _NUM : break ; case CHAR _ LITERAL : { addToken ( start , zzStartRead - _NUM , Token . LITERAL _ CHAR ) ; return firstToken ; } case _NUM _NUM _NUM : break ; case STRING _ Q _ SQUARE _ BRACKET : { addToken ( start , zzStartRead - _NUM , Token . LITERAL _ STRING _ DOUBLE _ QUOTE ) ; addEndToken ( INTERNAL _ STRING _ Q _ SQUARE _ BRACKET ) ; return firstToken ; } case _NUM _NUM _NUM : break ; default : return null ; } } else { zzScanError ( ZZ _ NO _ MATCH ) ; } } } } 
5961	public < T extends Appender > T getRequiredAppender ( final String name , final Class < T > cls ) { final T appender = getAppender ( name , cls ) ; assertNotNull ( _STR + loggerContext , appender ) ; return appender ; } 
5962	private ResourcesImpl findOrCreateResourcesImplForKeyLocked ( @ NonNull ResourcesKey key ) { ResourcesImpl impl = findResourcesImplForKeyLocked ( key ) ; if ( impl = = null ) { impl = createResourcesImpl ( key ) ; if ( impl ! = null ) { mResourceImpls . put ( key , new WeakReference < > ( impl ) ) ; } } return impl ; } 
5963	public static XmlID parse ( java . io . InputStream is , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( XmlID ) XmlBeans . getContextTypeLoader ( ) . parse ( is , type , options ) ; } 
5964	private void updateCurrentPacket ( boolean lastPacket ) throws IOException { Early return for the most common case . if ( mCurrentPacket ! = null & & mCurrentPacket . writableBytes ( ) > _NUM & & ! lastPacket ) { return ; } if ( mCurrentPacket = = null ) { if ( ! lastPacket ) { mCurrentPacket = allocateBuffer ( ) ; } return ; } if ( mCurrentPacket . writableBytes ( ) = = _NUM | | lastPacket ) { try { if ( mCurrentPacket . readableBytes ( ) > _NUM ) { for ( PacketWriter packetWriter : mPacketWriters ) { mCurrentPacket . retain ( ) ; packetWriter . writePacket ( mCurrentPacket . duplicate ( ) ) ; } } else { Preconditions . checkState ( lastPacket ) ; } } finally { If the packet has bytes to read , we increment its refcount explicitly for every packet writer . So we need to release here . If the packet has no bytes to read , then it has to be the last packet . It needs to be released as well . mCurrentPacket . release ( ) ; mCurrentPacket = null ; } } if ( ! lastPacket ) { mCurrentPacket = allocateBuffer ( ) ; } } 
5965	public static HtmlLayout createLayout ( @ PluginAttribute ( value = _STR + charset ; } return new HtmlLayout ( locationInfo , title , contentType , charset , font , fontSize , headerSize ) ; } 
5966	public void setCustomName ( String name ) { m _ visual . setText ( name ) ; } 
5967	public static Map < String , Object > sendNotification ( DispatchContext ctx , Map < String , ? extends Object > context ) { LocalDispatcher dispatcher = ctx . getDispatcher ( ) ; Locale locale = ( Locale ) context . get ( _STR , locale ) ) ; } return result ; } 
5968	public boolean getBoolean ( String key ) throws JSONException { Object o = get ( key ) ; if ( o . equals ( Boolean . FALSE ) | | ( o instanceof String & & ( ( String ) o ) . equalsIgnoreCase ( _STR ) ; } 
5969	public void realTimeReorder ( int empty , int target ) { completePendingPageChanges ( ) ; int delay = _NUM ; float delayAmount = START _ VIEW _ REORDER _ DELAY ; Animation only happens on the current page . int pageToAnimate = getNextPage ( ) ; int pageT = target / mMaxItemsPerPage ; int pagePosT = target % mMaxItemsPerPage ; if ( pageT ! = pageToAnimate ) { Log . e ( TAG , _STR ) ; } int pagePosE = empty % mMaxItemsPerPage ; int pageE = empty / mMaxItemsPerPage ; int startPos , endPos ; int moveStart , moveEnd ; int direction ; if ( target = = empty ) { No animation return ; } else if ( target > empty ) { Items will move backwards to make room for the empty cell . direction = _NUM ; If empty cell is in a different page , move them instantly . if ( pageE < pageToAnimate ) { moveStart = empty ; Instantly move the first item in the current page . moveEnd = pageToAnimate * mMaxItemsPerPage ; Animate the _NUM nd item in the current page , as the first item was already moved to the last page . startPos = _NUM ; } else { moveStart = moveEnd = - _NUM ; startPos = pagePosE ; } endPos = pagePosT ; } else { The items will move forward . direction = - _NUM ; if ( pageE > pageToAnimate ) { Move the items immediately . moveStart = empty ; Instantly move the last item in the current page . moveEnd = ( pageToAnimate + _NUM ) * mMaxItemsPerPage - _NUM ; Animations start with the second last item in the page startPos = mMaxItemsPerPage - _NUM ; } else { moveStart = moveEnd = - _NUM ; startPos = pagePosE ; } endPos = pagePosT ; } Instant moving views . while ( moveStart ! = moveEnd ) { int rankToMove = moveStart + direction ; int p = rankToMove / mMaxItemsPerPage ; int pagePos = rankToMove % mMaxItemsPerPage ; int x = pagePos % mGridCountX ; int y = pagePos / mGridCountX ; final CellLayout page = getPageAt ( p ) ; final View v = page . getChildAt ( x , y ) ; if ( v ! = null ) { if ( pageToAnimate ! = p ) { page . removeView ( v ) ; addViewForRank ( v , ( ShortcutInfo ) v . getTag ( ) , moveStart ) ; } else { Do a fake animation before removing it . final int newRank = moveStart ; final float oldTranslateX = v . getTranslationX ( ) ; Runnable endAction = new Runnable ( ) { @ Override public void run ( ) { mPendingAnimations . remove ( v ) ; v . setTranslationX ( oldTranslateX ) ; ( ( CellLayout ) v . getParent ( ) . getParent ( ) ) . removeView ( v ) ; addViewForRank ( v , ( ShortcutInfo ) v . getTag ( ) , newRank ) ; } } ; v . animate ( ) . translationXBy ( ( direction > _NUM ^ mIsRtl ) ? - v . getWidth ( ) : v . getWidth ( ) ) . setDuration ( REORDER _ ANIMATION _ DURATION ) . setStartDelay ( _NUM ) . withEndAction ( endAction ) ; mPendingAnimations . put ( v , endAction ) ; } } moveStart = rankToMove ; } if ( ( endPos - startPos ) * direction < = _NUM ) { No animation return ; } CellLayout page = getPageAt ( pageToAnimate ) ; for ( int i = startPos ; i ! = endPos ; i + = direction ) { int nextPos = i + direction ; View v = page . getChildAt ( nextPos % mGridCountX , nextPos / mGridCountX ) ; if ( v ! = null ) { ( ( ItemInfo ) v . getTag ( ) ) . rank - = direction ; } if ( page . animateChildToPosition ( v , i % mGridCountX , i / mGridCountX , REORDER _ ANIMATION _ DURATION , delay , true , true ) ) { delay + = delayAmount ; delayAmount * = VIEW _ REORDER _ DELAY _ FACTOR ; } } } 
5970	public void setCheckMarkTintMode ( @ Nullable PorterDuff . Mode tintMode ) { mCheckMarkTintMode = tintMode ; mHasCheckMarkTintMode = true ; applyCheckMarkTint ( ) ; } 
5971	public IStreamView copy ( UUID source , UUID destination , long timestamp ) { boolean written = false ; while ( ! written ) { TokenResponse tokenResponse = runtime . getSequencerView ( ) . nextToken ( Collections . singleton ( destination ) , _NUM ) ; if ( tokenResponse . getBackpointerMap ( ) . get ( destination ) ! = null & & Address . isAddress ( tokenResponse . getBackpointerMap ( ) . get ( destination ) ) ) { Reading from this address will cause a hole fill runtime . getAddressSpaceView ( ) . read ( tokenResponse . getTokenValue ( ) ) ; throw new RuntimeException ( _STR ) ; } catch ( StaleTokenException se ) { simply loop } } return get ( destination ) ; } 
5972	public void setDimAmount ( float amount ) { final WindowManager . LayoutParams attrs = getAttributes ( ) ; attrs . dimAmount = amount ; mHaveDimAmount = true ; dispatchWindowAttributesChanged ( attrs ) ; } 
5973	public static < T > int firstIndex ( Iterator < T > iter , Predicate < T > filter ) { for ( int idx = _NUM ; iter . hasNext ( ) ; idx + + ) { T t = iter . next ( ) ; if ( filter . test ( t ) ) return idx ; } return - _NUM ; } 
5974	private String treeToString ( ) { StringBuffer text = new StringBuffer ( ) ; if ( m _ topOfTree = = null ) { return _STR + m _ topOfTree . numberOfLinearModels ( ) ) ; return text . toString ( ) ; } 
5975	private boolean updateCurrentVrServiceLocked ( boolean enabled , boolean running _NUM dInVr , @ NonNull ComponentName component , int userId , int processId , ComponentName calling ) { boolean sendUpdatedCaller = false ; final long identity = Binder . clearCallingIdentity ( ) ; try { boolean validUserComponent = ( mComponentObserver . isValid ( component , userId ) = = EnabledComponentsObserver . NO _ ERROR ) ; boolean goingIntoVrMode = validUserComponent & & enabled ; if ( ! mVrModeEnabled & & ! goingIntoVrMode ) { Disabled - > Disabled transition does nothing . return validUserComponent ; } String oldVrServicePackage = mCurrentVrService ! = null ? mCurrentVrService . getComponent ( ) . getPackageName ( ) : null ; final int oldUserId = mCurrentVrModeUser ; Notify system services and VR HAL of mode change . changeVrModeLocked ( goingIntoVrMode ) ; boolean nothingChanged = false ; if ( ! goingIntoVrMode ) { Not going into VR mode , unbind whatever is running if ( mCurrentVrService ! = null ) { Slog . i ( TAG , _STR + mCurrentVrService . getUserId ( ) ) ; updateCompositorServiceLocked ( UserHandle . USER _ NULL , null ) ; createAndConnectService ( component , userId ) ; sendUpdatedCaller = true ; } else { nothingChanged = true ; } The service with the correct component / user is already bound , do nothing . } else { Nothing was previously running , bind a new service for the latest component / user selection . createAndConnectService ( component , userId ) ; sendUpdatedCaller = true ; } } if ( ( calling ! = null | | mPersistentVrModeEnabled ) & & ! Objects . equals ( calling , mCurrentVrModeComponent ) | | mRunning _NUM dInVr ! = running _NUM dInVr ) { sendUpdatedCaller = true ; } mCurrentVrModeComponent = calling ; mRunning _NUM dInVr = running _NUM dInVr ; mVrAppProcessId = processId ; if ( mCurrentVrModeUser ! = userId ) { mCurrentVrModeUser = userId ; sendUpdatedCaller = true ; } String newVrServicePackage = mCurrentVrService ! = null ? mCurrentVrService . getComponent ( ) . getPackageName ( ) : null ; final int newUserId = mCurrentVrModeUser ; Update AppOps settings that change state when entering / exiting VR mode , or changing the current VrListenerService . updateDependentAppOpsLocked ( newVrServicePackage , newUserId , oldVrServicePackage , oldUserId ) ; if ( mCurrentVrService ! = null & & sendUpdatedCaller ) { final ComponentName c = mCurrentVrModeComponent ; final boolean b = running _NUM dInVr ; final int pid = processId ; mCurrentVrService . sendEvent ( new PendingEvent ( ) { @ Override public void runEvent ( IInterface service ) throws RemoteException { IVrListener l = ( IVrListener ) service ; l . focusedActivityChanged ( c , b , pid ) ; } } ) ; } if ( ! nothingChanged ) { logStateLocked ( ) ; } return validUserComponent ; } finally { Binder . restoreCallingIdentity ( identity ) ; } } 
5976	public static List < Element > getDescriptorElements ( InputStream xmlDescriptorIn ) throws IOException { List < Element > elements = new ArrayList < > ( ) ; org . w _NUM c . dom . Document xmlDescriptorDOM = createDOM ( xmlDescriptorIn ) ; XPath xPath = XPathFactory . newInstance ( ) . newXPath ( ) ; NodeList allElements ; try { XPathExpression exp = xPath . compile ( _STR ) ; } for ( int i = _NUM ; i < allElements . getLength ( ) ; i + + ) { if ( allElements . item ( i ) instanceof Element ) { Element customElement = ( Element ) allElements . item ( i ) ; elements . add ( customElement ) ; } } return elements ; } 
5977	private void checkAllRequiredAttributes ( ) { if ( ! showValidationStatus ) { this . validationStatus . setText ( _STR ) ; this . validationStatus . setImage ( null ) ; } } } } 
5978	private void addHyperlinkToken ( int start , int end , int tokenType ) { int so = start + offsetShift ; addToken ( zzBuffer , start , end , tokenType , so , true ) ; } 
5979	public static CmsXmlPage convertToXmlPage ( CmsObject cms , byte [ ] content , Locale locale , String encoding ) throws CmsImportExportException , CmsXmlException { CmsXmlPage xmlPage = null ; Document page = CmsXmlUtils . unmarshalHelper ( content , null ) ; Element xmltemplate = page . getRootElement ( ) ; if ( ( xmltemplate = = null ) | | ! _STR . equals ( n . getName ( ) ) ) { contentBuffer . append ( OpenCms . getSystemInfo ( ) . getOpenCmsContext ( ) ) ; contentBuffer . append ( n . getText ( ) ) ; continue ; } } } bodyContent = contentBuffer . toString ( ) ; } if ( bodyContent = = null ) { throw new CmsImportExportException ( Messages . get ( ) . container ( Messages . ERR _ BODY _ CONTENT _ NOT _ FOUND _ _NUM ) ) ; } bodyContent = CmsStringUtil . substitute ( bodyContent , CmsStringUtil . MACRO _ OPENCMS _ CONTEXT , OpenCms . getSystemInfo ( ) . getOpenCmsContext ( ) ) ; if ( CmsStringUtil . isNotEmptyOrWhitespaceOnly ( bodyContent ) ) { xmlPage . addValue ( bodyName , locale ) ; xmlPage . setStringValue ( cms , bodyName , locale , bodyContent ) ; } } return xmlPage ; } 
5980	public void testPowerLocalMP _NUM Playback ( ) throws Exception { audioPlayback ( MP _NUM _ POWERTEST ) ; } 
5981	private int getThumbOffset ( ) { final float thumbPosition ; if ( ViewUtils . isLayoutRtl ( this ) ) { thumbPosition = _NUM - mThumbPosition ; } else { thumbPosition = mThumbPosition ; } return ( int ) ( thumbPosition * getThumbScrollRange ( ) + _NUM . _NUM f ) ; } 
5982	public void submit ( FileInputStream fileInputStream , FileInputStream propertiesFile , boolean envFilter ) throws Exception { EcoTopologyDefinition topologyDefinition = ecoParser . parseFromInputStream ( fileInputStream , propertiesFile , envFilter ) ; String topologyName = topologyDefinition . getName ( ) ; String topologyType = topologyDefinition . getType ( ) ; if ( _STR , topologyType , topologyName ) ) ; } } 
5983	void basicWithSomeCodec ( String codec , boolean useTags ) throws IOException { if ( useTags ) { conf . setInt ( _STR , Arrays . equals ( getSomeKey ( _NUM _NUM ) , Bytes . toBytes ( readKey ) ) ) ; scanner . seekTo ( KeyValueUtil . createKeyValueFromKey ( getSomeKey ( _NUM ) ) ) ; ByteBuffer val _NUM = scanner . getValue ( ) ; scanner . seekTo ( KeyValueUtil . createKeyValueFromKey ( getSomeKey ( _NUM ) ) ) ; ByteBuffer val _NUM = scanner . getValue ( ) ; assertTrue ( Arrays . equals ( Bytes . toBytes ( val _NUM ) , Bytes . toBytes ( val _NUM ) ) ) ; reader . close ( ) ; fin . close ( ) ; fs . delete ( ncHFile , true ) ; } 
5984	public EndpointResponse withChannelType ( ChannelType channelType ) { this . channelType = channelType . toString ( ) ; return this ; } 
5985	public TypeMirror getActualType ( Element element , DeclaredType enclosingClassType , GeneratedClassHolder holder ) { Types types = environment . getProcessingEnvironment ( ) . getTypeUtils ( ) ; TypeMirror annotatedClass = holder . getAnnotatedElement ( ) . asType ( ) ; Map < String , TypeMirror > actualTypes = getActualTypes ( types , enclosingClassType , annotatedClass ) ; TypeMirror type = actualTypes . get ( element . asType ( ) . toString ( ) ) ; return type = = null ? element . asType ( ) : type ; } 
5986	public void writeString ( char [ ] buffer , int offset , int length ) throws IOException { if ( buffer = = null ) { os . write ( ' N ' ) ; } else { while ( length > _NUM x _NUM _NUM _NUM _NUM ) { int sublen = _NUM x _NUM _NUM _NUM _NUM ; chunk can ' t end in high surrogate char tail = buffer [ offset + sublen - _NUM ] ; if ( _NUM xd _NUM _NUM _NUM < = tail & & tail < = _NUM xdbff ) sublen - - ; os . write ( ' s ' ) ; os . write ( sublen > > _NUM ) ; os . write ( sublen ) ; printString ( buffer , offset , sublen ) ; length - = sublen ; offset + = sublen ; } os . write ( ' S ' ) ; os . write ( length > > _NUM ) ; os . write ( length ) ; printString ( buffer , offset , length ) ; } } 
5987	public static String getUnmangledMethodName ( Class declaringClass , String methodName , Class [ ] paramTypes ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( declaringClass . getName ( ) ) ; sb . append ( _STR ) ; return sb . toString ( ) ; } 
5988	public static boolean startsWith ( final String string , final String sub ) { final int sl = string . length ( ) , tl = sub . length ( ) ; if ( tl > sl ) return false ; for ( int t = _NUM ; t < tl ; t + + ) { if ( ! equals ( string . charAt ( t ) , sub . charAt ( t ) ) ) return false ; } return true ; } 
5989	public static ValueEval getSingleValue ( ValueEval arg , int srcCellRow , int srcCellCol ) throws EvaluationException { final ValueEval result ; if ( arg instanceof RefEval ) { result = chooseSingleElementFromRef ( ( RefEval ) arg ) ; } else if ( arg instanceof AreaEval ) { result = chooseSingleElementFromArea ( ( AreaEval ) arg , srcCellRow , srcCellCol ) ; } else { result = arg ; } if ( result instanceof ErrorEval ) { throw new EvaluationException ( ( ErrorEval ) result ) ; } return result ; } 
5990	protected Object writeReplace ( ) { return new GenericMessage < > ( getIdentifier ( ) , getPayload ( ) , getMetaData ( ) ) ; } 
5991	public int getLengthInFrames ( ) { best guess . . . return getLengthInVideoFrames ( ) ; } 
5992	public void testFailedVolumeBeingRemovedFromDataNode ( ) throws InterruptedException , IOException , TimeoutException { The test uses DataNodeTestUtils # injectDataDirFailure ( ) to simulate volume failures which is currently not supported on Windows . assumeTrue ( ! Path . WINDOWS ) ; Path file _NUM = new Path ( _STR ) ; assertEquals ( _NUM , dataDirStrs . length ) ; assertFalse ( dataDirStrs [ _NUM ] . contains ( dn _NUM Vol _NUM . getAbsolutePath ( ) ) ) ; } 
5993	public void testRenameToExistingSnapshot ( ) throws Exception { DFSTestUtil . createFile ( hdfs , file _NUM , BLOCKSIZE , REPLICATION , seed ) ; Create snapshots for sub _NUM SnapshotTestHelper . createSnapshot ( hdfs , sub _NUM , _STR ) ; } 
5994	public void start ( ) { if ( ! queue . isPresent ( ) ) { initQueue ( ) ; } queue . ifPresent ( actualQueue - > actualQueue . startListener ( EventBusQueueAdapter . this : : sendToEventManager ) ) ; } 
5995	public void setTitle ( String value ) { setAttribute ( ATTR _ TITLE , value ) ; } 
5996	private void handleMotionEventStateTouchExploring ( MotionEvent event , MotionEvent rawEvent , int policyFlags ) { ReceivedPointerTracker receivedTracker = mReceivedPointerTracker ; switch ( event . getActionMasked ( ) ) { case MotionEvent . ACTION _ DOWN : { mAms . onTouchInteractionStart ( ) ; sendAccessibilityEvent ( AccessibilityEvent . TYPE _ TOUCH _ INTERACTION _ START ) ; If we still have not notified the user for the last touch , we figure out what to do . If were waiting we resent the delayed callback and wait again . mSendHoverEnterAndMoveDelayed . cancel ( ) ; mSendHoverExitDelayed . cancel ( ) ; if ( mSendTouchExplorationEndDelayed . isPending ( ) ) { mSendTouchExplorationEndDelayed . forceSendAndRemove ( ) ; } if ( mSendTouchInteractionEndDelayed . isPending ( ) ) { mSendTouchInteractionEndDelayed . forceSendAndRemove ( ) ; } if ( ! mGestureDetector . firstTapDetected ( ) & & ! mTouchExplorationInProgress ) { if ( ! mSendHoverEnterAndMoveDelayed . isPending ( ) ) { Deliver hover enter with a delay to have a chance to detect what the user is trying to do . final int pointerId = receivedTracker . getPrimaryPointerId ( ) ; final int pointerIdBits = ( _NUM < < pointerId ) ; mSendHoverEnterAndMoveDelayed . post ( event , true , pointerIdBits , policyFlags ) ; } else { Cache the event until we discern exploration from gesturing . mSendHoverEnterAndMoveDelayed . addEvent ( event ) ; } } } break ; case MotionEvent . ACTION _ POINTER _ DOWN : { Another finger down means that if we have not started to deliver hover events , we will not have to . The code for ACTION _ MOVE will decide what we will actually do next . mSendHoverEnterAndMoveDelayed . cancel ( ) ; mSendHoverExitDelayed . cancel ( ) ; } break ; case MotionEvent . ACTION _ MOVE : { final int pointerId = receivedTracker . getPrimaryPointerId ( ) ; final int pointerIndex = event . findPointerIndex ( pointerId ) ; final int pointerIdBits = ( _NUM < < pointerId ) ; switch ( event . getPointerCount ( ) ) { case _NUM : { figure out what the user is doing . if ( mSendHoverEnterAndMoveDelayed . isPending ( ) ) { Cache the event until we discern exploration from gesturing . mSendHoverEnterAndMoveDelayed . addEvent ( event ) ; } else { if ( mTouchExplorationInProgress ) { sendTouchExplorationGestureStartAndHoverEnterIfNeeded ( policyFlags ) ; sendMotionEvent ( event , MotionEvent . ACTION _ HOVER _ MOVE , pointerIdBits , policyFlags ) ; } } } break ; case _NUM : { and now we have to decide whether to delegate or drag . if ( mSendHoverEnterAndMoveDelayed . isPending ( ) ) { We have not started sending events so cancel scheduled sending events . mSendHoverEnterAndMoveDelayed . cancel ( ) ; mSendHoverExitDelayed . cancel ( ) ; } else { if ( mTouchExplorationInProgress ) { If the user is touch exploring the second pointer may be performing a double tap to activate an item without need for the user to lift his exploring finger . It is * important * to use the distance traveled by the pointers on the screen which may or may not be magnified . final float deltaX = receivedTracker . getReceivedPointerDownX ( pointerId ) - rawEvent . getX ( pointerIndex ) ; final float deltaY = receivedTracker . getReceivedPointerDownY ( pointerId ) - rawEvent . getY ( pointerIndex ) ; final double moveDelta = Math . hypot ( deltaX , deltaY ) ; if ( moveDelta < mDoubleTapSlop ) { break ; } We are sending events so send exit and gesture end since we transition to another state . sendHoverExitAndTouchExplorationGestureEndIfNeeded ( policyFlags ) ; } } if ( isDraggingGesture ( event ) ) { Two pointers moving in the same direction within a given distance perform a drag . mCurrentState = STATE _ DRAGGING ; mDraggingPointerId = pointerId ; event . setEdgeFlags ( receivedTracker . getLastReceivedDownEdgeFlags ( ) ) ; sendMotionEvent ( event , MotionEvent . ACTION _ DOWN , pointerIdBits , policyFlags ) ; } else { Two pointers moving arbitrary are delegated to the view hierarchy . mCurrentState = STATE _ DELEGATING ; sendDownForAllNotInjectedPointers ( event , policyFlags ) ; } } break ; default : { and now we have to decide whether to delegate or drag . if ( mSendHoverEnterAndMoveDelayed . isPending ( ) ) { We have not started sending events so cancel scheduled sending events . mSendHoverEnterAndMoveDelayed . cancel ( ) ; mSendHoverExitDelayed . cancel ( ) ; } else { We are sending events so send exit and gesture end since we transition to another state . sendHoverExitAndTouchExplorationGestureEndIfNeeded ( policyFlags ) ; } More than two pointers are delegated to the view hierarchy . mCurrentState = STATE _ DELEGATING ; sendDownForAllNotInjectedPointers ( event , policyFlags ) ; } } } break ; case MotionEvent . ACTION _ UP : { mAms . onTouchInteractionEnd ( ) ; final int pointerId = event . getPointerId ( event . getActionIndex ( ) ) ; final int pointerIdBits = ( _NUM < < pointerId ) ; if ( mSendHoverEnterAndMoveDelayed . isPending ( ) ) { If we have not delivered the enter schedule an exit . mSendHoverExitDelayed . post ( event , pointerIdBits , policyFlags ) ; } else { The user is touch exploring so we send events for end . sendHoverExitAndTouchExplorationGestureEndIfNeeded ( policyFlags ) ; } if ( ! mSendTouchInteractionEndDelayed . isPending ( ) ) { mSendTouchInteractionEndDelayed . post ( ) ; } } break ; } } 
5997	public void putAll ( Map < ? extends Long , ? extends Double > map ) { Iterator < ? extends Entry < ? extends Long , ? extends Double > > it = map . entrySet ( ) . iterator ( ) ; for ( int i = map . size ( ) ; i - - > _NUM ; ) { Entry < ? extends Long , ? extends Double > e = it . next ( ) ; this . put ( e . getKey ( ) , e . getValue ( ) ) ; } } 
5998	public void onSuccessfulLogin ( Subject subject , AuthenticationToken token , AuthenticationInfo info ) { always clear any previous identity : forgetIdentity ( subject ) ; now save the new identity : if ( isRememberMe ( token ) ) { rememberIdentity ( subject , token , info ) ; } else { if ( log . isDebugEnabled ( ) ) { log . debug ( _STR ) ; } } } 
5999	public void killAll ( ) { Do backups first . MasterThread activeMaster = null ; for ( MasterThread masterThread : getMasterThreads ( ) ) { if ( ! masterThread . getMaster ( ) . isActiveMaster ( ) ) { masterThread . getMaster ( ) . abort ( _STR ) ; } } 
6000	public void initData ( TrueTypeFont ttf , TTFDataStream data ) throws IOException { platformId = data . readUnsignedShort ( ) ; platformEncodingId = data . readUnsignedShort ( ) ; languageId = data . readUnsignedShort ( ) ; nameId = data . readUnsignedShort ( ) ; stringLength = data . readUnsignedShort ( ) ; stringOffset = data . readUnsignedShort ( ) ; } 
6001	public int removeByField ( IndexDefinition < T > indexDefinition , Object value ) { Set < T > toRemove = getByField ( indexDefinition , value ) ; int removed = _NUM ; for ( T o : toRemove ) { if ( remove ( o ) ) { removed + + ; } } return removed ; } 
6002	public int getBulletAutoNumberStart ( ) { ParagraphPropertyFetcher < Integer > fetcher = new ParagraphPropertyFetcher < Integer > ( getLevel ( ) ) { public boolean fetch ( CTTextParagraphProperties props ) { if ( props . isSetBuAutoNum ( ) & & props . getBuAutoNum ( ) . isSetStartAt ( ) ) { setValue ( props . getBuAutoNum ( ) . getStartAt ( ) ) ; return true ; } return false ; } } ; fetchParagraphProperty ( fetcher ) ; return fetcher . getValue ( ) = = null ? _NUM : fetcher . getValue ( ) ; } 
6003	 $ ANTLR start _STR , _NUM _NUM _NUM , _NUM , input ) ; throw nvae ; } switch ( alt _NUM _NUM _NUM ) { case _NUM : JPA _NUM . g : _NUM _NUM _NUM : _NUM : WORD { root _ _NUM = ( Object ) adaptor . nil ( ) ; WORD _NUM _NUM _NUM = ( Token ) match ( input , WORD , FOLLOW _ WORD _ in _ field _NUM _NUM _NUM _NUM ) ; if ( state . failed ) return retval ; if ( state . backtracking = = _NUM ) { WORD _NUM _NUM _NUM _ tree = ( Object ) adaptor . create ( WORD _NUM _NUM _NUM ) ; adaptor . addChild ( root _ _NUM , WORD _NUM _NUM _NUM _ tree ) ; } } break ; case _NUM : JPA _NUM . g : _NUM _NUM _NUM : _NUM _NUM : ' SELECT ' { root _ _NUM = ( Object ) adaptor . nil ( ) ; string _ literal _NUM _NUM _NUM = ( Token ) match ( input , _NUM _NUM _NUM , FOLLOW _ _NUM _NUM _NUM _ in _ field _NUM _NUM _NUM _NUM ) ; if ( state . failed ) return retval ; if ( state . backtracking = = _NUM ) { string _ literal _NUM _NUM _NUM _ tree = ( Object ) adaptor . create ( string _ literal _NUM _NUM _NUM ) ; adaptor . addChild ( root _ _NUM , string _ literal _NUM _NUM _NUM _ tree ) ; } } break ; case _NUM : JPA _NUM . g : _NUM _NUM _NUM : _NUM _NUM : ' FROM ' { root _ _NUM = ( Object ) adaptor . nil ( ) ; string _ literal _NUM _NUM _NUM = ( Token ) match ( input , _NUM _NUM _NUM , FOLLOW _ _NUM _NUM _NUM _ in _ field _NUM _NUM _NUM _NUM ) ; if ( state . failed ) return retval ; if ( state . backtracking = = _NUM ) { string _ literal _NUM _NUM _NUM _ tree = ( Object ) adaptor . create ( string _ literal _NUM _NUM _NUM ) ; adaptor . addChild ( root _ _NUM , string _ literal _NUM _NUM _NUM _ tree ) ; } } break ; case _NUM : JPA _NUM . g : _NUM _NUM _NUM : _NUM _NUM : ' GROUP ' { root _ _NUM = ( Object ) adaptor . nil ( ) ; string _ literal _NUM _NUM _NUM = ( Token ) match ( input , GROUP , FOLLOW _ GROUP _ in _ field _NUM _NUM _NUM _NUM ) ; if ( state . failed ) return retval ; if ( state . backtracking = = _NUM ) { string _ literal _NUM _NUM _NUM _ tree = ( Object ) adaptor . create ( string _ literal _NUM _NUM _NUM ) ; adaptor . addChild ( root _ _NUM , string _ literal _NUM _NUM _NUM _ tree ) ; } } break ; case _NUM : JPA _NUM . g : _NUM _NUM _NUM : _NUM _NUM : ' ORDER ' { root _ _NUM = ( Object ) adaptor . nil ( ) ; string _ literal _NUM _NUM _NUM = ( Token ) match ( input , ORDER , FOLLOW _ ORDER _ in _ field _NUM _NUM _NUM _NUM ) ; if ( state . failed ) return retval ; if ( state . backtracking = = _NUM ) { string _ literal _NUM _NUM _NUM _ tree = ( Object ) adaptor . create ( string _ literal _NUM _NUM _NUM ) ; adaptor . addChild ( root _ _NUM , string _ literal _NUM _NUM _NUM _ tree ) ; } } break ; case _NUM : JPA _NUM . g : _NUM _NUM _NUM : _NUM _NUM : ' MAX ' { root _ _NUM = ( Object ) adaptor . nil ( ) ; string _ literal _NUM _NUM _NUM = ( Token ) match ( input , MAX , FOLLOW _ MAX _ in _ field _NUM _NUM _NUM _NUM ) ; if ( state . failed ) return retval ; if ( state . backtracking = = _NUM ) { string _ literal _NUM _NUM _NUM _ tree = ( Object ) adaptor . create ( string _ literal _NUM _NUM _NUM ) ; adaptor . addChild ( root _ _NUM , string _ literal _NUM _NUM _NUM _ tree ) ; } } break ; case _NUM : JPA _NUM . g : _NUM _NUM _NUM : _NUM _NUM : ' MIN ' { root _ _NUM = ( Object ) adaptor . nil ( ) ; string _ literal _NUM _NUM _NUM = ( Token ) match ( input , MIN , FOLLOW _ MIN _ in _ field _NUM _NUM _NUM _NUM ) ; if ( state . failed ) return retval ; if ( state . backtracking = = _NUM ) { string _ literal _NUM _NUM _NUM _ tree = ( Object ) adaptor . create ( string _ literal _NUM _NUM _NUM ) ; adaptor . addChild ( root _ _NUM , string _ literal _NUM _NUM _NUM _ tree ) ; } } break ; case _NUM : JPA _NUM . g : _NUM _NUM _NUM : _NUM _NUM : ' SUM ' { root _ _NUM = ( Object ) adaptor . nil ( ) ; string _ literal _NUM _NUM _NUM = ( Token ) match ( input , SUM , FOLLOW _ SUM _ in _ field _NUM _NUM _NUM _NUM ) ; if ( state . failed ) return retval ; if ( state . backtracking = = _NUM ) { string _ literal _NUM _NUM _NUM _ tree = ( Object ) adaptor . create ( string _ literal _NUM _NUM _NUM ) ; adaptor . addChild ( root _ _NUM , string _ literal _NUM _NUM _NUM _ tree ) ; } } break ; case _NUM : JPA _NUM . g : _NUM _NUM _NUM : _NUM _NUM : ' AVG ' { root _ _NUM = ( Object ) adaptor . nil ( ) ; string _ literal _NUM _NUM _NUM = ( Token ) match ( input , AVG , FOLLOW _ AVG _ in _ field _NUM _NUM _NUM _NUM ) ; if ( state . failed ) return retval ; if ( state . backtracking = = _NUM ) { string _ literal _NUM _NUM _NUM _ tree = ( Object ) adaptor . create ( string _ literal _NUM _NUM _NUM ) ; adaptor . addChild ( root _ _NUM , string _ literal _NUM _NUM _NUM _ tree ) ; } } break ; case _NUM _NUM : JPA _NUM . g : _NUM _NUM _NUM : _NUM _NUM : ' COUNT ' { root _ _NUM = ( Object ) adaptor . nil ( ) ; string _ literal _NUM _NUM _NUM = ( Token ) match ( input , COUNT , FOLLOW _ COUNT _ in _ field _NUM _NUM _NUM _NUM ) ; if ( state . failed ) return retval ; if ( state . backtracking = = _NUM ) { string _ literal _NUM _NUM _NUM _ tree = ( Object ) adaptor . create ( string _ literal _NUM _NUM _NUM ) ; adaptor . addChild ( root _ _NUM , string _ literal _NUM _NUM _NUM _ tree ) ; } } break ; case _NUM _NUM : JPA _NUM . g : _NUM _NUM _NUM : _NUM _NUM : ' AS ' { root _ _NUM = ( Object ) adaptor . nil ( ) ; string _ literal _NUM _NUM _NUM = ( Token ) match ( input , AS , FOLLOW _ AS _ in _ field _NUM _NUM _NUM _NUM ) ; if ( state . failed ) return retval ; if ( state . backtracking = = _NUM ) { string _ literal _NUM _NUM _NUM _ tree = ( Object ) adaptor . create ( string _ literal _NUM _NUM _NUM ) ; adaptor . addChild ( root _ _NUM , string _ literal _NUM _NUM _NUM _ tree ) ; } } break ; case _NUM _NUM : JPA _NUM . g : _NUM _NUM _NUM : _NUM _NUM _NUM : ' MEMBER ' { root _ _NUM = ( Object ) adaptor . nil ( ) ; string _ literal _NUM _NUM _NUM = ( Token ) match ( input , _NUM _NUM _NUM , FOLLOW _ _NUM _NUM _NUM _ in _ field _NUM _NUM _NUM _NUM ) ; if ( state . failed ) return retval ; if ( state . backtracking = = _NUM ) { string _ literal _NUM _NUM _NUM _ tree = ( Object ) adaptor . create ( string _ literal _NUM _NUM _NUM ) ; adaptor . addChild ( root _ _NUM , string _ literal _NUM _NUM _NUM _ tree ) ; } } break ; case _NUM _NUM : JPA _NUM . g : _NUM _NUM _NUM : _NUM _NUM _NUM : ' CASE ' { root _ _NUM = ( Object ) adaptor . nil ( ) ; string _ literal _NUM _NUM _NUM = ( Token ) match ( input , CASE , FOLLOW _ CASE _ in _ field _NUM _NUM _NUM _NUM ) ; if ( state . failed ) return retval ; if ( state . backtracking = = _NUM ) { string _ literal _NUM _NUM _NUM _ tree = ( Object ) adaptor . create ( string _ literal _NUM _NUM _NUM ) ; adaptor . addChild ( root _ _NUM , string _ literal _NUM _NUM _NUM _ tree ) ; } } break ; case _NUM _NUM : JPA _NUM . g : _NUM _NUM _NUM : _NUM : ' OBJECT ' { root _ _NUM = ( Object ) adaptor . nil ( ) ; string _ literal _NUM _NUM _NUM = ( Token ) match ( input , _NUM _NUM _NUM , FOLLOW _ _NUM _NUM _NUM _ in _ field _NUM _NUM _NUM _NUM ) ; if ( state . failed ) return retval ; if ( state . backtracking = = _NUM ) { string _ literal _NUM _NUM _NUM _ tree = ( Object ) adaptor . create ( string _ literal _NUM _NUM _NUM ) ; adaptor . addChild ( root _ _NUM , string _ literal _NUM _NUM _NUM _ tree ) ; } } break ; case _NUM _NUM : JPA _NUM . g : _NUM _NUM _NUM : _NUM _NUM : date _ part { root _ _NUM = ( Object ) adaptor . nil ( ) ; pushFollow ( FOLLOW _ date _ part _ in _ field _NUM _NUM _NUM _NUM ) ; date _ part _NUM _NUM _NUM = date _ part ( ) ; state . _ fsp - - ; if ( state . failed ) return retval ; if ( state . backtracking = = _NUM ) adaptor . addChild ( root _ _NUM , date _ part _NUM _NUM _NUM . getTree ( ) ) ; } break ; } retval . stop = input . LT ( - _NUM ) ; if ( state . backtracking = = _NUM ) { retval . tree = ( Object ) adaptor . rulePostProcessing ( root _ _NUM ) ; adaptor . setTokenBoundaries ( retval . tree , retval . start , retval . stop ) ; } } catch ( RecognitionException re ) { reportError ( re ) ; recover ( input , re ) ; retval . tree = ( Object ) adaptor . errorNode ( input , retval . start , input . LT ( - _NUM ) , re ) ; } finally { do for sure before leaving } return retval ; } 
6004	public List < CmsProject > readProjectsForGroup ( CmsDbContext dbc , CmsGroup group ) throws CmsDataAccessException { List < CmsProject > projects = new ArrayList < CmsProject > ( ) ; try { create the statement Query q = m _ sqlManager . createQuery ( dbc , C _ PROJECTS _ READ _ BYGROUP _ _NUM ) ; q . setParameter ( _NUM , group . getId ( ) . toString ( ) ) ; q . setParameter ( _NUM , group . getId ( ) . toString ( ) ) ; @ SuppressWarnings ( _STR ) List < CmsDAOProjects > res = q . getResultList ( ) ; for ( CmsDAOProjects p : res ) { projects . add ( internalCreateProject ( p ) ) ; } } catch ( PersistenceException e ) { throw new CmsDataAccessException ( Messages . get ( ) . container ( Messages . ERR _ JPA _ PERSITENCE , e ) , e ) ; } return ( projects ) ; } 
6005	public < T > void put ( String key , Set < T > set ) { final PrimitiveList pl = new PrimitiveList ( ) ; pl . addAll ( set ) ; this . put ( key , pl ) ; } 
6006	private void fromString ( String str ) { Tokenizer toke = new Tokenizer ( str ) ; str = toke . nextToken ( ) ; m _ dateChanged = Long . parseLong ( str ) ; str = toke . nextToken ( ) ; if ( _STR . equals ( str ) ) { m _ structureId = null ; } else { m _ structureId = str ; } } 
6007	public final void dispatchRemoveFinished ( ViewHolder item ) { onRemoveFinished ( item ) ; dispatchAnimationFinished ( item ) ; } 
6008	protected void expectErrorCode ( WebRequest request , int errorCode , String errorText ) throws MalformedURLException , IOException , SAXException { String failureText = _STR ) ; } catch ( HttpException e ) { assertEquals ( failureText , errorCode , e . getResponseCode ( ) ) ; } } 
6009	protected void onFocusLost ( ) { resetPressedState ( ) ; } 
6010	void onAddToDatabase ( Context context , ContentValues values ) { writeToValues ( values ) ; long serialNumber = UserManagerCompat . getInstance ( context ) . getSerialNumberForUser ( user ) ; values . put ( LauncherSettings . Favorites . PROFILE _ ID , serialNumber ) ; if ( screenId = = Workspace . EXTRA _ EMPTY _ SCREEN _ ID ) { We should never persist an item on the extra empty screen . throw new RuntimeException ( _STR ) ; } } 
6011	public void stopNattKeepalive ( ) { synchronized ( mKeepaliveCallback ) { if ( mKeepalive = = null ) { Log . e ( TAG , _STR ) ; return ; } mKeepalive . stop ( ) ; } } 
6012	public static String getPluginsDirectoryName ( ) { if ( ! RuntimeUtil . isWindows ( ) ) { return _STR ; } } 
6013	public List < DatanodeStorageReport > init ( ) throws IOException { final DatanodeStorageReport [ ] reports = nnc . getLiveDatanodeStorageReport ( ) ; final List < DatanodeStorageReport > trimmed = new ArrayList < DatanodeStorageReport > ( ) ; over - utilized , above - average , below - average and under - utilized . for ( DatanodeStorageReport r : DFSUtil . shuffle ( reports ) ) { final DatanodeInfo datanode = r . getDatanodeInfo ( ) ; if ( shouldIgnore ( datanode ) ) { continue ; } trimmed . add ( r ) ; cluster . add ( datanode ) ; } return trimmed ; } 
6014	public Set < Map . Entry < Short , Integer > > entrySet ( ) { return new AbstractSet < Map . Entry < Short , Integer > > ( ) { public int size ( ) { return _ map . size ( ) ; } public boolean isEmpty ( ) { return TShortIntMapDecorator . this . isEmpty ( ) ; } public boolean contains ( Object o ) { if ( o instanceof Map . Entry ) { Object k = ( ( Map . Entry ) o ) . getKey ( ) ; Object v = ( ( Map . Entry ) o ) . getValue ( ) ; return TShortIntMapDecorator . this . containsKey ( k ) & & TShortIntMapDecorator . this . get ( k ) . equals ( v ) ; } else { return false ; } } public Iterator < Map . Entry < Short , Integer > > iterator ( ) { return new Iterator < Map . Entry < Short , Integer > > ( ) { private final TShortIntIterator it = _ map . iterator ( ) ; public Map . Entry < Short , Integer > next ( ) { it . advance ( ) ; short ik = it . key ( ) ; final Short key = ( ik = = _ map . getNoEntryKey ( ) ) ? null : wrapKey ( ik ) ; int iv = it . value ( ) ; final Integer v = ( iv = = _ map . getNoEntryValue ( ) ) ? null : wrapValue ( iv ) ; return new Map . Entry < Short , Integer > ( ) { private Integer val = v ; public boolean equals ( Object o ) { return o instanceof Map . Entry & & ( ( Map . Entry ) o ) . getKey ( ) . equals ( key ) & & ( ( Map . Entry ) o ) . getValue ( ) . equals ( val ) ; } public Short getKey ( ) { return key ; } public Integer getValue ( ) { return val ; } public int hashCode ( ) { return key . hashCode ( ) + val . hashCode ( ) ; } public Integer setValue ( Integer value ) { val = value ; return put ( key , value ) ; } } ; } public boolean hasNext ( ) { return it . hasNext ( ) ; } public void remove ( ) { it . remove ( ) ; } } ; } public boolean add ( Map . Entry < Short , Integer > o ) { throw new UnsupportedOperationException ( ) ; } public boolean remove ( Object o ) { boolean modified = false ; if ( contains ( o ) ) { noinspection unchecked Short key = ( ( Map . Entry < Short , Integer > ) o ) . getKey ( ) ; _ map . remove ( unwrapKey ( key ) ) ; modified = true ; } return modified ; } public boolean addAll ( Collection < ? extends Map . Entry < Short , Integer > > c ) { throw new UnsupportedOperationException ( ) ; } public void clear ( ) { TShortIntMapDecorator . this . clear ( ) ; } } ; } 
6015	public static < T > void structuralValueConsistentWithEquals ( Coder < T > coder , T value _NUM , T value _NUM ) throws Exception { for ( Coder . Context context : ALL _ CONTEXTS ) { CoderProperties . structuralValueConsistentWithEqualsInContext ( coder , context , value _NUM , value _NUM ) ; } } 
6016	protected void addToSelectList ( List < SqlNode > list , Set < String > aliases , List < Map . Entry < String , RelDataType > > fieldList , SqlNode exp , SqlValidatorScope scope , final boolean includeSystemVars ) { String alias = SqlValidatorUtil . getAlias ( exp , - _NUM ) ; String uniqueAlias = SqlValidatorUtil . uniquify ( alias , aliases , SqlValidatorUtil . EXPR _ SUGGESTER ) ; if ( ! alias . equals ( uniqueAlias ) ) { exp = SqlValidatorUtil . addAlias ( exp , uniqueAlias ) ; } fieldList . add ( Pair . of ( uniqueAlias , deriveType ( scope , exp ) ) ) ; list . add ( exp ) ; } 
6017	protected String resolveName ( Locale locale ) { return getName ( ) . key ( locale ) ; } 
6018	public void fakeDragBy ( float xOffset ) { if ( ! mFakeDragging ) { throw new IllegalStateException ( _STR ) ; } mLastMotionX + = xOffset ; float oldScrollX = getScrollX ( ) ; float scrollX = oldScrollX - xOffset ; final int width = getClientWidth ( ) ; float leftBound = width * mFirstOffset ; float rightBound = width * mLastOffset ; final ItemInfo firstItem = mItems . get ( _NUM ) ; final ItemInfo lastItem = mItems . get ( mItems . size ( ) - _NUM ) ; if ( firstItem . position ! = _NUM ) { leftBound = firstItem . offset * width ; } if ( lastItem . position ! = mAdapter . getCount ( ) - _NUM ) { rightBound = lastItem . offset * width ; } if ( scrollX < leftBound ) { scrollX = leftBound ; } else if ( scrollX > rightBound ) { scrollX = rightBound ; } Don ' t lose the rounded component mLastMotionX + = scrollX - ( int ) scrollX ; scrollTo ( ( int ) scrollX , getScrollY ( ) ) ; pageScrolled ( ( int ) scrollX ) ; Synthesize an event for the VelocityTracker . final long time = SystemClock . uptimeMillis ( ) ; final MotionEvent ev = MotionEvent . obtain ( mFakeDragBeginTime , time , MotionEvent . ACTION _ MOVE , mLastMotionX , _NUM , _NUM ) ; mVelocityTracker . addMovement ( ev ) ; ev . recycle ( ) ; } 
6019	public static PubsubTopic fromPath ( String path ) { if ( path . equals ( TOPIC _ DEV _ NULL _ TEST _ NAME ) ) { return new PubsubTopic ( Type . FAKE , _STR + path ) ; } projectName = match . group ( _NUM ) ; topicName = match . group ( _NUM ) ; } validateProjectName ( projectName ) ; validatePubsubName ( topicName ) ; return new PubsubTopic ( Type . NORMAL , projectName , topicName ) ; } 
6020	BTrace exit built - in functionstatic void exit ( int exitCode ) { BTraceRuntime runtime = getCurrent ( ) ; if ( runtime ! = null ) { Throwable th = runtime . currentException . get ( ) ; if ( ! ( th instanceof ExitException ) ) { runtime . currentException . set ( null ) ; } throw new ExitException ( exitCode ) ; } } 
6021	public static XmlLong parse ( java . net . URL u , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( XmlLong ) XmlBeans . getContextTypeLoader ( ) . parse ( u , type , options ) ; } 
6022	private void cancelFling ( ) { final MotionEvent cancelFling = MotionEvent . obtain ( _NUM , _NUM , MotionEvent . ACTION _ CANCEL , _NUM , _NUM , _NUM ) ; mList . onTouchEvent ( cancelFling ) ; cancelFling . recycle ( ) ; } 
6023	public boolean hasListeners ( ) { return listeners ! = null & & listeners . size ( ) > _NUM ; } 
6024	public static Iterator < String > symbolNameIterator ( final Iterator < SymbolToken > tokenIter ) { return new Iterator < String > ( ) { public boolean hasNext ( ) { return tokenIter . hasNext ( ) ; } public String next ( ) { return tokenIter . next ( ) . getText ( ) ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } 
6025	protected GroupPrivilegeResponse getResponse ( PrivilegeEntity privilegeEntity , String groupName ) { String permissionLabel = privilegeEntity . getPermission ( ) . getPermissionLabel ( ) ; String permissionName = privilegeEntity . getPermission ( ) . getPermissionName ( ) ; String principalTypeName = privilegeEntity . getPrincipal ( ) . getPrincipalType ( ) . getName ( ) ; GroupPrivilegeResponse groupPrivilegeResponse = new GroupPrivilegeResponse ( groupName , permissionLabel , permissionName , privilegeEntity . getId ( ) , PrincipalTypeEntity . PrincipalType . valueOf ( principalTypeName ) ) ; if ( principalTypeName . equals ( PrincipalTypeEntity . GROUP _ PRINCIPAL _ TYPE _ NAME ) ) { final GroupEntity groupEntity = groupDAO . findGroupByPrincipal ( privilegeEntity . getPrincipal ( ) ) ; groupPrivilegeResponse . setPrincipalName ( groupEntity . getGroupName ( ) ) ; } String typeName = privilegeEntity . getResource ( ) . getResourceType ( ) . getName ( ) ; ResourceType resourceType = ResourceType . translate ( typeName ) ; if ( resourceType ! = null ) { switch ( resourceType ) { case AMBARI : there is nothing special to add for this case break ; case CLUSTER : final ClusterEntity clusterEntity = clusterDAO . findByResourceId ( privilegeEntity . getResource ( ) . getId ( ) ) ; groupPrivilegeResponse . setClusterName ( clusterEntity . getClusterName ( ) ) ; break ; case VIEW : final ViewInstanceEntity viewInstanceEntity = viewInstanceDAO . findByResourceId ( privilegeEntity . getResource ( ) . getId ( ) ) ; final ViewEntity viewEntity = viewInstanceEntity . getViewEntity ( ) ; groupPrivilegeResponse . setViewName ( viewEntity . getCommonName ( ) ) ; groupPrivilegeResponse . setVersion ( viewEntity . getVersion ( ) ) ; groupPrivilegeResponse . setInstanceName ( viewInstanceEntity . getName ( ) ) ; break ; } groupPrivilegeResponse . setType ( resourceType ) ; } return groupPrivilegeResponse ; } 
6026	public ApplicationContext loadContext ( ConfigurableApplicationContext context , Class < ? > testClass ) throws Exception { AnnotationConfigUtils . registerAnnotationConfigProcessors ( ( BeanDefinitionRegistry ) context ) ; Post CamelContext ( s ) instantiation but pre CamelContext ( s ) start setup CamelAnnotationsHandler . handleRouteCoverage ( context , testClass , s - > getTestMethod ( ) . getName ( ) ) ; CamelAnnotationsHandler . handleProvidesBreakpoint ( context , testClass ) ; CamelAnnotationsHandler . handleShutdownTimeout ( context , testClass ) ; CamelAnnotationsHandler . handleMockEndpoints ( context , testClass ) ; CamelAnnotationsHandler . handleMockEndpointsAndSkip ( context , testClass ) ; CamelAnnotationsHandler . handleUseOverridePropertiesWithPropertiesComponent ( context , testClass ) ; CamelContext ( s ) startup CamelAnnotationsHandler . handleCamelContextStartup ( context , testClass ) ; return context ; } 
6027	copyvoid mutate ( ) { flip a bit do { int iBit ; do { iBit = m _ random . nextInt ( m _ nNodes * m _ nNodes ) ; } while ( isSquare ( iBit ) ) ; m _ bits [ iBit ] = ! m _ bits [ iBit ] ; } while ( hasCycles ( ) ) ; calcScore ( ) ; } 
6028	private void bindServerSocket ( InetAddress inetAddr ) throws IOException { while ( true ) { int port = HBaseTestingUtility . randomFreePort ( ) ; InetSocketAddress addr = new InetSocketAddress ( inetAddr , port ) ; ServerSocket serverSocket = null ; try { serverSocket = new ServerSocket ( ) ; serverSocket . bind ( addr ) ; break ; } catch ( BindException ex ) { continue LOG . info ( _STR + inetAddr , ex ) ; } finally { if ( serverSocket ! = null ) { serverSocket . close ( ) ; } } } } 
6029	protected int getPropertyIntValue ( final int id ) throws NoSingleSectionException { return getFirstSection ( ) . getPropertyIntValue ( id ) ; } 
6030	public JSONObject toJSONObject ( JSONArray names ) throws JSONException { if ( ( names = = null ) | | ( names . length ( ) = = _NUM ) | | ( length ( ) = = _NUM ) ) { return null ; } JSONObject jo = new JSONObject ( ) ; for ( int i = _NUM ; i < names . length ( ) ; i + = _NUM ) { jo . put ( names . getString ( i ) , this . opt ( i ) ) ; } return jo ; } 
6031	public void inPlaceXor ( DocIdSetIterator disi ) throws IOException { int doc ; long size = size ( ) ; while ( ( doc = disi . nextDoc ( ) ) < size ) { fastFlip ( doc ) ; } } 
6032	public SDVariable maxPooling _NUM d ( SDVariable [ ] inputs , Pooling _NUM DConfig pooling _NUM DConfig ) { MaxPooling _NUM D maxPooling _NUM D = MaxPooling _NUM D . builder ( ) . inputs ( inputs ) . sameDiff ( sameDiff ( ) ) . config ( pooling _NUM DConfig ) . build ( ) ; return maxPooling _NUM D . outputVariables ( ) [ _NUM ] ; } 
6033	public < T > T decodeAsNative ( String encodedAs , Class < T > clz , Element headerElement , Unmarshaller unmarshaller ) throws JAXBException { T ret = null ; if ( LOG . isLoggable ( Level . FINE ) ) { LOG . fine ( _STR + clz . getName ( ) ) ; } if ( NATIVE _ VERSION . equals ( encodedAs ) ) { ret = codec . decodeMAP ( clz , headerElement , unmarshaller ) ; } else if ( Names _NUM _NUM _NUM _NUM _NUM _NUM . WSA _ NAMESPACE _ NAME . equals ( encodedAs ) ) { if ( AttributedURIType . class . equals ( clz ) ) { ret = clz . cast ( convert ( codec . decodeMAP ( AttributedURI . class , headerElement , unmarshaller ) ) ) ; } else if ( EndpointReferenceType . class . equals ( clz ) ) { ret = clz . cast ( convert ( codec . decodeMAP ( Names _NUM _NUM _NUM _NUM _NUM _NUM . EPR _ TYPE , headerElement , unmarshaller ) ) ) ; } else if ( RelatesToType . class . equals ( clz ) ) { ret = clz . cast ( convert ( codec . decodeMAP ( Relationship . class , headerElement , unmarshaller ) ) ) ; } } else if ( org . apache . cxf . ws . addressing . VersionTransformer . Names _NUM _NUM _NUM _NUM _NUM _NUM . WSA _ NAMESPACE _ NAME . equals ( encodedAs ) ) { if ( AttributedURIType . class . equals ( clz ) ) { ret = clz . cast ( convert ( codec . decodeMAP ( org . apache . cxf . ws . addressing . v _NUM _NUM _NUM _NUM _NUM _NUM . AttributedURI . class , headerElement , unmarshaller ) ) ) ; } else if ( EndpointReferenceType . class . equals ( clz ) ) { ret = clz . cast ( convert ( codec . decodeMAP ( Names _NUM _NUM _NUM _NUM _NUM _NUM . EPR _ TYPE , headerElement , unmarshaller ) ) ) ; } else if ( RelatesToType . class . equals ( clz ) ) { ret = clz . cast ( convert ( codec . decodeMAP ( org . apache . cxf . ws . addressing . v _NUM _NUM _NUM _NUM _NUM _NUM . Relationship . class , headerElement , unmarshaller ) ) ) ; } } return ret ; } 
6034	public void testBuildParentVersionRangeLocallyWithoutChildVersion ( ) throws Exception { File f _NUM = getTestFile ( _STR ) ) ; } } 
6035	public void cleanUpViewState ( View child ) { if ( child = = mTranslatingParentView ) { mTranslatingParentView = null ; } mCurrentStackScrollState . removeViewStateForView ( child ) ; } 
6036	public CStringBuilder append ( String str ) { append _NUM ( str ) ; return this ; } 
6037	private PubMedIdSearchHandler getPubMedIds ( final String query , final int requestedResults ) throws Exception { final XMLReader reader = newXmlReader ( ) ; PubMedIdSearchHandler searchHandler = new PubMedIdSearchHandler ( ) ; reader . setContentHandler ( searchHandler ) ; final String url = E _ SEARCH _ URL + _STR ) ) ; } return searchHandler ; } 
6038	private void resendRequestsWhenNeeded ( Predicate < RequestInfo > shouldResendRequestPredicate ) { Check if there are open requests which have been sent a long time ago , and if so , resend them . List < ClientRequestId > addedRequestIds = Lists . newArrayList ( ) ; List < RequestInfo > addedRequestInfos = Lists . newArrayList ( ) ; Check all the requests for problems for ( Map . Entry < ClientRequestId , RequestInfo > entry : clientRequestIdRequestInfoMap . entrySet ( ) ) { RequestInfo requestInfo = entry . getValue ( ) ; If request should be resent if ( shouldResendRequestPredicate . apply ( requestInfo ) ) { ChannelFuture writeFuture = requestInfo . getWriteFuture ( ) ; String logMessage ; if ( writeFuture = = null ) { logMessage = _STR + requestInfo ) ; } writeRequestToChannel ( requestInfo ) ; } addedRequestIds . clear ( ) ; addedRequestInfos . clear ( ) ; } 
6039	public boolean moveFilter ( int filterId , int refId , int parentId ) { Connection conn = null ; PreparedStatement pstm = null ; JSTree refNode = this . getNodeById ( refId ) ; JSTree parentNode = this . getNodeById ( parentId ) ; try { if ( refId = = parentId ) return true ; conn = DbPoolConnection . getInstance ( ) . getConnection ( ) ; String oldFiltersStr = parentNode . getFilters ( ) ; String newFiltersStr = refNode . getFilters ( ) ; å…ˆ åŠ  å…¥ æ–° çš„ æ–‡ ä»¶ å¤¹ if ( newFiltersStr ! = null & & ! _STR ; pstm = conn . prepareStatement ( updateNewFiltersSql ) ; pstm . setString ( _NUM , newFiltersStr ) ; pstm . setInt ( _NUM , refId ) ; pstm . execute ( ) ; pstm = conn . prepareStatement ( updateOldFiltersSql ) ; pstm . setString ( _NUM , oldFiltersStr ) ; pstm . setInt ( _NUM , parentId ) ; if ( pstm . executeUpdate ( ) > _NUM ) { return true ; } else { return false ; } } catch ( Exception e ) { e . printStackTrace ( ) ; return false ; } finally { DbPoolConnection . getInstance ( ) . closeAll ( pstm , conn ) ; } } 
6040	public void startExperiment ( ) { List < MapNode > markers = map . getOsmMap ( ) . getMarkers ( ) ; if ( markers . size ( ) < _NUM ) { taskPaneCtrl . setStatus ( _STR ) ; taskPaneCtrl . setStatus ( search . getMetrics ( ) . toString ( ) ) ; } } 
6041	public void setLabelLinkStyle ( PieLabelLinkStyle style ) { if ( style = = null ) { throw new IllegalArgumentException ( _STR ) ; } this . labelLinkStyle = style ; fireChangeEvent ( ) ; } 
6042	private static File getCabalFile ( JpsModule module ) { String pathname = getContentRootPath ( module ) ; noinspection ConstantConditions for ( File file : new File ( pathname ) . listFiles ( ) ) { if ( file . getName ( ) . endsWith ( _STR ) ) { return file ; } } return null ; } 
6043	public Map < String , User > getUsers ( LDAPConnection ldapConnection ) throws GuacamoleException { Build map of users by querying each username attribute separately Map < String , User > users = new HashMap < String , User > ( ) ; for ( String usernameAttribute : confService . getUsernameAttributes ( ) ) { Attempt to pull all users with given attribute try { putAllUsers ( users , ldapConnection , usernameAttribute ) ; } Log any errors non - fatally catch ( GuacamoleException e ) { logger . warn ( _STR , e ) ; } } Return map of all users return users ; } 
6044	public void setActionClass ( String value ) { checkFrozen ( ) ; if ( CmsStringUtil . isEmpty ( value ) ) { m _ actionClass = null ; } else { if ( ! CmsStringUtil . isValidJavaClassName ( value ) ) { throw new CmsIllegalArgumentException ( Messages . get ( ) . container ( Messages . ERR _ MODULE _ ACTION _ CLASS _ _NUM , value , getName ( ) ) ) ; } m _ actionClass = value ; } } 
6045	public SelectResult withItems ( Item . . . items ) { if ( getItems ( ) = = null ) setItems ( new java . util . ArrayList < Item > ( items . length ) ) ; for ( Item value : items ) { getItems ( ) . add ( value ) ; } return this ; } 
6046	private Record getCoreRecordForSAS ( SlideAtomsSet sas ) { SlidePersistAtom spa = sas . getSlidePersistAtom ( ) ; int refID = spa . getRefID ( ) ; return getCoreRecordForRefID ( refID ) ; } 
6047	private int classifyTag ( ) { try { char ch = document . getChar ( cNextPos + + ) ; cNewLines = _NUM ; processing instruction ? if ( ' ? ' = = ch ) { boolean piFlag = false ; while ( cNextPos < fRangeEnd ) { ch = document . getChar ( cNextPos + + ) ; if ( ( ' > ' = = ch ) & & piFlag ) return PI _ TAG ; piFlag = ( ' ? ' = = ch ) ; } return EOR _ TAG ; } comment ? if ( ' ! ' = = ch ) { must be ' - ' but we don ' t care if not cNextPos + + ; must be ' - ' but we don ' t care if not cNextPos + + ; int commEnd = _NUM ; while ( cNextPos < fRangeEnd ) { ch = document . getChar ( cNextPos + + ) ; if ( ( ' > ' = = ch ) & & ( commEnd > = _NUM ) ) return COMMENT _ TAG ; if ( ( ' \ n ' = = ch ) | | ( ' \ r ' = = ch ) ) { if ( ( ch = = cLastNLChar ) | | ( ' ' = = cLastNLChar ) ) { cNewLines + + ; cLastNLChar = ch ; } } if ( ' - ' = = ch ) { commEnd + + ; } else { commEnd = _NUM ; } } return EOR _ TAG ; } consume whitespaces while ( ( ' ' = = ch ) | | ( ' \ t ' = = ch ) | | ( ' \ n ' = = ch ) | | ( ' \ r ' = = ch ) ) { ch = document . getChar ( cNextPos + + ) ; if ( cNextPos > fRangeEnd ) return EOR _ TAG ; } end tag ? if ( ' / ' = = ch ) { while ( cNextPos < fRangeEnd ) { ch = document . getChar ( cNextPos + + ) ; if ( ' > ' = = ch ) { cNewLines + = eatToEndOfLine ( ) ; return END _ TAG ; } if ( ' _STR ' = = ch ) break s ; } return EOR _ TAG ; case ' \ ' ' : while ( cNextPos < fRangeEnd ) { ch = document . getChar ( cNextPos + + ) ; if ( ' \ ' ' = = ch ) break s ; } return EOR _ TAG ; case ' > ' : cNewLines + = eatToEndOfLine ( ) ; return START _ TAG ; default : break ; } } return EOR _ TAG ; } catch ( BadLocationException e ) { should not happen , but we treat it as end of range return EOR _ TAG ; } } 
6048	public Object get ( String key ) throws InterpreterException { synchronized ( this ) { rRequestObject = new Request ( _STR , key , null ) ; return request ( ) ; } } 
6049	public void testGetAvailablePermits ( ) throws InterruptedException { final ScheduledExecutorService service = EasyMock . createMock ( ScheduledExecutorService . class ) ; final ScheduledFuture < ? > future = EasyMock . createMock ( ScheduledFuture . class ) ; prepareStartTimer ( service , future ) ; EasyMock . replay ( service , future ) ; final TimedSemaphore semaphore = new TimedSemaphore ( service , PERIOD , UNIT , LIMIT ) ; for ( int i = _NUM ; i < LIMIT ; i + + ) { assertEquals ( _STR , LIMIT , semaphore . getAvailablePermits ( ) ) ; EasyMock . verify ( service , future ) ; } 
6050	void addToTab ( String tabName , String key , @ Nullable Object value , boolean notify ) { Map < String , Object > tab = getTab ( tabName ) ; if ( value ! = null ) { tab . put ( key , value ) ; } else { tab . remove ( key ) ; } notifyBugsnagObservers ( NotifyType . META ) ; } 
6051	public MTSReleaseStatement release ( ) throws SQLSyntaxErrorException { match ( KW _ RELEASE ) ; matchIdentifier ( _STR ) ; Identifier id = identifier ( ) ; match ( EOF ) ; return new MTSReleaseStatement ( id ) ; } 
6052	private void updateXmlContents ( I _ CmsReport report , String resourcePath , boolean inclSubFolder , CmsObject cmsObject ) { write parameters to report report . println ( Messages . get ( ) . container ( Messages . RPT _ UPDATEXML _ BEGIN _ UPDATE _ _NUM ) , I _ CmsReport . FORMAT _ NOTE ) ; report . println ( Messages . get ( ) . container ( Messages . RPT _ UPDATEXML _ PARAMETERS _ _NUM ) , I _ CmsReport . FORMAT _ HEADLINE ) ; report . println ( Messages . get ( ) . container ( Messages . RPT _ UPDATEXML _ PARAMETERS _ RESOURCE _ PATH _ _NUM , resourcePath ) , I _ CmsReport . FORMAT _ NOTE ) ; report . println ( Messages . get ( ) . container ( Messages . RPT _ UPDATEXML _ PARAMETERS _ INC _ SUBFOLDERS _ _NUM , new Boolean ( inclSubFolder ) . toString ( ) ) , I _ CmsReport . FORMAT _ NOTE ) ; check for valid parameters ( vfs folder ) if ( CmsStringUtil . isEmpty ( resourcePath ) ) { report . println ( Messages . get ( ) . container ( Messages . RPT _ UPDATEXML _ NO _ VFS _ FOLDER _ _NUM ) , I _ CmsReport . FORMAT _ ERROR ) ; return ; } read all files in the vfs folder report . println ( Messages . get ( ) . container ( Messages . RPT _ UPDATEXML _ START _ SEARCHING _ _NUM ) , I _ CmsReport . FORMAT _ HEADLINE ) ; List < CmsResource > allFiles = null ; try { allFiles = cmsObject . readResources ( resourcePath , CmsResourceFilter . DEFAULT , inclSubFolder ) ; } catch ( CmsException e ) { m _ errorUpdate + = _NUM ; report . println ( Messages . get ( ) . container ( Messages . RPT _ UPDATEXML _ SEARCH _ ERROR _ _NUM ) , I _ CmsReport . FORMAT _ ERROR ) ; if ( LOG . isErrorEnabled ( ) ) { LOG . error ( e . getMessageContainer ( ) , e ) ; } report . println ( Messages . get ( ) . container ( Messages . RPT _ UPDATEXML _ END _ UPDATE _ _NUM ) , I _ CmsReport . FORMAT _ NOTE ) ; return ; } get the files to update List < CmsResource > files _NUM Update = new ArrayList < CmsResource > ( ) ; Iterator < CmsResource > iter = allFiles . iterator ( ) ; while ( iter . hasNext ( ) ) { CmsResource cmsResource = iter . next ( ) ; only update Xml contents if ( cmsResource . isFile ( ) & & ( CmsResourceTypeXmlContent . isXmlContent ( cmsResource ) | | CmsResourceTypeXmlPage . isXmlPage ( cmsResource ) ) ) { files _NUM Update . add ( cmsResource ) ; } } number of files to update int nrOfFiles = files _NUM Update . size ( ) ; report . println ( Messages . get ( ) . container ( Messages . RPT _ UPDATEXML _ FILES _ TO _ UPDATE _ _NUM , new Integer ( nrOfFiles ) . toString ( ) ) , I _ CmsReport . FORMAT _ NOTE ) ; the file counter int fileCounter = _NUM ; update the files if ( nrOfFiles > _NUM ) { report entry report . println ( Messages . get ( ) . container ( Messages . RPT _ UPDATEXML _ START _ UPDATING _ _NUM ) , I _ CmsReport . FORMAT _ HEADLINE ) ; loop over all files iter = files _NUM Update . iterator ( ) ; while ( iter . hasNext ( ) ) { CmsResource cmsResource = iter . next ( ) ; fileCounter + = _NUM ; report entries report . print ( org . opencms . report . Messages . get ( ) . container ( org . opencms . report . Messages . RPT _ SUCCESSION _ _NUM , String . valueOf ( fileCounter ) , String . valueOf ( nrOfFiles ) ) , I _ CmsReport . FORMAT _ NOTE ) ; report . print ( Messages . get ( ) . container ( Messages . RPT _ UPDATEXML _ CURRENT _ FILE _ _NUM ) , I _ CmsReport . FORMAT _ NOTE ) ; report . print ( org . opencms . report . Messages . get ( ) . container ( org . opencms . report . Messages . RPT _ ARGUMENT _ _NUM , report . removeSiteRoot ( cmsResource . getRootPath ( ) ) ) ) ; report . print ( org . opencms . report . Messages . get ( ) . container ( org . opencms . report . Messages . RPT _ DOTS _ _NUM ) , I _ CmsReport . FORMAT _ DEFAULT ) ; get current lock from file try { try to lock the resource if ( ! lockResource ( cmsObject , cmsResource , report ) ) { report . println ( Messages . get ( ) . container ( Messages . RPT _ UPDATEXML _ LOCKED _ FILE _ _NUM , cmsObject . getSitePath ( cmsResource ) ) , I _ CmsReport . FORMAT _ ERROR ) ; continue ; } } catch ( CmsException e ) { report . println ( Messages . get ( ) . container ( Messages . RPT _ UPDATEXML _ LOCKED _ FILE _ _NUM , cmsObject . getSitePath ( cmsResource ) ) , I _ CmsReport . FORMAT _ ERROR ) ; if ( LOG . isErrorEnabled ( ) ) { LOG . error ( e . getMessageContainer ( ) , e ) ; } continue ; } write the resource try { do not change the date last modified long lastModified = cmsResource . getDateLastModified ( ) ; CmsFile cmsFile = cmsObject . readFile ( cmsResource ) ; cmsFile . setDateLastModified ( lastModified ) ; cmsObject . writeFile ( cmsFile ) ; } catch ( Exception e ) { m _ errorUpdate + = _NUM ; report . println ( org . opencms . report . Messages . get ( ) . container ( org . opencms . report . Messages . RPT _ FAILED _ _NUM ) , I _ CmsReport . FORMAT _ ERROR ) ; if ( LOG . isErrorEnabled ( ) ) { LOG . error ( e . toString ( ) ) ; } continue ; } unlock the resource try { cmsObject . unlockResource ( cmsObject . getSitePath ( cmsResource ) ) ; } catch ( CmsException e ) { m _ errorUpdate + = _NUM ; report . println ( Messages . get ( ) . container ( Messages . RPT _ UPDATEXML _ UNLOCK _ FILE _ _NUM ) , I _ CmsReport . FORMAT _ WARNING ) ; if ( LOG . isErrorEnabled ( ) ) { LOG . error ( e . getMessageContainer ( ) , e ) ; } continue ; } successfully updated report . println ( org . opencms . report . Messages . get ( ) . container ( org . opencms . report . Messages . RPT _ OK _ _NUM ) , I _ CmsReport . FORMAT _ OK ) ; } } else { no files to update report . println ( Messages . get ( ) . container ( Messages . RPT _ UPDATEXML _ NO _ FILES _ FOUND _ _NUM ) , I _ CmsReport . FORMAT _ NOTE ) ; } the results are written in the report report . println ( Messages . get ( ) . container ( Messages . RPT _ UPDATEXML _ RESULT _ _NUM ) , I _ CmsReport . FORMAT _ HEADLINE ) ; report . println ( Messages . get ( ) . container ( Messages . RPT _ UPDATEXML _ FILES _ TO _ UPDATE _ _NUM , new Integer ( nrOfFiles ) . toString ( ) ) , I _ CmsReport . FORMAT _ NOTE ) ; report . println ( Messages . get ( ) . container ( Messages . RPT _ UPDATEXML _ UPDATE _ NUMBER _ ERRORS _ _NUM , new Integer ( m _ errorUpdate ) . toString ( ) ) , I _ CmsReport . FORMAT _ NOTE ) ; report . println ( Messages . get ( ) . container ( Messages . RPT _ UPDATEXML _ LOCKED _ FILES _ _NUM , new Integer ( m _ lockedFiles ) . toString ( ) ) , I _ CmsReport . FORMAT _ NOTE ) ; if ( m _ lockedFiles > _NUM ) { report . println ( Messages . get ( ) . container ( Messages . RPT _ UPDATEXML _ UPDATE _ FAILED _ _NUM ) , I _ CmsReport . FORMAT _ ERROR ) ; } else { report . println ( Messages . get ( ) . container ( Messages . RPT _ UPDATEXML _ UPDATE _ SUCCESS _ _NUM ) , I _ CmsReport . FORMAT _ OK ) ; } report . println ( Messages . get ( ) . container ( Messages . RPT _ UPDATEXML _ END _ UPDATE _ _NUM ) , I _ CmsReport . FORMAT _ NOTE ) ; } 
6053	public XYItemRenderer getRendererForDataset ( XYDataset dataset ) { XYItemRenderer result = null ; for ( int i = _NUM ; i < this . datasets . size ( ) ; i + + ) { if ( this . datasets . get ( i ) = = dataset ) { result = ( XYItemRenderer ) this . renderers . get ( i ) ; if ( result = = null ) { result = getRenderer ( ) ; } break ; } } return result ; } 
6054	private Eval slidingEval ( final Eval sub ) { return new WindowEval ( ) { private final ArrayDeque < Item > queue = new ArrayDeque < > ( ) ; @ Override public boolean next ( final QueryContext qc ) throws QueryException { while ( true ) { Item curr , next = null ; while ( ( curr = advance ( ) ) ! = null ) { next = queue . peekFirst ( ) ; if ( next = = null & & ( next = next ( ) ) ! = null ) queue . addLast ( next ) ; if ( start . matches ( qc , curr , pos , prev , next ) ) break ; prev = curr ; } if ( curr ! = null ) { final ValueBuilder vb = new ValueBuilder ( qc ) ; final Iterator < Item > iter = queue . iterator ( ) ; the first element is already the { @ code next } one if ( iter . hasNext ( ) ) iter . next ( ) ; Item pr = prev , it = curr , nx = next ; long ps = pos ; do { vb . add ( it ) ; if ( end . matches ( qc , it , ps + + , pr , nx ) ) break ; pr = it ; it = nx ; if ( iter . hasNext ( ) ) { nx = iter . next ( ) ; } else { nx = next ( ) ; if ( nx ! = null ) queue . addLast ( nx ) ; } } while ( it ! = null ) ; return window if end was found or { @ code only } isn ' t set if ( ! ( it = = null & & only ) ) { start . bind ( qc , curr , pos , prev , next ) ; prev = curr ; qc . set ( var , vb . value ( ) ) ; return true ; } } abort if no more tuples from above if ( ! prepareNext ( qc , sub ) ) return false ; queue . clear ( ) ; } } private Item advance ( ) throws QueryException { Item item = queue . pollFirst ( ) ; if ( item = = null ) item = next ( ) ; if ( item ! = null ) pos + + ; return item ; } } ; } 
6055	 @ SuppressWarnings ( _STR ) ) ; if ( ifMatchList . size ( ) > _NUM & & ! isMatchingEtag ( ifMatchList , etag ) ) { sendPreconditionFailed ( resp ) ; return true ; } return false ; } 
6056	protected void onDestroy ( ) { if ( DEBUG _ LIFECYCLE ) Slog . v ( TAG , _STR + this ) ; mCalled = true ; dismiss any dialogs we are managing . if ( mManagedDialogs ! = null ) { final int numDialogs = mManagedDialogs . size ( ) ; for ( int i = _NUM ; i < numDialogs ; i + + ) { final ManagedDialog md = mManagedDialogs . valueAt ( i ) ; if ( md . mDialog . isShowing ( ) ) { md . mDialog . dismiss ( ) ; } } mManagedDialogs = null ; } close any cursors we are managing . synchronized ( mManagedCursors ) { int numCursors = mManagedCursors . size ( ) ; for ( int i = _NUM ; i < numCursors ; i + + ) { ManagedCursor c = mManagedCursors . get ( i ) ; if ( c ! = null ) { c . mCursor . close ( ) ; } } mManagedCursors . clear ( ) ; } Close any open search dialog if ( mSearchManager ! = null ) { mSearchManager . stopSearch ( ) ; } if ( mActionBar ! = null ) { mActionBar . onDestroy ( ) ; } getApplication ( ) . dispatchActivityDestroyed ( this ) ; } 
6057	private static String doGetPath ( final String fileName , final int separatorAdd ) { if ( fileName = = null ) { return null ; } final int prefix = getPrefixLength ( fileName ) ; if ( prefix < _NUM ) { return null ; } final int index = indexOfLastSeparator ( fileName ) ; final int endIndex = index + separatorAdd ; if ( prefix > = fileName . length ( ) | | index < _NUM | | prefix > = endIndex ) { return EMPTY _ STRING ; } final String path = fileName . substring ( prefix , endIndex ) ; failIfNullBytePresent ( path ) ; return path ; } 
6058	public void sendBroadcastSync ( Intent intent ) { if ( sendBroadcast ( intent ) ) { executePendingBroadcasts ( ) ; } } 
6059	public DescribeMovingAddressesRequest withFilters ( Filter . . . filters ) { if ( getFilters ( ) = = null ) setFilters ( new java . util . ArrayList < Filter > ( filters . length ) ) ; for ( Filter value : filters ) { getFilters ( ) . add ( value ) ; } return this ; } 
6060	public static < T > T min ( Collection < ? extends T > collection , Comparator < ? super T > comparator ) { if ( comparator = = null ) { null comparator ? T is comparable @ SuppressWarnings ( _STR ) T result = ( T ) min ( ( Collection < java . lang . Comparable > ) collection ) ; return result ; } Iterator < ? extends T > it = collection . iterator ( ) ; T min = it . next ( ) ; while ( it . hasNext ( ) ) { T next = it . next ( ) ; if ( comparator . compare ( min , next ) > _NUM ) { min = next ; } } return min ; } 
6061	Check that the properties are set and valid . Note : this is done in a separate method so this class can be statically initialized . static void checkProperties ( ) { We ' re gonna check all properties and collect the exceptions , so we can give a general overview . Store the exceptions here . RuntimeException toThrow = null ; for ( int reason = _NUM ; reason < = PackageManagerService . REASON _ LAST ; reason + + ) { try { Check that the system property name is legal . String sysPropName = getSystemPropertyName ( reason ) ; if ( sysPropName = = null | | sysPropName . isEmpty ( ) ) { throw new IllegalStateException ( _STR ) ; } toThrow . addSuppressed ( exc ) ; } } if ( toThrow ! = null ) { throw toThrow ; } } 
6062	public static String scrypt ( String password , byte [ ] salt , int n , int r , int p , int dkLen ) { try { byte [ ] derived = deriveScryptKey ( password . getBytes ( StandardCharsets . UTF _ _NUM ) , salt , n , r , p , dkLen ) ; return formatHash ( salt , n , r , p , derived ) ; } catch ( GeneralSecurityException e ) { throw new IllegalStateException ( _STR ) ; } } 
6063	public final GFElement subtract ( GFElement minuend ) { return add ( minuend ) ; } 
6064	public void visitTables ( String schemaPath , SchemaPlus schema ) { final AbstractSchema drillSchema = schema . unwrap ( AbstractSchema . class ) ; final List < String > tableNames = Lists . newArrayList ( schema . getTableNames ( ) ) ; for ( Pair < String , ? extends Table > tableNameToTable : drillSchema . getTablesByNames ( tableNames ) ) { final String tableName = tableNameToTable . getKey ( ) ; final Table table = tableNameToTable . getValue ( ) ; final TableType tableType = table . getJdbcTableType ( ) ; Visit the table , and if requested . . . if ( shouldVisitTable ( schemaPath , tableName , tableType ) & & visitTable ( schemaPath , tableName , table ) ) { . . . do for each of the table ' s fields . final RelDataType tableRow = table . getRowType ( new JavaTypeFactoryImpl ( DRILL _ REL _ DATATYPE _ SYSTEM ) ) ; for ( RelDataTypeField field : tableRow . getFieldList ( ) ) { if ( shouldVisitColumn ( schemaPath , tableName , field . getName ( ) ) ) { visitField ( schemaPath , tableName , field ) ; } } } } } 
6065	public void onBackup ( ParcelFileDescriptor oldState , BackupDataOutput data , ParcelFileDescriptor newState ) throws IOException { backup operation . synchronized ( HugeBackupActivity . sDataLock ) { RandomAccessFile file = new RandomAccessFile ( mDataFile , _STR ) ; mFilling = file . readInt ( ) ; mAddMayo = file . readBoolean ( ) ; mAddTomato = file . readBoolean ( ) ; } If the new state file descriptor is null , this is the first time a backup is being performed , so we know we have to write the data . If there < em > is < / em > a previous state blob , we want to double check whether the current data is actually different from our last backup , so that we can avoid transmitting redundant data to the storage backend . boolean doBackup = ( oldState = = null ) ; if ( ! doBackup ) { doBackup = compareStateFile ( oldState ) ; } transport under the single key string . if ( doBackup ) { ByteArrayOutputStream bufStream = new ByteArrayOutputStream ( ) ; We use a DataOutputStream to write structured data into the buffering stream DataOutputStream outWriter = new DataOutputStream ( bufStream ) ; outWriter . writeInt ( mFilling ) ; outWriter . writeBoolean ( mAddMayo ) ; outWriter . writeBoolean ( mAddTomato ) ; Okay , we ' ve flattened the data for transmission . Pull it out of the buffering stream object and send it off . byte [ ] buffer = bufStream . toByteArray ( ) ; int len = buffer . length ; data . writeEntityHeader ( APP _ DATA _ KEY , len ) ; data . writeEntityData ( buffer , len ) ; * * * * * pathological behavior * * * * * Now , in order to incur deliberate too - much - data failures , try to back up _NUM _NUM MB of data besides what we already pushed . final int MEGABYTE = _NUM _NUM _NUM _NUM * _NUM _NUM _NUM _NUM ; final int NUM _ MEGS = _NUM _NUM ; buffer = new byte [ MEGABYTE ] ; data . writeEntityHeader ( HUGE _ DATA _ KEY , NUM _ MEGS * MEGABYTE ) ; for ( int i = _NUM ; i < NUM _ MEGS ; i + + ) { data . writeEntityData ( buffer , MEGABYTE ) ; } } Finally , in all cases , we need to write the new state blob writeStateFile ( newState ) ; } 
6066	public void fakeDragBy ( float xOffset ) { if ( ! mFakeDragging ) { throw new IllegalStateException ( _STR ) ; } mLastMotionX + = xOffset ; float oldScrollX = getScrollX ( ) ; float scrollX = oldScrollX - xOffset ; final int width = getClientWidth ( ) ; float leftBound = width * mFirstOffset ; float rightBound = width * mLastOffset ; final ItemInfo firstItem = mItems . get ( _NUM ) ; final ItemInfo lastItem = mItems . get ( mItems . size ( ) - _NUM ) ; if ( firstItem . position ! = _NUM ) { leftBound = firstItem . offset * width ; } if ( lastItem . position ! = mAdapter . getCount ( ) - _NUM ) { rightBound = lastItem . offset * width ; } if ( scrollX < leftBound ) { scrollX = leftBound ; } else if ( scrollX > rightBound ) { scrollX = rightBound ; } Don ' t lose the rounded component mLastMotionX + = scrollX - ( int ) scrollX ; scrollTo ( ( int ) scrollX , getScrollY ( ) ) ; pageScrolled ( ( int ) scrollX ) ; Synthesize an event for the VelocityTracker . final long time = SystemClock . uptimeMillis ( ) ; final MotionEvent ev = MotionEvent . obtain ( mFakeDragBeginTime , time , MotionEvent . ACTION _ MOVE , mLastMotionX , _NUM , _NUM ) ; mVelocityTracker . addMovement ( ev ) ; ev . recycle ( ) ; } 
6067	 @ RequestMapping ( value = _STR ) String alternateId ) throws Exception { return showViewUpdateCollection ( request , model , pathVars , id , collectionField , collectionItemId , alternateId , ModalHeaderType . UPDATE _ COLLECTION _ ITEM . getType ( ) ) ; } 
6068	 @ SuppressWarnings ( _STR + format ) ; } return result ; } 
6069	public int normalize ( char [ ] text , int len ) { for ( int i = _NUM ; i < len ; i + + ) { final Character . UnicodeBlock block = Character . UnicodeBlock . of ( text [ i ] ) ; final ScriptData sd = scripts . get ( block ) ; if ( sd ! = null ) { final int ch = text [ i ] - sd . base ; if ( sd . decompMask . get ( ch ) ) len = compose ( ch , block , sd , text , i , len ) ; } } return len ; } 
6070	public void selectCells ( @ NotNull Collection < GridPos > cells ) { checkWidget ( ) ; for ( GridPos cell : cells ) { addToCellSelection ( cell ) ; } updateSelectionCache ( ) ; redraw ( ) ; } 
6071	public Iterable < COSName > getPatternNames ( ) { return getNames ( COSName . PATTERN ) ; } 
6072	private List < CmsResource > internalReadResourceList ( CmsObject cms , List < CmsUUID > uuidList ) { List < CmsResource > resList = new ArrayList < CmsResource > ( uuidList . size ( ) ) ; for ( Iterator < CmsUUID > i = uuidList . iterator ( ) ; i . hasNext ( ) ; ) { try { CmsResource res = cms . readResource ( i . next ( ) , CmsResourceFilter . ALL ) ; resList . add ( res ) ; } catch ( CmsException exc ) { LOG . error ( exc . getLocalizedMessage ( ) , exc ) ; } } return resList ; } 
6073	public static void broadcastStickyIntent ( Intent intent , int appOp , int userId ) { try { getService ( ) . broadcastIntent ( null , intent , null , null , Activity . RESULT _ OK , null , null , null , appOp , null , false , true , userId ) ; } catch ( RemoteException ex ) { } } 
6074	public void setSheetIndex ( int index ) { int lastSheetIx = _ book . getNumberOfSheets ( ) - _NUM ; if ( index < - _NUM | | index > lastSheetIx ) { throw new IllegalArgumentException ( _STR ) ) ) ; } _ definedNameRec . setSheetNumber ( index + _NUM ) ; } 
6075	private int getHitBigRectNodesNum ( final int rn , final int lv , final TreeRect r ) { final int w = r . w ; final int ls = sub . levelSize ( rn , lv ) ; return Math . max ( ls / Math . max ( w , _NUM ) , _NUM ) ; } 
6076	public void testNoMemoryLeakOnInvalidSessions ( ) throws Exception { SessionListener sessionListener = new SessionListener ( ) { public void onStart ( Session session ) { session . setAttribute ( _STR ) ; } public void onStop ( Session session ) { tryToCleanSession ( session ) ; } public void onExpiration ( Session session ) { tryToCleanSession ( session ) ; } private void tryToCleanSession ( Session session ) { Collection < Object > keys = session . getAttributeKeys ( ) ; for ( Object key : keys ) { session . removeAttribute ( key ) ; } } } ; DefaultSessionManager sessionManager = new DefaultSessionManager ( ) ; sessionManager . setSessionListeners ( Arrays . asList ( sessionListener ) ) ; Session session = sessionManager . start ( null ) ; assertEquals ( _NUM , sessionManager . getActiveSessions ( ) . size ( ) ) ; session . setTimeout ( _NUM L ) ; last access timestamp needs to be older than the current timestamp when validating , so ensure a delay : Thread . sleep ( _NUM ) ; sessionManager . validateSessions ( ) ; assertEquals ( _NUM , sessionManager . getActiveSessions ( ) . size ( ) ) ; } 
6077	public static XmlString parse ( java . io . File f ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( XmlString ) XmlBeans . getContextTypeLoader ( ) . parse ( f , type , null ) ; } 
6078	public COSBase getObject ( int index ) { Object obj = objects . get ( index ) ; if ( obj instanceof COSObject ) { obj = ( ( COSObject ) obj ) . getObject ( ) ; } if ( obj instanceof COSNull ) { obj = null ; } return ( COSBase ) obj ; } 
6079	public Optional < T > filter ( Predicate < ? super T > predicate ) { if ( ! isPresent ( ) ) return this ; return predicate . test ( value ) ? this : Optional . < T > empty ( ) ; } 
6080	private void array ( ) throws QueryIOException { consumeWs ( ' [ ' , true ) ; conv . openArray ( ) ; if ( ! consumeWs ( ' ] ' , false ) ) { do { conv . openItem ( ) ; value ( ) ; conv . closeItem ( ) ; } while ( consumeWs ( ' , ' , false ) & & ! ( liberal & & curr ( ) = = ' ] ' ) ) ; consumeWs ( ' ] ' , true ) ; } conv . closeArray ( ) ; } 
6081	public void retainSubscriptionsForFactoryReset ( PendingIntent callbackIntent ) { if ( ! isEnabled ( ) ) { sendUnavailableError ( callbackIntent ) ; return ; } try { getIEuiccController ( ) . retainSubscriptionsForFactoryReset ( callbackIntent ) ; } catch ( RemoteException e ) { throw e . rethrowFromSystemServer ( ) ; } } 
6082	public long insertWithOnConflict ( String table , String nullColumnHack , ContentValues initialValues , int conflictAlgorithm ) { acquireReference ( ) ; try { StringBuilder sql = new StringBuilder ( ) ; sql . append ( _STR ) ; } sql . append ( ' ) ' ) ; SQLiteStatement statement = new SQLiteStatement ( this , sql . toString ( ) , bindArgs ) ; try { return statement . executeInsert ( ) ; } finally { statement . close ( ) ; } } finally { releaseReference ( ) ; } } 
6083	public void setOutlineVisible ( boolean visible ) { this . outlineVisible = visible ; fireChangeEvent ( ) ; } 
6084	public static FontImage createMaterial ( char icon , Style s , float size ) { Font f = getMaterialDesignFont ( ) . derive ( Display . getInstance ( ) . convertToPixels ( size ) , Font . STYLE _ PLAIN ) ; return create ( _STR + icon , s , f ) ; } 
6085	public boolean isTypeQuotaSet ( ) { if ( typeQuota = = null ) { return false ; } for ( StorageType t : StorageType . getTypesSupportingQuota ( ) ) { if ( typeQuota [ t . ordinal ( ) ] > _NUM ) { return true ; } } return false ; } 
6086	public void whenInvalidProfileIsSetAllLinksAreVisible ( ) throws Exception { quicklinkProfile = _STR , link . isVisible ( ) ) ; } } 
6087	public void testResolverInterface ( ) { I _ CmsMacroResolver resolver = new I _ CmsMacroResolver ( ) { public String getMacroValue ( String key ) { if ( _STR , result ) ; } 
6088	private boolean markupDecl ( ) throws IOException { if ( consume ( ENT ) ) { [ _NUM _NUM ] checkS ( ) ; if ( consume ( ' % ' ) ) { [ _NUM _NUM ] PEDecl checkS ( ) ; final byte [ ] key = name ( true ) ; checkS ( ) ; [ _NUM _NUM ] byte [ ] val = entityValue ( true ) ; if ( val = = null ) { val = externalID ( true , false ) ; if ( val = = null ) throw error ( INVEND ) ; } s ( ) ; pents . put ( key , val ) ; } else { [ _NUM _NUM ] GEDecl final byte [ ] key = name ( true ) ; checkS ( ) ; [ _NUM _NUM ] EntityDef byte [ ] val = entityValue ( false ) ; if ( val = = null ) { val = externalID ( true , false ) ; if ( val = = null ) throw error ( INVEND ) ; if ( s ( ) ) { check ( ND ) ; checkS ( ) ; name ( true ) ; } } s ( ) ; ents . put ( key , val ) ; } check ( ' > ' ) ; pe = true ; } else if ( consume ( ELEM ) ) { [ _NUM _NUM ] checkS ( ) ; name ( true ) ; checkS ( ) ; pe = true ; if ( ! consume ( EMP ) & & ! consume ( ANY ) ) { [ _NUM _NUM ] if ( consume ( ' ( ' ) ) { s ( ) ; if ( consume ( PC ) ) { [ _NUM _NUM ] s ( ) ; boolean alt = false ; while ( consume ( ' | ' ) ) { s ( ) ; name ( true ) ; s ( ) ; alt = true ; } check ( ' ) ' ) ; if ( ! consume ( ' * ' ) & & alt ) throw error ( INVEND ) ; } else { cp ( ) ; s ( ) ; check ( ' ) ' ) ; to be fixed . . . while ( ! consume ( ' ) ' ) ) consume ( ) ; input . prev ( _NUM ) ; occ ( ) ; } } else { throw error ( INVEND ) ; } } s ( ) ; check ( ' > ' ) ; } else if ( consume ( ATTL ) ) { [ _NUM _NUM ] pe = true ; checkS ( ) ; name ( true ) ; s ( ) ; while ( name ( false ) ! = null ) { [ _NUM _NUM ] checkS ( ) ; if ( ! consume ( CD ) & & ! consume ( IDRS ) & & ! consume ( IDR ) & & ! consume ( ID ) & & ! consume ( ENTS ) & & ! consume ( ENT _NUM ) & & ! consume ( NMTS ) & & ! consume ( NMT ) ) { [ _NUM _NUM ] if ( consume ( NOT ) ) { [ _NUM _NUM , _NUM _NUM ] checkS ( ) ; check ( ' ( ' ) ; s ( ) ; name ( true ) ; s ( ) ; while ( consume ( ' | ' ) ) { s ( ) ; name ( true ) ; s ( ) ; } check ( ' ) ' ) ; } else { [ _NUM _NUM ] check ( ' ( ' ) ; s ( ) ; nmtoken ( ) ; s ( ) ; while ( consume ( ' | ' ) ) { s ( ) ; nmtoken ( ) ; s ( ) ; } check ( ' ) ' ) ; } } [ _NUM _NUM ] pe = true ; checkS ( ) ; if ( ! consume ( REQ ) & & ! consume ( IMP ) ) { [ _NUM _NUM ] if ( consume ( FIX ) ) checkS ( ) ; quote = qu ( ) ; attValue ( consume ( ) ) ; } s ( ) ; } check ( ' > ' ) ; } else if ( consume ( NOTA ) ) { [ _NUM _NUM ] checkS ( ) ; name ( true ) ; s ( ) ; externalID ( false , false ) ; s ( ) ; check ( ' > ' ) ; } else if ( consume ( COMS ) ) { comment ( ) ; } else if ( consume ( XML ) ) { pi ( ) ; } else { return false ; } s ( ) ; pe = false ; return true ; } 
6089	public void activeLineRangeChanged ( ActiveLineRangeEvent e ) { if ( e . getMin ( ) = = - _NUM ) { clearActiveLineRange ( ) ; } else { setActiveLineRange ( e . getMin ( ) , e . getMax ( ) ) ; } } 
6090	public static Script createMultiSigInputScriptBytes ( List < byte [ ] > signatures , @ Nullable byte [ ] multisigProgramBytes ) { checkArgument ( signatures . size ( ) < = _NUM _NUM ) ; ScriptBuilder builder = new ScriptBuilder ( ) ; Work around a bug in CHECKMULTISIG that is now a required part of the protocol . builder . smallNum ( _NUM ) ; for ( byte [ ] signature : signatures ) builder . data ( signature ) ; if ( multisigProgramBytes ! = null ) builder . data ( multisigProgramBytes ) ; return builder . build ( ) ; } 
6091	public static Uri buildPreviewProgramsUriForChannel ( Uri channelUri ) { if ( ! isChannelUriForTunerInput ( channelUri ) ) { throw new IllegalArgumentException ( _STR + channelUri ) ; } return buildPreviewProgramsUriForChannel ( ContentUris . parseId ( channelUri ) ) ; } 
6092	private void updateRootAttr ( INodeWithAdditionalFields root ) { final QuotaCounts q = root . getQuotaCounts ( ) ; final long nsQuota = q . getNameSpace ( ) ; final long dsQuota = q . getStorageSpace ( ) ; FSDirectory fsDir = namesystem . dir ; if ( nsQuota ! = - _NUM | | dsQuota ! = - _NUM ) { fsDir . rootDir . getDirectoryWithQuotaFeature ( ) . setQuota ( nsQuota , dsQuota ) ; } fsDir . rootDir . cloneModificationTime ( root ) ; fsDir . rootDir . clonePermissionStatus ( root ) ; } 
6093	public List < String > getSelectedExportValues ( ) { Set < String > onValues = getOnValues ( ) ; List < String > exportValues = getExportValues ( ) ; List < String > selectedExportValues = new ArrayList < > ( ) ; if ( exportValues . isEmpty ( ) ) { selectedExportValues . add ( getValue ( ) ) ; return selectedExportValues ; } else { String fieldValue = getValue ( ) ; int idx = _NUM ; for ( String onValue : onValues ) { if ( onValue . compareTo ( fieldValue ) = = _NUM ) { selectedExportValues . add ( exportValues . get ( idx ) ) ; } } return selectedExportValues ; } } 
6094	private static INfcAdapter getServiceInterface ( ) { IBinder b = ServiceManager . getService ( _STR ) ; if ( b = = null ) { return null ; } return INfcAdapter . Stub . asInterface ( b ) ; } 
6095	public static void main ( String [ ] args ) throws Exception { if ( args . length ! = _NUM ) { System . out . println ( _STR ) ; System . out . println ( loader . getStructure ( ) ) ; while ( loader . hasMoreElements ( structure ) ) System . out . println ( loader . nextElement ( inst ) ) ; } 
6096	public void testUnsupportedPowerPoint ( ) throws Exception { String [ ] extensions = new String [ ] { _STR + filename , mimeTypes [ i ] , metadata . get ( Metadata . CONTENT _ TYPE ) ) ; But that ' s about it } } } 
6097	synchronized byte [ ] allocate ( ) throws InterruptedException { if ( LOG . isDebugEnabled ( ) ) { debugMessage . get ( ) . append ( _STR ) . append ( array ! = null ) ; } return array ! = null ? array : new byte [ byteArrayLength ] ; } 
6098	 @ VisibleForTestinglong getAccessTime ( String key ) { String interned = intern ( key ) ; synchronized ( interned ) { SharedCacheResource resource = cachedResources . get ( interned ) ; return resource = = null ? - _NUM : resource . getAccessTime ( ) ; } } 
6099	public void test _NUM _NUM _NUM _NUM a ( ) throws Exception { LOG . info ( _STR ) ; } 
6100	private static void addRegex ( final CharIterator i , final StringBuilder result ) { int braces = _NUM ; while ( i . hasNext ( ) ) { final char ch = i . nextNonWS ( ) ; if ( ch = = ' { ' ) + + braces ; else if ( ch = = ' } ' & & - - braces = = _NUM ) break ; result . append ( ch ) ; } } 
6101	public static long threadCount ( ) { return BTraceRuntime . getThreadCount ( ) ; } 
6102	private void parseQueryPredicate ( ) throws InvalidQueryException { String queryString = m _ body . getQueryString ( ) ; if ( queryString = = null ) { String uri = getURI ( ) ; int qsBegin = uri . indexOf ( _STR + e , e ) ; } } } 
6103	public boolean registerSystemCodeForService ( ComponentName service , String systemCode ) throws RuntimeException { if ( service = = null | | systemCode = = null ) { throw new NullPointerException ( _STR ) ; ee . rethrowAsRuntimeException ( ) ; return false ; } } } 
6104	public Control getControl ( ASN _NUM ObjectIdentifier type ) { AttributeTypeAndValue found = findControl ( type ) ; if ( found ! = null ) { if ( found . getType ( ) . equals ( CRMFObjectIdentifiers . id _ regCtrl _ pkiArchiveOptions ) ) { return new PKIArchiveControl ( PKIArchiveOptions . getInstance ( found . getValue ( ) ) ) ; } if ( found . getType ( ) . equals ( CRMFObjectIdentifiers . id _ regCtrl _ regToken ) ) { return new RegTokenControl ( DERUTF _NUM String . getInstance ( found . getValue ( ) ) ) ; } if ( found . getType ( ) . equals ( CRMFObjectIdentifiers . id _ regCtrl _ authenticator ) ) { return new AuthenticatorControl ( DERUTF _NUM String . getInstance ( found . getValue ( ) ) ) ; } } return null ; } 
6105	public boolean isSet ( _ Fields field ) { if ( field = = null ) { throw new java . lang . IllegalArgumentException ( ) ; } switch ( field ) { case TINFO : return isSetTinfo ( ) ; case CREDENTIALS : return isSetCredentials ( ) ; case PRINCIPAL : return isSetPrincipal ( ) ; case NS : return isSetNs ( ) ; case TBL _ NSPC _ PERM : return isSetTblNspcPerm ( ) ; } throw new java . lang . IllegalStateException ( ) ; } 
6106	public static String [ ] createEmptyBPDirs ( String [ ] baseDirs , String bpid ) throws IOException { String [ ] bpDirs = new String [ baseDirs . length ] ; for ( int i = _NUM ; i < baseDirs . length ; i + + ) { bpDirs [ i ] = MiniDFSCluster . getBPDir ( new File ( baseDirs [ i ] ) , bpid ) ; } createEmptyDirs ( bpDirs ) ; return bpDirs ; } 
6107	public void setName ( ) { InodeDirectory inode _NUM = createInodeDirectory ( ) ; Assert . assertEquals ( _STR , inode _NUM . getName ( ) ) ; } 
6108	public static int asInt ( final double datum , final int n ) { canonicalize - _NUM . _NUM , _NUM . _NUM final double d = ( datum = = _NUM . _NUM ) ? _NUM . _NUM : datum ; canonicalize all NaN forms final long [ ] data = { Double . doubleToLongBits ( d ) } ; data is long [ ] return asInteger ( data , n ) ; } 
6109	public Triple next ( ) { Triple toReturn = next ; walkOne ( ) ; return toReturn ; } 
6110	public static String [ ] splitLines ( String str ) { char [ ] [ ] split = Chr . splitLines ( FastStringUtils . toCharArray ( str ) ) ; return fromCharArrayOfArrayToStringArray ( split ) ; } 
6111	public void testFunctors _NUM ( ) { Graph data = Factory . createGraphMem ( ) ; data . add ( new Triple ( a , p , b ) ) ; data . add ( new Triple ( a , q , c ) ) ; data . add ( new Triple ( a , t , d ) ) ; List < Rule > rules = Rule . parseRules ( _STR ) ; Reasoner reasoner = createReasoner ( rules ) ; InfGraph infgraph = reasoner . bind ( data ) ; TestUtil . assertIteratorValues ( this , infgraph . find ( a , s , null ) , new Object [ ] { new Triple ( a , s , b ) , new Triple ( a , s , d ) } ) ; } 
6112	void readCMaps ( ) throws DocumentException , IOException { int [ ] table _ location ; table _ location = ( int [ ] ) tables . get ( _STR , fileName + style ) ) ; rf . seek ( table _ location [ _NUM ] ) ; rf . skipBytes ( _NUM ) ; int num _ tables = rf . readUnsignedShort ( ) ; fontSpecific = false ; int map _NUM _NUM = _NUM ; int map _NUM _NUM = _NUM ; int map _NUM _NUM = _NUM ; int mapExt = _NUM ; for ( int k = _NUM ; k < num _ tables ; + + k ) { int platId = rf . readUnsignedShort ( ) ; int platSpecId = rf . readUnsignedShort ( ) ; int offset = rf . readInt ( ) ; if ( platId = = _NUM & & platSpecId = = _NUM ) { fontSpecific = true ; map _NUM _NUM = offset ; } else if ( platId = = _NUM & & platSpecId = = _NUM ) { map _NUM _NUM = offset ; } else if ( platId = = _NUM & & platSpecId = = _NUM _NUM ) { mapExt = offset ; } if ( platId = = _NUM & & platSpecId = = _NUM ) { map _NUM _NUM = offset ; } } if ( map _NUM _NUM > _NUM ) { rf . seek ( table _ location [ _NUM ] + map _NUM _NUM ) ; int format = rf . readUnsignedShort ( ) ; switch ( format ) { case _NUM : cmap _NUM _NUM = readFormat _NUM ( ) ; break ; case _NUM : cmap _NUM _NUM = readFormat _NUM ( ) ; break ; case _NUM : cmap _NUM _NUM = readFormat _NUM ( ) ; break ; } } if ( map _NUM _NUM > _NUM ) { rf . seek ( table _ location [ _NUM ] + map _NUM _NUM ) ; int format = rf . readUnsignedShort ( ) ; if ( format = = _NUM ) { cmap _NUM _NUM = readFormat _NUM ( ) ; } } if ( map _NUM _NUM > _NUM ) { rf . seek ( table _ location [ _NUM ] + map _NUM _NUM ) ; int format = rf . readUnsignedShort ( ) ; if ( format = = _NUM ) { cmap _NUM _NUM = readFormat _NUM ( ) ; } } if ( mapExt > _NUM ) { rf . seek ( table _ location [ _NUM ] + mapExt ) ; int format = rf . readUnsignedShort ( ) ; switch ( format ) { case _NUM : cmapExt = readFormat _NUM ( ) ; break ; case _NUM : cmapExt = readFormat _NUM ( ) ; break ; case _NUM : cmapExt = readFormat _NUM ( ) ; break ; case _NUM _NUM : cmapExt = readFormat _NUM _NUM ( ) ; break ; } } } 
6113	public CmsProperty readPropertyObject ( String resourcePath , String property , boolean search ) throws CmsException { CmsResource resource = readResource ( resourcePath , CmsResourceFilter . ALL ) ; return m _ securityManager . readPropertyObject ( m _ context , resource , property , search ) ; } 
6114	public boolean marshall ( PackagePart part , OutputStream out ) throws OpenXML _NUM JException { if ( ! ( part instanceof PackagePropertiesPart ) ) throw new IllegalArgumentException ( _STR , namespaceCoreProperties ) ) ; DocumentHelper . addNamespaceDeclaration ( rootElem , namespaceCoreProperties ) ; DocumentHelper . addNamespaceDeclaration ( rootElem , namespaceDC ) ; DocumentHelper . addNamespaceDeclaration ( rootElem , namespaceDcTerms ) ; DocumentHelper . addNamespaceDeclaration ( rootElem , namespaceXSI ) ; xmlDoc . appendChild ( rootElem ) ; addCategory ( ) ; addContentStatus ( ) ; addContentType ( ) ; addCreated ( ) ; addCreator ( ) ; addDescription ( ) ; addIdentifier ( ) ; addKeywords ( ) ; addLanguage ( ) ; addLastModifiedBy ( ) ; addLastPrinted ( ) ; addModified ( ) ; addRevision ( ) ; addSubject ( ) ; addTitle ( ) ; addVersion ( ) ; return true ; } 
6115	public TransactionSignature calculateSignature ( int inputIndex , ECKey key , @ Nullable KeyParameter aesKey , byte [ ] redeemScript , SigHash hashType , boolean anyoneCanPay ) { Sha _NUM _NUM _NUM Hash hash = hashForSignature ( inputIndex , redeemScript , hashType , anyoneCanPay ) ; return new TransactionSignature ( key . sign ( hash , aesKey ) , hashType , anyoneCanPay ) ; } 
6116	public static CMSSignedData replaceSigners ( CMSSignedData signedData , SignerInformationStore signerInformationStore ) { copy CMSSignedData cms = new CMSSignedData ( signedData ) ; replace the store cms . signerInfoStore = signerInformationStore ; replace the signers in the SignedData object ASN _NUM EncodableVector digestAlgs = new ASN _NUM EncodableVector ( ) ; ASN _NUM EncodableVector vec = new ASN _NUM EncodableVector ( ) ; Iterator it = signerInformationStore . getSigners ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { SignerInformation signer = ( SignerInformation ) it . next ( ) ; digestAlgs . add ( CMSSignedHelper . INSTANCE . fixAlgID ( signer . getDigestAlgorithmID ( ) ) ) ; vec . add ( signer . toASN _NUM Structure ( ) ) ; } ASN _NUM Set digests = new DERSet ( digestAlgs ) ; ASN _NUM Set signers = new DERSet ( vec ) ; ASN _NUM Sequence sD = ( ASN _NUM Sequence ) signedData . signedData . toASN _NUM Primitive ( ) ; vec = new ASN _NUM EncodableVector ( ) ; signers are the last item in the sequence . version vec . add ( sD . getObjectAt ( _NUM ) ) ; vec . add ( digests ) ; for ( int i = _NUM ; i ! = sD . size ( ) - _NUM ; i + + ) { vec . add ( sD . getObjectAt ( i ) ) ; } vec . add ( signers ) ; cms . signedData = SignedData . getInstance ( new BERSequence ( vec ) ) ; replace the contentInfo with the new one cms . contentInfo = new ContentInfo ( cms . contentInfo . getContentType ( ) , cms . signedData ) ; return cms ; } 
6117	private void cleanup ( ) { if ( ! channelClosed . compareAndSet ( false , true ) ) { return ; } disconnected . set ( true ) ; onClosing ( ) ; } 
6118	public boolean contains ( float val ) { return index ( val ) > = _NUM ; } 
6119	public AggregateDefinition completionPredicate ( @ AsPredicate Predicate predicate ) { checkNoCompletedPredicate ( ) ; setCompletionPredicate ( new ExpressionSubElementDefinition ( predicate ) ) ; return this ; } 
6120	public void resolveEmptyIpAddress ( ) throws UnknownHostException { NetworkAddressUtils . resolveIpAddress ( _STR ) ; } 
6121	public static < T extends Comparable < ? super T > > T min ( final T . . . values ) { T result = null ; if ( values ! = null ) { for ( final T value : values ) { if ( compare ( value , result , true ) < _NUM ) { result = value ; } } } return result ; } 
6122	public List < AlertCurrentEntity > findCurrentByService ( long clusterId , String serviceName ) { TypedQuery < AlertCurrentEntity > query = m _ entityManagerProvider . get ( ) . createNamedQuery ( _STR , EnumSet . of ( Scope . ANY , Scope . SERVICE ) ) ; List < AlertCurrentEntity > alerts = m _ daoUtils . selectList ( query ) ; if caching is enabled , replace results with cached values when present if ( m _ configuration . isAlertCacheEnabled ( ) ) { alerts = supplementWithCachedAlerts ( alerts ) ; } return alerts ; } 
6123	protected void expectPropertyUnset ( String target , String property ) { expectPropertySet ( target , property , null ) ; } 
6124	private static ThreadFactory newDaemonThreadFactory ( final String prefix ) { final ThreadFactory namedFactory = getNamedThreadFactory ( prefix ) ; return new ThreadFactory ( ) { @ Override public Thread newThread ( Runnable r ) { Thread t = namedFactory . newThread ( r ) ; if ( ! t . isDaemon ( ) ) { t . setDaemon ( true ) ; } if ( t . getPriority ( ) ! = Thread . NORM _ PRIORITY ) { t . setPriority ( Thread . NORM _ PRIORITY ) ; } return t ; } } ; } 
6125	public int processLine ( String line , Vector featureVector ) { List < String > values = parseCsvLine ( line ) ; int targetValue = targetDictionary . intern ( values . get ( target ) ) ; if ( targetValue > = maxTargetValue ) { targetValue = maxTargetValue - _NUM ; } for ( Integer predictor : predictors ) { String value ; if ( predictor > = _NUM ) { value = values . get ( predictor ) ; } else { value = null ; } predictorEncoders . get ( predictor ) . addToVector ( value , featureVector ) ; } return targetValue ; } 
6126	private void startTMasterChecker ( ) { final int checkIntervalSec = TypeUtils . getInteger ( sinkConfig . get ( KEY _ TMASTER _ LOCATION _ CHECK _ INTERVAL _ SEC ) ) ; Runnable runnable = new Runnable ( ) { @ Override public void run ( ) { TopologyMaster . TMasterLocation location = ( TopologyMaster . TMasterLocation ) SingletonRegistry . INSTANCE . getSingleton ( TMASTER _ LOCATION _ BEAN _ NAME ) ; if ( location ! = null ) { if ( currentTMasterLocation = = null | | ! location . equals ( currentTMasterLocation ) ) { LOG . info ( _STR + checkIntervalSec ) ; } 
6127	public String buildSelectElementName ( String attributes ) { get the active page elements List elementList = getElementList ( ) ; int counter = _NUM ; int currentIndex = - _NUM ; List options = new ArrayList ( elementList . size ( ) ) ; List values = new ArrayList ( elementList . size ( ) ) ; String elementName = getParamElementname ( ) ; if ( CmsStringUtil . isEmpty ( elementName ) ) { elementName = getParamOldelementname ( ) ; } for ( int i = _NUM ; i < elementList . size ( ) ; i + + ) { get the current list element CmsDialogElement element = ( CmsDialogElement ) elementList . get ( i ) ; if ( CmsStringUtil . isNotEmpty ( elementName ) & & elementName . equals ( element . getName ( ) ) ) { current element is the displayed one , mark it as selected currentIndex = counter ; } if ( ( ! m _ page . hasValue ( element . getName ( ) , getElementLocale ( ) ) & & element . isMandantory ( ) ) | | m _ page . isEnabled ( element . getName ( ) , getElementLocale ( ) ) ) { add element if it is not available or if it is enabled options . add ( element . getNiceName ( ) ) ; values . add ( element . getName ( ) ) ; counter + + ; } } return buildSelect ( attributes , options , values , currentIndex , false ) ; } 
6128	private void compileTagHandlerPoolList ( Node . Nodes page ) throws JasperException { class TagHandlerPoolVisitor extends Node . Visitor { private Vector names ; TagHandlerPoolVisitor ( Vector v ) { names = v ; } public void visit ( Node . CustomTag n ) throws JasperException { if ( ! n . implementsSimpleTag ( ) ) { String name = createTagHandlerPoolName ( n . getPrefix ( ) , n . getLocalName ( ) , n . getAttributes ( ) , n . getNamedAttributeNodes ( ) , n . hasEmptyBody ( ) ) ; n . setTagHandlerPoolName ( name ) ; if ( ! names . contains ( name ) ) { names . add ( name ) ; } } visitBody ( n ) ; } private String createTagHandlerPoolName ( String prefix , String shortName , Attributes attrs , Node . Nodes namedAttrs , boolean hasEmptyBody ) { String poolName = null ; poolName = _STR ; } return JspUtil . makeJavaIdentifier ( poolName ) ; } } page . visit ( new TagHandlerPoolVisitor ( tagHandlerPoolNames ) ) ; } 
6129	public static boolean isNotEmpty ( CharSequence cs ) { return ! StringUtils . isEmpty ( cs ) ; } 
6130	public void setSpeculativeExecution ( boolean speculativeExecution ) { setMapSpeculativeExecution ( speculativeExecution ) ; setReduceSpeculativeExecution ( speculativeExecution ) ; } 
6131	public long getTimerTime ( int key ) { final int index = getIndex ( mTimerKeys , key ) ; if ( index < _NUM ) { throw new IndexOutOfBoundsException ( _STR + key ) ; } return mTimerTimes [ index ] ; } 
6132	public static void writeStaticField ( final Class < ? > cls , final String fieldName , final Object value , final boolean forceAccess ) throws IllegalAccessException { final Field field = getField ( cls , fieldName , forceAccess ) ; Validate . isTrue ( field ! = null , _STR , fieldName , cls ) ; already forced access above , don ' t repeat it here : writeStaticField ( field , value , false ) ; } 
6133	private void doRecommendConfigurations ( Configuration configuration , Set < String > configTypesUpdated ) { ConfigRecommendationStrategy configRecommendationStrategy = clusterTopology . getConfigRecommendationStrategy ( ) ; Map < String , AdvisedConfiguration > advisedConfigurations = clusterTopology . getAdvisedConfigurations ( ) ; LOG . info ( _STR , ConfigRecommendationStrategy . NEVER _ APPLY ) ; } } 
6134	protected boolean hasResourceValue ( OPT option ) { return super . hasResourceValue ( option ) | | ( hasParent ( ) & & getParent ( ) . hasResourceValue ( option ) ) ; } 
6135	protected void applyToPlot ( Plot plot ) { if ( plot = = null ) { throw new IllegalArgumentException ( _STR ) ; } if ( plot . getDrawingSupplier ( ) ! = null ) { plot . setDrawingSupplier ( getDrawingSupplier ( ) ) ; } if ( plot . getBackgroundPaint ( ) ! = null ) { plot . setBackgroundPaint ( this . plotBackgroundPaint ) ; } plot . setOutlinePaint ( this . plotOutlinePaint ) ; but I didn ' t and neither did anyone else ) . if ( plot instanceof PiePlot ) { applyToPiePlot ( ( PiePlot ) plot ) ; } else if ( plot instanceof MultiplePiePlot ) { applyToMultiplePiePlot ( ( MultiplePiePlot ) plot ) ; } else if ( plot instanceof CategoryPlot ) { applyToCategoryPlot ( ( CategoryPlot ) plot ) ; } else if ( plot instanceof XYPlot ) { applyToXYPlot ( ( XYPlot ) plot ) ; } else if ( plot instanceof FastScatterPlot ) { applyToFastScatterPlot ( ( FastScatterPlot ) plot ) ; } else if ( plot instanceof MeterPlot ) { applyToMeterPlot ( ( MeterPlot ) plot ) ; } else if ( plot instanceof ThermometerPlot ) { applyToThermometerPlot ( ( ThermometerPlot ) plot ) ; } else if ( plot instanceof SpiderWebPlot ) { applyToSpiderWebPlot ( ( SpiderWebPlot ) plot ) ; } else if ( plot instanceof PolarPlot ) { applyToPolarPlot ( ( PolarPlot ) plot ) ; } } 
6136	public void proposeRejectsLowerRanks ( ) { Layout layout = TestLayoutBuilder . single ( SERVERS . PORT _ _NUM ) ; long epoch = layout . getEpoch ( ) ; bootstrapServer ( layout ) ; sendPrepare ( epoch , HIGH _ RANK ) ; Assertions . assertThat ( getLastMessage ( ) . getMsgType ( ) ) . isEqualTo ( CorfuMsgType . LAYOUT _ PREPARE _ ACK ) ; sendPropose ( epoch , LOW _ RANK , layout ) ; Assertions . assertThat ( getLastMessage ( ) . getMsgType ( ) ) . isEqualTo ( CorfuMsgType . LAYOUT _ PROPOSE _ REJECT ) ; } 
6137	public DeleteResult isDeleted ( Cell cell ) { long duplicateMvcc = prepare ( cell ) ; for ( Map . Entry < Long , DeleteVersionsNode > e : delColMap . tailMap ( cell . getSequenceId ( ) ) . entrySet ( ) ) { DeleteVersionsNode node = e . getValue ( ) ; long deleteMvcc = Long . MAX _ VALUE ; SortedSet < Long > deleteVersionMvccs = node . deletesMap . get ( cell . getTimestamp ( ) ) ; if ( deleteVersionMvccs ! = null ) { SortedSet < Long > tail = deleteVersionMvccs . tailSet ( cell . getSequenceId ( ) ) ; if ( ! tail . isEmpty ( ) ) { deleteMvcc = tail . first ( ) ; } } SortedMap < Long , SortedSet < Long > > subMap = node . mvccCountingMap . subMap ( cell . getSequenceId ( ) , true , Math . min ( duplicateMvcc , deleteMvcc ) , true ) ; for ( Map . Entry < Long , SortedSet < Long > > seg : subMap . entrySet ( ) ) { if ( seg . getValue ( ) . size ( ) > = maxVersions ) { return DeleteResult . VERSION _ MASKED ; } seg . getValue ( ) . add ( cell . getSequenceId ( ) ) ; } if ( deleteMvcc < Long . MAX _ VALUE ) { return DeleteResult . VERSION _ DELETED ; } if ( cell . getTimestamp ( ) < = node . ts ) { return DeleteResult . COLUMN _ DELETED ; } } if ( duplicateMvcc < Long . MAX _ VALUE ) { return DeleteResult . VERSION _ MASKED ; } return DeleteResult . NOT _ DELETED ; } 
6138	private static Object handleHookedMethod ( Member method , int originalMethodId , Object additionalInfoObj , Object thisObject , Object [ ] args ) throws Throwable { AdditionalHookInfo additionalInfo = ( AdditionalHookInfo ) additionalInfoObj ; Object [ ] callbacksSnapshot = additionalInfo . callbacks . getSnapshot ( ) ; final int callbacksLength = callbacksSnapshot . length ; if ( callbacksLength = = _NUM ) { try { return invokeOriginalMethodNative ( method , originalMethodId , additionalInfo . parameterTypes , additionalInfo . returnType , thisObject , args ) ; } catch ( InvocationTargetException e ) { throw e . getCause ( ) ; } } MethodHookParam param = new MethodHookParam ( ) ; param . method = method ; param . thisObject = thisObject ; param . args = args ; call _STR callbacks int afterIdx = beforeIdx - _NUM ; do { Object lastResult = param . getResult ( ) ; Throwable lastThrowable = param . getThrowable ( ) ; try { ( ( XC _ MethodHook ) callbacksSnapshot [ afterIdx ] ) . afterHookedMethod ( param ) ; } catch ( Throwable t ) { DexposedBridge . log ( t ) ; reset to last result ( ignoring what the unexpectedly exiting callback did ) if ( lastThrowable = = null ) param . setResult ( lastResult ) ; else param . setThrowable ( lastThrowable ) ; } } while ( - - afterIdx > = _NUM ) ; return if ( param . hasThrowable ( ) ) throw param . getThrowable ( ) ; else return param . getResult ( ) ; } 
6139	public void continueOperation ( Intent resolutionIntent , Bundle resolutionExtras ) { if ( ! isEnabled ( ) ) { PendingIntent callbackIntent = resolutionIntent . getParcelableExtra ( EuiccManager . EXTRA _ EMBEDDED _ SUBSCRIPTION _ RESOLUTION _ CALLBACK _ INTENT ) ; if ( callbackIntent ! = null ) { sendUnavailableError ( callbackIntent ) ; } return ; } try { getIEuiccController ( ) . continueOperation ( resolutionIntent , resolutionExtras ) ; } catch ( RemoteException e ) { throw e . rethrowFromSystemServer ( ) ; } } 
6140	public void sequenceEvent ( PublishRequest request , Runnable callback ) { if ( requestSequence = = responseSequence ) { log . trace ( _STR , request ) ; callback . run ( ) ; eventIndex = request . eventIndex ( ) ; } else { eventCallbacks . add ( new EventCallback ( request , callback ) ) ; completeResponses ( ) ; } } 
6141	public final Object onRetainNonConfigurationInstance ( ) { if ( mStopped ) { doReallyStop ( true ) ; } Object custom = onRetainCustomNonConfigurationInstance ( ) ; FragmentManagerNonConfig fragments = mFragments . retainNestedNonConfig ( ) ; SimpleArrayMap < String , LoaderManager > loaders = mFragments . retainLoaderNonConfig ( ) ; if ( fragments = = null & & loaders = = null & & custom = = null ) { return null ; } NonConfigurationInstances nci = new NonConfigurationInstances ( ) ; nci . custom = custom ; nci . fragments = fragments ; nci . loaders = loaders ; return nci ; } 
6142	public void drawItem ( Graphics _NUM D g _NUM , XYItemRendererState state , Rectangle _NUM D dataArea , PlotRenderingInfo info , XYPlot plot , ValueAxis domainAxis , ValueAxis rangeAxis , XYDataset dataset , int series , int item , CrosshairState crosshairState , int pass ) { do nothing if item is not visible if ( ! getItemVisible ( series , item ) ) { return ; } first pass draws the shading if ( pass = = _NUM ) { IntervalXYDataset intervalDataset = ( IntervalXYDataset ) dataset ; State drState = ( State ) state ; double x = intervalDataset . getXValue ( series , item ) ; double yLow = intervalDataset . getStartYValue ( series , item ) ; double yHigh = intervalDataset . getEndYValue ( series , item ) ; RectangleEdge xAxisLocation = plot . getDomainAxisEdge ( ) ; RectangleEdge yAxisLocation = plot . getRangeAxisEdge ( ) ; double xx = domainAxis . valueToJava _NUM D ( x , dataArea , xAxisLocation ) ; double yyLow = rangeAxis . valueToJava _NUM D ( yLow , dataArea , yAxisLocation ) ; double yyHigh = rangeAxis . valueToJava _NUM D ( yHigh , dataArea , yAxisLocation ) ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drState . lowerCoordinates . add ( new double [ ] { yyLow , xx } ) ; drState . upperCoordinates . add ( new double [ ] { yyHigh , xx } ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drState . lowerCoordinates . add ( new double [ ] { xx , yyLow } ) ; drState . upperCoordinates . add ( new double [ ] { xx , yyHigh } ) ; } if ( item = = ( dataset . getItemCount ( series ) - _NUM ) ) { last item in series , draw the lot . . . set up the alpha - transparency . . . Composite originalComposite = g _NUM . getComposite ( ) ; g _NUM . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC _ OVER , this . alpha ) ) ; g _NUM . setPaint ( getItemFillPaint ( series , item ) ) ; GeneralPath area = new GeneralPath ( ) ; double [ ] coords = ( double [ ] ) drState . lowerCoordinates . get ( _NUM ) ; area . moveTo ( ( float ) coords [ _NUM ] , ( float ) coords [ _NUM ] ) ; for ( int i = _NUM ; i < drState . lowerCoordinates . size ( ) ; i + + ) { coords = ( double [ ] ) drState . lowerCoordinates . get ( i ) ; area . lineTo ( ( float ) coords [ _NUM ] , ( float ) coords [ _NUM ] ) ; } int count = drState . upperCoordinates . size ( ) ; coords = ( double [ ] ) drState . upperCoordinates . get ( count - _NUM ) ; area . lineTo ( ( float ) coords [ _NUM ] , ( float ) coords [ _NUM ] ) ; for ( int i = count - _NUM ; i > = _NUM ; i - - ) { coords = ( double [ ] ) drState . upperCoordinates . get ( i ) ; area . lineTo ( ( float ) coords [ _NUM ] , ( float ) coords [ _NUM ] ) ; } area . closePath ( ) ; g _NUM . fill ( area ) ; g _NUM . setComposite ( originalComposite ) ; drState . lowerCoordinates . clear ( ) ; drState . upperCoordinates . clear ( ) ; } } if ( isLinePass ( pass ) ) { all done by code in the super class if ( item = = _NUM ) { State s = ( State ) state ; s . seriesPath . reset ( ) ; s . setLastPointGood ( false ) ; } if ( getItemLineVisible ( series , item ) ) { drawPrimaryLineAsPath ( state , g _NUM , plot , dataset , pass , series , item , domainAxis , rangeAxis , dataArea ) ; } } else second pass adds shapes where the items are . . if ( isItemPass ( pass ) ) { setup for collecting optional entity info . . . EntityCollection entities = null ; if ( info ! = null ) { entities = info . getOwner ( ) . getEntityCollection ( ) ; } drawSecondaryPass ( g _NUM , plot , dataset , pass , series , item , domainAxis , dataArea , rangeAxis , crosshairState , entities ) ; } } 
6143	public void sameTierView ( ) { String tierAlias = mMetaManager . getTiers ( ) . get ( TEST _ TIER _ ORDINAL ) . getTierAlias ( ) ; StorageTierView tierView _NUM = mMetaManagerView . getTierView ( tierAlias ) ; Do some operations on metadata StorageDir dir = mMetaManager . getTiers ( ) . get ( TEST _ TIER _ ORDINAL ) . getDir ( TEST _ DIR ) ; BlockMeta blockMeta = new BlockMeta ( TEST _ BLOCK _ ID , TEST _ BLOCK _ SIZE , dir ) ; try { dir . addBlockMeta ( blockMeta ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } StorageTierView tierView _NUM = new StorageTierView ( mMetaManager . getTier ( tierAlias ) , mMetaManagerView ) ; assertSameTierView ( tierView _NUM , tierView _NUM ) ; } 
6144	public boolean put ( T item , String itemId , int maxWait , TimeUnit unit ) throws Exception { Preconditions . checkArgument ( isValidId ( itemId ) , _STR + itemId ) ; queue . checkState ( ) ; return queue . internalPut ( item , null , makeIdPath ( itemId ) , maxWait , unit ) ; } 
6145	private Placement placeOrWrapBGP ( ExprList exprsIn , BasicPattern pattern ) { if ( includeBGPs ) return placeBGP ( exprsIn , pattern ) ; else return wrapBGP ( exprsIn , pattern ) ; } 
6146	public void saveResultPicture ( long sessionID ) { initSavingPrefs ( ) ; SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( getApplicationContext ( ) ) ; save fused result try { File saveDir = getSaveDir ( false ) ; Calendar d = Calendar . getInstance ( ) ; int imagesAmount = Integer . parseInt ( getFromSharedMem ( _STR ) ; tmpFile . createNewFile ( ) ; copyFromForceFileName ( tmpFile ) ; } if ( ! enableExifTagOrientation ) { Matrix matrix = new Matrix ( ) ; if ( writeOrientationTag & & ( orientation + additionalRotationValue ) ! = _NUM ) { matrix . postRotate ( ( orientation + additionalRotationValue + _NUM _NUM _NUM ) % _NUM _NUM _NUM ) ; rotateImage ( tmpFile , matrix ) ; } else if ( ! writeOrientationTag & & additionalRotationValue ! = _NUM ) { matrix . postRotate ( ( additionalRotationValue + _NUM _NUM _NUM ) % _NUM _NUM _NUM ) ; rotateImage ( tmpFile , matrix ) ; } } if ( useGeoTaggingPrefExport ) { Location l = MLocation . getLocation ( getApplicationContext ( ) ) ; if ( l ! = null ) { double lat = l . getLatitude ( ) ; double lon = l . getLongitude ( ) ; boolean hasLatLon = ( lat ! = _NUM . _NUM d ) | | ( lon ! = _NUM . _NUM d ) ; if ( hasLatLon ) { values . put ( ImageColumns . LATITUDE , l . getLatitude ( ) ) ; values . put ( ImageColumns . LONGITUDE , l . getLongitude ( ) ) ; } } } File modifiedFile = saveExifTags ( tmpFile , sessionID , i , x , y , exif _ orientation , useGeoTaggingPrefExport , enableExifTagOrientation ) ; if ( ApplicationScreen . getForceFilename ( ) = = null ) { file . delete ( ) ; modifiedFile . renameTo ( file ) ; } else { copyToForceFileName ( modifiedFile ) ; tmpFile . delete ( ) ; modifiedFile . delete ( ) ; } Uri uri = getApplicationContext ( ) . getContentResolver ( ) . insert ( Images . Media . EXTERNAL _ CONTENT _ URI , values ) ; broadcastNewPicture ( uri ) ; } ApplicationScreen . getMessageHandler ( ) . sendEmptyMessage ( ApplicationInterface . MSG _ EXPORT _ FINISHED ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; ApplicationScreen . getMessageHandler ( ) . sendEmptyMessage ( ApplicationInterface . MSG _ EXPORT _ FINISHED _ IOEXCEPTION ) ; return ; } catch ( Exception e ) { e . printStackTrace ( ) ; ApplicationScreen . getMessageHandler ( ) . sendEmptyMessage ( ApplicationInterface . MSG _ EXPORT _ FINISHED ) ; } finally { ApplicationScreen . setForceFilename ( null ) ; } } 
6147	Node getLeaf ( int leafIndex , Node excludedNode ) { int count = _NUM ; check if the excluded node a leaf boolean isLeaf = excludedNode = = null | | ! ( excludedNode instanceof InnerNode ) ; calculate the total number of excluded leaf nodes int numOfExcludedLeaves = isLeaf ? _NUM : ( ( InnerNode ) excludedNode ) . getNumOfLeaves ( ) ; if ( isLeafParent ( ) ) { children are leaves if ( isLeaf ) { excluded node is a leaf node if ( excludedNode ! = null & & childrenMap . containsKey ( excludedNode . getName ( ) ) ) { int excludedIndex = children . indexOf ( excludedNode ) ; if ( excludedIndex ! = - _NUM & & leafIndex > = _NUM ) { excluded node is one of the children so adjust the leaf index leafIndex = leafIndex > = excludedIndex ? leafIndex + _NUM : leafIndex ; } } } range check if ( leafIndex < _NUM | | leafIndex > = this . getNumOfChildren ( ) ) { return null ; } return children . get ( leafIndex ) ; } else { for ( int i = _NUM ; i < children . size ( ) ; i + + ) { InnerNode child = ( InnerNode ) children . get ( i ) ; if ( excludedNode = = null | | excludedNode ! = child ) { not the excludedNode int numOfLeaves = child . getNumOfLeaves ( ) ; if ( excludedNode ! = null & & child . isAncestor ( excludedNode ) ) { numOfLeaves - = numOfExcludedLeaves ; } if ( count + numOfLeaves > leafIndex ) { the leaf is in the child subtree return child . getLeaf ( leafIndex - count , excludedNode ) ; } else { go to the next child count = count + numOfLeaves ; } } else { it is the excluededNode skip it and set the excludedNode to be null excludedNode = null ; } } return null ; } } 
6148	public void actionPerformed ( ActionEvent e ) { Sanity check - should have > _NUM parser if event is fired . int parserCount = getParserCount ( ) ; if ( parserCount = = _NUM ) { return ; } long begin = _NUM ; if ( DEBUG _ PARSING ) { begin = System . currentTimeMillis ( ) ; } RSyntaxDocument doc = ( RSyntaxDocument ) textArea . getDocument ( ) ; Element root = doc . getDefaultRootElement ( ) ; int firstLine = firstOffsetModded = = null ? _NUM : root . getElementIndex ( firstOffsetModded . getOffset ( ) ) ; int lastLine = lastOffsetModded = = null ? root . getElementCount ( ) - _NUM : root . getElementIndex ( lastOffsetModded . getOffset ( ) ) ; firstOffsetModded = lastOffsetModded = null ; if ( DEBUG _ PARSING ) { System . out . println ( _STR ) ; } } 
6149	public void afterRequest ( final String uriPath , final String method , final Set < NodeResponse > nodeResponses ) { as the cluster coordinator is responsible for performing the actual request replication . if ( ! isActiveClusterCoordinator ( ) ) { return ; } final boolean mutableRequest = isMutableRequest ( method ) ; if ( mutableRequest ) { final HttpResponseMapper responseMerger = new StandardHttpResponseMapper ( nifiProperties ) ; final Set < NodeResponse > problematicNodeResponses = responseMerger . getProblematicNodeResponses ( nodeResponses ) ; all nodes failed final boolean allNodesFailed = problematicNodeResponses . size ( ) = = nodeResponses . size ( ) ; some nodes had a problematic response because of a missing counter , ensure the are not disconnected final boolean someNodesFailedMissingCounter = ! problematicNodeResponses . isEmpty ( ) & & problematicNodeResponses . size ( ) < nodeResponses . size ( ) & & isMissingCounter ( problematicNodeResponses , uriPath ) ; ensure nodes stay connected in certain scenarios if ( allNodesFailed ) { logger . warn ( _STR + uriPath ) ; } } } } 
6150	public APIprotected static String [ ] splitKeyValue ( String keyValueLine ) { String line = StringUtils . clean ( keyValueLine ) ; if ( line = = null ) { return null ; } StringBuilder keyBuffer = new StringBuilder ( ) ; StringBuilder valueBuffer = new StringBuilder ( ) ; we ' ll build the value next : boolean buildingKey = true ; for ( int i = _NUM ; i < line . length ( ) ; i + + ) { char c = line . charAt ( i ) ; if ( buildingKey ) { if ( isKeyValueSeparatorChar ( c ) & & ! isCharEscaped ( line , i ) ) { now start building the value buildingKey = false ; } else { keyBuffer . append ( c ) ; } } else { if ( valueBuffer . length ( ) = = _NUM & & isKeyValueSeparatorChar ( c ) & & ! isCharEscaped ( line , i ) ) { swallow the separator chars before we start building the value } else { valueBuffer . append ( c ) ; } } } String key = StringUtils . clean ( keyBuffer . toString ( ) ) ; String value = StringUtils . clean ( valueBuffer . toString ( ) ) ; if ( key = = null | | value = = null ) { String msg = _STR , key , value ) ; return new String [ ] { key , value } ; } 
6151	public static KeyRange convertToInclusiveExclusiveRange ( KeyRange partialRange , RowKeySchema schema , ImmutableBytesWritable ptr ) { Ensure minMaxRange is lower inclusive and upper exclusive , as that ' s what we need to intersect against for the HBase scan . byte [ ] lowerRange = partialRange . getLowerRange ( ) ; if ( ! partialRange . lowerUnbound ( ) ) { if ( ! partialRange . isLowerInclusive ( ) ) { lowerRange = ScanUtil . nextKey ( lowerRange , schema , ptr ) ; } } byte [ ] upperRange = partialRange . getUpperRange ( ) ; if ( ! partialRange . upperUnbound ( ) ) { if ( partialRange . isUpperInclusive ( ) ) { upperRange = ScanUtil . nextKey ( upperRange , schema , ptr ) ; } } if ( partialRange . getLowerRange ( ) ! = lowerRange | | partialRange . getUpperRange ( ) ! = upperRange ) { partialRange = KeyRange . getKeyRange ( lowerRange , upperRange ) ; } return partialRange ; } 
6152	public boolean isUserLoggedIn ( ) { if ( isNativeLoginSupported ( ) ) { return nativeIsLoggedIn ( ) ; } else { return token ! = null ; } } 
6153	public static Matrix readMatrix ( DataInput in ) throws IOException { int flags = in . readInt ( ) ; Preconditions . checkArgument ( flags > > NUM _ FLAGS = = _NUM , _STR , Integer . toString ( flags , _NUM ) ) ; boolean dense = ( flags & FLAG _ DENSE ) ! = _NUM ; boolean sequential = ( flags & FLAG _ SEQUENTIAL ) ! = _NUM ; boolean hasLabels = ( flags & FLAG _ LABELS ) ! = _NUM ; boolean isSparseRowMatrix = ( flags & FLAG _ SPARSE _ ROW ) ! = _NUM ; int rows = in . readInt ( ) ; int columns = in . readInt ( ) ; byte vectorFlags = in . readByte ( ) ; Matrix matrix ; if ( dense ) { matrix = new DenseMatrix ( rows , columns ) ; for ( int row = _NUM ; row < rows ; row + + ) { matrix . assignRow ( row , VectorWritable . readVector ( in , vectorFlags , columns ) ) ; } } else if ( isSparseRowMatrix ) { Vector [ ] rowVectors = new Vector [ rows ] ; for ( int row = _NUM ; row < rows ; row + + ) { rowVectors [ row ] = VectorWritable . readVector ( in , vectorFlags , columns ) ; } matrix = new SparseRowMatrix ( rows , columns , rowVectors , true , ! sequential ) ; } else { matrix = new SparseMatrix ( rows , columns ) ; int numNonZeroRows = in . readInt ( ) ; int rowsRead = _NUM ; while ( rowsRead + + < numNonZeroRows ) { int rowIndex = in . readInt ( ) ; matrix . assignRow ( rowIndex , VectorWritable . readVector ( in , vectorFlags , columns ) ) ; } } if ( hasLabels ) { Map < String , Integer > columnLabelBindings = new HashMap < > ( ) ; Map < String , Integer > rowLabelBindings = new HashMap < > ( ) ; readLabels ( in , columnLabelBindings , rowLabelBindings ) ; if ( ! columnLabelBindings . isEmpty ( ) ) { matrix . setColumnLabelBindings ( columnLabelBindings ) ; } if ( ! rowLabelBindings . isEmpty ( ) ) { matrix . setRowLabelBindings ( rowLabelBindings ) ; } } return matrix ; } 
6154	public boolean removeAutomaticZenRules ( String packageName ) { INotificationManager service = getService ( ) ; try { return service . removeAutomaticZenRules ( packageName ) ; } catch ( RemoteException e ) { throw e . rethrowFromSystemServer ( ) ; } } 
6155	public void centerHorizontally ( int top ) { show ( ) ; int left = ( Window . getClientWidth ( ) - getOffsetWidth ( ) ) > > _NUM ; setPopupPosition ( Math . max ( Window . getScrollLeft ( ) + left , _NUM ) , Math . max ( Window . getScrollTop ( ) + top , _NUM ) ) ; } 
6156	public static String [ ] toHanyuPinyinStringArray ( char ch ) { return getUnformattedHanyuPinyinStringArray ( ch ) ; } 
6157	public void setBaseSeriesOutlinePaint ( Paint paint ) { if ( paint = = null ) { throw new IllegalArgumentException ( _STR ) ; } this . baseSeriesOutlinePaint = paint ; fireChangeEvent ( ) ; } 
6158	 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - static String format ( final Token [ ] tokens , final long years , final long months , final long days , final long hours , final long minutes , final long seconds , final long milliseconds , final boolean padWithZeros ) { final StringBuilder buffer = new StringBuilder ( ) ; boolean lastOutputSeconds = false ; for ( final Token token : tokens ) { final Object value = token . getValue ( ) ; final int count = token . getCount ( ) ; if ( value instanceof StringBuilder ) { buffer . append ( value . toString ( ) ) ; } else { if ( value . equals ( y ) ) { buffer . append ( paddedValue ( years , padWithZeros , count ) ) ; lastOutputSeconds = false ; } else if ( value . equals ( M ) ) { buffer . append ( paddedValue ( months , padWithZeros , count ) ) ; lastOutputSeconds = false ; } else if ( value . equals ( d ) ) { buffer . append ( paddedValue ( days , padWithZeros , count ) ) ; lastOutputSeconds = false ; } else if ( value . equals ( H ) ) { buffer . append ( paddedValue ( hours , padWithZeros , count ) ) ; lastOutputSeconds = false ; } else if ( value . equals ( m ) ) { buffer . append ( paddedValue ( minutes , padWithZeros , count ) ) ; lastOutputSeconds = false ; } else if ( value . equals ( s ) ) { buffer . append ( paddedValue ( seconds , padWithZeros , count ) ) ; lastOutputSeconds = true ; } else if ( value . equals ( S ) ) { if ( lastOutputSeconds ) { ensure at least _NUM digits are displayed even if padding is not selected final int width = padWithZeros ? Math . max ( _NUM , count ) : _NUM ; buffer . append ( paddedValue ( milliseconds , true , width ) ) ; } else { buffer . append ( paddedValue ( milliseconds , padWithZeros , count ) ) ; } lastOutputSeconds = false ; } } } return buffer . toString ( ) ; } 
6159	public Number getStartValue ( Comparable rowKey , Comparable columnKey , int subinterval ) { int r = getRowIndex ( rowKey ) ; int c = getColumnIndex ( columnKey ) ; if ( c ! = - _NUM ) { return this . underlying . getStartValue ( r , c + this . firstCategoryIndex , subinterval ) ; } else { throw new UnknownKeyException ( _STR + columnKey ) ; } } 
6160	public void testReadLattice ( ) throws IOException { final ObjectMapper mapper = mapper ( ) ; JsonRoot root = mapper . readValue ( _STR ) ) ; } 
6161	public boolean performAccessibilityActionInternal ( int action , Bundle arguments ) { if ( mEditor ! = null & & mEditor . mProcessTextIntentActionsHandler . performAccessibilityAction ( action ) ) { return true ; } switch ( action ) { case AccessibilityNodeInfo . ACTION _ CLICK : { return performAccessibilityActionClick ( arguments ) ; } case AccessibilityNodeInfo . ACTION _ COPY : { if ( isFocused ( ) & & canCopy ( ) ) { if ( onTextContextMenuItem ( ID _ COPY ) ) { return true ; } } } return false ; case AccessibilityNodeInfo . ACTION _ PASTE : { if ( isFocused ( ) & & canPaste ( ) ) { if ( onTextContextMenuItem ( ID _ PASTE ) ) { return true ; } } } return false ; case AccessibilityNodeInfo . ACTION _ CUT : { if ( isFocused ( ) & & canCut ( ) ) { if ( onTextContextMenuItem ( ID _ CUT ) ) { return true ; } } } return false ; case AccessibilityNodeInfo . ACTION _ SET _ SELECTION : { ensureIterableTextForAccessibilitySelectable ( ) ; CharSequence text = getIterableTextForAccessibility ( ) ; if ( text = = null ) { return false ; } final int start = ( arguments ! = null ) ? arguments . getInt ( AccessibilityNodeInfo . ACTION _ ARGUMENT _ SELECTION _ START _ INT , - _NUM ) : - _NUM ; final int end = ( arguments ! = null ) ? arguments . getInt ( AccessibilityNodeInfo . ACTION _ ARGUMENT _ SELECTION _ END _ INT , - _NUM ) : - _NUM ; if ( ( getSelectionStart ( ) ! = start | | getSelectionEnd ( ) ! = end ) ) { No arguments clears the selection . if ( start = = end & & end = = - _NUM ) { Selection . removeSelection ( ( Spannable ) text ) ; return true ; } if ( start > = _NUM & & start < = end & & end < = text . length ( ) ) { Selection . setSelection ( ( Spannable ) text , start , end ) ; Make sure selection mode is engaged . if ( mEditor ! = null ) { mEditor . startSelectionActionModeAsync ( false ) ; } return true ; } } } return false ; case AccessibilityNodeInfo . ACTION _ NEXT _ AT _ MOVEMENT _ GRANULARITY : case AccessibilityNodeInfo . ACTION _ PREVIOUS _ AT _ MOVEMENT _ GRANULARITY : { ensureIterableTextForAccessibilitySelectable ( ) ; return super . performAccessibilityActionInternal ( action , arguments ) ; } case ACCESSIBILITY _ ACTION _ SHARE : { if ( isFocused ( ) & & canShare ( ) ) { if ( onTextContextMenuItem ( ID _ SHARE ) ) { return true ; } } } return false ; case AccessibilityNodeInfo . ACTION _ SET _ TEXT : { if ( ! isEnabled ( ) | | ( mBufferType ! = BufferType . EDITABLE ) ) { return false ; } CharSequence text = ( arguments ! = null ) ? arguments . getCharSequence ( AccessibilityNodeInfo . ACTION _ ARGUMENT _ SET _ TEXT _ CHARSEQUENCE ) : null ; setText ( text ) ; if ( mText ! = null ) { int updatedTextLength = mText . length ( ) ; if ( updatedTextLength > _NUM ) { Selection . setSelection ( ( Spannable ) mText , updatedTextLength ) ; } } } return true ; default : { return super . performAccessibilityActionInternal ( action , arguments ) ; } } } 
6162	These methods are called by HadoopFS clients * Set permissions for an existing file . * @ throws IOException * / void setPermission ( String src , FsPermission permission ) throws IOException { HdfsFileStatus auditStat ; checkOperation ( OperationCategory . WRITE ) ; writeLock ( ) ; try { checkOperation ( OperationCategory . WRITE ) ; checkNameNodeSafeMode ( _STR , src , null , auditStat ) ; } 
6163	public char readChar ( ) throws java . io . IOException { if ( inBuf > _NUM ) { - - inBuf ; if ( + + bufpos = = bufsize ) bufpos = _NUM ; return buffer [ bufpos ] ; } char c ; if ( + + bufpos = = available ) AdjustBuffSize ( ) ; if ( ( buffer [ bufpos ] = c = ReadByte ( ) ) = = ' \ \ ' ) { UpdateLineColumn ( c ) ; int backSlashCnt = _NUM ; for ( ; ; ) Read all the backslashes { if ( + + bufpos = = available ) AdjustBuffSize ( ) ; try { if ( ( buffer [ bufpos ] = c = ReadByte ( ) ) ! = ' \ \ ' ) { UpdateLineColumn ( c ) ; found a non - backslash char . if ( ( c = = ' u ' ) & & ( ( backSlashCnt & _NUM ) = = _NUM ) ) { if ( - - bufpos < _NUM ) bufpos = bufsize - _NUM ; break ; } backup ( backSlashCnt ) ; return ' \ \ ' ; } } catch ( java . io . IOException e ) { We are returning one backslash so we should only backup ( count - _NUM ) if ( backSlashCnt > _NUM ) backup ( backSlashCnt - _NUM ) ; return ' \ \ ' ; } UpdateLineColumn ( c ) ; backSlashCnt + + ; } Here , we have seen an odd number of backslash ' s followed by a ' u ' try { while ( ( c = ReadByte ( ) ) = = ' u ' ) + + column ; buffer [ bufpos ] = c = ( char ) ( hexval ( c ) < < _NUM _NUM | hexval ( ReadByte ( ) ) < < _NUM | hexval ( ReadByte ( ) ) < < _NUM | hexval ( ReadByte ( ) ) ) ; column + = _NUM ; } catch ( java . io . IOException e ) { throw new Error ( _STR ) ; } if ( backSlashCnt = = _NUM ) return c ; else { backup ( backSlashCnt - _NUM ) ; return ' \ \ ' ; } } else { UpdateLineColumn ( c ) ; return c ; } } 
6164	private static InetAddressAndPort findSuitableEndpoint ( String keyspaceName , DecoratedKey key , String localDataCenter , ConsistencyLevel cl ) throws UnavailableException { Keyspace keyspace = Keyspace . open ( keyspaceName ) ; IEndpointSnitch snitch = DatabaseDescriptor . getEndpointSnitch ( ) ; List < InetAddressAndPort > endpoints = new ArrayList < > ( ) ; StorageService . instance . getLiveNaturalEndpoints ( keyspace , key , endpoints ) ; CASSANDRA - _NUM _NUM _NUM _NUM _NUM : filter out those endpoints not accepting clients yet , maybe because still bootstrapping endpoints . removeIf ( endpoint - > ! StorageService . instance . isRpcReady ( endpoint ) ) ; TODO have a way to compute the consistency level if ( endpoints . isEmpty ( ) ) throw new UnavailableException ( cl , cl . blockFor ( keyspace ) , _NUM ) ; List < InetAddressAndPort > localEndpoints = new ArrayList < > ( endpoints . size ( ) ) ; for ( InetAddressAndPort endpoint : endpoints ) if ( snitch . getDatacenter ( endpoint ) . equals ( localDataCenter ) ) localEndpoints . add ( endpoint ) ; if ( localEndpoints . isEmpty ( ) ) { If the consistency required is local then we should not involve other DCs if ( cl . isDatacenterLocal ( ) ) throw new UnavailableException ( cl , cl . blockFor ( keyspace ) , _NUM ) ; No endpoint in local DC , pick the closest endpoint according to the snitch snitch . sortByProximity ( FBUtilities . getBroadcastAddressAndPort ( ) , endpoints ) ; return endpoints . get ( _NUM ) ; } return localEndpoints . get ( ThreadLocalRandom . current ( ) . nextInt ( localEndpoints . size ( ) ) ) ; } 
6165	public static XmlENTITY parse ( java . lang . String s ) throws org . apache . xmlbeans . XmlException { return ( XmlENTITY ) XmlBeans . getContextTypeLoader ( ) . parse ( s , type , null ) ; } 
6166	public final TestSuiteBuilder includeAllPackagesUnderHere ( ) { StackTraceElement [ ] stackTraceElements = Thread . currentThread ( ) . getStackTrace ( ) ; String callingClassName = null ; String thisClassName = TestSuiteBuilder . class . getName ( ) ; should be one level below this class in the stack trace . for ( int i = _NUM ; i < stackTraceElements . length ; i + + ) { StackTraceElement element = stackTraceElements [ i ] ; if ( thisClassName . equals ( element . getClassName ( ) ) & & _STR . equals ( element . getMethodName ( ) ) ) { We ' ve found this class in the call stack . The calling class must be the next class in the stack . callingClassName = stackTraceElements [ i + _NUM ] . getClassName ( ) ; break ; } } String packageName = parsePackageNameFromClassName ( callingClassName ) ; return includePackages ( packageName ) ; } 
6167	static int convertUnitsOrPercentage ( String units , int defaultSuffix ) { if ( units = = null ) { return - _NUM ; } boolean percentage = false ; if ( units . charAt ( units . length ( ) - _NUM ) = = ' % ' ) { percentage = true ; for percentage , the number without the % is sent and needs to stay as is ( factor = _NUM ) defaultSuffix = LENGTH _ SUFFIX _ PX ; units = units . substring ( _NUM , units . length ( ) - _NUM ) ; } int val = convertUnits ( units , defaultSuffix ) ; if ( percentage ) { val + = VAL _ PERCENTAGE ; } return val ; } 
6168	private boolean isInActiveGroup ( ITestNGMethod method , ITestContext context ) { String [ ] includedGroupsArray = context . getIncludedGroups ( ) ; List < String > includeGroups = includedGroupsArray ! = null ? asList ( includedGroupsArray ) : Collections . < String > emptyList ( ) ; String [ ] excludedGroupsArray = context . getExcludedGroups ( ) ; List < String > excludeGroups = excludedGroupsArray ! = null ? asList ( excludedGroupsArray ) : Collections . < String > emptyList ( ) ; if ( includeGroups . isEmpty ( ) ) { if ( excludeGroups . isEmpty ( ) ) { no group restriction return true ; } else { return isInActiveGroupWithoutIncludes ( method , excludeGroups ) ; } } else { return isInActiveGroupWithIncludes ( method , includeGroups , excludeGroups ) ; } } 
6169	public void addWindow ( View view , String name ) { mWindowsLock . writeLock ( ) . lock ( ) ; try { mWindows . put ( view . getRootView ( ) , name ) ; } finally { mWindowsLock . writeLock ( ) . unlock ( ) ; } fireWindowsChangedEvent ( ) ; } 
6170	public static void releaseAllContexts ( ) { ArrayList < RenderScript > oldList ; synchronized ( mProcessContextList ) { oldList = mProcessContextList ; mProcessContextList = new ArrayList < RenderScript > ( ) ; } for ( RenderScript prs : oldList ) { prs . mIsProcessContext = false ; prs . destroy ( ) ; } oldList . clear ( ) ; } 
6171	private Map < String , Object > checkAuth ( String localName , Map < String , Object > context , ModelService origService ) throws ServiceAuthException , GenericServiceException { String service = null ; try { service = ServiceConfigUtil . getServiceEngine ( ) . getAuthorization ( ) . getServiceName ( ) ; } catch ( GenericConfigException e ) { throw new GenericServiceException ( e . getMessage ( ) , e ) ; } if ( service = = null ) { throw new GenericServiceException ( _STR ) ; } } return context ; } 
6172	public static final Font getDefaultFont ( ) { Use StyleContext to get a composite font for better Asian language support ; see Sun bug S _NUM _NUM _NUM _NUM _NUM _NUM . StyleContext sc = StyleContext . getDefaultStyleContext ( ) ; Font font = null ; if ( isOSX ( ) ) { Snow Leopard ( _NUM . _NUM ) uses Menlo as default monospaced font , pre - Snow Leopard used Monaco . font = sc . getFont ( _STR + font . getName ( ) ) ; return font ; } 
6173	public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( _STR ) ; return sb . toString ( ) ; } 
6174	public static void setOutputPath ( JobConf conf , Path outputDir ) { outputDir = new Path ( conf . getWorkingDirectory ( ) , outputDir ) ; conf . set ( org . apache . hadoop . mapreduce . lib . output . FileOutputFormat . OUTDIR , outputDir . toString ( ) ) ; } 
6175	private TaskAttempt selectBestAttempt ( ) { if ( successfulAttempt ! = null ) { return attempts . get ( successfulAttempt ) ; } float progress = _NUM f ; TaskAttempt result = null ; for ( TaskAttempt at : attempts . values ( ) ) { switch ( at . getState ( ) ) { ignore all failed task attempts case FAILED : case KILLED : continue ; } if ( result = = null ) { The first time around result = at ; } calculate the best progress float attemptProgress = at . getProgress ( ) ; if ( attemptProgress > progress ) { result = at ; progress = attemptProgress ; } } return result ; } 
6176	boolean shrink ( ) throws IllegalInstructionException { if ( mTargetLabel = = null ) { return false ; } int oldSize = size ( ) ; int oldTargetLabelSize = mTargetLabelSize ; mTargetLabelSize = calculateImmSize ( calculateTargetLabelOffset ( ) , false ) ; if ( mTargetLabelSize > oldTargetLabelSize ) { throw new IllegalStateException ( _STR ) ; } return size ( ) < oldSize ; } 
6177	public synchronized long obtainSnapshotTimestamp ( ) { final AbstractTransactionalContext atc = getRootContext ( ) ; if ( atc ! = null & & atc ! = this ) { needs to come from the root . return atc . getSnapshotTimestamp ( ) ; } else { Otherwise , fetch a read token from the sequencer the linearize ourselves against . long currentTail = builder . runtime . getSequencerView ( ) . nextToken ( Collections . emptySet ( ) , _NUM ) . getToken ( ) . getTokenValue ( ) ; log . trace ( _STR , this , currentTail ) ; return currentTail ; } } 
6178	public Builder clearChild ( ) { if ( childBuilder _ = = null ) { child _ = java . util . Collections . emptyList ( ) ; bitField _NUM _ = ( bitField _NUM _ & ~ _NUM x _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM ) ; onChanged ( ) ; } else { childBuilder _ . clear ( ) ; } return this ; } 
6179	private void repaintLine ( LineHighlightInfo lhi ) { int offs = lhi . getOffset ( ) ; May be > length if they deleted text including the highlight if ( offs > = _NUM & & offs < = textArea . getDocument ( ) . getLength ( ) ) { try { int y = textArea . yForLineContaining ( offs ) ; if ( y > - _NUM ) { textArea . repaint ( _NUM , y , textArea . getWidth ( ) , textArea . getLineHeight ( ) ) ; } } catch ( BadLocationException ble ) { Never happens ble . printStackTrace ( ) ; } } } 
6180	public synchronized void storeChannelInWallet ( Sha _NUM _NUM _NUM Hash id ) { stateMachine . checkState ( State . SAVE _ STATE _ IN _ WALLET ) ; checkState ( id ! = null ) ; if ( storedChannel ! = null ) { checkState ( storedChannel . id . equals ( id ) ) ; return ; } doStoreChannelInWallet ( id ) ; try { wallet . commitTx ( getContractInternal ( ) ) ; } catch ( VerificationException e ) { We created it throw new RuntimeException ( e ) ; } stateMachine . transition ( State . PROVIDE _ MULTISIG _ CONTRACT _ TO _ SERVER ) ; } 
6181	protected void after ( ) { stop ( ) ; } 
6182	public HSSFCellStyle createCellStyle ( ) { if ( workbook . getNumExFormats ( ) = = MAX _ STYLES ) { throw new IllegalStateException ( _STR ) ; } ExtendedFormatRecord xfr = workbook . createCellXF ( ) ; short index = ( short ) ( getNumCellStyles ( ) - _NUM ) ; return new HSSFCellStyle ( index , xfr , this ) ; } 
6183	public void reportGeofenceMonitorStatus ( int monitoringType , int monitoringStatus , Location location , int source ) { setMonitorAvailability ( monitoringType , monitoringStatus ) ; acquireWakeLock ( ) ; GeofenceHardwareMonitorEvent event = new GeofenceHardwareMonitorEvent ( monitoringType , monitoringStatus , source , location ) ; Message message = mCallbacksHandler . obtainMessage ( GEOFENCE _ STATUS , event ) ; message . sendToTarget ( ) ; } 
6184	public boolean isUnderReplicated ( ) { try { int numBlocks = getNumCurrentReplicas ( ) ; if ( numBlocks = = - _NUM ) { return false ; } int desiredBlocks ; if ( configuredMinReplicas ! = null ) { desiredBlocks = configuredMinReplicas ; } else { desiredBlocks = getFsDesiredReplication ( ) ; } return numBlocks < desiredBlocks ; } catch ( IllegalAccessException e ) { logger . error ( _STR , e ) ; } return false ; } 
6185	boolean onTaskStackBoundsChanged ( Rect targetBounds , Rect outBounds ) { synchronized ( mService . mWindowMap ) { final DisplayInfo displayInfo = mDisplayContent . getDisplayInfo ( ) ; if ( mDisplayInfo . equals ( displayInfo ) ) { We are already in the right orientation , ignore outBounds . setEmpty ( ) ; return false ; } else if ( targetBounds . isEmpty ( ) ) { The stack is null , we are just initializing the stack , so just store the display info and ignore mDisplayInfo . copyFrom ( displayInfo ) ; outBounds . setEmpty ( ) ; return false ; } mTmpRect . set ( targetBounds ) ; final Rect postChangeStackBounds = mTmpRect ; Calculate the snap fraction of the current stack along the old movement bounds final Rect preChangeMovementBounds = getMovementBounds ( postChangeStackBounds ) ; final float snapFraction = mSnapAlgorithm . getSnapFraction ( postChangeStackBounds , preChangeMovementBounds ) ; mDisplayInfo . copyFrom ( displayInfo ) ; Calculate the stack bounds in the new orientation to the same same fraction along the rotated movement bounds . final Rect postChangeMovementBounds = getMovementBounds ( postChangeStackBounds , false ) ; mSnapAlgorithm . applySnapFraction ( postChangeStackBounds , postChangeMovementBounds , snapFraction ) ; if ( mIsMinimized ) { applyMinimizedOffset ( postChangeStackBounds , postChangeMovementBounds ) ; } notifyMovementBoundsChanged ( false ) ; outBounds . set ( postChangeStackBounds ) ; return true ; } } 
6186	public final void dispatchOnGlobalLayout ( ) { NOTE : because of the use of CopyOnWriteArrayList , we * must * use an iterator to perform the dispatching . The iterator is a safe guard against listeners that could mutate the list by calling the various add / remove methods . This prevents the array from being modified while we iterate it . final CopyOnWriteArray < OnGlobalLayoutListener > listeners = mOnGlobalLayoutListeners ; if ( listeners ! = null & & listeners . size ( ) > _NUM ) { CopyOnWriteArray . Access < OnGlobalLayoutListener > access = listeners . start ( ) ; try { int count = access . size ( ) ; for ( int i = _NUM ; i < count ; i + + ) { access . get ( i ) . onGlobalLayout ( ) ; } } finally { listeners . end ( ) ; } } } 
6187	public void setSectionOutlinePaint ( Paint paint ) { this . sectionOutlinePaint = paint ; fireChangeEvent ( ) ; } 
6188	public void queryNoResult ( ) throws IOException { try ( Query query = session . query ( _STR , query . more ( ) ) ; } } 
6189	protected void addOrReplaceUrlNameMapping ( CmsDbContext dbc , String name , CmsUUID structureId , String locale ) throws CmsDataAccessException { getVfsDriver ( dbc ) . deleteUrlNameMappingEntries ( dbc , false , CmsUrlNameMappingFilter . ALL . filterStructureId ( structureId ) . filterLocale ( locale ) . filterState ( CmsUrlNameMappingEntry . MAPPING _ STATUS _ NEW ) ) ; CmsUrlNameMappingEntry newEntry = new CmsUrlNameMappingEntry ( name , structureId , CmsUrlNameMappingEntry . MAPPING _ STATUS _ NEW , System . currentTimeMillis ( ) , locale ) ; getVfsDriver ( dbc ) . addUrlNameMappingEntry ( dbc , false , newEntry ) ; } 
6190	 $ ANTLR start _STR , _NUM _NUM , _NUM , input ) ; throw nvae ; } switch ( alt _NUM _NUM ) { case _NUM : JPA . g : _NUM _NUM _NUM : _NUM : datetime _ primary { root _ _NUM = ( Object ) adaptor . nil ( ) ; pushFollow ( FOLLOW _ datetime _ primary _ in _ datetime _ expression _NUM _NUM _NUM _NUM ) ; datetime _ primary _NUM _NUM _NUM = datetime _ primary ( ) ; state . _ fsp - - ; if ( state . failed ) return retval ; if ( state . backtracking = = _NUM ) adaptor . addChild ( root _ _NUM , datetime _ primary _NUM _NUM _NUM . getTree ( ) ) ; } break ; case _NUM : JPA . g : _NUM _NUM _NUM : _NUM : subquery { root _ _NUM = ( Object ) adaptor . nil ( ) ; pushFollow ( FOLLOW _ subquery _ in _ datetime _ expression _NUM _NUM _NUM _NUM ) ; subquery _NUM _NUM _NUM = subquery ( ) ; state . _ fsp - - ; if ( state . failed ) return retval ; if ( state . backtracking = = _NUM ) adaptor . addChild ( root _ _NUM , subquery _NUM _NUM _NUM . getTree ( ) ) ; } break ; } retval . stop = input . LT ( - _NUM ) ; if ( state . backtracking = = _NUM ) { retval . tree = ( Object ) adaptor . rulePostProcessing ( root _ _NUM ) ; adaptor . setTokenBoundaries ( retval . tree , retval . start , retval . stop ) ; } } catch ( RecognitionException re ) { reportError ( re ) ; recover ( input , re ) ; retval . tree = ( Object ) adaptor . errorNode ( input , retval . start , input . LT ( - _NUM ) , re ) ; } finally { } return retval ; } 
6191	private void updateHourFormat ( ) { final String bestDateTimePattern = DateFormat . getBestDateTimePattern ( mLocale , mIs _NUM _NUM Hour ? _STR ) ; final int lengthPattern = bestDateTimePattern . length ( ) ; boolean showLeadingZero = false ; char hourFormat = ' \ _NUM ' ; for ( int i = _NUM ; i < lengthPattern ; i + + ) { final char c = bestDateTimePattern . charAt ( i ) ; if ( c = = ' H ' | | c = = ' h ' | | c = = ' K ' | | c = = ' k ' ) { hourFormat = c ; if ( i + _NUM < lengthPattern & & c = = bestDateTimePattern . charAt ( i + _NUM ) ) { showLeadingZero = true ; } break ; } } mHourFormatShowLeadingZero = showLeadingZero ; mHourFormatStartsAtZero = hourFormat = = ' K ' | | hourFormat = = ' H ' ; Update hour text field . final int minHour = mHourFormatStartsAtZero ? _NUM : _NUM ; final int maxHour = ( mIs _NUM _NUM Hour ? _NUM _NUM : _NUM _NUM ) + minHour ; mHourView . setRange ( minHour , maxHour ) ; mHourView . setShowLeadingZeroes ( mHourFormatShowLeadingZero ) ; final String [ ] digits = DecimalFormatSymbols . getInstance ( mLocale ) . getDigitStrings ( ) ; int maxCharLength = _NUM ; for ( int i = _NUM ; i < _NUM _NUM ; i + + ) { maxCharLength = Math . max ( maxCharLength , digits [ i ] . length ( ) ) ; } mTextInputPickerView . setHourFormat ( maxCharLength * _NUM ) ; } 
6192	public static XmlAnyURI parse ( java . io . Reader r ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( XmlAnyURI ) XmlBeans . getContextTypeLoader ( ) . parse ( r , type , null ) ; } 
6193	private Drawable getDrawableFromResourceValue ( String drawableId ) { if ( drawableId = = null | | drawableId . isEmpty ( ) | | _STR + drawableId ) ; return null ; } } 
6194	private static KeyStore createTrustStore ( final InputStream is , String type ) throws IOException , CertificateException , KeyStoreException , NoSuchAlgorithmException { final Collection < ? extends Certificate > certs = loadCertificates ( is ) ; final KeyStore keyStore = KeyStore . getInstance ( type ) ; keyStore . load ( null , null ) ; for ( Certificate cert : certs ) { final X _NUM _NUM _NUM Certificate xcert = ( X _NUM _NUM _NUM Certificate ) cert ; keyStore . setCertificateEntry ( xcert . getSubjectX _NUM _NUM _NUM Principal ( ) . getName ( ) , cert ) ; } return keyStore ; } 
6195	 $ ANTLR start _STR , retval ! = null ? retval . getTree ( ) : null ) ; root _ _NUM = ( Object ) adaptor . nil ( ) ; _NUM _NUM _NUM : _NUM : - > ^ ( T _ SOURCES [ $ fr ] identification _ variable _ declaration ) { JPA _NUM . g : _NUM _NUM _NUM : _NUM : ^ ( T _ SOURCES [ $ fr ] identification _ variable _ declaration ) { Object root _ _NUM = ( Object ) adaptor . nil ( ) ; root _ _NUM = ( Object ) adaptor . becomeRoot ( new FromNode ( T _ SOURCES , fr ) , root _ _NUM ) ; adaptor . addChild ( root _ _NUM , stream _ identification _ variable _ declaration . nextTree ( ) ) ; adaptor . addChild ( root _ _NUM , root _ _NUM ) ; } } retval . tree = root _ _NUM ; } } retval . stop = input . LT ( - _NUM ) ; if ( state . backtracking = = _NUM ) { retval . tree = ( Object ) adaptor . rulePostProcessing ( root _ _NUM ) ; adaptor . setTokenBoundaries ( retval . tree , retval . start , retval . stop ) ; } } catch ( RecognitionException re ) { reportError ( re ) ; recover ( input , re ) ; retval . tree = ( Object ) adaptor . errorNode ( input , retval . start , input . LT ( - _NUM ) , re ) ; } finally { do for sure before leaving } return retval ; } 
6196	private int setupEmulation ( Configuration conf , String traceIn , Path scratchDir , Path ioPath , boolean generate ) throws IOException , InterruptedException { create scratch directory ( output directory of gridmix ) final FileSystem scratchFs = scratchDir . getFileSystem ( conf ) ; FileSystem . mkdirs ( scratchFs , scratchDir , new FsPermission ( ( short ) _NUM _NUM _NUM _NUM ) ) ; Setup things needed for emulation of distributed cache load return setupDistCacheEmulation ( conf , traceIn , ioPath , generate ) ; Setup emulation of other loads like CPU load , Memory load } 
6197	List < JobQueueInfo > expandQueueList ( JobQueueInfo [ ] rootQueues ) { List < JobQueueInfo > allQueues = new ArrayList < JobQueueInfo > ( ) ; for ( JobQueueInfo queue : rootQueues ) { allQueues . add ( queue ) ; if ( queue . getChildren ( ) ! = null ) { JobQueueInfo [ ] childQueues = queue . getChildren ( ) . toArray ( new JobQueueInfo [ _NUM ] ) ; allQueues . addAll ( expandQueueList ( childQueues ) ) ; } } return allQueues ; } 
6198	public void setRowOutlineLevel ( int rownum , int level ) { SXSSFRow row = _ rows . get ( rownum ) ; row . setOutlineLevel ( level ) ; if ( level > _NUM & & level > outlineLevelRow ) { outlineLevelRow = level ; setWorksheetOutlineLevelRow ( ) ; } } 
6199	public static Model modelWithStatements ( IProducer < ? extends Model > producer , final StmtIterator it ) { Model m = createModel ( producer ) ; txnBegin ( m ) ; while ( it . hasNext ( ) ) { m . add ( it . nextStatement ( ) ) ; } txnCommit ( m ) ; return m ; } 
6200	public void reportIncident ( String settingName , byte [ ] headerProto ) { Sections String setting = Settings . System . getString ( mContext . getContentResolver ( ) , settingName ) ; IncidentReportArgs args ; try { args = IncidentReportArgs . parseSetting ( setting ) ; } catch ( IllegalArgumentException ex ) { Slog . w ( TAG , _STR , ex ) ; } } 
6201	public void queryContext ( ) throws IOException { try ( Query query = session . query ( _STR , query . next ( ) ) ; } } 
6202	public void canReadWithEntriesInterleavingCPS ( ) throws Exception { populateMaps ( SOME , getDefaultRuntime ( ) , CorfuTable . class , true , _NUM ) ; int mapCount = maps . size ( ) ; ExecutorService checkPointThread = Executors . newFixedThreadPool ( _NUM ) ; checkPointThread . execute ( ( ) - > { for ( int i = _NUM ; i < NUMBER _ OF _ CHECKPOINTS ; i + + ) { try { checkPointAll ( getDefaultRuntime ( ) ) ; } catch ( Exception e ) { } } } ) ; for ( int i = _NUM ; i < NUMBER _ OF _ PUT ; i + + ) { maps . get ( _STR + Integer . toString ( i ) ) ; } try { checkPointThread . shutdown ( ) ; final int timeout = _NUM _NUM ; checkPointThread . awaitTermination ( timeout , TimeUnit . SECONDS ) ; } catch ( InterruptedException e ) { } CorfuRuntime rt _NUM = Helpers . createNewRuntimeWithFastLoader ( getDefaultConfigurationString ( ) ) ; assertThatMapsAreBuilt ( rt _NUM ) ; assertThatObjectCacheIsTheSameSize ( getDefaultRuntime ( ) , rt _NUM ) ; Also test it cans find the tails Map < UUID , Long > streamTails = Helpers . getRecoveryStreamTails ( getDefaultConfigurationString ( ) ) ; assertThatStreamTailsAreCorrect ( streamTails ) ; Need to have checkpoint for each stream assertThat ( streamTails . size ( ) ) . isEqualTo ( mapCount * _NUM ) ; } 
6203	private long setFeedItem ( FeedItem item , boolean saveFeed ) { ContentValues values = new ContentValues ( ) ; values . put ( KEY _ TITLE , item . getTitle ( ) ) ; values . put ( KEY _ LINK , item . getLink ( ) ) ; if ( item . getDescription ( ) ! = null ) { values . put ( KEY _ DESCRIPTION , item . getDescription ( ) ) ; } if ( item . getContentEncoded ( ) ! = null ) { values . put ( KEY _ CONTENT _ ENCODED , item . getContentEncoded ( ) ) ; } values . put ( KEY _ PUBDATE , item . getPubDate ( ) . getTime ( ) ) ; values . put ( KEY _ PAYMENT _ LINK , item . getPaymentLink ( ) ) ; if ( saveFeed & & item . getFeed ( ) ! = null ) { setFeed ( item . getFeed ( ) ) ; } values . put ( KEY _ FEED , item . getFeed ( ) . getId ( ) ) ; if ( item . isNew ( ) ) { values . put ( KEY _ READ , FeedItem . NEW ) ; } else if ( item . isPlayed ( ) ) { values . put ( KEY _ READ , FeedItem . PLAYED ) ; } else { values . put ( KEY _ READ , FeedItem . UNPLAYED ) ; } values . put ( KEY _ HAS _ CHAPTERS , item . getChapters ( ) ! = null | | item . hasChapters ( ) ) ; values . put ( KEY _ ITEM _ IDENTIFIER , item . getItemIdentifier ( ) ) ; values . put ( KEY _ FLATTR _ STATUS , item . getFlattrStatus ( ) . toLong ( ) ) ; values . put ( KEY _ AUTO _ DOWNLOAD , item . getAutoDownload ( ) ) ; if ( item . hasItemImage ( ) ) { if ( item . getImage ( ) . getId ( ) = = _NUM ) { setImage ( item . getImage ( ) ) ; } values . put ( KEY _ IMAGE , item . getImage ( ) . getId ( ) ) ; } if ( item . getId ( ) = = _NUM ) { item . setId ( db . insert ( TABLE _ NAME _ FEED _ ITEMS , null , values ) ) ; } else { db . update ( TABLE _ NAME _ FEED _ ITEMS , values , KEY _ ID + _STR , new String [ ] { String . valueOf ( item . getId ( ) ) } ) ; } if ( item . getMedia ( ) ! = null ) { setMedia ( item . getMedia ( ) ) ; } if ( item . getChapters ( ) ! = null ) { setChapters ( item ) ; } return item . getId ( ) ; } 
6204	public void testBoundaryEventSubscrptionsDeletedOnProcessInstanceDelete ( ) { String deploymentId _NUM = deployBoundaryMessageTestProcess ( ) ; runtimeService . startProcessInstanceByKey ( _STR , taskService . createTaskQuery ( ) . singleResult ( ) . getName ( ) ) ; cleanup ( deploymentId _NUM , deploymentId _NUM ) ; } 
6205	public final QuotaCounts storagespaceConsumed ( BlockStoragePolicy bsp ) { QuotaCounts counts = new QuotaCounts . Builder ( ) . build ( ) ; final Iterable < BlockInfo > blocks ; FileWithSnapshotFeature sf = getFileWithSnapshotFeature ( ) ; if ( sf = = null ) { blocks = Arrays . asList ( getBlocks ( ) ) ; } else { Collect all distinct blocks Set < BlockInfo > allBlocks = new HashSet < > ( Arrays . asList ( getBlocks ( ) ) ) ; List < FileDiff > diffs = sf . getDiffs ( ) . asList ( ) ; for ( FileDiff diff : diffs ) { BlockInfo [ ] diffBlocks = diff . getBlocks ( ) ; if ( diffBlocks ! = null ) { allBlocks . addAll ( Arrays . asList ( diffBlocks ) ) ; } } blocks = allBlocks ; } final short replication = getPreferredBlockReplication ( ) ; for ( BlockInfo b : blocks ) { long blockSize = b . isComplete ( ) ? b . getNumBytes ( ) : getPreferredBlockSize ( ) ; counts . addStorageSpace ( blockSize * replication ) ; if ( bsp ! = null ) { List < StorageType > types = bsp . chooseStorageTypes ( replication ) ; for ( StorageType t : types ) { if ( t . supportTypeQuota ( ) ) { counts . addTypeSpace ( t , blockSize ) ; } } } } return counts ; } 
6206	public ASN _NUM Primitive getLoadedObject ( ) throws IOException { return new DERSequence ( _ parser . readVector ( ) ) ; } 
6207	private void removeUnusedFixedViews ( @ Nullable List < FixedViewInfo > infoList ) { if ( infoList = = null ) { return ; } for ( int i = infoList . size ( ) - _NUM ; i > = _NUM ; i - - ) { final FixedViewInfo fixedViewInfo = infoList . get ( i ) ; final View view = fixedViewInfo . view ; final LayoutParams lp = ( LayoutParams ) view . getLayoutParams ( ) ; if ( view . getParent ( ) = = null & & lp ! = null & & lp . recycledHeaderFooter ) { removeDetachedView ( view , false ) ; lp . recycledHeaderFooter = false ; } } } 
6208	public void reportInetCondition ( int networkType , int percentage ) { NetworkAgentInfo nai = mLegacyTypeTracker . getNetworkForType ( networkType ) ; if ( nai = = null ) return ; reportNetworkConnectivity ( nai . network , percentage > _NUM _NUM ) ; } 
6209	public void setSetButton ( Button b ) { mSetButton = b ; enableSetButton ( ) ; } 
6210	public static String [ ] getStrings ( String str ) { Collection < String > values = getStringCollection ( str ) ; if ( values . size ( ) = = _NUM ) { return null ; } return values . toArray ( new String [ values . size ( ) ] ) ; } 
6211	public void waitForConnected ( ) { synchronized ( this ) { while ( ! isConnected ( ) ) { try { this . wait ( _NUM _NUM * _NUM _NUM _NUM _NUM ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } } 
6212	public void setTermIndexInterval ( int interval ) { ensureOpen ( ) ; config . setTermIndexInterval ( interval ) ; } 
6213	public void setName ( String name ) { checkFrozen ( ) ; m _ name = name . trim ( ) ; } 
6214	protected void checkConfiguration ( HttpServletRequest request ) { if ( ! checkCompleted ) { GlobalConfig config = AppBeans . get ( Configuration . class ) . getConfig ( GlobalConfig . class ) ; if ( config . getLogIncorrectWebAppPropertiesEnabled ( ) ) { StringBuilder sb = new StringBuilder ( ) ; if ( ! request . getServerName ( ) . equals ( config . getWebHostName ( ) ) ) { sb . append ( _STR + sb . toString ( ) ) ; } } checkCompleted = true ; } } 
6215	double computeImportance ( RelSubset subset ) { double importance ; if ( subset = = planner . root ) { The root always has importance = _NUM importance = _NUM . _NUM ; } else { final RelMetadataQuery mq = subset . getCluster ( ) . getMetadataQuery ( ) ; The importance of a subset is the max of its importance to its parents importance = _NUM . _NUM ; for ( RelSubset parent : subset . getParentSubsets ( planner ) ) { final double childImportance = computeImportanceOfChild ( mq , subset , parent ) ; importance = Math . max ( importance , childImportance ) ; } } LOGGER . trace ( _STR , subset , importance ) ; return importance ; } 
6216	public String toString ( ) { StringBuffer buf = new StringBuffer ( _STR ) ; return buf . toString ( ) ; } 
6217	public void testRoundRobinResolver ( ) throws Exception { final UserResolver rslv = new RoundRobinUserResolver ( ) ; Path usersFilePath = new Path ( rootDir , _STR ) ; validateValidUsersFile ( rslv , userRsrc ) ; } 
6218	private void updateAppearance ( ) { Expand overflow button . if ( mAdapter . getCount ( ) > _NUM ) { mExpandActivityOverflowButton . setEnabled ( true ) ; } else { mExpandActivityOverflowButton . setEnabled ( false ) ; } Default activity button . final int activityCount = mAdapter . getActivityCount ( ) ; final int historySize = mAdapter . getHistorySize ( ) ; if ( activityCount > _NUM & & historySize > _NUM ) { mDefaultActivityButton . setVisibility ( VISIBLE ) ; ResolveInfo activity = mAdapter . getDefaultActivity ( ) ; PackageManager packageManager = mContext . getPackageManager ( ) ; mDefaultActivityButtonImage . setImageDrawable ( activity . loadIcon ( packageManager ) ) ; if ( mDefaultActionButtonContentDescription ! = _NUM ) { CharSequence label = activity . loadLabel ( packageManager ) ; String contentDescription = mContext . getString ( mDefaultActionButtonContentDescription , label ) ; mDefaultActivityButton . setContentDescription ( contentDescription ) ; } Work - around for # _NUM _NUM _NUM . mAdapter . setShowDefaultActivity ( false , false ) ; } else { mDefaultActivityButton . setVisibility ( View . GONE ) ; } Activity chooser content . if ( mDefaultActivityButton . getVisibility ( ) = = VISIBLE ) { mActivityChooserContent . setBackgroundDrawable ( mActivityChooserContentBackground ) ; } else { mActivityChooserContent . setBackgroundDrawable ( null ) ; mActivityChooserContent . setPadding ( _NUM , _NUM , _NUM , _NUM ) ; } } 
6219	public boolean isSet ( _ Fields field ) { if ( field = = null ) { throw new java . lang . IllegalArgumentException ( ) ; } switch ( field ) { case TRACE _ ID : return isSetTraceId ( ) ; case PARENT _ ID : return isSetParentId ( ) ; } throw new java . lang . IllegalStateException ( ) ; } 
6220	public void testReadingWithKeyRange ( ) throws Exception { final String table = _STR , union , containsInAnyOrder ( testRows . toArray ( new Row [ ] { } ) ) ) ; Suffix should contain the middle . assertThat ( suffixRows , hasItems ( middleRows . toArray ( new Row [ ] { } ) ) ) ; } 
6221	public INDArray muli ( INDArray other , INDArray result ) { if ( other . isScalar ( ) ) { return muli ( other . getDouble ( _NUM ) , result ) ; } if ( isScalar ( ) ) { return other . muli ( getDouble ( _NUM ) , result ) ; } if ( ! Shape . shapeEquals ( this . shape ( ) , other . shape ( ) ) ) { int [ ] broadcastDimensions = Shape . getBroadcastDimensions ( this . shape ( ) , other . shape ( ) ) ; Nd _NUM j . getExecutioner ( ) . exec ( new BroadcastMulOp ( this , other , result , broadcastDimensions ) , broadcastDimensions ) ; return result ; } LinAlgExceptions . assertSameShape ( other , result ) ; Nd _NUM j . getExecutioner ( ) . exec ( new OldMulOp ( this , other , result , length ( ) ) ) ; if ( Nd _NUM j . ENFORCE _ NUMERICAL _ STABILITY ) Nd _NUM j . clearNans ( result ) ; return result ; } 
6222	private void queryWithCollKeyUpperCaseWithExpectedOrder ( String localeString , Integer beginIndex , Integer endIndex , Integer [ ] expectedIndexOrder ) throws Exception { String query = String . format ( _STR , tableName , beginIndex , endIndex , localeString ) ; queryWithExpectedOrder ( query , expectedIndexOrder ) ; } 
6223	private Object readResolve ( ) { return forName ( name ) ; } 
6224	public static void writeBlock ( final BATBlock bat , final ByteBuffer block ) throws IOException { bat . writeData ( block ) ; } 
6225	public static org . apache . xmlbeans . xml . stream . XMLInputStream newValidatingXMLInputStream ( org . apache . xmlbeans . xml . stream . XMLInputStream xis , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , org . apache . xmlbeans . xml . stream . XMLStreamException { return XmlBeans . getContextTypeLoader ( ) . newValidatingXMLInputStream ( xis , type , options ) ; } 
6226	public void testMutatingOutputWithEnforcementDisabledSucceeds ( ) throws Exception { PipelineOptions options = PipelineOptionsFactory . create ( ) ; options . setRunner ( DirectRunner . class ) ; options . as ( DirectOptions . class ) . setEnforceImmutability ( false ) ; Pipeline pipeline = Pipeline . create ( options ) ; pipeline . apply ( Create . of ( _NUM _NUM ) ) . apply ( ParDo . of ( new DoFn < Integer , List < Integer > > ( ) { @ ProcessElement public void processElement ( ProcessContext c ) { List < Integer > outputList = Arrays . asList ( _NUM , _NUM , _NUM , _NUM ) ; c . output ( outputList ) ; outputList . set ( _NUM , _NUM _NUM ) ; c . output ( outputList ) ; } } ) ) ; pipeline . run ( ) ; } 
6227	private void recordEdit ( EditOperation edit , @ MergeMode int mergeMode ) { Fetch the last edit operation and attempt to merge in the new edit . final UndoManager um = mEditor . mUndoManager ; um . beginUpdate ( _STR + edit ) ; um . commitState ( mEditor . mUndoOwner ) ; um . addOperation ( edit , UndoManager . MERGE _ MODE _ NONE ) ; } mPreviousOperationWasInSameBatchEdit = mIsUserEdit ; um . endUpdate ( ) ; } 
6228	protected Client getAndValidateClientFromIdAndSecret ( String clientId , String providedClientSecret , MultivaluedMap < String , String > params ) { Client client = getClient ( clientId , providedClientSecret , params ) ; if ( ! client . getClientId ( ) . equals ( clientId ) ) { reportInvalidClient ( ) ; } if ( ! client . isConfidential ( ) | | ! isConfidenatialClientSecretValid ( client , providedClientSecret ) ) { reportInvalidClient ( ) ; } return client ; } 
6229	public CmsPublishList mergePublishLists ( CmsRequestContext context , CmsPublishList pubList _NUM , CmsPublishList pubList _NUM ) throws CmsException { CmsPublishList ret = null ; CmsDbContext dbc = m _ dbContextFactory . getDbContext ( context ) ; try { get all resources from the first list Set < CmsResource > publishResources = new HashSet < CmsResource > ( pubList _NUM . getAllResources ( ) ) ; get all resources from the second list publishResources . addAll ( pubList _NUM . getAllResources ( ) ) ; create merged publish list ret = new CmsPublishList ( pubList _NUM . getDirectPublishResources ( ) , pubList _NUM . isPublishSiblings ( ) , pubList _NUM . isPublishSubResources ( ) ) ; ignore files that should not be published ret . addAll ( publishResources , false ) ; ensure sort order ret . initialize ( ) ; checkPublishPermissions ( dbc , ret ) ; } catch ( Exception e ) { dbc . report ( null , Messages . get ( ) . container ( Messages . ERR _ MERGING _ PUBLISH _ LISTS _ _NUM ) , e ) ; } finally { dbc . clear ( ) ; } return ret ; } 
6230	private void handleCollectionOfValues ( Object newInstance , FieldAccess field , Collection < Value > acollectionOfValues ) { Collection collectionOfValues = acollectionOfValues ; if ( null = = collectionOfValues ) { field . setObject ( newInstance , null ) ; return ; } if ( field . typeEnum ( ) = = INSTANCE ) { field . setObject ( newInstance , fromList ( ( List ) acollectionOfValues , field . type ( ) ) ) ; return ; } if ( collectionOfValues instanceof ValueList ) { collectionOfValues = ( ( ValueList ) collectionOfValues ) . list ( ) ; } Class < ? > componentClass = field . getComponentClass ( ) ; switch ( field . typeEnum ( ) ) { case LIST : case SET : case COLLECTION : Collection < Object > newCollection = Conversions . createCollection ( field . type ( ) , collectionOfValues . size ( ) ) ; for ( Value value : ( List < Value > ) collectionOfValues ) { if ( value . isContainer ( ) ) { Object oValue = value . toValue ( ) ; if ( oValue instanceof Map ) { newCollection . add ( fromValueMap ( ( Map ) oValue , componentClass ) ) ; } } else { newCollection . add ( Conversions . coerce ( componentClass , value . toValue ( ) ) ) ; } } field . setObject ( newInstance , newCollection ) ; break ; case ARRAY : case ARRAY _ INT : case ARRAY _ BYTE : case ARRAY _ SHORT : case ARRAY _ FLOAT : case ARRAY _ DOUBLE : case ARRAY _ LONG : case ARRAY _ STRING : case ARRAY _ OBJECT : TypeType componentType = field . componentType ( ) ; int index = _NUM ; switch ( componentType ) { case INT : int [ ] iarray = new int [ collectionOfValues . size ( ) ] ; for ( Value value : ( List < Value > ) collectionOfValues ) { iarray [ index ] = value . intValue ( ) ; index + + ; } field . setObject ( newInstance , iarray ) ; return ; case SHORT : short [ ] sarray = new short [ collectionOfValues . size ( ) ] ; for ( Value value : ( List < Value > ) collectionOfValues ) { sarray [ index ] = value . shortValue ( ) ; index + + ; } field . setObject ( newInstance , sarray ) ; return ; case DOUBLE : double [ ] darray = new double [ collectionOfValues . size ( ) ] ; for ( Value value : ( List < Value > ) collectionOfValues ) { darray [ index ] = value . doubleValue ( ) ; index + + ; } field . setObject ( newInstance , darray ) ; return ; case FLOAT : float [ ] farray = new float [ collectionOfValues . size ( ) ] ; for ( Value value : ( List < Value > ) collectionOfValues ) { farray [ index ] = value . floatValue ( ) ; index + + ; } field . setObject ( newInstance , farray ) ; return ; case LONG : long [ ] larray = new long [ collectionOfValues . size ( ) ] ; for ( Value value : ( List < Value > ) collectionOfValues ) { larray [ index ] = value . longValue ( ) ; index + + ; } field . setObject ( newInstance , larray ) ; return ; case BYTE : byte [ ] barray = new byte [ collectionOfValues . size ( ) ] ; for ( Value value : ( List < Value > ) collectionOfValues ) { barray [ index ] = value . byteValue ( ) ; index + + ; } field . setObject ( newInstance , barray ) ; return ; case CHAR : char [ ] chars = new char [ collectionOfValues . size ( ) ] ; for ( Value value : ( List < Value > ) collectionOfValues ) { chars [ index ] = value . charValue ( ) ; index + + ; } field . setObject ( newInstance , chars ) ; return ; case STRING : CharBuf buffer = CharBuf . create ( _NUM _NUM _NUM ) ; String [ ] strings = new String [ collectionOfValues . size ( ) ] ; for ( Value value : ( List < Value > ) collectionOfValues ) { strings [ index ] = value . stringValue ( buffer ) ; index + + ; } field . setObject ( newInstance , strings ) ; return ; default : Object array = Array . newInstance ( componentClass , collectionOfValues . size ( ) ) ; Object o ; for ( Value value : ( List < Value > ) collectionOfValues ) { if ( value instanceof ValueContainer ) { o = value . toValue ( ) ; if ( o instanceof List ) { o = fromList ( ( List ) o , componentClass ) ; if ( componentClass . isInstance ( o ) ) { Array . set ( array , index , o ) ; } else { break ; } } else if ( o instanceof Map ) { o = fromMap ( ( Map ) o , componentClass ) ; if ( componentClass . isInstance ( o ) ) { Array . set ( array , index , o ) ; } else { break ; } } } else { o = value . toValue ( ) ; if ( componentClass . isInstance ( o ) ) { Array . set ( array , index , o ) ; } else { Array . set ( array , index , Conversions . coerce ( componentClass , o ) ) ; } } index + + ; } field . setValue ( newInstance , array ) ; } break ; } } 
6231	public void testBalancerWithExcludeList ( ) throws Exception { final Configuration conf = new HdfsConfiguration ( ) ; initConf ( conf ) ; Set < String > excludeHosts = new HashSet < String > ( ) ; excludeHosts . add ( _STR } , excludeHosts , Parameters . DEFAULT . nodesToBeIncluded ) , false , false ) ; } 
6232	public void testDeleteWithWhereClause ( ) throws SQLException { String whereClause = _STR , _NUM ) ) . size ( ) ) ; insertBack ( ) ; } 
6233	public alluxio . proto . journal . File . InodeFileEntry . Builder getInodeFileBuilder ( ) { bitField _NUM _ | = _NUM x _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM ; onChanged ( ) ; return getInodeFileFieldBuilder ( ) . getBuilder ( ) ; } 
6234	void pollAllDevicesNow ( ) { Clear existing timer to avoid overlapped execution mActionTimer . clearTimerMessage ( ) ; mTimeoutCount = _NUM ; mState = STATE _ WAIT _ FOR _ NEXT _ POLLING ; pollAllDevices ( ) ; addTimer ( mState , POLLING _ INTERVAL _ MS ) ; } 
6235	public void testMultipartUploadCallbackBody ( ) { String key = _STR ) ; callback . setCalbackBodyType ( CalbackBodyType . URL ) ; CompleteMultipartUploadRequest completeMultipartUploadRequest = new CompleteMultipartUploadRequest ( bucketName , key , uploadId , partETags ) ; completeMultipartUploadRequest . setCallback ( callback ) ; CompleteMultipartUploadResult completeMultipartUploadResult = ossClient . completeMultipartUpload ( completeMultipartUploadRequest ) ; byte [ ] buffer = new byte [ bufferLength ] ; int nRead = completeMultipartUploadResult . getResponse ( ) . getContent ( ) . read ( buffer ) ; completeMultipartUploadResult . getResponse ( ) . getContent ( ) . close ( ) ; Assert . assertEquals ( callbackResponse , new String ( buffer , _NUM , nRead ) ) ; OSSObject obj = ossClient . getObject ( bucketName , key ) ; Assert . assertEquals ( key , obj . getKey ( ) ) ; Assert . assertEquals ( instreamLength , obj . getObjectMetadata ( ) . getContentLength ( ) ) ; obj . forcedClose ( ) ; } catch ( Exception ex ) { Assert . fail ( ex . getMessage ( ) ) ; } } 
6236	protected void setColumns ( CmsListMetadata metadata ) { setColumnVisibilities ( ) ; position _NUM : icon CmsListColumnDefinition typeIconCol = new CmsListColumnDefinition ( LIST _ COLUMN _ TYPEICON ) ; typeIconCol . setName ( Messages . get ( ) . container ( Messages . GUI _ EXPLORER _ LIST _ COLS _ ICON _ _NUM ) ) ; typeIconCol . setHelpText ( Messages . get ( ) . container ( Messages . GUI _ EXPLORER _ LIST _ COLS _ ICON _ HELP _ _NUM ) ) ; typeIconCol . setWidth ( _STR ) ; add resource icon action CmsListDirectAction resourceProjStateAction = new CmsListResourceProjStateAction ( LIST _ ACTION _ PROJSTATEICON ) ; resourceProjStateAction . setEnabled ( false ) ; projStateIconCol . addDirectAction ( resourceProjStateAction ) ; metadata . addColumn ( projStateIconCol ) ; position _NUM : name CmsListColumnDefinition nameCol = new CmsListExplorerColumn ( LIST _ COLUMN _ NAME ) ; nameCol . setName ( org . opencms . workplace . explorer . Messages . get ( ) . container ( org . opencms . workplace . explorer . Messages . GUI _ INPUT _ PATH _ _NUM ) ) ; add resource open action CmsListDefaultAction resourceOpenDefAction = new CmsListOpenResourceAction ( LIST _ DEFACTION _ OPEN , LIST _ COLUMN _ ROOT _ PATH ) ; resourceOpenDefAction . setEnabled ( true ) ; nameCol . addDefaultAction ( resourceOpenDefAction ) ; metadata . addColumn ( nameCol ) ; nameCol . setPrintable ( false ) ; position _NUM : root path for printing CmsListColumnDefinition rootPathCol = new CmsListExplorerColumn ( LIST _ COLUMN _ ROOT _ PATH ) ; rootPathCol . setName ( org . opencms . workplace . explorer . Messages . get ( ) . container ( org . opencms . workplace . explorer . Messages . GUI _ INPUT _ NAME _ _NUM ) ) ; rootPathCol . setVisible ( false ) ; rootPathCol . setPrintable ( true ) ; metadata . addColumn ( rootPathCol ) ; position _NUM : title CmsListColumnDefinition titleCol = new CmsListExplorerColumn ( LIST _ COLUMN _ TITLE ) ; titleCol . setName ( org . opencms . workplace . explorer . Messages . get ( ) . container ( org . opencms . workplace . explorer . Messages . GUI _ INPUT _ TITLE _ _NUM ) ) ; metadata . addColumn ( titleCol ) ; position _NUM : resource type CmsListColumnDefinition typeCol = new CmsListExplorerColumn ( LIST _ COLUMN _ TYPE ) ; typeCol . setName ( org . opencms . workplace . explorer . Messages . get ( ) . container ( org . opencms . workplace . explorer . Messages . GUI _ INPUT _ TYPE _ _NUM ) ) ; metadata . addColumn ( typeCol ) ; position _NUM : size CmsListColumnDefinition sizeCol = new CmsListExplorerColumn ( LIST _ COLUMN _ SIZE ) ; sizeCol . setName ( org . opencms . workplace . explorer . Messages . get ( ) . container ( org . opencms . workplace . explorer . Messages . GUI _ INPUT _ SIZE _ _NUM ) ) ; metadata . addColumn ( sizeCol ) ; position _NUM : permissions CmsListColumnDefinition permissionsCol = new CmsListExplorerColumn ( LIST _ COLUMN _ PERMISSIONS ) ; permissionsCol . setName ( org . opencms . workplace . explorer . Messages . get ( ) . container ( org . opencms . workplace . explorer . Messages . GUI _ INPUT _ PERMISSIONS _ _NUM ) ) ; metadata . addColumn ( permissionsCol ) ; position _NUM : date of last modification CmsListColumnDefinition dateLastModCol = new CmsListExplorerColumn ( LIST _ COLUMN _ DATELASTMOD ) ; dateLastModCol . setName ( org . opencms . workplace . explorer . Messages . get ( ) . container ( org . opencms . workplace . explorer . Messages . GUI _ INPUT _ DATELASTMODIFIED _ _NUM ) ) ; dateLastModCol . setFormatter ( CmsListDateMacroFormatter . getDefaultDateFormatter ( ) ) ; metadata . addColumn ( dateLastModCol ) ; position _NUM _NUM : user who last modified the resource CmsListColumnDefinition userLastModCol = new CmsListExplorerColumn ( LIST _ COLUMN _ USERLASTMOD ) ; userLastModCol . setName ( org . opencms . workplace . explorer . Messages . get ( ) . container ( org . opencms . workplace . explorer . Messages . GUI _ INPUT _ USERLASTMODIFIED _ _NUM ) ) ; metadata . addColumn ( userLastModCol ) ; position _NUM _NUM : date of creation CmsListColumnDefinition dateCreateCol = new CmsListExplorerColumn ( LIST _ COLUMN _ DATECREATE ) ; dateCreateCol . setName ( org . opencms . workplace . explorer . Messages . get ( ) . container ( org . opencms . workplace . explorer . Messages . GUI _ INPUT _ DATECREATED _ _NUM ) ) ; dateCreateCol . setFormatter ( CmsListDateMacroFormatter . getDefaultDateFormatter ( ) ) ; metadata . addColumn ( dateCreateCol ) ; position _NUM _NUM : user who created the resource CmsListColumnDefinition userCreateCol = new CmsListExplorerColumn ( LIST _ COLUMN _ USERCREATE ) ; userCreateCol . setName ( org . opencms . workplace . explorer . Messages . get ( ) . container ( org . opencms . workplace . explorer . Messages . GUI _ INPUT _ USERCREATED _ _NUM ) ) ; metadata . addColumn ( userCreateCol ) ; position _NUM _NUM : date of release CmsListColumnDefinition dateReleaseCol = new CmsListExplorerColumn ( LIST _ COLUMN _ DATEREL ) ; dateReleaseCol . setName ( org . opencms . workplace . explorer . Messages . get ( ) . container ( org . opencms . workplace . explorer . Messages . GUI _ INPUT _ DATERELEASED _ _NUM ) ) ; dateReleaseCol . setFormatter ( new CmsListDateMacroFormatter ( Messages . get ( ) . container ( Messages . GUI _ LIST _ DATE _ FORMAT _ _NUM ) , new CmsMessageContainer ( null , CmsTouch . DEFAULT _ DATE _ STRING ) , CmsResource . DATE _ RELEASED _ DEFAULT ) ) ; metadata . addColumn ( dateReleaseCol ) ; position _NUM _NUM : date of expiration CmsListColumnDefinition dateExpirationCol = new CmsListExplorerColumn ( LIST _ COLUMN _ DATEEXP ) ; dateExpirationCol . setName ( org . opencms . workplace . explorer . Messages . get ( ) . container ( org . opencms . workplace . explorer . Messages . GUI _ INPUT _ DATEEXPIRED _ _NUM ) ) ; dateExpirationCol . setFormatter ( new CmsListDateMacroFormatter ( Messages . get ( ) . container ( Messages . GUI _ LIST _ DATE _ FORMAT _ _NUM ) , new CmsMessageContainer ( null , CmsTouch . DEFAULT _ DATE _ STRING ) , CmsResource . DATE _ EXPIRED _ DEFAULT ) ) ; metadata . addColumn ( dateExpirationCol ) ; position _NUM _NUM : state ( changed , unchanged , new , deleted ) CmsListColumnDefinition stateCol = new CmsListExplorerColumn ( LIST _ COLUMN _ STATE ) ; stateCol . setName ( org . opencms . workplace . explorer . Messages . get ( ) . container ( org . opencms . workplace . explorer . Messages . GUI _ INPUT _ STATE _ _NUM ) ) ; metadata . addColumn ( stateCol ) ; position _NUM _NUM : locked by CmsListColumnDefinition lockedByCol = new CmsListExplorerColumn ( LIST _ COLUMN _ LOCKEDBY ) ; lockedByCol . setName ( org . opencms . workplace . explorer . Messages . get ( ) . container ( org . opencms . workplace . explorer . Messages . GUI _ INPUT _ LOCKEDBY _ _NUM ) ) ; metadata . addColumn ( lockedByCol ) ; position _NUM _NUM : site CmsListColumnDefinition siteCol = new CmsListExplorerColumn ( LIST _ COLUMN _ SITE ) ; siteCol . setName ( org . opencms . workplace . explorer . Messages . get ( ) . container ( org . opencms . workplace . explorer . Messages . GUI _ LABEL _ SITE _ _NUM ) ) ; metadata . addColumn ( siteCol ) ; } 
6237	public < K , V > void assertDoesNotContainDuplicateValues ( Description description , Map < K , V > actual ) { assertNotNull ( description , actual ) ; Collection < ? > duplicates = duplicatesFrom ( actual . values ( ) ) ; if ( ! duplicates . isEmpty ( ) ) { throw failures . failure ( description , shouldNotHaveDuplicates ( actual , duplicates ) ) ; } } 
6238	public void recordData ( NetworkIdentitySet ident , int uid , int set , int tag , long start , long end , NetworkStats . Entry entry ) { final NetworkStatsHistory history = findOrCreateHistory ( ident , uid , set , tag ) ; history . recordData ( start , end , entry ) ; noteRecordedHistory ( history . getStart ( ) , history . getEnd ( ) , entry . rxBytes + entry . txBytes ) ; } 
6239	private static RestApp findMaster ( Collection < RestApp > cluster ) { for ( RestApp restApp : cluster ) { if ( restApp . isMaster ( ) ) { return restApp ; } } return null ; } 
6240	 @ DELETE @ Consumes ( MediaType . WILDCARD ) @ Produces ( MediaType . APPLICATION _ JSON ) @ Path ( _STR ) final String snippetId ) { if ( isReplicateRequest ( ) ) { return replicate ( HttpMethod . DELETE ) ; } final ComponentEntity requestEntity = new ComponentEntity ( ) ; requestEntity . setId ( snippetId ) ; get the revision from this snippet final Set < Revision > requestRevisions = serviceFacade . getRevisionsFromSnippet ( snippetId ) ; return withWriteLock ( serviceFacade , requestEntity , requestRevisions , lookup - > { ensure write permission to every component in the snippet excluding referenced services final SnippetAuthorizable snippet = lookup . getSnippet ( snippetId ) ; authorizeSnippet ( snippet , authorizer , lookup , RequestAction . WRITE , true , false ) ; ensure write permission to the parent process group snippet . getParentProcessGroup ( ) . authorize ( authorizer , RequestAction . WRITE , NiFiUserUtils . getNiFiUser ( ) ) ; } , ( ) - > serviceFacade . verifyDeleteSnippet ( snippetId , requestRevisions . stream ( ) . map ( rev - > rev . getComponentId ( ) ) . collect ( Collectors . toSet ( ) ) ) , ( revisions , entity ) - > { delete the specified snippet final SnippetEntity snippetEntity = serviceFacade . deleteSnippet ( revisions , entity . getId ( ) ) ; return generateOkResponse ( snippetEntity ) . build ( ) ; } ) ; } 
6241	public void testCachingRelaysSingleSwitchQueries ( ) throws Throwable { create a single switch map StaticMapping staticMapping = newInstance ( null ) ; assertSingleSwitch ( staticMapping ) ; CachedDNSToSwitchMapping cachedMap = new CachedDNSToSwitchMapping ( staticMapping ) ; LOG . info ( _STR + cachedMap . dumpTopology ( ) ) ; assertSingleSwitch ( cachedMap ) ; } 
6242	public V get ( Object key ) { byte k ; if ( key ! = null ) { if ( key instanceof Byte ) { k = unwrapKey ( ( Byte ) key ) ; } else { return null ; } } else { k = _ map . getNoEntryKey ( ) ; } return _ map . get ( k ) ; } 
6243	public String displaySearchResult ( CmsSearch search ) { initSearch ( search ) ; StringBuffer result = new StringBuffer ( _NUM _NUM _NUM ) ; CmsMessages messages = org . opencms . search . Messages . get ( ) . getBundle ( m _ jsp . getRequestContext ( ) . getLocale ( ) ) ; result . append ( _STR ) ; } } include the post forms for the page links : Iterator values = m _ formCache . values ( ) . iterator ( ) ; while ( values . hasNext ( ) ) { result . append ( values . next ( ) ) ; } return result . toString ( ) ; } 
6244	protected void onEditingModeChange ( ViewHolder vh , boolean editing , boolean withTransition ) { GuidedAction action = vh . getAction ( ) ; TextView titleView = vh . getTitleView ( ) ; TextView descriptionView = vh . getDescriptionView ( ) ; if ( editing ) { CharSequence editTitle = action . getEditTitle ( ) ; if ( titleView ! = null & & editTitle ! = null ) { titleView . setText ( editTitle ) ; } CharSequence editDescription = action . getEditDescription ( ) ; if ( descriptionView ! = null & & editDescription ! = null ) { descriptionView . setText ( editDescription ) ; } if ( action . isDescriptionEditable ( ) ) { if ( descriptionView ! = null ) { descriptionView . setVisibility ( View . VISIBLE ) ; descriptionView . setInputType ( action . getDescriptionEditInputType ( ) ) ; } vh . mEditingMode = EDITING _ DESCRIPTION ; } else if ( action . isEditable ( ) ) { if ( titleView ! = null ) { titleView . setInputType ( action . getEditInputType ( ) ) ; } vh . mEditingMode = EDITING _ TITLE ; } else if ( vh . mActivatorView ! = null ) { onEditActivatorView ( vh , editing , withTransition ) ; vh . mEditingMode = EDITING _ ACTIVATOR _ VIEW ; } } else { if ( titleView ! = null ) { titleView . setText ( action . getTitle ( ) ) ; } if ( descriptionView ! = null ) { descriptionView . setText ( action . getDescription ( ) ) ; } if ( vh . mEditingMode = = EDITING _ DESCRIPTION ) { if ( descriptionView ! = null ) { descriptionView . setVisibility ( TextUtils . isEmpty ( action . getDescription ( ) ) ? View . GONE : View . VISIBLE ) ; descriptionView . setInputType ( action . getDescriptionInputType ( ) ) ; } } else if ( vh . mEditingMode = = EDITING _ TITLE ) { if ( titleView ! = null ) { titleView . setInputType ( action . getInputType ( ) ) ; } } else if ( vh . mEditingMode = = EDITING _ ACTIVATOR _ VIEW ) { if ( vh . mActivatorView ! = null ) { onEditActivatorView ( vh , editing , withTransition ) ; } } vh . mEditingMode = EDITING _ NONE ; } call deprecated method for backward compatible onEditingModeChange ( vh , action , editing ) ; } 
6245	public boolean removeParser ( Parser parser ) { removeParserNotices ( parser ) ; boolean removed = parsers . remove ( parser ) ; if ( removed ) { textArea . fireParserNoticesChange ( ) ; } return removed ; } 
6246	public void unsubscribe ( List < String > datasetNames ) { for ( String datasetName : datasetNames ) { Dataset dataset = openOrCreateDataset ( datasetName ) ; try { dataset . unsubscribe ( ) ; } catch ( UnsubscribeFailedException ufe ) { if ( ufe . getCause ( ) instanceof ResourceNotFoundException ) { LOGGER . warn ( _STR ) ; } else { throw ufe ; } } } } 
6247	public void drawButton ( float llx , float lly , float urx , float ury , String text , BaseFont bf , float size ) { if ( llx > urx ) { float x = llx ; llx = urx ; urx = x ; } if ( lly > ury ) { float y = lly ; lly = ury ; ury = y ; } black rectangle not filled setColorStroke ( new Color ( _NUM x _NUM _NUM , _NUM x _NUM _NUM , _NUM x _NUM _NUM ) ) ; setLineWidth ( _NUM ) ; setLineCap ( _NUM ) ; rectangle ( llx , lly , urx - llx , ury - lly ) ; stroke ( ) ; silver rectangle filled setLineWidth ( _NUM ) ; setLineCap ( _NUM ) ; setColorFill ( new Color ( _NUM xC _NUM , _NUM xC _NUM , _NUM xC _NUM ) ) ; rectangle ( llx + _NUM . _NUM f , lly + _NUM . _NUM f , urx - llx - _NUM f , ury - lly - _NUM f ) ; fill ( ) ; white lines setColorStroke ( new Color ( _NUM xFF , _NUM xFF , _NUM xFF ) ) ; setLineWidth ( _NUM ) ; setLineCap ( _NUM ) ; moveTo ( llx + _NUM f , lly + _NUM f ) ; lineTo ( llx + _NUM f , ury - _NUM f ) ; lineTo ( urx - _NUM f , ury - _NUM f ) ; stroke ( ) ; dark grey lines setColorStroke ( new Color ( _NUM xA _NUM , _NUM xA _NUM , _NUM xA _NUM ) ) ; setLineWidth ( _NUM ) ; setLineCap ( _NUM ) ; moveTo ( llx + _NUM f , lly + _NUM f ) ; lineTo ( urx - _NUM f , lly + _NUM f ) ; lineTo ( urx - _NUM f , ury - _NUM f ) ; stroke ( ) ; text resetRGBColorFill ( ) ; beginText ( ) ; setFontAndSize ( bf , size ) ; showTextAligned ( PdfContentByte . ALIGN _ CENTER , text , llx + ( urx - llx ) / _NUM , lly + ( ury - lly - size ) / _NUM , _NUM ) ; endText ( ) ; } 
6248	protected void processSeparationColorSpace ( PDColorSpace colorSpace ) { try { COSBase cosAlt = ( ( COSArray ) colorSpace . getCOSObject ( ) ) . getObject ( _NUM ) ; PDColorSpace altCol = PDColorSpace . create ( cosAlt ) ; if ( altCol ! = null ) { ColorSpaces acs = ColorSpaces . valueOf ( altCol . getName ( ) ) ; switch ( acs ) { case Separation : case DeviceN : case Pattern : case Indexed : case I : context . addValidationError ( new ValidationError ( ERROR _ GRAPHIC _ INVALID _ COLOR _ SPACE _ ALTERNATE , acs . getLabel ( ) + _STR + e . getMessage ( ) , e ) ) ; } } 
6249	protected PdfIndirectReference getReferenceJBIG _NUM Globals ( byte [ ] content ) { if ( content = = null ) return null ; PdfStream stream ; for ( Iterator i = JBIG _NUM Globals . keySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { stream = ( PdfStream ) i . next ( ) ; if ( Arrays . equals ( content , stream . getBytes ( ) ) ) { return ( PdfIndirectReference ) JBIG _NUM Globals . get ( stream ) ; } } stream = new PdfStream ( content ) ; PdfIndirectObject ref ; try { ref = addToBody ( stream ) ; } catch ( IOException e ) { return null ; } JBIG _NUM Globals . put ( stream , ref . getIndirectReference ( ) ) ; return ref . getIndirectReference ( ) ; } 
6250	public Object getCachedObject ( CmsObject cms , String rootPath ) { String key = getCacheKeyForCurrentProject ( cms , rootPath ) ; return OpenCms . getMemoryMonitor ( ) . getCachedVfsObject ( key ) ; } 
6251	public TTree begin ( Object data ) { current = new Node ( current , data ) ; current . markBegin ( ) ; return this ; } 
6252	public void getArticleContent ( ) throws Exception { final ArticleQueryService articleQueryService = getArticleQueryService ( ) ; final List < JSONObject > articles = articleQueryService . getRecentArticles ( _NUM _NUM ) ; Assert . assertEquals ( articles . size ( ) , _NUM ) ; final String articleId = articles . get ( _NUM ) . getString ( Keys . OBJECT _ ID ) ; Assert . assertNotNull ( articleQueryService . getArticleContent ( null , articleId ) ) ; } 
6253	protected ResultSerializer getResultSerializer ( final MediaType mediaType ) { final ResultSerializer serializer = getResultSerializer ( ) ; if ( mediaType . equals ( MediaType . TEXT _ PLAIN _ TYPE ) ) { return new ResultSerializer ( ) { @ Override public Object serialize ( Result result ) { return serializer . serialize ( result ) . toString ( ) ; } @ Override public Object serializeError ( ResultStatus error ) { return serializer . serializeError ( error ) . toString ( ) ; } } ; } else if ( mediaType . equals ( MediaType . APPLICATION _ JSON _ TYPE ) ) { return new ResultSerializer ( ) { @ Override public Object serialize ( Result result ) { return JSON . parse ( serializer . serialize ( result ) . toString ( ) ) ; } @ Override public Object serializeError ( ResultStatus error ) { return JSON . parse ( serializer . serializeError ( error ) . toString ( ) ) ; } } ; } else if ( mediaType . equals ( MEDIA _ TYPE _ TEXT _ CSV _ TYPE ) ) { return new CsvSerializer ( ) ; } throw new IllegalArgumentException ( _STR ) ; } 
6254	public void add ( final T t ) { if ( t = = null ) { throw new NullPointerException ( _STR ) ; } if ( queue . size ( ) > = maxSize ) { final T maxElement = queue . peek ( ) ; if ( comparator . compare ( maxElement , t ) < _NUM ) { return ; } else { queue . poll ( ) ; } } queue . add ( t ) ; } 
6255	protected String getXMLifiedLogMsg ( String type , String resourceId , Throwable t , String . . . attrs ) { ContentHandler toXML = new ToXMLContentHandler ( ) ; SafeContentHandler handler = new SafeContentHandler ( toXML ) ; AttributesImpl attributes = new AttributesImpl ( ) ; attributes . addAttribute ( _STR , resourceId , t ) ; } return handler . toString ( ) ; } 
6256	public void exceptionOnMissingQuotes ( ) throws IOException { int numOfEntities = _NUM ; String collectionName = _STR ) ; } catch ( ClientErrorException uie ) { Check for an exception assertEquals ( _NUM _NUM _NUM , uie . getResponse ( ) . getStatus ( ) ) ; } } 
6257	public V putIfAbsent ( @ NonNull K key , @ NonNull V v ) { Entry < K , V > entry = get ( key ) ; if ( entry ! = null ) { return entry . mValue ; } put ( key , v ) ; return null ; } 
6258	public static void drawTooltip ( final Graphics g , final String tt , final int x , final int y , final int w , final int c ) { final int tw = width ( g , tt ) ; final int th = g . getFontMetrics ( ) . getHeight ( ) ; final int xx = Math . min ( w - tw - _NUM , x ) ; g . setColor ( color ( c ) ) ; g . fillRect ( xx - _NUM , y - th , tw + _NUM , th ) ; g . setColor ( BACK ) ; g . drawString ( tt , xx , y - _NUM ) ; } 
6259	protected RangeToken parseCharacterClass ( boolean useNrange ) throws ParseException { this . setContext ( S _ INBRACKETS ) ; ' [ ' this . next ( ) ; boolean nrange = false ; RangeToken base = null ; RangeToken tok ; if ( this . read ( ) = = T _ CHAR & & this . chardata = = ' ^ ' ) { nrange = true ; ' ^ ' this . next ( ) ; base = Token . createRange ( ) ; base . addRange ( _NUM , Token . UTF _NUM _NUM _ MAX ) ; tok = Token . createRange ( ) ; } else { tok = Token . createRange ( ) ; } int type ; boolean firstloop = true ; while ( ( type = this . read ( ) ) ! = T _ EOF ) { single - range | from - to - range | subtraction if ( type = = T _ CHAR & & this . chardata = = ' ] ' & & ! firstloop ) { if ( nrange ) { base . subtractRanges ( tok ) ; tok = base ; } break ; } int c = this . chardata ; boolean end = false ; if ( type = = T _ BACKSOLIDUS ) { switch ( c ) { case ' d ' : case ' D ' : case ' w ' : case ' W ' : case ' s ' : case ' S ' : tok . mergeRanges ( this . getTokenForShorthand ( c ) ) ; end = true ; break ; case ' i ' : case ' I ' : case ' c ' : case ' C ' : c = this . processCIinCharacterClass ( tok , c ) ; if ( c < _NUM ) end = true ; break ; case ' p ' : case ' P ' : int pstart = this . offset ; RangeToken tok _NUM = this . processBacksolidus _ pP ( c ) ; if ( tok _NUM = = null ) throw this . ex ( _STR , this . offset ) ; tok . sortRanges ( ) ; tok . compactRanges ( ) ; tok . dumpRanges ( ) ; this . setContext ( S _ NORMAL ) ; Skips ' ] ' this . next ( ) ; return tok ; } 
6260	public Object put ( Object key , Object value ) { key = convertKey ( key ) ; int hashCode = hash ( key ) ; int index = hashIndex ( hashCode , data . length ) ; HashEntry entry = data [ index ] ; while ( entry ! = null ) { if ( entry . hashCode = = hashCode & & isEqualKey ( key , entry . key ) ) { Object oldValue = entry . getValue ( ) ; updateEntry ( entry , value ) ; return oldValue ; } entry = entry . next ; } addMapping ( index , hashCode , key , value ) ; return null ; } 
6261	private boolean appendFilter ( ) { if ( isFiltering ( ) ) { useFilteredFromEntries ( filteredEntries ) ; return true ; } return applyFilter ( ) ; } 
6262	public void pretrainLayer ( String layerName , MultiDataSetIterator iter ) { if ( ! configuration . isPretrain ( ) ) return ; if ( flattenedGradients = = null ) { initGradientsView ( ) ; } if ( ! verticesMap . containsKey ( layerName ) ) { throw new IllegalStateException ( _STR + layerName ) ; } if ( ! verticesMap . get ( layerName ) . hasLayer ( ) ) { No op return ; } int layerIndex = verticesMap . get ( layerName ) . getVertexIndex ( ) ; Need to do partial forward pass . Simply folowing the topological ordering won ' t be efficient , as we might end up doing forward pass on layers we don ' t need to . However , we can start with the topological order , and prune out any layers we don ' t need to do LinkedList < Integer > partialTopoSort = new LinkedList < > ( ) ; Set < Integer > seenSoFar = new HashSet < > ( ) ; partialTopoSort . add ( topologicalOrder [ layerIndex ] ) ; seenSoFar . add ( topologicalOrder [ layerIndex ] ) ; for ( int j = layerIndex - _NUM ; j > = _NUM ; j - - ) { Do we need to do forward pass on this GraphVertex ? If it is input to any other layer we need , then yes . Otherwise : no VertexIndices [ ] outputsTo = vertices [ topologicalOrder [ j ] ] . getOutputVertices ( ) ; boolean needed = false ; for ( VertexIndices vi : outputsTo ) { if ( seenSoFar . contains ( vi . getVertexIndex ( ) ) ) { needed = true ; break ; } } if ( needed ) { partialTopoSort . addFirst ( topologicalOrder [ j ] ) ; seenSoFar . add ( topologicalOrder [ j ] ) ; } } int [ ] fwdPassOrder = new int [ partialTopoSort . size ( ) ] ; int k = _NUM ; for ( Integer g : partialTopoSort ) fwdPassOrder [ k + + ] = g ; GraphVertex gv = vertices [ fwdPassOrder [ fwdPassOrder . length - _NUM ] ] ; Layer layer = gv . getLayer ( ) ; if ( ! iter . hasNext ( ) & & iter . resetSupported ( ) ) { iter . reset ( ) ; } MemoryWorkspace workspace = configuration . getTrainingWorkspaceMode ( ) = = WorkspaceMode . NONE ? new DummyWorkspace ( ) : Nd _NUM j . getWorkspaceManager ( ) . getWorkspaceForCurrentThread ( ComputationGraph . workspaceConfigurationExternal , ComputationGraph . WORKSPACE _ EXTERNAL ) ; MemoryWorkspace cache = configuration . getTrainingWorkspaceMode ( ) = = WorkspaceMode . NONE ? new DummyWorkspace ( ) : Nd _NUM j . getWorkspaceManager ( ) . getWorkspaceForCurrentThread ( ComputationGraph . workspaceConfigurationCache , ComputationGraph . WORKSPACE _ CACHE ) ; MemoryWorkspace wsFF ; MemoryWorkspace wsPTR ; switch ( configuration . getTrainingWorkspaceMode ( ) ) { case NONE : wsFF = new DummyWorkspace ( ) ; wsPTR = new DummyWorkspace ( ) ; break ; case SINGLE : wsFF = Nd _NUM j . getWorkspaceManager ( ) . getWorkspaceForCurrentThread ( WORKSPACE _ EXTERNAL ) ; wsPTR = Nd _NUM j . getWorkspaceManager ( ) . getWorkspaceForCurrentThread ( WORKSPACE _ EXTERNAL ) ; break ; case SEPARATE : wsFF = Nd _NUM j . getWorkspaceManager ( ) . getWorkspaceForCurrentThread ( workspaceConfigurationFeedForward , WORKSPACE _ FEED _ FORWARD ) ; wsPTR = Nd _NUM j . getWorkspaceManager ( ) . getWorkspaceForCurrentThread ( workspaceConfigurationFeedForward , WORKSPACE _ PRETRAIN ) ; break ; default : throw new RuntimeException ( ) ; } while ( iter . hasNext ( ) ) { MultiDataSet multiDataSet = iter . next ( ) ; try ( MemoryWorkspace wsCache = cache . notifyScopeEntered ( ) ) { try ( MemoryWorkspace ws = workspace . notifyScopeEntered ( ) ) { try ( MemoryWorkspace wP = wsPTR . notifyScopeEntered ( ) ) { setInputs ( multiDataSet . getFeatures ( ) ) ; for ( int j = _NUM ; j < fwdPassOrder . length - _NUM ; j + + ) { try ( MemoryWorkspace wF = wsFF . notifyScopeEntered ( ) ) { GraphVertex current = vertices [ fwdPassOrder [ j ] ] ; if ( current . isInputVertex ( ) ) { VertexIndices [ ] inputsTo = current . getOutputVertices ( ) ; INDArray input = inputs [ current . getVertexIndex ( ) ] ; for ( VertexIndices v : inputsTo ) { int vIdx = v . getVertexIndex ( ) ; int vIdxInputNum = v . getVertexEdgeNumber ( ) ; This input : the ' vIdxInputNum ' th input to vertex ' vIdx ' vertices [ vIdx ] . setInput ( vIdxInputNum , TODO When to dup ? input . dup ( ) . leverageTo ( WORKSPACE _ PRETRAIN ) ) ; } } else { Do forward pass : INDArray out = current . doForward ( true ) ; Now , set the inputs for the next vertices : VertexIndices [ ] outputsTo = current . getOutputVertices ( ) ; if ( outputsTo ! = null ) { for ( VertexIndices v : outputsTo ) { int vIdx = v . getVertexIndex ( ) ; int inputNum = v . getVertexEdgeNumber ( ) ; This ( jth ) connection from the output : is the ' inputNum ' th input to vertex ' vIdx ' vertices [ vIdx ] . setInput ( inputNum , out ) ; } } } } } At this point : have done all of the required forward pass stuff . Can now pretrain layer on current input layer . fit ( gv . getInputs ( ) [ _NUM ] ) ; layer . conf ( ) . setPretrain ( false ) ; } } } } } 
6263	public void testNotInUncorrelatedSubQueryInSelectDeduceNotNull _NUM ( ) { final String sql = _STR ; sql ( sql ) . ok ( ) ; } 
6264	public AWSCredentialsProvider getCredentialsProvider ( final Map < PropertyDescriptor , String > properties ) { final CredentialsStrategy primaryStrategy = selectPrimaryStrategy ( properties ) ; AWSCredentialsProvider primaryCredentialsProvider = primaryStrategy . getCredentialsProvider ( properties ) ; AWSCredentialsProvider derivedCredentialsProvider = null ; for ( CredentialsStrategy strategy : strategies ) { if ( strategy . canCreateDerivedCredential ( properties ) ) { derivedCredentialsProvider = strategy . getDerivedCredentialsProvider ( properties , primaryCredentialsProvider ) ; break ; } } if ( derivedCredentialsProvider ! = null ) { return derivedCredentialsProvider ; } else { return primaryCredentialsProvider ; } } 
6265	public static MutableFloat fromExternal ( final Supplier < Float > s , final Consumer < Float > c ) { return new MutableFloat ( ) { @ Override public float getAsFloat ( ) { return s . get ( ) ; } @ Override public Float get ( ) { return getAsFloat ( ) ; } @ Override public MutableFloat set ( final float value ) { c . accept ( value ) ; return this ; } } ; } 
6266	public final void indexDictionary ( Dictionary dict , IndexWriterConfig config , boolean fullMerge ) throws IOException { synchronized ( modifyCurrentIndexLock ) { ensureOpen ( ) ; final Directory dir = this . spellIndex ; final IndexWriter writer = new IndexWriter ( dir , config ) ; IndexSearcher indexSearcher = obtainSearcher ( ) ; final List < IndexReader > readers = new ArrayList < IndexReader > ( ) ; if ( searcher . maxDoc ( ) > _NUM ) { ReaderUtil . gatherSubReaders ( readers , searcher . getIndexReader ( ) ) ; } boolean isEmpty = readers . isEmpty ( ) ; try { Iterator < String > iter = dict . getWordsIterator ( ) ; terms : while ( iter . hasNext ( ) ) { String word = iter . next ( ) ; int len = word . length ( ) ; if ( len < _NUM ) { too short we bail but _STR is fine . . . continue ; } if ( ! isEmpty ) { we have a non - empty index , check if the term exists Term term = F _ WORD _ TERM . createTerm ( word ) ; for ( IndexReader ir : readers ) { if ( ir . docFreq ( term ) > _NUM ) { continue terms ; } } } ok index the word Document doc = createDocument ( word , getMin ( len ) , getMax ( len ) ) ; writer . addDocument ( doc ) ; } } finally { releaseSearcher ( indexSearcher ) ; } if ( fullMerge ) { writer . forceMerge ( _NUM ) ; } close writer writer . close ( ) ; TODO : this isn ' t that great , maybe in the future SpellChecker should take IWC in its ctor / keep its writer open ? also re - open the spell index to see our own changes when the next suggestion is fetched : swapSearcher ( dir ) ; } } 
6267	public void doHistory ( KeyEvent e ) { if ( e . getSource ( ) = = m _ Input ) { switch ( e . getKeyCode ( ) ) { case KeyEvent . VK _ UP : if ( m _ HistoryPos > _NUM ) { m _ HistoryPos - - ; String command = ( String ) m _ CommandHistory . elementAt ( m _ HistoryPos ) ; m _ Input . setText ( command ) ; } break ; case KeyEvent . VK _ DOWN : if ( m _ HistoryPos < m _ CommandHistory . size ( ) ) { m _ HistoryPos + + ; String command = _STR ; if ( m _ HistoryPos < m _ CommandHistory . size ( ) ) { command = ( String ) m _ CommandHistory . elementAt ( m _ HistoryPos ) ; } m _ Input . setText ( command ) ; } break ; default : break ; } } } 
6268	public static XmlString parse ( org . apache . xmlbeans . xml . stream . XMLInputStream xis ) throws org . apache . xmlbeans . XmlException , org . apache . xmlbeans . xml . stream . XMLStreamException { return ( XmlString ) XmlBeans . getContextTypeLoader ( ) . parse ( xis , type , null ) ; } 
6269	public void onEndOfSpeech ( ) { if ( ! recognizer . getSearchName ( ) . equals ( KWS _ SEARCH ) ) switchSearch ( KWS _ SEARCH ) ; } 
6270	public static int writeCell ( Cell cell , OutputStream out , boolean withTags ) throws IOException { if ( cell instanceof ExtendedCell ) { return ( ( ExtendedCell ) cell ) . write ( out , withTags ) ; } else { ByteBufferUtils . putInt ( out , estimatedSerializedSizeOfKey ( cell ) ) ; ByteBufferUtils . putInt ( out , cell . getValueLength ( ) ) ; writeFlatKey ( cell , out ) ; writeValue ( out , cell , cell . getValueLength ( ) ) ; int tagsLength = cell . getTagsLength ( ) ; if ( withTags ) { byte [ ] len = new byte [ Bytes . SIZEOF _ SHORT ] ; Bytes . putAsShort ( len , _NUM , tagsLength ) ; out . write ( len ) ; if ( tagsLength > _NUM ) { writeTags ( out , cell , tagsLength ) ; } } int lenWritten = ( _NUM * Bytes . SIZEOF _ INT ) + estimatedSerializedSizeOfKey ( cell ) + cell . getValueLength ( ) ; if ( withTags ) { lenWritten + = Bytes . SIZEOF _ SHORT + tagsLength ; } return lenWritten ; } } 
6271	public final void openElem ( final byte [ ] name , final Atts att , final Atts nsp ) throws IOException { addElem ( name , att , nsp ) ; + + level ; } 
6272	static TBigInteger modInverseHars ( TBigInteger a , TBigInteger m ) { PRE : ( a > _NUM ) and ( m > _NUM ) TBigInteger u , v , r , s , temp ; u = MAX ( a , m ) , v = MIN ( a , m ) if ( a . compareTo ( m ) = = TBigInteger . LESS ) { u = m ; v = a ; r = TBigInteger . ZERO ; s = TBigInteger . ONE ; } else { v = m ; u = a ; s = TBigInteger . ZERO ; r = TBigInteger . ONE ; } int uLen = u . bitLength ( ) ; int vLen = v . bitLength ( ) ; int f = uLen - vLen ; while ( vLen > _NUM ) { if ( u . sign = = v . sign ) { u = u . subtract ( v . shiftLeft ( f ) ) ; r = r . subtract ( s . shiftLeft ( f ) ) ; } else { u = u . add ( v . shiftLeft ( f ) ) ; r = r . add ( s . shiftLeft ( f ) ) ; } uLen = u . abs ( ) . bitLength ( ) ; vLen = v . abs ( ) . bitLength ( ) ; f = uLen - vLen ; if ( f < _NUM ) { SWAP ( u , v ) temp = u ; u = v ; v = temp ; SWAP ( r , s ) temp = r ; r = s ; s = temp ; f = - f ; vLen = uLen ; } } if ( v . sign = = _NUM ) { return TBigInteger . ZERO ; } if ( v . sign < _NUM ) { s = s . negate ( ) ; } if ( s . compareTo ( m ) = = TBigInteger . GREATER ) { return s . subtract ( m ) ; } if ( s . sign < _NUM ) { return s . add ( m ) ; } a ^ ( - _NUM ) mod m return s ; } 
6273	public DirectoryString [ ] getPostal ( ) { if ( postalAddress = = null ) { return null ; } DirectoryString [ ] dirStrings = new DirectoryString [ postalAddress . size ( ) ] ; for ( int i = _NUM ; i ! = dirStrings . length ; i + + ) { dirStrings [ i ] = DirectoryString . getInstance ( postalAddress . getObjectAt ( i ) ) ; } return dirStrings ; } 
6274	public boolean newPage ( ) { lastElementType = - _NUM ; if ( isPageEmpty ( ) ) { setNewPageSizeAndMargins ( ) ; return false ; } if ( ! open | | close ) { throw new RuntimeException ( MessageLocalization . getComposedMessage ( _STR , new PdfRectangle ( pageSize , pageSize . getRotation ( ) ) ) ; } } [ M _NUM ] pageResources . addDefaultColorDiff ( writer . getDefaultColorspace ( ) ) ; if ( writer . isRgbTransparencyBlending ( ) ) { PdfDictionary dcs = new PdfDictionary ( ) ; dcs . put ( PdfName . CS , PdfName . DEVICERGB ) ; pageResources . addDefaultColorDiff ( dcs ) ; } PdfDictionary resources = pageResources . getResources ( ) ; we create the page dictionary PdfPage page = new PdfPage ( new PdfRectangle ( pageSize , rotation ) , thisBoxSize , resources , rotation ) ; page . put ( PdfName . TABS , writer . getTabs ( ) ) ; [ C _NUM ] if there is XMP data to add : add it if ( xmpMetadata ! = null ) { PdfStream xmp = new PdfStream ( xmpMetadata ) ; xmp . put ( PdfName . TYPE , PdfName . METADATA ) ; xmp . put ( PdfName . SUBTYPE , PdfName . XML ) ; page . put ( PdfName . METADATA , writer . addToBody ( xmp ) . getIndirectReference ( ) ) ; } [ U _NUM ] page actions : transition , duration , additional actions if ( this . transition ! = null ) { page . put ( PdfName . TRANS , this . transition . getTransitionDictionary ( ) ) ; transition = null ; } if ( this . duration > _NUM ) { page . put ( PdfName . DUR , new PdfNumber ( this . duration ) ) ; duration = _NUM ; } if ( pageAA ! = null ) { page . put ( PdfName . AA , writer . addToBody ( pageAA ) . getIndirectReference ( ) ) ; pageAA = null ; } [ U _NUM ] we add the thumbs if ( thumb ! = null ) { page . put ( PdfName . THUMB , thumb ) ; thumb = null ; } [ U _NUM ] we check if the userunit is defined if ( writer . getUserunit ( ) > _NUM f ) { page . put ( PdfName . USERUNIT , new PdfNumber ( writer . getUserunit ( ) ) ) ; } [ C _NUM ] and [ C _NUM ] we add the annotations if ( annotationsImp . hasUnusedAnnotations ( ) ) { PdfArray array = annotationsImp . rotateAnnotations ( writer , pageSize ) ; if ( array . size ( ) ! = _NUM ) page . put ( PdfName . ANNOTS , array ) ; } [ F _NUM _NUM ] we add tag info if ( writer . isTagged ( ) ) page . put ( PdfName . STRUCTPARENTS , new PdfNumber ( writer . getCurrentPageNumber ( ) - _NUM ) ) ; if ( text . size ( ) > textEmptySize ) text . endText ( ) ; else text = null ; writer . add ( page , new PdfContents ( writer . getDirectContentUnder ( ) , graphics , text , writer . getDirectContent ( ) , pageSize ) ) ; we initialize the new page initPage ( ) ; } catch ( DocumentException de ) { maybe this never happens , but it ' s better to check . throw new ExceptionConverter ( de ) ; } catch ( IOException ioe ) { throw new ExceptionConverter ( ioe ) ; } return true ; } 
6275	public void setStartDegree ( int startDegree ) { setStartEndDegree ( startDegree , endDegree ) ; } 
6276	public static String parseGetBucketLocation ( InputStream responseBody ) throws ResponseParseException { try { Element root = getXmlRootElement ( responseBody ) ; return root . getText ( ) ; } catch ( JDOMParseException e ) { throw new ResponseParseException ( e . getPartialDocument ( ) + _STR + e . getMessage ( ) , e ) ; } catch ( Exception e ) { throw new ResponseParseException ( e . getMessage ( ) , e ) ; } } 
6277	public static ColumnInfo detectColumnType ( String var , Node value , boolean allowsNulls ) throws SQLException { if ( allowsNulls & & value = = null ) { column as string return new StringColumn ( var , ResultSetMetaData . columnNullable ) ; } else if ( ! allowsNulls & & value = = null ) { throw new SQLException ( _STR ) ; } else { We know we have a non - null value so now we need to determine the column type appropriately int nullable = allowsNulls ? ResultSetMetaData . columnNullable : ResultSetMetaData . columnNoNulls ; if ( value . isBlank ( ) ) { Type blank nodes as strings return new StringColumn ( var , nullable ) ; } else if ( value . isURI ( ) ) { TODO : Does JDBC have a URL type ? return new StringColumn ( var , nullable ) ; } else if ( value . isLiteral ( ) ) { Literals will be typed based on the declared data type where applicable String dtUri = value . getLiteralDatatypeURI ( ) ; if ( dtUri ! = null ) { Is a typed literal return selectColumnType ( var , dtUri , nullable ) ; } else { Untyped literals are typed as strings return new StringColumn ( var , nullable ) ; } } else { Anything else we treat as a string return new StringColumn ( var , nullable ) ; } } } 
6278	public void alarmComplete ( IBinder who ) { if ( who = = null ) { mLog . w ( _STR + who ) ; } } } } finally { Binder . restoreCallingIdentity ( ident ) ; } } 
6279	public void removeAllAppenders ( ) { if ( appenderList ! = null ) { int len = appenderList . size ( ) ; for ( int i = _NUM ; i < len ; i + + ) { Appender a = ( Appender ) appenderList . elementAt ( i ) ; a . close ( ) ; } appenderList . removeAllElements ( ) ; appenderList = null ; } } 
6280	public void setBorderColorRight ( Color borderColorRight ) { throwReadOnlyError ( ) ; } 
6281	public void setOptions ( List < String > displayValues ) { if ( displayValues ! = null & & ! displayValues . isEmpty ( ) ) { if ( isSort ( ) ) { Collections . sort ( displayValues ) ; } getCOSObject ( ) . setItem ( COSName . OPT , COSArrayList . convertStringListToCOSStringCOSArray ( displayValues ) ) ; } else { getCOSObject ( ) . removeItem ( COSName . OPT ) ; } } 
6282	Code from https : static void copy ( File src , File dst ) throws IOException { InputStream in = new FileInputStream ( src ) ; try { OutputStream out = new FileOutputStream ( dst ) ; try { Transfer bytes from in to out byte [ ] buf = new byte [ _NUM _NUM _NUM _NUM ] ; int len ; while ( ( len = in . read ( buf ) ) > _NUM ) { out . write ( buf , _NUM , len ) ; } } finally { out . close ( ) ; } } finally { in . close ( ) ; } } 
6283	public static Properties parseArgs ( Class < ? > caller , String [ ] args , Configuration conf ) throws IOException { try { Parse command - line options if ( conf ! = null ) { args = new GenericOptionsParser ( conf , args ) . getCommandLine ( ) . getArgs ( ) ; } CommandLine cmd = new DefaultParser ( ) . parse ( options ( ) , args ) ; if ( cmd . hasOption ( HELP _ OPTION . getOpt ( ) ) ) { printUsage ( caller ) ; System . exit ( _NUM ) ; } String jobConfigLocation = JOB _ CONFIG _ OPTION . getLongOpt ( ) ; if ( ! cmd . hasOption ( jobConfigLocation ) ) { printUsage ( caller ) ; System . exit ( _NUM ) ; } Load job configuration properties Properties jobConfig ; if ( conf = = null ) { jobConfig = JobConfigurationUtils . fileToProperties ( cmd . getOptionValue ( jobConfigLocation ) ) ; } else { jobConfig = JobConfigurationUtils . fileToProperties ( cmd . getOptionValue ( jobConfigLocation ) , conf ) ; JobConfigurationUtils . putConfigurationIntoProperties ( conf , jobConfig ) ; } return jobConfig ; } catch ( ParseException | ConfigurationException e ) { throw new IOException ( e ) ; } } 
6284	public StringList descendants ( final FileFilter filter ) { final StringList files = new StringList ( ) ; final File [ ] children = filter = = null ? file . listFiles ( ) : file . listFiles ( filter ) ; if ( children = = null ) return files ; if ( exists ( ) ) addDescendants ( this , files , filter , path ( ) . length ( ) + _NUM ) ; return files ; } 
6285	private boolean performMenuItemShortcut ( int keycode , KeyEvent event ) { if ( ! ( Build . VERSION . SDK _ INT > = _NUM _NUM ) & & ! event . isCtrlPressed ( ) & & ! KeyEvent . metaStateHasNoModifiers ( event . getMetaState ( ) ) & & event . getRepeatCount ( ) = = _NUM & & ! KeyEvent . isModifierKey ( event . getKeyCode ( ) ) ) { final Window currentWindow = getWindow ( ) ; if ( currentWindow ! = null & & currentWindow . getDecorView ( ) ! = null ) { final View decorView = currentWindow . getDecorView ( ) ; if ( decorView . dispatchKeyShortcutEvent ( event ) ) { return true ; } } } return false ; } 
6286	privateOffsets . length ] ; OffsetItem [ ] fdSubrs = new DictOffsetItem [ fonts [ Font ] . fdprivateOffsets . length ] ; Reconstruct each type ReconstructFDArray ( Font , fdPrivate ) ; ReconstructPrivateDict ( Font , fdPrivate , fdPrivateBase , fdSubrs ) ; ReconstructPrivateSubrs ( Font , fdPrivateBase , fdSubrs ) ; } 
6287	public static void writeToParcel ( UserHandle h , Parcel out ) { if ( h ! = null ) { h . writeToParcel ( out , _NUM ) ; } else { out . writeInt ( USER _ NULL ) ; } } 
6288	boolean updateOrientationFromAppTokensLocked ( boolean inTransaction , int displayId ) { long ident = Binder . clearCallingIdentity ( ) ; try { final DisplayContent dc = mRoot . getDisplayContent ( displayId ) ; final int req = dc . getOrientation ( ) ; if ( req ! = dc . getLastOrientation ( ) ) { dc . setLastOrientation ( req ) ; TODO ( multi - display ) : Implement policy for secondary displays . if ( dc . isDefaultDisplay ) { mPolicy . setCurrentOrientationLw ( req ) ; } if ( dc . updateRotationUnchecked ( inTransaction ) ) { changed return true ; } } return false ; } finally { Binder . restoreCallingIdentity ( ident ) ; } } 
6289	private AssociateSoftwareTokenResult associateTotpMfaInternalWithTokens ( final CognitoUserSession session ) { if ( session ! = null & & session . isValid ( ) ) { final AssociateSoftwareTokenRequest request = new AssociateSoftwareTokenRequest ( ) ; request . setAccessToken ( session . getAccessToken ( ) . getJWTToken ( ) ) ; return associateTotpMfaInternal ( request ) ; } else { throw new CognitoNotAuthorizedException ( _STR ) ; } } 
6290	public void startSearch ( String initialQuery , boolean selectInitialQuery , ComponentName launchActivity , Bundle appSearchData , boolean globalSearch , Rect sourceBounds ) { if ( globalSearch ) { startGlobalSearch ( initialQuery , selectInitialQuery , appSearchData , sourceBounds ) ; return ; } final UiModeManager uiModeManager = mContext . getSystemService ( UiModeManager . class ) ; Don ' t show search dialog on televisions . if ( uiModeManager . getCurrentModeType ( ) ! = Configuration . UI _ MODE _ TYPE _ TELEVISION ) { ensureSearchDialog ( ) ; mSearchDialog . show ( initialQuery , selectInitialQuery , launchActivity , appSearchData ) ; } } 
6291	protected void acquireWriteLock ( ) throws StaleReaderException , CorruptIndexException , LockObtainFailedException , IOException { if ( readOnly ) { NOTE : we should not reach this code w / the core IndexReader classes ; however , an external subclass of IndexReader could reach this . ReadOnlySegmentReader . noWrite ( ) ; } if ( segmentInfos ! = null ) { ensureOpen ( ) ; if ( stale ) throw new StaleReaderException ( _STR ) ; } } } } 
6292	public void testgetStartEndOffset ( ) throws Exception { KeyFieldHelper helper = new KeyFieldHelper ( ) ; helper . setKeyFieldSeparator ( _STR ; testKeySpecs ( input , expectedOutput , helper , _NUM _NUM , _NUM _NUM ) ; } 
6293	public boolean hasRole ( PrincipalCollection principals , String roleIdentifier ) { assertRealmsConfigured ( ) ; for ( Realm realm : getRealms ( ) ) { if ( ! ( realm instanceof Authorizer ) ) continue ; if ( ( ( Authorizer ) realm ) . hasRole ( principals , roleIdentifier ) ) { return true ; } } return false ; } 
6294	private boolean isFrameObject ( String outputName ) { Data data = getData ( outputName ) ; return ( data instanceof FrameObject ) ; } 
6295	public void actionCommit ( ) { List errors = new ArrayList ( ) ; boolean isEmail = ( getParamMsgtype ( ) ! = null ) & & getParamMsgtype ( ) . equals ( MSGTYPE _ EMAIL ) ; if ( ( m _ groups = = null ) | | m _ groups . isEmpty ( ) ) { setCommitErrors ( Collections . singletonList ( ( Throwable ) new CmsIllegalStateException ( Messages . get ( ) . container ( Messages . ERR _ NO _ SELECTED _ GROUP _ _NUM ) ) ) ) ; return ; } boolean hasUser = false ; Iterator itGroups = getGroups ( ) . iterator ( ) ; while ( ! hasUser & & itGroups . hasNext ( ) ) { String groupName = ( String ) itGroups . next ( ) ; try { Iterator itUsers = getCms ( ) . getUsersOfGroup ( groupName , true ) . iterator ( ) ; while ( ! hasUser & & itUsers . hasNext ( ) ) { CmsUser user = ( CmsUser ) itUsers . next ( ) ; if ( ! isEmail ) { if ( ! OpenCms . getSessionManager ( ) . getSessionInfos ( user . getId ( ) ) . isEmpty ( ) ) { hasUser = true ; } } else { if ( CmsStringUtil . isNotEmptyOrWhitespaceOnly ( user . getEmail ( ) ) ) { hasUser = true ; } } } } catch ( CmsException e ) { should never happen } } if ( ! hasUser ) { setCommitErrors ( Collections . singletonList ( ( Throwable ) new CmsIllegalStateException ( Messages . get ( ) . container ( Messages . ERR _ NO _ SELECTED _ RECEIVERS _ _NUM ) ) ) ) ; return ; } try { Set groups = new HashSet ( m _ groups ) ; Map params = new HashMap ( ) ; params . put ( CmsToolDialog . PARAM _ STYLE , CmsToolDialog . STYLE _ NEW ) ; params . put ( CmsSendEmailGroupsDialog . PARAM _ GROUPS , CmsStringUtil . collectionAsString ( groups , CmsHtmlList . ITEM _ SEPARATOR ) ) ; params . put ( CmsDialog . PARAM _ CLOSELINK , CmsToolManager . linkForToolPath ( getJsp ( ) , _STR , params ) ; } } catch ( Throwable t ) { errors . add ( t ) ; } set the list of errors to display when saving failed setCommitErrors ( errors ) ; } 
6296	protected boolean matchesWhen ( Exchange exchange ) { if ( onWhen = = null ) { if no predicate then it ' s always a match return true ; } return onWhen . matches ( exchange ) ; } 
6297	public void setAttributes ( Revisions < PDAttributeObject > attributes ) { COSName key = COSName . A ; if ( ( attributes . size ( ) = = _NUM ) & & ( attributes . getRevisionNumber ( _NUM ) = = _NUM ) ) { PDAttributeObject attributeObject = attributes . getObject ( _NUM ) ; attributeObject . setStructureElement ( this ) ; this . getCOSObject ( ) . setItem ( key , attributeObject ) ; return ; } COSArray array = new COSArray ( ) ; for ( int i = _NUM ; i < attributes . size ( ) ; i + + ) { PDAttributeObject attributeObject = attributes . getObject ( i ) ; attributeObject . setStructureElement ( this ) ; int revisionNumber = attributes . getRevisionNumber ( i ) ; if ( revisionNumber < _NUM ) { throw new IllegalArgumentException ( _STR ) ; } array . add ( attributeObject ) ; array . add ( COSInteger . get ( revisionNumber ) ) ; } this . getCOSObject ( ) . setItem ( key , array ) ; } 
6298	void peekDrawer ( WearableDrawerView drawer ) { if ( drawer = = null ) { throw new IllegalArgumentException ( _STR ) ; } if ( drawer = = mTopDrawerView ) { mShouldPeekTopDrawerAfterLayout = true ; } else if ( drawer = = mBottomDrawerView ) { mShouldPeekBottomDrawerAfterLayout = true ; } return ; } maybePeekDrawer ( drawer ) ; } 
6299	void screenTurningOff ( ScreenOffListener listener ) { if ( shouldDisableSnapshots ( ) ) { listener . onScreenOff ( ) ; return ; } We can ' t take a snapshot when screen is off , so take a snapshot now ! mHandler . post ( ( ) - > { try { synchronized ( mService . mWindowMap ) { mTmpTasks . clear ( ) ; mService . mRoot . forAllTasks ( task - > { if ( task . isVisible ( ) ) { mTmpTasks . add ( task ) ; } } ) ; snapshotTasks ( mTmpTasks ) ; } } finally { listener . onScreenOff ( ) ; } } ) ; } 
6300	public final boolean add ( final int key ) { return index ( key ) > _NUM ; } 
6301	public Component getSelectedComponent ( ) { int i = getSelectedIndex ( ) ; if ( i = = - _NUM ) { return null ; } return getTabComponentAt ( i ) ; } 
6302	public void addIgnored ( Class c , String displayName ) { HashSet < String > list ; retrieve list if ( m _ Ignored . contains ( c ) ) { list = ( HashSet < String > ) m _ Ignored . get ( c ) ; } else { list = new HashSet < String > ( ) ; m _ Ignored . put ( c , list ) ; } list . add ( displayName ) ; } 
6303	public static < S , R extends Writable > ReducerArrayHandle < S , R > createGlobalReducerArrayHandle ( final int fixedSize , final ReduceOperation < S , R > elementReduceOp , final CreateReducersApi reduceApi , int maxNumStripes ) { PrimitiveTypeOps < R > typeOps = TypeOpsUtils . getPrimitiveTypeOpsOrNull ( ( Class < R > ) elementReduceOp . createInitialValue ( ) . getClass ( ) ) ; final CreateReducerFunctionApi createReducer = new CreateReducerFunctionApi ( ) { @ Override public < S , R extends Writable > ReducerHandle < S , R > createReducer ( ReduceOperation < S , R > reduceOp ) { return reduceApi . createGlobalReducer ( reduceOp ) ; } } ; if ( fixedSize < maxNumStripes ) { return new ArrayOfReducers < > ( fixedSize , new Supplier < ReducerHandle < S , R > > ( ) { @ Override public ReducerHandle < S , R > get ( ) { return createReducer . createReducer ( elementReduceOp ) ; } } ) ; } else { final ObjectStriping striping = new ObjectStriping ( fixedSize , maxNumStripes ) ; final ArrayList < ReducerArrayHandle < S , R > > handles = new ArrayList < > ( striping . getSplits ( ) ) ; for ( int i = _NUM ; i < striping . getSplits ( ) ; i + + ) { if ( typeOps ! = null ) { handles . add ( BasicArrayReduce . createArrayHandles ( striping . getSplitSize ( i ) , typeOps , elementReduceOp , createReducer ) ) ; } else { handles . add ( ArrayReduce . createArrayHandles ( striping . getSplitSize ( i ) , elementReduceOp , createReducer ) ) ; } } return new ReducerArrayHandle < S , R > ( ) { @ Override public ReducerHandle < S , R > get ( int index ) { if ( ( index > = fixedSize ) | | ( index < _NUM ) ) { throw new RuntimeException ( _STR ) ; } } ; } } 
6304	public void testL _NUM tpIpsecRsaConnection ( ) throws Exception { mPreviousIpAddress = getIpAddress ( ) ; VpnInfo curVpnInfo = mVpnInfoPool . get ( VpnProfile . TYPE _ L _NUM TP _ IPSEC _ RSA ) ; VpnProfile vpnProfile = curVpnInfo . getVpnProfile ( ) ; if ( DEBUG ) { printVpnProfile ( vpnProfile ) ; } String certFile = curVpnInfo . getCertificateFile ( ) ; String password = curVpnInfo . getPassword ( ) ; installCertificatesFromFile ( vpnProfile , certFile , password ) ; connect ( vpnProfile ) ; validateVpnConnection ( vpnProfile ) ; } 
6305	public void convict ( InetAddressAndPort endpoint , double phi ) { EndpointState epState = endpointStateMap . get ( endpoint ) ; if ( epState = = null ) return ; if ( ! epState . isAlive ( ) ) return ; logger . debug ( _STR , endpoint , getGossipStatus ( epState ) , epState . isAlive ( ) ) ; if ( isShutdown ( endpoint ) ) { markAsShutdown ( endpoint ) ; } else { markDead ( endpoint , epState ) ; } } 
6306	public org . bitcoinj . wallet . Protos . Tag . Builder addTagsBuilder ( ) { return getTagsFieldBuilder ( ) . addBuilder ( org . bitcoinj . wallet . Protos . Tag . getDefaultInstance ( ) ) ; } 
6307	public int [ ] computeGids ( int [ ] userIds ) { int [ ] gids = mGlobalGids ; for ( int userId : userIds ) { final int [ ] userGids = computeGids ( userId ) ; gids = appendInts ( gids , userGids ) ; } return gids ; } 
6308	private void rCheckCandidates ( Candidate c , DataType cdt , ArrayList < StatementBlock > asb , Integer sCount , boolean [ ] dep ) { check candidate only ( output dependency if scalar or constant matrix subscript ) if ( cdt = = DataType . SCALAR | | dat _NUM checked for other candidate cdt = = DataType . OBJECT ) { every write to a scalar or complete data object is an output dependency dep [ _NUM ] = true ; if ( ABORT _ ON _ FIRST _ DEPENDENCY ) return ; } else if ( cdt = = DataType . MATRIX ) { if ( runConstantCheck ( c . _ dat ) & & ! c . _ isAccum ) { if ( LOG . isTraceEnabled ( ) ) LOG . trace ( _STR ) ; } } } } } 
6309	public boolean removeHeaderView ( View v ) { if ( mHeaderViewInfos . size ( ) > _NUM ) { return removeFixedViewInfo ( v , mHeaderViewInfos ) ; } return false ; } 
6310	public boolean isEmpty ( ) { return size ( ) = = _NUM ; } 
6311	public java . lang . StringBuilder insert ( int index , java . lang . String string ) { if ( string = = null ) { string = _STR ; } int min = string . length ( ) ; if ( min ! = _NUM ) { move ( min , index ) ; string . getChars ( _NUM , min , value , index ) ; count + = min ; } return this ; } 
6312	private void layoutCue ( int viewportWidth , int viewportHeight , CueLayout cueBox ) { final TextTrackCue cue = cueBox . getCue ( ) ; final int direction = getLayoutDirection ( ) ; final int absAlignment = resolveCueAlignment ( direction , cue . mAlignment ) ; final boolean cueSnapToLines = cue . mSnapToLines ; int size = _NUM _NUM _NUM * cueBox . getMeasuredWidth ( ) / viewportWidth ; Determine raw x - position . int xPosition ; switch ( absAlignment ) { case TextTrackCue . ALIGNMENT _ LEFT : xPosition = cue . mTextPosition ; break ; case TextTrackCue . ALIGNMENT _ RIGHT : xPosition = cue . mTextPosition - size ; break ; case TextTrackCue . ALIGNMENT _ MIDDLE : default : xPosition = cue . mTextPosition - size / _NUM ; break ; } Adjust x - position for layout . if ( direction = = LAYOUT _ DIRECTION _ RTL ) { xPosition = _NUM _NUM _NUM - xPosition ; } cue within the title - safe area . if ( cueSnapToLines ) { final int paddingLeft = _NUM _NUM _NUM * getPaddingLeft ( ) / viewportWidth ; final int paddingRight = _NUM _NUM _NUM * getPaddingRight ( ) / viewportWidth ; if ( xPosition < paddingLeft & & xPosition + size > paddingLeft ) { xPosition + = paddingLeft ; size - = paddingLeft ; } final float rightEdge = _NUM _NUM _NUM - paddingRight ; if ( xPosition < rightEdge & & xPosition + size > rightEdge ) { size - = paddingRight ; } } Compute absolute left position and width . final int left = xPosition * viewportWidth / _NUM _NUM _NUM ; final int width = size * viewportWidth / _NUM _NUM _NUM ; Determine initial y - position . final int yPosition = calculateLinePosition ( cueBox ) ; Compute absolute final top position and height . final int height = cueBox . getMeasuredHeight ( ) ; final int top ; if ( yPosition < _NUM ) { TODO : This needs to use the actual height of prior boxes . top = viewportHeight + yPosition * height ; } else { top = yPosition * ( viewportHeight - height ) / _NUM _NUM _NUM ; } Layout cue in final position . cueBox . layout ( left , top , left + width , top + height ) ; } 
6313	public void testAutoBalanceSplits ( ) throws IOException { testAutobalanceNumOfSplit ( ) ; } 
6314	public static void initTableReducerJob ( String table , Class < ? extends TableReducer > reducer , Job job , Class partitioner , String quorumAddress , String serverClass , String serverImpl , boolean addDependencyJars ) throws IOException { Configuration conf = job . getConfiguration ( ) ; HBaseConfiguration . merge ( conf , HBaseConfiguration . create ( conf ) ) ; job . setOutputFormatClass ( TableOutputFormat . class ) ; if ( reducer ! = null ) job . setReducerClass ( reducer ) ; conf . set ( TableOutputFormat . OUTPUT _ TABLE , table ) ; conf . setStrings ( _STR ) , MutationSerialization . class . getName ( ) , ResultSerialization . class . getName ( ) ) ; If passed a quorum / ensemble address , pass it on to TableOutputFormat . if ( quorumAddress ! = null ) { Calling this will validate the format ZKConfig . validateClusterKey ( quorumAddress ) ; conf . set ( TableOutputFormat . QUORUM _ ADDRESS , quorumAddress ) ; } if ( serverClass ! = null & & serverImpl ! = null ) { conf . set ( TableOutputFormat . REGION _ SERVER _ CLASS , serverClass ) ; conf . set ( TableOutputFormat . REGION _ SERVER _ IMPL , serverImpl ) ; } job . setOutputKeyClass ( ImmutableBytesWritable . class ) ; job . setOutputValueClass ( Writable . class ) ; if ( partitioner = = HRegionPartitioner . class ) { job . setPartitionerClass ( HRegionPartitioner . class ) ; int regions = MetaTableAccessor . getRegionCount ( conf , TableName . valueOf ( table ) ) ; if ( job . getNumReduceTasks ( ) > regions ) { job . setNumReduceTasks ( regions ) ; } } else if ( partitioner ! = null ) { job . setPartitionerClass ( partitioner ) ; } if ( addDependencyJars ) { addDependencyJars ( job ) ; } initCredentials ( job ) ; } 
6315	public Set < Map . Entry < From , To > > entrySet ( ) { Set < Map . Entry < From , To > > s = CollectionFactory . createHashedSet ( ) ; for ( From key : m _ table . keySet ( ) ) { List < To > values = m _ table . get ( key ) ; add each key - value pair to the result set for ( ListIterator < To > e _NUM = values . listIterator ( ) ; e _NUM . hasNext ( ) ; ) { s . add ( new Entry < > ( key , e _NUM . next ( ) ) ) ; } } return s ; } 
6316	protected Size _NUM D arrangeRR ( BlockContainer container , Graphics _NUM D g _NUM , RectangleConstraint constraint ) { first arrange without constraints , and see if this fits within the required ranges . . . Size _NUM D s _NUM = arrangeNN ( container , g _NUM ) ; if ( constraint . getHeightRange ( ) . contains ( s _NUM . height ) ) { TODO : we didn ' t check the width yet return s _NUM ; } else { RectangleConstraint c = constraint . toFixedHeight ( constraint . getHeightRange ( ) . getUpperBound ( ) ) ; return arrangeRF ( container , g _NUM , c ) ; } } 
6317	private int getNumberOfUSMServicesWithRunningState ( final ProcessingUnit processingUnit ) { int puInstanceCounter = _NUM ; if ( processingUnit ! = null ) { for ( ProcessingUnitInstance pui : processingUnit . getInstances ( ) ) { if ( isUsmStateOfPuiRunning ( pui ) ) { puInstanceCounter + + ; } } } return puInstanceCounter ; } 
6318	 @ Test ( groups = _STR ) ; QueryTracker queryTracker = new QueryTracker ( ) ; queryTracker . query ( session , _NUM _NUM , statement ) ; then : primary replica is _NUM , secondary is _NUM ; since the child policy returns [ _NUM , _NUM , _NUM , _NUM ] , the TAP reorders the plan to [ _NUM , _NUM , _NUM , _NUM ] . Only _NUM should be queried queryTracker . assertQueried ( sCluster , _NUM , _NUM , _NUM _NUM ) ; queryTracker . assertQueried ( sCluster , _NUM , _NUM , _NUM ) ; queryTracker . assertQueried ( sCluster , _NUM , _NUM , _NUM ) ; queryTracker . assertQueried ( sCluster , _NUM , _NUM , _NUM ) ; when : The secondary node owning that key ( _NUM ) goes down and a query is made . queryTracker . reset ( ) ; sCluster . stop ( cluster , _NUM ) ; queryTracker . query ( session , _NUM _NUM , statement ) ; then : The next replica having that data should be chosen ( node _NUM - primary replica ) . queryTracker . assertQueried ( sCluster , _NUM , _NUM , _NUM ) ; queryTracker . assertQueried ( sCluster , _NUM , _NUM , _NUM ) ; queryTracker . assertQueried ( sCluster , _NUM , _NUM , _NUM ) ; queryTracker . assertQueried ( sCluster , _NUM , _NUM , _NUM _NUM ) ; when : All nodes having that token are down and a query is made . queryTracker . reset ( ) ; sCluster . stop ( cluster , _NUM ) ; queryTracker . query ( session , _NUM _NUM , statement ) ; then : The remaining nodes which are non - replicas of that token should be used delegating to the child policy . queryTracker . assertQueried ( sCluster , _NUM , _NUM , _NUM ) ; queryTracker . assertQueried ( sCluster , _NUM , _NUM , _NUM _NUM ) ; queryTracker . assertQueried ( sCluster , _NUM , _NUM , _NUM ) ; queryTracker . assertQueried ( sCluster , _NUM , _NUM , _NUM ) ; when : A replica having that key ( _NUM ) becomes up and a query is made . queryTracker . reset ( ) ; sCluster . start ( cluster , _NUM ) ; queryTracker . query ( session , _NUM _NUM , statement ) ; then : The newly up replica should be queried . queryTracker . assertQueried ( sCluster , _NUM , _NUM , _NUM ) ; queryTracker . assertQueried ( sCluster , _NUM , _NUM , _NUM ) ; queryTracker . assertQueried ( sCluster , _NUM , _NUM , _NUM ) ; queryTracker . assertQueried ( sCluster , _NUM , _NUM , _NUM _NUM ) ; when : The other replica becomes up and a query is made . queryTracker . reset ( ) ; sCluster . start ( cluster , _NUM ) ; queryTracker . query ( session , _NUM _NUM , statement ) ; then : The secondary replica ( _NUM ) which is now up should be queried . queryTracker . assertQueried ( sCluster , _NUM , _NUM , _NUM _NUM ) ; queryTracker . assertQueried ( sCluster , _NUM , _NUM , _NUM ) ; queryTracker . assertQueried ( sCluster , _NUM , _NUM , _NUM ) ; queryTracker . assertQueried ( sCluster , _NUM , _NUM , _NUM ) ; } finally { cluster . close ( ) ; sCluster . stop ( ) ; } } 
6319	public void testDeleteNew ( ) throws Exception { CmsObject cms = getCmsObject ( ) ; String baseName = _STR ; CmsResource res = createFile ( ) ; addMapping ( baseName , res ) ; delete ( res ) ; assertNull ( cms . readIdForUrlName ( baseName ) ) ; assertNull ( readBestUrlName ( cms , res . getStructureId ( ) ) ) ; } 
6320	private boolean scrollAndFocus ( int direction , int left , int right ) { boolean handled = true ; int width = getWidth ( ) ; int containerLeft = getScrollX ( ) ; int containerRight = containerLeft + width ; boolean goLeft = direction = = View . FOCUS _ LEFT ; View newFocused = findFocusableViewInBounds ( goLeft , left , right ) ; if ( newFocused = = null ) { newFocused = this ; } if ( left > = containerLeft & & right < = containerRight ) { handled = false ; } else { int delta = goLeft ? ( left - containerLeft ) : ( right - containerRight ) ; doScrollX ( delta ) ; } if ( newFocused ! = findFocus ( ) ) newFocused . requestFocus ( direction ) ; return handled ; } 
6321	private ProjectCache cache ( final IOFile root ) throws InterruptedException { final ProjectCache pc = cache ; if ( pc = = null ) { no file cache available : create and return new one cache = new ProjectCache ( ) ; add ( root , cache ) ; cache . finish ( ) ; } else { wait until file cache is initialized while ( ! pc . valid ( ) ) { Performance . sleep ( _NUM ) ; file cache was replaced with newer version if ( pc ! = cache ) throw new InterruptedException ( ) ; } } return existing file cache return cache ; } 
6322	public void setAllCap ( boolean flag ) { setFlagBit ( FLAG _ ALL _ CAP , flag ) ; } 
6323	public boolean isSet ( _ Fields field ) { if ( field = = null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case WORKER _ ID : return isSetWorkerId ( ) ; } throw new IllegalStateException ( ) ; } 
6324	public Disruptor createDisruptor ( String topic ) { TreeSet handlers = getHandles ( topic ) ; if ( handlers = = null ) return null ; Disruptor dw = createDw ( topic ) ; Disruptor disruptor = addEventMessageHandler ( dw , topic , handlers ) ; if ( disruptor = = null ) return null ; disruptor . start ( ) ; return disruptor ; } 
6325	public Object lookup ( int key ) { return mItems . get ( key ) ; } 
6326	public static HmmModel truncateModel ( HmmModel model , double threshold ) { Vector ip = model . getInitialProbabilities ( ) ; Matrix em = model . getEmissionMatrix ( ) ; Matrix tr = model . getTransitionMatrix ( ) ; allocate the sparse data structures RandomAccessSparseVector sparseIp = new RandomAccessSparseVector ( model . getNrOfHiddenStates ( ) ) ; SparseMatrix sparseEm = new SparseMatrix ( model . getNrOfHiddenStates ( ) , model . getNrOfOutputStates ( ) ) ; SparseMatrix sparseTr = new SparseMatrix ( model . getNrOfHiddenStates ( ) , model . getNrOfHiddenStates ( ) ) ; now transfer the values for ( int i = _NUM ; i < model . getNrOfHiddenStates ( ) ; + + i ) { double value = ip . getQuick ( i ) ; if ( value > threshold ) { sparseIp . setQuick ( i , value ) ; } for ( int j = _NUM ; j < model . getNrOfHiddenStates ( ) ; + + j ) { value = tr . getQuick ( i , j ) ; if ( value > threshold ) { sparseTr . setQuick ( i , j , value ) ; } } for ( int j = _NUM ; j < model . getNrOfOutputStates ( ) ; + + j ) { value = em . getQuick ( i , j ) ; if ( value > threshold ) { sparseEm . setQuick ( i , j , value ) ; } } } create a new model HmmModel sparseModel = new HmmModel ( sparseTr , sparseEm , sparseIp ) ; normalize the model normalizeModel ( sparseModel ) ; register the names sparseModel . registerHiddenStateNames ( model . getHiddenStateNames ( ) ) ; sparseModel . registerOutputStateNames ( model . getOutputStateNames ( ) ) ; and return return sparseModel ; } 
6327	public List < Dependency > getMissingDependencies ( List < Package > packages ) throws Exception { List < Dependency > missing = new ArrayList < Dependency > ( ) ; String dependencies = getPackageMetaDataElement ( _STR ) ; while ( tok . hasMoreTokens ( ) ) { String nextT = tok . nextToken ( ) . trim ( ) ; String [ ] split = splitNameVersion ( nextT ) ; don ' t consider the base system ! if ( ! ( split [ _NUM ] . equalsIgnoreCase ( m _ packageManager . getBaseSystemName ( ) ) ) ) { gets the latest version of this package if split [ _NUM ] is null Package tempDep = m _ packageManager . getRepositoryPackageInfo ( split [ _NUM ] , split [ _NUM ] ) ; if ( ! findPackage ( split [ _NUM ] , packages ) ) { VersionPackageConstraint versionConstraint = new VersionPackageConstraint ( tempDep ) ; if ( split [ _NUM ] = = null ) { assume anything up to and including the current version is acceptable versionConstraint . setVersionConstraint ( VersionPackageConstraint . VersionComparison . LESSTHANOREQUAL ) ; missing . add ( new Dependency ( this , versionConstraint ) ) ; } else { if ( split . length = = _NUM ) { versionConstraint . setVersionConstraint ( split [ _NUM ] ) ; missing . add ( new Dependency ( this , versionConstraint ) ) ; } else { VersionRangePackageConstraint versionRConstraint = new VersionRangePackageConstraint ( tempDep ) ; VersionPackageConstraint . VersionComparison comp _NUM = VersionPackageConstraint . getVersionComparison ( split [ _NUM ] ) ; VersionPackageConstraint . VersionComparison comp _NUM = VersionPackageConstraint . getVersionComparison ( split [ _NUM ] ) ; versionRConstraint . setRangeConstraint ( split [ _NUM ] , comp _NUM , split [ _NUM ] , comp _NUM ) ; missing . add ( new Dependency ( this , versionRConstraint ) ) ; } } } } } } return missing ; } 
6328	public void setBeanContext ( BeanContext bc ) { m _ beanContext = bc ; m _ design = m _ beanContext . isDesignTime ( ) ; if ( m _ design ) { appearanceDesign ( ) ; } else { java . awt . GraphicsEnvironment ge = java . awt . GraphicsEnvironment . getLocalGraphicsEnvironment ( ) ; if ( ! ge . isHeadless ( ) ) { appearanceFinal ( ) ; } } } 
6329	void removeSkippedScrap ( ) { if ( mSkippedScrap = = null ) { return ; } final int count = mSkippedScrap . size ( ) ; for ( int i = _NUM ; i < count ; i + + ) { removeDetachedView ( mSkippedScrap . get ( i ) , false ) ; } mSkippedScrap . clear ( ) ; } 
6330	public boolean getBoolean ( int tag ) { if ( hwEnforced . containsTag ( tag ) ) { return hwEnforced . getBoolean ( tag ) ; } else { return swEnforced . getBoolean ( tag ) ; } } 
6331	public List < CmsGroup > getGroups ( CmsDbContext dbc , CmsOrganizationalUnit orgUnit , boolean includeSubOus , boolean readRoles ) throws CmsException { return getUserDriver ( dbc ) . getGroups ( dbc , orgUnit , includeSubOus , readRoles ) ; } 
6332	public Response authorize ( ) { MultivaluedMap < String , String > params = getQueryParameters ( ) ; return startAuthorization ( params ) ; } 
6333	public static < X > X readThreadLocal ( ThreadLocal < X > threadLocal ) { X x = threadLocal . get ( ) ; if ( x = = null ) threadLocal . remove ( ) ; return x ; } 
6334	public static List < String > readLines ( final File file , final Charset encoding ) throws IOException { try ( InputStream in = openInputStream ( file ) ) { return IOUtils . readLines ( in , Charsets . toCharset ( encoding ) ) ; } } 
6335	public static String getDescWithoutMethodName ( final CtMethod m ) throws NotFoundException { StringBuilder ret = new StringBuilder ( ) ; ret . append ( ' ( ' ) ; CtClass [ ] parameterTypes = m . getParameterTypes ( ) ; for ( int i = _NUM ; i < parameterTypes . length ; i + + ) ret . append ( getDesc ( parameterTypes [ i ] ) ) ; ret . append ( ' ) ' ) . append ( getDesc ( m . getReturnType ( ) ) ) ; return ret . toString ( ) ; } 
6336	public boolean isExpected ( final HandlingEvent event ) { if ( legs . isEmpty ( ) ) { return true ; } if ( event . type ( ) = = HandlingEvent . Type . RECEIVE ) { Check that the first leg ' s origin is the event ' s location final Leg leg = legs . get ( _NUM ) ; return ( leg . loadLocation ( ) . equals ( event . location ( ) ) ) ; } if ( event . type ( ) = = HandlingEvent . Type . LOAD ) { Check that the there is one leg with same load location and voyage for ( Leg leg : legs ) { if ( leg . loadLocation ( ) . sameIdentityAs ( event . location ( ) ) & & leg . voyage ( ) . sameIdentityAs ( event . voyage ( ) ) ) return true ; } return false ; } if ( event . type ( ) = = HandlingEvent . Type . UNLOAD ) { Check that the there is one leg with same unload location and voyage for ( Leg leg : legs ) { if ( leg . unloadLocation ( ) . equals ( event . location ( ) ) & & leg . voyage ( ) . equals ( event . voyage ( ) ) ) return true ; } return false ; } if ( event . type ( ) = = HandlingEvent . Type . CLAIM ) { Check that the last leg ' s destination is from the event ' s location final Leg leg = lastLeg ( ) ; return ( leg . unloadLocation ( ) . equals ( event . location ( ) ) ) ; } HandlingEvent . Type . CUSTOMS ; return true ; } 
6337	AppWindowToken getAppWindowToken ( IBinder binder ) { for ( int i = mChildren . size ( ) - _NUM ; i > = _NUM ; - - i ) { final DisplayContent dc = mChildren . get ( i ) ; final AppWindowToken atoken = dc . getAppWindowToken ( binder ) ; if ( atoken ! = null ) { return atoken ; } } return null ; } 
6338	public static XmlFloat parse ( java . io . Reader r ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( XmlFloat ) XmlBeans . getContextTypeLoader ( ) . parse ( r , type , null ) ; } 
6339	public synchronized boolean equals ( Object object ) { if ( this = = object ) { return true ; } if ( object instanceof Map ) { Map < ? , ? > map = ( Map < ? , ? > ) object ; if ( size ( ) ! = map . size ( ) ) { return false ; } Set < Map . Entry < K , V > > entries = entrySet ( ) ; Iterator it = map . entrySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { Map . Entry < ? , ? > e = ( Map . Entry < ? , ? > ) it . next ( ) ; if ( ! entries . contains ( e ) ) { return false ; } } return true ; } return false ; } 
6340	public final String parameters ( final Context ctx ) { try { init ( args [ _NUM ] , ctx ) ; return qp . qc . serParams ( ) . toString ( ) ; } catch ( final QueryException ex ) { error ( Util . message ( ex ) ) ; } finally { qp = null ; popJob ( ) ; } return SerializerMode . DEFAULT . get ( ) . toString ( ) ; } 
6341	public String buildResultList ( ) { StringBuffer result = new StringBuffer ( _NUM _NUM ) ; if ( ( getChangedResources ( ) ! = null ) & & ( getChangedResources ( ) . size ( ) > _NUM ) ) { at least one resource property value has been changed , show list for ( int i = _NUM ; i < getChangedResources ( ) . size ( ) ; i + + ) { CmsResource res = ( CmsResource ) getChangedResources ( ) . get ( i ) ; String resName = getCms ( ) . getSitePath ( res ) ; result . append ( resName ) ; result . append ( _STR ) ; } } else { nothing was changed , show message result . append ( Messages . get ( ) . getBundle ( getLocale ( ) ) . key ( Messages . GUI _ INPUT _ PROPERTYCHANGE _ RESULT _ NONE _ _NUM ) ) ; } return result . toString ( ) ; } 
6342	public void separate ( RemoteConnection connection ) { if ( mChildConnections . contains ( connection ) ) { try { mConnectionService . splitFromConference ( connection . getId ( ) , null ) ; } catch ( RemoteException e ) { } } } 
6343	public void testClusteringEuclideanSeq ( ) throws Exception { List < VectorWritable > points = getPointsWritable ( ) ; Configuration config = getConfiguration ( ) ; ClusteringTestUtils . writePointsToFile ( points , getTestTempFilePath ( _STR , points . size ( ) , count ) ; } 
6344	private void onPrepared ( final boolean startWhenPrepared ) { playerLock . lock ( ) ; if ( playerStatus ! = PlayerStatus . PREPARING ) { playerLock . unlock ( ) ; throw new IllegalStateException ( _STR ) ; media . setDuration ( mediaPlayer . getDuration ( ) ) ; } setPlayerStatus ( PlayerStatus . PREPARED , media ) ; if ( startWhenPrepared ) { resumeSync ( ) ; } playerLock . unlock ( ) ; } 
6345	public void testRolloverThenLeaderRestart ( ) throws Exception { ZooKeeper zk = getClient ( idxLeader ) ; int countCreated = createNodes ( zk , _NUM , _NUM _NUM ) ; adjustEpochNearEnd ( ) ; checkNodes ( zk , _NUM , countCreated ) ; shutdown ( idxLeader ) ; start ( idxLeader ) ; zk = getClient ( idxLeader ) ; checkNodes ( zk , _NUM , countCreated ) ; countCreated + = createNodes ( zk , countCreated , _NUM _NUM ) ; adjustEpochNearEnd ( ) ; checkNodes ( zk , _NUM , countCreated ) ; countCreated + = createNodes ( zk , countCreated , _NUM _NUM ) ; shutdown ( idxLeader ) ; start ( idxLeader ) ; zk = getClient ( idxLeader ) ; checkNodes ( zk , _NUM , countCreated ) ; countCreated + = createNodes ( zk , countCreated , _NUM _NUM ) ; shutdown ( idxLeader ) ; start ( idxLeader ) ; zk = getClient ( idxFollower ) ; checkNodes ( zk , _NUM , countCreated ) ; countCreated + = createNodes ( zk , countCreated , _NUM _NUM ) ; sanity check Assert . assertTrue ( countCreated > _NUM ) ; Assert . assertTrue ( countCreated < _NUM _NUM ) ; } 
6346	public org . apache . drill . exec . proto . CoordinationProtos . DrillbitEndpoint . Builder getForemanBuilder ( ) { bitField _NUM _ | = _NUM x _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM ; onChanged ( ) ; return getForemanFieldBuilder ( ) . getBuilder ( ) ; } 
6347	public String toCQLString ( ) { return maybeQuote ( text ) ; } 
6348	public static void execHttpGet ( String url , String acceptHeader , HttpResponseHandler handler , HttpClient httpClient , HttpContext httpContext ) { String requestURI = determineRequestURI ( url ) ; HttpGet httpget = new HttpGet ( requestURI ) ; exec ( url , httpget , acceptHeader , handler , httpClient , httpContext ) ; } 
6349	private static String huntForShiroIni ( String [ ] locations ) { FusekiEnv . setEnvironment ( ) ; Fuseki . init ( ) ; for ( String loc : locations ) { If file : , look for that file . If a relative name without scheme , look in FUSEKI _ BASE , FUSEKI _ HOME , webapp . String scheme = FileUtils . getScheme ( loc ) ; Covers C : \ \ as a _STR file : + fn ; try ( InputStream is = ResourceUtils . getInputStreamForPath ( loc ) ) { boolean exists = ( is ! = null ) ; return loc ; } catch ( IOException e ) { } } return null ; } 
6350	private static List < DatanodeDescriptor > chooseDatanodesForCaching ( final List < DatanodeDescriptor > possibilities , final int neededCached , final long staleInterval ) { Make a copy that we can modify List < DatanodeDescriptor > targets = new ArrayList < DatanodeDescriptor > ( possibilities ) ; Selected targets List < DatanodeDescriptor > chosen = new LinkedList < DatanodeDescriptor > ( ) ; Filter out stale datanodes List < DatanodeDescriptor > stale = new LinkedList < DatanodeDescriptor > ( ) ; Iterator < DatanodeDescriptor > it = targets . iterator ( ) ; while ( it . hasNext ( ) ) { DatanodeDescriptor d = it . next ( ) ; if ( d . isStale ( staleInterval ) ) { it . remove ( ) ; stale . add ( d ) ; } } Select targets while ( chosen . size ( ) < neededCached ) { Try to use stale nodes if we ' re out of non - stale nodes , else we ' re done if ( targets . isEmpty ( ) ) { if ( ! stale . isEmpty ( ) ) { targets = stale ; } else { break ; } } Select a random target DatanodeDescriptor target = chooseRandomDatanodeByRemainingCapacity ( targets ) ; chosen . add ( target ) ; targets . remove ( target ) ; } return chosen ; } 
6351	private Set < RemoteProcessGroupPortDescriptor > convertRemotePort ( final Set < RemoteProcessGroupPortDTO > ports ) { Set < RemoteProcessGroupPortDescriptor > remotePorts = null ; if ( ports ! = null ) { remotePorts = new LinkedHashSet < > ( ports . size ( ) ) ; for ( final RemoteProcessGroupPortDTO port : ports ) { final StandardRemoteProcessGroupPortDescriptor descriptor = new StandardRemoteProcessGroupPortDescriptor ( ) ; descriptor . setId ( port . getId ( ) ) ; descriptor . setVersionedComponentId ( port . getVersionedComponentId ( ) ) ; descriptor . setTargetId ( port . getTargetId ( ) ) ; descriptor . setName ( port . getName ( ) ) ; descriptor . setComments ( port . getComments ( ) ) ; descriptor . setTargetRunning ( port . isTargetRunning ( ) ) ; descriptor . setConnected ( port . isConnected ( ) ) ; descriptor . setConcurrentlySchedulableTaskCount ( port . getConcurrentlySchedulableTaskCount ( ) ) ; descriptor . setTransmitting ( port . isTransmitting ( ) ) ; descriptor . setUseCompression ( port . getUseCompression ( ) ) ; final BatchSettingsDTO batchSettings = port . getBatchSettings ( ) ; if ( batchSettings ! = null ) { descriptor . setBatchCount ( batchSettings . getCount ( ) ) ; descriptor . setBatchSize ( batchSettings . getSize ( ) ) ; descriptor . setBatchDuration ( batchSettings . getDuration ( ) ) ; } remotePorts . add ( descriptor ) ; } } return remotePorts ; } 
6352	public int compareTo ( ImmutableBitSet o ) { int i = _NUM ; for ( ; ; ) { int n _NUM = nextSetBit ( i ) ; int n _NUM = o . nextSetBit ( i ) ; int c = Utilities . compare ( n _NUM , n _NUM ) ; if ( c ! = _NUM | | n _NUM < _NUM ) { return c ; } i = n _NUM + _NUM ; } } 
6353	public String getBatteryTechnology ( ) { String technology = _STR ; mBatteryState . init ( ) ; technology = mBatteryState . getTechnology ( ) ; mBatteryState . deinit ( ) ; return technology ; } 
6354	public void setDescription ( String value ) { checkFrozen ( ) ; m _ description = value . trim ( ) ; } 
6355	public void handle ( Message . Response response ) { if ( ! ( response instanceof Responses . Event ) ) { logger . error ( _STR , scc . targetType , scc . targetKeyspace , scc . targetName ) ; } else { switch ( scc . targetType ) { case TABLE : we can ' t tell whether it ' s a table or a view , but since two objects cannot have the same name , try removing both final TableMetadata removedTable = keyspace . removeTable ( scc . targetName ) ; if ( removedTable ! = null ) { executor . submit ( new Runnable ( ) { @ Override public void run ( ) { manager . metadata . triggerOnTableRemoved ( removedTable ) ; } } ) ; } else { final MaterializedViewMetadata removedView = keyspace . removeMaterializedView ( scc . targetName ) ; if ( removedView ! = null ) { executor . submit ( new Runnable ( ) { @ Override public void run ( ) { manager . metadata . triggerOnMaterializedViewRemoved ( removedView ) ; } } ) ; } } break ; case TYPE : final UserType removedType = keyspace . removeUserType ( scc . targetName ) ; if ( removedType ! = null ) { executor . submit ( new Runnable ( ) { @ Override public void run ( ) { manager . metadata . triggerOnUserTypeRemoved ( removedType ) ; } } ) ; } break ; case FUNCTION : final FunctionMetadata removedFunction = keyspace . removeFunction ( Metadata . fullFunctionName ( scc . targetName , scc . targetSignature ) ) ; if ( removedFunction ! = null ) { executor . submit ( new Runnable ( ) { @ Override public void run ( ) { manager . metadata . triggerOnFunctionRemoved ( removedFunction ) ; } } ) ; } break ; case AGGREGATE : final AggregateMetadata removedAggregate = keyspace . removeAggregate ( Metadata . fullFunctionName ( scc . targetName , scc . targetSignature ) ) ; if ( removedAggregate ! = null ) { executor . submit ( new Runnable ( ) { @ Override public void run ( ) { manager . metadata . triggerOnAggregateRemoved ( removedAggregate ) ; } } ) ; } break ; } } } break ; } break ; } } 
6356	public static final GraphicalView getCubeLineChartView ( Context context , XYMultipleSeriesDataset dataset , XYMultipleSeriesRenderer renderer , float smoothness ) { checkParameters ( dataset , renderer ) ; XYChart chart = new CubicLineChart ( dataset , renderer , smoothness ) ; return new GraphicalView ( context , chart ) ; } 
6357	public void setDomainMinorGridlinePaint ( Paint paint ) { if ( paint = = null ) { throw new IllegalArgumentException ( _STR ) ; } this . domainMinorGridlinePaint = paint ; fireChangeEvent ( ) ; } 
6358	public synchronized long skip ( long n ) throws IOException { long curPos = getPos ( ) ; long fileLength = getFileLength ( ) ; if ( n + curPos > fileLength ) { n = fileLength - curPos ; } return super . skip ( n ) ; } 
6359	public boolean canCameraGestureBeLaunched ( boolean keyguardIsShowing ) { if ( ! mStatusBar . isCameraAllowedByAdmin ( ) ) { return false ; } ResolveInfo resolveInfo = mKeyguardBottomArea . resolveCameraIntent ( ) ; String packageToLaunch = ( resolveInfo = = null | | resolveInfo . activityInfo = = null ) ? null : resolveInfo . activityInfo . packageName ; return packageToLaunch ! = null & & ( keyguardIsShowing | | ! isForegroundApp ( packageToLaunch ) ) & & ! mAffordanceHelper . isSwipingInProgress ( ) ; } 
6360	private boolean parse ( ) { if ( mData = = null ) { the empty is OK . return true ; } DataInputStream dis = new DataInputStream ( new ByteArrayInputStream ( mData ) ) ; mDnsQueryName = readDnsName ( dis ) ; if ( mDnsQueryName = = null ) { return false ; } try { mDnsType = dis . readUnsignedShort ( ) ; mVersion = dis . readUnsignedByte ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; return false ; } if ( mDnsType = = WifiP _NUM pDnsSdServiceInfo . DNS _ TYPE _ PTR ) { String rData = readDnsName ( dis ) ; if ( rData = = null ) { return false ; } if ( rData . length ( ) < = mDnsQueryName . length ( ) ) { return false ; } mInstanceName = rData . substring ( _NUM , rData . length ( ) - mDnsQueryName . length ( ) - _NUM ) ; } else if ( mDnsType = = WifiP _NUM pDnsSdServiceInfo . DNS _ TYPE _ TXT ) { return readTxtData ( dis ) ; } else { return false ; } return true ; } 
6361	public void testPutMetrics _NUM ( ) { setup GraphiteSink GraphiteSink sink = new GraphiteSink ( ) ; final GraphiteSink . Graphite mockGraphite = makeGraphite ( ) ; Whitebox . setInternalState ( sink , _STR ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } 
6362	public static DERVisibleString getInstance ( ASN _NUM TaggedObject obj , boolean explicit ) { ASN _NUM Primitive o = obj . getObject ( ) ; if ( explicit | | o instanceof DERVisibleString ) { return getInstance ( o ) ; } else { return new DERVisibleString ( ASN _NUM OctetString . getInstance ( o ) . getOctets ( ) ) ; } } 
6363	public ViewPropertyAnimator translationY ( float value ) { animateProperty ( TRANSLATION _ Y , value ) ; return this ; } 
6364	public static < T _NUM , T _NUM , T _NUM , T _NUM , R > Function _NUM < T _NUM , T _NUM , T _NUM , T _NUM , R > memoizeQuadFunctionAsync ( final Function _NUM < T _NUM , T _NUM , T _NUM , T _NUM , R > fn , ScheduledExecutorService ex , long updateRateInMillis ) { Function _NUM < Tuple _NUM < T _NUM , T _NUM , T _NUM , T _NUM > , R > memoise _NUM = memoizeFunctionAsync ( ( final Tuple _NUM < T _NUM , T _NUM , T _NUM , T _NUM > quad ) - > fn . apply ( quad . _ _NUM ( ) , quad . _ _NUM ( ) , quad . _ _NUM ( ) , quad . _ _NUM ( ) ) , ex , updateRateInMillis ) ; return ( t _NUM , t _NUM , t _NUM , t _NUM ) - > memoise _NUM . apply ( tuple ( t _NUM , t _NUM , t _NUM , t _NUM ) ) ; } 
6365	void runDiffTest ( int startSize , int numModifications ) { final int width = findWidth ( startSize + numModifications ) ; System . out . println ( _STR ) ; } } { for ( int m = _NUM ; m < n ; m + + ) { final INode inode = newINode ( m , width ) ; { test accessPrevious final Container < INode > r = combined . accessPrevious ( inode . getKey ( ) ) ; final INode computed ; if ( r ! = null ) { computed = r . getElement ( ) ; } else { final int i = Diff . search ( current , inode . getKey ( ) ) ; computed = i < _NUM ? null : current . get ( i ) ; } final int j = Diff . search ( previous , inode . getKey ( ) ) ; final INode expected = j < _NUM ? null : previous . get ( j ) ; must be the same object ( equals is not enough ) Assert . assertTrue ( computed = = expected ) ; } { test accessCurrent final Container < INode > r = combined . accessCurrent ( inode . getKey ( ) ) ; final INode computed ; if ( r ! = null ) { computed = r . getElement ( ) ; } else { final int i = Diff . search ( previous , inode . getKey ( ) ) ; computed = i < _NUM ? null : previous . get ( i ) ; } final int j = Diff . search ( current , inode . getKey ( ) ) ; final INode expected = j < _NUM ? null : current . get ( j ) ; must be the same object ( equals is not enough ) Assert . assertTrue ( computed = = expected ) ; } } } } 
6366	public void testQueryForObjectOnCobarSqlMapClientTemplate ( ) { _NUM . initialize data String [ ] names = { _STR , name ) ; assertNotNull ( follower ) ; } } 
6367	private void initDeleteIfIdStatement ( ) { Delete delete = generateDelete ( table , pkColumns , false ) ; Delete . Conditions deleteIf = delete . onlyIf ( eq ( exchangeIdColumn , bindMarker ( ) ) ) ; deleteIf = applyConsistencyLevel ( deleteIf , writeConsistencyLevel ) ; LOGGER . debug ( _STR , deleteIf ) ; deleteIfIdStatement = getSession ( ) . prepare ( deleteIf ) ; } 
6368	public void buildClassifier ( Instances instances ) throws Exception { String debug = _STR ; can classifier handle the data ? getCapabilities ( ) . testWithFail ( instances ) ; remove instances with missing class instances = new Instances ( instances ) ; instances . deleteWithMissingClass ( ) ; m _ Train = new Instances ( instances , _NUM , instances . numInstances ( ) ) ; initializes class attributes * * java - speaking ! : - ) * * init _ m _ Attributes ( ) ; } 
6369	protected void paintEmptyRows ( Graphics g ) { final int rowCount = getRowCount ( ) ; final Rectangle clip = g . getClipBounds ( ) ; final int height = clip . y + clip . height ; if ( rowCount * rowHeight < height ) { for ( int i = rowCount ; i < = height / rowHeight ; + + i ) { g . setColor ( colorForRow ( i ) ) ; g . fillRect ( clip . x , i * rowHeight , clip . width , rowHeight ) ; } Mac OS ' Aqua LAF never draws vertical grid lines , so we have to draw them ourselves . if ( System . getProperty ( _STR ) & & getShowVerticalLines ( ) ) { g . setColor ( MAC _ UNFOCUSED _ UNSELECTED _ VERTICAL _ LINE _ COLOR ) ; TableColumnModel columnModel = getColumnModel ( ) ; int x = _NUM ; for ( int i = _NUM ; i < columnModel . getColumnCount ( ) ; + + i ) { TableColumn column = columnModel . getColumn ( i ) ; x + = column . getWidth ( ) ; g . drawLine ( x - _NUM , rowCount * rowHeight , x - _NUM , height ) ; } } } } 
6370	protected void parseID _NUM v _NUM Frames ( InputStream frames , HashMap < String , Object > props ) { byte [ ] bframes = null ; int size = - _NUM ; try { size = frames . available ( ) ; bframes = new byte [ size ] ; frames . mark ( size ) ; frames . read ( bframes ) ; frames . reset ( ) ; } catch ( IOException e ) { system . error ( _STR ) ; } 
6371	public void attach ( String pid , String agentPath , String sysCp , String bootCp ) throws IOException { try { VirtualMachine vm = null ; if ( debug ) { debugPrint ( _STR + agentPath ) ; } } catch ( RuntimeException re ) { throw re ; } catch ( IOException ioexp ) { throw ioexp ; } catch ( Exception exp ) { throw new IOException ( exp . getMessage ( ) ) ; } } 
6372	public final E _ StrStartsWith strstarts ( Object expr _NUM , Object expr _NUM ) { return new E _ StrStartsWith ( asExpr ( expr _NUM ) , asExpr ( expr _NUM ) ) ; } 
6373	void copyAll ( final String db , final String path , final String tdb , final String tpath ) throws IOException { final WebDAVQuery query = new WebDAVQuery ( _STR , tpath ) ; execute ( query ) ; } 
6374	public RelNode convertProject ( RexNode defaultExpr ) { locate all fields referenced in the projection and filter locateAllRefs ( ) ; there ' s no point in proceeding any further if ( origProj = = null ) { if ( childPreserveExprs . size ( ) = = _NUM ) { return null ; } selecting all fields if ( nChildFields > _NUM ) { Calling with nChildFields = = _NUM should be safe but hits http : projRefs . set ( _NUM , nChildFields ) ; } nProject = nChildFields ; } else if ( ( projRefs . cardinality ( ) = = nChildFields ) & & ( childPreserveExprs . size ( ) = = _NUM ) ) { return null ; } first column if there is no default expression if ( ( projRefs . cardinality ( ) = = _NUM ) & & ( childPreserveExprs . size ( ) = = _NUM ) ) { if ( defaultExpr ! = null ) { childPreserveExprs . add ( defaultExpr ) ; } else if ( nChildFields = = _NUM ) { return null ; } else { projRefs . set ( _NUM ) ; nProject = _NUM ; } } create a new projection referencing all fields referenced in either the project or the filter RelNode newProject = createProjectRefsAndExprs ( childRel , false , false ) ; int [ ] adjustments = getAdjustments ( ) ; if a filter was passed in , convert it to reference the projected columns , placing it on top of the project just created RelNode projChild ; if ( origFilter ! = null ) { RexNode newFilter = convertRefsAndExprs ( origFilter , newProject . getRowType ( ) . getFieldList ( ) , adjustments ) ; relBuilder . push ( newProject ) ; relBuilder . filter ( newFilter ) ; projChild = relBuilder . build ( ) ; } else { projChild = newProject ; } a projection that essentially selects all fields return createNewProject ( projChild , adjustments ) ; } 
6375	public byte [ ] getEncoded ( ) throws CertificateEncodingException { Iterator iter = getEncodings ( ) ; if ( iter . hasNext ( ) ) { Object enc = iter . next ( ) ; if ( enc instanceof String ) { return getEncoded ( ( String ) enc ) ; } } return null ; } 
6376	static String getFileDisplayNameFromUri ( Context context , Uri uri ) { String scheme = uri . getScheme ( ) ; if ( ContentResolver . SCHEME _ FILE . equals ( scheme ) ) { return uri . getLastPathSegment ( ) ; } else if ( ContentResolver . SCHEME _ CONTENT . equals ( scheme ) ) { We need to query the ContentResolver to get the actual file name as the Uri masks it . This means we want the name used for display purposes only . String [ ] proj = { OpenableColumns . DISPLAY _ NAME } ; try ( Cursor cursor = context . getContentResolver ( ) . query ( uri , proj , null , null , null ) ) { if ( cursor ! = null & & cursor . getCount ( ) ! = _NUM ) { cursor . moveToFirst ( ) ; return cursor . getString ( cursor . getColumnIndex ( OpenableColumns . DISPLAY _ NAME ) ) ; } } } it already represents the file ' s name . return uri . toString ( ) ; } 
6377	public void loadSpanReceivers ( ) { String [ ] receiverNames = conf . getStrings ( SPAN _ RECEIVERS _ CONF _ KEY ) ; if ( receiverNames = = null | | receiverNames . length = = _NUM ) { return ; } SpanReceiver . Builder builder = new SpanReceiver . Builder ( new HBaseHTraceConfiguration ( conf ) ) ; for ( String className : receiverNames ) { className = className . trim ( ) ; SpanReceiver receiver = builder . className ( className ) . build ( ) ; if ( receiver ! = null ) { receivers . add ( receiver ) ; LOG . info ( _STR ) ; } } for ( SpanReceiver rcvr : receivers ) { TraceUtil . addReceiver ( rcvr ) ; } } 
6378	public void addGroup ( PDOptionalContentGroup ocg ) { COSArray ocgs = getOCGs ( ) ; ocgs . add ( ocg . getCOSObject ( ) ) ; By default , add new group to the _STR entry so it appears in the user interface COSArray order = ( COSArray ) getD ( ) . getDictionaryObject ( COSName . ORDER ) ; if ( order = = null ) { order = new COSArray ( ) ; getD ( ) . setItem ( COSName . ORDER , order ) ; } order . add ( ocg ) ; } 
6379	public void scrollComponentToVisible ( Component c ) { if ( isScrollable ( ) ) { if ( c ! = null ) { Rectangle r = c . getVisibleBounds ( ) ; if ( c . getParent ( ) ! = null ) { special case for the first component to allow the user to scroll all the way to the top Form f = getComponentForm ( ) ; if ( f ! = null & & f . getInvisibleAreaUnderVKB ( ) = = _NUM & & f . findFirstFocusable ( ) = = c ) { support this use case only if the component doesn ' t explicitly declare visible bounds if ( r = = c . getBounds ( ) & & ! Display . getInstance ( ) . isTouchScreenDevice ( ) ) { scrollRectToVisible ( new Rectangle ( _NUM , _NUM , c . getX ( ) + Math . min ( c . getWidth ( ) , getWidth ( ) ) , c . getY ( ) + Math . min ( c . getHeight ( ) , getHeight ( ) ) ) , this ) ; return ; } } } boolean moveToVisible = true ; boolean large = c . getVisibleBounds ( ) . getSize ( ) . getHeight ( ) > getHeight ( ) | | c . getVisibleBounds ( ) . getSize ( ) . getWidth ( ) > getWidth ( ) ; if ( large ) { int x = getScrollX ( ) ; int y = getScrollY ( ) ; int w = getWidth ( ) ; int h = getHeight ( ) ; boolean visible = contains ( c ) & & Rectangle . intersects ( c . getAbsoluteX ( ) , c . getAbsoluteY ( ) , c . getWidth ( ) , c . getHeight ( ) , getAbsoluteX ( ) + x , getAbsoluteY ( ) + y , w , h ) ; if this is a big component no need to scroll to the begining if it ' s partially visible moveToVisible = ! visible ; } if ( moveToVisible ) { scrollRectToVisible ( r . getX ( ) , r . getY ( ) , Math . min ( r . getSize ( ) . getWidth ( ) , getWidth ( ) ) , Math . min ( r . getSize ( ) . getHeight ( ) , getHeight ( ) ) , c ) ; } } } } 
6380	public void testDistinctCount ( ) { foodmartModelWithOneTile ( ) . query ( _STR ) ; } 
6381	public void draw ( Graphics _NUM D g _NUM , Rectangle _NUM D area , Point _NUM D anchor , PlotState state , PlotRenderingInfo info ) { if the plot area is too small , just return . . . boolean b _NUM = ( area . getWidth ( ) < = MINIMUM _ WIDTH _ TO _ DRAW ) ; boolean b _NUM = ( area . getHeight ( ) < = MINIMUM _ HEIGHT _ TO _ DRAW ) ; if ( b _NUM | | b _NUM ) { return ; } record the plot area . . . if ( info ! = null ) { info . setPlotArea ( area ) ; } adjust the drawing area for the plot insets ( if any ) . . . RectangleInsets insets = getInsets ( ) ; insets . trim ( area ) ; drawChipGrid ( g _NUM , area ) ; drawWaferEdge ( g _NUM , area ) ; } 
6382	protected String stem ( String term ) { Use lowercase for medium stemming . term = term . toLowerCase ( ) ; if ( ! isStemmable ( term ) ) return term ; Reset the StringBuilder . sb . delete ( _NUM , sb . length ( ) ) ; sb . insert ( _NUM , term ) ; Stemming starts here . . . substitute ( sb ) ; strip ( sb ) ; optimize ( sb ) ; resubstitute ( sb ) ; removeParticleDenotion ( sb ) ; return sb . toString ( ) ; } 
6383	public Token getNextToken ( ) { Token matchedToken ; int curPos = _NUM ; EOFLoop : for ( ; ; ) { try { curChar = input _ stream . BeginToken ( ) ; } catch ( java . io . IOException e ) { jjmatchedKind = _NUM ; matchedToken = jjFillToken ( ) ; return matchedToken ; } switch ( curLexState ) { case _NUM : jjmatchedKind = _NUM x _NUM fffffff ; jjmatchedPos = _NUM ; curPos = jjMoveStringLiteralDfa _NUM _ _NUM ( ) ; break ; case _NUM : jjmatchedKind = _NUM x _NUM fffffff ; jjmatchedPos = _NUM ; curPos = jjMoveStringLiteralDfa _NUM _ _NUM ( ) ; break ; case _NUM : jjmatchedKind = _NUM x _NUM fffffff ; jjmatchedPos = _NUM ; curPos = jjMoveStringLiteralDfa _NUM _ _NUM ( ) ; break ; case _NUM : jjmatchedKind = _NUM x _NUM fffffff ; jjmatchedPos = _NUM ; curPos = jjMoveStringLiteralDfa _NUM _ _NUM ( ) ; break ; } if ( jjmatchedKind ! = _NUM x _NUM fffffff ) { if ( jjmatchedPos + _NUM < curPos ) input _ stream . backup ( curPos - jjmatchedPos - _NUM ) ; if ( ( jjtoToken [ jjmatchedKind > > _NUM ] & ( _NUM L < < ( jjmatchedKind & _NUM _NUM _NUM ) ) ) ! = _NUM L ) { matchedToken = jjFillToken ( ) ; if ( jjnewLexState [ jjmatchedKind ] ! = - _NUM ) curLexState = jjnewLexState [ jjmatchedKind ] ; return matchedToken ; } else { if ( jjnewLexState [ jjmatchedKind ] ! = - _NUM ) curLexState = jjnewLexState [ jjmatchedKind ] ; continue EOFLoop ; } } int error _ line = input _ stream . getEndLine ( ) ; int error _ column = input _ stream . getEndColumn ( ) ; String error _ after = null ; boolean EOFSeen = false ; try { input _ stream . readChar ( ) ; input _ stream . backup ( _NUM ) ; } catch ( java . io . IOException e _NUM ) { EOFSeen = true ; error _ after = curPos < = _NUM ? _STR : input _ stream . GetImage ( ) ; } throw new TokenMgrError ( EOFSeen , curLexState , error _ line , error _ column , error _ after , curChar , TokenMgrError . LEXICAL _ ERROR ) ; } } 
6384	private void addAuthentication ( UserEntity userEntity , UserAuthenticationType type , String key , Validator validator , boolean persist ) throws AmbariException { if ( userEntity = = null ) { throw new AmbariException ( _STR ) ; } validator . validate ( userEntity , key ) ; List < UserAuthenticationEntity > authenticationEntities = userAuthenticationDAO . findByUser ( userEntity ) ; UserAuthenticationEntity authenticationEntity = new UserAuthenticationEntity ( ) ; authenticationEntity . setUser ( userEntity ) ; authenticationEntity . setAuthenticationType ( type ) ; authenticationEntity . setAuthenticationKey ( key ) ; authenticationEntities . add ( authenticationEntity ) ; userEntity . setAuthenticationEntities ( authenticationEntities ) ; if ( persist ) { userDAO . merge ( userEntity ) ; } } 
6385	public static long readUIntLE ( InputStream stream ) throws IOException , BufferUnderrunException { int ch _NUM = stream . read ( ) ; int ch _NUM = stream . read ( ) ; int ch _NUM = stream . read ( ) ; int ch _NUM = stream . read ( ) ; if ( ( ch _NUM | ch _NUM | ch _NUM | ch _NUM ) < _NUM ) { throw new BufferUnderrunException ( ) ; } return ( ( ch _NUM < < _NUM _NUM ) + ( ch _NUM < < _NUM _NUM ) + ( ch _NUM < < _NUM ) + ( ch _NUM < < _NUM ) ) & _NUM x _NUM _NUM FFFFFFFFl ; } 
6386	public org . apache . drill . exec . proto . UserProtos . PreparedStatementHandle . Builder getServerHandleBuilder ( ) { bitField _NUM _ | = _NUM x _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM ; onChanged ( ) ; return getServerHandleFieldBuilder ( ) . getBuilder ( ) ; } 
6387	public boolean hasPrevious ( ) { If we are at the start of the list there are no previous elements . if ( currentIndex = = startIndex ) { return false ; } previous element to make sure it exists . if ( previousElement = = null ) { previousElement = getPreviousElement ( ) ; If getting the previous element failed , return false . if ( previousElement = = null ) { return false ; } } return true ; } 
6388	public boolean matchesSelector ( @ NonNull MediaRouteSelector selector ) { if ( selector = = null ) { throw new IllegalArgumentException ( _STR ) ; } checkCallingThread ( ) ; return selector . matchesControlFilters ( mControlFilters ) ; } 
6389	private static void checkQueryScope ( Query query ) { Collection < Var > vars = varsOfQuery ( query ) ; checkExprListAssignment ( vars , query . getProject ( ) ) ; } 
6390	private void writeAttributeInfo ( Processor processor , XMLStreamWriter xmlStreamWriter ) throws XMLStreamException { handleReadsAttributes ( xmlStreamWriter , processor ) ; handleWritesAttributes ( xmlStreamWriter , processor ) ; } 
6391	public static void main ( String [ ] args ) throws Exception { Options options = new Options ( ) ; options . addOption ( Option . builder ( _STR , e ) ; } finally { System . exit ( exitStatus ) ; } } 
6392	private PairStream < K , V > combineByKey ( Reducer < V > reducer ) { if ( shouldPartitionByKey ( ) ) { if ( node instanceof ProcessorNode ) { if ( node . isWindowed ( ) ) { return reducePartition ( reducer ) . partitionBy ( KEY ) . reducePartition ( reducer ) ; } } else if ( node instanceof WindowNode ) { for ( Node p : node . getParents ( ) ) { if ( p . isWindowed ( ) ) { Node localReduceNode = makeProcessorNode ( new ReduceByKeyProcessor < > ( reducer ) , KEY _ VALUE , true ) ; streamBuilder . insert ( p , localReduceNode ) ; } } } return partitionBy ( KEY ) . reducePartition ( reducer ) ; } else { return reducePartition ( reducer ) ; } } 
6393	public Object resolvePropertyValue ( ConfigurableBeanFactory beanFactory , String beanName , String placeholder ) { resolve string value String strVal = beanFactory . resolveEmbeddedValue ( placeholder ) ; BeanDefinition bd = ( beanFactory . containsBean ( beanName ) ? beanFactory . getMergedBeanDefinition ( beanName ) : null ) ; resolve expressions like _STR return evaluateBeanDefinitionString ( beanFactory , strVal , bd ) ; } 
6394	private void doGracefulFailover ( ) throws ServiceFailedException , IOException , InterruptedException { int timeout = FailoverController . getGracefulFenceTimeout ( conf ) * _NUM ; Phase _NUM : pre - flight checks checkEligibleForFailover ( ) ; Phase _NUM : determine old / current active node . Check that we ' re not ourselves active , etc . HAServiceTarget oldActive = getCurrentActive ( ) ; if ( oldActive = = null ) { probably something preventing us from becoming active . throw new ServiceFailedException ( _STR + attempt . status ; throw new ServiceFailedException ( msg ) ; } } 
6395	private byte [ ] getStartTime ( String entityId , String entityType ) throws IOException { Long l = getStartTimeLong ( entityId , entityType ) ; return l = = null ? null : writeReverseOrderedLong ( l ) ; } 
6396	public int getInt ( String key ) throws JSONException { Object o = get ( key ) ; return o instanceof Number ? ( ( Number ) o ) . intValue ( ) : ( int ) getDouble ( key ) ; } 
6397	private void testFailureLogFormat ( boolean checkIP ) { testFailureLogFormatHelper ( checkIP , null , null ) ; testFailureLogFormatHelper ( checkIP , APPID , null ) ; testFailureLogFormatHelper ( checkIP , null , CONTAINERID ) ; testFailureLogFormatHelper ( checkIP , APPID , CONTAINERID ) ; } 
6398	public static XmlInt parse ( java . lang . String s ) throws org . apache . xmlbeans . XmlException { return ( XmlInt ) XmlBeans . getContextTypeLoader ( ) . parse ( s , type , null ) ; } 
6399	protected NodeId next ( ) { If a connection was already established then use that connection . if ( currentNode ! = null ) { return currentNode ; } if ( ! selector . hasNext ( ) ) { if ( selector . leader ( ) ! = null ) { selector . reset ( null , selector . members ( ) ) ; this . currentNode = selector . next ( ) ; this . selectionId + + ; return currentNode ; } else { log . debug ( _STR ) ; selector . reset ( ) ; return null ; } } else { this . currentNode = selector . next ( ) ; this . selectionId + + ; return currentNode ; } } 
6400	public boolean isTriggeringEvent ( final LogEvent event ) { final boolean triggered = manager . getFileSize ( ) > maxFileSize ; if ( triggered ) { manager . getPatternProcessor ( ) . updateTime ( ) ; } return triggered ; } 
6401	public String shortKey ( String keyName ) { String value = keyDefault ( keyName + CmsMessages . KEY _ SHORT _ SUFFIX , ( String ) null ) ; if ( value = = null ) { short key value not found , return _STR key value return key ( keyName ) ; } return value ; } 
6402	public alluxio . proto . journal . Block . DeleteBlockEntry . Builder getDeleteBlockBuilder ( ) { bitField _NUM _ | = _NUM x _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM ; onChanged ( ) ; return getDeleteBlockFieldBuilder ( ) . getBuilder ( ) ; } 
6403	public NavigableSet < Clustering > getClusteringColumns ( QueryOptions options ) { set ( since that ' s what ClusteringIndexNamesFilter expects ) . if ( table . isStaticCompactTable ( ) ) return BTreeSet . empty ( table . comparator ) ; return clusteringColumnsRestrictions . valuesAsClustering ( options ) ; } 
6404	public static String squeeze ( final String str , final String . . . set ) { if ( StringUtils . isEmpty ( str ) | | deepEmpty ( set ) ) { return str ; } final CharSet chars = CharSet . getInstance ( set ) ; final StringBuilder buffer = new StringBuilder ( str . length ( ) ) ; final char [ ] chrs = str . toCharArray ( ) ; final int sz = chrs . length ; char lastChar = chrs [ _NUM ] ; char ch = ' ' ; Character inChars = null ; Character notInChars = null ; buffer . append ( lastChar ) ; for ( int i = _NUM ; i < sz ; i + + ) { ch = chrs [ i ] ; if ( ch = = lastChar ) { if ( inChars ! = null & & ch = = inChars ) { continue ; } if ( notInChars = = null | | ch ! = notInChars ) { if ( chars . contains ( ch ) ) { inChars = ch ; continue ; } notInChars = ch ; } } buffer . append ( ch ) ; lastChar = ch ; } return buffer . toString ( ) ; } 
6405	public GF _NUM nPolynomialElement squareMatrix ( ) { GF _NUM nPolynomialElement result = new GF _NUM nPolynomialElement ( this ) ; result . squareThisMatrix ( ) ; result . reduceThis ( ) ; return result ; } 
6406	private TokenInfo < Unit > createTokenInfos ( Map < Unit , UnitInfo < Unit > > units , GroupInfo newUnitGroup ) { build the circular list TokenInfo < Unit > prev = null ; TokenInfo < Unit > first = null ; for ( Map . Entry < Token , Unit > en : sortedTokens . entrySet ( ) ) { Token t = en . getKey ( ) ; UnitInfo < Unit > ni = units . get ( en . getValue ( ) ) ; TokenInfo < Unit > ti = new TokenInfo < > ( t , ni ) ; first = ti . insertAfter ( first , prev ) ; prev = ti ; } TokenInfo < Unit > curr = first ; do { populateTokenInfoAndAdjustUnit ( curr , newUnitGroup ) ; curr = curr . next ; } while ( curr ! = first ) ; return first ; } 
6407	protected void sessionDestroyed ( HttpSessionEvent event ) { synchronized ( m _ lockSessionCount ) { m _ sessionCountCurrent = ( m _ sessionCountCurrent < = _NUM ) ? _NUM : ( m _ sessionCountCurrent - _NUM ) ; if ( LOG . isInfoEnabled ( ) ) { LOG . info ( Messages . get ( ) . getBundle ( ) . key ( Messages . LOG _ SESSION _ DESTROYED _ _NUM , new Integer ( m _ sessionCountTotal ) , new Integer ( m _ sessionCountCurrent ) ) ) ; } } CmsSessionInfo sessionInfo = getSessionInfo ( event . getSession ( ) ) ; CmsUUID userId = null ; if ( sessionInfo ! = null ) { userId = sessionInfo . getUserId ( ) ; m _ sessionStorageProvider . remove ( sessionInfo . getSessionId ( ) ) ; } if ( ( userId ! = null ) & & ( getSessionInfos ( userId ) . size ( ) = = _NUM ) ) { remove the temporary locks of this user from memory OpenCmsCore . getInstance ( ) . getLockManager ( ) . removeTempLocks ( userId ) ; } if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( Messages . get ( ) . getBundle ( ) . key ( Messages . LOG _ SESSION _ DESTROYED _ _NUM , event . getSession ( ) . getId ( ) ) ) ; } } 
6408	public void close ( ) throws java . io . IOException { _NUM . Ensure that pending characters are written flushBase _NUM _NUM ( ) ; _NUM . Actually close the stream Base class both flushes and closes . super . close ( ) ; buffer = null ; out = null ; } 
6409	public void split ( ) throws Exception { int i ; Instances leftSubset , rightSubset ; SplitEvaluate bestSplit , currentSplit ; boolean [ ] attsBelow ; if ( ! m _ isLeaf ) { bestSplit = new YongSplitInfo ( _NUM , m _ numInstances - _NUM , - _NUM ) ; currentSplit = new YongSplitInfo ( _NUM , m _ numInstances - _NUM , - _NUM ) ; find the best attribute to split on for ( i = _NUM ; i < m _ numAttributes ; i + + ) { if ( i ! = m _ classIndex ) { sort the instances by this attribute m _ instances . sort ( i ) ; currentSplit . attrSplit ( i , m _ instances ) ; if ( ( Math . abs ( currentSplit . maxImpurity ( ) - bestSplit . maxImpurity ( ) ) > _NUM . e - _NUM ) & & ( currentSplit . maxImpurity ( ) > bestSplit . maxImpurity ( ) + _NUM . e - _NUM ) ) { bestSplit = currentSplit . copy ( ) ; } } } cant find a good split or split point ? if ( bestSplit . splitAttr ( ) < _NUM | | bestSplit . position ( ) < _NUM | | bestSplit . position ( ) > m _ numInstances - _NUM ) { m _ isLeaf = true ; } else { m _ splitAtt = bestSplit . splitAttr ( ) ; m _ splitValue = bestSplit . splitValue ( ) ; leftSubset = new Instances ( m _ instances , m _ numInstances ) ; rightSubset = new Instances ( m _ instances , m _ numInstances ) ; for ( i = _NUM ; i < m _ numInstances ; i + + ) { if ( m _ instances . instance ( i ) . value ( m _ splitAtt ) < = m _ splitValue ) { leftSubset . add ( m _ instances . instance ( i ) ) ; } else { rightSubset . add ( m _ instances . instance ( i ) ) ; } } leftSubset . compactify ( ) ; rightSubset . compactify ( ) ; build left and right nodes m _ left = new RuleNode ( m _ globalDeviation , m _ globalAbsDeviation , this ) ; m _ left . setMinNumInstances ( m _ splitNum ) ; m _ left . setRegressionTree ( m _ regressionTree ) ; m _ left . setSaveInstances ( m _ saveInstances ) ; m _ left . buildClassifier ( leftSubset ) ; m _ right = new RuleNode ( m _ globalDeviation , m _ globalAbsDeviation , this ) ; m _ right . setMinNumInstances ( m _ splitNum ) ; m _ right . setRegressionTree ( m _ regressionTree ) ; m _ right . setSaveInstances ( m _ saveInstances ) ; m _ right . buildClassifier ( rightSubset ) ; subtrees and use them to learn a linear model for this node if ( ! m _ regressionTree ) { attsBelow = attsTestedBelow ( ) ; attsBelow [ m _ classIndex ] = true ; int count = _NUM , j ; for ( j = _NUM ; j < m _ numAttributes ; j + + ) { if ( attsBelow [ j ] ) { count + + ; } } int [ ] indices = new int [ count ] ; count = _NUM ; for ( j = _NUM ; j < m _ numAttributes ; j + + ) { if ( attsBelow [ j ] & & ( j ! = m _ classIndex ) ) { indices [ count + + ] = j ; } } indices [ count ] = m _ classIndex ; m _ indices = indices ; } else { m _ indices = new int [ _NUM ] ; m _ indices [ _NUM ] = m _ classIndex ; m _ numParameters = _NUM ; } } } if ( m _ isLeaf ) { int [ ] indices = new int [ _NUM ] ; indices [ _NUM ] = m _ classIndex ; m _ indices = indices ; m _ numParameters = _NUM ; need to evaluate the model here if want correct stats for unpruned tree } } 
6410	public ValidationReport loadProjectFlow ( final Project project , final File projectDir ) { convertYamlFiles ( projectDir ) ; FlowLoaderUtils . checkJobProperties ( project . getId ( ) , this . props , this . jobPropsMap , this . errors ) ; return FlowLoaderUtils . generateFlowLoaderReport ( this . errors ) ; } 
6411	public void setIndicatorVisibility ( IndicatorVisibility visibility ) { if ( visibility = = IndicatorVisibility . Visible ) { setVisibility ( View . VISIBLE ) ; } else { setVisibility ( View . INVISIBLE ) ; } resetDrawable ( ) ; } 
6412	public void testUpsertMemstoreSize ( ) throws Exception { MemStoreSize oldSize = memstore . size ( ) ; List < Cell > l = new ArrayList < > ( ) ; KeyValue kv _NUM = KeyValueTestUtil . create ( _STR ) ; kv _NUM . setSequenceId ( _NUM ) ; l . clear ( ) ; l . add ( kv _NUM ) ; this . memstore . upsert ( l , _NUM , null ) ; assertEquals ( newSize , this . memstore . size ( ) ) ; The kv _NUM should be removed . assert ( memstore . getActive ( ) . getCellsCount ( ) = = _NUM ) ; this . memstore = null ; } 
6413	public void testNoLogs ( ) throws Exception { FileUtil . fullyDelete ( new File ( _STR ) ) ; } 
6414	public void ftTest ( ) { createDoc ( ) ; execute ( new Open ( NAME ) ) ; check ( _STR ) ; } 
6415	public boolean isPendingTransactionRelevant ( Transaction tx ) throws ScriptException { lock . lock ( ) ; try { Ignore it if we already know about this transaction . Receiving a pending transaction never moves it between pools . EnumSet < Pool > containingPools = getContainingPools ( tx ) ; if ( ! containingPools . equals ( EnumSet . noneOf ( Pool . class ) ) ) { log . debug ( _STR ) ; return false ; } return true ; } finally { lock . unlock ( ) ; } } 
6416	public SortedMap < String , Histogram > getHistograms ( MetricFilter filter ) { return getSimplyNamedMetrics ( Histogram . class , Optional . of ( filter ) ) ; } 
6417	public void testIdempotentAllocateBlockAndClose ( ) throws Exception { final String src = _STR , t ) ; throw t ; } } } ) . when ( spyNN ) . complete ( Mockito . anyString ( ) , Mockito . anyString ( ) , Mockito . < ExtendedBlock > any ( ) , anyLong ( ) ) ; OutputStream stm = client . create ( file . toString ( ) , true ) ; try { AppendTestUtil . write ( stm , _NUM , _NUM _NUM _NUM _NUM _NUM ) ; stm . close ( ) ; stm = null ; } finally { IOUtils . cleanup ( LOG , stm ) ; } Make sure the mock was actually properly injected . Mockito . verify ( spyNN , Mockito . atLeastOnce ( ) ) . addBlock ( Mockito . anyString ( ) , Mockito . anyString ( ) , Mockito . < ExtendedBlock > any ( ) , Mockito . < DatanodeInfo [ ] > any ( ) , Mockito . anyLong ( ) , Mockito . < String [ ] > any ( ) ) ; Mockito . verify ( spyNN , Mockito . atLeastOnce ( ) ) . complete ( Mockito . anyString ( ) , Mockito . anyString ( ) , Mockito . < ExtendedBlock > any ( ) , anyLong ( ) ) ; AppendTestUtil . check ( fs , file , _NUM _NUM _NUM _NUM _NUM ) ; } finally { cluster . shutdown ( ) ; } } 
6418	public void showDropDown ( ) { buildImeCompletions ( ) ; if ( mPopup . getAnchorView ( ) = = null ) { if ( mDropDownAnchorId ! = View . NO _ ID ) { mPopup . setAnchorView ( getRootView ( ) . findViewById ( mDropDownAnchorId ) ) ; } else { mPopup . setAnchorView ( this ) ; } } if ( ! isPopupShowing ( ) ) { Make sure the list does not obscure the IME when shown for the first time . mPopup . setInputMethodMode ( ListPopupWindow . INPUT _ METHOD _ NEEDED ) ; mPopup . setListItemExpandMax ( EXPAND _ MAX ) ; } mPopup . show ( ) ; mPopup . getListView ( ) . setOverScrollMode ( View . OVER _ SCROLL _ ALWAYS ) ; } 
6419	int indexOf ( GridColumn column ) { column = column . getFirstLeaf ( ) ; int index = columns . indexOf ( column ) ; if ( index < _NUM ) { log . warn ( _STR ) ; } return index ; } 
6420	public void pickContact ( ) { try { checkPermission ( ) ; pick ( ) ; } catch ( PickerException e ) { e . printStackTrace ( ) ; if ( callback ! = null ) { callback . onError ( e . getMessage ( ) ) ; } } } 
6421	public Future < SummaryCollection > processPartition ( ExecutorService execSrv , int modulus , int remainder ) { PartitionFuture future = new PartitionFuture ( Tracer . traceInfo ( ) , execSrv , modulus , remainder ) ; future . initiateProcessing ( ) ; return future ; } 
6422	private void writeSymbolsField ( SymbolTable symTab ) { SymbolTable ' s APIs doesn ' t expose an Iterator to traverse declared symbol strings in reverse order . As such , we utilize these two indexes to traverse the strings in reverse . int importedMaxId = symTab . getImportedMaxId ( ) ; int maxId = symTab . getMaxId ( ) ; if ( importedMaxId = = maxId ) { There are no declared local symbols return ; } final int originalOffset = myBuffer . length - myOffset ; for ( int i = maxId ; i > importedMaxId ; i - - ) { String str = symTab . findKnownSymbol ( i ) ; if ( str = = null ) { writeByte ( ( byte ) ( TYPE _ STRING | NULL _ LENGTH _ MASK ) ) ; } else { writeIonStringContent ( str ) ; } } writePrefix ( TYPE _ LIST , myBuffer . length - myOffset - originalOffset ) ; writeByte ( ( byte ) ( _NUM x _NUM _NUM | SYMBOLS _ SID ) ) ; } 
6423	public List < String > getTokens ( ) { List < String > tokens = new ArrayList < > ( ) ; if ( ! tokens . isEmpty ( ) ) return tokens ; log . info ( _STR ) ; return tokens ; } 
6424	public void setOnScrollListener ( OnScrollListener l ) { mOnScrollListener = l ; invokeOnItemScrollListener ( ) ; } 
6425	public void testSecondaryNodePorts ( ) throws Exception { NameNode nn = null ; try { nn = startNameNode ( ) ; bind http server to the same port as name - node Configuration conf _NUM = new HdfsConfiguration ( config ) ; conf _NUM . set ( DFSConfigKeys . DFS _ NAMENODE _ SECONDARY _ HTTP _ ADDRESS _ KEY , config . get ( DFSConfigKeys . DFS _ NAMENODE _ HTTP _ ADDRESS _ KEY ) ) ; LOG . info ( _STR + conf _NUM . get ( DFSConfigKeys . DFS _ NAMENODE _ SECONDARY _ HTTP _ ADDRESS _ KEY ) ) ; started = canStartSecondaryNode ( conf _NUM ) ; should start now assertTrue ( started ) ; } finally { stopNameNode ( nn ) ; } } 
6426	public java . lang . String toString ( ) { return getClass ( ) . getName ( ) + _STR + message ; } 
6427	 @ SuppressWarnings ( _STR , beforeAsXml , afterAsXml ) ; If the camel context is started then we start the route if ( camelContext instanceof StatefulService ) { StatefulService service = ( StatefulService ) camelContext ; if ( service . isStarted ( ) ) { camelContext . startRoute ( merged ) ; } } return merged ; } 
6428	public void run ( ) { if ( runnable ! = null ) { runnable . run ( ) ; } else { try { callable . call ( ) ; } catch ( Exception ex ) { throw new RuntimeException ( ex ) ; } } } 
6429	public org . bitcoinj . wallet . Protos . Transaction . Builder addTransactionBuilder ( ) { return getTransactionFieldBuilder ( ) . addBuilder ( org . bitcoinj . wallet . Protos . Transaction . getDefaultInstance ( ) ) ; } 
6430	public void partialResults ( Bundle partialResults ) throws RemoteException { mListener . onPartialResults ( partialResults ) ; } 
6431	private void updateNodeConf ( CCMBridge ccm ) { int n = _NUM ; Closer closer = Closer . create ( ) ; try { for ( int dc = _NUM ; dc < = nodes . length ; dc + + ) { int nodesInDc = nodes [ dc - _NUM ] ; for ( int i = _NUM ; i < nodesInDc ; i + + ) { int jmxPort = ccm . jmxAddressOfNode ( n ) . getPort ( ) ; int debugPort = TestUtils . findAvailablePort ( ) ; logger . trace ( _STR , ipPrefix + n , debugPort ) ; } pw . println ( line ) ; } pw . flush ( ) ; pw . close ( ) ; Files . move ( nodeConf _NUM , nodeConf ) ; n + + ; } } } catch ( IOException e ) { Throwables . propagate ( e ) ; } finally { try { closer . close ( ) ; } catch ( IOException e ) { Throwables . propagate ( e ) ; } } } 
6432	public void clear ( ) { if ( mCurrentPresenter ! = null ) { mCurrentPresenter . onUnbindViewHolder ( mCurrentViewHolder ) ; mParent . removeView ( mCurrentViewHolder . view ) ; mCurrentViewHolder = null ; mCurrentPresenter = null ; } } 
6433	public apiprivate final void detach ( ) { if ( mStarted ) { if ( mDebug ) Slog . v ( TAG , _STR ) ; mWindowToken = null ; mCanDoze = false ; } } 
6434	public boolean supportsAidPrefixRegistration ( ) { try { return sService . supportsAidPrefixRegistration ( ) ; } catch ( RemoteException e ) { recoverService ( ) ; if ( sService = = null ) { Log . e ( TAG , _STR ) ; return false ; } } } 
6435	public void addParameter ( String name , String value ) { String key = name . trim ( ) . toLowerCase ( ) ; switch ( SCALER _ ATTRS _ LIST . indexOf ( key ) ) { case scaleColor _NUM : setScaleColor ( value ) ; break ; case scaleFilter _NUM : setScaleFilter ( value ) ; break ; case height _NUM : setHeight ( value ) ; break ; case partialTag _NUM : setPartialTag ( value ) ; break ; case scalePosition _NUM : setScalePosition ( value ) ; break ; case scaleQuality _NUM : setScaleQuality ( value ) ; break ; case scaleRendermode _NUM : setScaleRendermode ( value ) ; break ; case src _NUM : setSrc ( value ) ; break ; case scaleType _NUM : setScaleType ( value ) ; break ; case width _NUM : setWidth ( value ) ; break ; default : no a value used by the image scaler , treat as HTML attribute setAttribute ( key , value ) ; } } 
6436	public void setFocusState ( int focusState ) { int prevFocusState = mFocusState ; mFocusState = focusState ; updateFrontBackTransforms ( ) ; if ( mCb ! = null ) { mCb . onFocusStateChanged ( prevFocusState , focusState ) ; } } 
6437	public void writeCData ( String data ) throws XMLStreamException { String filteredData = nonXmlCharFilterer . filter ( data ) ; writer . writeCData ( filteredData ) ; } 
6438	public void clear ( ) { try { startWrite ( ) ; tupleTable . clear ( ) ; } finally { finishWrite ( ) ; } } 
6439	private boolean generateOpsForPendingActions ( ArrayList < BackStackRecord > records , ArrayList < Boolean > isPop ) { boolean didSomething = false ; synchronized ( this ) { if ( mPendingActions = = null | | mPendingActions . size ( ) = = _NUM ) { return false ; } final int numActions = mPendingActions . size ( ) ; for ( int i = _NUM ; i < numActions ; i + + ) { didSomething | = mPendingActions . get ( i ) . generateOps ( records , isPop ) ; } mPendingActions . clear ( ) ; mHost . getHandler ( ) . removeCallbacks ( mExecCommit ) ; } return didSomething ; } 
6440	public Model getReasonerCapabilities ( ) { if ( factory ! = null ) { return factory . getCapabilities ( ) ; } else { return null ; } } 
6441	public static String find ( final String query , final Context ctx , final boolean root ) { treat input as XQuery if ( query . startsWith ( _STR + name + preds ) ; return tb . toString ( ) ; } 
6442	public void setWebViewClient ( WebViewClient client ) { checkThread ( ) ; mProvider . setWebViewClient ( client ) ; } 
6443	private void upgradeIfNecessaryLP ( Bundle oldGlobalUserRestrictions ) { final int originalVersion = mUserVersion ; int userVersion = mUserVersion ; if ( userVersion < _NUM ) { Assign a proper name for the owner , if not initialized correctly before UserData userData = getUserDataNoChecks ( UserHandle . USER _ SYSTEM ) ; if ( _STR + USER _ VERSION ) ; } else { mUserVersion = userVersion ; if ( originalVersion < mUserVersion ) { writeUserListLP ( ) ; } } } 
6444	public RepositoryVersionEntity create ( StackEntity stackEntity , String version , String displayName , List < RepoOsEntity > repoOsEntities , RepositoryType type ) throws AmbariException { if ( stackEntity = = null | | version = = null | | version . isEmpty ( ) | | displayName = = null | | displayName . isEmpty ( ) ) { throw new AmbariException ( _STR + stackEntity . getStackVersion ( ) ) ) ; } RepositoryVersionEntity newEntity = new RepositoryVersionEntity ( stackEntity , version , displayName , repoOsEntities ) ; newEntity . setType ( type ) ; this . create ( newEntity ) ; return newEntity ; } 
6445	protected AbstractHash newHashInstance ( ) { String hashAlgorithmName = assertHashAlgorithmName ( ) ; return new SimpleHash ( hashAlgorithmName ) ; } 
6446	public void purgeAndResetPriorityQueue ( ) throws SchemaChangeException , ClassTransformationException , IOException { final Stopwatch watch = Stopwatch . createStarted ( ) ; final VectorContainer c = priorityQueue . getHyperBatch ( ) ; final VectorContainer newContainer = new VectorContainer ( oContext ) ; @ SuppressWarnings ( _STR , watch . elapsed ( TimeUnit . MICROSECONDS ) ) ; } 
6447	TableSignature getTableSignature ( String tableName ) { return new TableSignature ( tableName , params ( ) ) ; } 
6448	public static Expression simple ( String expression ) { return expression ( expression ) ; } 
6449	public void testManifestQuads ( ) { Graph g = getGraph ( ) ; ReifierStd . reifyAs ( g , node ( _STR ; assertIsomorphic ( graphWith ( reified ) , g ) ; } 
6450	public ComponentSelector setBgPainter ( Painter bgPainter ) { currentStyle ( ) . setBgPainter ( bgPainter ) ; return this ; } 
6451	private void doSignal ( Node first ) { do { if ( ( firstWaiter = first . nextWaiter ) = = null ) lastWaiter = null ; first . nextWaiter = null ; } while ( ! transferForSignal ( first ) & & ( first = firstWaiter ) ! = null ) ; } 
6452	protected void processCYMKColorSpace ( PDColorSpace colorSpace ) { if ( ! processDefaultColorSpace ( colorSpace ) ) { if ( iccpw = = null ) { context . addValidationError ( new ValidationError ( ERROR _ GRAPHIC _ INVALID _ COLOR _ SPACE _ MISSING , _STR ) ) ; } } } 
6453	private boolean compareValue ( final CompareOperator op , final ByteArrayComparable comparator , final Cell cell ) { if ( op = = CompareOperator . NO _ OP ) { return true ; } int compareResult = PrivateCellUtil . compareValue ( cell , comparator ) ; return CompareFilter . compare ( op , compareResult ) ; } 
6454	public static UnfilteredRowIterator merge ( List < UnfilteredRowIterator > iterators , int nowInSec , MergeListener mergeListener ) { return UnfilteredRowMergeIterator . create ( iterators , nowInSec , mergeListener ) ; } 
6455	public void clients _NUM _NUM _NUM runs _NUM _NUM ( ) throws Exception { run ( _NUM _NUM _NUM , _NUM _NUM ) ; } 
6456	public void testReplace _NUM ( ) { ConcurrentMap map = map _NUM ( ) ; assertNotNull ( map . replace ( one , _STR , map . get ( one ) ) ; } 
6457	public void setSwitchPadding ( int pixels ) { mSwitchPadding = pixels ; requestLayout ( ) ; } 
6458	public void shouldRoundTripRecordsEvenWhenConfiguredToDisableSpecificAvro ( ) { Given SpecificAvroSerde < User > serde = createConfiguredSerdeForRecordValues ( ) ; User record = User . newBuilder ( ) . setName ( _STR ) ; serdeConfig . put ( KafkaAvroDeserializerConfig . SPECIFIC _ AVRO _ READER _ CONFIG , false ) ; When configured to be a serde for record keys serde . configure ( serdeConfig , true ) ; User roundtrippedRecordForKeySerde = serde . deserializer ( ) . deserialize ( ANY _ TOPIC , serde . serializer ( ) . serialize ( ANY _ TOPIC , record ) ) ; Then assertThat ( roundtrippedRecordForKeySerde , equalTo ( record ) ) ; When configured to be a serde for record values serde . configure ( serdeConfig , true ) ; User roundtrippedRecordForValueSerde = serde . deserializer ( ) . deserialize ( ANY _ TOPIC , serde . serializer ( ) . serialize ( ANY _ TOPIC , record ) ) ; Then assertThat ( roundtrippedRecordForValueSerde , equalTo ( record ) ) ; Cleanup serde . close ( ) ; } 
6459	public synchronized void onStart ( Activity activity ) { if ( Countly . sharedInstance ( ) . isLoggingEnabled ( ) ) { Log . d ( Countly . TAG , _STR + referrer ) ; } if ( referrer ! = null ) { connectionQueue _ . sendReferrerData ( referrer ) ; ReferrerReceiver . deleteReferrer ( context _ ) ; } CrashDetails . inForeground ( ) ; if ( autoViewTracker ) { String usedActivityName ; if ( automaticTrackingShouldUseShortName ) { usedActivityName = activity . getClass ( ) . getSimpleName ( ) ; } else { usedActivityName = activity . getClass ( ) . getName ( ) ; } recordView ( usedActivityName ) ; } calledAtLeastOnceOnStart = true ; } 
6460	public static String formatFileSize ( @ Nullable Context context , long sizeBytes , MeasureUnit unit , long mult ) { if ( context = = null ) { return _STR ; } final RoundedBytesResult res = formatBytes ( sizeBytes , unit , mult ) ; return bidiWrap ( context , formatRoundedBytesResult ( context , res ) ) ; } 
6461	public void testProviderSettingChangedDuringBootIfProviderNotAvailable ( ) { String chosenPackage = _STR , true , false , null ) } ; setupWithPackages ( packages ) ; Only ' install ' nonChosenPackage mTestSystemImpl . setPackageInfo ( createPackageInfo ( nonChosenPackage , true , true , true ) ) ; Set user - chosen package mTestSystemImpl . updateUserSetting ( null , chosenPackage ) ; runWebViewBootPreparationOnMainSync ( ) ; Verify that we switch the setting to point to the current package Mockito . verify ( mTestSystemImpl ) . updateUserSetting ( Mockito . anyObject ( ) , Mockito . eq ( nonChosenPackage ) ) ; assertEquals ( nonChosenPackage , mTestSystemImpl . getUserChosenWebViewProvider ( null ) ) ; checkPreparationPhasesForPackage ( nonChosenPackage , _NUM ) ; } 
6462	public void forward ( int lengthInMillis ) throws TransientNetworkDisconnectionException , NoConnectionException { Log . d ( TAG , _STR ) ; throw new NoConnectionException ( ) ; } long position = remoteMediaPlayer . getApproximateStreamPosition ( ) + lengthInMillis ; seek ( ( int ) position ) ; } 
6463	private void doMultiReducerTest ( int numMaps , int numReduces , int parallelMaps , int parallelReduces ) throws Exception { Path in = getNumberDirPath ( ) ; Path out = getOutputPath ( ) ; Clear data from any previous tests . Configuration conf = new Configuration ( ) ; FileSystem fs = FileSystem . getLocal ( conf ) ; if ( fs . exists ( out ) ) { fs . delete ( out , true ) ; } if ( fs . exists ( in ) ) { fs . delete ( in , true ) ; } for ( int i = _NUM ; i < numMaps ; i + + ) { makeNumberFile ( i , _NUM _NUM _NUM ) ; } Job job = Job . getInstance ( ) ; job . setNumReduceTasks ( numReduces ) ; job . setMapperClass ( SequenceMapper . class ) ; job . setOutputKeyClass ( Text . class ) ; job . setOutputValueClass ( NullWritable . class ) ; FileInputFormat . addInputPath ( job , in ) ; FileOutputFormat . setOutputPath ( job , out ) ; LocalJobRunner . setLocalMaxRunningMaps ( job , parallelMaps ) ; LocalJobRunner . setLocalMaxRunningReduces ( job , parallelReduces ) ; boolean result = job . waitForCompletion ( true ) ; assertTrue ( _STR , result ) ; verifyNumberJob ( numMaps ) ; } 
6464	public void setMaximumAngle ( float angleInDegrees ) { mMaximumAngle = angleInDegrees ; mMaximumTangent = toTangent ( angleInDegrees ) ; } 
6465	private static void executeOps ( ArrayList < BackStackRecord > records , ArrayList < Boolean > isRecordPop , int startIndex , int endIndex ) { for ( int i = startIndex ; i < endIndex ; i + + ) { final BackStackRecord record = records . get ( i ) ; final boolean isPop = isRecordPop . get ( i ) ; if ( isPop ) { record . bumpBackStackNesting ( - _NUM ) ; Only execute the add operations at the end of all transactions . boolean moveToState = i = = ( endIndex - _NUM ) ; record . executePopOps ( moveToState ) ; } else { record . bumpBackStackNesting ( _NUM ) ; record . executeOps ( ) ; } } } 
6466	public static boolean isInstrumentationAccessAllowed ( ServletContext servletContext , HttpServletRequest request , HttpServletResponse response ) throws IOException { Configuration conf = ( Configuration ) servletContext . getAttribute ( CONF _ CONTEXT _ ATTRIBUTE ) ; boolean access = true ; boolean adminAccess = conf . getBoolean ( CommonConfigurationKeys . HADOOP _ SECURITY _ INSTRUMENTATION _ REQUIRES _ ADMIN , false ) ; if ( adminAccess ) { access = hasAdministratorAccess ( servletContext , request , response ) ; } return access ; } 
6467	public void testWithLayoutChangeAndFinalize ( ) throws Exception { final long seed = _NUM x _NUM _NUM _NUM DF _NUM _NUM D ; try { startCluster ( ) ; Path [ ] paths = new Path [ _NUM ] ; File [ ] blockFiles = new File [ _NUM ] ; Create two files in DFS . for ( int i = _NUM ; i < _NUM ; + + i ) { paths [ i ] = new Path ( _STR ) ; assertFalse ( trashFile _NUM . exists ( ) ) ; assertFalse ( dn _NUM . getStorage ( ) . getBPStorage ( blockPoolId ) . isTrashAllowed ( blockFiles [ _NUM ] ) ) ; Ensure that the block file for the first file was moved from ' trash ' to ' previous ' . assertTrue ( isBlockFileInPrevious ( blockFiles [ _NUM ] ) ) ; assertFalse ( isTrashRootPresent ( ) ) ; Delete the second file . Ensure that its block file is in previous . blockFiles [ _NUM ] = getBlockForFile ( paths [ _NUM ] , true ) ; fs . delete ( paths [ _NUM ] , false ) ; assertTrue ( isBlockFileInPrevious ( blockFiles [ _NUM ] ) ) ; assertFalse ( isTrashRootPresent ( ) ) ; Finalize and ensure that neither block file exists in trash or previous . finalizeRollingUpgrade ( ) ; assertFalse ( isTrashRootPresent ( ) ) ; assertFalse ( isBlockFileInPrevious ( blockFiles [ _NUM ] ) ) ; assertFalse ( isBlockFileInPrevious ( blockFiles [ _NUM ] ) ) ; } finally { shutdownCluster ( ) ; } } 
6468	private void init ( String serverProtocol , String serverName , int serverPort , long timeOffset ) { setServerProtocol ( serverProtocol ) ; setServerName ( serverName ) ; setServerPort ( serverPort ) ; setTimeOffset ( timeOffset ) ; } 
6469	protected void publishNewFile ( CmsDbContext dbc , CmsProject onlineProject , CmsResource offlineResource , Set < CmsUUID > publishedContentIds , CmsUUID publishHistoryId , int publishTag ) throws CmsDataAccessException { CmsResourceState resourceState = fixMovedResource ( dbc , onlineProject , offlineResource , publishHistoryId , publishTag ) ; CmsFile newFile ; try { reset the labeled link flag before writing the online file int flags = offlineResource . getFlags ( ) ; flags & = ~ CmsResource . FLAG _ LABELED ; offlineResource . setFlags ( flags ) ; publish the file content newFile = m _ driverManager . getProjectDriver ( dbc ) . publishFileContent ( dbc , dbc . currentProject ( ) , onlineProject , offlineResource , publishedContentIds , true , publishTag ) ; } catch ( CmsVfsResourceAlreadyExistsException e ) { try { remove the existing file and ensure that it ' s content is written in any case by removing it ' s resource ID from the set of published resource IDs m _ driverManager . getVfsDriver ( dbc ) . removeFile ( dbc , onlineProject . getUuid ( ) , offlineResource ) ; publishedContentIds . remove ( offlineResource . getResourceId ( ) ) ; newFile = m _ driverManager . getProjectDriver ( dbc ) . publishFileContent ( dbc , dbc . currentProject ( ) , onlineProject , offlineResource , publishedContentIds , true , publishTag ) ; } catch ( CmsDataAccessException e _NUM ) { if ( LOG . isErrorEnabled ( ) ) { LOG . error ( Messages . get ( ) . getBundle ( ) . key ( Messages . LOG _ PUBLISHING _ RESOURCE _ _NUM , offlineResource . getRootPath ( ) ) , e ) ; } throw e _NUM ; } } catch ( CmsDataAccessException e ) { if ( LOG . isErrorEnabled ( ) ) { LOG . error ( Messages . get ( ) . getBundle ( ) . key ( Messages . LOG _ PUBLISHING _ RESOURCE _ _NUM , offlineResource . getRootPath ( ) ) , e ) ; } throw e ; } List < CmsProperty > offlineProperties ; try { write the properties online offlineProperties = m _ driverManager . getVfsDriver ( dbc ) . readPropertyObjects ( dbc , dbc . currentProject ( ) , offlineResource ) ; CmsProperty . setAutoCreatePropertyDefinitions ( offlineProperties , true ) ; m _ driverManager . getVfsDriver ( dbc ) . writePropertyObjects ( dbc , onlineProject , newFile , offlineProperties ) ; } catch ( CmsDataAccessException e ) { if ( LOG . isErrorEnabled ( ) ) { LOG . error ( Messages . get ( ) . getBundle ( ) . key ( Messages . LOG _ PUBLISHING _ PROPERTIES _ _NUM , newFile . getRootPath ( ) ) , e ) ; } throw e ; } try { write the ACL online m _ driverManager . getUserDriver ( dbc ) . publishAccessControlEntries ( dbc , dbc . currentProject ( ) , onlineProject , offlineResource . getResourceId ( ) , newFile . getResourceId ( ) ) ; } catch ( CmsDataAccessException e ) { if ( LOG . isErrorEnabled ( ) ) { LOG . error ( Messages . get ( ) . getBundle ( ) . key ( Messages . LOG _ PUBLISHING _ ACL _ _NUM , newFile . getRootPath ( ) ) , e ) ; } throw e ; } CmsFile offlineFile = new CmsFile ( offlineResource ) ; offlineFile . setContents ( newFile . getContents ( ) ) ; internalWriteHistory ( dbc , offlineFile , resourceState , offlineProperties , publishHistoryId , publishTag ) ; m _ driverManager . getVfsDriver ( dbc ) . updateRelations ( dbc , onlineProject , offlineResource ) ; } 
6470	public void testStoreBlobMd _NUM ( ) throws Exception { Configuration conf = new Configuration ( ) ; conf . setBoolean ( KEY _ STORE _ BLOB _ MD _NUM , true ) ; testAccount = AzureBlobStorageTestAccount . create ( conf ) ; testStoreBlobMd _NUM ( true ) ; } 
6471	public void testSize ( ) { ConcurrentMap map = map _NUM ( ) ; ConcurrentMap empty = map ( ) ; assertEquals ( _NUM , empty . size ( ) ) ; assertEquals ( _NUM , map . size ( ) ) ; } 
6472	public CharSequence getSummary ( ) { final CharSequence entry = getEntry ( ) ; if ( mSummary = = null ) { return super . getSummary ( ) ; } else { return String . format ( mSummary , entry = = null ? _STR : entry ) ; } } 
6473	public static XmlDouble parse ( org . apache . xmlbeans . xml . stream . XMLInputStream xis , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , org . apache . xmlbeans . xml . stream . XMLStreamException { return ( XmlDouble ) XmlBeans . getContextTypeLoader ( ) . parse ( xis , type , options ) ; } 
6474	protected boolean [ ] canHandleZeroTraining ( boolean nominalPredictor , boolean numericPredictor , boolean stringPredictor , boolean datePredictor , boolean relationalPredictor , boolean multiInstance , int classType ) { print ( _STR ) ; int numTrain = _NUM , numClasses = _NUM , missingLevel = _NUM ; boolean predictorMissing = false , classMissing = false ; return runBasicTest ( nominalPredictor , numericPredictor , stringPredictor , datePredictor , relationalPredictor , multiInstance , classType , missingLevel , predictorMissing , classMissing , numTrain , numClasses , accepts ) ; } 
6475	public boolean nextMatch ( LPInterpreter interpreter ) { if ( matchIterator . hasNext ( ) ) { lastMatch = matchIterator . next ( ) ; return true ; } else { return false ; } } 
6476	public void createAndRunJob ( Configuration conf ) throws IOException , InterruptedException , ClassNotFoundException { JobConf job = new JobConf ( conf ) ; job . setJarByClass ( TestLineRecordReaderJobs . class ) ; job . setMapperClass ( IdentityMapper . class ) ; job . setReducerClass ( IdentityReducer . class ) ; FileInputFormat . addInputPath ( job , inputDir ) ; FileOutputFormat . setOutputPath ( job , outputDir ) ; JobClient . runJob ( job ) ; } 
6477	public static byte [ ] makeKeyChecksum ( String algorithm , byte [ ] pwBytes , byte [ ] salt , int rounds ) { char [ ] mkAsChar = new char [ pwBytes . length ] ; for ( int i = _NUM ; i < pwBytes . length ; i + + ) { mkAsChar [ i ] = ( char ) pwBytes [ i ] ; } Key checksum = buildCharArrayKey ( algorithm , mkAsChar , salt , rounds ) ; return checksum . getEncoded ( ) ; } 
6478	private void readUntilEndStream ( final OutputStream out ) throws IOException { int bufSize ; int charMatchCount = _NUM ; byte [ ] keyw = ENDSTREAM ; last character position of shortest keyword ( ' endobj ' ) final int quickTestOffset = _NUM ; read next chunk into buffer ; already matched chars are added to beginning of buffer while ( ( bufSize = source . read ( strmBuf , charMatchCount , STRMBUFLEN - charMatchCount ) ) > _NUM ) { bufSize + = charMatchCount ; int bIdx = charMatchCount ; int quickTestIdx ; iterate over buffer , trying to find keyword match for ( int maxQuicktestIdx = bufSize - quickTestOffset ; bIdx < bufSize ; bIdx + + ) { reduce compare operations by first test last character we would have to match if current one matches ; if it is not a character from keywords we can move behind the test character ; this shortcut is inspired by the Boyer - Moore string search algorithm and can reduce parsing time by approx . _NUM _NUM % quickTestIdx = bIdx + quickTestOffset ; if ( charMatchCount = = _NUM & & quickTestIdx < maxQuicktestIdx ) { final byte ch = strmBuf [ quickTestIdx ] ; if ( ( ch > ' t ' ) | | ( ch < ' a ' ) ) { last character we would have to match if current character would match is not a character from keywords - > jump behind and start over bIdx = quickTestIdx ; continue ; } } could be negative - but we only compare to ASCII final byte ch = strmBuf [ bIdx ] ; if ( ch = = keyw [ charMatchCount ] ) { if ( + + charMatchCount = = keyw . length ) { match found bIdx + + ; break ; } } else { if ( ( charMatchCount = = _NUM ) & & ( ch = = ENDOBJ [ charMatchCount ] ) ) { maybe ENDSTREAM is missing but we could have ENDOBJ keyw = ENDOBJ ; charMatchCount + + ; } else { no match ; incrementing match start by _NUM would be dumb since we already know matched chars depending on current char read we may already have beginning of a new match : ' e ' : first char matched ; ' n ' : if we are at match position idx _NUM we already read ' e ' thus _NUM chars matched for each other char we have to start matching first keyword char beginning with next read position charMatchCount = ( ch = = E ) ? _NUM : ( ( ch = = N ) & & ( charMatchCount = = _NUM ) ) ? _NUM : _NUM ; search again for ' endstream ' keyw = ENDSTREAM ; } } } int contentBytes = Math . max ( _NUM , bIdx - charMatchCount ) ; write buffer content until first matched char to output stream if ( contentBytes > _NUM ) { out . write ( strmBuf , _NUM , contentBytes ) ; } if ( charMatchCount = = keyw . length ) { keyword matched ; unread matched keyword ( endstream / endobj ) and following buffered content source . rewind ( bufSize - contentBytes ) ; break ; } else { copy matched chars at start of buffer System . arraycopy ( keyw , _NUM , strmBuf , _NUM , charMatchCount ) ; } } this writes a lonely CR or drops trailing CR LF and LF out . flush ( ) ; } 
6479	private void calculateActiveItem ( ItemsPositionGetter itemsPositionGetter , ListItemData listItemData ) { int currentItemVisibilityPercents = listItemData . getVisibilityPercents ( mListItems ) ; if ( SHOW _ LOGS ) Logger . v ( TAG , _STR + currentItemVisibilityPercents ) ; if ( enoughPercentsForDeactivation ( currentItemVisibilityPercents ) & & neighbourItemData . isAvailable ( ) ) { neighbour item become active ( current ) setCurrentItem ( neighbourItemData ) ; } } 
6480	public void rollMasterKey ( ) { super . writeLock . lock ( ) ; try { LOG . info ( _STR ) ; this . timer . schedule ( new NextKeyActivator ( ) , this . activationDelay ) ; } } finally { super . writeLock . unlock ( ) ; } } 
6481	protected void init ( I _ CmsResourceContainer container ) throws JspException { check if the tag contains a pageSize , pageIndex and pageNavLength attribute , or none of them int pageAttribCount = _NUM ; pageAttribCount + = CmsStringUtil . isNotEmpty ( m _ pageSize ) ? _NUM : _NUM ; pageAttribCount + = CmsStringUtil . isNotEmpty ( m _ pageIndex ) ? _NUM : _NUM ; if ( ( pageAttribCount > _NUM ) & & ( pageAttribCount < _NUM ) ) { throw new CmsIllegalArgumentException ( Messages . get ( ) . container ( Messages . ERR _ TAG _ RESOURCELOAD _ INDEX _ SIZE _ _NUM ) ) ; } I _ CmsResourceContainer usedContainer ; if ( container = = null ) { no preloading ancestor has been found usedContainer = this ; if ( CmsStringUtil . isEmpty ( m _ collector ) ) { check if the tag contains a collector attribute throw new CmsIllegalArgumentException ( Messages . get ( ) . container ( Messages . ERR _ TAG _ RESOURCELOAD _ MISSING _ COLLECTOR _ _NUM ) ) ; } if ( CmsStringUtil . isEmpty ( m _ param ) ) { check if the tag contains a param attribute throw new CmsIllegalArgumentException ( Messages . get ( ) . container ( Messages . ERR _ TAG _ RESOURCELOAD _ MISSING _ PARAM _ _NUM ) ) ; } } else { use provided container ( preloading ancestor ) usedContainer = container ; } initialize OpenCms access objects m _ controller = CmsFlexController . getController ( pageContext . getRequest ( ) ) ; m _ cms = m _ controller . getCmsObject ( ) ; get the resource name from the selected container String resourcename = getResourceName ( m _ cms , usedContainer ) ; initialize a string mapper to resolve EL like strings in tag attributes CmsMacroResolver resolver = CmsMacroResolver . newInstance ( ) . setCmsObject ( m _ cms ) . setJspPageContext ( pageContext ) . setResourceName ( resourcename ) . setKeepEmptyMacros ( true ) ; resolve the collector name if ( container = = null ) { no preload parent container , initialize new values m _ collectorName = resolver . resolveMacros ( getCollector ( ) ) ; resolve the parameter m _ collectorParam = resolver . resolveMacros ( getParam ( ) ) ; m _ collectorResult = null ; } else { preload parent content container available , use values from this container m _ collectorName = usedContainer . getCollectorName ( ) ; m _ collectorParam = usedContainer . getCollectorParam ( ) ; m _ collectorResult = usedContainer . getCollectorResult ( ) ; } try { now collect the resources I _ CmsResourceCollector collector = OpenCms . getResourceManager ( ) . getContentCollector ( m _ collectorName ) ; if ( collector = = null ) { throw new CmsException ( Messages . get ( ) . container ( Messages . ERR _ COLLECTOR _ NOT _ FOUND _ _NUM , m _ collectorName ) ) ; } execute the collector if not already done in parent tag if ( m _ collectorResult = = null ) { m _ collectorResult = collector . getResults ( m _ cms , m _ collectorName , m _ collectorParam ) ; } m _ contentInfoBean = new CmsContentInfoBean ( ) ; m _ contentInfoBean . setPageSizeAsString ( resolver . resolveMacros ( m _ pageSize ) ) ; m _ contentInfoBean . setPageIndexAsString ( resolver . resolveMacros ( m _ pageIndex ) ) ; m _ contentInfoBean . setPageNavLengthAsString ( resolver . resolveMacros ( m _ pageNavLength ) ) ; m _ contentInfoBean . setResultSize ( m _ collectorResult . size ( ) ) ; m _ contentInfoBean . initResultIndex ( ) ; if ( ! isPreloader ( ) ) { not required when only preloading m _ collectorResult = CmsJspTagResourceLoad . limitCollectorResult ( m _ contentInfoBean , m _ collectorResult ) ; m _ contentInfoBean . initPageNavIndexes ( ) ; } else if ( isScopeVarSet ( ) ) { scope variable is set , store resource load bean in JSP context CmsJspResourceLoadBean bean = new CmsJspResourceLoadBean ( m _ cms , m _ collectorResult ) ; storeAttribute ( bean ) ; } } catch ( CmsException e ) { m _ controller . setThrowable ( e , m _ cms . getRequestContext ( ) . getUri ( ) ) ; throw new JspException ( e ) ; } } 
6482	public HSLFSlide removeSlide ( int index ) { int lastSlideIdx = _ slides . size ( ) - _NUM ; if ( index < _NUM | | index > lastSlideIdx ) { throw new IllegalArgumentException ( _STR ) ; } SlideListWithText slwt = _ documentRecord . getSlideSlideListWithText ( ) ; SlideAtomsSet [ ] sas = slwt . getSlideAtomsSets ( ) ; List < Record > records = new ArrayList < > ( ) ; List < SlideAtomsSet > sa = new ArrayList < > ( Arrays . asList ( sas ) ) ; HSLFSlide removedSlide = _ slides . remove ( index ) ; _ notes . remove ( removedSlide . getNotes ( ) ) ; sa . remove ( index ) ; int i = _NUM ; for ( HSLFSlide s : _ slides ) { s . setSlideNumber ( i + + ) ; } for ( SlideAtomsSet s : sa ) { records . add ( s . getSlidePersistAtom ( ) ) ; records . addAll ( Arrays . asList ( s . getSlideRecords ( ) ) ) ; } if ( sa . isEmpty ( ) ) { _ documentRecord . removeSlideListWithText ( slwt ) ; } else { slwt . setSlideAtomsSets ( sa . toArray ( new SlideAtomsSet [ sa . size ( ) ] ) ) ; slwt . setChildRecord ( records . toArray ( new Record [ records . size ( ) ] ) ) ; } if the removed slide had notes - remove references to them too int notesId = removedSlide . getSlideRecord ( ) . getSlideAtom ( ) . getNotesID ( ) ; if ( notesId ! = _NUM ) { SlideListWithText nslwt = _ documentRecord . getNotesSlideListWithText ( ) ; records = new ArrayList < > ( ) ; ArrayList < SlideAtomsSet > na = new ArrayList < > ( ) ; for ( SlideAtomsSet ns : nslwt . getSlideAtomsSets ( ) ) { if ( ns . getSlidePersistAtom ( ) . getSlideIdentifier ( ) = = notesId ) { continue ; } na . add ( ns ) ; records . add ( ns . getSlidePersistAtom ( ) ) ; if ( ns . getSlideRecords ( ) ! = null ) { records . addAll ( Arrays . asList ( ns . getSlideRecords ( ) ) ) ; } } if ( na . isEmpty ( ) ) { _ documentRecord . removeSlideListWithText ( nslwt ) ; } else { nslwt . setSlideAtomsSets ( na . toArray ( new SlideAtomsSet [ na . size ( ) ] ) ) ; nslwt . setChildRecord ( records . toArray ( new Record [ records . size ( ) ] ) ) ; } } return removedSlide ; } 
6483	public ActionBar getActionBar ( ) { initWindowDecorActionBar ( ) ; return mActionBar ; } 
6484	public String getOidcConnectTimeout ( ) { return getProperty ( SECURITY _ USER _ OIDC _ CONNECT _ TIMEOUT , DEFAULT _ SECURITY _ USER _ OIDC _ CONNECT _ TIMEOUT ) ; } 
6485	public void setUserOwner ( ApiResponse response ) { LinkedHashMap orgHashMap = ( LinkedHashMap ) response . getProperties ( ) . get ( _STR ) ) ; } 
6486	public static void validateSyncExtrasBundle ( Bundle extras ) { try { for ( String key : extras . keySet ( ) ) { Object value = extras . get ( key ) ; if ( value = = null ) continue ; if ( value instanceof Long ) continue ; if ( value instanceof Integer ) continue ; if ( value instanceof Boolean ) continue ; if ( value instanceof Float ) continue ; if ( value instanceof Double ) continue ; if ( value instanceof String ) continue ; if ( value instanceof Account ) continue ; throw new IllegalArgumentException ( _STR , exc ) ; } } 
6487	public ApplicationDescription getApplicationDescription ( final Application application ) { String applicationName = application . getName ( ) ; final ApplicationDescription applicationDescription = new ApplicationDescription ( ) ; List < ServiceDescription > serviceDescriptionList = getServicesDescription ( application ) ; logger . log ( Level . FINE , _STR + applicationName ) ; final DeploymentState applicationState = getApplicationState ( serviceDescriptionList ) ; applicationDescription . setApplicationName ( applicationName ) ; applicationDescription . setAuthGroups ( getApplicationAuthorizationGroups ( application ) ) ; applicationDescription . setServicesDescription ( serviceDescriptionList ) ; applicationDescription . setApplicationState ( applicationState ) ; return applicationDescription ; } 
6488	public void clearTemporaryMemory ( ) { To record the cuda block sizes needed by allocatedGPUObjects , others are cleared up . Set < Pointer > temporaryPointers = nonIn ( allocatedGPUPointers . keySet ( ) , getDirtyPointers ( ) ) ; for ( Pointer tmpPtr : temporaryPointers ) { guardedCudaFree ( tmpPtr ) ; } } 
6489	public static DataAccessPoint buildDataAccessPoint ( Resource svc , DatasetDescriptionRegistry dsDescMap ) { RDFNode n = FusekiLib . getOne ( svc , _STR , FmtUtils . stringForRDFNode ( object ) ) ) ; String name = object . getLexicalForm ( ) ; name = DataAccessPoint . canonical ( name ) ; DataService dataService = buildDataServiceCustom ( svc , dsDescMap ) ; DataAccessPoint dataAccess = new DataAccessPoint ( name , dataService ) ; return dataAccess ; } 
6490	public alluxio . proto . journal . File . CompleteFileEntry . Builder getCompleteFileBuilder ( ) { bitField _NUM _ | = _NUM x _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM ; onChanged ( ) ; return getCompleteFileFieldBuilder ( ) . getBuilder ( ) ; } 
6491	public void setPresetTransformer ( String transformerName ) { for ( Transformer t : Transformer . values ( ) ) { if ( t . equals ( transformerName ) ) { setPresetTransformer ( t ) ; return ; } } } 
6492	public void close ( ) throws IOException { if ( cOut ! = null ) { if ( digestCalc ! = null ) { hand code a mod detection packet BCPGOutputStream bOut = new BCPGOutputStream ( genOut , PacketTags . MOD _ DETECTION _ CODE , _NUM _NUM ) ; bOut . flush ( ) ; byte [ ] dig = digestCalc . getDigest ( ) ; cOut . write ( dig ) ; } cOut . close ( ) ; cOut = null ; pOut = null ; } } 
6493	public void testRWConflictWW ( boolean testInterleaved ) throws Exception { testRWConflicts ( testInterleaved ) ; verfiy that all aborts are justified for ( int task _ num = _NUM ; task _ num < numTasks ; task _ num + + ) { if ( commitStatus . get ( task _ num ) ! = COMMITVALUE ) assertThat ( commitStatus . get ( ( task _ num + _NUM ) % numTasks ) = = COMMITVALUE | | commitStatus . get ( ( task _ num - _NUM ) % numTasks ) = = COMMITVALUE ) . isTrue ( ) ; } } 
6494	private Collection < Path > getResourcesPaths ( final Pattern pattern ) throws Exception { final String classPath = System . getProperty ( _STR + path . toString ( ) ) ; paths . add ( path ) ; } return paths ; } 
6495	protected static ColumnMetaData . StructType drillFieldMetaData ( Class < ? > clazz ) { final List < ColumnMetaData > list = new ArrayList < > ( ) ; for ( Field field : clazz . getFields ( ) ) { if ( Modifier . isPublic ( field . getModifiers ( ) ) & & ! Modifier . isStatic ( field . getModifiers ( ) ) ) { NotNull notNull = field . getAnnotation ( NotNull . class ) ; boolean notNullable = ( notNull ! = null | | field . getType ( ) . isPrimitive ( ) ) ; list . add ( drillColumnMetaData ( AvaticaUtils . camelToUpper ( field . getName ( ) ) , list . size ( ) , field . getType ( ) , notNullable ) ) ; } } return ColumnMetaData . struct ( list ) ; } 
6496	public Locale getLocale ( ) { Locale locale = ( Locale ) get ( LOCALE ) ; if ( locale = = null ) { locale = Locale . getDefault ( ) ; setLocale ( locale ) ; } return locale ; } 
6497	protected AxisSpace calculateAxisSpace ( Graphics _NUM D g _NUM , Rectangle _NUM D plotArea ) { AxisSpace space = new AxisSpace ( ) ; PlotOrientation orientation = getOrientation ( ) ; work out the space required by the domain axis . . . AxisSpace fixed = getFixedDomainAxisSpace ( ) ; if ( fixed ! = null ) { if ( orientation = = PlotOrientation . HORIZONTAL ) { space . setLeft ( fixed . getLeft ( ) ) ; space . setRight ( fixed . getRight ( ) ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { space . setTop ( fixed . getTop ( ) ) ; space . setBottom ( fixed . getBottom ( ) ) ; } } else { CategoryAxis categoryAxis = getDomainAxis ( ) ; RectangleEdge categoryEdge = Plot . resolveDomainAxisLocation ( getDomainAxisLocation ( ) , orientation ) ; if ( categoryAxis ! = null ) { space = categoryAxis . reserveSpace ( g _NUM , this , plotArea , categoryEdge , space ) ; } else { if ( getDrawSharedDomainAxis ( ) ) { space = getDomainAxis ( ) . reserveSpace ( g _NUM , this , plotArea , categoryEdge , space ) ; } } } Rectangle _NUM D adjustedPlotArea = space . shrink ( plotArea , null ) ; work out the maximum height or width of the non - shared axes . . . int n = this . subplots . size ( ) ; int totalWeight = _NUM ; for ( int i = _NUM ; i < n ; i + + ) { CategoryPlot sub = ( CategoryPlot ) this . subplots . get ( i ) ; totalWeight + = sub . getWeight ( ) ; } this . subplotAreas = new Rectangle _NUM D [ n ] ; double x = adjustedPlotArea . getX ( ) ; double y = adjustedPlotArea . getY ( ) ; double usableSize = _NUM . _NUM ; if ( orientation = = PlotOrientation . HORIZONTAL ) { usableSize = adjustedPlotArea . getWidth ( ) - this . gap * ( n - _NUM ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { usableSize = adjustedPlotArea . getHeight ( ) - this . gap * ( n - _NUM ) ; } for ( int i = _NUM ; i < n ; i + + ) { CategoryPlot plot = ( CategoryPlot ) this . subplots . get ( i ) ; calculate sub - plot area if ( orientation = = PlotOrientation . HORIZONTAL ) { double w = usableSize * plot . getWeight ( ) / totalWeight ; this . subplotAreas [ i ] = new Rectangle _NUM D . Double ( x , y , w , adjustedPlotArea . getHeight ( ) ) ; x = x + w + this . gap ; } else if ( orientation = = PlotOrientation . VERTICAL ) { double h = usableSize * plot . getWeight ( ) / totalWeight ; this . subplotAreas [ i ] = new Rectangle _NUM D . Double ( x , y , adjustedPlotArea . getWidth ( ) , h ) ; y = y + h + this . gap ; } AxisSpace subSpace = plot . calculateRangeAxisSpace ( g _NUM , this . subplotAreas [ i ] , null ) ; space . ensureAtLeast ( subSpace ) ; } return space ; } 
6498	protected WorkUnit squeezeMultiWorkUnit ( MultiWorkUnit multiWorkUnit ) { WatermarkInterval interval = getWatermarkIntervalFromMultiWorkUnit ( multiWorkUnit ) ; List < KafkaPartition > partitions = getPartitionsFromMultiWorkUnit ( multiWorkUnit ) ; Preconditions . checkArgument ( ! partitions . isEmpty ( ) , _STR , partitions ) ) ; return workUnit ; } 
6499	public String getInstructions ( String [ ] inputs , String output ) { String opString = getOpcode ( ) ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( getExecType ( ) ) ; sb . append ( Lop . OPERAND _ DELIMITOR ) ; sb . append ( opString ) ; sb . append ( OPERAND _ DELIMITOR ) ; for ( int i = _NUM ; i < inputs . length ; i + + ) { sb . append ( getInputs ( ) . get ( i ) . prepInputOperand ( inputs [ i ] ) ) ; sb . append ( OPERAND _ DELIMITOR ) ; } sb . append ( prepOutputOperand ( output ) ) ; return sb . toString ( ) ; } 
6500	private int matchPaths ( String path _NUM , String path _NUM ) { int result = _NUM ; int end _NUM = path _NUM . length ( ) ; int end _NUM = path _NUM . length ( ) ; while ( end _NUM > _NUM & & end _NUM > _NUM ) { int slash _NUM = path _NUM . lastIndexOf ( ' / ' , end _NUM - _NUM ) ; int slash _NUM = path _NUM . lastIndexOf ( ' / ' , end _NUM - _NUM ) ; int backSlash _NUM = path _NUM . lastIndexOf ( ' \ \ ' , end _NUM - _NUM ) ; int backSlash _NUM = path _NUM . lastIndexOf ( ' \ \ ' , end _NUM - _NUM ) ; int start _NUM = ( slash _NUM > backSlash _NUM ? slash _NUM : backSlash _NUM ) ; int start _NUM = ( slash _NUM > backSlash _NUM ? slash _NUM : backSlash _NUM ) ; if ( start _NUM < _NUM ) start _NUM = _NUM ; else start _NUM + + ; if ( start _NUM < _NUM ) start _NUM = _NUM ; else start _NUM + + ; int length = end _NUM - start _NUM ; if ( end _NUM - start _NUM ! = length ) break ; if ( path _NUM . regionMatches ( true , start _NUM , path _NUM , start _NUM , length ) ) { result + + ; end _NUM = start _NUM - _NUM ; end _NUM = start _NUM - _NUM ; } else break ; } return result ; } 
6501	public boolean flingToBeginning ( int maxSwipes ) throws UiObjectNotFoundException { Tracer . trace ( maxSwipes ) ; return scrollToBeginning ( maxSwipes , FLING _ STEPS ) ; } 
6502	private static String [ ] lc ( final Option < ? > . . . options ) { final StringList sl = new StringList ( ) ; for ( final Option < ? > option : options ) sl . add ( lc ( option ) ) ; return sl . finish ( ) ; } 
6503	public static int [ ] getInputShapeFromConfig ( Map < String , Object > layerConfig , KerasLayerConfiguration conf ) throws InvalidKerasConfigurationException { TODO : validate this . shouldn ' t we also have INPUT _ SHAPE checked ? Map < String , Object > innerConfig = KerasLayerUtils . getInnerLayerConfigFromConfig ( layerConfig , conf ) ; if ( ! innerConfig . containsKey ( conf . getLAYER _ FIELD _ BATCH _ INPUT _ SHAPE ( ) ) ) return null ; List < Integer > batchInputShape = ( List < Integer > ) innerConfig . get ( conf . getLAYER _ FIELD _ BATCH _ INPUT _ SHAPE ( ) ) ; int [ ] inputShape = new int [ batchInputShape . size ( ) - _NUM ] ; for ( int i = _NUM ; i < batchInputShape . size ( ) ; i + + ) { inputShape [ i - _NUM ] = batchInputShape . get ( i ) ! = null ? batchInputShape . get ( i ) : _NUM ; } return inputShape ; } 
6504	private void loadFromFile ( ) throws IOException { InterpreterInfoSaving infoSaving = configStorage . loadInterpreterSettings ( ) ; if ( infoSaving = = null ) { setting from interpreterSettingTemplates for ( InterpreterSetting interpreterSettingTemplate : interpreterSettingTemplates . values ( ) ) { InterpreterSetting interpreterSetting = new InterpreterSetting ( interpreterSettingTemplate ) ; initInterpreterSetting ( interpreterSetting ) ; interpreterSettings . put ( interpreterSetting . getId ( ) , interpreterSetting ) ; } return ; } update interpreter binding first as we change interpreter setting id in ZEPPELIN - _NUM _NUM _NUM _NUM . Map < String , List < String > > newBindingMap = new HashMap < > ( ) ; for ( Map . Entry < String , List < String > > entry : infoSaving . interpreterBindings . entrySet ( ) ) { String noteId = entry . getKey ( ) ; List < String > oldSettingIdList = entry . getValue ( ) ; List < String > newSettingIdList = new ArrayList < > ( ) ; for ( String oldId : oldSettingIdList ) { if ( infoSaving . interpreterSettings . containsKey ( oldId ) ) { newSettingIdList . add ( infoSaving . interpreterSettings . get ( oldId ) . getName ( ) ) ; } ; } newBindingMap . put ( noteId , newSettingIdList ) ; } interpreterBindings . putAll ( newBindingMap ) ; TODO ( zjffdu ) still ugly ( should move all to InterpreterInfoSaving ) for ( InterpreterSetting savedInterpreterSetting : infoSaving . interpreterSettings . values ( ) ) { savedInterpreterSetting . setProperties ( InterpreterSetting . convertInterpreterProperties ( savedInterpreterSetting . getProperties ( ) ) ) ; initInterpreterSetting ( savedInterpreterSetting ) ; InterpreterSetting interpreterSettingTemplate = interpreterSettingTemplates . get ( savedInterpreterSetting . getGroup ( ) ) ; the user saved interpreter setting if ( interpreterSettingTemplate ! = null ) { savedInterpreterSetting . setInterpreterDir ( interpreterSettingTemplate . getInterpreterDir ( ) ) ; merge properties from interpreter - setting . json and interpreter . json Map < String , InterpreterProperty > mergedProperties = new HashMap < > ( InterpreterSetting . convertInterpreterProperties ( interpreterSettingTemplate . getProperties ( ) ) ) ; Map < String , InterpreterProperty > savedProperties = InterpreterSetting . convertInterpreterProperties ( savedInterpreterSetting . getProperties ( ) ) ; for ( Map . Entry < String , InterpreterProperty > entry : savedProperties . entrySet ( ) ) { only merge properties whose value is not empty if ( entry . getValue ( ) . getValue ( ) ! = null & & ! StringUtils . isBlank ( entry . getValue ( ) . toString ( ) ) ) { mergedProperties . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } } savedInterpreterSetting . setProperties ( mergedProperties ) ; merge InterpreterInfo savedInterpreterSetting . setInterpreterInfos ( interpreterSettingTemplate . getInterpreterInfos ( ) ) ; savedInterpreterSetting . setInterpreterRunner ( interpreterSettingTemplate . getInterpreterRunner ( ) ) ; } else { LOGGER . warn ( _STR , savedInterpreterSetting . getName ( ) ) ; interpreterSettings . put ( savedInterpreterSetting . getId ( ) , savedInterpreterSetting ) ; } if ( infoSaving . interpreterRepositories ! = null ) { for ( RemoteRepository repo : infoSaving . interpreterRepositories ) { if ( ! dependencyResolver . getRepos ( ) . contains ( repo ) ) { this . interpreterRepositories . add ( repo ) ; } } repositories have been loaded . for ( InterpreterSetting setting : interpreterSettings . values ( ) ) { setting . setDependencies ( setting . getDependencies ( ) ) ; } } } 
6505	protected void onSelectionChanged ( int selStart , int selEnd ) { if ( mSettingExtractedText = = _NUM & & mIME ! = null & & selStart > = _NUM & & selEnd > = _NUM ) { mIME . onExtractedSelectionChanged ( selStart , selEnd ) ; } } 
6506	public default < V > Property < V > property ( final String key ) { final Iterator < ? extends Property < V > > iterator = this . properties ( key ) ; return iterator . hasNext ( ) ? iterator . next ( ) : Property . < V > empty ( ) ; } 
6507	public void actionReport ( ) throws JspException { save initialized instance of this class in request attribute for included sub - elements getJsp ( ) . getRequest ( ) . setAttribute ( SESSION _ WORKPLACE _ CLASS , this ) ; switch ( getAction ( ) ) { case ACTION _ REPORT _ END : actionCloseDialog ( ) ; break ; case ACTION _ REPORT _ UPDATE : setParamAction ( REPORT _ UPDATE ) ; getJsp ( ) . include ( FILE _ REPORT _ OUTPUT ) ; break ; case ACTION _ REPORT _ BEGIN : case ACTION _ CONFIRMED : default : CmsElementRenameThread thread = new CmsElementRenameThread ( getCms ( ) , this ) ; thread . start ( ) ; setParamAction ( REPORT _ BEGIN ) ; setParamThread ( thread . getUUID ( ) . toString ( ) ) ; getJsp ( ) . include ( FILE _ REPORT _ OUTPUT ) ; break ; } } 
6508	public void report ( List < Page > result ) { Print Pages out ranked by highest authority sortAuthority ( result ) ; System . out . println ( _STR + getMaxAuthority ( result ) . getLocation ( ) ) ; } 
6509	public int addPicture ( byte [ ] pictureData , int format ) { int imageNumber = getAllPictures ( ) . size ( ) + _NUM ; XSSFPictureData img = createRelationship ( XSSFPictureData . RELATIONS [ format ] , this . xssfFactory , imageNumber , true ) . getDocumentPart ( ) ; try ( OutputStream out = img . getPackagePart ( ) . getOutputStream ( ) ) { out . write ( pictureData ) ; } catch ( IOException e ) { throw new POIXMLException ( e ) ; } pictures . add ( img ) ; return imageNumber - _NUM ; } 
6510	private void onRecord ( boolean start ) { if ( start ) { onPlay ( STOP _ PLAYING ) ; mPlayPause . setImageResource ( R . drawable . ic _ play ) ; startRecordingAsync ( ) ; startAnimate ( ) ; } else { if ( ! mIsRecording ) { recordingAsync . cancel ( true ) ; } stopRecording ( ) ; stopAnimating ( ) ; try { long size = _NUM ; File forSize = new File ( mFilePath ) ; if ( forSize . exists ( ) ) { size = forSize . length ( ) ; String text = getString ( R . string . OK ) + _STR + Tools . readableFileSize ( size ) ; okButton . setText ( text ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } ; } } 
6511	public List < ValueSource > parseValueSourceList ( ) throws ParseException { List < ValueSource > sources = new ArrayList < ValueSource > ( _NUM ) ; while ( hasMoreArguments ( ) ) { sources . add ( parseValueSource ( true ) ) ; } return sources ; } 
6512	public void bindProperty ( Component cmp , final String propertyName , final String attributeName , final int defer , boolean objectLead ) { if ( objectLead ) { Object val = values . get ( attributeName ) ; Object cmpVal = cmp . getBoundPropertyValue ( propertyName ) ; if ( val = = null ) { if ( cmpVal ! = null ) { cmp . setBoundPropertyValue ( propertyName , null ) ; } } else { if ( cmpVal = = null | | ! ( val . equals ( cmpVal ) ) ) { cmp . setBoundPropertyValue ( propertyName , val ) ; } } } else { Object val = values . get ( attributeName ) ; Object cmpVal = cmp . getBoundPropertyValue ( propertyName ) ; if ( cmpVal = = null ) { if ( val ! = null ) { values . remove ( attributeName ) ; status = STATUS _ MODIFIED ; } } else { if ( val = = null | | ! ( val . equals ( cmpVal ) ) ) { values . put ( attributeName , cmpVal ) ; status = STATUS _ MODIFIED ; } } } BindTarget target = new BindTarget ( ) { public void propertyChanged ( Component source , String propertyName , Object oldValue , Object newValue ) { switch ( defer ) { case BINDING _ DEFERRED : if ( deferedValues = = null ) { deferedValues = new Hashtable ( ) ; } deferedValues . put ( attributeName , newValue ) ; break ; case BINDING _ IMMEDIATE : values . put ( attributeName , newValue ) ; status = STATUS _ MODIFIED ; break ; case BINDING _ AUTO _ SAVE : values . put ( attributeName , newValue ) ; status = STATUS _ MODIFIED ; CloudStorage . getInstance ( ) . save ( CloudObject . this ) ; break ; } } } ; cmp . bindProperty ( propertyName , target ) ; cmp . putClientProperty ( _STR + propertyName , target ) ; } 
6513	protected CmsVfsEntryBean makeEntryBean ( CmsResource resource , boolean root ) throws CmsException { CmsObject cms = getCmsObject ( ) ; boolean isFolder = resource . isFolder ( ) ; String name = root ? _STR : resource . getName ( ) ; String path = cms . getSitePath ( resource ) ; boolean hasChildren = false ; if ( isFolder ) { List < CmsResource > children = cms . getResourcesInFolder ( cms . getRequestContext ( ) . getSitePath ( resource ) , CmsResourceFilter . DEFAULT ) ; if ( ! children . isEmpty ( ) ) { hasChildren = true ; } } String resourceType = OpenCms . getResourceManager ( ) . getResourceType ( resource . getTypeId ( ) ) . getTypeName ( ) ; return new CmsVfsEntryBean ( path , name , resourceType , isFolder , hasChildren ) ; } 
6514	public int genCode ( String language , String destDir , ArrayList < String > options ) throws IOException { CodeGenerator gen = CodeGenerator . get ( language ) ; if ( gen ! = null ) { gen . genCode ( mName , mInclFiles , mRecords , destDir , options ) ; } else { System . err . println ( _STR + language ) ; return _NUM ; } return _NUM ; } 
6515	public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( _STR ) ; return sb . toString ( ) ; } 
6516	public void closeWithActiveCheckpoints ( ) throws Exception { setupOneMessage ( ) ; PubsubReader reader = primSource . createReader ( p . getOptions ( ) , null ) ; reader . start ( ) ; PubsubCheckpoint checkpoint = reader . getCheckpointMark ( ) ; reader . close ( ) ; checkpoint . finalizeCheckpoint ( ) ; } 
6517	public String registerWindowingStrategy ( WindowingStrategy < ? , ? > windowingStrategy ) throws IOException { String existing = windowingStrategyIds . get ( windowingStrategy ) ; if ( existing ! = null ) { return existing ; } String baseName = String . format ( _STR , NameUtils . approximateSimpleName ( windowingStrategy ) , NameUtils . approximateSimpleName ( windowingStrategy . getWindowFn ( ) ) ) ; String name = uniqify ( baseName , windowingStrategyIds . values ( ) ) ; windowingStrategyIds . put ( windowingStrategy , name ) ; RunnerApi . WindowingStrategy windowingStrategyProto = WindowingStrategyTranslation . toProto ( windowingStrategy , this ) ; componentsBuilder . putWindowingStrategies ( name , windowingStrategyProto ) ; return name ; } 
6518	protected void fireCaretUpdate ( CaretEvent e ) { super . fireCaretUpdate ( e ) ; if ( isBracketMatchingEnabled ( ) ) { doBracketMatching ( ) ; } } 
6519	public void discardContent ( ) { dispose ( ) ; } 
6520	public static DERBitString getInstance ( Object obj ) { if ( obj = = null | | obj instanceof DERBitString ) { return ( DERBitString ) obj ; } if ( obj instanceof DLBitString ) { return new DERBitString ( ( ( DLBitString ) obj ) . data , ( ( DLBitString ) obj ) . padBits ) ; } if ( obj instanceof byte [ ] ) { try { return ( DERBitString ) fromByteArray ( ( byte [ ] ) obj ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( _STR + obj . getClass ( ) . getName ( ) ) ; } 
6521	public void setMinMaxSpeed ( float minSpeed , float maxSpeed ) { if ( minSpeed > = maxSpeed ) throw new IllegalArgumentException ( _STR ) ; cancelSpeedAnimator ( ) ; this . minSpeed = minSpeed ; this . maxSpeed = maxSpeed ; if ( ! attachedToWindow ) return ; updateBackgroundBitmap ( ) ; setSpeedAt ( speed ) ; } 
6522	public synchronized int read ( ) throws IOException { ensureOpen ( ) ; while ( mData . length = = mIndex ) { if ( ! mParent . continueOperation ( true , true ) ) { return - _NUM ; } } return ( mData [ mIndex + + ] & _NUM xFF ) ; } 
6523	public void testDocumentReset ( ) throws Exception { ClassPathResource reuters _NUM _NUM _NUM _NUM = new ClassPathResource ( _STR ) ; File f = reuters _NUM _NUM _NUM _NUM . getFile ( ) ; DocumentIterator iter = new FileDocumentIterator ( f . getAbsolutePath ( ) ) ; int cnt = _NUM ; while ( iter . hasNext ( ) ) { InputStream stream = iter . nextDocument ( ) ; stream . close ( ) ; cnt + + ; } iter . reset ( ) ; while ( iter . hasNext ( ) ) { InputStream stream = iter . nextDocument ( ) ; stream . close ( ) ; cnt + + ; } assertEquals ( _NUM _NUM , cnt ) ; } 
6524	public static void checkArgument ( boolean expression , @ Nullable String errorMessageTemplate , @ Nullable Object . . . errorMessageArgs ) { if ( ! expression ) { throw new IllegalArgumentException ( format ( errorMessageTemplate , errorMessageArgs ) ) ; } } 
6525	public static void waitToFinish ( ) { long startTime = System . currentTimeMillis ( ) ; boolean hadMessages = false ; Handler handler = getHandler ( ) ; synchronized ( sLock ) { if ( handler . hasMessages ( QueuedWorkHandler . MSG _ RUN ) ) { Delayed work will be processed at processPendingWork ( ) below handler . removeMessages ( QueuedWorkHandler . MSG _ RUN ) ; if ( DEBUG ) { hadMessages = true ; Log . d ( LOG _ TAG , _STR ) ; } } } } 
6526	protected void snapshotRegions ( List < Pair < RegionInfo , ServerName > > regions ) throws HBaseSnapshotException , IOException { Set < String > regionServers = new HashSet < > ( regions . size ( ) ) ; for ( Pair < RegionInfo , ServerName > region : regions ) { if ( region ! = null & & region . getFirst ( ) ! = null & & region . getSecond ( ) ! = null ) { RegionInfo hri = region . getFirst ( ) ; if ( hri . isOffline ( ) & & ( hri . isSplit ( ) | | hri . isSplitParent ( ) ) ) continue ; regionServers . add ( region . getSecond ( ) . toString ( ) ) ; } } start the snapshot on the RS Procedure proc = coordinator . startProcedure ( this . monitor , this . snapshot . getName ( ) , this . snapshot . toByteArray ( ) , Lists . newArrayList ( regionServers ) ) ; if ( proc = = null ) { String msg = _STR , e ) ; monitor . receive ( ee ) ; Thread . currentThread ( ) . interrupt ( ) ; } catch ( ForeignException e ) { monitor . receive ( e ) ; } } 
6527	public static String makeUnifiedLineFeeds ( DBPDataSource dataSource , String query ) { SQLDialect dialect = SQLUtils . getDialectFromDataSource ( dataSource ) ; if ( ! dialect . isCRLFBroken ( ) ) { return query ; } if ( query . indexOf ( ' \ r ' ) = = - _NUM ) { return query ; } StringBuilder result = new StringBuilder ( query . length ( ) ) ; for ( int i = _NUM ; i < query . length ( ) ; i + + ) { char c = query . charAt ( i ) ; if ( c = = ' \ r ' ) { continue ; } result . append ( c ) ; } return result . toString ( ) ; } 
6528	public void setLineDash ( LineDash pen ) { AbstractEscherOptRecord opt = getEscherOptRecord ( ) ; setEscherProperty ( opt , EscherProperties . LINESTYLE _ _ LINEDASHING , pen = = LineDash . SOLID ? - _NUM : pen . nativeId ) ; } 
6529	public void testInvalidSetQueryTimeout ( ) throws SQLException { try ( PreparedStatement stmt = connection . prepareStatement ( SYS _ VERSION _ SQL ) ) { Setting negative value int valueToSet = - _NUM _NUM ; try { stmt . setQueryTimeout ( valueToSet ) ; } catch ( final SQLException e ) { assertThat ( e . getMessage ( ) , containsString ( _STR ) ) ; } } } 
6530	public static ThreadFactory newDaemonThreadFactory ( final String prefix , final UncaughtExceptionHandler handler ) { final ThreadFactory namedFactory = getNamedThreadFactory ( prefix ) ; return new ThreadFactory ( ) { @ Override public Thread newThread ( Runnable r ) { Thread t = namedFactory . newThread ( r ) ; if ( handler ! = null ) { t . setUncaughtExceptionHandler ( handler ) ; } else { t . setUncaughtExceptionHandler ( LOGGING _ EXCEPTION _ HANDLER ) ; } if ( ! t . isDaemon ( ) ) { t . setDaemon ( true ) ; } if ( t . getPriority ( ) ! = Thread . NORM _ PRIORITY ) { t . setPriority ( Thread . NORM _ PRIORITY ) ; } return t ; } } ; } 
6531	public static void axpy ( ExecutionContext ec , GPUContext gCtx , String instName , MatrixObject in _NUM , MatrixObject in _NUM , String outputName , double constant ) { if ( ec . getGPUContext ( _NUM ) ! = gCtx ) throw new DMLRuntimeException ( _STR , ExecutionConfig . getConfigForSimpleMatrixOperations ( rlenA , clenA ) , A , B , constant , C , rlenA , clenA , rlenB , clenB ) ; if ( DMLScript . FINEGRAINED _ STATISTICS ) GPUStatistics . maintainCPMiscTimes ( instName , GPUInstruction . MISC _ TIMER _ DAXPY _ MV _ KERNEL , System . nanoTime ( ) - t _NUM ) ; } } 
6532	public Stream partitionAggregate ( Fields inputFields , Aggregator agg , Fields functionFields ) { projectionValidation ( inputFields ) ; return _ topology . addSourcedNode ( this , new ProcessorNode ( _ topology . getUniqueStreamId ( ) , _ name , functionFields , functionFields , new AggregateProcessor ( inputFields , agg ) ) ) ; } 
6533	public static void listContentStream ( File pdfFile , int pageNum , PrintWriter out ) throws IOException { PdfReader reader = new PdfReader ( pdfFile . getCanonicalPath ( ) ) ; listContentStreamForPage ( reader , pageNum , out ) ; } 
6534	public void add ( UnfilteredRowIterator partition ) { assert Range . isInRanges ( partition . partitionKey ( ) . getToken ( ) , desc . ranges ) : partition . partitionKey ( ) . getToken ( ) + _STR + lastKey . getToken ( ) ; case _NUM must be true : mix in the hashed row RowHash rowHash = rowHash ( partition ) ; if ( rowHash ! = null ) { range . addHash ( rowHash ) ; } } 
6535	public static < R > List < R > getResultsWithNCallables ( CallableFactory < R > callableFactory , int numThreads , String threadNameFormat , Progressable progressable ) { ExecutorService executorService = Executors . newFixedThreadPool ( numThreads , ThreadUtils . createThreadFactory ( threadNameFormat ) ) ; HashMap < Integer , Future < R > > futures = new HashMap < > ( numThreads ) ; for ( int i = _NUM ; i < numThreads ; i + + ) { Callable < R > callable = callableFactory . newCallable ( i ) ; Future < R > future = executorService . submit ( new LogStacktraceCallable < R > ( callable ) ) ; futures . put ( i , future ) ; } executorService . shutdown ( ) ; List < R > futureResults = new ArrayList < > ( Collections . < R > nCopies ( numThreads , null ) ) ; We do this in order to get any exceptions from the futures early while ( ! futures . isEmpty ( ) ) { Iterator < Map . Entry < Integer , Future < R > > > iterator = futures . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Map . Entry < Integer , Future < R > > entry = iterator . next ( ) ; R result ; try { Try to get result from the future result = entry . getValue ( ) . get ( MSEC _ TO _ WAIT _ ON _ EACH _ FUTURE , TimeUnit . MILLISECONDS ) ; } catch ( InterruptedException e ) { throw new IllegalStateException ( _STR , e . getCause ( ) ) ; } } catch ( TimeoutException e ) { If result is not ready yet just keep waiting continue ; } Result is ready , put it to final results futureResults . set ( entry . getKey ( ) , result ) ; Remove current future since we are done with it iterator . remove ( ) ; } progressable . progress ( ) ; } return futureResults ; } 
6536	public void validate ( ) throws ValidationException { checkMandatoryField ( ) ; createFontDescriptorHelper ( ) ; processFontDescriptorValidation ( ) ; checkEncoding ( ) ; checkToUnicode ( ) ; } 
6537	protected void writeSource ( ) { if ( includeSource ( ) ) { first save a copy of the source in compact form into a buffer ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; RDFWriter rw = m _ source . getWriter ( _STR ) ; } } 
6538	public boolean isOutgoingCallPermitted ( PhoneAccountHandle phoneAccountHandle ) { ITelecomService service = getTelecomService ( ) ; if ( service ! = null ) { try { return service . isOutgoingCallPermitted ( phoneAccountHandle ) ; } catch ( RemoteException e ) { Log . e ( TAG , _STR , e ) ; } } return false ; } 
6539	private void removeKey ( Key k , List < Key > [ ] vector ) { if ( k = = null ) { throw new NullPointerException ( _STR ) ; } int [ ] h = hash . hash ( k ) ; hash . clear ( ) ; for ( int i = _NUM ; i < nbHash ; i + + ) { vector [ h [ i ] ] . remove ( k ) ; } } 
6540	public static double correlation ( double [ ] residuals , double [ ] targetAttribute ) { double [ ] predictedValues = new double [ residuals . length ] ; for ( int i = _NUM ; i < predictedValues . length ; i + + ) { predictedValues [ i ] = targetAttribute [ i ] - residuals [ i ] ; } double ssErr = ssError ( predictedValues , targetAttribute ) ; double total = ssTotal ( residuals , targetAttribute ) ; return _NUM - ( ssErr / total ) ; } 
6541	public void restat ( String path ) { mStat = doStat ( path ) ; } 
6542	public ArrayList getBlankSignatureNames ( ) { getSignatureNames ( ) ; ArrayList sigs = new ArrayList ( ) ; for ( Iterator it = fields . entrySet ( ) . iterator ( ) ; it . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) it . next ( ) ; Item item = ( Item ) entry . getValue ( ) ; PdfDictionary merged = item . getMerged ( _NUM ) ; if ( ! PdfName . SIG . equals ( merged . getAsName ( PdfName . FT ) ) ) continue ; if ( sigNames . containsKey ( entry . getKey ( ) ) ) continue ; sigs . add ( entry . getKey ( ) ) ; } return sigs ; } 
6543	public void remove ( int series ) { if ( ( series < _NUM ) | | ( series > = getSeriesCount ( ) ) ) { throw new IllegalArgumentException ( _STR ) ; } fetch the series , remove the change listener , then remove the series . TaskSeries ts = ( TaskSeries ) this . data . get ( series ) ; ts . removeChangeListener ( this ) ; this . data . remove ( series ) ; fireDatasetChanged ( ) ; } 
6544	public void setRefreshingLabel ( CharSequence refreshingLabel ) { getLoadingLayoutProxy ( ) . setRefreshingLabel ( refreshingLabel ) ; } 
6545	public Builder clearServerInfos ( ) { if ( serverInfosBuilder _ = = null ) { serverInfos _ = org . apache . drill . exec . proto . UserProtos . RpcEndpointInfos . getDefaultInstance ( ) ; onChanged ( ) ; } else { serverInfosBuilder _ . clear ( ) ; } bitField _NUM _ = ( bitField _NUM _ & ~ _NUM x _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM ) ; return this ; } 
6546	public static RegularExpression createRegex ( String pattern , String options ) throws ParseException { RegularExpression re = null ; int intOptions = REUtil . parseOptions ( options ) ; synchronized ( REUtil . regexCache ) { int i ; for ( i = _NUM ; i < REUtil . CACHESIZE ; i + + ) { RegularExpression cached = REUtil . regexCache [ i ] ; if ( cached = = null ) { i = - _NUM ; break ; } if ( cached . equals ( pattern , intOptions ) ) { re = cached ; break ; } } if ( re ! = null ) { if ( i ! = _NUM ) { System . arraycopy ( REUtil . regexCache , _NUM , REUtil . regexCache , _NUM , i ) ; REUtil . regexCache [ _NUM ] = re ; } } else { re = new RegularExpression ( pattern , options ) ; System . arraycopy ( REUtil . regexCache , _NUM , REUtil . regexCache , _NUM , REUtil . CACHESIZE - _NUM ) ; REUtil . regexCache [ _NUM ] = re ; } } return re ; } 
6547	long runMiniBenchmarkWithDelegationToken ( Configuration conf , int count , String keytabKey , String userNameKey ) throws IOException { get login information String user = System . getProperty ( _STR ) ; if ( userNameKey ! = null ) user = conf . get ( userNameKey , user ) ; String keytabFile = null ; if ( keytabKey ! = null ) keytabFile = conf . get ( keytabKey , keytabFile ) ; MiniServer miniServer = null ; UserGroupInformation . setConfiguration ( conf ) ; String shortUserName = UserGroupInformation . createRemoteUser ( user ) . getShortUserName ( ) ; try { conf . setStrings ( DefaultImpersonationProvider . getTestProvider ( ) . getProxySuperuserGroupConfKey ( shortUserName ) , GROUP _ NAME _ _NUM ) ; configureSuperUserIPAddresses ( conf , shortUserName ) ; start the server miniServer = new MiniServer ( conf , user , keytabFile ) ; InetSocketAddress addr = miniServer . getAddress ( ) ; connectToServerAndGetDelegationToken ( conf , addr ) ; connect to the server count times setLoggingLevel ( logLevel ) ; long elapsed = _NUM L ; for ( int idx = _NUM ; idx < count ; idx + + ) { elapsed + = connectToServerUsingDelegationToken ( conf , addr ) ; } return elapsed ; } finally { if ( miniServer ! = null ) miniServer . stop ( ) ; } } 
6548	public synchronized int getPredictedTotal ( T predicted ) { int total = _NUM ; for ( T actual : classes ) { total + = getCount ( actual , predicted ) ; } return total ; } 
6549	public static Document parseXml ( final InputStream is , XmlTextTransformer xmlTransformer , String rootNames , final String forceNamespace ) throws Exception { ObjectHelper . notNull ( is , _STR ) ) ; } Outputs text accumulated under the current node private void addTextIfNeeded ( ) { if ( textBuffer . length ( ) > _NUM ) { final Element el = elementStack . isEmpty ( ) ? null : elementStack . peek ( ) ; if ( el ! = null ) { final Node textNode = doc . createTextNode ( textBuffer . toString ( ) ) ; el . appendChild ( textNode ) ; textBuffer . delete ( _NUM , textBuffer . length ( ) ) ; } } } } ; parser . parse ( is , handler ) ; return doc ; } 
6550	protected HRegion getRegion ( final byte [ ] regionName ) throws NotServingRegionException { String encodedRegionName = RegionInfo . encodeRegionName ( regionName ) ; return getRegionByEncodedName ( regionName , encodedRegionName ) ; } 
6551	public static XmlUnsignedInt parse ( java . net . URL u , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( XmlUnsignedInt ) XmlBeans . getContextTypeLoader ( ) . parse ( u , type , options ) ; } 
6552	public static synchronized XMLReader newXMLReader ( ) throws SAXException , ParserConfigurationException { XMLReader xmlReader = saxFactory . newSAXParser ( ) . getXMLReader ( ) ; xmlReader . setEntityResolver ( IGNORING _ ENTITY _ RESOLVER ) ; trySetSAXFeature ( xmlReader , XMLConstants . FEATURE _ SECURE _ PROCESSING ) ; trySetXercesSecurityManager ( xmlReader ) ; return xmlReader ; } 
6553	static ArrayOfDoublesUnion heapifyUnion ( final Memory mem , final long seed ) { final SerializerDeserializer . SketchType type = SerializerDeserializer . getSketchType ( mem ) ; compatibility with version _NUM . _NUM . _NUM and lower if ( type = = SerializerDeserializer . SketchType . ArrayOfDoublesQuickSelectSketch ) { final ArrayOfDoublesQuickSelectSketch sketch = new HeapArrayOfDoublesQuickSelectSketch ( mem , seed ) ; return new HeapArrayOfDoublesUnion ( sketch ) ; } final byte version = mem . getByte ( SERIAL _ VERSION _ BYTE ) ; if ( version ! = serialVersionUID ) { throw new SketchesArgumentException ( _STR + version ) ; } SerializerDeserializer . validateFamily ( mem . getByte ( FAMILY _ ID _ BYTE ) , mem . getByte ( PREAMBLE _ LONGS _ BYTE ) ) ; SerializerDeserializer . validateType ( mem . getByte ( SKETCH _ TYPE _ BYTE ) , SerializerDeserializer . SketchType . ArrayOfDoublesUnion ) ; final long unionTheta = mem . getLong ( THETA _ LONG ) ; final Memory sketchMem = mem . region ( PREAMBLE _ SIZE _ BYTES , mem . getCapacity ( ) - PREAMBLE _ SIZE _ BYTES ) ; final ArrayOfDoublesQuickSelectSketch sketch = new HeapArrayOfDoublesQuickSelectSketch ( sketchMem , seed ) ; final ArrayOfDoublesUnion union = new HeapArrayOfDoublesUnion ( sketch ) ; union . theta _ = unionTheta ; return union ; } 
6554	public int getFlattrQueueSize ( ) { int res = _NUM ; Cursor c = db . rawQuery ( String . format ( _STR ) ; } return res ; } 
6555	public CMap parse ( InputStream input ) throws IOException { PushbackInputStream cmapStream = new PushbackInputStream ( input ) ; CMap result = new CMap ( ) ; Object previousToken = null ; Object token = null ; while ( ( token = parseNextToken ( cmapStream ) ) ! = null ) { if ( token instanceof Operator ) { Operator op = ( Operator ) token ; if ( op . op . equals ( BEGIN _ CODESPACE _ RANGE ) ) { Number cosCount = ( Number ) previousToken ; for ( int j = _NUM ; j < cosCount . intValue ( ) ; j + + ) { byte [ ] startRange = ( byte [ ] ) parseNextToken ( cmapStream ) ; byte [ ] endRange = ( byte [ ] ) parseNextToken ( cmapStream ) ; CodespaceRange range = new CodespaceRange ( ) ; range . setStart ( startRange ) ; range . setEnd ( endRange ) ; result . addCodespaceRange ( range ) ; } } else if ( op . op . equals ( BEGIN _ BASE _ FONT _ CHAR ) ) { Number cosCount = ( Number ) previousToken ; for ( int j = _NUM ; j < cosCount . intValue ( ) ; j + + ) { byte [ ] inputCode = ( byte [ ] ) parseNextToken ( cmapStream ) ; Object nextToken = parseNextToken ( cmapStream ) ; if ( nextToken instanceof byte [ ] ) { byte [ ] bytes = ( byte [ ] ) nextToken ; String value = createStringFromBytes ( bytes ) ; result . addMapping ( inputCode , value ) ; } else if ( nextToken instanceof LiteralName ) { result . addMapping ( inputCode , ( ( LiteralName ) nextToken ) . name ) ; } else { throw new IOException ( MessageLocalization . getComposedMessage ( _STR , nextToken ) ) ; } } } else if ( op . op . equals ( BEGIN _ BASE _ FONT _ RANGE ) ) { Number cosCount = ( Number ) previousToken ; for ( int j = _NUM ; j < cosCount . intValue ( ) ; j + + ) { byte [ ] startCode = ( byte [ ] ) parseNextToken ( cmapStream ) ; byte [ ] endCode = ( byte [ ] ) parseNextToken ( cmapStream ) ; Object nextToken = parseNextToken ( cmapStream ) ; List array = null ; byte [ ] tokenBytes = null ; if ( nextToken instanceof List ) { array = ( List ) nextToken ; tokenBytes = ( byte [ ] ) array . get ( _NUM ) ; } else { tokenBytes = ( byte [ ] ) nextToken ; } String value = null ; int arrayIndex = _NUM ; boolean done = false ; while ( ! done ) { if ( compare ( startCode , endCode ) > = _NUM ) { done = true ; } value = createStringFromBytes ( tokenBytes ) ; result . addMapping ( startCode , value ) ; increment ( startCode ) ; if ( array = = null ) { increment ( tokenBytes ) ; } else { arrayIndex + + ; if ( arrayIndex < array . size ( ) ) { tokenBytes = ( byte [ ] ) array . get ( arrayIndex ) ; } } } } } } previousToken = token ; } return result ; } 
6556	public void removeEnforcement ( ) { safeGetDocumentProtection ( ) . setEnforcement ( STOnOff . X _ _NUM ) ; } 
6557	public CMSEnvelopedData generate ( CMSTypedData content , OutputEncryptor contentEncryptor ) throws CMSException { return doGenerate ( content , contentEncryptor ) ; } 
6558	public JSONObject append ( String key , Object value ) throws JSONException { testValidity ( value ) ; Object o = opt ( key ) ; if ( o = = null ) { put ( key , new JSONArray ( ) . put ( value ) ) ; } else if ( o instanceof JSONArray ) { put ( key , ( ( JSONArray ) o ) . put ( value ) ) ; } else { throw new JSONException ( _STR ) ; } return this ; } 
6559	void apply ( final QueryContext qc ) throws QueryException { execute database updates auc . execute ( true ) ; auc = null ; execute database operations Collections . sort ( dbUpdates ) ; final int sz = dbUpdates . size ( ) ; for ( int i = _NUM ; i < sz ; i + + ) { dbUpdates . get ( i ) . apply ( ) ; dbUpdates . set ( i , null ) ; } execute fn : put operations for ( final Put put : puts . values ( ) ) put . apply ( ) ; try { Optimize . finish ( data ) ; } catch ( final IOException ex ) { throw UPDBOPTERR _ X . get ( null , ex ) ; } final String original = data . meta . original ; if ( ! original . isEmpty ( ) & & data . inMemory ( ) ) { if ( writeback ) { try { Export . export ( data , original , qc . context . options , null ) ; } catch ( final IOException ex ) { throw UPDBOPTERR _ X . get ( null , ex ) ; } } else { FnTrace . trace ( Token . token ( original + _STR ) , null , qc ) ; } } } 
6560	public Port createLocalInputPort ( String id , String name ) { id = requireNonNull ( id ) . intern ( ) ; name = requireNonNull ( name ) . intern ( ) ; verifyPortIdDoesNotExist ( id ) ; return new LocalPort ( id , name , null , ConnectableType . INPUT _ PORT , processScheduler ) ; } 
6561	public void allocateNew ( int valueCount ) { final int size = getSizeFromCount ( valueCount ) ; allocateBytes ( size ) ; } 
6562	public void zap ( final int index ) { ensureArrayExists ( ) ; if ( ( index > = _NUM ) & & ( index < _ array . length ) ) { _ array [ index ] = null ; } } 
6563	public SimpleStatement setRoutingKey ( ByteBuffer . . . routingKeyComponents ) { this . routingKey = compose ( routingKeyComponents ) ; return this ; } 
6564	public void stop ( ) { tell the listenee ( upstream bean ) to stop if ( m _ listenee instanceof BeanCommon ) { ( ( BeanCommon ) m _ listenee ) . stop ( ) ; } stop the io thread if ( m _ ioThread ! = null ) { m _ ioThread . interrupt ( ) ; m _ ioThread . stop ( ) ; m _ ioThread = null ; m _ visual . setStatic ( ) ; } } 
6565	public void removeGameView ( EntityView view , RenderLayer layer ) { getRenderGroup ( layer ) . getChildren ( ) . remove ( view ) ; } 
6566	public static XmlGMonthDay parse ( javax . xml . stream . XMLStreamReader xsr ) throws org . apache . xmlbeans . XmlException { return ( XmlGMonthDay ) XmlBeans . getContextTypeLoader ( ) . parse ( xsr , type , null ) ; } 
6567	public void clearGalleries ( ) { List < String > selectedGalleries = m _ searchObject . getGalleries ( ) ; m _ handler . onClearGalleries ( selectedGalleries ) ; m _ searchObject . clearGalleries ( ) ; updateResultsTab ( false ) ; ValueChangeEvent . fire ( this , m _ searchObject ) ; } 
6568	public static DecisionForest load ( Configuration conf , Path forestPath ) throws IOException { FileSystem fs = forestPath . getFileSystem ( conf ) ; Path [ ] files ; if ( fs . getFileStatus ( forestPath ) . isDir ( ) ) { files = DFUtils . listOutputFiles ( fs , forestPath ) ; } else { files = new Path [ ] { forestPath } ; } DecisionForest forest = null ; for ( Path path : files ) { try ( FSDataInputStream dataInput = new FSDataInputStream ( fs . open ( path ) ) ) { if ( forest = = null ) { forest = read ( dataInput ) ; } else { forest . readFields ( dataInput ) ; } } } return forest ; } 
6569	public synchronized boolean isMethodSupported ( String methodName , Class < ? > . . . parameterTypes ) throws IOException { if ( ! supportServerMethodCheck ) { return true ; } Method method ; try { method = protocol . getDeclaredMethod ( methodName , parameterTypes ) ; } catch ( SecurityException e ) { throw new IOException ( e ) ; } catch ( NoSuchMethodException e ) { throw new IOException ( e ) ; } if ( ! serverMethodsFetched ) { fetchServerMethods ( method ) ; } if ( serverMethods = = null ) { client & server have the same protocol return true ; } return serverMethods . contains ( Integer . valueOf ( ProtocolSignature . getFingerprint ( method ) ) ) ; } 
6570	public static int oneHex ( StringBuilder out , int x , int i ) { int y = BitsInt . unpack ( x , _NUM * i , _NUM * i + _NUM ) ; char charHex = Chars . hexDigitsUC [ y ] ; out . append ( charHex ) ; return BitsInt . clear ( x , _NUM * i , _NUM * i + _NUM ) ; } 
6571	public void setAcceptMessagesWhileStopping ( boolean acceptMessagesWhileStopping ) { getConfiguration ( ) . setAcceptMessagesWhileStopping ( acceptMessagesWhileStopping ) ; } 
6572	public void testSocketLeak ( ) throws IOException { only run on Linux Assume . assumeTrue ( FD _ DIR . exists ( ) ) ; long startFds = countOpenFileDescriptors ( ) ; for ( int i = _NUM ; i < _NUM _NUM ; i + + ) { Server server = new TestServer ( _NUM , true ) ; server . start ( ) ; server . stop ( ) ; } long endFds = countOpenFileDescriptors ( ) ; assertTrue ( _STR , endFds - startFds < _NUM _NUM ) ; } 
6573	private synchronized void removeLease ( Lease lease , long inodeId ) { leasesById . remove ( inodeId ) ; if ( ! lease . removeFile ( inodeId ) ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( _STR ) ; } } } 
6574	private void write ( ConsistencyLevel cl , int retryCount ) { System . out . printf ( _STR + e ) ; if ( e instanceof UnavailableException ) { With an UnavailableException , we know that the write wasn ' t even attempted . Downgrade to the number of replicas reported alive and retry . int aliveReplicas = ( ( UnavailableException ) e ) . getAliveReplicas ( ) ; ConsistencyLevel downgraded = downgrade ( cl , aliveReplicas , e ) ; write ( downgraded , retryCount + _NUM ) ; } else if ( e instanceof WriteTimeoutException ) { WriteType writeType = ( ( WriteTimeoutException ) e ) . getWriteType ( ) ; int acknowledgements = ( ( WriteTimeoutException ) e ) . getReceivedAcknowledgements ( ) ; switch ( writeType ) { case SIMPLE : case BATCH : a retry would ever succeed . if ( acknowledgements = = _NUM ) { throw e ; } break ; case UNLOGGED _ BATCH : For unlogged batches , the write might have been persisted only partially , so we can ' t simply ignore the exception : instead , we need to retry with consistency level equal to the number of acknowledged writes . ConsistencyLevel downgraded = downgrade ( cl , acknowledgements , e ) ; write ( downgraded , retryCount + _NUM ) ; break ; case BATCH _ LOG : Rare edge case : the peers that were chosen by the coordinator to receive the distributed batch log failed to respond . Simply retry with same consistency level . write ( cl , retryCount + _NUM ) ; break ; default : Other write types are uncommon and should not be retried . throw e ; } } else { Unexpected error : just retry with same consistency level and hope to talk to a healthier coordinator . write ( cl , retryCount + _NUM ) ; } } } 
6575	public MimeMultipart sign ( MimeBodyPart message , SignerInfoGenerator signerInfoGenerator ) throws SMIMEException { SMIMESignedGenerator gen = new SMIMESignedGenerator ( ) ; if ( signerInfoGenerator . hasAssociatedCertificate ( ) ) { List certList = new ArrayList ( ) ; certList . add ( signerInfoGenerator . getAssociatedCertificate ( ) ) ; gen . addCertificates ( new CollectionStore ( certList ) ) ; } gen . addSignerInfoGenerator ( signerInfoGenerator ) ; return gen . generate ( message ) ; } 
6576	public void forget ( int netId , ActionListener listener ) { if ( netId < _NUM ) throw new IllegalArgumentException ( _STR ) ; getChannel ( ) . sendMessage ( FORGET _ NETWORK , netId , putListener ( listener ) ) ; } 
6577	public List < Object > getFileDecodeParams ( ) throws IOException { List < Object > retval = null ; COSBase dp = stream . getDictionaryObject ( COSName . F _ DECODE _ PARMS ) ; if ( dp instanceof COSDictionary ) { Map < ? , ? > map = COSDictionaryMap . convertBasicTypesToMap ( ( COSDictionary ) dp ) ; retval = new COSArrayList < Object > ( map , dp , stream , COSName . F _ DECODE _ PARMS ) ; } else if ( dp instanceof COSArray ) { COSArray array = ( COSArray ) dp ; List < Object > actuals = new ArrayList < > ( ) ; for ( int i = _NUM ; i < array . size ( ) ; i + + ) { actuals . add ( COSDictionaryMap . convertBasicTypesToMap ( ( COSDictionary ) array . getObject ( i ) ) ) ; } retval = new COSArrayList < > ( actuals , array ) ; } return retval ; } 
6578	private List < HRegionLocation > locateRegionsInRange ( byte [ ] startKey , byte [ ] endKey , boolean reload ) throws IOException { final boolean endKeyIsEndOfTable = Bytes . equals ( endKey , HConstants . EMPTY _ END _ ROW ) ; if ( ( Bytes . compareTo ( startKey , endKey ) > _NUM ) & & ! endKeyIsEndOfTable ) { throw new IllegalArgumentException ( _STR + ( regionLocation = = null ? null : regionLocation . getRegionInfo ( ) ) ) ; } currentKey = regionLocation . getRegionInfo ( ) . getEndKey ( ) ; } while ( ! Bytes . equals ( currentKey , HConstants . EMPTY _ END _ ROW ) & & ( endKeyIsEndOfTable | | Bytes . compareTo ( currentKey , endKey ) < _NUM ) ) ; return regionList ; } 
6579	public boolean canConsume ( int type , String currentExpected , String . . . expectedForNextTokens ) throws IllegalStateException { if ( completed ) return false ; ListIterator < Token > iter = tokens . listIterator ( tokenIterator . previousIndex ( ) ) ; if ( ! iter . hasNext ( ) ) return false ; Token token = iter . next ( ) ; if ( currentExpected ! = ANY _ VALUE & & ! token . matches ( type , currentExpected ) ) return false ; for ( String nextExpected : expectedForNextTokens ) { if ( ! iter . hasNext ( ) ) return false ; token = iter . next ( ) ; if ( nextExpected = = ANY _ VALUE ) continue ; if ( ! token . matches ( type , nextExpected ) ) return false ; } this . tokenIterator = iter ; this . currentToken = tokenIterator . hasNext ( ) ? tokenIterator . next ( ) : null ; this . completed = this . currentToken = = null ; return true ; } 
6580	public boolean render ( Graphics _NUM D g _NUM , Rectangle _NUM D dataArea , int index , PlotRenderingInfo info , CrosshairState crosshairState ) { boolean foundData = false ; XYDataset dataset = getDataset ( index ) ; if ( ! DatasetUtilities . isEmptyOrNull ( dataset ) ) { foundData = true ; ValueAxis xAxis = getDomainAxisForDataset ( index ) ; ValueAxis yAxis = getRangeAxisForDataset ( index ) ; if ( xAxis = = null | | yAxis = = null ) { can ' t render anything without axes return foundData ; } XYItemRenderer renderer = getRenderer ( index ) ; if ( renderer = = null ) { renderer = getRenderer ( ) ; if ( renderer = = null ) { no default renderer available return foundData ; } } XYItemRendererState state = renderer . initialise ( g _NUM , dataArea , this , dataset , info ) ; int passCount = renderer . getPassCount ( ) ; SeriesRenderingOrder seriesOrder = getSeriesRenderingOrder ( ) ; if ( seriesOrder = = SeriesRenderingOrder . REVERSE ) { render series in reverse order for ( int pass = _NUM ; pass < passCount ; pass + + ) { int seriesCount = dataset . getSeriesCount ( ) ; for ( int series = seriesCount - _NUM ; series > = _NUM ; series - - ) { int firstItem = _NUM ; int lastItem = dataset . getItemCount ( series ) - _NUM ; if ( lastItem = = - _NUM ) { continue ; } if ( state . getProcessVisibleItemsOnly ( ) ) { int [ ] itemBounds = RendererUtilities . findLiveItems ( dataset , series , xAxis . getLowerBound ( ) , xAxis . getUpperBound ( ) ) ; firstItem = Math . max ( itemBounds [ _NUM ] - _NUM , _NUM ) ; lastItem = Math . min ( itemBounds [ _NUM ] + _NUM , lastItem ) ; } state . startSeriesPass ( dataset , series , firstItem , lastItem , pass , passCount ) ; for ( int item = firstItem ; item < = lastItem ; item + + ) { renderer . drawItem ( g _NUM , state , dataArea , info , this , xAxis , yAxis , dataset , series , item , crosshairState , pass ) ; } state . endSeriesPass ( dataset , series , firstItem , lastItem , pass , passCount ) ; } } } else { render series in forward order for ( int pass = _NUM ; pass < passCount ; pass + + ) { int seriesCount = dataset . getSeriesCount ( ) ; for ( int series = _NUM ; series < seriesCount ; series + + ) { int firstItem = _NUM ; int lastItem = dataset . getItemCount ( series ) - _NUM ; if ( state . getProcessVisibleItemsOnly ( ) ) { int [ ] itemBounds = RendererUtilities . findLiveItems ( dataset , series , xAxis . getLowerBound ( ) , xAxis . getUpperBound ( ) ) ; firstItem = Math . max ( itemBounds [ _NUM ] - _NUM , _NUM ) ; lastItem = Math . min ( itemBounds [ _NUM ] + _NUM , lastItem ) ; } state . startSeriesPass ( dataset , series , firstItem , lastItem , pass , passCount ) ; for ( int item = firstItem ; item < = lastItem ; item + + ) { renderer . drawItem ( g _NUM , state , dataArea , info , this , xAxis , yAxis , dataset , series , item , crosshairState , pass ) ; } state . endSeriesPass ( dataset , series , firstItem , lastItem , pass , passCount ) ; } } } } return foundData ; } 
6581	public void testVanityDriver ( ) throws SQLException { Properties info = new Properties ( ) ; Connection connection = DriverManager . getConnection ( _STR , info ) ; connection . close ( ) ; } 
6582	public void setQuadrantPaint ( int index , Paint paint ) { if ( index < _NUM | | index > _NUM ) { throw new IllegalArgumentException ( _STR ) ; } this . quadrantPaint [ index ] = paint ; fireChangeEvent ( ) ; } 
6583	protected void filterError ( String message , Throwable t ) { log . error ( _STR ) ; } } 
6584	public static int [ ] mergeSparseArrays ( Iterable < int [ ] > source ) { final IntIntHashMap m = new IntIntHashMap ( ) ; for ( int [ ] list : source ) { final int max = list . length ; for ( int i = _NUM ; i < max ; i + = _NUM ) { final int v = list [ i + _NUM ] ; m . putOrAdd ( list [ i ] , v , v ) ; } } return hashToKeyValuePairs ( m ) ; } 
6585	char getChar ( String key , char defaultValue ) { unparcel ( ) ; Object o = mMap . get ( key ) ; if ( o = = null ) { return defaultValue ; } try { return ( Character ) o ; } catch ( ClassCastException e ) { typeWarning ( key , o , _STR , defaultValue , e ) ; return defaultValue ; } } 
6586	public org . apache . phoenix . coprocessor . generated . PTableProtos . EncodedCQCounter . Builder getEncodedCQCountersBuilder ( int index ) { return getEncodedCQCountersFieldBuilder ( ) . getBuilder ( index ) ; } 
6587	public final MainModule parseMain ( ) throws QueryException { init ( ) ; try { versionDecl ( ) ; final int p = pos ; if ( wsConsumeWs ( MODULE , NAMESPACE , null ) ) throw error ( MAINMOD ) ; pos = p ; prolog _NUM ( ) ; importModules ( ) ; prolog _NUM ( ) ; localVars . pushContext ( null ) ; final Expr ex = expr ( ) ; if ( ex = = null ) throw alter = = null ? error ( EXPREMPTY ) : error ( ) ; final VarScope vs = localVars . popContext ( ) ; final MainModule mm = new MainModule ( vs , ex , null , doc , null , funcs , vars , imports ) ; finish ( mm ) ; check ( mm ) ; return mm ; } catch ( final QueryException ex ) { mark ( ) ; ex . pos ( this ) ; throw ex ; } } 
6588	private CompletableFuture < ? > applyInternal ( final Mutation mutation , final boolean writeCommitLog , boolean updateIndexes , boolean isDroppable , boolean isDeferrable , CompletableFuture < ? > future ) { if ( TEST _ FAIL _ WRITES & & metadata . name . equals ( TEST _ FAIL _ WRITES _ KS ) ) throw new RuntimeException ( _STR , upd . metadata ( ) . name ) ; UpdateTransaction indexTransaction = updateIndexes ? cfs . indexManager . newUpdateTransaction ( upd , opGroup , nowInSec ) : UpdateTransaction . NO _ OP ; cfs . apply ( upd , indexTransaction , opGroup , commitLogPosition ) ; if ( requiresViewUpdate ) baseComplete . set ( System . currentTimeMillis ( ) ) ; } if ( future ! = null ) { future . complete ( null ) ; } return future ; } finally { if ( locks ! = null ) { for ( Lock lock : locks ) if ( lock ! = null ) lock . unlock ( ) ; } } } 
6589	public static XmlInt parse ( org . w _NUM c . dom . Node node , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException { return ( XmlInt ) XmlBeans . getContextTypeLoader ( ) . parse ( node , type , options ) ; } 
6590	public void close ( ) throws IOException { if ( mClosed ) { return ; } try { This aborts the block if the block is not fully read . updateBlockWriter ( mBlockMeta . getBlockSize ( ) ) ; if ( mUnderFileSystemInputStream ! = null ) { mUfsInstreamManager . release ( mUnderFileSystemInputStream ) ; mUnderFileSystemInputStream = null ; } if ( mBlockWriter ! = null ) { mBlockWriter . close ( ) ; } mUfsResource . close ( ) ; } finally { mClosed = true ; } } 
6591	private void paste ( final String string ) { final int pos = editor . pos ( ) ; if ( editor . selected ( ) ) editor . delete ( ) ; editor . add ( string ) ; finish ( pos ) ; } 
6592	public DescribeAddressesResult withAddresses ( Address . . . addresses ) { if ( getAddresses ( ) = = null ) setAddresses ( new java . util . ArrayList < Address > ( addresses . length ) ) ; for ( Address value : addresses ) { getAddresses ( ) . add ( value ) ; } return this ; } 
6593	public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( _STR ) ; return sb . toString ( ) ; } 
6594	public List < byte [ ] > getOID ( ) { COSBase base = this . dictionary . getDictionaryObject ( COSName . OID ) ; if ( base instanceof COSArray ) { COSArray array = ( COSArray ) base ; return getListOfByteArraysFromCOSArray ( array ) ; } return null ; } 
6595	public synchronized void addLineageFromJournal ( LineageEntry entry ) { Lineage lineage = Lineage . fromJournalEntry ( entry ) ; createLineageInternal ( lineage ) ; } 
6596	public void start ( ) { initialize ( ) ; servers . forEach ( Server : : start ) ; } 
6597	public void testContinuousTask ( ) throws Exception { Create a TaskState TaskState taskState = getStreamingTaskState ( ) ; ArrayList < Object > recordCollector = new ArrayList < > ( _NUM _NUM _NUM ) ; _NUM second per record long perRecordExtractLatencyMillis = _NUM _NUM _NUM _NUM ; ContinuousExtractor continuousExtractor = new ContinuousExtractor ( perRecordExtractLatencyMillis ) ; TaskContext mockTaskContext = getMockTaskContext ( recordCollector , continuousExtractor ) ; Create a mock TaskStateTracker TaskStateTracker mockTaskStateTracker = mock ( TaskStateTracker . class ) ; Create a TaskExecutor - a real TaskExecutor must be created so a Fork is run in a separate thread TaskExecutor taskExecutor = new TaskExecutor ( new Properties ( ) ) ; Create the Task Task task = new Task ( mockTaskContext , mockTaskStateTracker , taskExecutor , Optional . < CountDownLatch > absent ( ) ) ; ScheduledExecutorService taskRunner = new ScheduledThreadPoolExecutor ( _NUM , ExecutorsUtils . newThreadFactory ( Optional . of ( log ) ) ) ; taskRunner . execute ( task ) ; Let the task run for _NUM _NUM seconds int sleepIterations = _NUM _NUM ; int currentIteration = _NUM ; while ( currentIteration < sleepIterations ) { Thread . sleep ( _NUM _NUM _NUM _NUM ) ; currentIteration + + ; Map < String , CheckpointableWatermark > externalWatermarkStorage = mockTaskContext . getWatermarkStorage ( ) . getCommittedWatermarks ( CheckpointableWatermark . class , ImmutableList . of ( _STR ) ) ) ) ; task . commit ( ) ; Shutdown the executor taskRunner . shutdown ( ) ; taskRunner . awaitTermination ( _NUM _NUM _NUM , TimeUnit . MILLISECONDS ) ; } 
6598	public SeqType union ( final SeqType st ) { ignore general type of empty sequence final Type tp = type . eq ( st . type ) | | st . zero ( ) ? type : zero ( ) ? st . type : type . union ( st . type ) ; final Occ oc = occ . union ( st . occ ) ; return get ( tp , oc ) ; } 
6599	private < T > void alternatives ( @ Observes @ WithAnnotations ( Alternative . class ) ProcessAnnotatedType < T > pat ) { AnnotatedType < T > type = pat . getAnnotatedType ( ) ; if ( ! Arrays . asList ( beans . alternatives ( ) ) . contains ( type . getJavaClass ( ) ) ) { Only select globally the alternatives that are declared with @ Beans return ; } Set < AnnotatedMethod < ? super T > > methods = new HashSet < > ( ) ; for ( AnnotatedMethod < ? super T > method : type . getMethods ( ) ) { if ( method . isAnnotationPresent ( Alternative . class ) & & ! method . isAnnotationPresent ( Priority . class ) ) { methods . add ( new AnnotatedMethodDecorator < > ( method , PriorityLiteral . of ( APPLICATION ) ) ) ; } } if ( type . isAnnotationPresent ( Alternative . class ) & & ! type . isAnnotationPresent ( Priority . class ) ) { pat . setAnnotatedType ( new AnnotatedTypeDecorator < > ( type , PriorityLiteral . of ( APPLICATION ) , methods ) ) ; } else if ( ! methods . isEmpty ( ) ) { pat . setAnnotatedType ( new AnnotatedTypeDecorator < > ( type , methods ) ) ; } } 
6600	public Date parseDateTime ( String str ) throws ParseException { TimeZone timeZone = uss . getUserSession ( ) . getTimeZone ( ) ; Datatype < Date > datatype = Datatypes . getNN ( Date . class ) ; if ( datatype instanceof TimeZoneAwareDatatype ) { return ( Date ) ( ( TimeZoneAwareDatatype ) datatype ) . parse ( str , uss . getLocale ( ) , timeZone ) ; } return datatype . parse ( str , uss . getLocale ( ) ) ; } 
6601	public void getDocumentEntry ( ) throws Exception { for ( NPOIFSFileSystem fs : get _NUM _NUM _NUM and _NUM kFileAndInput ( ) ) { DirectoryEntry root = fs . getRoot ( ) ; Entry si = root . getEntry ( _STR ) ; assertEquals ( true , si . isDocumentEntry ( ) ) ; doc = ( DocumentNode ) si ; assertContentsMatches ( null , doc ) ; inp = new NDocumentInputStream ( doc ) ; ps = PropertySetFactory . create ( inp ) ; DocumentSummaryInformation dinf = ( DocumentSummaryInformation ) ps ; assertEquals ( _NUM _NUM _NUM _NUM _NUM _NUM , dinf . getOSVersion ( ) ) ; fs . close ( ) ; } } 
6602	public int sendCommand ( String command , String args ) throws IOException { if ( _ controlOutput _ = = null ) { throw new IOException ( _STR ) ; } final String message = _ _ buildMessage ( command , args ) ; _ _ send ( message ) ; fireCommandSent ( command , message ) ; _ _ getReply ( ) ; return _ replyCode ; } 
6603	protected void rescaleImage ( int width , int height , int hint ) { Image master = getMasterImage ( ) ; if ( master ! = null ) { Map < RenderingHints . Key , Object > hints = new HashMap < RenderingHints . Key , Object > ( ) ; switch ( hint ) { default : case Image . SCALE _ AREA _ AVERAGING : case Image . SCALE _ SMOOTH : hints . put ( RenderingHints . KEY _ INTERPOLATION , RenderingHints . VALUE _ INTERPOLATION _ BICUBIC ) ; hints . put ( RenderingHints . KEY _ RENDERING , RenderingHints . VALUE _ RENDER _ QUALITY ) ; hints . put ( RenderingHints . KEY _ ANTIALIASING , RenderingHints . VALUE _ ANTIALIAS _ ON ) ; } bgImage = createAcceleratedImage ( width , height ) ; Graphics _NUM D g = bgImage . createGraphics ( ) ; g . addRenderingHints ( hints ) ; g . drawImage ( master , _NUM , _NUM , width , height , null ) ; g . dispose ( ) ; } else { bgImage = null ; } } 
6604	public boolean isVoiceInteractionRoot ( ) { try { return mVoiceInteractor ! = null & & ActivityManager . getService ( ) . isRootVoiceInteraction ( mToken ) ; } catch ( RemoteException e ) { } return false ; } 
6605	private void updateServiceModelInfo ( SoapMessage message ) throws Fault { AddressingProperties maps = ContextUtils . retrieveMAPs ( message , false , false , false ) ; AttributedURIType actionURI = null = = maps ? null : maps . getAction ( ) ; String action = null = = actionURI ? null : actionURI . getValue ( ) . trim ( ) ; LOG . fine ( _STR ) ; } } 
6606	public DescribeCustomerGatewaysRequest withFilters ( Filter . . . filters ) { if ( getFilters ( ) = = null ) setFilters ( new java . util . ArrayList < Filter > ( filters . length ) ) ; for ( Filter value : filters ) { getFilters ( ) . add ( value ) ; } return this ; } 
6607	public void loadData ( String data , String mimeType , String encoding ) { checkThread ( ) ; mProvider . loadData ( data , mimeType , encoding ) ; } 
6608	private void constructLopsCentralMoment ( ) { if ( _ op ! = OpOp _NUM . MOMENT ) throw new HopsException ( _STR + OpOp _NUM . MOMENT ) ; ExecType et = optFindExecType ( ) ; if ( et = = ExecType . MR ) { CombineBinary combine = CombineBinary . constructCombineLop ( OperationTypes . PreCentralMoment , getInput ( ) . get ( _NUM ) . constructLops ( ) , getInput ( ) . get ( _NUM ) . constructLops ( ) , DataType . MATRIX , getValueType ( ) ) ; combine . getOutputParameters ( ) . setDimensions ( getInput ( ) . get ( _NUM ) . getDim _NUM ( ) , getInput ( ) . get ( _NUM ) . getDim _NUM ( ) , getInput ( ) . get ( _NUM ) . getRowsInBlock ( ) , getInput ( ) . get ( _NUM ) . getColsInBlock ( ) , getInput ( ) . get ( _NUM ) . getNnz ( ) ) ; CentralMoment cm = new CentralMoment ( combine , getInput ( ) . get ( _NUM ) . constructLops ( ) , DataType . MATRIX , getValueType ( ) , et ) ; cm . getOutputParameters ( ) . setDimensions ( _NUM , _NUM , _NUM , _NUM , - _NUM ) ; setLineNumbers ( cm ) ; UnaryCP unary _NUM = new UnaryCP ( cm , HopsOpOp _NUM LopsUS . get ( OpOp _NUM . CAST _ AS _ SCALAR ) , getDataType ( ) , getValueType ( ) ) ; unary _NUM . getOutputParameters ( ) . setDimensions ( _NUM , _NUM , _NUM , _NUM , - _NUM ) ; setLineNumbers ( unary _NUM ) ; setLops ( unary _NUM ) ; } else CP / SPARK { CentralMoment cm = new CentralMoment ( getInput ( ) . get ( _NUM ) . constructLops ( ) , getInput ( ) . get ( _NUM ) . constructLops ( ) , getInput ( ) . get ( _NUM ) . constructLops ( ) , getDataType ( ) , getValueType ( ) , et ) ; cm . getOutputParameters ( ) . setDimensions ( _NUM , _NUM , _NUM , _NUM , - _NUM ) ; setLineNumbers ( cm ) ; setLops ( cm ) ; } } 
6609	public static ComponentName getDefaultRespondViaMessageApplication ( Context context , boolean updateIfNeeded ) { int userId = getIncomingUserId ( context ) ; final long token = Binder . clearCallingIdentity ( ) ; try { ComponentName component = null ; SmsApplicationData smsApplicationData = getApplication ( context , updateIfNeeded , userId ) ; if ( smsApplicationData ! = null ) { component = new ComponentName ( smsApplicationData . mPackageName , smsApplicationData . mRespondViaMessageClass ) ; } return component ; } finally { Binder . restoreCallingIdentity ( token ) ; } } 
6610	private FileStatus getFileStatus ( FTPFile ftpFile , Path parentPath ) { long length = ftpFile . getSize ( ) ; boolean isDir = ftpFile . isDirectory ( ) ; int blockReplication = _NUM ; Using default block size since there is no way in FTP client to know of block sizes on server . The assumption could be less than ideal . long blockSize = DEFAULT _ BLOCK _ SIZE ; long modTime = ftpFile . getTimestamp ( ) . getTimeInMillis ( ) ; long accessTime = _NUM ; FsPermission permission = getPermissions ( ftpFile ) ; String user = ftpFile . getUser ( ) ; String group = ftpFile . getGroup ( ) ; Path filePath = new Path ( parentPath , ftpFile . getName ( ) ) ; return new FileStatus ( length , isDir , blockReplication , blockSize , modTime , accessTime , permission , user , group , filePath . makeQualified ( this ) ) ; } 
6611	public void setNoDataMessageFont ( Font font ) { if ( font = = null ) { throw new IllegalArgumentException ( _STR ) ; } this . noDataMessageFont = font ; fireChangeEvent ( ) ; } 
6612	public TreeMap readMap ( ) throws IOException { int length = readMapHeader ( ) ; TreeMap result = new TreeMap ( ) ; for ( int i = _NUM ; i < length ; i + + ) { Object key = read ( ) ; Object value = read ( ) ; result . put ( key , value ) ; } return result ; } 
6613	public static INDArray randn ( int rows , int columns , org . nd _NUM j . linalg . api . rng . Random r ) { INDArray ret = Nd _NUM j . createUninitialized ( new int [ ] { rows , columns } , order ( ) ) ; logCreationIfNecessary ( ret ) ; return randn ( ret , r ) ; } 
6614	TODO : this can ' t be controlled and until it can be controlled we shouldn ' allow muggles to do this . So system access only . TODO : use scheduler here to get around people sending a reindex call _NUM _NUM times . @ POST @ Path ( _STR ) String callback ) throws Exception { addItemToServiceContext ( ui , itemName ) ; IndexResource indexResource = new IndexResource ( injector ) ; return indexResource . rebuildIndexesPost ( services . getApplicationId ( ) . toString ( ) , itemName . getPath ( ) , false , callback ) ; } 
6615	public void testAuditDenied ( ) throws Exception { final Path file = new Path ( fnames [ _NUM ] ) ; FileSystem userfs = DFSTestUtil . getFileSystemAs ( userGroupInfo , conf ) ; fs . setPermission ( file , new FsPermission ( ( short ) _NUM _NUM _NUM _NUM ) ) ; fs . setOwner ( file , _STR ) ; } verifyAuditLogs ( false ) ; } 
6616	public void testMkdir ( ) throws IOException { Configuration conf = new HdfsConfiguration ( ) ; MiniDFSCluster cluster = new MiniDFSCluster . Builder ( conf ) . numDataNodes ( _NUM ) . build ( ) ; DistributedFileSystem dfs = cluster . getFileSystem ( ) ; try { Create a dir in root dir , should succeed assertTrue ( dfs . mkdir ( new Path ( _STR , expectedException ! = null & & expectedException instanceof FileNotFoundException ) ; } finally { dfs . close ( ) ; cluster . shutdown ( ) ; } } 
6617	 @ SuppressWarnings ( _STR + testType ) ; this . scheduleRegularTests ( context ) ; } 
6618	private String getActualLangCode ( String langCode ) { if ( langCode = = null | | _STR . equals ( langCode ) ) { return defaultLangCode ; } if ( commonTokenMap . containsKey ( langCode ) ) { return langCode ; } tryToLoad ( langCode ) ; Set < String > set = commonTokenMap . get ( langCode ) ; if ( set = = null ) { return defaultLangCode ; } return langCode ; } 
6619	void cleanupLocked ( int userId ) { int recentsCount = size ( ) ; if ( recentsCount = = _NUM ) { or just any empty list . return ; } final IPackageManager pm = AppGlobals . getPackageManager ( ) ; for ( int i = recentsCount - _NUM ; i > = _NUM ; i - - ) { final TaskRecord task = get ( i ) ; if ( userId ! = UserHandle . USER _ ALL & & task . userId ! = userId ) { Only look at tasks for the user ID of interest . continue ; } if ( task . autoRemoveRecents & & task . getTopActivity ( ) = = null ) { This situation is broken , and we should just get rid of it now . remove ( i ) ; task . removedFromRecents ( ) ; Slog . w ( TAG , _STR + task ) ; task . isAvailable = true ; } } } } Verify the affiliate chain for each task . int i = _NUM ; recentsCount = size ( ) ; while ( i < recentsCount ) { i = processNextAffiliateChainLocked ( i ) ; } recent tasks are now in sorted , affiliated order . } 
6620	public int getStorageCacheSize ( ) { return cache . getCacheSize ( ) ; } 
6621	public void updateCell ( String sheetName , int rowIndex , int columnIndex , ValueEval value ) { ForkedEvaluationCell cell = _ sewb . getOrCreateUpdatableCell ( sheetName , rowIndex , columnIndex ) ; cell . setValue ( value ) ; _ evaluator . notifyUpdateCell ( cell ) ; } 
6622	public synchronized void addServant ( URL url , JettyHTTPHandler handler ) { if ( shouldCheckUrl ( handler . getBus ( ) ) ) { checkRegistedContext ( url ) ; } initializeContexts ( ) ; SecurityHandler securityHandler = null ; if ( server = = null ) { DefaultHandler defaultHandler = null ; create a new jetty server instance if there is no server there server = createServer ( ) ; addServerMBean ( ) ; if ( connector = = null ) { connector = createConnector ( getHost ( ) , getPort ( ) ) ; if ( LOG . isLoggable ( Level . FINER ) ) { logConnector ( ( ServerConnector ) connector ) ; } } server . addConnector ( connector ) ; setupThreadPool ( ) ; int numberOfHandlers = _NUM ; if ( handlers ! = null ) { numberOfHandlers + = handlers . size ( ) ; } Handler existingHandler = server . getHandler ( ) ; HandlerCollection handlerCollection = null ; boolean existingHandlerCollection = existingHandler instanceof HandlerCollection ; if ( existingHandlerCollection ) { handlerCollection = ( HandlerCollection ) existingHandler ; } if ( ! existingHandlerCollection & & ( existingHandler ! = null | | numberOfHandlers > _NUM ) ) { handlerCollection = new HandlerCollection ( ) ; if ( existingHandler ! = null ) { handlerCollection . addHandler ( existingHandler ) ; } server . setHandler ( handlerCollection ) ; } if ( handlers ! = null & & ! handlers . isEmpty ( ) ) { for ( Handler h : handlers ) { which should not be added at this point . if ( h instanceof DefaultHandler ) { defaultHandler = ( DefaultHandler ) h ; } else { if ( ( h instanceof SecurityHandler ) & & ( ( SecurityHandler ) h ) . getHandler ( ) = = null ) { if h is SecurityHandler ( such as ConstraintSecurityHandler ) then it need be on top of JettyHTTPHandler set JettyHTTPHandler as inner handler if inner handler is null ( ( SecurityHandler ) h ) . setHandler ( handler ) ; securityHandler = ( SecurityHandler ) h ; } else { handlerCollection . addHandler ( h ) ; } } } } if ( handlerCollection ! = null ) { handlerCollection . addHandler ( contexts ) ; if ( defaultHandler ! = null ) { handlerCollection . addHandler ( defaultHandler ) ; } } else { server . setHandler ( contexts ) ; } try { server . start ( ) ; } catch ( Exception e ) { LOG . log ( Level . SEVERE , _STR , new Object [ ] { ex . getMessage ( ) } ) ; } } registedPaths . add ( url . getPath ( ) ) ; + + servantCount ; } 
6623	public void fireActionEvent ( ActionEvent ev ) { if ( listeners = = null | | listeners . size ( ) = = _NUM ) { return ; } minor optimization for a common use case to avoid allocation costs boolean isEdt = Display . getInstance ( ) . isEdt ( ) ; if ( isEdt & & listeners . size ( ) = = _NUM ) { ActionListener a = ( ActionListener ) listeners . get ( _NUM ) ; a . actionPerformed ( ev ) ; return ; } ActionListener [ ] array ; synchronized ( this ) { array = new ActionListener [ listeners . size ( ) ] ; int alen = array . length ; for ( int iter = _NUM ; iter < alen ; iter + + ) { array [ iter ] = ( ActionListener ) listeners . get ( iter ) ; } } if we already are on the EDT just fire the event if ( isEdt ) { fireActionSync ( array , ev ) ; } else { actionListenerArray = true ; Runnable cl = new CallbackClass ( array , ev ) ; if ( blocking ) { Display . getInstance ( ) . callSeriallyAndWait ( cl ) ; } else { Display . getInstance ( ) . callSerially ( cl ) ; } } } 
6624	public void bug _NUM _NUM _NUM _NUM _NUM ( ) throws Exception { HSSFWorkbook wb = openSample ( _STR ) ; HSSFSheet s = wb . getSheetAt ( _NUM ) ; s . setRowBreak ( _NUM ) ; writeOutAndReadBack ( wb ) . close ( ) ; wb . close ( ) ; } 
6625	public void attachToRecyclerView ( @ Nullable RecyclerView recyclerView ) throws IllegalStateException { if ( mRecyclerView = = recyclerView ) { nothing to do return ; } if ( mRecyclerView ! = null ) { destroyCallbacks ( ) ; } mRecyclerView = recyclerView ; if ( mRecyclerView ! = null ) { setupCallbacks ( ) ; mGravityScroller = new Scroller ( mRecyclerView . getContext ( ) , new DecelerateInterpolator ( ) ) ; snapToTargetExistingView ( ) ; } } 
6626	protected int insertKey ( char val ) { int hash , index ; hash = HashFunctions . hash ( val ) & _NUM x _NUM fffffff ; index = hash % _ states . length ; byte state = _ states [ index ] ; consumeFreeSlot = false ; if ( state = = FREE ) { consumeFreeSlot = true ; insertKeyAt ( index , val ) ; empty , all done return index ; } if ( state = = FULL & & _ set [ index ] = = val ) { already stored return - index - _NUM ; } already FULL or REMOVED , must probe return insertKeyRehash ( val , index , hash , state ) ; } 
6627	protected void onInterrupted ( Exception e ) { onException ( e ) ; } 
6628	void dispatchSaveInstanceState ( Bundle container ) { if ( hasKey ( ) ) { mBaseMethodCalled = false ; Parcelable state = onSaveInstanceState ( ) ; if ( ! mBaseMethodCalled ) { throw new IllegalStateException ( _STR ) ; } if ( state ! = null ) { container . putParcelable ( mKey , state ) ; } } } 
6629	public static double widthUnits _NUM Millimetres ( short widthUnits ) { return ( ConvertImageUnits . widthUnits _NUM Pixel ( widthUnits ) / ConvertImageUnits . PIXELS _ PER _ MILLIMETRES ) ; } 
6630	public void insertDeleteCorrectness ( ) { for ( int i = _NUM , cnt = BASEID + _NUM , id = BASEID + _NUM ; i < ITERATIONS ; + + i ) { can ' t delete if all records have been deleted : if ( RANDOM . nextBoolean ( ) | | cnt = = _NUM ) insert ( RANDOM . nextInt ( + + cnt ) , id + + ) ; else delete ( RANDOM . nextInt ( cnt - - ) ) ; check ( ) ; } } 
6631	public void setClassifierName ( String newClassifierName ) throws Exception { try { setClassifier ( ( Classifier ) Class . forName ( newClassifierName ) . newInstance ( ) ) ; } catch ( Exception ex ) { throw new Exception ( _STR + newClassifierName ) ; } } 
6632	default Integer getInteger ( CharSequence fieldName ) { Value value = get ( fieldName ) ; return value ! = null & & value . isInteger ( ) ? value . asInteger ( ) : null ; } 
6633	public Response getUsedBytes ( ) { return RestUtils . call ( new RestUtils . RestCallable < Long > ( ) { @ Override public Long call ( ) throws Exception { return mBlockMaster . getUsedBytes ( ) ; } } ) ; } 
6634	public boolean connectChannelToSink ( BluetoothDevice device , BluetoothHealthAppConfiguration config , int channelType ) { final IBluetoothHealth service = mService ; if ( service ! = null & & isEnabled ( ) & & isValidDevice ( device ) & & config ! = null ) { try { return service . connectChannelToSink ( device , config , channelType ) ; } catch ( RemoteException e ) { Log . e ( TAG , e . toString ( ) ) ; } } else { Log . w ( TAG , _STR ) ; if ( DBG ) Log . d ( TAG , Log . getStackTraceString ( new Throwable ( ) ) ) ; } return false ; } 
6635	public AttributeStats attributeStats ( int index ) { AttributeStats result = new AttributeStats ( ) ; if ( attribute ( index ) . isNominal ( ) ) { result . nominalCounts = new int [ attribute ( index ) . numValues ( ) ] ; result . nominalWeights = new double [ attribute ( index ) . numValues ( ) ] ; } if ( attribute ( index ) . isNumeric ( ) ) { result . numericStats = new weka . experiment . Stats ( ) ; } result . totalCount = numInstances ( ) ; double [ ] attVals = attributeToDoubleArray ( index ) ; int [ ] sorted = Utils . sort ( attVals ) ; int currentCount = _NUM ; double currentWeight = _NUM ; double prev = Double . NaN ; for ( int j = _NUM ; j < numInstances ( ) ; j + + ) { Instance current = instance ( sorted [ j ] ) ; if ( current . isMissing ( index ) ) { result . missingCount = numInstances ( ) - j ; break ; } if ( current . value ( index ) = = prev ) { currentCount + + ; currentWeight + = current . weight ( ) ; } else { result . addDistinct ( prev , currentCount , currentWeight ) ; currentCount = _NUM ; currentWeight = current . weight ( ) ; prev = current . value ( index ) ; } } result . addDistinct ( prev , currentCount , currentWeight ) ; So we don ' t count _STR as a value result . distinctCount - - ; return result ; } 
6636	 @ SuppressWarnings ( _STR , request , error ) ; if ( error instanceof ConnectException | | error instanceof TimeoutException | | error instanceof ClosedChannelException ) { if ( count < selector . members ( ) . size ( ) + _NUM ) { retryRequest ( error , request , sender , count + _NUM , selectionId , future ) ; } else { future . completeExceptionally ( error ) ; } } else { future . completeExceptionally ( error ) ; } } } 
6637	protected final int nextIndex ( ) { if ( _ expectedSize ! = _ hash . size ( ) ) { throw new ConcurrentModificationException ( ) ; } Object [ ] set = TObjectDoubleCustomHashMap . this . _ set ; int i = _ index ; while ( i - - > _NUM & & ( set [ i ] = = TCustomObjectHash . FREE | | set [ i ] = = TCustomObjectHash . REMOVED ) ) { ; } return i ; } 
6638	public static boolean isTemporaryFileName ( String path ) { return ( path ! = null ) & & getName ( path ) . startsWith ( TEMP _ FILE _ PREFIX ) ; } 
6639	public static Method findMethod ( Class c , String name , Object . . . params ) { Class [ ] paramTypes = getParamTypes ( params ) ; Method method = null ; try { method = c . getDeclaredMethod ( name , paramTypes ) ; } catch ( NoSuchMethodException e ) { try { method = c . getMethod ( name , paramTypes ) ; } catch ( NoSuchMethodException e _NUM ) { } } if ( method ! = null ) method . setAccessible ( true ) ; return method ; } 
6640	protected static Boolean getBooleanValue ( Map < ? , ? > map , String key , Boolean defaultValue ) { String value = getStringValue ( map , key ) ; return ( StringUtils . isEmpty ( value ) ) ? defaultValue : Boolean . valueOf ( value ) ; } 
6641	public void run ( ) { Map < TransmittableThreadLocal < ? > , Object > copied = copiedRef . get ( ) ; if ( copied = = null | | releaseTtlValueReferenceAfterRun & & ! copiedRef . compareAndSet ( copied , null ) ) { throw new IllegalStateException ( _STR ) ; } Map < TransmittableThreadLocal < ? > , Object > backup = TransmittableThreadLocal . backupAndSetToCopied ( copied ) ; try { timerTask . run ( ) ; } finally { TransmittableThreadLocal . restoreBackup ( backup ) ; } } 
6642	public void disconnect ( CometdProducerConsumer prodcon ) throws Exception { CometdEndpoint endpoint = prodcon . getEndpoint ( ) ; String connectorKey = endpoint . getProtocol ( ) + _STR + endpoint . getPort ( ) ; synchronized ( connectors ) { ConnectorRef connectorRef = connectors . get ( connectorKey ) ; if ( connectorRef ! = null ) { if ( connectorRef . decrement ( ) = = _NUM ) { connectorRef . server . removeConnector ( connectorRef . connector ) ; connectorRef . connector . stop ( ) ; connectorRef . server . stop ( ) ; connectors . remove ( connectorKey ) ; } } } } 
6643	public void clear ( ) { final int size = getSize ( ) ; this . data . clear ( ) ; final ListDataEvent evt = new ListDataEvent ( this , ListDataEvent . INTERVAL _ REMOVED , _NUM , size - _NUM ) ; fireListDataEvent ( evt ) ; } 
6644	protected final double [ ] getNumberArray ( ValueEval [ ] operands ) throws EvaluationException { if ( operands . length > getMaxNumOperands ( ) ) { throw EvaluationException . invalidValue ( ) ; } DoubleList retval = new DoubleList ( ) ; for ( int i = _NUM , iSize = operands . length ; i < iSize ; i + + ) { collectValues ( operands [ i ] , retval ) ; } return retval . toArray ( ) ; } 
6645	public boolean isSet ( _ Fields field ) { if ( field = = null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case UFS _ LENGTH : return isSetUfsLength ( ) ; case COMMON _ OPTIONS : return isSetCommonOptions ( ) ; } throw new IllegalStateException ( ) ; } 
6646	protected void addSpacing ( float extraspace , float oldleading , Font f ) { if ( extraspace = = _NUM ) return ; if ( pageEmpty ) return ; if ( currentHeight + line . height ( ) + leading > indentTop ( ) - indentBottom ( ) ) return ; leading = extraspace ; carriageReturn ( ) ; if ( f . isUnderlined ( ) | | f . isStrikethru ( ) ) { f = new Font ( f ) ; int style = f . getStyle ( ) ; style & = ~ Font . UNDERLINE ; style & = ~ Font . STRIKETHRU ; f . setStyle ( style ) ; } Chunk space = new Chunk ( _STR , f ) ; space . process ( this ) ; carriageReturn ( ) ; leading = oldleading ; } 
6647	final boolean acquireQueued ( final Node node , long arg ) { boolean failed = true ; try { boolean interrupted = false ; for ( ; ; ) { final Node p = node . predecessor ( ) ; if ( p = = head & & tryAcquire ( arg ) ) { setHead ( node ) ; help GC p . next = null ; failed = false ; return interrupted ; } if ( shouldParkAfterFailedAcquire ( p , node ) & & parkAndCheckInterrupt ( ) ) interrupted = true ; } } finally { if ( failed ) cancelAcquire ( node ) ; } } 
6648	public static void setOutput ( Job job , String tableName , int fieldCount ) throws IOException { DBConfiguration dbConf = setOutput ( job , tableName ) ; dbConf . setOutputFieldCount ( fieldCount ) ; } 
6649	private static String getStackTrace ( ) { final StringBuilder sb = new StringBuilder ( ) ; try { throw new RuntimeException ( ) ; } catch ( RuntimeException e ) { final StackTraceElement [ ] frames = e . getStackTrace ( ) ; Start at _NUM because the first frame is here and we don ' t care about it for ( int j = _NUM ; j < frames . length ; + + j ) { sb . append ( frames [ j ] . toString ( ) + _STR ) ; } } return sb . toString ( ) ; } 
6650	public static JSONObject rowToJSONObject ( JSONArray names , JSONTokener x ) throws JSONException { JSONArray ja = rowToJSONArray ( x ) ; return ja ! = null ? ja . toJSONObject ( names ) : null ; } 
6651	private boolean taskTopActivityIsUser ( TaskRecord task , @ UserIdInt int userId ) { To handle the case that work app is in the task but just is not the top one . final ActivityRecord activityRecord = task . getTopActivity ( ) ; final ActivityRecord resultTo = ( activityRecord ! = null ? activityRecord . resultTo : null ) ; return ( activityRecord ! = null & & activityRecord . userId = = userId ) | | ( resultTo ! = null & & resultTo . userId = = userId ) ; } 
6652	public OpenCmsTestResourceStorageEntry get ( String resourceName ) throws Exception { String mappedResourceName = mapResourcename ( resourceName ) ; OpenCmsTestResourceStorageEntry entry = null ; entry = m _ storage . get ( mappedResourceName ) ; if ( entry = = null ) { throw new Exception ( _STR + m _ storage . keySet ( ) . toString ( ) ) ; } return entry ; } 
6653	public void deleteProjectResources ( CmsDbContext dbc , CmsProject project ) throws CmsDataAccessException { Connection conn = null ; PreparedStatement stmt = null ; try { conn = m _ sqlManager . getConnection ( dbc ) ; stmt = m _ sqlManager . getPreparedStatement ( conn , _STR ) ; stmt . setString ( _NUM , project . getUuid ( ) . toString ( ) ) ; stmt . executeUpdate ( ) ; } catch ( SQLException e ) { throw new CmsDbSqlException ( Messages . get ( ) . container ( Messages . ERR _ GENERIC _ SQL _ _NUM , CmsDbSqlException . getErrorQuery ( stmt ) ) , e ) ; } finally { m _ sqlManager . closeAll ( dbc , conn , stmt , null ) ; } } 
6654	public java _ cup . runtime . Symbol do _ action ( int act _ num , java _ cup . runtime . lr _ parser parser , java . util . Stack stack , int top ) throws java . lang . Exception { return action _ obj . CUP $ Parser $ do _ action ( act _ num , parser , stack , top ) ; } 
6655	private String getRelativePathName ( String absolutePathName , String volume ) { absolutePathName = normalizePath ( absolutePathName ) ; Get the file names if ( ! absolutePathName . startsWith ( volume ) ) { return null ; } Get rid of the volume prefix String fileName = absolutePathName . substring ( volume . length ( ) ) ; if ( fileName . charAt ( _NUM ) = = Path . SEPARATOR _ CHAR ) { fileName = fileName . substring ( _NUM ) ; } return fileName ; } 
6656	protected static Attribute toAttribute ( JSONNode att , boolean [ ] classAtt ) { Attribute result ; String name ; String type ; String dateformat ; JSONNode labels ; ArrayList < String > values ; int i ; double weight ; name = ( String ) att . getChild ( NAME ) . getValue ( _STR ) ; return null ; } result . setWeight ( weight ) ; return result ; } 
6657	public static void multiOrSequential ( ZKWatcher zkw , List < ZKUtilOp > ops , boolean runSequentialOnMultiFailure ) throws KeeperException { if ( zkw . getConfiguration ( ) . get ( _STR ) ; processSequentially ( zkw , ops ) ; break ; } default : throw ke ; } } catch ( InterruptedException ie ) { zkw . interruptedException ( ie ) ; } } 
6658	public Port createRemoteInputPort ( String id , String name ) { id = requireNonNull ( id ) . intern ( ) ; name = requireNonNull ( name ) . intern ( ) ; verifyPortIdDoesNotExist ( id ) ; return new StandardRootGroupPort ( id , name , null , TransferDirection . RECEIVE , ConnectableType . INPUT _ PORT , authorizer , getBulletinRepository ( ) , processScheduler , Boolean . TRUE . equals ( isSiteToSiteSecure ) , nifiProperties ) ; } 
6659	public int getResultingHeight ( ) { int height = getResultingTargetHeight ( ) ; if ( height = = - _NUM ) { if ( isCropped ( ) ) { height = m _ cropHeight ; } else { height = m _ orgHeight ; } } return height ; } 
6660	public static void encodeFileToFile ( String infile , String outfile ) throws java . io . IOException { String encoded = Base _NUM _NUM . encodeFromFile ( infile ) ; java . io . OutputStream out = null ; try { out = new java . io . BufferedOutputStream ( new java . io . FileOutputStream ( outfile ) ) ; Strict , _NUM - bit output . out . write ( encoded . getBytes ( _STR ) ) ; } end try catch ( java . io . IOException e ) { Catch and release to execute finally { } throw e ; } finally end catch { try { out . close ( ) ; } catch ( Exception ex ) { } } end finally } 
6661	public static String getPathDifference ( final Path root , final Path child ) { final int depthDiff = child . depth ( ) - root . depth ( ) ; if ( depthDiff < = _NUM ) { return _STR . intern ( ) ; } String lastRoot = root . getName ( ) ; Path childsParent = child . getParent ( ) ; final StringBuilder builder = new StringBuilder ( ) ; builder . append ( childsParent . getName ( ) ) ; for ( int i = ( depthDiff - _NUM ) ; i > = _NUM ; i - - ) { childsParent = childsParent . getParent ( ) ; String name = childsParent . getName ( ) ; if ( name . equals ( lastRoot ) & & childsParent . toString ( ) . endsWith ( root . toString ( ) ) ) { break ; } builder . insert ( _NUM , Path . SEPARATOR ) . insert ( _NUM , name ) ; } return builder . toString ( ) ; } 
6662	void playTransition ( ViewGroup sceneRoot ) { mStartValuesList = new ArrayList < TransitionValues > ( ) ; mEndValuesList = new ArrayList < TransitionValues > ( ) ; matchStartAndEnd ( mStartValues , mEndValues ) ; ArrayMap < Animator , AnimationInfo > runningAnimators = getRunningAnimators ( ) ; int numOldAnims = runningAnimators . size ( ) ; WindowId windowId = sceneRoot . getWindowId ( ) ; for ( int i = numOldAnims - _NUM ; i > = _NUM ; i - - ) { Animator anim = runningAnimators . keyAt ( i ) ; if ( anim ! = null ) { AnimationInfo oldInfo = runningAnimators . get ( anim ) ; if ( oldInfo ! = null & & oldInfo . view ! = null & & oldInfo . windowId = = windowId ) { TransitionValues oldValues = oldInfo . values ; View oldView = oldInfo . view ; TransitionValues startValues = getTransitionValues ( oldView , true ) ; TransitionValues endValues = getMatchedTransitionValues ( oldView , true ) ; if ( startValues = = null & & endValues = = null ) { endValues = mEndValues . viewValues . get ( oldView ) ; } boolean cancel = ( startValues ! = null | | endValues ! = null ) & & oldInfo . transition . isTransitionRequired ( oldValues , endValues ) ; if ( cancel ) { if ( anim . isRunning ( ) | | anim . isStarted ( ) ) { if ( DBG ) { Log . d ( LOG _ TAG , _STR + anim ) ; } runningAnimators . remove ( anim ) ; } } } } } createAnimators ( sceneRoot , mStartValues , mEndValues , mStartValuesList , mEndValuesList ) ; runAnimators ( ) ; } 
6663	public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( _STR ) ; return sb . toString ( ) ; } 
6664	public int put ( K key , V val ) { final Set < V > theSet ; if ( theMap . containsKey ( key ) ) { theSet = theMap . get ( key ) ; } else { theSet = new HashSet < V > ( _NUM _NUM ) ; theMap . put ( key , theSet ) ; } theSet . add ( val ) ; return theSet . size ( ) ; } 
6665	public CategoryAxis getDomainAxisForDataset ( int index ) { if ( index < _NUM ) { throw new IllegalArgumentException ( _STR ) ; } CategoryAxis axis = null ; List axisIndices = ( List ) this . datasetToDomainAxesMap . get ( new Integer ( index ) ) ; if ( axisIndices ! = null ) { the first axis in the list is used for data < - - > Java _NUM D Integer axisIndex = ( Integer ) axisIndices . get ( _NUM ) ; axis = getDomainAxis ( axisIndex . intValue ( ) ) ; } else { axis = getDomainAxis ( _NUM ) ; } return axis ; } 
6666	List < WebDAVResource > listDbs ( ) throws IOException { final WebDAVQuery query = new WebDAVQuery ( STRING _ JOIN . args ( _ DB _ LIST _ DETAILS . args ( ) + _STR , WEBDAV _ DB ) ; final String [ ] result = results ( query ) ; final List < WebDAVResource > dbs = new ArrayList < > ( ) ; final int rs = result . length ; for ( int r = _NUM ; r < rs ; r + = _NUM ) { final String name = result [ r ] ; final long mod = DateTime . parse ( result [ r + _NUM ] ) . getTime ( ) ; dbs . add ( WebDAVFactory . database ( this , new WebDAVMetaData ( name , mod ) ) ) ; } return dbs ; } 
6667	public static void shutdownExecutorService ( ExecutorService executorService , Optional < Logger > logger , long timeout , TimeUnit unit ) { Preconditions . checkNotNull ( unit ) ; Disable new tasks from being submitted executorService . shutdown ( ) ; if ( logger . isPresent ( ) ) { logger . get ( ) . info ( _STR + executorService ) ; } } } 
6668	public PdfOutline getRootOutline ( ) { checkWriter ( ) ; return pdf . getRootOutline ( ) ; } 
6669	public String getValue ( ArgDecl argDecl ) { Arg arg = getArg ( argDecl ) ; if ( arg = = null ) return null ; if ( arg . hasValue ( ) ) return arg . getValue ( ) ; return null ; } 
6670	public void setAuthorEmail ( String value ) { checkFrozen ( ) ; m _ authorEmail = value . trim ( ) ; } 
6671	public Long createCluster ( String clusterName ) throws Exception { required to populate the database with stacks injector . getInstance ( AmbariMetaInfo . class ) ; ResourceTypeDAO resourceTypeDAO = injector . getInstance ( ResourceTypeDAO . class ) ; ResourceTypeEntity resourceTypeEntity = new ResourceTypeEntity ( ) ; resourceTypeEntity . setId ( ResourceType . CLUSTER . getId ( ) ) ; resourceTypeEntity . setName ( ResourceType . CLUSTER . name ( ) ) ; resourceTypeEntity = resourceTypeDAO . merge ( resourceTypeEntity ) ; ResourceEntity resourceEntity = new ResourceEntity ( ) ; resourceEntity . setResourceType ( resourceTypeEntity ) ; ClusterDAO clusterDAO = injector . getInstance ( ClusterDAO . class ) ; StackDAO stackDAO = injector . getInstance ( StackDAO . class ) ; StackEntity stackEntity = stackDAO . find ( _STR ) ; method . setAccessible ( true ) ; method . invoke ( clusters ) ; return clusterEntity . getClusterId ( ) ; } 
6672	private void filter ( char [ ] ch , int start , int length , Output output ) throws SAXException { int end = start + length ; int i = start ; while ( i < end ) { int c = Character . codePointAt ( ch , i , end ) ; int j = i + Character . charCount ( c ) ; if ( isInvalid ( c ) ) { Output any preceding valid characters if ( i > start ) { output . write ( ch , start , i - start ) ; } Output the replacement for this invalid character writeReplacement ( output ) ; Continue with the rest of the array start = j ; } i = j ; } Output any remaining valid characters output . write ( ch , start , end - start ) ; } 
6673	void processBaseNode ( WatchedEvent event ) throws KeeperException , InterruptedException { switch ( event . getType ( ) ) { case NodeDeleted : The parent node was deleted , no children are possible , remove all keys log . debug ( _STR , event . getType ( ) ) ; break ; } } 
6674	public static Container encloseX ( Component . . . cmps ) { return Container . encloseIn ( new BoxLayout ( BoxLayout . X _ AXIS ) , cmps ) ; } 
6675	public static void prepareRoute ( ModelCamelContext context , RouteDefinition route , List < OnExceptionDefinition > onExceptions , List < InterceptDefinition > intercepts , List < InterceptFromDefinition > interceptFromDefinitions , List < InterceptSendToEndpointDefinition > interceptSendToEndpointDefinitions , List < OnCompletionDefinition > onCompletions ) { Runnable propertyPlaceholdersChangeReverter = ProcessorDefinitionHelper . createPropertyPlaceholdersChangeReverter ( ) ; try { prepareRouteImp ( context , route , onExceptions , intercepts , interceptFromDefinitions , interceptSendToEndpointDefinitions , onCompletions ) ; } finally { Lets restore propertyPlaceholdersChangeReverter . run ( ) ; } } 
6676	public void setCustomPropsFile ( File value ) { m _ CustomPropsFile = value ; initialize ( m _ CustomPropsFile ) ; } 
6677	public ShapeBadgeItem show ( boolean animate ) { mIsHidden = false ; if ( isWeakReferenceValid ( ) ) { FrameLayout frameLayout = mFrameLayout . get ( ) ; if ( animate ) { frameLayout . setScaleX ( _NUM ) ; frameLayout . setScaleY ( _NUM ) ; frameLayout . setVisibility ( View . VISIBLE ) ; ViewPropertyAnimatorCompat animatorCompat = ViewCompat . animate ( frameLayout ) ; animatorCompat . cancel ( ) ; animatorCompat . setDuration ( mAnimationDuration ) ; animatorCompat . scaleX ( _NUM ) . scaleY ( _NUM ) ; animatorCompat . setListener ( null ) ; animatorCompat . start ( ) ; } else { frameLayout . setScaleX ( _NUM ) ; frameLayout . setScaleY ( _NUM ) ; frameLayout . setVisibility ( View . VISIBLE ) ; } } return this ; } 
6678	public static BigDecimal log ( final Rational r , final MathContext mc ) { if ( r . compareTo ( Rational . ZERO ) < = _NUM ) { throw new ArithmeticException ( _STR + r . toString ( ) ) ; } else if ( r . compareTo ( Rational . ONE ) = = _NUM ) { return BigDecimal . ZERO ; } else { double eps = prec _NUM err ( Math . log ( r . doubleValue ( ) ) , mc . getPrecision ( ) ) ; MathContext mcloc = new MathContext ( _NUM + err _NUM prec ( eps ) ) ; final BigDecimal resul = log ( r . BigDecimalValue ( mcloc ) ) ; return resul . round ( mc ) ; } } 
6679	boolean shutdownRequested ( IRecordProcessorCheckpointer checkpointer ) { Future < Boolean > writeFuture = messageWriter . writeShutdownRequestedMessage ( ) ; return waitForStatusMessage ( ShutdownRequestedMessage . ACTION , checkpointer , writeFuture ) ; } 
6680	private Expression logicalXORExpression ( ) throws SQLSyntaxErrorException { for ( Expression expr = logicalAndExpression ( ) ; ; ) { switch ( lexer . token ( ) ) { case KW _ XOR : lexer . nextToken ( ) ; Expression newExpr = logicalAndExpression ( ) ; expr = new LogicalXORExpression ( expr , newExpr ) . setCacheEvalRst ( cacheEvalRst ) ; break ; default : return expr ; } } } 
6681	public static void editRole ( String name , String inheritedRole , String description , String newName ) throws RoleNotFoundException , RoleNotModifiableException { if ( ! RoleDao . exists ( name ) ) throw new RoleNotFoundException ( name + _STR , newName ) ; if ( description ! = null ) roleDoc . field ( FIELD _ DESCRIPTION , description ) ; roleDoc . save ( ) ; } 
6682	public ElementGroup getClause ( ) { Element e = query . getQueryPattern ( ) ; if ( e = = null ) { e = new ElementGroup ( ) ; query . setQueryPattern ( e ) ; } if ( e instanceof ElementGroup ) { return ( ElementGroup ) e ; } ElementGroup eg = new ElementGroup ( ) ; eg . addElement ( e ) ; query . setQueryPattern ( eg ) ; return eg ; } 
6683	private Point getTableSize ( ) { int x = _NUM ; int y = _NUM ; if ( columnHeadersVisible ) { y + = headerHeight ; } y + = getGridHeight ( ) ; if ( rowHeaderVisible ) { x + = rowHeaderWidth ; } for ( GridColumn column : columns ) { x + = column . getWidth ( ) ; } return new Point ( x , y ) ; } 
6684	public static LongArrayMap < Object > removeBrokenHotseatItems ( Context context ) throws Exception { GridSizeMigrationTask task = new GridSizeMigrationTask ( context , LauncherAppState . getInstance ( ) . getInvariantDeviceProfile ( ) , getValidPackages ( context ) , Integer . MAX _ VALUE , Integer . MAX _ VALUE ) ; Load all the valid entries ArrayList < DbEntry > items = task . loadHotseatEntries ( ) ; Delete any entry marked for deletion by above load . task . applyOperations ( ) ; LongArrayMap < Object > positions = new LongArrayMap < > ( ) ; for ( DbEntry item : items ) { positions . put ( item . screenId , item ) ; } return positions ; } 
6685	public final boolean readBoolean ( ) throws java . io . IOException { int temp = in . read ( ) ; if ( temp < _NUM ) { throw new EOFException ( ) ; } return temp ! = _NUM ; } 
6686	public void startDozing ( ) { if ( mCanDoze & & ! mDozing ) { mDozing = true ; updateDoze ( ) ; } } 
6687	public void testMeta ( ) throws Exception { InputStream stream = ClassLoader . getSystemResourceAsStream ( TikaResourceTest . TEST _ DOC ) ; Response response = WebClient . create ( endPoint + _STR , msg ) ; } 
6688	public static synchronized void printTarget ( String target ) { if ( statusMsgs ) { target = _STR + line ) ; printMessage ( target ) ; printMessage ( line ) ; } } 
6689	public static String preambleToString ( final Memory mem ) { make sure we can get the assumed preamble final int preLongs = getAndCheckPreLongs ( mem ) ; final Family family = Family . idToFamily ( mem . getByte ( FAMILY _ BYTE ) ) ; switch ( family ) { case RESERVOIR : case VAROPT : return sketchPreambleToString ( mem , family , preLongs ) ; case RESERVOIR _ UNION : case VAROPT _ UNION : return unionPreambleToString ( mem , family , preLongs ) ; default : throw new SketchesArgumentException ( _STR + family . getFamilyName ( ) ) ; } } 
6690	public void validateCopyConstructorWithSourceWithSimCred ( ) throws Exception { Credential sourceCred = createCredentialWithSimCredential ( ) ; Credential copyCred = new Credential ( sourceCred ) ; assertTrue ( copyCred . equals ( sourceCred ) ) ; } 
6691	protected LinkedList < TransactionOutput > calculateAllSpendCandidatesFromUTXOProvider ( boolean excludeImmatureCoinbases ) { checkState ( lock . isHeldByCurrentThread ( ) ) ; UTXOProvider utxoProvider = checkNotNull ( vUTXOProvider , _STR , e ) ; } We need to handle the pending transactions that we know about . for ( Transaction tx : pending . values ( ) ) { Remove the spent outputs . for ( TransactionInput input : tx . getInputs ( ) ) { if ( input . getConnectedOutput ( ) . isMine ( this ) ) { candidates . remove ( input . getConnectedOutput ( ) ) ; } } Add change outputs . Do not try and spend coinbases that were mined too recently , the protocol forbids it . if ( ! excludeImmatureCoinbases | | tx . isMature ( ) ) { for ( TransactionOutput output : tx . getOutputs ( ) ) { if ( output . isAvailableForSpending ( ) & & output . isMine ( this ) ) { candidates . add ( output ) ; } } } } return candidates ; } 
6692	int doIO ( ByteBuffer buf , int ops ) throws IOException { if ( ! buf . hasRemaining ( ) ) { throw new IllegalArgumentException ( _STR ) ; or should we just return _NUM ? } while ( buf . hasRemaining ( ) ) { if ( closed ) { return - _NUM ; } try { int n = performIO ( buf ) ; if ( n ! = _NUM ) { successful io or an error . return n ; } } catch ( IOException e ) { if ( ! channel . isOpen ( ) ) { closed = true ; } throw e ; } now wait for socket to be ready . int count = _NUM ; try { count = selector . select ( channel , ops , timeout ) ; } catch ( IOException e ) { unexpected IOException . closed = true ; throw e ; } if ( count = = _NUM ) { throw new SocketTimeoutException ( timeoutExceptionString ( channel , timeout , ops ) ) ; } otherwise the socket should be ready for io . } does not reach here . return _NUM ; } 
6693	public int read ( ) throws IOException { final int b = readFirstBytes ( ) ; return b > = _NUM ? b : in . read ( ) ; } 
6694	public static void main ( String [ ] args ) throws IOException { if ( args . length < _NUM ) { usage ( ) ; System . exit ( - _NUM ) ; } either dump using the WALPrettyPrinter or split , depending on args if ( args [ _NUM ] . compareTo ( _STR ) = = _NUM ) { Configuration conf = HBaseConfiguration . create ( ) ; for ( int i = _NUM ; i < args . length ; i + + ) { try { Path logPath = new Path ( args [ i ] ) ; FSUtils . setFsDefault ( conf , logPath ) ; split ( conf , logPath ) ; } catch ( IOException t ) { t . printStackTrace ( System . err ) ; System . exit ( - _NUM ) ; } } } else { usage ( ) ; System . exit ( - _NUM ) ; } } 
6695	public static int truncatedCompareTo ( final Date date _NUM , final Date date _NUM , final int field ) { final Date truncatedDate _NUM = truncate ( date _NUM , field ) ; final Date truncatedDate _NUM = truncate ( date _NUM , field ) ; return truncatedDate _NUM . compareTo ( truncatedDate _NUM ) ; } 
6696	private void fillDetailDocTypes ( CmsListItem item , String detailId ) { CmsSearchManager searchManager = OpenCms . getSearchManager ( ) ; StringBuffer html = new StringBuffer ( ) ; search for the corresponding CmsSearchIndexSource : String idxSourceName = ( String ) item . get ( LIST _ COLUMN _ NAME ) ; CmsSearchIndexSource idxSource = searchManager . getIndexSource ( idxSourceName ) ; get the index sources doc types List docTypes = idxSource . getDocumentTypes ( ) ; output of found index sources Iterator itDocTypes = docTypes . iterator ( ) ; CmsSearchDocumentType docType ; html . append ( _STR ) ; item . set ( detailId , html . toString ( ) ) ; } 
6697	protected synchronized void startSecureZK ( ) throws Exception { assertNull ( _STR + methodName . getMethodName ( ) ) ; secureZK . start ( ) ; } 
6698	private InputStream openResponseEntity ( State state , HttpResponse response ) throws StopRequest { try { return response . getEntity ( ) . getContent ( ) ; } catch ( IOException ex ) { logNetworkState ( ) ; throw new StopRequest ( getFinalStatusForHttpError ( state ) , _STR + ex . toString ( ) , ex ) ; } } 
6699	private void addHyperlinkToken ( int start , int end , int tokenType ) { int so = start + offsetShift ; addToken ( zzBuffer , start , end , tokenType , so , true ) ; } 
6700	protected void scheduleDelayedStart ( ) throws Exception { Runnable startRunnable = new Runnable ( ) { @ Override public void run ( ) { try { doStart ( ) ; } catch ( Exception e ) { LOG . error ( _STR , URISupport . sanitizeUri ( mJmxEndpoint . getEndpointUri ( ) ) , mJmxEndpoint . getReconnectDelay ( ) ) ; getExecutor ( ) . schedule ( startRunnable , mJmxEndpoint . getReconnectDelay ( ) , TimeUnit . SECONDS ) ; } 
6701	public View focusSearch ( View focused , int direction ) { View result = mLayout . onInterceptFocusSearch ( focused , direction ) ; if ( result ! = null ) { return result ; } final boolean canRunFocusFailure = mAdapter ! = null & & mLayout ! = null & & ! isComputingLayout ( ) & & ! mLayoutFrozen ; final FocusFinder ff = FocusFinder . getInstance ( ) ; if ( canRunFocusFailure & & ( direction = = View . FOCUS _ FORWARD | | direction = = View . FOCUS _ BACKWARD ) ) { convert direction to absolute direction and see if we have a view there and if not tell LayoutManager to add if it can . boolean needsFocusFailureLayout = false ; if ( mLayout . canScrollVertically ( ) ) { final int absDir = direction = = View . FOCUS _ FORWARD ? View . FOCUS _ DOWN : View . FOCUS _ UP ; final View found = ff . findNextFocus ( this , focused , absDir ) ; needsFocusFailureLayout = found = = null ; if ( FORCE _ ABS _ FOCUS _ SEARCH _ DIRECTION ) { Workaround for broken FOCUS _ BACKWARD in API _NUM _NUM and older devices . direction = absDir ; } } if ( ! needsFocusFailureLayout & & mLayout . canScrollHorizontally ( ) ) { boolean rtl = mLayout . getLayoutDirection ( ) = = View . LAYOUT _ DIRECTION _ RTL ; final int absDir = ( direction = = View . FOCUS _ FORWARD ) ^ rtl ? View . FOCUS _ RIGHT : View . FOCUS _ LEFT ; final View found = ff . findNextFocus ( this , focused , absDir ) ; needsFocusFailureLayout = found = = null ; if ( FORCE _ ABS _ FOCUS _ SEARCH _ DIRECTION ) { Workaround for broken FOCUS _ BACKWARD in API _NUM _NUM and older devices . direction = absDir ; } } if ( needsFocusFailureLayout ) { consumePendingUpdateOperations ( ) ; final View focusedItemView = findContainingItemView ( focused ) ; if ( focusedItemView = = null ) { panic , focused view is not a child anymore , cannot call super . return null ; } eatRequestLayout ( ) ; mLayout . onFocusSearchFailed ( focused , direction , mRecycler , mState ) ; resumeRequestLayout ( false ) ; } result = ff . findNextFocus ( this , focused , direction ) ; } else { result = ff . findNextFocus ( this , focused , direction ) ; if ( result = = null & & canRunFocusFailure ) { consumePendingUpdateOperations ( ) ; final View focusedItemView = findContainingItemView ( focused ) ; if ( focusedItemView = = null ) { panic , focused view is not a child anymore , cannot call super . return null ; } eatRequestLayout ( ) ; result = mLayout . onFocusSearchFailed ( focused , direction , mRecycler , mState ) ; resumeRequestLayout ( false ) ; } } return isPreferredNextFocus ( focused , result , direction ) ? result : super . focusSearch ( focused , direction ) ; } 
6702	public Insert value ( String name , Object value ) { checkState ( json = = null & & jsonDefault = = null , _STR ) ; names . add ( name ) ; values . add ( value ) ; checkForBindMarkers ( value ) ; if ( ! hasNonIdempotentOps ( ) & & ! Utils . isIdempotent ( value ) ) this . setNonIdempotentOps ( ) ; maybeAddRoutingKey ( name , value ) ; return this ; } 
6703	private void initAudioRecorder ( ) throws IOException { mBufferSize = AudioRecord . getMinBufferSize ( DEFAULT _ SAMPLING _ RATE , DEFAULT _ CHANNEL _ CONFIG , DEFAULT _ AUDIO _ FORMAT . getAudioFormat ( ) ) ; int bytesPerFrame = DEFAULT _ AUDIO _ FORMAT . getBytesPerFrame ( ) ; int frameSize = mBufferSize / bytesPerFrame ; if ( frameSize % FRAME _ COUNT ! = _NUM ) { frameSize + = ( FRAME _ COUNT - frameSize % FRAME _ COUNT ) ; mBufferSize = frameSize * bytesPerFrame ; } mAudioRecord = new AudioRecord ( DEFAULT _ AUDIO _ SOURCE , DEFAULT _ SAMPLING _ RATE , DEFAULT _ CHANNEL _ CONFIG , DEFAULT _ AUDIO _ FORMAT . getAudioFormat ( ) , mBufferSize ) ; mPCMBuffer = new short [ mBufferSize ] ; LameUtil . init ( DEFAULT _ SAMPLING _ RATE , DEFAULT _ LAME _ IN _ CHANNEL , DEFAULT _ SAMPLING _ RATE , DEFAULT _ LAME _ MP _NUM _ BIT _ RATE , DEFAULT _ LAME _ MP _NUM _ QUALITY ) ; Create and run thread used to encode data The thread will mEncodeThread = new DataEncodeThread ( mRecordFile , mBufferSize ) ; mEncodeThread . start ( ) ; mAudioRecord . setRecordPositionUpdateListener ( mEncodeThread , mEncodeThread . getHandler ( ) ) ; mAudioRecord . setPositionNotificationPeriod ( FRAME _ COUNT ) ; } 
6704	public void abort ( ) { cancel ( ) ; if ( mDragState = = STATE _ SETTLING ) { final int oldX = mScroller . getCurrX ( ) ; final int oldY = mScroller . getCurrY ( ) ; mScroller . abortAnimation ( ) ; final int newX = mScroller . getCurrX ( ) ; final int newY = mScroller . getCurrY ( ) ; mCallback . onViewPositionChanged ( mCapturedView , newX , newY , newX - oldX , newY - oldY ) ; } setDragState ( STATE _ IDLE ) ; } 
6705	static Implementation getImplementation ( String baseName , String algorithm , Provider prov ) { if ( prov = = null ) { Provider [ ] provider = Security . getProviders ( ) ; for ( int i = _NUM ; i ! = provider . length ; i + + ) { Implementation imp = getImplementation ( baseName , algorithm , provider [ i ] ) ; if ( imp ! = null ) { return imp ; } } return null ; } String alias ; while ( ( alias = prov . getProperty ( _STR + e . toString ( ) ) ; } } return null ; } 
6706	public void setRetransmitEndpoint ( InetSocketAddress endpoint ) throws IllegalStateException , IllegalArgumentException { String addrString = null ; int port = _NUM ; if ( null ! = endpoint ) { addrString = endpoint . getAddress ( ) . getHostAddress ( ) ; port = endpoint . getPort ( ) ; } int ret = native _ setRetransmitEndpoint ( addrString , port ) ; if ( ret ! = _NUM ) { throw new IllegalArgumentException ( _STR + ret ) ; } } 
6707	private void paintComponentWrapped ( Graphics g ) { The variables we use are as follows : - visibleRect is the _STR area of the text area ; e . g . [ _NUM , _NUM _NUM _NUM , _NUM _NUM _NUM , _NUM _NUM _NUM + ( lineCount * cellHeight ) - _NUM ] . actualTop . y is the topmost - pixel in the first logical line we paint . Note that we may well not paint this part of the logical line , as it may be broken into many physical lines , with the first few physical lines scrolled past . Note also that this is NOT the visible rect of this line number list ; this line number list has visible rect = = [ _NUM , _NUM , insets . left - _NUM , visibleRect . height - _NUM ] . - offset ( < = _NUM ) is the y - coordinate at which we begin painting when we begin painting with the first logical line . This can be negative , signifying that we ' ve scrolled past the actual topmost part of this line . The algorithm is as follows : - Get the starting y - coordinate at which to paint . This may be above the first visible y - coordinate as we ' re in line - wrapping mode , but we always paint entire logical lines . - Paint that line ' s indicator , if appropriate . Increment y to be just below the are we just painted ( i . e . , the beginning of the next logical line ' s view area ) . - Get the ending visual position for that line . We can now loop back , paint this line , and continue until our y - coordinate is past the last visible y - value . We avoid using modelToView / viewToModel where possible , as these methods trigger a parsing of the line into syntax tokens , which is costly . It ' s cheaper to just grab the child views ' bounds . Some variables we ' ll be using . int width = getWidth ( ) ; RTextAreaUI ui = ( RTextAreaUI ) textArea . getUI ( ) ; View v = ui . getRootView ( textArea ) . getView ( _NUM ) ; Document doc = textArea . getDocument ( ) ; Element root = doc . getDefaultRootElement ( ) ; int topPosition = textArea . viewToModel ( new Point ( visibleRect . x , visibleRect . y ) ) ; int topLine = root . getElementIndex ( topPosition ) ; int cellHeight = textArea . getLineHeight ( ) ; FoldManager fm = ( ( RSyntaxTextArea ) textArea ) . getFoldManager ( ) ; Compute the y at which to begin painting text , taking into account that _NUM logical line = > at least _NUM physical line , so it may be that y < _NUM . The computed y - value is the y - value of the top of the first ( possibly ) partially - visible view . Rectangle visibleEditorRect = ui . getVisibleEditorRect ( ) ; Rectangle r = LineNumberList . getChildViewBounds ( v , topLine , visibleEditorRect ) ; int y = r . y ; y + = ( cellHeight - collapsedFoldIcon . getIconHeight ( ) ) / _NUM ; int visibleBottom = visibleRect . y + visibleRect . height ; int x = width - _NUM _NUM ; int line = topLine ; boolean paintingOutlineLine = foldWithOutlineShowing ! = null & & foldWithOutlineShowing . containsLine ( line ) ; int lineCount = root . getElementCount ( ) ; while ( y < visibleBottom & & line < lineCount ) { int curLineH = LineNumberList . getChildViewBounds ( v , line , visibleEditorRect ) . height ; if ( paintingOutlineLine ) { g . setColor ( getForeground ( ) ) ; int w _NUM = width / _NUM ; if ( line = = foldWithOutlineShowing . getEndLine ( ) ) { int y _NUM = y + curLineH - cellHeight / _NUM ; g . drawLine ( w _NUM , y , w _NUM , y _NUM ) ; g . drawLine ( w _NUM , y _NUM , width - _NUM , y _NUM ) ; paintingOutlineLine = false ; } else { g . drawLine ( w _NUM , y , w _NUM , y + curLineH ) ; } } Fold fold = fm . getFoldForLine ( line ) ; if ( fold ! = null ) { if ( fold = = foldWithOutlineShowing ) { if ( ! fold . isCollapsed ( ) ) { g . setColor ( getForeground ( ) ) ; int w _NUM = width / _NUM ; g . drawLine ( w _NUM , y + cellHeight / _NUM , w _NUM , y + curLineH ) ; paintingOutlineLine = true ; } if ( mouseOverFoldIcon ) { paintFoldArmed = true ; } } if ( fold . isCollapsed ( ) ) { collapsedFoldIcon . paintIcon ( this , g , x , y ) ; y + = LineNumberList . getChildViewBounds ( v , line , visibleEditorRect ) . height ; line + = fold . getLineCount ( ) + _NUM ; } else { expandedFoldIcon . paintIcon ( this , g , x , y ) ; y + = curLineH ; line + + ; } paintFoldArmed = false ; } else { y + = curLineH ; line + + ; } } } 
6708	final void verifyStates ( ) { if ( injectShouldPerformVerification ( ) ) { verifyStatesInner ( ) ; } } 
6709	public void setFile ( File file ) throws IOException { m _ File = file . getPath ( ) ; setSource ( file ) ; } 
6710	public ComponentSelector append ( Component child ) { for ( Component c : this ) { if ( c instanceof Container ) { Container cnt = ( Container ) c ; cnt . add ( child ) ; return this ; } } return this ; } 
6711	public String getRenditionParams ( ) { TextType tt = getRenditionParamsProperty ( ) ; return tt ! = null ? tt . getStringValue ( ) : null ; } 
6712	public static BigDecimal getOrderItemSubTotal ( GenericValue orderItem , List < GenericValue > adjustments , boolean forTax , boolean forShipping ) { BigDecimal unitPrice = orderItem . getBigDecimal ( _STR , true ) ; } catch ( GenericEntityException e ) { } result = result . multiply ( getWorkEffortRentalQuantity ( workEffort ) ) ; } } } } subtotal also includes non tax and shipping adjustments ; tax and shipping will be calculated using this adjusted value result = result . add ( getOrderItemAdjustmentsTotal ( orderItem , adjustments , true , false , false , forTax , forShipping ) ) ; return result . setScale ( scale , rounding ) ; } 
6713	public void importResourcesWithTempProject ( String importFile ) throws Exception { CmsProject project = m _ cms . createProject ( _STR , true ) ; OpenCms . getImportExportManager ( ) . importData ( m _ cms , new CmsShellReport ( m _ cms . getRequestContext ( ) . getLocale ( ) ) , params ) ; m _ cms . unlockProject ( id ) ; OpenCms . getPublishManager ( ) . publishProject ( m _ cms ) ; OpenCms . getPublishManager ( ) . waitWhileRunning ( ) ; } 
6714	public boolean onForwardedEvent ( MotionEvent event , int activePointerId ) { boolean handledEvent = true ; boolean clearPressedItem = false ; final int actionMasked = event . getActionMasked ( ) ; switch ( actionMasked ) { case MotionEvent . ACTION _ CANCEL : handledEvent = false ; break ; case MotionEvent . ACTION _ UP : handledEvent = false ; $ FALL - THROUGH $ case MotionEvent . ACTION _ MOVE : final int activeIndex = event . findPointerIndex ( activePointerId ) ; if ( activeIndex < _NUM ) { handledEvent = false ; break ; } final int x = ( int ) event . getX ( activeIndex ) ; final int y = ( int ) event . getY ( activeIndex ) ; final int position = pointToPosition ( x , y ) ; if ( position = = INVALID _ POSITION ) { clearPressedItem = true ; break ; } final View child = getChildAt ( position - getFirstVisiblePosition ( ) ) ; setPressedItem ( child , position , x , y ) ; handledEvent = true ; if ( actionMasked = = MotionEvent . ACTION _ UP ) { clickPressedItem ( child , position ) ; } break ; } Failure to handle the event cancels forwarding . if ( ! handledEvent | | clearPressedItem ) { clearPressedItem ( ) ; } Manage automatic scrolling . if ( handledEvent ) { if ( mScrollHelper = = null ) { mScrollHelper = new ListViewAutoScrollHelper ( this ) ; } mScrollHelper . setEnabled ( true ) ; mScrollHelper . onTouch ( this , event ) ; } else if ( mScrollHelper ! = null ) { mScrollHelper . setEnabled ( false ) ; } return handledEvent ; } 
6715	public void processingInstruction ( String target , String data ) { final Node last = ( Node ) _ nodeStk . peek ( ) ; ProcessingInstruction pi = _ document . createProcessingInstruction ( target , data ) ; if ( pi ! = null ) last . appendChild ( pi ) ; } 
6716	private byte [ ] makeText ( byte [ ] buffer , boolean prettyPrint ) throws IOException { IonReader in = makeIterator ( buffer ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; IonTextWriterBuilder b = IonTextWriterBuilder . standard ( ) ; if ( prettyPrint ) { b . withPrettyPrinting ( ) ; } b . setInitialIvmHandling ( SUPPRESS ) ; IonWriter tw = b . build ( out ) ; tw . writeValues ( in ) ; tw . close ( ) ; this is utf - _NUM byte [ ] buf = out . toByteArray ( ) ; return buf ; } 
6717	public void testMultipartUploadCallbackDefault ( ) { String key = _STR ) ; CompleteMultipartUploadRequest completeMultipartUploadRequest = new CompleteMultipartUploadRequest ( bucketName , key , uploadId , partETags ) ; completeMultipartUploadRequest . setCallback ( callback ) ; CompleteMultipartUploadResult completeMultipartUploadResult = ossClient . completeMultipartUpload ( completeMultipartUploadRequest ) ; byte [ ] buffer = new byte [ bufferLength ] ; int nRead = completeMultipartUploadResult . getCallbackResponseBody ( ) . read ( buffer ) ; completeMultipartUploadResult . getCallbackResponseBody ( ) . close ( ) ; Assert . assertEquals ( callbackResponse , new String ( buffer , _NUM , nRead ) ) ; OSSObject obj = ossClient . getObject ( bucketName , key ) ; Assert . assertEquals ( key , obj . getKey ( ) ) ; Assert . assertEquals ( instreamLength , obj . getObjectMetadata ( ) . getContentLength ( ) ) ; } catch ( Exception ex ) { Assert . fail ( ex . getMessage ( ) ) ; } } 
6718	public void buildClassifier ( Instances trainInstances ) throws Exception { Initialize the remaining instance variables . m _ numSubsets = _NUM ; m _ splitPoint = Double . MAX _ VALUE ; m _ infoGain = _NUM ; m _ gainRatio = _NUM ; attributes . if ( trainInstances . attribute ( m _ attIndex ) . isNominal ( ) ) { m _ complexityIndex = trainInstances . attribute ( m _ attIndex ) . numValues ( ) ; m _ index = m _ complexityIndex ; handleEnumeratedAttribute ( trainInstances ) ; } else { m _ complexityIndex = _NUM ; m _ index = _NUM ; trainInstances . sort ( trainInstances . attribute ( m _ attIndex ) ) ; handleNumericAttribute ( trainInstances ) ; } } 
6719	void forceRemoveSelfLocked ( ) { if ( sVerbose ) Slog . v ( TAG , _STR , e ) ; } } } 
6720	public boolean contains ( byte val ) { return index ( val ) > = _NUM ; } 
6721	public void connect ( Context srcContext , Handler srcHandler , Messenger dstMessenger ) { if ( DBG ) log ( _STR ) ; } 
6722	public static XmlUnsignedInt parse ( java . io . InputStream is , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( XmlUnsignedInt ) XmlBeans . getContextTypeLoader ( ) . parse ( is , type , options ) ; } 
6723	public Map < String , CmsJspContentAccessBean > getXml ( ) { return getReadXml ( ) ; } 
6724	public boolean unlock ( final CmsUUID structureId ) { lock the sitemap CmsRpcAction < String > unlockAction = new CmsRpcAction < String > ( ) { @ Override public void execute ( ) { setLoadingMessage ( Messages . get ( ) . key ( Messages . GUI _ UNLOCKING _ _NUM ) ) ; start ( _NUM _NUM _NUM , false ) ; getService ( ) . unlock ( structureId , this ) ; } @ Override public void onResponse ( String result ) { stop ( false ) ; if ( result = = null ) { ok return ; } unable to lock String text = Messages . get ( ) . key ( Messages . GUI _ UNLOCK _ NOTIFICATION _ _NUM , structureId . toString ( ) , result ) ; CmsNotification . get ( ) . send ( CmsNotification . Type . WARNING , text ) ; } } ; return unlockAction . executeSync ( ) = = null ; } 
6725	public Rational getRational ( int tagType ) { Object o = getObject ( tagType ) ; if ( o = = null ) return null ; if ( o instanceof Rational ) return ( Rational ) o ; if ( o instanceof Integer ) return new Rational ( ( Integer ) o , _NUM ) ; if ( o instanceof Long ) return new Rational ( ( Long ) o , _NUM ) ; return null ; } 
6726	public void setFieldDefs ( ArrayList < Attribute > fieldDefs ) throws Exception { super . setFieldDefs ( fieldDefs ) ; setUpField ( ) ; } 
6727	public void zoomRange ( double lowerPercent , double upperPercent ) { double start = this . timeline . toTimelineValue ( ( long ) getRange ( ) . getLowerBound ( ) ) ; double length = ( this . timeline . toTimelineValue ( ( long ) getRange ( ) . getUpperBound ( ) ) - this . timeline . toTimelineValue ( ( long ) getRange ( ) . getLowerBound ( ) ) ) ; Range adjusted = null ; if ( isInverted ( ) ) { adjusted = new DateRange ( this . timeline . toMillisecond ( ( long ) ( start + ( length * ( _NUM - upperPercent ) ) ) ) , this . timeline . toMillisecond ( ( long ) ( start + ( length * ( _NUM - lowerPercent ) ) ) ) ) ; } else { adjusted = new DateRange ( this . timeline . toMillisecond ( ( long ) ( start + length * lowerPercent ) ) , this . timeline . toMillisecond ( ( long ) ( start + length * upperPercent ) ) ) ; } setRange ( adjusted ) ; } 
6728	public static void writePropertyFile ( CmsObject cms , String resourcename , byte [ ] content ) throws CmsException { Properties properties = new Properties ( ) ; try { String props = CmsEncoder . createString ( content , CmsEncoder . ENCODING _ UTF _ _NUM ) ; props = unescapeString ( props ) ; props = CmsEncoder . encodeJavaEntities ( props , CmsEncoder . ENCODING _ ISO _ _NUM _NUM _NUM _NUM _ _NUM ) ; byte [ ] modContent = props . getBytes ( CmsEncoder . ENCODING _ ISO _ _NUM _NUM _NUM _NUM _ _NUM ) ; properties . load ( new ByteArrayInputStream ( modContent ) ) ; List < CmsProperty > propList = new ArrayList < CmsProperty > ( ) ; Iterator < Map . Entry < Object , Object > > it = properties . entrySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { Map . Entry < Object , Object > e = it . next ( ) ; String key = ( String ) e . getKey ( ) ; String value = ( String ) e . getValue ( ) ; if ( key . endsWith ( SUFFIX _ PROP _ SHARED ) ) { propList . add ( new CmsProperty ( key . substring ( _NUM , key . length ( ) - SUFFIX _ PROP _ SHARED . length ( ) ) , null , value ) ) ; } else if ( key . endsWith ( SUFFIX _ PROP _ INDIVIDUAL ) ) { propList . add ( new CmsProperty ( key . substring ( _NUM , key . length ( ) - SUFFIX _ PROP _ INDIVIDUAL . length ( ) ) , value , null ) ) ; } } cms . writePropertyObjects ( resourcename , propList ) ; } catch ( IOException e ) { noop } } 
6729	public static < K , V > PerKeyDistinct < K , V > perKey ( ) { return PerKeyDistinct . < K , V > builder ( ) . build ( ) ; } 
6730	public final void close ( ) throws IOException { stop ( ) ; } 
6731	private static synchronized void maybeInitialize ( ) { if ( currentAddon ! = null ) { this is to ensure _STR gets called and the LAFState initialized UIManager . getLookAndFeelDefaults ( ) ; if ( ! UIManager . getBoolean ( APPCONTEXT _ INITIALIZED ) ) { setAddon ( currentAddon ) ; } } } 
6732	public void clearAccountsForPackage ( String packageName ) { try { if ( isServiceConnected ( ) & & ! TextUtils . isEmpty ( packageName ) ) { getTelecomService ( ) . clearAccounts ( packageName ) ; } } catch ( RemoteException e ) { Log . e ( TAG , _STR , e ) ; } } 
6733	public void setCustomName ( String name ) { m _ visual . setText ( name ) ; } 
6734	public static byte [ ] token ( final float flt ) { final byte [ ] b = tok ( flt ) ; if ( b ! = null ) return b ; final int fl = FLT . length ; for ( int i = _NUM ; i < fl ; + + i ) if ( flt = = FLT [ i ] ) return FLTSTR [ i ] ; final float a = Math . abs ( flt ) ; final boolean small = a > = _NUM . _NUM e - _NUM f & & a < _NUM . _NUM e _NUM f ; String s _NUM ; if ( small ) { synchronized ( DF ) { s _NUM = DF . format ( flt ) ; } } else { synchronized ( SF ) { s _NUM = SF . format ( flt ) ; } } final String s _NUM = Float . toString ( flt ) ; if ( s _NUM . length ( ) < s _NUM . length ( ) & & ( ! s _NUM . contains ( _STR ) | | ! small ) ) s _NUM = s _NUM ; return chopNumber ( token ( s _NUM ) ) ; } 
6735	private void saveStream ( byte [ ] bytes , FileFilter filter , String extension ) throws IOException { FileOpenSaveDialog saveDialog = new FileOpenSaveDialog ( parent , filter ) ; saveDialog . saveFile ( bytes , extension ) ; } 
6736	public static void assertTrue ( boolean value ) { if ( verbose ) { log ( _STR ) ; } assertBool ( value ) ; } 
6737	public void callActivityOnCreate ( Activity activity , Bundle icicle ) { prePerformCreate ( activity ) ; activity . performCreate ( icicle ) ; postPerformCreate ( activity ) ; } 
6738	void normalize _NUM _NUM h ( ) { if ( ! hasTime ( ) | | getHour ( ) ! = _NUM _NUM ) return ; _ normalizeTimeAndDate ( ) ; } 
6739	private boolean convertNamedDestination ( PdfObject obj , HashMap names ) { obj = getPdfObject ( obj ) ; int objIdx = lastXrefPartial ; releaseLastXrefPartial ( ) ; if ( obj ! = null & & obj . isDictionary ( ) ) { PdfObject ob _NUM = getPdfObject ( ( ( PdfDictionary ) obj ) . get ( PdfName . A ) ) ; if ( ob _NUM ! = null ) { int obj _NUM Idx = lastXrefPartial ; releaseLastXrefPartial ( ) ; PdfDictionary dic = ( PdfDictionary ) ob _NUM ; PdfName type = ( PdfName ) getPdfObjectRelease ( dic . get ( PdfName . S ) ) ; if ( PdfName . GOTOR . equals ( type ) ) { PdfObject ob _NUM = getPdfObjectRelease ( dic . get ( PdfName . D ) ) ; Object name = null ; if ( ob _NUM ! = null ) { if ( ob _NUM . isName ( ) ) name = ob _NUM ; else if ( ob _NUM . isString ( ) ) name = ob _NUM . toString ( ) ; PdfArray dest = ( PdfArray ) names . get ( name ) ; if ( dest ! = null ) { dic . remove ( PdfName . F ) ; dic . remove ( PdfName . NEWWINDOW ) ; dic . put ( PdfName . S , PdfName . GOTO ) ; setXrefPartialObject ( obj _NUM Idx , ob _NUM ) ; setXrefPartialObject ( objIdx , obj ) ; return true ; } } } } } return false ; } 
6740	public static < T > List < Tag < T > > fromMap ( Map < ? extends String , T > tagsMap ) { ImmutableList . Builder < Tag < T > > tagsBuilder = ImmutableList . builder ( ) ; for ( Map . Entry < ? extends String , T > entry : tagsMap . entrySet ( ) ) { tagsBuilder . add ( new Tag < > ( entry ) ) ; } return tagsBuilder . build ( ) ; } 
6741	public void remove ( BindingVector env ) { BindingVector key = getPartialEnv ( env ) ; Map < BindingVector , Count > set = data . get ( key ) ; if ( set ! = null ) { Count c = set . get ( env ) ; if ( c ! = null ) { if ( c . getCount ( ) > _NUM ) { c . dec ( ) ; } else { clean up set . remove ( env ) ; } } if ( set . isEmpty ( ) ) { data . remove ( key ) ; } } } 
6742	public String [ ] getImageResourceNames ( ) { ArrayList < String > vec = new ArrayList < String > ( ) ; Iterator < String > e = resourceTypes . keySet ( ) . iterator ( ) ; while ( e . hasNext ( ) ) { String c = e . next ( ) ; if ( isImage ( c ) ) { vec . add ( c ) ; } } return toStringArray ( vec ) ; } 
6743	public final GF _NUM nPolynomial quotient ( GF _NUM nPolynomial b ) throws RuntimeException , ArithmeticException { GF _NUM nPolynomial [ ] result = new GF _NUM nPolynomial [ _NUM ] ; result = divide ( b ) ; return result [ _NUM ] ; } 
6744	public long getUpperBound ( final long item ) { UB = itemCount + offset return hashMap . get ( item ) + offset ; } 
6745	public void deleteStoreFile ( ) throws IOException { boolean evictOnClose = cacheConf ! = null ? cacheConf . shouldEvictOnClose ( ) : true ; closeStoreFile ( evictOnClose ) ; this . fs . delete ( getPath ( ) , true ) ; } 
6746	public OpenRegionResponse openRegion ( final RpcController controller , final OpenRegionRequest request ) throws ServiceException { requestCount . increment ( ) ; if ( request . hasServerStartCode ( ) ) { check that we are the same server that this RPC is intended for . long serverStartCode = request . getServerStartCode ( ) ; if ( regionServer . serverName . getStartcode ( ) ! = serverStartCode ) { throw new ServiceException ( new DoNotRetryIOException ( _STR + region . getRegionNameAsString ( ) , ie ) ; if ( isBulkAssign ) { builder . addOpeningState ( RegionOpeningState . FAILED _ OPENING ) ; } else { throw new ServiceException ( ie ) ; } } } return builder . build ( ) ; } 
6747	public void setGravity ( int gravity ) { if ( mGravity ! = gravity ) { mGravity = gravity ; requestLayout ( ) ; } } 
6748	public boolean contains ( Object object ) { Iterator < E > it = iterator ( ) ; if ( object ! = null ) { while ( it . hasNext ( ) ) { if ( object . equals ( it . next ( ) ) ) { return true ; } } } else { while ( it . hasNext ( ) ) { if ( it . next ( ) = = null ) { return true ; } } } return false ; } 
6749	public Response getServiceVersion ( ) { return RestUtils . call ( new RestUtils . RestCallable < Long > ( ) { @ Override public Long call ( ) throws Exception { return Constants . FILE _ SYSTEM _ MASTER _ CLIENT _ SERVICE _ VERSION ; } } ) ; } 
6750	private Iterator < String > getEdgeTypes ( final ApplicationScope scope , final SearchEdgeType search , final MultiTenantColumnFamily < ScopedRowKey < Id > , String > cf ) { ValidationUtils . validateApplicationScope ( scope ) ; GraphValidation . validateSearchEdgeType ( search ) ; final ScopedRowKey < Id > sourceKey = new ScopedRowKey < > ( scope . getApplication ( ) , search . getNode ( ) ) ; resume from the last if specified . Also set the range final RangeBuilder rangeBuilder = createRange ( search ) ; RowQuery < ScopedRowKey < Id > , String > query = keyspace . prepareQuery ( cf ) . getKey ( sourceKey ) . autoPaginate ( true ) . withColumnRange ( rangeBuilder . build ( ) ) ; return new ColumnNameIterator < > ( query , PARSER , search . getLast ( ) . isPresent ( ) ) ; } 
6751	protected final T getResultTimed ( int sequence ) throws TimeoutException { final long startMillis = SystemClock . uptimeMillis ( ) ; while ( true ) { try { synchronized ( mLock ) { if ( mReceivedCalls . indexOfKey ( sequence ) > = _NUM ) { return mReceivedCalls . removeReturnOld ( sequence ) ; } final long elapsedMillis = SystemClock . uptimeMillis ( ) - startMillis ; final long waitMillis = mCallTimeoutMillis - elapsedMillis ; if ( waitMillis < = _NUM ) { mAwaitedCalls . delete ( sequence ) ; throw new TimeoutException ( _STR + sequence ) ; } mLock . wait ( waitMillis ) ; } } catch ( InterruptedException ie ) { } } } 
6752	public void testDisabledActions ( ) throws Throwable { Intent intent = new Intent ( ) ; Resources res = mContext . getResources ( ) ; final int NUM _ SEARCH _ ACTIONS = _NUM _NUM ; final List < Integer > DISABLED _ ACTIONS = new ArrayList < > ( Arrays . asList ( _NUM , _NUM , _NUM , _NUM ) ) ; final int ACTION _ ID _ REVERT _ BUTTON = _NUM ; final int ACTION _ ID _ SEARCH _ BEGIN = ACTION _ ID _ REVERT _ BUTTON + _NUM ; int ACTION _ ID _ SEARCH _ END = ACTION _ ID _ SEARCH _ BEGIN ; sequence of clicked actions simulated in the test List < Integer > CLICK _ SEQUENCE = new ArrayList < > ( ) ; Expected Clicked sequence can be different from focused ones since some of the actions are disabled hence not clickable List < Integer > EXPECTED _ FOCUSED _ SEQUENCE = new ArrayList < > ( ) ; List < Integer > EXPECTED _ CLICKED _ SEQUENCE = new ArrayList < > ( ) ; Expected actions state according to list of DISABLED _ ACTIONS : false for disabled actions List < Boolean > EXPECTED _ ACTIONS _ STATE = new ArrayList < > ( Arrays . asList ( new Boolean [ NUM _ SEARCH _ ACTIONS ] ) ) ; Collections . fill ( EXPECTED _ ACTIONS _ STATE , Boolean . TRUE ) ; for ( int i = _NUM ; i < NUM _ SEARCH _ ACTIONS ; i + + ) { CLICK _ SEQUENCE . add ( i + _NUM ) ; } for ( int clickedActionId : CLICK _ SEQUENCE ) { EXPECTED _ FOCUSED _ SEQUENCE . add ( clickedActionId ) ; if ( ! DISABLED _ ACTIONS . contains ( clickedActionId - _NUM ) ) EXPECTED _ CLICKED _ SEQUENCE . add ( clickedActionId ) ; else EXPECTED _ CLICKED _ SEQUENCE . add ( - _NUM ) ; } String title = _STR + i ) . description ( res . getString ( R . string . search _ description ) + i ) . build ( ) ) ; } for ( int action _ id : DISABLED _ ACTIONS ) { if ( action _ id > = _NUM & & action _ id < NUM _ SEARCH _ ACTIONS ) { actionList . get ( action _ id + _NUM ) . setEnabled ( false ) ; EXPECTED _ ACTIONS _ STATE . set ( action _ id , Boolean . FALSE ) ; } } GuidedStepAttributesTestFragment . clear ( ) ; GuidedStepAttributesTestFragment . GUIDANCE = guidance ; GuidedStepAttributesTestFragment . ACTION _ LIST = actionList ; GuidedStepAttributesTestFragment . setActionClickCallback ( ACTION _ ID _ REVERT _ BUTTON , sRevertCallback ) ; initActivity ( intent ) ; examineEnabledAndDisabledActions ( actionList , CLICK _ SEQUENCE , EXPECTED _ FOCUSED _ SEQUENCE , EXPECTED _ CLICKED _ SEQUENCE ) ; } 
6753	public INDArray zeros ( int [ ] shape ) { INDArray ret = create ( shape ) ; return ret ; } 
6754	protected void cleanMovedRegions ( ) { final long cutOff = System . currentTimeMillis ( ) - TIMEOUT _ REGION _ MOVED ; Iterator < Entry < String , MovedRegionInfo > > it = movedRegions . entrySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { Map . Entry < String , MovedRegionInfo > e = it . next ( ) ; if ( e . getValue ( ) . getMoveTime ( ) < cutOff ) { it . remove ( ) ; } } } 
6755	private void reloadResources ( ) { final Resources res = mService . mContext . getResources ( ) ; mDefaultMinSize = res . getDimensionPixelSize ( com . android . internal . R . dimen . default _ minimal _ size _ pip _ resizable _ task ) ; mCurrentMinSize = mDefaultMinSize ; mDefaultAspectRatio = res . getFloat ( com . android . internal . R . dimen . config _ pictureInPictureDefaultAspectRatio ) ; final String screenEdgeInsetsDpString = res . getString ( com . android . internal . R . string . config _ defaultPictureInPictureScreenEdgeInsets ) ; final Size screenEdgeInsetsDp = ! screenEdgeInsetsDpString . isEmpty ( ) ? Size . parseSize ( screenEdgeInsetsDpString ) : null ; mDefaultStackGravity = res . getInteger ( com . android . internal . R . integer . config _ defaultPictureInPictureGravity ) ; mDisplayContent . getDisplay ( ) . getRealMetrics ( mTmpMetrics ) ; mScreenEdgeInsets = screenEdgeInsetsDp = = null ? new Point ( ) : new Point ( dpToPx ( screenEdgeInsetsDp . getWidth ( ) , mTmpMetrics ) , dpToPx ( screenEdgeInsetsDp . getHeight ( ) , mTmpMetrics ) ) ; mMinAspectRatio = res . getFloat ( com . android . internal . R . dimen . config _ pictureInPictureMinAspectRatio ) ; mMaxAspectRatio = res . getFloat ( com . android . internal . R . dimen . config _ pictureInPictureMaxAspectRatio ) ; } 
6756	public double calculateScore ( int first , int second ) { Score is - log P ( out | in ) double prob = calculateProb ( first , second ) ; return - FastMath . log ( prob ) ; } 
6757	static MD _NUM Hash getFileClient ( URL infoServer , String queryString , List < File > localPaths , Storage dstStorage , boolean getChecksum ) throws IOException { URL url = new URL ( infoServer , ImageServlet . PATH _ SPEC + _STR + url ) ; return doGetUrl ( url , localPaths , dstStorage , getChecksum ) ; } 
6758	public void testAppend _NUM AfterSoftLimit ( ) throws Exception { Configuration conf = new HdfsConfiguration ( ) ; conf . setInt ( DFSConfigKeys . DFS _ REPLICATION _ KEY , _NUM ) ; Set small soft - limit for lease final long softLimit = _NUM L ; final long hardLimit = _NUM _NUM _NUM _NUM _NUM _NUM _NUM L ; MiniDFSCluster cluster = new MiniDFSCluster . Builder ( conf ) . numDataNodes ( _NUM ) . build ( ) ; cluster . setLeasePeriod ( softLimit , hardLimit ) ; cluster . waitActive ( ) ; DistributedFileSystem fs = cluster . getFileSystem ( ) ; DistributedFileSystem fs _NUM = new DistributedFileSystem ( ) ; fs _NUM . initialize ( fs . getUri ( ) , conf ) ; final Path testPath = new Path ( _STR ) ; final byte [ ] fileContents = AppendTestUtil . initBuffer ( _NUM _NUM ) ; create a new file without closing FSDataOutputStream out = fs . create ( testPath ) ; out . write ( fileContents ) ; Wait for > soft - limit Thread . sleep ( _NUM _NUM _NUM ) ; try { FSDataOutputStream appendStream _NUM = fs _NUM . append ( testPath , EnumSet . of ( CreateFlag . APPEND , CreateFlag . NEW _ BLOCK ) , _NUM _NUM _NUM _NUM , null ) ; appendStream _NUM . write ( fileContents ) ; appendStream _NUM . close ( ) ; assertEquals ( fileContents . length , fs . getFileStatus ( testPath ) . getLen ( ) ) ; make sure we now have _NUM block since the first writer was revoked LocatedBlocks blks = fs . getClient ( ) . getLocatedBlocks ( testPath . toString ( ) , _NUM L ) ; assertEquals ( _NUM , blks . getLocatedBlocks ( ) . size ( ) ) ; for ( LocatedBlock blk : blks . getLocatedBlocks ( ) ) { assertEquals ( fileContents . length , blk . getBlockSize ( ) ) ; } } finally { fs . close ( ) ; fs _NUM . close ( ) ; cluster . shutdown ( ) ; } } 
6759	public void fillContent ( final CmsGallerySearchBean searchObj , List < CmsSearchParamPanel > paramPanels ) { removeNoParamMessage ( ) ; displayResultCount ( getResultsDisplayed ( searchObj ) , searchObj . getResultCount ( ) ) ; m _ hasMoreResults = searchObj . hasMore ( ) ; if ( searchObj . getPage ( ) = = _NUM ) { m _ preset = null ; getList ( ) . scrollToTop ( ) ; getList ( ) . getElement ( ) . getStyle ( ) . setDisplay ( Display . NONE ) ; clearList ( ) ; showParams ( paramPanels ) ; m _ backwardScrollHandler . updateSearchBean ( searchObj ) ; getList ( ) . getElement ( ) . getStyle ( ) . clearDisplay ( ) ; scrollToPreset ( ) ; } else { showParams ( paramPanels ) ; addContent ( searchObj ) ; } showUpload ( searchObj ) ; } 
6760	public V put ( Float key , V value ) { float k ; if ( key = = null ) { k = _ map . getNoEntryKey ( ) ; } else { k = unwrapKey ( key ) ; } return _ map . put ( k , value ) ; } 
6761	public boolean isSet ( _ Fields field ) { if ( field = = null ) { throw new java . lang . IllegalArgumentException ( ) ; } switch ( field ) { case RESULTS : return isSetResults ( ) ; case MORE : return isSetMore ( ) ; } throw new java . lang . IllegalStateException ( ) ; } 
6762	protected boolean hasNextValue ( Object value ) { while ( true ) { try { if ( reader . next ( key , value ) ) { return true ; } if ( initNextReader ( job ) ) { continue ; } return false ; } catch ( IOException | ExecutionSetupException e ) { throw new DrillRuntimeException ( e ) ; } } } 
6763	public void testFlushCreateListDestroy ( ) throws Exception { LOG . debug ( _STR ; FileSystem fs = UTIL . getHBaseCluster ( ) . getMaster ( ) . getMasterFileSystem ( ) . getFileSystem ( ) ; Path rootDir = UTIL . getHBaseCluster ( ) . getMaster ( ) . getMasterFileSystem ( ) . getRootDir ( ) ; SnapshotTestingUtils . createSnapshotAndValidate ( admin , TABLE _ NAME , Bytes . toString ( TEST _ FAM ) , snapshotName , rootDir , fs , true ) ; } 
6764	public E poll ( ) { if ( size = = _NUM ) return null ; return removeFirst ( ) ; } 
6765	public final void setHintTextColor ( ColorStateList colors ) { mHintTextColor = colors ; updateTextColors ( ) ; } 
6766	int [ ] getColumnsWidths ( int widthMeasureSpec , int heightMeasureSpec ) { final int numColumns = getVirtualChildCount ( ) ; if ( mColumnWidths = = null | | numColumns ! = mColumnWidths . length ) { mColumnWidths = new int [ numColumns ] ; } final int [ ] columnWidths = mColumnWidths ; for ( int i = _NUM ; i < numColumns ; i + + ) { final View child = getVirtualChildAt ( i ) ; if ( child ! = null & & child . getVisibility ( ) ! = GONE ) { final LayoutParams layoutParams = ( LayoutParams ) child . getLayoutParams ( ) ; if ( layoutParams . span = = _NUM ) { int spec ; switch ( layoutParams . width ) { case LayoutParams . WRAP _ CONTENT : spec = getChildMeasureSpec ( widthMeasureSpec , _NUM , LayoutParams . WRAP _ CONTENT ) ; break ; case LayoutParams . MATCH _ PARENT : spec = MeasureSpec . makeSafeMeasureSpec ( MeasureSpec . getSize ( heightMeasureSpec ) , MeasureSpec . UNSPECIFIED ) ; break ; default : spec = MeasureSpec . makeMeasureSpec ( layoutParams . width , MeasureSpec . EXACTLY ) ; } child . measure ( spec , spec ) ; final int width = child . getMeasuredWidth ( ) + layoutParams . leftMargin + layoutParams . rightMargin ; columnWidths [ i ] = width ; } else { columnWidths [ i ] = _NUM ; } } else { columnWidths [ i ] = _NUM ; } } return columnWidths ; } 
6767	public static void setAndroidLScanningDisabled ( boolean disabled ) { sAndroidLScanningDisabled = disabled ; BeaconManager instance = sInstance ; if ( instance ! = null ) { instance . applySettings ( ) ; } } 
6768	public int getInnerWidth ( ) { return getWidth ( ) - getStyle ( ) . getHorizontalPadding ( ) ; } 
6769	public void add ( long key , int value ) { if ( size = = capacity & & compare ( keys [ _NUM ] , values [ _NUM ] , key , value ) > = _NUM ) { than value , do nothing return ; } int position ; if ( size < capacity ) { If the heap is not full , increase its size and find the position for new element ( up - heap search ) position = size ; size + + ; while ( position > _NUM ) { int parent = ( position - _NUM ) > > _NUM ; if ( compare ( keys [ parent ] , values [ parent ] , key , value ) < _NUM ) { break ; } values [ position ] = values [ parent ] ; keys [ position ] = keys [ parent ] ; position = parent ; } } else { If the heap is full , remove element from the root and find the position for new element ( down - heap search ) position = removeRootAndFindPosition ( key , value ) ; } Fill position with key value pair keys [ position ] = key ; values [ position ] = value ; } 
6770	public void setDomainCrosshairPaint ( Paint paint ) { if ( paint = = null ) { throw new IllegalArgumentException ( _STR ) ; } this . domainCrosshairPaint = paint ; fireChangeEvent ( ) ; } 
6771	public static void cache ( long sessionId , long blockId , long bytes , StorageDir dir , BlockMetadataManager meta , Evictor evictor ) throws Exception { TempBlockMeta tempBlockMeta = createTempBlock ( sessionId , blockId , bytes , dir ) ; commit block FileUtils . move ( tempBlockMeta . getPath ( ) , tempBlockMeta . getCommitPath ( ) ) ; meta . commitTempBlockMeta ( tempBlockMeta ) ; update evictor if ( evictor instanceof BlockStoreEventListener ) { ( ( BlockStoreEventListener ) evictor ) . onCommitBlock ( sessionId , blockId , dir . toBlockStoreLocation ( ) ) ; } } 
6772	public List readPropertyObjects ( CmsDbContext dbc , CmsProject project , CmsResource resource ) throws CmsDataAccessException { CmsUUID projectId = ( ( dbc . getProjectId ( ) = = null ) | | dbc . getProjectId ( ) . isNullUUID ( ) ) ? project . getUuid ( ) : dbc . getProjectId ( ) ; ResultSet res = null ; PreparedStatement stmt = null ; Connection conn = null ; int mappingType = - _NUM ; Map propertyMap = new HashMap ( ) ; String propertyKey ; String propertyValue ; CmsProperty property ; try { conn = m _ sqlManager . getConnection ( dbc ) ; stmt = m _ sqlManager . getPreparedStatement ( conn , projectId , _STR ) ; stmt . setString ( _NUM , resource . getStructureId ( ) . toString ( ) ) ; stmt . setString ( _NUM , resource . getResourceId ( ) . toString ( ) ) ; res = stmt . executeQuery ( ) ; while ( res . next ( ) ) { propertyKey = null ; propertyValue = null ; mappingType = - _NUM ; propertyKey = res . getString ( _NUM ) ; propertyValue = res . getString ( _NUM ) ; mappingType = res . getInt ( _NUM ) ; property = ( CmsProperty ) propertyMap . get ( propertyKey ) ; if ( property = = null ) { there doesn ' t exist a property object for this key yet property = new CmsProperty ( ) ; property . setName ( propertyKey ) ; propertyMap . put ( propertyKey , property ) ; } if ( mappingType = = CmsProperty . STRUCTURE _ RECORD _ MAPPING ) { this property value is mapped to a structure record property . setStructureValue ( propertyValue ) ; } else if ( mappingType = = CmsProperty . RESOURCE _ RECORD _ MAPPING ) { this property value is mapped to a resource record property . setResourceValue ( propertyValue ) ; } else { throw new CmsDbConsistencyException ( Messages . get ( ) . container ( Messages . ERR _ UNKNOWN _ PROPERTY _ VALUE _ MAPPING _ _NUM , resource . getRootPath ( ) , new Integer ( mappingType ) , propertyKey ) ) ; } property . setOrigin ( resource . getRootPath ( ) ) ; } } catch ( SQLException e ) { throw new CmsDbSqlException ( Messages . get ( ) . container ( Messages . ERR _ GENERIC _ SQL _ _NUM , CmsDbSqlException . getErrorQuery ( stmt ) ) , e ) ; } finally { m _ sqlManager . closeAll ( dbc , conn , stmt , res ) ; } return new ArrayList ( propertyMap . values ( ) ) ; } 
6773	public void createMusicFolder ( MusicFolder musicFolder ) { musicFolderDao . createMusicFolder ( musicFolder ) ; clearMusicFolderCache ( ) ; } 
6774	public Node insertNode ( Node n , String shortName ) { Stack _NUM stack = splitParts ( shortName ) ; org . w _NUM c . dom . Document doc = n . getOwnerDocument ( ) ; Node n _NUM = null ; n = n . getFirstChild ( ) ; for ( int k = _NUM ; k < stack . size ( ) ; + + k ) { String part = ( String ) stack . get ( k ) ; int idx = part . lastIndexOf ( ' [ ' ) ; String name = part . substring ( _NUM , idx ) ; idx = Integer . parseInt ( part . substring ( idx + _NUM , part . length ( ) - _NUM ) ) ; int found = - _NUM ; for ( n _NUM = n . getFirstChild ( ) ; n _NUM ! = null ; n _NUM = n _NUM . getNextSibling ( ) ) { if ( n _NUM . getNodeType ( ) = = Node . ELEMENT _ NODE ) { String s = escapeSom ( n _NUM . getLocalName ( ) ) ; if ( s . equals ( name ) ) { + + found ; if ( found = = idx ) break ; } } } for ( ; found < idx ; + + found ) { n _NUM = doc . createElementNS ( null , name ) ; n _NUM = n . appendChild ( n _NUM ) ; Node attr = doc . createAttributeNS ( XFA _ DATA _ SCHEMA , _STR ) ; n _NUM . getAttributes ( ) . setNamedItemNS ( attr ) ; } n = n _NUM ; } inverseSearchAdd ( inverseSearch , stack , shortName ) ; name _NUM Node . put ( shortName , n _NUM ) ; order . add ( shortName ) ; return n _NUM ; } 
6775	public int run ( Path corpusInput , Path eigenInput , Path output , Path tempOut , double maxError , double minEigenValue , boolean inMemory , Configuration conf ) throws IOException { this . outPath = output ; this . tmpOut = tempOut ; this . maxError = maxError ; this . minEigenValue = minEigenValue ; if ( eigenInput ! = null & & eigensToVerify = = null ) { prepareEigens ( conf , eigenInput , inMemory ) ; } DistributedRowMatrix c = new DistributedRowMatrix ( corpusInput , tempOut , _NUM , _NUM ) ; c . setConf ( conf ) ; corpus = c ; set up eigenverifier and orthoverifier TODO : allow multithreaded execution eigenVerifier = new SimpleEigenVerifier ( ) ; we don ' t currently verify orthonormality here . VectorIterable pairwiseInnerProducts = computePairwiseInnerProducts ( ) ; Map < MatrixSlice , EigenStatus > eigenMetaData = verifyEigens ( ) ; List < Map . Entry < MatrixSlice , EigenStatus > > prunedEigenMeta = pruneEigens ( eigenMetaData ) ; saveCleanEigens ( new Configuration ( ) , prunedEigenMeta ) ; return _NUM ; } 
6776	public String remove ( final String key ) { final String result = get ( key ) ; data . remove ( key ) ; return result ; } 
6777	public V createVertexValue ( ) { return getVertexValueFactory ( ) . newInstance ( ) ; } 
6778	public Header getEvenHeader ( ) { return new XSSFEvenHeader ( getSheetTypeHeaderFooter ( ) ) ; } 
6779	public RexNode convertBetween ( SqlRexContext cx , SqlBetweenOperator op , SqlCall call ) { final List < RexNode > list = convertExpressionList ( cx , call . getOperandList ( ) , op . getOperandTypeChecker ( ) . getConsistency ( ) ) ; final RexNode x = list . get ( SqlBetweenOperator . VALUE _ OPERAND ) ; final RexNode y = list . get ( SqlBetweenOperator . LOWER _ OPERAND ) ; final RexNode z = list . get ( SqlBetweenOperator . UPPER _ OPERAND ) ; final RexBuilder rexBuilder = cx . getRexBuilder ( ) ; RexNode ge _NUM = ge ( rexBuilder , x , y ) ; RexNode le _NUM = le ( rexBuilder , x , z ) ; RexNode and _NUM = and ( rexBuilder , ge _NUM , le _NUM ) ; RexNode res ; final SqlBetweenOperator . Flag symmetric = op . flag ; switch ( symmetric ) { case ASYMMETRIC : res = and _NUM ; break ; case SYMMETRIC : RexNode ge _NUM = ge ( rexBuilder , x , z ) ; RexNode le _NUM = le ( rexBuilder , x , y ) ; RexNode and _NUM = and ( rexBuilder , ge _NUM , le _NUM ) ; res = or ( rexBuilder , and _NUM , and _NUM ) ; break ; default : throw Util . unexpected ( symmetric ) ; } final SqlBetweenOperator betweenOp = ( SqlBetweenOperator ) call . getOperator ( ) ; if ( betweenOp . isNegated ( ) ) { res = rexBuilder . makeCall ( SqlStdOperatorTable . NOT , res ) ; } return res ; } 
6780	public static double getWeightDegradeRate ( String appName ) { FaultToleranceConfig config = getConfig ( appName ) ; return config . getWeightDegradeRate ( ) ; } 
6781	public static void addScriptToLoad ( Configuration conf , DeployedScript script ) { List < DeployedScript > scriptsToLoad = getScriptsToLoad ( conf ) ; if ( scriptsToLoad = = null ) { scriptsToLoad = Lists . < DeployedScript > newArrayList ( ) ; } scriptsToLoad . add ( script ) ; SCRIPTS _ TO _ LOAD . set ( conf , scriptsToLoad ) ; } 
6782	public void resetCropOverlayView ( ) { if ( initializedCropWindow ) { initCropWindow ( mBitmapRect ) ; invalidate ( ) ; } } 
6783	public static XmlENTITY parse ( java . io . InputStream is ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( XmlENTITY ) XmlBeans . getContextTypeLoader ( ) . parse ( is , type , null ) ; } 
6784	public static void setStarRatingInitConfig ( Context context , int limit , String starRatingTextTitle , String starRatingTextMessage , String starRatingTextDismiss ) { StarRatingPreferences srp = loadStarRatingPreferences ( context ) ; if ( limit > = _NUM ) { srp . sessionLimit = limit ; } if ( starRatingTextTitle ! = null ) { srp . dialogTextTitle = starRatingTextTitle ; } if ( starRatingTextMessage ! = null ) { srp . dialogTextMessage = starRatingTextMessage ; } if ( starRatingTextDismiss ! = null ) { srp . dialogTextDismiss = starRatingTextDismiss ; } saveStarRatingPreferences ( context , srp ) ; } 
6785	public static boolean isAccountClass ( GenericValue glAccount , String glAccountClassId ) throws GenericEntityException { if ( glAccount = = null ) { return false ; } GenericValue glAccountClass = glAccount . getRelatedOne ( _STR ) ) ; } return isAccountClassClass ( glAccountClass , glAccountClassId ) ; } 
6786	public static Map < String , String > splitAsMap ( String source , String paramDelim , String keyValDelim ) { int keyValLen = keyValDelim . length ( ) ; use LinkedHashMap to preserve the order of items Map < String , String > params = new LinkedHashMap < String , String > ( ) ; Iterator < String > itParams = CmsStringUtil . splitAsList ( source , paramDelim , true ) . iterator ( ) ; while ( itParams . hasNext ( ) ) { String param = itParams . next ( ) ; int pos = param . indexOf ( keyValDelim ) ; String key = param ; String value = _STR ; if ( pos > _NUM ) { key = param . substring ( _NUM , pos ) ; if ( pos + keyValLen < param . length ( ) ) { value = param . substring ( pos + keyValLen ) ; } } params . put ( key , value ) ; } return params ; } 
6787	public M with ( final String key , final String value ) { put ( key , value ) ; return ( M ) this ; } 
6788	public static Container encloseXNoGrow ( Component . . . cmps ) { return Container . encloseIn ( new BoxLayout ( BoxLayout . X _ AXIS _ NO _ GROW ) , cmps ) ; } 
6789	public void sendAlert ( AlertType alertType , long dataCenterId , Long podId , Long clusterId , String subject , String content ) throws MessagingException , UnsupportedEncodingException { s _ logger . warn ( _STR , _ smtpHost , _ smtpPort , null , _ smtpUsername , _ smtpPassword ) ) ; } sendMessage ( smtpTrans , msg ) ; } } 
6790	public void addNode ( String propertyString , Object object ) { No nulls in the graph . if ( object = = null ) return ; No primitive types in the graph . if ( isPrimitive ( object ) ) return ; Capture where to continue graphing . int index = nodes . size ( ) ; Add the new node or get the existing one . Node newNode = getNode ( object ) ; While the node list is not exhausted . for ( ; index < nodes . size ( ) ; index + + ) { get the next node . Node node = nodes . get ( index ) ; Get the node object . object = node . object ; Get the object class . Class clazz = object . getClass ( ) ; Add object header to label . addHeader ( object , clazz , node ) ; If the object is an array . if ( clazz . isArray ( ) ) { Display detail if under object limit and not excluded . if ( index < arrayLimit & & shouldDetail ( object ) ) { addArrayDetail ( object , node ) ; } else { Indicate there is more than displayed . addContinuation ( node ) ; } } else { Display detail if under object limit and not excluded . if ( index < objectLimit & & shouldDetail ( object ) ) { if ( ! expandCollections & & object instanceof Collection ) { Display collection as an array of enties . addCollectionDetail ( object , clazz , node ) ; } else if ( ! expandCollections & & object instanceof Map ) { Display map as an array of key - > value . addMapDetail ( object , clazz , node ) ; } else if ( displayStatics & & object instanceof Class ) { Display class static fields . addClassDetail ( object , clazz , node ) ; } else { Display as a detailed java object . addObjectDetail ( object , clazz , node ) ; } } else { Indicate there is more than displayed . addContinuation ( node ) ; } } } Add properties to the node if present . if ( propertyString ! = null ) { newNode . addProperties ( propertyString ) ; } } 
6791	public static SingleParser singleParser ( final IO source , final MainOptions options , final String target ) throws IOException { use file specific parser final SingleParser p ; final MainParser mp = options . get ( MainOptions . PARSER ) ; switch ( mp ) { case HTML : p = new HtmlParser ( source , options ) ; break ; case TEXT : p = new TextParser ( source , options ) ; break ; case JSON : p = new JsonParser ( source , options ) ; break ; case CSV : p = new CsvParser ( source , options ) ; break ; default : p = options . get ( MainOptions . INTPARSE ) ? new XMLParser ( source , options ) : new SAXWrapper ( source , options ) ; break ; } p . target ( target ) ; return p ; } 
6792	public List < MtpStorageInfo > getStorageList ( String deviceName ) { MtpDevice device = getDevice ( deviceName ) ; if ( device = = null ) { return null ; } int [ ] storageIds = device . getStorageIds ( ) ; if ( storageIds = = null ) { return null ; } int length = storageIds . length ; ArrayList < MtpStorageInfo > storageList = new ArrayList < MtpStorageInfo > ( length ) ; for ( int i = _NUM ; i < length ; i + + ) { MtpStorageInfo info = device . getStorageInfo ( storageIds [ i ] ) ; if ( info = = null ) { Log . w ( TAG , _STR ) ; } else { storageList . add ( info ) ; } } return storageList ; } 
6793	public static XmlNonPositiveInteger newInstance ( org . apache . xmlbeans . XmlOptions options ) { return ( XmlNonPositiveInteger ) XmlBeans . getContextTypeLoader ( ) . newInstance ( type , options ) ; } 
6794	public VerificationKeysListResponse getKeys ( Principal principal ) { boolean includeSymmetric = includeSymmetricalKeys ( principal ) ; Map < String , KeyInfo > keys = KeyInfo . getKeys ( ) ; List < VerificationKeyResponse > keyResponses = keys . values ( ) . stream ( ) . filter ( k - > includeSymmetric | | k . isAssymetricKey ( ) ) . map ( TokenKeyEndpoint : : getVerificationKeyResponse ) . collect ( Collectors . toList ( ) ) ; return new VerificationKeysListResponse ( keyResponses ) ; } 
6795	public void testGetConnectAddress ( ) throws Exception { for ( ServiceType service : ServiceType . values ( ) ) { getConnectAddress ( service ) ; } } 
6796	public static XmlPositiveInteger parse ( org . apache . xmlbeans . xml . stream . XMLInputStream xis , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , org . apache . xmlbeans . xml . stream . XMLStreamException { return ( XmlPositiveInteger ) XmlBeans . getContextTypeLoader ( ) . parse ( xis , type , options ) ; } 
6797	public void testPingSupplicant ( ) { assertTrue ( mWifiManager . pingSupplicant ( ) ) ; mWifiManager . setWifiEnabled ( false ) ; sleepAfterWifiEnable ( ) ; assertFalse ( mWifiManager . pingSupplicant ( ) ) ; mWifiManager . setWifiEnabled ( true ) ; sleepAfterWifiEnable ( ) ; } 
6798	public static Object element ( List list ) { switch ( list . size ( ) ) { case _NUM : return null ; case _NUM : return list . get ( _NUM ) ; default : throw new RuntimeException ( _STR ) ; } } 
6799	private void doMiniBatchMutate ( BatchOperation < ? > batchOp ) throws IOException { boolean success = false ; WALEdit walEdit = null ; WriteEntry writeEntry = null ; boolean locked = false ; We try to set up a batch in the range [ batchOp . nextIndexToProcess , lastIndexExclusive ) MiniBatchOperationInProgress < Mutation > miniBatchOp = null ; List < RowLock > acquiredRowLocks = Lists . newArrayListWithCapacity ( batchOp . size ( ) ) ; try { STEP _NUM . Try to acquire as many locks as we can and build mini - batch of operations with locked rows miniBatchOp = batchOp . lockRowsAndBuildMiniBatch ( acquiredRowLocks ) ; Ensure we acquire at least one . if ( miniBatchOp . getReadyToWriteCount ( ) < = _NUM ) { Nothing to put / delete - - an exception in the above such as NoSuchColumnFamily ? return ; } lock ( this . updatesLock . readLock ( ) , miniBatchOp . getReadyToWriteCount ( ) ) ; locked = true ; STEP _NUM . Update mini batch of all operations in progress with LATEST _ TIMESTAMP timestamp We should record the timestamp only after we have acquired the rowLock , otherwise , newer puts / deletes are not guaranteed to have a newer timestamp long now = EnvironmentEdgeManager . currentTime ( ) ; batchOp . prepareMiniBatchOperations ( miniBatchOp , now , acquiredRowLocks ) ; STEP _NUM . Build WAL edit List < Pair < NonceKey , WALEdit > > walEdits = batchOp . buildWALEdits ( miniBatchOp ) ; STEP _NUM . Append the WALEdits to WAL and sync . for ( Iterator < Pair < NonceKey , WALEdit > > it = walEdits . iterator ( ) ; it . hasNext ( ) ; ) { Pair < NonceKey , WALEdit > nonceKeyWALEditPair = it . next ( ) ; walEdit = nonceKeyWALEditPair . getSecond ( ) ; NonceKey nonceKey = nonceKeyWALEditPair . getFirst ( ) ; if ( walEdit ! = null & & ! walEdit . isEmpty ( ) ) { writeEntry = doWALAppend ( walEdit , batchOp . durability , batchOp . getClusterIds ( ) , now , nonceKey . getNonceGroup ( ) , nonceKey . getNonce ( ) , batchOp . getOrigLogSeqNum ( ) ) ; } Complete mvcc for all but last writeEntry ( for replay case ) if ( it . hasNext ( ) & & writeEntry ! = null ) { mvcc . complete ( writeEntry ) ; writeEntry = null ; } } STEP _NUM . Write back to memStore NOTE : writeEntry can be null here writeEntry = batchOp . writeMiniBatchOperationsToMemStore ( miniBatchOp , writeEntry ) ; STEP _NUM . Complete MiniBatchOperations : If required calls postBatchMutate ( ) CP hook and complete mvcc for last writeEntry batchOp . completeMiniBatchOperations ( miniBatchOp , writeEntry ) ; writeEntry = null ; success = true ; } finally { Call complete rather than completeAndWait because we probably had error if walKey ! = null if ( writeEntry ! = null ) mvcc . complete ( writeEntry ) ; if ( locked ) { this . updatesLock . readLock ( ) . unlock ( ) ; } releaseRowLocks ( acquiredRowLocks ) ; final int finalLastIndexExclusive = miniBatchOp ! = null ? miniBatchOp . getLastIndexExclusive ( ) : batchOp . size ( ) ; final boolean finalSuccess = success ; batchOp . visitBatchOperations ( true , finalLastIndexExclusive , ( int i ) - > { batchOp . retCodeDetails [ i ] = finalSuccess ? OperationStatus . SUCCESS : OperationStatus . FAILURE ; return true ; } ) ; batchOp . doPostOpCleanupForMiniBatch ( miniBatchOp , walEdit , finalSuccess ) ; batchOp . nextIndexToProcess = finalLastIndexExclusive ; } } 
6800	protected static String [ ] handleQueueEnforcement ( String [ ] argArray ) { SparkConf sparkConf = getSparkProperties ( ) ; Configuration conf = new Configuration ( ) ; int queueParameterIndex = getUserSpecifiedQueueParameterIndex ( argArray ) ; boolean requiredSparkDefaultQueue = false ; if ( sparkConf . getBoolean ( SPARK _ CONF _ DYNAMIC _ ALLOC _ ENABLED , false ) ) { if ( isLargeContainerRequired ( argArray , conf , sparkConf ) ) { Case A requiredSparkDefaultQueue = true ; logger . info ( _STR + argArray [ queueParameterIndex + _NUM ] ) ; argArray [ queueParameterIndex ] = null ; argArray [ queueParameterIndex + _NUM ] = null ; } return argArray ; } 
6801	public BlockMeta moveBlockMeta ( BlockMeta blockMeta , TempBlockMeta tempBlockMeta ) throws BlockDoesNotExistException , WorkerOutOfSpaceException , BlockAlreadyExistsException { StorageDir srcDir = blockMeta . getParentDir ( ) ; StorageDir dstDir = tempBlockMeta . getParentDir ( ) ; srcDir . removeBlockMeta ( blockMeta ) ; BlockMeta newBlockMeta = new BlockMeta ( blockMeta . getBlockId ( ) , blockMeta . getBlockSize ( ) , dstDir ) ; dstDir . removeTempBlockMeta ( tempBlockMeta ) ; dstDir . addBlockMeta ( newBlockMeta ) ; return newBlockMeta ; } 
6802	private static void svm _ binary _ svc _ probability ( svm _ problem prob , svm _ parameter param , double Cp , double Cn , double [ ] probAB ) { int i ; int nr _ fold = _NUM ; int [ ] perm = new int [ prob . l ] ; double [ ] dec _ values = new double [ prob . l ] ; random shuffle for ( i = _NUM ; i < prob . l ; i + + ) perm [ i ] = i ; for ( i = _NUM ; i < prob . l ; i + + ) { int j = i + rand . nextInt ( prob . l - i ) ; do { int tmp = perm [ i ] ; perm [ i ] = perm [ j ] ; perm [ j ] = tmp ; } while ( false ) ; } for ( i = _NUM ; i < nr _ fold ; i + + ) { int begin = i * prob . l / nr _ fold ; int end = ( i + _NUM ) * prob . l / nr _ fold ; int j , k ; svm _ problem subprob = new svm _ problem ( ) ; subprob . l = prob . l - ( end - begin ) ; subprob . x = new svm _ node [ subprob . l ] [ ] ; subprob . y = new double [ subprob . l ] ; k = _NUM ; for ( j = _NUM ; j < begin ; j + + ) { subprob . x [ k ] = prob . x [ perm [ j ] ] ; subprob . y [ k ] = prob . y [ perm [ j ] ] ; + + k ; } for ( j = end ; j < prob . l ; j + + ) { subprob . x [ k ] = prob . x [ perm [ j ] ] ; subprob . y [ k ] = prob . y [ perm [ j ] ] ; + + k ; } int p _ count = _NUM , n _ count = _NUM ; for ( j = _NUM ; j < k ; j + + ) if ( subprob . y [ j ] > _NUM ) p _ count + + ; else n _ count + + ; if ( p _ count = = _NUM & & n _ count = = _NUM ) for ( j = begin ; j < end ; j + + ) dec _ values [ perm [ j ] ] = _NUM ; else if ( p _ count > _NUM & & n _ count = = _NUM ) for ( j = begin ; j < end ; j + + ) dec _ values [ perm [ j ] ] = _NUM ; else if ( p _ count = = _NUM & & n _ count > _NUM ) for ( j = begin ; j < end ; j + + ) dec _ values [ perm [ j ] ] = - _NUM ; else { svm _ parameter subparam = ( svm _ parameter ) param . clone ( ) ; subparam . probability = _NUM ; subparam . C = _NUM . _NUM ; subparam . nr _ weight = _NUM ; subparam . weight _ label = new int [ _NUM ] ; subparam . weight = new double [ _NUM ] ; subparam . weight _ label [ _NUM ] = + _NUM ; subparam . weight _ label [ _NUM ] = - _NUM ; subparam . weight [ _NUM ] = Cp ; subparam . weight [ _NUM ] = Cn ; svm _ model submodel = svm _ train ( subprob , subparam ) ; for ( j = begin ; j < end ; j + + ) { double [ ] dec _ value = new double [ _NUM ] ; svm _ predict _ values ( submodel , prob . x [ perm [ j ] ] , dec _ value ) ; dec _ values [ perm [ j ] ] = dec _ value [ _NUM ] ; ensure + _NUM - _NUM order ; reason not using CV subroutine dec _ values [ perm [ j ] ] * = submodel . label [ _NUM ] ; } } } sigmoid _ train ( prob . l , dec _ values , prob . y , probAB ) ; } 
6803	public static String toString ( JSONArray ja ) throws JSONException { Object e ; int i ; JSONObject jo ; String k ; Iterator keys ; int length ; StringBuilder sb = new StringBuilder ( ) ; String tagName ; String v ; Emit < tagName tagName = ja . getString ( _NUM ) ; XML . noSpace ( tagName ) ; tagName = XML . escape ( tagName ) ; sb . append ( ' < ' ) ; sb . append ( tagName ) ; e = ja . opt ( _NUM ) ; if ( e instanceof JSONObject ) { i = _NUM ; jo = ( JSONObject ) e ; Emit the attributes keys = jo . keys ( ) ; while ( keys . hasNext ( ) ) { k = keys . next ( ) . toString ( ) ; XML . noSpace ( k ) ; v = jo . optString ( k ) ; if ( v ! = null ) { sb . append ( ' ' ) ; sb . append ( XML . escape ( k ) ) ; sb . append ( ' = ' ) ; sb . append ( ' _STR ' ) ; } } } else { i = _NUM ; } Emit content in body length = ja . length ( ) ; if ( i > = length ) { sb . append ( ' / ' ) ; sb . append ( ' > ' ) ; } else { sb . append ( ' > ' ) ; do { e = ja . get ( i ) ; i + = _NUM ; if ( e ! = null ) { if ( e instanceof String ) { sb . append ( XML . escape ( e . toString ( ) ) ) ; } else if ( e instanceof JSONObject ) { sb . append ( toString ( ( JSONObject ) e ) ) ; } else if ( e instanceof JSONArray ) { sb . append ( toString ( ( JSONArray ) e ) ) ; } } } while ( i < length ) ; sb . append ( ' < ' ) ; sb . append ( ' / ' ) ; sb . append ( tagName ) ; sb . append ( ' > ' ) ; } return sb . toString ( ) ; } 
6804	public void testSqlScalar ( ) throws Exception { try ( final TryThreadLocal . Memo ignored = Prepare . THREAD _ EXPAND . push ( true ) ) { checkRun ( path ) ; } } 
6805	protected void sendVolumeUpdate ( int streamType , int oldIndex , int index , int flags ) { streamType = mStreamVolumeAlias [ streamType ] ; if ( streamType = = AudioSystem . STREAM _ MUSIC ) { flags = updateFlagsForSystemAudio ( flags ) ; } mVolumeController . postVolumeChanged ( streamType , flags ) ; } 
6806	public Map < String , Run > getMap ( String commitId , int runNumber , String testName ) { BoolQueryBuilder queryBuilder = QueryBuilders . boolQuery ( ) . must ( termQuery ( _STR , testName . toLowerCase ( ) ) ) ; SearchResponse response = getRequest ( DAO _ INDEX _ KEY , DAO _ TYPE _ KEY ) . setQuery ( queryBuilder ) . setSize ( MAX _ RESULT _ SIZE ) . execute ( ) . actionGet ( ) ; HashMap < String , Run > runs = new HashMap < String , Run > ( ) ; for ( SearchHit hit : response . getHits ( ) . hits ( ) ) { runs . put ( hit . getId ( ) , toRun ( hit ) ) ; } return runs ; } 
6807	public void xtestChecksumVerification ( ) throws Exception { ArtifactRepositoryPolicy policy = new ArtifactRepositoryPolicy ( true , ArtifactRepositoryPolicy . UPDATE _ POLICY _ ALWAYS , ArtifactRepositoryPolicy . CHECKSUM _ POLICY _ FAIL ) ; ArtifactRepository repo = artifactRepositoryFactory . createArtifactRepository ( _STR ) ; } catch ( ChecksumFailedException e ) { expected } } 
6808	public boolean isSet ( _ Fields field ) { if ( field = = null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case ID : return is _ set _ id ( ) ; case NAME : return is _ set _ name ( ) ; case NUM _ TASKS : return is _ set _ num _ tasks ( ) ; case NUM _ WORKERS : return is _ set _ num _ workers ( ) ; case UPTIME _ SECS : return is _ set _ uptime _ secs ( ) ; case STATUS : return is _ set _ status ( ) ; } throw new IllegalStateException ( ) ; } 
6809	private synchronized boolean startDequeue ( ) { int threads = Math . min ( queue . size ( ) , maxThreads ) ; for ( int i = _NUM ; i < threads ; i + + ) { ResourceThread t = ( ResourceThread ) queue . firstElement ( ) ; queue . removeElementAt ( _NUM ) ; running . addElement ( t ) ; threadCount + + ; t . go ( ) ; Thread ( t ) . start ( ) ; } for ( Enumeration e = running . elements ( ) ; e . hasMoreElements ( ) ; ) { ResourceThread t = ( ResourceThread ) e . nextElement ( ) ; t . go ( ) ; } return ( threads > _NUM ) ; } 
6810	public static int chunkContainingPos ( final long [ ] arr , final long pos ) { final int nominalLength = arr . length - _NUM ; assert nominalLength > _NUM ; final long n = arr [ nominalLength ] ; assert _NUM < = pos ; assert pos < n ; final int l = _NUM ; final int r = nominalLength ; that the necessary invariants hold at the beginning of the search assert l < r ; assert arr [ l ] < = pos ; assert pos < arr [ r ] ; return searchForChunkContainingPos ( arr , pos , l , r ) ; } 
6811	public void drawString ( String str , int x , int y ) { setStateToLocal ( ) ; m _ printstream . println ( xTransform ( xScale ( x ) ) + _STR ) ; } 
6812	protected double getMaxRelativeNodeWidth ( double [ ] [ ] nodeRanges , double [ ] [ ] universe ) { int widest = widestDim ( nodeRanges , universe ) ; if ( widest < _NUM ) return _NUM . _NUM ; else return nodeRanges [ widest ] [ WIDTH ] / universe [ widest ] [ WIDTH ] ; } 
6813	public static Map < String , Object > parseParameters ( URI uri ) throws URISyntaxException { String query = uri . getQuery ( ) ; if ( query = = null ) { String schemeSpecificPart = uri . getSchemeSpecificPart ( ) ; int idx = schemeSpecificPart . indexOf ( ' ? ' ) ; if ( idx < _NUM ) { return an empty map return new LinkedHashMap < String , Object > ( _NUM ) ; } else { query = schemeSpecificPart . substring ( idx + _NUM ) ; } } else { query = stripPrefix ( query , _STR ) ; } return parseQuery ( query ) ; } 
6814	public List < Object > handleParseResult ( List < CommandLine > parsedCommands , PrintStream out , Help . Ansi ansi ) { if ( printHelpIfRequested ( parsedCommands , out , ansi ) ) { return Collections . emptyList ( ) ; } CommandLine last = parsedCommands . get ( parsedCommands . size ( ) - _NUM ) ; return Arrays . asList ( execute ( last ) ) ; } 
6815	public void bindAppWidget ( final LauncherAppWidgetInfo item ) { Runnable r = new Runnable ( ) { public void run ( ) { bindAppWidget ( item ) ; } } ; if ( waitUntilResume ( r ) ) { return ; } if ( mIsSafeModeEnabled ) { bindSafeModeWidget ( item ) ; return ; } final long start = DEBUG _ WIDGETS ? SystemClock . uptimeMillis ( ) : _NUM ; if ( DEBUG _ WIDGETS ) { Log . d ( TAG , _STR ) ; } } 
6816	private void fillAboveAndBelow ( View sel , int position ) { final int dividerHeight = mDividerHeight ; if ( ! mStackFromBottom ) { fillUp ( position - _NUM , sel . getTop ( ) - dividerHeight ) ; adjustViewsUpOrDown ( ) ; fillDown ( position + _NUM , sel . getBottom ( ) + dividerHeight ) ; } else { fillDown ( position + _NUM , sel . getBottom ( ) + dividerHeight ) ; adjustViewsUpOrDown ( ) ; fillUp ( position - _NUM , sel . getTop ( ) - dividerHeight ) ; } } 
6817	boolean smoothSlideTo ( float slideOffset , int velocity ) { if ( ! mCanSlide ) { Nothing to do . return false ; } final LayoutParams lp = ( LayoutParams ) mSlideableView . getLayoutParams ( ) ; final int leftBound = getPaddingLeft ( ) + lp . leftMargin ; int x = ( int ) ( leftBound + slideOffset * mSlideRange ) ; if ( mDragHelper . smoothSlideViewTo ( mSlideableView , x , mSlideableView . getTop ( ) ) ) { setAllChildrenVisible ( ) ; ViewCompat . postInvalidateOnAnimation ( this ) ; return true ; } return false ; } 
6818	public Throwable dropSSTables ( final Predicate < SSTableReader > remove , OperationType operationType , Throwable accumulate ) { try ( LogTransaction txnLogs = new LogTransaction ( operationType , this ) ) { Pair < View , View > result = apply ( view - > { Set < SSTableReader > toremove = copyOf ( filter ( view . sstables , and ( remove , notIn ( view . compacting ) ) ) ) ; return updateLiveSet ( toremove , emptySet ( ) ) . apply ( view ) ; } ) ; Set < SSTableReader > removed = Sets . difference ( result . left . sstables , result . right . sstables ) ; assert Iterables . all ( removed , remove ) ; It is important that any method accepting / returning a Throwable never throws an exception , and does its best to complete the instructions given to it List < LogTransaction . Obsoletion > obsoletions = new ArrayList < > ( ) ; accumulate = prepareForObsoletion ( removed , txnLogs , obsoletions , accumulate ) ; try { txnLogs . finish ( ) ; if ( ! removed . isEmpty ( ) ) { accumulate = markObsolete ( obsoletions , accumulate ) ; accumulate = updateSizeTracking ( removed , emptySet ( ) , accumulate ) ; accumulate = release ( selfRefs ( removed ) , accumulate ) ; notifySSTablesChanged - > LeveledManifest . promote doesn ' t like a no - op _STR accumulate = notifySSTablesChanged ( removed , Collections . < SSTableReader > emptySet ( ) , txnLogs . type ( ) , accumulate ) ; } } catch ( Throwable t ) { accumulate = abortObsoletion ( obsoletions , accumulate ) ; accumulate = Throwables . merge ( accumulate , t ) ; } } catch ( Throwable t ) { accumulate = Throwables . merge ( accumulate , t ) ; } return accumulate ; } 
6819	public synchronized void setIndeterminate ( boolean indeterminate ) { if ( ( ! mOnlyIndeterminate | | ! mIndeterminate ) & & indeterminate ! = mIndeterminate ) { mIndeterminate = indeterminate ; if ( indeterminate ) { swap between indeterminate and regular backgrounds mCurrentDrawable = mIndeterminateDrawable ; startAnimation ( ) ; } else { mCurrentDrawable = mProgressDrawable ; stopAnimation ( ) ; } } } 
6820	public static void main ( final String . . . args ) throws Exception { init ( _STR / books . xml ' ) rs . writeSequenceToSAX ( new MySAXHandler ( ) ) ; Closing connection to the Database . close ( conn ) ; } 
6821	private Entry readEntry ( XmlPullParser parser ) throws XmlPullParserException , IOException { parser . require ( XmlPullParser . START _ TAG , ns , _STR ) ) { link = readLink ( parser ) ; } else { skip ( parser ) ; } } return new Entry ( title , summary , link ) ; } 
6822	public RDD < String > toRDDStringIJV ( ) { return MLContextConversionUtil . frameObjectToRDDStringIJV ( frameObject ) ; } 
6823	public void testWriteThenReplace ( ) throws Exception { NPOIFSFileSystem fs = new NPOIFSFileSystem ( ) ; Starts empty , other that Properties and BAT BATBlock bat = fs . getBATBlockAndIndex ( _NUM ) . getBlock ( ) ; assertEquals ( POIFSConstants . END _ OF _ CHAIN , bat . getValueAt ( _NUM ) ) ; assertEquals ( POIFSConstants . FAT _ SECTOR _ BLOCK , bat . getValueAt ( _NUM ) ) ; assertEquals ( POIFSConstants . UNUSED _ BLOCK , bat . getValueAt ( _NUM ) ) ; Write something that uses a main stream byte [ ] main _NUM _NUM _NUM _NUM = new byte [ _NUM _NUM _NUM _NUM ] ; main _NUM _NUM _NUM _NUM [ _NUM ] = - _NUM _NUM ; main _NUM _NUM _NUM _NUM [ _NUM _NUM _NUM _NUM ] = - _NUM _NUM ; DocumentEntry normal = fs . getRoot ( ) . createDocument ( _STR ) ; assertEquals ( _NUM _NUM _NUM _NUM , normal . getSize ( ) ) ; assertEquals ( _NUM _NUM _NUM _NUM , ( ( DocumentNode ) normal ) . getProperty ( ) . getSize ( ) ) ; fs . close ( ) ; } 
6824	protected void initTitleBarStatus ( ) { if ( getUIManager ( ) . isThemeConstant ( _STR ) ; addComponent ( BorderLayout . NORTH , bar ) ; } } } 
6825	public void toPdf ( PdfWriter writer , OutputStream os ) throws IOException { os . write ( ' < ' ) ; os . write ( ' < ' ) ; loop over all the object - pairs in the HashMap PdfName key ; PdfObject value ; int type = _NUM ; for ( Iterator i = hashMap . keySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { key = ( PdfName ) i . next ( ) ; value = ( PdfObject ) hashMap . get ( key ) ; key . toPdf ( writer , os ) ; type = value . type ( ) ; if ( type ! = PdfObject . ARRAY & & type ! = PdfObject . DICTIONARY & & type ! = PdfObject . NAME & & type ! = PdfObject . STRING ) os . write ( ' ' ) ; value . toPdf ( writer , os ) ; } os . write ( ' > ' ) ; os . write ( ' > ' ) ; } 
6826	public Element toDOMElement ( Source source ) throws TransformerException , ParserConfigurationException , IOException , SAXException { Node node = toDOMNode ( source ) ; return toDOMElement ( node ) ; } 
6827	public boolean performAccessibilityAction ( int action , Bundle arguments ) { if ( mAccessibilityDelegate ! = null ) { return mAccessibilityDelegate . performAccessibilityAction ( this , action , arguments ) ; } else { return performAccessibilityActionInternal ( action , arguments ) ; } } 
6828	private void visitImplicitFirstFrame ( ) { There can be at most descriptor . length ( ) + _NUM locals int frameIndex = startFrame ( _NUM , descriptor . length ( ) + _NUM , _NUM ) ; if ( ( access & Opcodes . ACC _ STATIC ) = = _NUM ) { if ( ( access & ACC _ CONSTRUCTOR ) = = _NUM ) { frame [ frameIndex + + ] = Frame . OBJECT | cw . addType ( cw . thisName ) ; } else { Opcodes . UNINITIALIZED _ THIS ; frame [ frameIndex + + ] = _NUM ; } } int i = _NUM ; loop : while ( true ) { int j = i ; switch ( descriptor . charAt ( i + + ) ) { case ' Z ' : case ' C ' : case ' B ' : case ' S ' : case ' I ' : Opcodes . INTEGER ; frame [ frameIndex + + ] = _NUM ; break ; case ' F ' : Opcodes . FLOAT ; frame [ frameIndex + + ] = _NUM ; break ; case ' J ' : Opcodes . LONG ; frame [ frameIndex + + ] = _NUM ; break ; case ' D ' : Opcodes . DOUBLE ; frame [ frameIndex + + ] = _NUM ; break ; case ' [ ' : while ( descriptor . charAt ( i ) = = ' [ ' ) { + + i ; } if ( descriptor . charAt ( i ) = = ' L ' ) { + + i ; while ( descriptor . charAt ( i ) ! = ' ; ' ) { + + i ; } } frame [ frameIndex + + ] = Frame . OBJECT | cw . addType ( descriptor . substring ( j , + + i ) ) ; break ; case ' L ' : while ( descriptor . charAt ( i ) ! = ' ; ' ) { + + i ; } frame [ frameIndex + + ] = Frame . OBJECT | cw . addType ( descriptor . substring ( j + _NUM , i + + ) ) ; break ; default : break loop ; } } frame [ _NUM ] = frameIndex - _NUM ; endFrame ( ) ; } 
6829	public void updateHeaders ( ) { XSSFSheet sheet = ( XSSFSheet ) getParent ( ) ; CellReference ref = getStartCellReference ( ) ; if ( ref = = null ) return ; int headerRow = ref . getRow ( ) ; int firstHeaderColumn = ref . getCol ( ) ; XSSFRow row = sheet . getRow ( headerRow ) ; DataFormatter formatter = new DataFormatter ( ) ; if ( row ! = null & & row . getCTRow ( ) . validate ( ) ) { int cellnum = firstHeaderColumn ; CTTableColumns ctTableColumns = getCTTable ( ) . getTableColumns ( ) ; if ( ctTableColumns ! = null ) { for ( CTTableColumn col : ctTableColumns . getTableColumnList ( ) ) { XSSFCell cell = row . getCell ( cellnum ) ; if ( cell ! = null ) { col . setName ( formatter . formatCellValue ( cell ) ) ; } cellnum + + ; } } } tableColumns = null ; columnMap = null ; xmlColumnPrs = null ; commonXPath = null ; } 
6830	public void onInitializeAccessibilityNodeInfoForItem ( Recycler recycler , State state , View host , AccessibilityNodeInfo info ) { int rowIndexGuess = canScrollVertically ( ) ? getPosition ( host ) : _NUM ; int columnIndexGuess = canScrollHorizontally ( ) ? getPosition ( host ) : _NUM ; final AccessibilityNodeInfo . CollectionItemInfo itemInfo = AccessibilityNodeInfo . CollectionItemInfo . obtain ( rowIndexGuess , _NUM , columnIndexGuess , _NUM , false , false ) ; info . setCollectionItemInfo ( itemInfo ) ; } 
6831	public void testFullBackupSetExist ( ) throws Exception { LOG . info ( _STR ) ; hba . close ( ) ; } } 
6832	public void writeBytes ( byte [ ] data , int offset , int length ) throws IOException { prepareValue ( ) ; updateLength ( length ) ; buffer . writeBytes ( data , offset , length ) ; finishValue ( ) ; } 
6833	 @ Around ( _STR ; } } final FlowChangeConfigureDetails actionDetails = new FlowChangeConfigureDetails ( ) ; actionDetails . setName ( property ) ; actionDetails . setValue ( newValue ) ; actionDetails . setPreviousValue ( oldValue ) ; create a configuration action FlowChangeAction configurationAction = new FlowChangeAction ( ) ; configurationAction . setUserIdentity ( user . getIdentity ( ) ) ; configurationAction . setOperation ( operation ) ; configurationAction . setTimestamp ( actionTimestamp ) ; configurationAction . setSourceId ( reportingTask . getIdentifier ( ) ) ; configurationAction . setSourceName ( reportingTask . getName ( ) ) ; configurationAction . setSourceType ( Component . ReportingTask ) ; configurationAction . setComponentDetails ( taskDetails ) ; configurationAction . setActionDetails ( actionDetails ) ; actions . add ( configurationAction ) ; } } determine the new executing state final ScheduledState updatedScheduledState = reportingTask . getScheduledState ( ) ; determine if the running state has changed and its not disabled if ( scheduledState ! = updatedScheduledState ) { create a reporting task action FlowChangeAction taskAction = new FlowChangeAction ( ) ; taskAction . setUserIdentity ( user . getIdentity ( ) ) ; taskAction . setTimestamp ( new Date ( ) ) ; taskAction . setSourceId ( reportingTask . getIdentifier ( ) ) ; taskAction . setSourceName ( reportingTask . getName ( ) ) ; taskAction . setSourceType ( Component . ReportingTask ) ; taskAction . setComponentDetails ( taskDetails ) ; set the operation accordingly if ( ScheduledState . RUNNING . equals ( updatedScheduledState ) ) { taskAction . setOperation ( Operation . Start ) ; } else if ( ScheduledState . DISABLED . equals ( updatedScheduledState ) ) { taskAction . setOperation ( Operation . Disable ) ; } else { state is now stopped . . . consider the previous state if ( ScheduledState . RUNNING . equals ( scheduledState ) ) { taskAction . setOperation ( Operation . Stop ) ; } else if ( ScheduledState . DISABLED . equals ( scheduledState ) ) { taskAction . setOperation ( Operation . Enable ) ; } } actions . add ( taskAction ) ; } ensure there are actions to record if ( ! actions . isEmpty ( ) ) { save the actions saveActions ( actions , logger ) ; } } return updatedReportingTask ; } 
6834	public void addSignatureField ( List < PDSignatureField > sigFields , SignatureInterface signatureInterface , SignatureOptions options ) throws IOException { PDDocumentCatalog catalog = getDocumentCatalog ( ) ; catalog . getCOSObject ( ) . setNeedToBeUpdated ( true ) ; PDAcroForm acroForm = catalog . getAcroForm ( ) ; if ( acroForm = = null ) { acroForm = new PDAcroForm ( this ) ; catalog . setAcroForm ( acroForm ) ; } COSDictionary acroFormDict = acroForm . getCOSObject ( ) ; acroFormDict . setDirect ( true ) ; acroFormDict . setNeedToBeUpdated ( true ) ; if ( ! acroForm . isSignaturesExist ( ) ) { _NUM if at least one signature field is available acroForm . setSignaturesExist ( true ) ; } List < PDField > acroformFields = acroForm . getFields ( ) ; for ( PDSignatureField sigField : sigFields ) { sigField . getCOSObject ( ) . setNeedToBeUpdated ( true ) ; Check if the field already exists boolean checkSignatureField = checkSignatureField ( acroForm . getFieldIterator ( ) , sigField ) ; if ( checkSignatureField ) { sigField . getCOSObject ( ) . setNeedToBeUpdated ( true ) ; } else { acroformFields . add ( sigField ) ; } Check if we need to add a signature if ( sigField . getSignature ( ) ! = null ) { sigField . getCOSObject ( ) . setNeedToBeUpdated ( true ) ; if ( options = = null ) { TODO ? ? } addSignature ( sigField . getSignature ( ) , signatureInterface , options ) ; } } } 
6835	public boolean isInManagedCall ( ) { try { if ( isServiceConnected ( ) ) { return getTelecomService ( ) . isInManagedCall ( mContext . getOpPackageName ( ) ) ; } } catch ( RemoteException e ) { Log . e ( TAG , _STR , e ) ; } return false ; } 
6836	public Object set ( int index , Object obj ) { list . lock . lock ( ) ; try { checkIndexExlusive ( index , read . size ) ; checkModifications ( ) ; Object result = list . set ( index + start , obj ) ; read = new SubListReadData ( read . size , list . getData ( ) ) ; return result ; } finally { list . lock . unlock ( ) ; } } 
6837	public final double classifyInstance ( Instance instance ) throws Exception { int theSubset ; theSubset = whichSubset ( instance ) ; if ( theSubset > - _NUM ) return ( double ) m _ distribution . maxClass ( theSubset ) ; else return ( double ) m _ distribution . maxClass ( ) ; } 
6838	public void setTickTextFormat ( byte tickTextFormat ) { this . tickTextFormat = tickTextFormat ; if ( ! attachedToWindow ) return ; updateBackgroundBitmap ( ) ; invalidate ( ) ; } 
6839	public static String getLocalHostName ( ) throws UnknownHostException { return chooseAddress ( ) . getHostName ( ) ; } 
6840	public static < T > T createFromModel ( String baseAddress , Class < T > cls , String modelRef , List < ? > providers , String configLocation ) { JAXRSClientFactoryBean bean = WebClient . getBean ( baseAddress , configLocation ) ; bean . setProviders ( providers ) ; bean . setModelRef ( modelRef ) ; bean . setServiceClass ( cls ) ; return bean . create ( cls ) ; } 
6841	public void writeFile ( String resourceName , String exportpoint , byte [ ] content ) { writeResource ( resourceName , exportpoint , content ) ; } 
6842	public boolean removeField ( String name , int page ) { Item item = getFieldItem ( name ) ; if ( item = = null ) return false ; PdfDictionary acroForm = ( PdfDictionary ) PdfReader . getPdfObject ( reader . getCatalog ( ) . get ( PdfName . ACROFORM ) , reader . getCatalog ( ) ) ; if ( acroForm = = null ) return false ; PdfArray arrayf = acroForm . getAsArray ( PdfName . FIELDS ) ; if ( arrayf = = null ) return false ; for ( int k = _NUM ; k < item . size ( ) ; + + k ) { int pageV = item . getPage ( k ) . intValue ( ) ; if ( page ! = - _NUM & & page ! = pageV ) continue ; PdfIndirectReference ref = item . getWidgetRef ( k ) ; PdfDictionary wd = item . getWidget ( k ) ; PdfDictionary pageDic = reader . getPageN ( pageV ) ; PdfArray annots = pageDic . getAsArray ( PdfName . ANNOTS ) ; if ( annots ! = null ) { if ( removeRefFromArray ( annots , ref ) = = _NUM ) { pageDic . remove ( PdfName . ANNOTS ) ; markUsed ( pageDic ) ; } else markUsed ( annots ) ; } PdfReader . killIndirect ( ref ) ; PdfIndirectReference kid = ref ; while ( ( ref = wd . getAsIndirectObject ( PdfName . PARENT ) ) ! = null ) { wd = wd . getAsDict ( PdfName . PARENT ) ; PdfArray kids = wd . getAsArray ( PdfName . KIDS ) ; if ( removeRefFromArray ( kids , kid ) ! = _NUM ) break ; kid = ref ; PdfReader . killIndirect ( ref ) ; } if ( ref = = null ) { removeRefFromArray ( arrayf , kid ) ; markUsed ( arrayf ) ; } if ( page ! = - _NUM ) { item . remove ( k ) ; - - k ; } } if ( page = = - _NUM | | item . size ( ) = = _NUM ) fields . remove ( name ) ; return true ; } 
6843	public AggregatedMetrics add ( String name , long value , String hostnamePartitionId ) { AggregatedMetricLong aggregatedMetric = ( AggregatedMetricLong ) metrics . get ( name ) ; if ( aggregatedMetric = = null ) { aggregatedMetric = new AggregatedMetricLong ( ) ; metrics . put ( name , aggregatedMetric ) ; } aggregatedMetric . addItem ( value , hostnamePartitionId ) ; return this ; } 
6844	public < T _NUM , T _NUM , T _NUM , T _NUM , T _NUM , T _NUM , T _NUM , T _NUM , T _NUM , T _NUM _NUM , T _NUM _NUM , T _NUM _NUM , T _NUM _NUM , T _NUM _NUM > Tuple _NUM _NUM < T _NUM , T _NUM , T _NUM , T _NUM , T _NUM , T _NUM , T _NUM , T _NUM , T _NUM , T _NUM _NUM , T _NUM _NUM , T _NUM _NUM , T _NUM _NUM , T _NUM _NUM > getTuple ( String outputName _NUM , String outputName _NUM , String outputName _NUM , String outputName _NUM , String outputName _NUM , String outputName _NUM , String outputName _NUM , String outputName _NUM , String outputName _NUM , String outputName _NUM _NUM , String outputName _NUM _NUM , String outputName _NUM _NUM , String outputName _NUM _NUM , String outputName _NUM _NUM ) { return new Tuple _NUM _NUM < > ( ( T _NUM ) outputValue ( outputName _NUM ) , ( T _NUM ) outputValue ( outputName _NUM ) , ( T _NUM ) outputValue ( outputName _NUM ) , ( T _NUM ) outputValue ( outputName _NUM ) , ( T _NUM ) outputValue ( outputName _NUM ) , ( T _NUM ) outputValue ( outputName _NUM ) , ( T _NUM ) outputValue ( outputName _NUM ) , ( T _NUM ) outputValue ( outputName _NUM ) , ( T _NUM ) outputValue ( outputName _NUM ) , ( T _NUM _NUM ) outputValue ( outputName _NUM _NUM ) , ( T _NUM _NUM ) outputValue ( outputName _NUM _NUM ) , ( T _NUM _NUM ) outputValue ( outputName _NUM _NUM ) , ( T _NUM _NUM ) outputValue ( outputName _NUM _NUM ) , ( T _NUM _NUM ) outputValue ( outputName _NUM _NUM ) ) ; } 
6845	public static final double exp ( double a ) { return ieee _NUM _NUM _NUM _ exp ( a ) ; } 
6846	private synchronized void requestCorePoolDecrease ( ) { if ( scheduler . getCorePoolSize ( ) > MIN _ CORE _ POOL _ SIZE ) { scheduler . setCorePoolSize ( scheduler . getCorePoolSize ( ) - _NUM ) ; printChoreServiceDetails ( _STR ) ; } } 
6847	public List < BluetoothHeadsetClientCall > getCurrentCalls ( BluetoothDevice device ) { if ( DBG ) log ( _STR ) ; return null ; } 
6848	public void update ( ) { applyMinHeight ( ) ; } 
6849	public static DERBMPString getInstance ( Object obj ) { if ( obj = = null | | obj instanceof DERBMPString ) { return ( DERBMPString ) obj ; } if ( obj instanceof byte [ ] ) { try { return ( DERBMPString ) fromByteArray ( ( byte [ ] ) obj ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( _STR + obj . getClass ( ) . getName ( ) ) ; } 
6850	public Object pop ( ) { if ( size ( ) = = _NUM ) throw new EmptyStackException ( ) ; Object ret = get ( size ( ) - _NUM ) ; remove ( size ( ) - _NUM ) ; return ret ; } 
6851	public void testUpgradeWithJournalNodes ( ) throws IOException , URISyntaxException { MiniQJMHACluster qjCluster = null ; FileSystem fs = null ; try { Builder builder = new MiniQJMHACluster . Builder ( conf ) ; builder . getDfsBuilder ( ) . numDataNodes ( _NUM ) ; qjCluster = builder . build ( ) ; MiniDFSCluster cluster = qjCluster . getDfsCluster ( ) ; No upgrade is in progress at the moment . checkJnPreviousDirExistence ( qjCluster , false ) ; checkClusterPreviousDirExistence ( cluster , false ) ; assertCTimesEqual ( cluster ) ; Transition NN _NUM to active and do some FS ops . cluster . transitionToActive ( _NUM ) ; fs = HATestUtil . configureFailoverFs ( cluster , conf ) ; assertTrue ( fs . mkdirs ( new Path ( _STR ) ) ) ; assertCTimesEqual ( cluster ) ; } finally { if ( fs ! = null ) { fs . close ( ) ; } if ( qjCluster ! = null ) { qjCluster . shutdown ( ) ; } } } 
6852	private void prepareForSuperstep ( GraphState graphState ) { serviceWorker . prepareSuperstep ( ) ; serviceWorker . getWorkerContext ( ) . setGraphState ( graphState ) ; serviceWorker . getWorkerContext ( ) . setupSuperstep ( serviceWorker ) ; GiraphTimerContext preSuperstepTimer = wcPreSuperstepTimer . time ( ) ; serviceWorker . getWorkerContext ( ) . preSuperstep ( ) ; preSuperstepTimer . stop ( ) ; context . progress ( ) ; for ( WorkerObserver obs : serviceWorker . getWorkerObservers ( ) ) { obs . preSuperstep ( graphState . getSuperstep ( ) ) ; context . progress ( ) ; } } 
6853	public void paintShading ( PdfShading shading ) { writer . addSimpleShading ( shading ) ; PageResources prs = getPageResources ( ) ; PdfName name = prs . addShading ( shading . getShadingName ( ) , shading . getShadingReference ( ) ) ; content . append ( name . getBytes ( ) ) . append ( _STR ) . append _ i ( separator ) ; ColorDetails details = shading . getColorDetails ( ) ; if ( details ! = null ) prs . addColor ( details . getColorName ( ) , details . getIndirectReference ( ) ) ; } 
6854	public static Logger getFormatterLogger ( final String name ) { return name = = null ? getFormatterLogger ( StackLocatorUtil . getCallerClass ( _NUM ) ) : getLogger ( name , StringFormatterMessageFactory . INSTANCE ) ; } 
6855	public static String unHide ( final String key ) { return isHidden ( key ) ? key . substring ( HIDDEN _ PREFIX _ LENGTH ) : key ; } 
6856	protected void repairBrokenRelations ( CmsDbContext dbc , CmsUUID projectId , CmsUUID structureId , String rootPath ) throws CmsDataAccessException { try { Query q = m _ sqlManager . createQuery ( dbc , projectId , C _ RELATIONS _ REPAIR _ BROKEN ) ; q . setParameter ( _NUM , rootPath ) ; @ SuppressWarnings ( _STR ) List < I _ CmsDAOResourceRelations > res = q . getResultList ( ) ; I _ CmsDAOResourceRelations newR ; for ( I _ CmsDAOResourceRelations rr : res ) { newR = CmsProject . isOnlineProject ( projectId ) ? new CmsDAOOnlineResourceRelations ( ) : new CmsDAOOfflineResourceRelations ( ) ; newR . setRelationSourceId ( rr . getRelationSourceId ( ) ) ; newR . setRelationSourcePath ( rr . getRelationSourcePath ( ) ) ; newR . setRelationTargetId ( structureId . toString ( ) ) ; newR . setRelationTargetPath ( rr . getRelationTargetPath ( ) ) ; newR . setRelationType ( rr . getRelationType ( ) ) ; m _ sqlManager . remove ( dbc , rr ) ; m _ sqlManager . persist ( dbc , newR ) ; } } catch ( PersistenceException e ) { throw new CmsDataAccessException ( Messages . get ( ) . container ( Messages . ERR _ JPA _ PERSITENCE , e ) , e ) ; } } 
6857	public static boolean isEmptyOrNull ( PieDataset dataset ) { if ( dataset = = null ) { return true ; } int itemCount = dataset . getItemCount ( ) ; if ( itemCount = = _NUM ) { return true ; } for ( int item = _NUM ; item < itemCount ; item + + ) { Number y = dataset . getValue ( item ) ; if ( y ! = null ) { double yy = y . doubleValue ( ) ; if ( yy > _NUM . _NUM ) { return false ; } } } return true ; } 
6858	public void evaluate ( ObjectStream < TokenSample > samples , int nFolds ) throws IOException { CrossValidationPartitioner < TokenSample > partitioner = new CrossValidationPartitioner < > ( samples , nFolds ) ; while ( partitioner . hasNext ( ) ) { CrossValidationPartitioner . TrainingSampleStream < TokenSample > trainingSampleStream = partitioner . next ( ) ; Maybe throws IOException if temporary file handling fails . . . TokenizerModel model = TokenizerME . train ( trainingSampleStream , this . factory , params ) ; TokenizerEvaluator evaluator = new TokenizerEvaluator ( new TokenizerME ( model ) , listeners ) ; evaluator . evaluate ( trainingSampleStream . getTestSampleStream ( ) ) ; fmeasure . mergeInto ( evaluator . getFMeasure ( ) ) ; } } 
6859	private static boolean getOsMatches ( final String osNamePrefix , final String osVersionPrefix ) { return isOSMatch ( OS _ NAME , OS _ VERSION , osNamePrefix , osVersionPrefix ) ; } 
6860	private void reportTablesInFlux ( ) { AtomicInteger numSkipped = new AtomicInteger ( _NUM ) ; TableDescriptor [ ] allTables = getTables ( numSkipped ) ; errors . print ( _STR + td . getColumnFamilyCount ( ) ) ; } } } 
6861	public static < T extends Comparable < ? super T > > T median ( final T . . . items ) { Validate . notEmpty ( items ) ; Validate . noNullElements ( items ) ; final TreeSet < T > sort = new TreeSet < > ( ) ; Collections . addAll ( sort , items ) ; we know all items added were T instances @ SuppressWarnings ( _STR ) final T result = ( T ) sort . toArray ( ) [ ( sort . size ( ) - _NUM ) / _NUM ] ; return result ; } 
6862	private void testEventsAfterLeaderKill ( int nodes ) throws Throwable { List < RaftServer > servers = createServers ( nodes ) ; RaftClient client = createClient ( ) ; PrimitiveProxy session = createSession ( client ) ; session . addEventListener ( event - > { threadAssertNotNull ( event ) ; resume ( ) ; } ) ; for ( int i = _NUM ; i < _NUM _NUM ; i + + ) { session . invoke ( EVENT , clientSerializer : : encode , true ) . thenRun ( this : : resume ) ; await ( _NUM _NUM _NUM _NUM _NUM , _NUM ) ; } session . invoke ( EVENT , clientSerializer : : encode , true ) . thenRun ( this : : resume ) ; RaftServer leader = servers . stream ( ) . filter ( s - > s . getRole ( ) = = RaftServer . Role . LEADER ) . findFirst ( ) . get ( ) ; leader . shutdown ( ) . get ( _NUM _NUM , TimeUnit . SECONDS ) ; await ( _NUM _NUM _NUM _NUM _NUM ) ; for ( int i = _NUM ; i < _NUM _NUM ; i + + ) { session . invoke ( EVENT , clientSerializer : : encode , true ) . thenRun ( this : : resume ) ; await ( _NUM _NUM _NUM _NUM _NUM , _NUM ) ; } } 
6863	private float drawLineWithSelection ( TokenPainter painter , Token token , Graphics _NUM D g , float x , float y , int selStart , int selEnd ) { The x - value at the end of our text . float nextX = x ; boolean useSTC = host . getUseSelectedTextColor ( ) ; while ( token ! = null & & token . isPaintable ( ) & & nextX < clipEnd ) { Selection starts in this token if ( token . containsPosition ( selStart ) ) { if ( selStart > token . getOffset ( ) ) { tempToken . copyFrom ( token ) ; tempToken . textCount = selStart - tempToken . getOffset ( ) ; nextX = painter . paint ( tempToken , g , nextX , y , host , this , clipStart ) ; tempToken . textCount = token . length ( ) ; tempToken . makeStartAt ( selStart ) ; Clone required since token and tempToken must be different tokens for else statement below token = new TokenImpl ( tempToken ) ; } int tokenLen = token . length ( ) ; int selCount = Math . min ( tokenLen , selEnd - token . getOffset ( ) ) ; if ( selCount = = tokenLen ) { nextX = painter . paintSelected ( token , g , nextX , y , host , this , clipStart , useSTC ) ; } else { tempToken . copyFrom ( token ) ; tempToken . textCount = selCount ; nextX = painter . paintSelected ( tempToken , g , nextX , y , host , this , clipStart , useSTC ) ; tempToken . textCount = token . length ( ) ; tempToken . makeStartAt ( token . getOffset ( ) + selCount ) ; token = tempToken ; nextX = painter . paint ( token , g , nextX , y , host , this , clipStart ) ; } } else Selection ends in this token if ( token . containsPosition ( selEnd ) ) { tempToken . copyFrom ( token ) ; tempToken . textCount = selEnd - tempToken . getOffset ( ) ; nextX = painter . paintSelected ( tempToken , g , nextX , y , host , this , clipStart , useSTC ) ; tempToken . textCount = token . length ( ) ; tempToken . makeStartAt ( selEnd ) ; token = tempToken ; nextX = painter . paint ( token , g , nextX , y , host , this , clipStart ) ; } else This token is entirely selected if ( token . getOffset ( ) > = selStart & & token . getEndOffset ( ) < = selEnd ) { nextX = painter . paintSelected ( token , g , nextX , y , host , this , clipStart , useSTC ) ; } else This token is entirely unselected { nextX = painter . paint ( token , g , nextX , y , host , this , clipStart ) ; } token = token . getNextToken ( ) ; } but don ' t because I ' m just too lazy . if ( host . getEOLMarkersVisible ( ) ) { g . setColor ( host . getForegroundForTokenType ( Token . WHITESPACE ) ) ; g . setFont ( host . getFontForTokenType ( Token . WHITESPACE ) ) ; g . drawString ( _STR , nextX , y ) ; } Return the x - coordinate at the end of the painted text . return nextX ; } 
6864	public static int [ ] range ( int from , int to , int increment ) { int diff = Math . abs ( from - to ) ; int [ ] ret = new int [ diff / increment ] ; if ( ret . length < _NUM ) ret = new int [ _NUM ] ; if ( from < to ) { int count = _NUM ; for ( int i = from ; i < to ; i + = increment ) { if ( count > = ret . length ) break ; ret [ count + + ] = i ; } } else if ( from > to ) { int count = _NUM ; for ( int i = from - _NUM ; i > = to ; i - = increment ) { if ( count > = ret . length ) break ; ret [ count + + ] = i ; } } return ret ; } 
6865	 @ SuppressWarnings ( _STR + this . name , module ) ; } Object nulledKey = fromKey ( key ) ; CacheLine < V > oldCacheLine ; V oldValue ; oldCacheLine = memoryTable . remove ( nulledKey ) ; oldValue = oldCacheLine ! = null ? oldCacheLine . getValue ( ) : null ; if ( oldCacheLine ! = null ) { cancel ( oldCacheLine ) ; } if ( oldValue ! = null ) { noteRemoval ( ( K ) key , oldValue ) ; if ( countRemove ) removeHitCount . incrementAndGet ( ) ; return oldValue ; } else { if ( countRemove ) removeMissCount . incrementAndGet ( ) ; return null ; } } 
6866	public void write ( int value , int repetitionLevel , int definitionLevel ) { if ( DEBUG ) log ( value , repetitionLevel , definitionLevel ) ; repetitionLevel ( repetitionLevel ) ; definitionLevel ( definitionLevel ) ; dataColumn . writeInteger ( value ) ; statistics . updateStats ( value ) ; + + valueCount ; } 
6867	private Collection < Resource > getRequestResources ( Long clusterId , String clusterName , List < Long > requestIds , Set < String > requestedPropertyIds ) { Map < Long , Resource > resourceMap = new HashMap < > ( ) ; List < RequestEntity > requests = s _ requestDAO . findByPks ( requestIds , true ) ; todo : this was ( and still is ) in ActionManager but this class was changed to not use ActionManager recently List < RequestEntity > topologyRequestEntities = new ArrayList < > ( ) ; Collection < ? extends org . apache . ambari . server . actionmanager . Request > topologyRequests = topologyManager . getRequests ( requestIds ) ; for ( org . apache . ambari . server . actionmanager . Request request : topologyRequests ) { topologyRequestEntities . add ( request . constructNewPersistenceEntity ( ) ) ; } if requests is empty , map is Collections . emptyMap ( ) which can ' t be added to so create a new map if ( requests . isEmpty ( ) ) { requests = new ArrayList < > ( ) ; } requests . addAll ( topologyRequestEntities ) ; for ( RequestEntity re : requests ) { if ( if cluster IS NOT requested AND the db request is not for a cluster ( null = = clusterId & & ( null = = re . getClusterId ( ) | | - _NUM L = = re . getClusterId ( ) ) ) | | ( null ! = clusterId & & null ! = re . getRequestId ( ) & & re . getClusterId ( ) . equals ( clusterId ) ) ) { if cluster IS requested and the request has a cluster id equal to the one requested Resource r = getRequestResource ( re , clusterName , requestedPropertyIds ) ; resourceMap . put ( re . getRequestId ( ) , r ) ; } } return resourceMap . values ( ) ; } 
6868	private String nextTokenFromStream ( ) { StringBuilder sb = new StringBuilder ( ) ; if ( streamTokenizer . ttype = = StreamTokenizer . TT _ WORD ) { sb . append ( streamTokenizer . sval ) ; } else if ( streamTokenizer . ttype = = StreamTokenizer . TT _ NUMBER ) { sb . append ( streamTokenizer . nval ) ; } else if ( streamTokenizer . ttype = = StreamTokenizer . TT _ EOL ) { try { while ( streamTokenizer . ttype = = StreamTokenizer . TT _ EOL ) streamTokenizer . nextToken ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } else if ( streamHasMoreTokens ( ) ) return nextTokenFromStream ( ) ; String ret = sb . toString ( ) ; if ( tokenPreProcess ! = null ) ret = tokenPreProcess . preProcess ( ret ) ; return ret ; } 
6869	public TarEntry getNextEntry ( ) throws IOException { closeCurrentEntry ( ) ; byte [ ] header = new byte [ TarConstants . HEADER _ BLOCK ] ; byte [ ] theader = new byte [ TarConstants . HEADER _ BLOCK ] ; int tr = _NUM ; Read full header while ( tr < TarConstants . HEADER _ BLOCK ) { int res = read ( theader , _NUM , TarConstants . HEADER _ BLOCK - tr ) ; if ( res < _NUM ) { break ; } System . arraycopy ( theader , _NUM , header , tr , res ) ; tr + = res ; } Check if record is null boolean eof = true ; for ( byte b : header ) { if ( b ! = _NUM ) { eof = false ; break ; } } if ( ! eof ) { bytesRead + = header . length ; currentEntry = new TarEntry ( header ) ; } return currentEntry ; } 
6870	public CmsResource initResource ( CmsResource resource , CmsObject cms , HttpServletRequest req , HttpServletResponse res ) throws CmsResourceInitException , CmsSecurityException { check if the resource was already found boolean abort = ( resource ! = null ) ; check if the resource comes from the / system / folder abort | = cms . getRequestContext ( ) . getUri ( ) . startsWith ( CmsWorkplace . VFS _ PATH _ SYSTEM ) ; if ( abort ) { skip in all cases above return resource ; } String path = cms . getRequestContext ( ) . getUri ( ) ; path = CmsFileUtil . removeTrailingSeparator ( path ) ; try { cms . readResource ( path ) ; } catch ( CmsSecurityException e ) { no resource should be displayed , even if the user would have access to the detail page . return null ; } catch ( CmsException e ) { ignore } String detailName = CmsResource . getName ( path ) ; try { CmsUUID detailId = cms . readIdForUrlName ( detailName ) ; if ( detailId ! = null ) { check existence / permissions CmsResource detailRes = cms . readResource ( detailId ) ; change OpenCms request URI to detail page CmsResource detailPage = cms . readDefaultFile ( CmsResource . getFolderPath ( path ) ) ; if ( ! isValidDetailPage ( cms , detailPage , detailRes ) ) { return null ; } if ( res ! = null ) { response will be null if this run through the init handler is only for determining the locale req . setAttribute ( ATTR _ DETAIL _ CONTENT _ RESOURCE , detailRes ) ; } set the resource path cms . getRequestContext ( ) . setUri ( cms . getSitePath ( detailPage ) ) ; return detailPage ; } } catch ( CmsPermissionViolationException e ) { trigger the permission denied handler throw e ; } catch ( CmsResourceInitException e ) { throw e ; } catch ( Throwable e ) { String uri = cms . getRequestContext ( ) . getUri ( ) ; CmsMessageContainer msg = Messages . get ( ) . container ( Messages . ERR _ RESCOURCE _ NOT _ FOUND _ _NUM , uri ) ; LOG . error ( msg . key ( ) , e ) ; throw new CmsResourceInitException ( msg , e ) ; } return null ; } 
6871	public static Set < String > findFullPrefixKeys ( Properties properties , Optional < String > keyPrefix ) { TreeSet < String > propNames = new TreeSet < > ( ) ; for ( Map . Entry < Object , Object > entry : properties . entrySet ( ) ) { String entryKey = entry . getKey ( ) . toString ( ) ; if ( StringUtils . startsWith ( entryKey , keyPrefix . or ( StringUtils . EMPTY ) ) ) { propNames . add ( entryKey ) ; } } Set < String > result = new HashSet < > ( ) ; String lastKey = null ; Iterator < String > sortedKeysIter = propNames . iterator ( ) ; while ( sortedKeysIter . hasNext ( ) ) { String propName = sortedKeysIter . next ( ) ; if ( null ! = lastKey & & propName . startsWith ( lastKey + _STR ) ) { result . add ( lastKey ) ; } lastKey = propName ; } return result ; } 
6872	 @ Ignore ( _STR , sqlEx . getMessage ( ) ) ; throw ( SqlTimeoutException ) sqlEx ; } finally { Pause briefly to wait for server to unblock try { Thread . sleep ( TimeUnit . SECONDS . toMillis ( cleanupPause ) ) ; } catch ( InterruptedException e ) { } } } } 
6873	public static boolean isNonEmpty ( final Object o ) { return ! isEmpty ( o ) ; } 
6874	public static String getHopDAG ( MLContext mlCtx , Script script , ArrayList < Integer > lines , SparkConf newConf , boolean performHOPRewrites , boolean withSubgraph ) { SparkConf oldConf = mlCtx . getSparkSession ( ) . sparkContext ( ) . getConf ( ) ; SparkExecutionContext . SparkClusterConfig systemmlConf = SparkExecutionContext . getSparkClusterConfig ( ) ; long oldMaxMemory = InfrastructureAnalyzer . getLocalMaxMemory ( ) ; try { if ( newConf ! = null ) { systemmlConf . analyzeSparkConfiguation ( newConf ) ; InfrastructureAnalyzer . setLocalMaxMemory ( newConf . getSizeAsBytes ( _STR , e ) ; } finally { if ( newConf ! = null ) { systemmlConf . analyzeSparkConfiguation ( oldConf ) ; InfrastructureAnalyzer . setLocalMaxMemory ( oldMaxMemory ) ; } } } 
6875	public void test _ single _ loop ( ) throws Exception { Fs fs = startCrawlerDefinition ( ) . build ( ) ; logger . info ( _STR , crawler . getFsParser ( ) . isClosed ( ) , is ( true ) ) ; assertThat ( crawler . getFsParser ( ) . getRunNumber ( ) , is ( _NUM ) ) ; } 
6876	private static List < String > listChildrenBFSNoWatch ( ZKWatcher zkw , final String znode ) throws KeeperException { Deque < String > queue = new LinkedList < > ( ) ; List < String > tree = new ArrayList < > ( ) ; queue . add ( znode ) ; while ( true ) { String node = queue . pollFirst ( ) ; if ( node = = null ) { break ; } List < String > children = listChildrenNoWatch ( zkw , node ) ; if ( children = = null ) { continue ; } for ( final String child : children ) { final String childPath = node + _STR + child ; queue . add ( childPath ) ; tree . add ( childPath ) ; } } return tree ; } 
6877	public boolean performFinish ( ) { DriverDescriptor driver = getSelectedDriver ( ) ; ConnectionPageSettings pageSettings = getPageSettings ( ) ; DataSourceDescriptor dataSourceTpl = pageSettings = = null ? getActiveDataSource ( ) : pageSettings . getActiveDataSource ( ) ; DBPDataSourceRegistry dataSourceRegistry = getDataSourceRegistry ( ) ; DataSourceDescriptor dataSourceNew = new DataSourceDescriptor ( dataSourceRegistry , dataSourceTpl . getId ( ) , driver , dataSourceTpl . getConnectionConfiguration ( ) ) ; dataSourceNew . copyFrom ( dataSourceTpl ) ; saveSettings ( dataSourceNew ) ; dataSourceRegistry . addDataSource ( dataSourceNew ) ; return true ; } 
6878	public static String sanitizeDescription ( String javadoc , boolean summary ) { if ( Strings . isNullOrEmpty ( javadoc ) ) { return null ; } lets just use what java accepts as identifiers StringBuilder sb = new StringBuilder ( ) ; split into lines String [ ] lines = javadoc . split ( _STR ) ; return s . trim ( ) ; } 
6879	 @ VisibleForTestingstatic Pair < ByteBuff , CallCleanup > allocateByteBuffToReadInto ( ByteBufferPool pool , int minSizeForPoolUse , int reqLen ) { ByteBuff resultBuf ; List < ByteBuffer > bbs = new ArrayList < > ( ( reqLen / pool . getBufferSize ( ) ) + _NUM ) ; int remain = reqLen ; ByteBuffer buf = null ; while ( remain > = minSizeForPoolUse & & ( buf = pool . getBuffer ( ) ) ! = null ) { bbs . add ( buf ) ; remain - = pool . getBufferSize ( ) ; } ByteBuffer [ ] bufsFromPool = null ; if ( bbs . size ( ) > _NUM ) { bufsFromPool = new ByteBuffer [ bbs . size ( ) ] ; bbs . toArray ( bufsFromPool ) ; } if ( remain > _NUM ) { bbs . add ( ByteBuffer . allocate ( remain ) ) ; } if ( bbs . size ( ) > _NUM ) { ByteBuffer [ ] items = new ByteBuffer [ bbs . size ( ) ] ; bbs . toArray ( items ) ; resultBuf = new MultiByteBuff ( items ) ; } else { We are backed by single BB resultBuf = new SingleByteBuff ( bbs . get ( _NUM ) ) ; } resultBuf . limit ( reqLen ) ; if ( bufsFromPool ! = null ) { final ByteBuffer [ ] bufsFromPoolFinal = bufsFromPool ; return new Pair < > ( resultBuf , ( ) - > { Return back all the BBs to pool for ( int i = _NUM ; i < bufsFromPoolFinal . length ; i + + ) { pool . putbackBuffer ( bufsFromPoolFinal [ i ] ) ; } } ) ; } return new Pair < > ( resultBuf , null ) ; } 
6880	private List < Float > interpolatePositions ( PositionInfo left , PositionInfo right , int steps ) { if ( left . isOutOfBounds ( ) ) { if ( right . isNormal ( ) ) { return interpolateDownwards ( right . getNavPos ( ) , steps ) ; } else if ( right . isMax ( ) | | right . isOutOfBounds ( ) ) { return interpolateEmpty ( steps ) ; } else { can ' t happen assert false ; } } else if ( left . isNormal ( ) ) { if ( right . isOutOfBounds ( ) | | right . isMax ( ) ) { return interpolateUpwards ( left . getNavPos ( ) , steps ) ; } else if ( right . isNormal ( ) ) { return interpolateBetween ( left . getNavPos ( ) , right . getNavPos ( ) , steps ) ; } else { can ' t happen assert false ; } } else { can ' t happen assert false ; } return null ; } 
6881	public Op exec ( Op op , int . . . dimension ) { return processOp ( op ) ; } 
6882	public static < T > ItemsUnion < T > getInstance ( final ItemsSketch < T > sketch ) { return new ItemsUnion < > ( sketch . getK ( ) , sketch . getComparator ( ) , ItemsSketch . copy ( sketch ) ) ; } 
6883	public String getId ( Map < String , Object > contextMap ) { String markedParam = null ; AddressingProperties maps = ( AddressingProperties ) contextMap . get ( ADDRESSING _ PROPERTIES _ INBOUND ) ; if ( null ! = maps ) { EndpointReferenceType toEpr = maps . getToEndpointReference ( ) ; if ( null ! = toEpr ) { markedParam = extractStringElementFromAny ( MULTIPLEX _ ID _ QNAME , toEpr ) ; } } return markedParam ; } 
6884	public void drawBorderColors ( CellRangeAddress range , short color , BorderExtent extent ) { switch ( extent ) { case NONE : removeBorderColors ( range ) ; break ; case ALL : drawHorizontalBorderColors ( range , color , BorderExtent . ALL ) ; drawVerticalBorderColors ( range , color , BorderExtent . ALL ) ; break ; case INSIDE : drawHorizontalBorderColors ( range , color , BorderExtent . INSIDE ) ; drawVerticalBorderColors ( range , color , BorderExtent . INSIDE ) ; break ; case OUTSIDE : drawOutsideBorderColors ( range , color , BorderExtent . ALL ) ; break ; case TOP : drawTopBorderColor ( range , color ) ; break ; case BOTTOM : drawBottomBorderColor ( range , color ) ; break ; case LEFT : drawLeftBorderColor ( range , color ) ; break ; case RIGHT : drawRightBorderColor ( range , color ) ; break ; case HORIZONTAL : drawHorizontalBorderColors ( range , color , BorderExtent . ALL ) ; break ; case INSIDE _ HORIZONTAL : drawHorizontalBorderColors ( range , color , BorderExtent . INSIDE ) ; break ; case OUTSIDE _ HORIZONTAL : drawOutsideBorderColors ( range , color , BorderExtent . HORIZONTAL ) ; break ; case VERTICAL : drawVerticalBorderColors ( range , color , BorderExtent . ALL ) ; break ; case INSIDE _ VERTICAL : drawVerticalBorderColors ( range , color , BorderExtent . INSIDE ) ; break ; case OUTSIDE _ VERTICAL : drawOutsideBorderColors ( range , color , BorderExtent . VERTICAL ) ; break ; } } 
6885	public void setCustomProperties ( final CustomProperties customProperties ) { ensureSection _NUM ( ) ; final Section section = getSections ( ) . get ( _NUM ) ; final Map < Long , String > dictionary = customProperties . getDictionary ( ) ; section . clear ( ) ; int cpCodepage = customProperties . getCodepage ( ) ; if ( cpCodepage < _NUM ) { cpCodepage = section . getCodepage ( ) ; } if ( cpCodepage < _NUM ) { cpCodepage = Property . DEFAULT _ CODEPAGE ; } customProperties . setCodepage ( cpCodepage ) ; section . setCodepage ( cpCodepage ) ; section . setDictionary ( dictionary ) ; for ( CustomProperty p : customProperties . properties ( ) ) { section . setProperty ( p ) ; } } 
6886	public synchronized void bootstrap ( ) { if ( ! isRunning ( ) | | System . currentTimeMillis ( ) - lastBootstrap < DHTConstants . BOOTSTRAP _ MIN _ INTERVAL ) { return ; } if ( ! bootstrapping . compareAndSet ( BootstrapState . NONE , BootstrapState . FILL ) ) return ; if ( useRouterBootstrapping & & node . getNumEntriesInRoutingTable ( ) < DHTConstants . USE _ BT _ ROUTER _ IF _ LESS _ THAN _ X _ PEERS ) { routerBootstrap ( ) ; } else { fillHomeBuckets ( Collections . emptyList ( ) ) ; } } 
6887	public Collection < Recipient > getRecipients ( RecipientId selector ) { if ( selector instanceof KeyTransRecipientId ) { KeyTransRecipientId keyTrans = ( KeyTransRecipientId ) selector ; X _NUM _NUM _NUM Name issuer = keyTrans . getIssuer ( ) ; byte [ ] subjectKeyId = keyTrans . getSubjectKeyIdentifier ( ) ; if ( issuer ! = null & & subjectKeyId ! = null ) { List results = new ArrayList ( ) ; Collection match _NUM = getRecipients ( new KeyTransRecipientId ( issuer , keyTrans . getSerialNumber ( ) ) ) ; if ( match _NUM ! = null ) { results . addAll ( match _NUM ) ; } Collection match _NUM = getRecipients ( new KeyTransRecipientId ( subjectKeyId ) ) ; if ( match _NUM ! = null ) { results . addAll ( match _NUM ) ; } return results ; } } List list = ( ArrayList ) table . get ( selector ) ; return list = = null ? new ArrayList ( ) : new ArrayList ( list ) ; } 
6888	public void testBlockLocationConstructors ( ) throws Exception { BlockLocation loc ; loc = new BlockLocation ( ) ; checkBlockLocation ( loc ) ; loc = new BlockLocation ( null , null , _NUM , _NUM ) ; checkBlockLocation ( loc , _NUM , _NUM , false ) ; loc = new BlockLocation ( null , null , null , _NUM , _NUM ) ; checkBlockLocation ( loc , _NUM , _NUM , false ) ; loc = new BlockLocation ( null , null , null , _NUM , _NUM , true ) ; checkBlockLocation ( loc , _NUM , _NUM , true ) ; loc = new BlockLocation ( null , null , null , null , _NUM , _NUM , true ) ; checkBlockLocation ( loc , _NUM , _NUM , true ) ; } 
6889	public static boolean isValidNameForComponent ( String component ) { if ( component . equals ( _STR ) > = _NUM ) { return false ; } return ! isReservedPathComponent ( component ) ; } 
6890	private void scheduleRestarts ( ThreadContext context ) { if ( shutdownTimers . isEmpty ( ) & & restartTimers . isEmpty ( ) ) { int shutdownCount = randomNumber ( servers . size ( ) - _NUM ) + _NUM ; boolean remove = randomBoolean ( ) ; for ( int i = _NUM ; i < shutdownCount ; i + + ) { scheduleRestart ( remove , i , context ) ; } } } 
6891	int findOnePartiallyOrCompletelyVisibleChild ( int fromIndex , int toIndex , boolean completelyVisible , boolean acceptCompletelyVisible , boolean acceptEndPointInclusion ) { final int start = mPrimaryOrientation . getStartAfterPadding ( ) ; final int end = mPrimaryOrientation . getEndAfterPadding ( ) ; final int next = toIndex > fromIndex ? _NUM : - _NUM ; for ( int i = fromIndex ; i ! = toIndex ; i + = next ) { final View child = mViews . get ( i ) ; final int childStart = mPrimaryOrientation . getDecoratedStart ( child ) ; final int childEnd = mPrimaryOrientation . getDecoratedEnd ( child ) ; boolean childStartInclusion = acceptEndPointInclusion ? ( childStart < = end ) : ( childStart < end ) ; boolean childEndInclusion = acceptEndPointInclusion ? ( childEnd > = start ) : ( childEnd > start ) ; if ( childStartInclusion & & childEndInclusion ) { if ( completelyVisible & & acceptCompletelyVisible ) { the child has to be completely visible to be returned . if ( childStart > = start & & childEnd < = end ) { return getPosition ( child ) ; } } else if ( acceptCompletelyVisible ) { can return either a partially or completely visible child . return getPosition ( child ) ; } else if ( childStart < start | | childEnd > end ) { visible child is not acceptable in this case . return getPosition ( child ) ; } } } return NO _ POSITION ; } 
6892	public int toArgb ( ) { if ( mColorSpace . isSrgb ( ) ) { return ( ( int ) ( mComponents [ _NUM ] * _NUM _NUM _NUM . _NUM f + _NUM . _NUM f ) < < _NUM _NUM ) | ( ( int ) ( mComponents [ _NUM ] * _NUM _NUM _NUM . _NUM f + _NUM . _NUM f ) < < _NUM _NUM ) | ( ( int ) ( mComponents [ _NUM ] * _NUM _NUM _NUM . _NUM f + _NUM . _NUM f ) < < _NUM ) | ( int ) ( mComponents [ _NUM ] * _NUM _NUM _NUM . _NUM f + _NUM . _NUM f ) ; } float [ ] color = new float [ ] { mComponents [ _NUM ] , mComponents [ _NUM ] , mComponents [ _NUM ] , mComponents [ _NUM ] } ; The transformation saturates the output ColorSpace . connect ( mColorSpace ) . transform ( color ) ; return ( ( int ) ( color [ _NUM ] * _NUM _NUM _NUM . _NUM f + _NUM . _NUM f ) < < _NUM _NUM ) | ( ( int ) ( color [ _NUM ] * _NUM _NUM _NUM . _NUM f + _NUM . _NUM f ) < < _NUM _NUM ) | ( ( int ) ( color [ _NUM ] * _NUM _NUM _NUM . _NUM f + _NUM . _NUM f ) < < _NUM ) | ( int ) ( color [ _NUM ] * _NUM _NUM _NUM . _NUM f + _NUM . _NUM f ) ; } 
6893	public void addTrainingInstanceFromMouseLocation ( int mouseX , int mouseY , int classAttIndex , double classValue ) { convert to coordinates in the training instance space . double x = convertFromPanelX ( mouseX ) ; double y = convertFromPanelY ( mouseY ) ; build the training instance Instance newInstance = new DenseInstance ( m _ trainingData . numAttributes ( ) ) ; for ( int i = _NUM ; i < newInstance . numAttributes ( ) ; i + + ) { if ( i = = classAttIndex ) { newInstance . setValue ( i , classValue ) ; } else if ( i = = m _ xAttribute ) newInstance . setValue ( i , x ) ; else if ( i = = m _ yAttribute ) newInstance . setValue ( i , y ) ; else newInstance . setMissing ( i ) ; } add it to our data set . addTrainingInstance ( newInstance ) ; } 
6894	public int compare ( NotificationData . Entry a , NotificationData . Entry b ) { HeadsUpEntry aEntry = getHeadsUpEntry ( a . key ) ; HeadsUpEntry bEntry = getHeadsUpEntry ( b . key ) ; if ( aEntry = = null | | bEntry = = null ) { return aEntry = = null ? _NUM : - _NUM ; } return aEntry . compareTo ( bEntry ) ; } 
6895	private Map < String , ScanInfo [ ] > getDiskReport ( ) { ScanInfoPerBlockPool list = new ScanInfoPerBlockPool ( ) ; ScanInfoPerBlockPool [ ] dirReports = null ; First get list of data directories try ( FsDatasetSpi . FsVolumeReferences volumes = dataset . getFsVolumeReferences ( ) ) { Use an array since the threads may return out of order and compilersInProgress # keySet may return out of order as well . dirReports = new ScanInfoPerBlockPool [ volumes . size ( ) ] ; Map < Integer , Future < ScanInfoPerBlockPool > > compilersInProgress = new HashMap < Integer , Future < ScanInfoPerBlockPool > > ( ) ; for ( int i = _NUM ; i < volumes . size ( ) ; i + + ) { ReportCompiler reportCompiler = new ReportCompiler ( datanode , volumes . get ( i ) ) ; Future < ScanInfoPerBlockPool > result = reportCompileThreadPool . submit ( reportCompiler ) ; compilersInProgress . put ( i , result ) ; } for ( Entry < Integer , Future < ScanInfoPerBlockPool > > report : compilersInProgress . entrySet ( ) ) { try { dirReports [ report . getKey ( ) ] = report . getValue ( ) . get ( ) ; } catch ( Exception ex ) { LOG . error ( _STR , e ) ; } if ( dirReports ! = null ) { Compile consolidated report for all the volumes for ( ScanInfoPerBlockPool report : dirReports ) { list . addAll ( report ) ; } } return list . toSortedArrays ( ) ; } 
6896	public static NodeId getNodeId ( DatasetGraph ds , Node node ) { DatasetGraphTDB dsg = getDatasetGraphTDB ( ds ) ; return getNodeId ( dsg , node ) ; } 
6897	public void testFull ( ) throws IOException { for ( final Object [ ] exp : TYPES ) { if ( exp . length < _NUM ) continue ; try ( TestQuery tq = session . query ( exp [ _NUM ] . toString ( ) ) ) { final TestResult tr = tq . full ( exp ) ; final Object [ ] type = TYPES [ tr . type ] ; assertSame ( _STR + type [ _NUM ] , exp , type ) ; assertEquals ( Token . string ( tr . result ) , type [ _NUM ] ) ; if ( exp . length > _NUM ) assertEquals ( Token . string ( tr . uri ) , type [ _NUM ] ) ; } } } 
6898	protected Instances determineOutputFormat ( Instances inputFormat ) throws Exception { Vector < Integer > indices ; int [ ] attributes ; int i ; determine indices indices = new Vector < Integer > ( ) ; for ( i = _NUM ; i < inputFormat . numAttributes ( ) ; i + + ) { skip class if ( i = = inputFormat . classIndex ( ) ) continue ; if ( inputFormat . attribute ( i ) . name ( ) . matches ( m _ Expression ) ) indices . add ( i ) ; } attributes = new int [ indices . size ( ) ] ; for ( i = _NUM ; i < indices . size ( ) ; i + + ) attributes [ i ] = indices . get ( i ) ; m _ Remove = new Remove ( ) ; m _ Remove . setAttributeIndicesArray ( attributes ) ; m _ Remove . setInvertSelection ( getInvertSelection ( ) ) ; m _ Remove . setInputFormat ( inputFormat ) ; return m _ Remove . getOutputFormat ( ) ; } 
6899	public DataBuffer getIncludedIndices ( ) { if ( isScalar ( ) ) { return Nd _NUM j . createBuffer ( new int [ ] { _NUM , _NUM } ) ; } List < Integer > ind = new ArrayList < > ( ) ; for ( int i = _NUM ; i < values . length ( ) ; i + + ) { boolean isIn = true ; int idxNotFixed = _NUM ; TODO change for getIndicesOf ( i ) int [ ] idx = getUnderlyingIndicesOf ( i ) . asInt ( ) ; for ( int dim = _NUM ; dim < idx . length ; dim + + ) { if ( flags ( ) [ dim ] = = _NUM ) { if ( sparseOffsets ( ) [ dim ] ! = idx [ dim ] ) { isIn = false ; break ; } } else { int lowerBound = sparseOffsets ( ) [ dim ] ; int upperBound = sparseOffsets ( ) [ dim ] + shape ( ) [ idxNotFixed ] ; if ( ! ( idx [ dim ] > = lowerBound & & idx [ dim ] < upperBound ) ) { isIn = false ; break ; } idxNotFixed + + ; } } if ( isIn ) { int notFixedDim = _NUM ; for ( int dim = _NUM ; dim < idx . length ; dim + + ) { if ( flags ( ) [ dim ] = = _NUM ) { if ( shape ( ) [ notFixedDim ] = = _NUM ) { ind . add ( _NUM ) ; notFixedDim + + ; } else { ind . add ( idx [ dim ] - sparseOffsets ( ) [ dim ] ) ; } } } } } return Nd _NUM j . createBuffer ( Ints . toArray ( ind ) ) ; } 
6900	protected void read _ lookahead ( ) throws java . lang . Exception { lookahead = new Symbol [ error _ sync _ size ( ) ] ; for ( int i = _NUM ; i < error _ sync _ size ( ) ; i + + ) { lookahead [ i ] = cur _ token ; cur _ token = scan ( ) ; } lookahead _ pos = _NUM ; } 
6901	public void setExif ( Collection < ExifTag > tags ) { clearExif ( ) ; setTags ( tags ) ; } 
6902	public Node pushNode ( String name , PInput input , PTransform < ? , ? > transform ) { checkNotNull ( transform , _STR , PTransform . class . getSimpleName ( ) ) ; Node node = new Node ( current , transform , name , input ) ; unexpandedInputs . put ( node , input ) ; current . addComposite ( node ) ; current = node ; return current ; } 
6903	private static Row combineTwoRowsIntoOne ( Row leftRow , Row rightRow , boolean swap ) { if ( swap ) { return combineTwoRowsIntoOneHelper ( rightRow , leftRow ) ; } else { return combineTwoRowsIntoOneHelper ( leftRow , rightRow ) ; } } 
6904	public String getUserSearchFilter ( boolean useAlternateUserSearchFilter ) { String filter = useAlternateUserSearchFilter ? alternateUserSearchFilter : userSearchFilter ; return resolveUserSearchFilterPlaceHolders ( filter ) ; } 
6905	public void setIsLogfile ( boolean isLogfile ) throws CmsRuntimeException { checkFrozen ( ) ; m _ isLogfile = isLogfile ; } 
6906	public AssignProcedure [ ] createAssignProcedures ( final List < RegionInfo > hris ) { if ( hris . isEmpty ( ) ) { return null ; } int index = _NUM ; AssignProcedure [ ] procedures = new AssignProcedure [ hris . size ( ) ] ; for ( RegionInfo hri : hris ) { Sort the procedures so meta and system regions are first in the returned array . procedures [ index + + ] = createAssignProcedure ( hri ) ; } if ( procedures . length > _NUM ) { Sort the procedures so meta and system regions are first in the returned array . Arrays . sort ( procedures , AssignProcedure . COMPARATOR ) ; } return procedures ; } 
6907	public void setDelegator ( Delegator internalDelegator ) { assertIsMutable ( ) ; if ( internalDelegator = = null ) return ; this . delegatorName = internalDelegator . getDelegatorName ( ) ; this . internalDelegator = internalDelegator ; } 
6908	public void needsCleanupInProgress ( ) { PendingRepairManager prm = csm . getPendingRepairManagers ( ) . get ( _NUM ) ; UUID repairID = registerSession ( cfs , true , true ) ; LocalSessionAccessor . prepareUnsafe ( repairID , COORDINATOR , PARTICIPANTS ) ; SSTableReader sstable = makeSSTable ( true ) ; mutateRepaired ( sstable , repairID ) ; prm . addSSTable ( sstable ) ; Assert . assertNotNull ( prm . get ( repairID ) ) ; Assert . assertFalse ( prm . canCleanup ( repairID ) ) ; } 
6909	public Optional < byte [ ] > getSplitPoint ( ) throws IOException { if ( this . getStorefileCount ( ) = = _NUM ) { return Optional . empty ( ) ; } if ( state . stripeFiles . size ( ) < = _NUM ) { return getSplitPointFromAllFiles ( ) ; } int leftIndex = - _NUM , rightIndex = state . stripeFiles . size ( ) ; long leftSize = _NUM , rightSize = _NUM ; long lastLeftSize = _NUM , lastRightSize = _NUM ; while ( rightIndex - _NUM ! = leftIndex ) { if ( leftSize > = rightSize ) { - - rightIndex ; lastRightSize = getStripeFilesSize ( rightIndex ) ; rightSize + = lastRightSize ; } else { + + leftIndex ; lastLeftSize = getStripeFilesSize ( leftIndex ) ; leftSize + = lastLeftSize ; } } if ( leftSize = = _NUM | | rightSize = = _NUM ) { String errMsg = String . format ( _STR + config . getMaxSplitImbalance ( ) ) ; OK , we may get better ratio , get it . return StoreUtils . getSplitPoint ( state . stripeFiles . get ( isRightLarger ? rightIndex : leftIndex ) , cellComparator ) ; } 
6910	public void setVirtualDisplayProperties ( Vr _NUM dDisplayProperties displayProperties ) { synchronized ( mVdLock ) { if ( DEBUG ) { Log . i ( TAG , _STR + dpi ) ; mVirtualDisplayWidth = width ; mVirtualDisplayHeight = height ; mVirtualDisplayDpi = dpi ; resized = true ; } if ( ( displayProperties . getFlags ( ) & Vr _NUM dDisplayProperties . FLAG _ VIRTUAL _ DISPLAY _ ENABLED ) = = Vr _NUM dDisplayProperties . FLAG _ VIRTUAL _ DISPLAY _ ENABLED ) { mIsVirtualDisplayAllowed = true ; } else if ( ( displayProperties . getRemovedFlags ( ) & Vr _NUM dDisplayProperties . FLAG _ VIRTUAL _ DISPLAY _ ENABLED ) = = Vr _NUM dDisplayProperties . FLAG _ VIRTUAL _ DISPLAY _ ENABLED ) { mIsVirtualDisplayAllowed = false ; } if ( mVirtualDisplay ! = null & & resized & & mIsVirtualDisplayAllowed ) { mVirtualDisplay . resize ( mVirtualDisplayWidth , mVirtualDisplayHeight , mVirtualDisplayDpi ) ; ImageReader oldImageReader = mImageReader ; mImageReader = null ; startImageReader ( ) ; oldImageReader . close ( ) ; } Start / Stop the virtual display in case the updates indicated that we should . updateVirtualDisplay ( ) ; } } 
6911	public static List < String > splitOgnl ( String ognl ) { List < String > methods = new ArrayList < String > ( ) ; return an empty list if ognl is empty if ( ObjectHelper . isEmpty ( ognl ) ) { return methods ; } StringBuilder sb = new StringBuilder ( ) ; j is used as counter per method int j = _NUM ; special to keep track if we are inside a square bracket block , eg : [ foo ] boolean squareBracket = false ; special to keep track if we are inside a parenthesis block , eg : bar ( $ { body } , $ { header . foo } ) boolean parenthesisBracket = false ; for ( int i = _NUM ; i < ognl . length ( ) ; i + + ) { char ch = ognl . charAt ( i ) ; special for starting a new method if ( j = = _NUM | | ( j = = _NUM & & ognl . charAt ( i - _NUM ) = = ' ? ' ) | | ( ch ! = ' . ' & & ch ! = ' ? ' & & ch ! = ' ] ' ) ) { sb . append ( ch ) ; special if we are doing square bracket if ( ch = = ' [ ' & & ! parenthesisBracket ) { squareBracket = true ; } else if ( ch = = ' ( ' ) { parenthesisBracket = true ; } else if ( ch = = ' ) ' ) { parenthesisBracket = false ; } advance j + + ; } else { if ( ch = = ' . ' & & ! squareBracket & & ! parenthesisBracket ) { only treat dot as a method separator if not inside a square bracket block as dots can be used in key names when accessing maps a dit denotes end of this method and a new method is to be invoked String s = sb . toString ( ) ; reset sb sb . setLength ( _NUM ) ; pass over ? to the new method if ( s . endsWith ( _STR + last ) ; } } return methods ; } 
6912	public void inc ( ) { checkWriteTxn ( ) ; IntegerState ts = getDataState ( ) ; ts . txnValue + + ; } 
6913	public static String getRfsPath ( String filename , String extension , String parameters ) { StringBuffer buf = new StringBuffer ( _NUM _NUM _NUM ) ; buf . append ( filename ) ; buf . append ( ' _ ' ) ; int h = parameters . hashCode ( ) ; ensure we do have a positive id value buf . append ( h > _NUM ? h : - h ) ; buf . append ( extension ) ; return buf . toString ( ) ; } 
6914	private Expr copyModify ( ) throws QueryException { if ( ! wsConsumeWs ( COPY , DOLLAR , INCOMPLETE ) ) return null ; final int s = localVars . openScope ( ) ; Let [ ] fl = { } ; do { final Var var = newVar ( SeqType . NOD _ O ) ; wsCheck ( ASSIGN ) ; final Expr ex = check ( single ( ) , INCOMPLETE ) ; fl = Array . add ( fl , new Let ( localVars . add ( var ) , ex , false ) ) ; } while ( wsConsumeWs ( COMMA ) ) ; wsCheck ( MODIFY ) ; final InputInfo info = info ( ) ; final Expr m = check ( single ( ) , INCOMPLETE ) ; wsCheck ( RETURN ) ; final Expr r = check ( single ( ) , INCOMPLETE ) ; localVars . closeScope ( s ) ; qc . updating ( ) ; return new Transform ( info , fl , m , r ) ; } 
6915	public Range getDataRange ( ValueAxis axis ) { Range result = null ; List mappedDatasets = new ArrayList ( ) ; List includedAnnotations = new ArrayList ( ) ; boolean isDomainAxis = true ; is it a domain axis ? int domainIndex = getDomainAxisIndex ( axis ) ; if ( domainIndex > = _NUM ) { isDomainAxis = true ; mappedDatasets . addAll ( getDatasetsMappedToDomainAxis ( new Integer ( domainIndex ) ) ) ; if ( domainIndex = = _NUM ) { grab the plot ' s annotations Iterator iterator = this . annotations . iterator ( ) ; while ( iterator . hasNext ( ) ) { XYAnnotation annotation = ( XYAnnotation ) iterator . next ( ) ; if ( annotation instanceof XYAnnotationBoundsInfo ) { includedAnnotations . add ( annotation ) ; } } } } or is it a range axis ? int rangeIndex = getRangeAxisIndex ( axis ) ; if ( rangeIndex > = _NUM ) { isDomainAxis = false ; mappedDatasets . addAll ( getDatasetsMappedToRangeAxis ( new Integer ( rangeIndex ) ) ) ; if ( rangeIndex = = _NUM ) { Iterator iterator = this . annotations . iterator ( ) ; while ( iterator . hasNext ( ) ) { XYAnnotation annotation = ( XYAnnotation ) iterator . next ( ) ; if ( annotation instanceof XYAnnotationBoundsInfo ) { includedAnnotations . add ( annotation ) ; } } } } iterate through the datasets that map to the axis and get the union of the ranges . Iterator iterator = mappedDatasets . iterator ( ) ; while ( iterator . hasNext ( ) ) { XYDataset d = ( XYDataset ) iterator . next ( ) ; if ( d ! = null ) { XYItemRenderer r = getRendererForDataset ( d ) ; if ( isDomainAxis ) { if ( r ! = null ) { result = Range . combine ( result , r . findDomainBounds ( d ) ) ; } else { result = Range . combine ( result , DatasetUtilities . findDomainBounds ( d ) ) ; } } else { if ( r ! = null ) { result = Range . combine ( result , r . findRangeBounds ( d ) ) ; } else { result = Range . combine ( result , DatasetUtilities . findRangeBounds ( d ) ) ; } } getAnnotations ( ) method but it should if ( r instanceof AbstractXYItemRenderer ) { AbstractXYItemRenderer rr = ( AbstractXYItemRenderer ) r ; Collection c = rr . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { XYAnnotation a = ( XYAnnotation ) i . next ( ) ; if ( a instanceof XYAnnotationBoundsInfo ) { includedAnnotations . add ( a ) ; } } } } } Iterator it = includedAnnotations . iterator ( ) ; while ( it . hasNext ( ) ) { XYAnnotationBoundsInfo xyabi = ( XYAnnotationBoundsInfo ) it . next ( ) ; if ( xyabi . getIncludeInDataBounds ( ) ) { if ( isDomainAxis ) { result = Range . combine ( result , xyabi . getXRange ( ) ) ; } else { result = Range . combine ( result , xyabi . getYRange ( ) ) ; } } } return result ; } 
6916	public void testUdfArgumentName ( ) { final CalciteAssert . AssertThat with = withUdf ( ) ; arguments in physical order with . query ( _STR ) ; } 
6917	protected void executeAction ( HttpAction action ) { executeLifecycle ( action ) ; } 
6918	public static String concat ( final String basePath , final String fullFileNameToAdd ) { final int prefix = getPrefixLength ( fullFileNameToAdd ) ; if ( prefix < _NUM ) { return null ; } if ( prefix > _NUM ) { return normalize ( fullFileNameToAdd ) ; } if ( basePath = = null ) { return null ; } final int len = basePath . length ( ) ; if ( len = = _NUM ) { return normalize ( fullFileNameToAdd ) ; } final char ch = basePath . charAt ( len - _NUM ) ; if ( isSeparator ( ch ) ) { return normalize ( basePath + fullFileNameToAdd ) ; } return normalize ( basePath + ' / ' + fullFileNameToAdd ) ; } 
6919	public RunnerApi . Pipeline toPipeline ( ) { Map < String , PTransform > executableStageTransforms = getEnvironmentExecutedTransforms ( ) ; Set < String > executableTransformIds = Sets . union ( executableStageTransforms . keySet ( ) , getRunnerExecutedTransforms ( ) . stream ( ) . map ( PTransformNode : : getId ) . collect ( Collectors . toSet ( ) ) ) ; Augment the initial transforms with all of the executable transforms . Components fusedComponents = getComponents ( ) . toBuilder ( ) . putAllTransforms ( executableStageTransforms ) . build ( ) ; List < String > rootTransformIds = StreamSupport . stream ( QueryablePipeline . forTransforms ( executableTransformIds , fusedComponents ) . getTopologicallyOrderedTransforms ( ) . spliterator ( ) , false ) . map ( PTransformNode : : getId ) . collect ( Collectors . toList ( ) ) ; return Pipeline . newBuilder ( ) . setComponents ( fusedComponents ) . addAllRootTransformIds ( rootTransformIds ) . build ( ) ; } 
6920	public PGPOnePassSignature generateOnePassVersion ( boolean isNested ) throws PGPException { return new PGPOnePassSignature ( new OnePassSignaturePacket ( sigType , contentSigner . getHashAlgorithm ( ) , contentSigner . getKeyAlgorithm ( ) , contentSigner . getKeyID ( ) , isNested ) ) ; } 
6921	private void doWork ( ) throws InvalidStateTransitionException , AmbariException { List < Host > allHosts = clusters . getHosts ( ) ; long now = System . currentTimeMillis ( ) ; for ( Host hostObj : allHosts ) { if ( hostObj . getState ( ) = = HostState . HEARTBEAT _ LOST ) { do not check if host already known be lost continue ; } String host = hostObj . getHostName ( ) ; HostState hostState = hostObj . getState ( ) ; String hostname = hostObj . getHostName ( ) ; long lastHeartbeat = _NUM ; try { lastHeartbeat = clusters . getHost ( host ) . getLastHeartbeatTime ( ) ; } catch ( AmbariException e ) { LOG . warn ( _STR ) ; hostObj . setState ( HostState . INIT ) ; } } } } 
6922	public void write ( double value , int repetitionLevel , int definitionLevel ) { if ( DEBUG ) log ( value , repetitionLevel , definitionLevel ) ; repetitionLevel ( repetitionLevel ) ; definitionLevel ( definitionLevel ) ; dataColumn . writeDouble ( value ) ; statistics . updateStats ( value ) ; + + valueCount ; } 
6923	public byte byteValue ( ) { return getByteValue ( ) ; } 
6924	public static boolean isJava _NUM _NUM ( ) { return getJavaMajorVersion ( ) = = _NUM ; } 
6925	public void setTabStopEnabled ( boolean doTabStop ) { this . doTabStop = doTabStop ; if ( doTabStop | | vaadinModality ) { addTabBlockHandlers ( ) ; } else { removeTabBlockHandlers ( ) ; } } 
6926	private static double percentageWordsWithThreeSyllables ( String strText ) { int intWordCount = wordCount ( strText ) ; int intLongWordCount = wordsWithThreeSyllables ( strText ) ; double percentage = ( ( intLongWordCount / ( double ) intWordCount ) * _NUM _NUM _NUM . _NUM ) ; return percentage ; } 
6927	public Builder setProperties ( org . apache . drill . exec . proto . UserProtos . UserProperties . Builder builderForValue ) { if ( propertiesBuilder _ = = null ) { properties _ = builderForValue . build ( ) ; onChanged ( ) ; } else { propertiesBuilder _ . setMessage ( builderForValue . build ( ) ) ; } bitField _NUM _ | = _NUM x _NUM _NUM _NUM _NUM _NUM _NUM _NUM _NUM ; return this ; } 
6928	public void testClientConnectionRequestDuringStartupWithNettyServerCnxn ( ) throws Exception { tmpDir = ClientBase . createTmpDir ( ) ; ClientBase . setupTestEnv ( ) ; String originalServerCnxnFactory = System . getProperty ( ServerCnxnFactory . ZOOKEEPER _ SERVER _ CNXN _ FACTORY ) ; try { System . setProperty ( ServerCnxnFactory . ZOOKEEPER _ SERVER _ CNXN _ FACTORY , NettyServerCnxnFactory . class . getName ( ) ) ; startSimpleZKServer ( startupDelayLatch ) ; SimpleZooKeeperServer simplezks = ( SimpleZooKeeperServer ) zks ; Assert . assertTrue ( _STR , simplezks . waitForSessionCreation ( _NUM ) ) ; watcher . waitForConnected ( ClientBase . CONNECTION _ TIMEOUT ) ; zkClient . close ( ) ; } finally { reset cnxn factory if ( originalServerCnxnFactory = = null ) { System . clearProperty ( ServerCnxnFactory . ZOOKEEPER _ SERVER _ CNXN _ FACTORY ) ; return ; } System . setProperty ( ServerCnxnFactory . ZOOKEEPER _ SERVER _ CNXN _ FACTORY , originalServerCnxnFactory ) ; } } 
6929	ThemeImpl newThemeImpl ( Resources . ThemeKey key ) { ThemeImpl impl = new ThemeImpl ( ) ; impl . mKey . setTo ( key ) ; impl . rebase ( ) ; return impl ; } 
6930	public static DeadServerList getDeadTservers ( ) { MasterMonitorInfo mmi = getMmi ( ) ; if ( null = = mmi ) { return new DeadServerList ( ) ; } DeadServerList deadServers = new DeadServerList ( ) ; Add new dead servers to the list for ( DeadServer dead : mmi . deadTabletServers ) { deadServers . addDeadServer ( new DeadServerInformation ( dead . server , dead . lastStatus , dead . status ) ) ; } return deadServers ; } 
6931	public String getEntry ( String key , Locale loc , TimeZone timezone ) throws MissingEntryException { String entry = id ; if ( key ! = null ) { entry + = _STR , resource , entry , loc , loader ! = null ? loader : this . getClassLoader ( ) ) ; } catch ( UnsupportedEncodingException use ) { should never occur - cause we already test this in the constructor throw new RuntimeException ( use . toString ( ) ) ; } } 
6932	default void printOut ( ) { stream ( ) . printOut ( ) ; } 
6933	public void sendAbortResult ( Bundle result ) { try { if ( DEBUG ) Log . d ( TAG , _STR + result ) ; finishRequest ( ) ; mCallback . deliverAbortVoiceResult ( mInterface , result ) ; } catch ( RemoteException e ) { } } 
6934	private boolean decimalFormatDecl ( final boolean def ) throws QueryException { if ( def & & ! wsConsumeWs ( DECIMAL _ FORMAT ) ) return false ; use empty name for default declaration final QNm name = def ? QNm . EMPTY : eQName ( QNAME _ X , null ) ; check if format has already been declared if ( sc . decFormats . get ( name . id ( ) ) ! = null ) throw error ( DECDUPL ) ; create new format final TokenMap map = new TokenMap ( ) ; collect all property declarations int n ; do { n = map . size ( ) ; skipWs ( ) ; final byte [ ] prop = ncName ( null ) ; for ( final byte [ ] s : DECFORMATS ) { if ( ! eq ( prop , s ) ) continue ; if ( map . get ( s ) ! = null ) throw error ( DECDUPLPROP _ X , s ) ; wsCheck ( IS ) ; map . put ( s , stringLiteral ( ) ) ; break ; } if ( map . isEmpty ( ) ) throw error ( NODECLFORM _ X , prop ) ; } while ( n ! = map . size ( ) ) ; completes the format declaration sc . decFormats . put ( name . id ( ) , new DecFormatter ( map , info ( ) ) ) ; return true ; } 
6935	private void generateLegalTimesTree ( ) { Create a quick cache of numbers to their keycodes . int k _NUM = KeyEvent . KEYCODE _ _NUM ; int k _NUM = KeyEvent . KEYCODE _ _NUM ; int k _NUM = KeyEvent . KEYCODE _ _NUM ; int k _NUM = KeyEvent . KEYCODE _ _NUM ; int k _NUM = KeyEvent . KEYCODE _ _NUM ; int k _NUM = KeyEvent . KEYCODE _ _NUM ; int k _NUM = KeyEvent . KEYCODE _ _NUM ; int k _NUM = KeyEvent . KEYCODE _ _NUM ; int k _NUM = KeyEvent . KEYCODE _ _NUM ; int k _NUM = KeyEvent . KEYCODE _ _NUM ; The root of the tree doesn ' t contain any numbers . mLegalTimesTree = new Node ( ) ; if ( mIs _NUM _NUM HourMode ) { We ' ll be re - using these nodes , so we ' ll save them . Node minuteFirstDigit = new Node ( k _NUM , k _NUM , k _NUM , k _NUM , k _NUM , k _NUM ) ; Node minuteSecondDigit = new Node ( k _NUM , k _NUM , k _NUM , k _NUM , k _NUM , k _NUM , k _NUM , k _NUM , k _NUM , k _NUM ) ; The first digit must be followed by the second digit . minuteFirstDigit . addChild ( minuteSecondDigit ) ; The first digit may be _NUM - _NUM . Node firstDigit = new Node ( k _NUM , k _NUM ) ; mLegalTimesTree . addChild ( firstDigit ) ; When the first digit is _NUM - _NUM , the second digit may be _NUM - _NUM . Node secondDigit = new Node ( k _NUM , k _NUM , k _NUM , k _NUM , k _NUM , k _NUM ) ; firstDigit . addChild ( secondDigit ) ; We may now be followed by the first minute digit . E . g . _NUM _NUM : _NUM _NUM , _NUM _NUM : _NUM _NUM . secondDigit . addChild ( minuteFirstDigit ) ; When the first digit is _NUM - _NUM , and the second digit is _NUM - _NUM , the third digit may be _NUM - _NUM . Node thirdDigit = new Node ( k _NUM , k _NUM , k _NUM , k _NUM ) ; The time must now be finished . E . g . _NUM : _NUM _NUM , _NUM : _NUM _NUM . secondDigit . addChild ( thirdDigit ) ; When the first digit is _NUM - _NUM , the second digit may be _NUM - _NUM . secondDigit = new Node ( k _NUM , k _NUM , k _NUM , k _NUM ) ; firstDigit . addChild ( secondDigit ) ; We must now be followed by the first minute digit . E . g . _NUM _NUM : _NUM _NUM , _NUM _NUM : _NUM _NUM . secondDigit . addChild ( minuteFirstDigit ) ; The first digit may be _NUM . firstDigit = new Node ( k _NUM ) ; mLegalTimesTree . addChild ( firstDigit ) ; When the first digit is _NUM , the second digit may be _NUM - _NUM . secondDigit = new Node ( k _NUM , k _NUM , k _NUM , k _NUM ) ; firstDigit . addChild ( secondDigit ) ; We must now be followed by the first minute digit . E . g . _NUM _NUM : _NUM _NUM , _NUM _NUM : _NUM _NUM . secondDigit . addChild ( minuteFirstDigit ) ; When the first digit is _NUM , the second digit may be _NUM - _NUM . secondDigit = new Node ( k _NUM , k _NUM ) ; firstDigit . addChild ( secondDigit ) ; We must now be followd by the last minute digit . E . g . _NUM : _NUM _NUM , _NUM : _NUM _NUM . secondDigit . addChild ( minuteSecondDigit ) ; The first digit may be _NUM - _NUM . firstDigit = new Node ( k _NUM , k _NUM , k _NUM , k _NUM , k _NUM , k _NUM , k _NUM ) ; mLegalTimesTree . addChild ( firstDigit ) ; We must now be followed by the first minute digit . E . g . _NUM : _NUM _NUM , _NUM : _NUM _NUM . firstDigit . addChild ( minuteFirstDigit ) ; } else { We ' ll need to use the AM / PM node a lot . Set up AM and PM to respond to _STR . Node ampm = new Node ( getAmOrPmKeyCode ( AM ) , getAmOrPmKeyCode ( PM ) ) ; The first hour digit may be _NUM . Node firstDigit = new Node ( k _NUM ) ; mLegalTimesTree . addChild ( firstDigit ) ; We ' ll allow quick input of on - the - hour times . E . g . _NUM pm . firstDigit . addChild ( ampm ) ; When the first digit is _NUM , the second digit may be _NUM - _NUM . Node secondDigit = new Node ( k _NUM , k _NUM , k _NUM ) ; firstDigit . addChild ( secondDigit ) ; Also for quick input of on - the - hour times . E . g . _NUM _NUM pm , _NUM _NUM am . secondDigit . addChild ( ampm ) ; When the first digit is _NUM , and the second digit is _NUM - _NUM , the third digit may be _NUM - _NUM . Node thirdDigit = new Node ( k _NUM , k _NUM , k _NUM , k _NUM , k _NUM , k _NUM ) ; secondDigit . addChild ( thirdDigit ) ; The time may be finished now . E . g . _NUM : _NUM _NUM pm , _NUM : _NUM _NUM am . thirdDigit . addChild ( ampm ) ; When the first digit is _NUM , the second digit is _NUM - _NUM , and the third digit is _NUM - _NUM , the fourth digit may be _NUM - _NUM . Node fourthDigit = new Node ( k _NUM , k _NUM , k _NUM , k _NUM , k _NUM , k _NUM , k _NUM , k _NUM , k _NUM , k _NUM ) ; thirdDigit . addChild ( fourthDigit ) ; The time must be finished now . E . g . _NUM _NUM : _NUM _NUM am , _NUM _NUM : _NUM _NUM pm . fourthDigit . addChild ( ampm ) ; When the first digit is _NUM , and the second digit is _NUM - _NUM , the third digit may be _NUM - _NUM . thirdDigit = new Node ( k _NUM , k _NUM , k _NUM , k _NUM ) ; secondDigit . addChild ( thirdDigit ) ; The time must be finished now . E . g . _NUM : _NUM _NUM am , _NUM : _NUM _NUM pm . thirdDigit . addChild ( ampm ) ; When the first digit is _NUM , the second digit may be _NUM - _NUM . secondDigit = new Node ( k _NUM , k _NUM , k _NUM ) ; firstDigit . addChild ( secondDigit ) ; When the first digit is _NUM , and the second digit is _NUM - _NUM , the third digit may be _NUM - _NUM . thirdDigit = new Node ( k _NUM , k _NUM , k _NUM , k _NUM , k _NUM , k _NUM , k _NUM , k _NUM , k _NUM , k _NUM ) ; secondDigit . addChild ( thirdDigit ) ; The time must be finished now . E . g . _NUM : _NUM _NUM am , _NUM : _NUM _NUM pm . thirdDigit . addChild ( ampm ) ; The hour digit may be _NUM - _NUM . firstDigit = new Node ( k _NUM , k _NUM , k _NUM , k _NUM , k _NUM , k _NUM , k _NUM , k _NUM ) ; mLegalTimesTree . addChild ( firstDigit ) ; We ' ll allow quick input of on - the - hour - times . E . g . _NUM am , _NUM pm . firstDigit . addChild ( ampm ) ; When the first digit is _NUM - _NUM , the second digit may be _NUM - _NUM . secondDigit = new Node ( k _NUM , k _NUM , k _NUM , k _NUM , k _NUM , k _NUM ) ; firstDigit . addChild ( secondDigit ) ; When the first digit is _NUM - _NUM , and the second digit is _NUM - _NUM , the third digit may be _NUM - _NUM . thirdDigit = new Node ( k _NUM , k _NUM , k _NUM , k _NUM , k _NUM , k _NUM , k _NUM , k _NUM , k _NUM , k _NUM ) ; secondDigit . addChild ( thirdDigit ) ; The time must be finished now . E . g . _NUM : _NUM _NUM am , _NUM : _NUM _NUM pm . thirdDigit . addChild ( ampm ) ; } } 
6936	boolean isDisplayAdded ( int displayId ) { return getActivityDisplayOrCreateLocked ( displayId ) ! = null ; } 
6937	public Rating createFromParcel ( Parcel p ) { return new Rating ( p . readInt ( ) , p . readFloat ( ) ) ; } 
6938	public < A extends Writable > A getAggregatedValueIntercept ( String name ) { A retVal = super . < A > getAggregatedValue ( name ) ; commonVertexMasterInterceptionUtil . addAggregatedValueIfNotExists ( name , retVal ) ; return retVal ; } 
6939	public Set < K > keySet ( ) { return getCollection ( ) . getKeySet ( ) ; } 
6940	public void writeExif ( Bitmap bmap , String exifOutFileName ) throws FileNotFoundException , IOException { if ( bmap = = null | | exifOutFileName = = null ) { throw new IllegalArgumentException ( NULL _ ARGUMENT _ STRING ) ; } OutputStream s = null ; try { s = getExifWriterStream ( exifOutFileName ) ; bmap . compress ( Bitmap . CompressFormat . JPEG , _NUM _NUM , s ) ; s . flush ( ) ; } catch ( IOException e ) { closeSilently ( s ) ; throw e ; } s . close ( ) ; } 
6941	public void updateCursor ( View view , int left , int top , int right , int bottom ) { checkFocus ( ) ; synchronized ( mH ) { if ( ( mServedView ! = view & & ( mServedView = = null | | ! mServedView . checkInputConnectionProxy ( view ) ) ) | | mCurrentTextBoxAttribute = = null | | mCurMethod = = null ) { return ; } mTmpCursorRect . set ( left , top , right , bottom ) ; if ( ! mCursorRect . equals ( mTmpCursorRect ) ) { if ( DEBUG ) Log . d ( TAG , _STR + mCurId , e ) ; } } } } 
6942	private void fetchStats ( NetworkTemplate template ) { INetworkStatsSession session = null ; try { mStatsService . forceUpdate ( ) ; session = mStatsService . openSession ( ) ; final NetworkStats stats = session . getSummaryForAllUid ( template , Long . MIN _ VALUE , Long . MAX _ VALUE , false ) ; reportStats ( stats ) ; } catch ( RemoteException e ) { Log . w ( LOG _ TAG , _STR ) ; } finally { TrafficStats . closeQuietly ( session ) ; } } 
6943	public void testMetadataHandlerCacheLimit ( ) { Assume . assumeTrue ( _STR ) ; final RelMetadataProvider metadataProvider = rel . getCluster ( ) . getMetadataProvider ( ) ; final RelOptPlanner planner = rel . getCluster ( ) . getPlanner ( ) ; for ( int i = _NUM ; i < iterationCount ; i + + ) { RelMetadataQuery . THREAD _ PROVIDERS . set ( JaninoRelMetadataProvider . of ( new CachingRelMetadataProvider ( metadataProvider , planner ) ) ) ; final RelMetadataQuery mq = RelMetadataQuery . instance ( ) ; final Double result = mq . getRowCount ( rel ) ; assertThat ( result , within ( _NUM _NUM d , _NUM . _NUM d ) ) ; } } 
6944	private JournalSegment < E > loadMappedSegment ( long segmentId ) { File file = JournalSegmentFile . createSegmentFile ( name , directory , segmentId ) ; Buffer buffer = MappedBuffer . allocate ( file , Math . min ( DEFAULT _ BUFFER _ SIZE , maxSegmentSize ) , Integer . MAX _ VALUE ) ; JournalSegmentDescriptor descriptor = new JournalSegmentDescriptor ( buffer ) ; JournalSegment < E > segment = newSegment ( new JournalSegmentFile ( file ) , descriptor ) ; log . debug ( _STR , descriptor . id ( ) , file . getName ( ) ) ; return segment ; } 
6945	public void should _ init _ policy _ with _ up _ contact _ points ( ) throws Exception { HistoryPolicy policy = new HistoryPolicy ( new RoundRobinPolicy ( ) ) ; Cluster cluster = register ( Cluster . builder ( ) . addContactPoints ( getContactPoints ( ) ) . withPort ( ccm ( ) . getBinaryPort ( ) ) . withLoadBalancingPolicy ( policy ) . build ( ) ) ; try { cluster . init ( ) ; assertThat ( policy . history ) . containsOnly ( entry ( INIT , TestUtils . findHost ( cluster , _NUM ) ) , entry ( INIT , TestUtils . findHost ( cluster , _NUM ) ) ) ; } finally { cluster . close ( ) ; } } 
6946	public void testGetFormattedCellValueHSSFCell ( ) { Valid date formats - - cell values should be date formatted & not _STR ) ; } 
6947	public static org . apache . xmlbeans . xml . stream . XMLInputStream newValidatingXMLInputStream ( org . apache . xmlbeans . xml . stream . XMLInputStream xis , org . apache . xmlbeans . XmlOptions options ) throws org . apache . xmlbeans . XmlException , org . apache . xmlbeans . xml . stream . XMLStreamException { return XmlBeans . getContextTypeLoader ( ) . newValidatingXMLInputStream ( xis , type , options ) ; } 
6948	public FlatDataList toFlatDataList ( ) { Collection < Object > values = internalData . values ( ) ; List < Object > list ; if ( values instanceof List < ? > ) { list = ( List < Object > ) values ; } else { list = new ArrayList ( values ) ; } return new FlatDataList ( list ) ; } 
6949	public BoundStatement setRoutingKey ( ByteBuffer . . . routingKeyComponents ) { this . routingKey = SimpleStatement . compose ( routingKeyComponents ) ; return this ; } 
6950	public void queryBinary ( ) throws IOException { if ( out = = null ) return ; session . execute ( _STR + retr + ' , ' + retr ) ; assertArrayEquals ( concat ( tmp , token ( Prop . NL ) , tmp ) , out . next ( ) ) ; check query execution session . query ( retr + ' , ' + retr ) . execute ( ) ; assertArrayEquals ( concat ( tmp , token ( Prop . NL ) , tmp ) , out . next ( ) ) ; check iterator final Query q = session . query ( retr + ' , ' + retr ) ; q . next ( ) ; assertArrayEquals ( tmp , out . next ( ) ) ; q . next ( ) ; assertArrayEquals ( tmp , out . next ( ) ) ; assertNull ( q . next ( ) ) ; } 
6951	public String getServerLink ( CmsObject cms , String resourceName ) { String result = substituteLinkForUnknownTarget ( cms , resourceName ) ; return appendServerPrefix ( cms , result , resourceName ) ; } 
6952	public void addTimer ( TimedOpTag timedOpTag ) { if ( isActive ( ) ) { TraceTag tag = acquire ( ) ; if ( tag . getOpCount ( ) > = flushAtOpCount ) { traceTagReporter . report ( tag ) ; tag . removeOps ( ) ; } tag . add ( timedOpTag ) ; if TraceTag # metered , send to meter by tag name } else { if ( reportUnattached ) { traceTagReporter . reportUnattached ( timedOpTag ) ; } } } 
6953	public TableState setTableStateIfInStates ( TableName tableName , TableState . State newState , TableState . State . . . states ) throws IOException { lock . writeLock ( ) . lock ( ) ; try { TableState currentState = readMetaState ( tableName ) ; if ( currentState = = null ) { throw new TableNotFoundException ( tableName ) ; } if ( currentState . inStates ( states ) ) { updateMetaState ( tableName , newState ) ; return null ; } else { return currentState ; } } finally { lock . writeLock ( ) . unlock ( ) ; } } 
6954	public Where where ( Clause clause ) { return where . and ( clause ) ; } 
6955	public void framePoints ( List < double [ ] > points ) { double topMost = - Integer . MAX _ VALUE ; double bottomMost = Integer . MAX _ VALUE ; double leftMost = Integer . MAX _ VALUE ; double rightMost = - Integer . MAX _ VALUE ; for ( double [ ] coordinate : points ) { double x = coordinate [ _NUM ] ; double y = coordinate [ _NUM ] ; if ( positionManager . contains ( x , y ) ) { topMost = Math . max ( topMost , x ) ; bottomMost = Math . min ( bottomMost , x ) ; leftMost = Math . min ( leftMost , y ) ; rightMost = Math . max ( rightMost , y ) ; } } Point topRight = translate ( topMost , rightMost ) ; Point bottomLeft = translate ( bottomMost , leftMost ) ; int width = bottomLeft . x - topRight . x ; int height = bottomLeft . y - topRight . y ; double scaleX = Math . abs ( getWidth ( ) / ( double ) width ) ; double scaleY = Math . abs ( getHeight ( ) / ( double ) height ) ; double destinationScale = Math . min ( scaleX , scaleY ) ; double middleX = ( rightMost + leftMost ) * _NUM . _NUM f ; double middleY = ( topMost + bottomMost ) * _NUM . _NUM f ; moveToAndCenter ( middleY , middleX ) ; setScaleFromCenter ( destinationScale ) ; } 
6956	public void testMain ( ) throws Exception { SecurityManager securityManager = System . getSecurityManager ( ) ; final ByteArrayOutputStream bytes = new ByteArrayOutputStream ( ) ; final PrintStream out = new PrintStream ( bytes ) ; final PrintStream oldOut = System . out ; System . setErr ( out ) ; ExitUtil . disableSystemExit ( ) ; try { String [ ] argv = new String [ _NUM ] ; DebugGridmix . main ( argv ) ; } catch ( ExitUtil . ExitException e ) { assertEquals ( _STR ) ) ; } 
6957	public static String createXpath ( String path , int index ) { if ( path . indexOf ( ' / ' ) > - _NUM ) { this is a complex path over more then _NUM node StringBuffer result = new StringBuffer ( path . length ( ) + _NUM _NUM ) ; split the path into sub elements List < String > elements = CmsStringUtil . splitAsList ( path , ' / ' ) ; int end = elements . size ( ) - _NUM ; for ( int i = _NUM ; i < = end ; i + + ) { append [ i ] to path element if required result . append ( createXpathElementCheck ( elements . get ( i ) , ( i = = end ) ? index : _NUM ) ) ; if ( i < end ) { append path delimiter if not final path element result . append ( ' / ' ) ; } } return result . toString ( ) ; } this path has only _NUM node , append [ index ] if required return createXpathElementCheck ( path , index ) ; } 
6958	public static DoubleVector dchisq ( double x , DoubleVector ncp ) { int n = ncp . size ( ) ; DoubleVector d = new DoubleVector ( n ) ; double xh = Math . sqrt ( x ) ; double mean ; for ( int i = _NUM ; i < n ; i + + ) { mean = Math . sqrt ( ncp . get ( i ) ) ; if ( ncp . get ( i ) = = _NUM . _NUM ) d . set ( i , dchisq ( x ) ) ; else d . set ( i , ( dnorm ( xh - mean ) + dnorm ( - xh - mean ) ) / ( _NUM * xh ) ) ; } return d ; } 
6959	public long getStride ( ) { if ( mByteBufferStride = = - _NUM ) { getByteBuffer ( ) ; } return mByteBufferStride ; } 
6960	 @ Nullable @ VisibleForTestingState waitUntilFinish ( Duration duration , @ Nullable MonitoringUtil . JobMessagesHandler messageHandler , Sleeper sleeper , NanoClock nanoClock , MonitoringUtil monitor ) throws IOException , InterruptedException { BackOff backoff ; if ( ! duration . isLongerThan ( Duration . ZERO ) ) { backoff = BackOffAdapter . toGcpBackOff ( MESSAGES _ BACKOFF _ FACTORY . backoff ( ) ) ; } else { backoff = BackOffAdapter . toGcpBackOff ( MESSAGES _ BACKOFF _ FACTORY . withMaxCumulativeBackoff ( duration ) . backoff ( ) ) ; } This function tracks the cumulative time from the * first request * to enforce the wall - clock limit . Any backoff instance could , at best , track the the time since the first attempt at a given request . Thus , we need to track the cumulative time ourselves . long startNanos = nanoClock . nanoTime ( ) ; State state ; do { Get the state of the job before listing messages . This ensures we always fetch job messages after the job finishes to ensure we have all them . state = getStateWithRetries ( BackOffAdapter . toGcpBackOff ( STATUS _ BACKOFF _ FACTORY . withMaxRetries ( _NUM ) . backoff ( ) ) , sleeper ) ; boolean hasError = state = = State . UNKNOWN ; if ( messageHandler ! = null & & ! hasError ) { Process all the job messages that have accumulated so far . try { List < JobMessage > allMessages = monitor . getJobMessages ( jobId , lastTimestamp ) ; if ( ! allMessages . isEmpty ( ) ) { lastTimestamp = fromCloudTime ( allMessages . get ( allMessages . size ( ) - _NUM ) . getTime ( ) ) . getMillis ( ) ; messageHandler . process ( allMessages ) ; } } catch ( GoogleJsonResponseException | SocketTimeoutException e ) { hasError = true ; LOG . warn ( _STR , state ) ; Timed out . return null ; } 
6961	public static void compareResultSetWithPattern ( ResultSet resultSet , Pattern pattern ) throws Exception { if ( ! resultSet . next ( ) ) { fail ( _STR ) ; } } 
6962	public float getCurrVelocity ( ) { return mVelocity - mDeceleration * timePassed ( ) / _NUM _NUM _NUM _NUM . _NUM f ; } 
6963	public final boolean hasMedia ( ) { return mediaComponents ! = null & & mediaComponents . size ( ) > _NUM ; } 
6964	private void updateAll ( CmsClientSitemapEntry entry ) { CmsSitemapTreeItem item = getTreeItem ( entry . getId ( ) ) ; if ( item ! = null ) { item . updateEntry ( entry ) ; item . updateSitePath ( entry . getSitePath ( ) ) ; for ( CmsClientSitemapEntry child : entry . getSubEntries ( ) ) { updateAll ( child ) ; } } } 
6965	protected Event grantServiceTicket ( final RequestContext context ) { final String ticketGrantingTicketId = WebUtils . getTicketGrantingTicketId ( context ) ; final Credential credential = getCredentialFromContext ( context ) ; try { final Service service = WebUtils . getService ( context ) ; final Authentication authn = ticketRegistrySupport . getAuthenticationFrom ( ticketGrantingTicketId ) ; final RegisteredService registeredService = this . servicesManager . findServiceBy ( service ) ; if ( authn ! = null & & registeredService ! = null ) { LOGGER . debug ( _STR , registeredService , authn . getPrincipal ( ) ) ; final AuditableContext audit = AuditableContext . builder ( ) . service ( service ) . authentication ( authn ) . registeredService ( registeredService ) . retrievePrincipalAttributesFromReleasePolicy ( Boolean . TRUE ) . build ( ) ; final AuditableExecutionResult accessResult = this . registeredServiceAccessStrategyEnforcer . execute ( audit ) ; accessResult . throwExceptionIfNeeded ( ) ; } final AuthenticationResult authenticationResult = this . authenticationSystemSupport . handleAndFinalizeSingleAuthenticationTransaction ( service , credential ) ; final ServiceTicket serviceTicketId = this . centralAuthenticationService . grantServiceTicket ( ticketGrantingTicketId , service , authenticationResult ) ; WebUtils . putServiceTicketInRequestScope ( context , serviceTicketId ) ; WebUtils . putWarnCookieIfRequestParameterPresent ( this . warnCookieGenerator , context ) ; return newEvent ( CasWebflowConstants . TRANSITION _ ID _ WARN ) ; } catch ( final AuthenticationException | AbstractTicketException e ) { return newEvent ( CasWebflowConstants . TRANSITION _ ID _ AUTHENTICATION _ FAILURE , e ) ; } } 
6966	private void publish ( List < MapEvent < String , byte [ ] > > events ) { listeners . values ( ) . forEach ( session - > { session . publish ( CHANGE , serializer ( ) : : encode , events ) ; } ) ; } 
6967	public void setClassName ( CharSequence className ) { enforceNotSealed ( ) ; mClassName = className ; } 
6968	private void animateProperty ( int constantName , float toValue ) { float fromValue = getValue ( constantName ) ; float deltaValue = toValue - fromValue ; animatePropertyBy ( constantName , fromValue , deltaValue ) ; } 
6969	public static IPartitioner newPartitioner ( Descriptor desc ) throws IOException { EnumSet < MetadataType > types = EnumSet . of ( MetadataType . VALIDATION , MetadataType . HEADER ) ; Map < MetadataType , MetadataComponent > sstableMetadata = desc . getMetadataSerializer ( ) . deserialize ( desc , types ) ; ValidationMetadata validationMetadata = ( ValidationMetadata ) sstableMetadata . get ( MetadataType . VALIDATION ) ; SerializationHeader . Component header = ( SerializationHeader . Component ) sstableMetadata . get ( MetadataType . HEADER ) ; return newPartitioner ( validationMetadata . partitioner , Optional . of ( header . getKeyType ( ) ) ) ; } 
6970	public static H _NUM ODrm exec ( H _NUM ODrm drmA , H _NUM ODrm drmB ) { Frame fra = drmA . frame ; Vec keysa = drmA . keys ; Frame frb = drmB . frame ; Vec keysb = drmB . keys ; If A and B are similarly partitioned , . . if ( fra . anyVec ( ) . group ( ) = = frb . anyVec ( ) . group ( ) ) { . . then , do a light weight zip ( ) return zip ( fra , keysa , frb , keysb ) ; } else { . . else , do a heavy weight join ( ) which involves moving data over the wire return join ( fra , keysa , frb , keysb ) ; } } 
6971	public CmsSitemapTreeItem getTreeItem ( String path ) { CmsSitemapData data = m _ controller . getData ( ) ; CmsClientSitemapEntry root = data . getRoot ( ) ; String rootSitePath = root . getSitePath ( ) ; String remainingPath = path . substring ( rootSitePath . length ( ) ) ; CmsSitemapTreeItem result = getRootItem ( ) ; String [ ] names = CmsStringUtil . splitAsArray ( remainingPath , _STR ) ; for ( String name : names ) { if ( CmsStringUtil . isEmptyOrWhitespaceOnly ( name ) ) { continue ; } result = ( CmsSitemapTreeItem ) result . getChild ( name ) ; if ( result = = null ) { return null ; } } return result ; } 
6972	void poll ( ) { try { final ConsumerRecords < byte [ ] , byte [ ] > records = kafkaConsumer . poll ( _NUM _NUM ) ; lastPollEmpty = records . count ( ) = = _NUM ; processRecords ( records ) ; } catch ( final ProcessException pe ) { throw pe ; } catch ( final Throwable t ) { this . poison ( ) ; throw t ; } } 
6973	public IntStreamEx sorted ( Comparator < Integer > comparator ) { return new IntStreamEx ( stream ( ) . boxed ( ) . sorted ( comparator ) . mapToInt ( Integer : : intValue ) , context ) ; } 
6974	private long initializeStores ( CancelableProgressable reporter , MonitoredTask status ) throws IOException { Load in all the HStores . long maxSeqId = - _NUM ; initialized to - _NUM so that we pick up MemstoreTS from column families long maxMemstoreTS = - _NUM ; if ( htableDescriptor . getColumnFamilyCount ( ) ! = _NUM ) { initialize the thread pool for opening stores in parallel . ThreadPoolExecutor storeOpenerThreadPool = getStoreOpenAndCloseThreadPool ( _STR , e ) ; } } } } } return Math . max ( maxSeqId , maxMemstoreTS + _NUM ) ; } 
6975	public void write ( String s , int off , int len ) throws IOException { if ( writer ! = null ) { writer . write ( s , off , len ) ; } else { ensureOpen ( ) ; if ( len > = bufferSize - nextChar ) reAllocBuff ( len ) ; s . getChars ( off , off + len , cb , nextChar ) ; nextChar + = len ; } } 
6976	public PGPPublicKey getPublicKey ( long keyID ) { PGPSecretKey key = getSecretKey ( keyID ) ; if ( key ! = null ) { return key . getPublicKey ( ) ; } for ( int i = _NUM ; i ! = extraPubKeys . size ( ) ; i + + ) { PGPPublicKey k = ( PGPPublicKey ) keys . get ( i ) ; if ( keyID = = k . getKeyID ( ) ) { return k ; } } return null ; } 
6977	public synchronized StateFlag nextMatch ( LPInterpreter interpreter ) { while ( resultIndex < generator . results . size ( ) ) { Triple result = ( Triple ) generator . results . get ( resultIndex + + ) ; Check if we have finished with this generator if ( resultIndex > = generator . results . size ( ) & & generator . isComplete ( ) ) { generator . removeConsumer ( this ) ; } if ( bindResult ( result , interpreter ) ) { return StateFlag . SATISFIED ; } } if ( generator . isComplete ( ) ) { setFinished ( ) ; generator . removeConsumer ( this ) ; return StateFlag . FAIL ; } else { return StateFlag . SUSPEND ; } } 
6978	public static int indexOfSubList ( List < ? > list , List < ? > sublist ) { int size = list . size ( ) ; int sublistSize = sublist . size ( ) ; if ( sublistSize > size ) { return - _NUM ; } if ( sublistSize = = _NUM ) { return _NUM ; } find the first element of sublist in the list to get a head start Object firstObj = sublist . get ( _NUM ) ; int index = list . indexOf ( firstObj ) ; if ( index = = - _NUM ) { return - _NUM ; } while ( index < size & & ( size - index > = sublistSize ) ) { ListIterator < ? > listIt = list . listIterator ( index ) ; if ( ( firstObj = = null ) ? listIt . next ( ) = = null : firstObj . equals ( listIt . next ( ) ) ) { iterate through the elements in sublist to see if they are included in the same order in the list ListIterator < ? > sublistIt = sublist . listIterator ( _NUM ) ; boolean difFound = false ; while ( sublistIt . hasNext ( ) ) { Object element = sublistIt . next ( ) ; if ( ! listIt . hasNext ( ) ) { return - _NUM ; } if ( ( element = = null ) ? listIt . next ( ) ! = null : ! element . equals ( listIt . next ( ) ) ) { difFound = true ; break ; } } starting from index . if ( ! difFound ) { return index ; } } This was not the sequence we were looking for , continue search for the firstObj in main list at the position after index . index + + ; } return - _NUM ; } 
6979	public void initialize ( CmsObject cms ) { initialize static export RFS path ( relative to web application ) m _ staticExportPath = normalizeExportPath ( m _ staticExportPathConfigured ) ; m _ staticExportWorkPath = normalizeExportPath ( getExportWorkPathForConfiguration ( ) ) ; if ( m _ staticExportPath . equals ( OpenCms . getSystemInfo ( ) . getWebApplicationRfsPath ( ) ) ) { throw new CmsIllegalArgumentException ( Messages . get ( ) . container ( Messages . ERR _ INVALID _ EXPORT _ PATH _ _NUM ) ) ; } initialize prefix variables m _ rfsPrefix = normalizeRfsPrefix ( m _ rfsPrefixConfigured ) ; Iterator < CmsStaticExportRfsRule > itRfsRules = m _ rfsRules . iterator ( ) ; while ( itRfsRules . hasNext ( ) ) { CmsStaticExportRfsRule rule = itRfsRules . next ( ) ; try { rule . setExportPath ( normalizeExportPath ( rule . getExportPathConfigured ( ) ) ) ; } catch ( CmsIllegalArgumentException e ) { CmsLog . INIT . warn ( e . getMessageContainer ( ) ) ; rule . setExportPath ( m _ staticExportPath ) ; } try { rule . setExportWorkPath ( normalizeExportPath ( rule . getExportWorkPathConfigured ( ) ) ) ; } catch ( CmsIllegalArgumentException e ) { CmsLog . INIT . warn ( e . getMessageContainer ( ) ) ; rule . setExportWorkPath ( m _ staticExportWorkPath ) ; } rule . setRfsPrefix ( normalizeRfsPrefix ( rule . getRfsPrefixConfigured ( ) ) ) ; } m _ vfsPrefix = insertContextStrings ( m _ vfsPrefixConfigured ) ; m _ vfsPrefix = CmsFileUtil . normalizePath ( m _ vfsPrefix , ' / ' ) ; if ( CmsResource . isFolder ( m _ vfsPrefix ) ) { ensure prefix does NOT end with a folder ' / ' m _ vfsPrefix = m _ vfsPrefix . substring ( _NUM , m _ vfsPrefix . length ( ) - _NUM ) ; } if ( CmsLog . INIT . isDebugEnabled ( ) ) { if ( cms ! = null ) { CmsLog . INIT . debug ( Messages . get ( ) . getBundle ( ) . key ( Messages . INIT _ SE _ MANAGER _ CREATED _ _NUM , cms ) ) ; } else { CmsLog . INIT . debug ( Messages . get ( ) . getBundle ( ) . key ( Messages . INIT _ SE _ MANAGER _ CREATED _ _NUM ) ) ; } } Map < String , String > lruMap _NUM = CmsCollectionsGenericWrapper . createLRUMap ( _NUM _NUM _NUM _NUM ) ; m _ cacheOnlineLinks = Collections . synchronizedMap ( lruMap _NUM ) ; map must be of type _STR ) ) ; } CmsLog . INIT . info ( Messages . get ( ) . getBundle ( ) . key ( Messages . INIT _ EXPORT _ VFS _ PREFIX _ _NUM , getVfsPrefix ( ) ) ) ; CmsLog . INIT . info ( Messages . get ( ) . getBundle ( ) . key ( Messages . INIT _ EXPORT _ EXPORT _ HANDLER _ _NUM , getHandler ( ) . getClass ( ) . getName ( ) ) ) ; CmsLog . INIT . info ( Messages . get ( ) . getBundle ( ) . key ( Messages . INIT _ EXPORT _ URL _ _NUM , getExportUrl ( ) ) ) ; CmsLog . INIT . info ( Messages . get ( ) . getBundle ( ) . key ( Messages . INIT _ EXPORT _ OPTIMIZATION _ _NUM , getPlainExportOptimization ( ) ) ) ; CmsLog . INIT . info ( Messages . get ( ) . getBundle ( ) . key ( Messages . INIT _ EXPORT _ TESTRESOURCE _ _NUM , getTestResource ( ) ) ) ; CmsLog . INIT . info ( Messages . get ( ) . getBundle ( ) . key ( Messages . INIT _ LINKSUBSTITUTION _ HANDLER _ _NUM , getLinkSubstitutionHandler ( ) . getClass ( ) . getName ( ) ) ) ; } else { CmsLog . INIT . info ( Messages . get ( ) . getBundle ( ) . key ( Messages . INIT _ STATIC _ EXPORT _ DISABLED _ _NUM ) ) ; } } } 
6980	public void fields ( ) { Random rand = new Random ( ) ; long blockId = rand . nextLong ( ) ; long blockSize = rand . nextLong ( ) ; GetWorkerOptions options = GetWorkerOptions . defaults ( ) ; options . setBlockId ( blockId ) ; options . setBlockSize ( blockSize ) ; assertEquals ( blockId , options . getBlockId ( ) ) ; assertEquals ( blockSize , options . getBlockSize ( ) ) ; } 
6981	public void testSwitchAlgorithms ( ) throws IOException { FileSystem fsWithCrc _NUM _NUM = createFsWithChecksum ( _STR ) ; appendWithTwoFs ( p , fsWithCrc _NUM _NUM , fsWithCrc _NUM _NUM C ) ; Regardless of which FS is used to read , it should pick up the on - disk checksum ! AppendTestUtil . check ( fsWithCrc _NUM _NUM C , p , SEGMENT _ LENGTH * _NUM ) ; AppendTestUtil . check ( fsWithCrc _NUM _NUM , p , SEGMENT _ LENGTH * _NUM ) ; } 
6982	private int putSymbol ( String symbolName ) { if ( isReadOnly ) { throw new ReadOnlyValueException ( SymbolTable . class ) ; } if ( mySymbolsCount = = mySymbolNames . length ) { int newlen = mySymbolsCount * _NUM ; if ( newlen < DEFAULT _ CAPACITY ) { newlen = DEFAULT _ CAPACITY ; } String [ ] temp = new String [ newlen ] ; System . arraycopy ( mySymbolNames , _NUM , temp , _NUM , mySymbolsCount ) ; mySymbolNames = temp ; } int sid = mySymbolsCount + myFirstLocalSid ; assert sid = = getMaxId ( ) + _NUM ; putToMapIfNotThere ( mySymbolsMap , symbolName , sid ) ; mySymbolNames [ mySymbolsCount ] = symbolName ; mySymbolsCount + + ; if ( myImage ! = null ) { recordLocalSymbolInIonRep ( myImage , symbolName , sid ) ; } return sid ; } 
6983	public void protectSheet ( String password ) { protect objs & scenarios ( normal ) getProtectionBlock ( ) . protectSheet ( password , true , true ) ; } 
6984	protected JSONObject addBreadcrumbData ( final HttpServletRequest request ) throws JSONException { final JSONObject breadcrumbObjects = new JSONObject ( ) ; breadcrumbObjects . put ( _STR , breadcrumbList ) ; return breadcrumbObjects ; } 
6985	public synchronized boolean continueOperation ( boolean sendEmpty , boolean inStream ) throws IOException { if ( ! mGetOperation ) { if ( ! finalBitSet ) { if ( sendEmpty ) { sendReply ( ResponseCodes . OBEX _ HTTP _ CONTINUE ) ; return true ; } else { if ( ( mResponseSize > _NUM ) | | ( mPrivateOutput . size ( ) > _NUM ) ) { sendReply ( ResponseCodes . OBEX _ HTTP _ CONTINUE ) ; return true ; } else { return false ; } } } else { return false ; } } else { sendReply ( ResponseCodes . OBEX _ HTTP _ CONTINUE ) ; return true ; } } 
6986	public boolean draw ( Canvas c , Paint p ) { final boolean hasDisplayListCanvas = ! mForceSoftware & & c . isHardwareAccelerated ( ) & & c instanceof DisplayListCanvas ; if ( mHasDisplayListCanvas ! = hasDisplayListCanvas ) { mHasDisplayListCanvas = hasDisplayListCanvas ; if ( ! hasDisplayListCanvas ) { We ' ve switched from hardware to non - hardware mode . Panic . endHardwareAnimations ( ) ; } } if ( hasDisplayListCanvas ) { final DisplayListCanvas hw = ( DisplayListCanvas ) c ; startPendingAnimation ( hw , p ) ; if ( mHardwareAnimator ! = null ) { return drawHardware ( hw ) ; } } return drawSoftware ( c , p ) ; } 
6987	public static XmlGYear parse ( java . io . Reader r ) throws org . apache . xmlbeans . XmlException , java . io . IOException { return ( XmlGYear ) XmlBeans . getContextTypeLoader ( ) . parse ( r , type , null ) ; } 
6988	public static PageRange [ ] parsePageRanges ( CharSequence s , int maxPageNumber ) { ArrayList < PageRange > ranges = new ArrayList < > ( ) ; int pos = _NUM ; while ( pos < s . length ( ) ) { Pair < Integer , PageRange > retRange = readRange ( s , pos , maxPageNumber ) ; if ( retRange . second = = null ) { ranges . clear ( ) ; break ; } ranges . add ( retRange . second ) ; pos = retRange . first ; } return PageRangeUtils . normalize ( ranges . toArray ( new PageRange [ ranges . size ( ) ] ) ) ; } 
6989	public void accept ( CompositeRecordReader . JoinCollector i , K key ) throws IOException { vjoin . clear ( ) ; if ( _NUM = = cmp . compare ( key , khead ) ) { do { vjoin . add ( vhead ) ; } while ( next ( ) & & _NUM = = cmp . compare ( key , khead ) ) ; } i . add ( id , vjoin ) ; } 
6990	private boolean hover ( ) { if ( mHoverView = = null ) return false ; if ( getHoverStatus ( ) ! = HOVER _ STATUS . DISAPPEARED | | ! mPlayingAnimators . isEmpty ( ) ) return true ; removeView ( mBlurImage ) ; if ( enableBlurBackground ) addBlurImage ( ) ; if ( mHoverView . getParent ( ) ! = null ) { ( ( ViewGroup ) ( mHoverView . getParent ( ) ) ) . removeView ( mHoverView ) ; } addView ( mHoverView , getFullParentSizeLayoutParams ( ) ) ; mHoverView . getViewTreeObserver ( ) . addOnGlobalLayoutListener ( new ViewTreeObserver . OnGlobalLayoutListener ( ) { @ Override public void onGlobalLayout ( ) { startChildrenAppearAnimations ( ) ; startBlurImageAppearAnimator ( ) ; startHoverAppearAnimator ( ) ; if ( Build . VERSION . SDK _ INT > = _NUM _NUM ) mHoverView . getViewTreeObserver ( ) . removeOnGlobalLayoutListener ( this ) ; else mHoverView . getViewTreeObserver ( ) . removeGlobalOnLayoutListener ( this ) ; } } ) ; return true ; } 
6991	public static synchronized boolean canDexposed ( Context context ) { if ( ! DeviceCheck . isDeviceSupport ( context ) ) { return false ; } load dexposed lib for hook . return loadDexposedLib ( context ) ; } 
6992	public void addAuthor ( String author ) { XmpArray array = new XmpArray ( XmpArray . ORDERED ) ; array . add ( author ) ; setProperty ( CREATOR , array ) ; } 
6993	private void mergeServiceWithExplicitParent ( ServiceModule service , String parent , Map < String , StackModule > allStacks , Map < String , ServiceModule > commonServices , Map < String , ExtensionModule > extensions ) throws AmbariException { if ( isCommonServiceParent ( parent ) ) { LOG . info ( _STR ) ; } } 
6994	public V call ( ) throws Exception { Map < TransmittableThreadLocal < ? > , Object > copied = copiedRef . get ( ) ; if ( copied = = null | | releaseTtlValueReferenceAfterCall & & ! copiedRef . compareAndSet ( copied , null ) ) { throw new IllegalStateException ( _STR ) ; } Map < TransmittableThreadLocal < ? > , Object > backup = TransmittableThreadLocal . backupAndSetToCopied ( copied ) ; try { return callable . call ( ) ; } finally { TransmittableThreadLocal . restoreBackup ( backup ) ; } } 
6995	public static double calculateBigramPriorSmoothingProbability ( String x _NUM , String x _NUM , Collection < StringList > set , Double k ) { return ( count ( new StringList ( x _NUM , x _NUM ) , set ) + k * calculateUnigramMLProbability ( x _NUM , set ) ) / ( count ( new StringList ( x _NUM ) , set ) + k * set . size ( ) ) ; } 
6996	public boolean setInputFormat ( Instances instanceInfo ) throws Exception { super . setInputFormat ( instanceInfo ) ; m _ AttIndex . setUpper ( instanceInfo . numAttributes ( ) - _NUM ) ; if ( ! isNumeric ( ) & & ! isNominal ( ) ) { throw new UnsupportedAttributeTypeException ( _STR ) ; } m _ Values . setUpper ( instanceInfo . attribute ( m _ AttIndex . getIndex ( ) ) . numValues ( ) - _NUM ) ; if ( isNominal ( ) & & m _ ModifyHeader ) { copy before modifying instanceInfo = new Instances ( instanceInfo , _NUM ) ; Attribute oldAtt = instanceInfo . attribute ( m _ AttIndex . getIndex ( ) ) ; int [ ] selection = m _ Values . getSelection ( ) ; FastVector newVals = new FastVector ( ) ; for ( int i = _NUM ; i < selection . length ; i + + ) { newVals . addElement ( oldAtt . value ( selection [ i ] ) ) ; } instanceInfo . deleteAttributeAt ( m _ AttIndex . getIndex ( ) ) ; instanceInfo . insertAttributeAt ( new Attribute ( oldAtt . name ( ) , newVals ) , m _ AttIndex . getIndex ( ) ) ; m _ NominalMapping = new int [ oldAtt . numValues ( ) ] ; for ( int i = _NUM ; i < m _ NominalMapping . length ; i + + ) { boolean found = false ; for ( int j = _NUM ; j < selection . length ; j + + ) { if ( selection [ j ] = = i ) { m _ NominalMapping [ i ] = j ; found = true ; break ; } } if ( ! found ) { m _ NominalMapping [ i ] = - _NUM ; } } } setOutputFormat ( instanceInfo ) ; return true ; } 
6997	 @ SuppressWarnings ( _STR + e , e ) ; if ( attempt > ATTEMPT _ LIMIT ) { throw e ; } } } delete ( backupFile ) ; partNumber + + ; blockOffset = _NUM ; if ( ! closingUpload ) { if not the final upload , create a new output stream backupFile = newBackupFile ( ) ; backupStream = new BufferedOutputStream ( new FileOutputStream ( backupFile ) ) ; } } } 
6998	private byte [ ] loadSyntheticPasswordHandle ( int userId ) { return loadState ( SP _ HANDLE _ NAME , DEFAULT _ HANDLE , userId ) ; } 
6999	public static XmlNegativeInteger parse ( java . lang . String s ) throws org . apache . xmlbeans . XmlException { return ( XmlNegativeInteger ) XmlBeans . getContextTypeLoader ( ) . parse ( s , type , null ) ; } 
7000	public String [ ] getRsCoprocessors ( ) { return getRegionServerCoprocessors ( ) ; } 
